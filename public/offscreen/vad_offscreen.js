// ==UserScript==
// @name         Say, Pi
// @name:zh-CN   说，Pi 
// @namespace    http://www.saypi.ai/
// @version      1.7.0
// @description  Seamless speech-to-text enhancement for Pi, the conversational AI. Enjoy hands-free, high-accuracy conversations in any language.
// @description:zh-CN  为Pi聊天机器人提供无手操作的高精度语音转文字功能，支持多种语言。
// @author       Ross Cadogan
// @match        https://pi.ai/talk
// @inject-into  page
// @updateURL    https://app.saypi.ai/saypi.user.js
// @downloadURL  https://app.saypi.ai/saypi.user.js
// @license      MIT
// ==/UserScript==

/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@ricky0123/vad-web/dist/asset-path.js":
/*!************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/asset-path.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.baseAssetPath = void 0;
// nextjs@14 bundler may attempt to execute this during SSR and crash
const isWeb = typeof window !== "undefined" && typeof window.document !== "undefined";
const currentScript = isWeb
    ? window.document.currentScript
    : null;
let basePath = "/";
if (currentScript) {
    basePath = currentScript.src
        .replace(/#.*$/, "")
        .replace(/\?.*$/, "")
        .replace(/\/[^\/]+$/, "/");
}
exports.baseAssetPath = basePath;
//# sourceMappingURL=asset-path.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/default-model-fetcher.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/default-model-fetcher.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultModelFetcher = void 0;
const defaultModelFetcher = (path) => {
    return fetch(path).then((model) => model.arrayBuffer());
};
exports.defaultModelFetcher = defaultModelFetcher;
//# sourceMappingURL=default-model-fetcher.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/frame-processor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/frame-processor.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
Some of this code, together with the default options found in index.ts,
were taken (or took inspiration) from https://github.com/snakers4/silero-vad
*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FrameProcessor = exports.validateOptions = exports.defaultV5FrameProcessorOptions = exports.defaultLegacyFrameProcessorOptions = void 0;
const logging_1 = __webpack_require__(/*! ./logging */ "./node_modules/@ricky0123/vad-web/dist/logging.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/@ricky0123/vad-web/dist/messages.js");
const RECOMMENDED_FRAME_SAMPLES = [512, 1024, 1536];
exports.defaultLegacyFrameProcessorOptions = {
    positiveSpeechThreshold: 0.5,
    negativeSpeechThreshold: 0.5 - 0.15,
    preSpeechPadFrames: 1,
    redemptionFrames: 8,
    frameSamples: 1536,
    minSpeechFrames: 3,
    submitUserSpeechOnPause: false,
};
exports.defaultV5FrameProcessorOptions = {
    positiveSpeechThreshold: 0.5,
    negativeSpeechThreshold: 0.5 - 0.15,
    preSpeechPadFrames: 3,
    redemptionFrames: 24,
    frameSamples: 512,
    minSpeechFrames: 9,
    submitUserSpeechOnPause: false,
};
function validateOptions(options) {
    if (!RECOMMENDED_FRAME_SAMPLES.includes(options.frameSamples)) {
        logging_1.log.warn("You are using an unusual frame size");
    }
    if (options.positiveSpeechThreshold < 0 ||
        options.positiveSpeechThreshold > 1) {
        logging_1.log.error("positiveSpeechThreshold should be a number between 0 and 1");
    }
    if (options.negativeSpeechThreshold < 0 ||
        options.negativeSpeechThreshold > options.positiveSpeechThreshold) {
        logging_1.log.error("negativeSpeechThreshold should be between 0 and positiveSpeechThreshold");
    }
    if (options.preSpeechPadFrames < 0) {
        logging_1.log.error("preSpeechPadFrames should be positive");
    }
    if (options.redemptionFrames < 0) {
        logging_1.log.error("redemptionFrames should be positive");
    }
}
exports.validateOptions = validateOptions;
const concatArrays = (arrays) => {
    const sizes = arrays.reduce((out, next) => {
        out.push(out.at(-1) + next.length);
        return out;
    }, [0]);
    const outArray = new Float32Array(sizes.at(-1));
    arrays.forEach((arr, index) => {
        const place = sizes[index];
        outArray.set(arr, place);
    });
    return outArray;
};
class FrameProcessor {
    constructor(modelProcessFunc, modelResetFunc, options) {
        this.modelProcessFunc = modelProcessFunc;
        this.modelResetFunc = modelResetFunc;
        this.options = options;
        this.speaking = false;
        this.redemptionCounter = 0;
        this.speechFrameCount = 0;
        this.active = false;
        this.speechRealStartFired = false;
        this.reset = () => {
            this.speaking = false;
            this.speechRealStartFired = false;
            this.audioBuffer = [];
            this.modelResetFunc();
            this.redemptionCounter = 0;
            this.speechFrameCount = 0;
        };
        this.pause = (handleEvent) => {
            this.active = false;
            if (this.options.submitUserSpeechOnPause) {
                this.endSegment(handleEvent);
            }
            else {
                this.reset();
            }
        };
        this.resume = () => {
            this.active = true;
        };
        this.endSegment = (handleEvent) => {
            const audioBuffer = this.audioBuffer;
            this.audioBuffer = [];
            const speaking = this.speaking;
            this.reset();
            if (speaking) {
                const speechFrameCount = audioBuffer.reduce((acc, item) => {
                    return item.isSpeech ? (acc + 1) : acc;
                }, 0);
                if (speechFrameCount >= this.options.minSpeechFrames) {
                    const audio = concatArrays(audioBuffer.map((item) => item.frame));
                    handleEvent({ msg: messages_1.Message.SpeechEnd, audio });
                }
                else {
                    handleEvent({ msg: messages_1.Message.VADMisfire });
                }
            }
            return {};
        };
        this.process = async (frame, handleEvent) => {
            if (!this.active) {
                return;
            }
            const probs = await this.modelProcessFunc(frame);
            const isSpeech = probs.isSpeech >= this.options.positiveSpeechThreshold;
            handleEvent({ probs, msg: messages_1.Message.FrameProcessed, frame });
            this.audioBuffer.push({
                frame,
                isSpeech,
            });
            if (isSpeech) {
                this.speechFrameCount++;
                this.redemptionCounter = 0;
            }
            if (isSpeech && !this.speaking) {
                this.speaking = true;
                handleEvent({ msg: messages_1.Message.SpeechStart });
            }
            if (this.speaking &&
                this.speechFrameCount === this.options.minSpeechFrames &&
                !this.speechRealStartFired) {
                this.speechRealStartFired = true;
                handleEvent({ msg: messages_1.Message.SpeechRealStart });
            }
            if (probs.isSpeech < this.options.negativeSpeechThreshold &&
                this.speaking &&
                ++this.redemptionCounter >= this.options.redemptionFrames) {
                this.redemptionCounter = 0;
                this.speechFrameCount = 0;
                this.speaking = false;
                this.speechRealStartFired = false;
                const audioBuffer = this.audioBuffer;
                this.audioBuffer = [];
                const speechFrameCount = audioBuffer.reduce((acc, item) => {
                    return item.isSpeech ? (acc + 1) : acc;
                }, 0);
                if (speechFrameCount >= this.options.minSpeechFrames) {
                    const audio = concatArrays(audioBuffer.map((item) => item.frame));
                    handleEvent({ msg: messages_1.Message.SpeechEnd, audio });
                }
                else {
                    handleEvent({ msg: messages_1.Message.VADMisfire });
                }
            }
            if (!this.speaking) {
                while (this.audioBuffer.length > this.options.preSpeechPadFrames) {
                    this.audioBuffer.shift();
                }
                this.speechFrameCount = 0;
            }
        };
        this.audioBuffer = [];
        this.reset();
    }
}
exports.FrameProcessor = FrameProcessor;
//# sourceMappingURL=frame-processor.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDefaultRealTimeVADOptions = exports.MicVAD = exports.DEFAULT_MODEL = exports.AudioNodeVAD = exports.utils = exports.NonRealTimeVAD = exports.Message = exports.FrameProcessor = exports.defaultModelFetcher = exports.baseAssetPath = void 0;
var asset_path_1 = __webpack_require__(/*! ./asset-path */ "./node_modules/@ricky0123/vad-web/dist/asset-path.js");
Object.defineProperty(exports, "baseAssetPath", ({ enumerable: true, get: function () { return asset_path_1.baseAssetPath; } }));
var default_model_fetcher_1 = __webpack_require__(/*! ./default-model-fetcher */ "./node_modules/@ricky0123/vad-web/dist/default-model-fetcher.js");
Object.defineProperty(exports, "defaultModelFetcher", ({ enumerable: true, get: function () { return default_model_fetcher_1.defaultModelFetcher; } }));
var frame_processor_1 = __webpack_require__(/*! ./frame-processor */ "./node_modules/@ricky0123/vad-web/dist/frame-processor.js");
Object.defineProperty(exports, "FrameProcessor", ({ enumerable: true, get: function () { return frame_processor_1.FrameProcessor; } }));
var messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/@ricky0123/vad-web/dist/messages.js");
Object.defineProperty(exports, "Message", ({ enumerable: true, get: function () { return messages_1.Message; } }));
var non_real_time_vad_1 = __webpack_require__(/*! ./non-real-time-vad */ "./node_modules/@ricky0123/vad-web/dist/non-real-time-vad.js");
Object.defineProperty(exports, "NonRealTimeVAD", ({ enumerable: true, get: function () { return non_real_time_vad_1.NonRealTimeVAD; } }));
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@ricky0123/vad-web/dist/utils.js");
exports.utils = {
    audioFileToArray: utils_1.audioFileToArray,
    minFramesForTargetMS: utils_1.minFramesForTargetMS,
    arrayBufferToBase64: utils_1.arrayBufferToBase64,
    encodeWAV: utils_1.encodeWAV,
};
var real_time_vad_1 = __webpack_require__(/*! ./real-time-vad */ "./node_modules/@ricky0123/vad-web/dist/real-time-vad.js");
Object.defineProperty(exports, "AudioNodeVAD", ({ enumerable: true, get: function () { return real_time_vad_1.AudioNodeVAD; } }));
Object.defineProperty(exports, "DEFAULT_MODEL", ({ enumerable: true, get: function () { return real_time_vad_1.DEFAULT_MODEL; } }));
Object.defineProperty(exports, "MicVAD", ({ enumerable: true, get: function () { return real_time_vad_1.MicVAD; } }));
Object.defineProperty(exports, "getDefaultRealTimeVADOptions", ({ enumerable: true, get: function () { return real_time_vad_1.getDefaultRealTimeVADOptions; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/logging.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/logging.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.log = exports.LOG_PREFIX = void 0;
exports.LOG_PREFIX = "[VAD]";
const levels = ["error", "debug", "warn"];
function getLog(level) {
    return (...args) => {
        console[level](exports.LOG_PREFIX, ...args);
    };
}
const _log = levels.reduce((acc, level) => {
    acc[level] = getLog(level);
    return acc;
}, {});
exports.log = _log;
//# sourceMappingURL=logging.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/messages.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/messages.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Message = void 0;
var Message;
(function (Message) {
    Message["AudioFrame"] = "AUDIO_FRAME";
    Message["SpeechStart"] = "SPEECH_START";
    Message["VADMisfire"] = "VAD_MISFIRE";
    Message["SpeechEnd"] = "SPEECH_END";
    Message["SpeechStop"] = "SPEECH_STOP";
    Message["SpeechRealStart"] = "SPEECH_REAL_START";
    Message["FrameProcessed"] = "FRAME_PROCESSED";
})(Message || (exports.Message = Message = {}));
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/models/common.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/models/common.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/models/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/models/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SileroV5 = exports.SileroLegacy = void 0;
__exportStar(__webpack_require__(/*! ./common */ "./node_modules/@ricky0123/vad-web/dist/models/common.js"), exports);
var legacy_1 = __webpack_require__(/*! ./legacy */ "./node_modules/@ricky0123/vad-web/dist/models/legacy.js");
Object.defineProperty(exports, "SileroLegacy", ({ enumerable: true, get: function () { return legacy_1.SileroLegacy; } }));
var v5_1 = __webpack_require__(/*! ./v5 */ "./node_modules/@ricky0123/vad-web/dist/models/v5.js");
Object.defineProperty(exports, "SileroV5", ({ enumerable: true, get: function () { return v5_1.SileroV5; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/models/legacy.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/models/legacy.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SileroLegacy = void 0;
const logging_1 = __webpack_require__(/*! ../logging */ "./node_modules/@ricky0123/vad-web/dist/logging.js");
class SileroLegacy {
    constructor(ortInstance, _session, _h, _c, _sr) {
        this.ortInstance = ortInstance;
        this._session = _session;
        this._h = _h;
        this._c = _c;
        this._sr = _sr;
        this.reset_state = () => {
            const zeroes = Array(2 * 64).fill(0);
            this._h = new this.ortInstance.Tensor("float32", zeroes, [2, 1, 64]);
            this._c = new this.ortInstance.Tensor("float32", zeroes, [2, 1, 64]);
        };
        this.process = async (audioFrame) => {
            const t = new this.ortInstance.Tensor("float32", audioFrame, [
                1,
                audioFrame.length,
            ]);
            const inputs = {
                input: t,
                h: this._h,
                c: this._c,
                sr: this._sr,
            };
            const out = await this._session.run(inputs);
            this._h = out["hn"];
            this._c = out["cn"];
            const [isSpeech] = out["output"]?.data;
            const notSpeech = 1 - isSpeech;
            return { notSpeech, isSpeech };
        };
    }
}
exports.SileroLegacy = SileroLegacy;
_a = SileroLegacy;
SileroLegacy.new = async (ortInstance, modelFetcher) => {
    logging_1.log.debug("initializing vad");
    const modelArrayBuffer = await modelFetcher();
    const _session = await ortInstance.InferenceSession.create(modelArrayBuffer);
    // @ts-ignore
    const _sr = new ortInstance.Tensor("int64", [16000n]);
    const zeroes = Array(2 * 64).fill(0);
    const _h = new ortInstance.Tensor("float32", zeroes, [2, 1, 64]);
    const _c = new ortInstance.Tensor("float32", zeroes, [2, 1, 64]);
    logging_1.log.debug("vad is initialized");
    const model = new _a(ortInstance, _session, _h, _c, _sr);
    return model;
};
//# sourceMappingURL=legacy.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/models/v5.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/models/v5.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SileroV5 = void 0;
const logging_1 = __webpack_require__(/*! ../logging */ "./node_modules/@ricky0123/vad-web/dist/logging.js");
function getNewState(ortInstance) {
    const zeroes = Array(2 * 128).fill(0);
    return new ortInstance.Tensor("float32", zeroes, [2, 1, 128]);
}
class SileroV5 {
    constructor(_session, _state, _sr, ortInstance) {
        this._session = _session;
        this._state = _state;
        this._sr = _sr;
        this.ortInstance = ortInstance;
        this.reset_state = () => {
            this._state = getNewState(this.ortInstance);
        };
        this.process = async (audioFrame) => {
            const t = new this.ortInstance.Tensor("float32", audioFrame, [
                1,
                audioFrame.length,
            ]);
            const inputs = {
                input: t,
                state: this._state,
                sr: this._sr,
            };
            const out = await this._session.run(inputs);
            // @ts-ignore
            this._state = out["stateN"];
            // @ts-ignore
            const [isSpeech] = out["output"]?.data;
            const notSpeech = 1 - isSpeech;
            return { notSpeech, isSpeech };
        };
    }
}
exports.SileroV5 = SileroV5;
_a = SileroV5;
SileroV5.new = async (ortInstance, modelFetcher) => {
    logging_1.log.debug("Loading VAD...");
    const modelArrayBuffer = await modelFetcher();
    const _session = await ortInstance.InferenceSession.create(modelArrayBuffer);
    // @ts-ignore
    const _sr = new ortInstance.Tensor("int64", [16000n]);
    const _state = getNewState(ortInstance);
    logging_1.log.debug("...finished loading VAD");
    return new _a(_session, _state, _sr, ortInstance);
};
//# sourceMappingURL=v5.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/non-real-time-vad.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/non-real-time-vad.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NonRealTimeVAD = exports.defaultNonRealTimeVADOptions = void 0;
const ortInstance = __importStar(__webpack_require__(/*! onnxruntime-web */ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-web/dist/ort-web.min.js"));
const asset_path_1 = __webpack_require__(/*! ./asset-path */ "./node_modules/@ricky0123/vad-web/dist/asset-path.js");
const default_model_fetcher_1 = __webpack_require__(/*! ./default-model-fetcher */ "./node_modules/@ricky0123/vad-web/dist/default-model-fetcher.js");
const frame_processor_1 = __webpack_require__(/*! ./frame-processor */ "./node_modules/@ricky0123/vad-web/dist/frame-processor.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/@ricky0123/vad-web/dist/messages.js");
const models_1 = __webpack_require__(/*! ./models */ "./node_modules/@ricky0123/vad-web/dist/models/index.js");
const resampler_1 = __webpack_require__(/*! ./resampler */ "./node_modules/@ricky0123/vad-web/dist/resampler.js");
exports.defaultNonRealTimeVADOptions = {
    ...frame_processor_1.defaultLegacyFrameProcessorOptions,
    ortConfig: undefined,
    modelURL: asset_path_1.baseAssetPath + "silero_vad_legacy.onnx",
    modelFetcher: default_model_fetcher_1.defaultModelFetcher,
};
class NonRealTimeVAD {
    static async new(options = {}) {
        const fullOptions = {
            ...exports.defaultNonRealTimeVADOptions,
            ...options,
        };
        (0, frame_processor_1.validateOptions)(fullOptions);
        if (fullOptions.ortConfig !== undefined) {
            fullOptions.ortConfig(ortInstance);
        }
        const modelFetcher = () => fullOptions.modelFetcher(fullOptions.modelURL);
        const model = await models_1.SileroLegacy.new(ortInstance, modelFetcher);
        const frameProcessor = new frame_processor_1.FrameProcessor(model.process, model.reset_state, {
            frameSamples: fullOptions.frameSamples,
            positiveSpeechThreshold: fullOptions.positiveSpeechThreshold,
            negativeSpeechThreshold: fullOptions.negativeSpeechThreshold,
            redemptionFrames: fullOptions.redemptionFrames,
            preSpeechPadFrames: fullOptions.preSpeechPadFrames,
            minSpeechFrames: fullOptions.minSpeechFrames,
            submitUserSpeechOnPause: fullOptions.submitUserSpeechOnPause,
        });
        frameProcessor.resume();
        const vad = new this(modelFetcher, ortInstance, fullOptions, frameProcessor);
        return vad;
    }
    constructor(modelFetcher, ort, options, frameProcessor) {
        this.modelFetcher = modelFetcher;
        this.ort = ort;
        this.options = options;
        this.frameProcessor = frameProcessor;
    }
    async *run(inputAudio, sampleRate) {
        const resamplerOptions = {
            nativeSampleRate: sampleRate,
            targetSampleRate: 16000,
            targetFrameSize: this.options.frameSamples,
        };
        const resampler = new resampler_1.Resampler(resamplerOptions);
        let start = 0;
        let end = 0;
        let frameIndex = 0;
        let messageContainer = [];
        for await (const frame of resampler.stream(inputAudio)) {
            await this.frameProcessor.process(frame, (event) => {
                messageContainer.push(event);
            });
            for (const event of messageContainer) {
                switch (event.msg) {
                    case messages_1.Message.SpeechStart:
                        start = (frameIndex * this.options.frameSamples) / 16;
                        break;
                    case messages_1.Message.SpeechEnd:
                        end = ((frameIndex + 1) * this.options.frameSamples) / 16;
                        yield { audio: event.audio, start, end };
                        break;
                    default:
                        break;
                }
            }
            frameIndex++;
        }
        const { msg, audio } = this.frameProcessor.endSegment((event) => {
            messageContainer.push(event);
        });
        for (const event of messageContainer) {
            switch (event.msg) {
                case messages_1.Message.SpeechEnd:
                    yield {
                        audio: event.audio,
                        start,
                        end: (frameIndex * this.options.frameSamples) / 16,
                    };
            }
        }
    }
}
exports.NonRealTimeVAD = NonRealTimeVAD;
//# sourceMappingURL=non-real-time-vad.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/real-time-vad.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/real-time-vad.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AudioNodeVAD = exports.MicVAD = exports.getDefaultRealTimeVADOptions = exports.ort = exports.DEFAULT_MODEL = void 0;
const ortInstance = __importStar(__webpack_require__(/*! onnxruntime-web */ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-web/dist/ort-web.min.js"));
const default_model_fetcher_1 = __webpack_require__(/*! ./default-model-fetcher */ "./node_modules/@ricky0123/vad-web/dist/default-model-fetcher.js");
const frame_processor_1 = __webpack_require__(/*! ./frame-processor */ "./node_modules/@ricky0123/vad-web/dist/frame-processor.js");
const logging_1 = __webpack_require__(/*! ./logging */ "./node_modules/@ricky0123/vad-web/dist/logging.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/@ricky0123/vad-web/dist/messages.js");
const models_1 = __webpack_require__(/*! ./models */ "./node_modules/@ricky0123/vad-web/dist/models/index.js");
const resampler_1 = __webpack_require__(/*! ./resampler */ "./node_modules/@ricky0123/vad-web/dist/resampler.js");
exports.DEFAULT_MODEL = "legacy";
exports.ort = ortInstance;
const workletFile = "vad.worklet.bundle.min.js";
const sileroV5File = "silero_vad_v5.onnx";
const sileroLegacyFile = "silero_vad_legacy.onnx";
const getDefaultRealTimeVADOptions = (model) => {
    const frameProcessorOptions = model === "v5"
        ? frame_processor_1.defaultV5FrameProcessorOptions
        : frame_processor_1.defaultLegacyFrameProcessorOptions;
    return {
        ...frameProcessorOptions,
        onFrameProcessed: (probabilities, frame) => { },
        onVADMisfire: () => {
            logging_1.log.debug("VAD misfire");
        },
        onSpeechStart: () => {
            logging_1.log.debug("Detected speech start");
        },
        onSpeechEnd: () => {
            logging_1.log.debug("Detected speech end");
        },
        onSpeechRealStart: () => {
            logging_1.log.debug("Detected real speech start");
        },
        baseAssetPath: "https://cdn.jsdelivr.net/npm/@ricky0123/vad-web@latest/dist/",
        onnxWASMBasePath: "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/",
        stream: undefined,
        ortConfig: undefined,
        model: model,
        workletOptions: {},
    };
};
exports.getDefaultRealTimeVADOptions = getDefaultRealTimeVADOptions;
class MicVAD {
    static async new(options = {}) {
        const fullOptions = {
            ...(0, exports.getDefaultRealTimeVADOptions)(options.model ?? exports.DEFAULT_MODEL),
            ...options,
        };
        (0, frame_processor_1.validateOptions)(fullOptions);
        let stream;
        if (fullOptions.stream === undefined)
            stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    ...fullOptions.additionalAudioConstraints,
                    channelCount: 1,
                    echoCancellation: true,
                    autoGainControl: true,
                    noiseSuppression: true,
                },
            });
        else
            stream = fullOptions.stream;
        const audioContext = new AudioContext();
        const sourceNode = new MediaStreamAudioSourceNode(audioContext, {
            mediaStream: stream,
        });
        const audioNodeVAD = await AudioNodeVAD.new(audioContext, fullOptions);
        audioNodeVAD.receive(sourceNode);
        return new MicVAD(fullOptions, audioContext, stream, audioNodeVAD, sourceNode);
    }
    constructor(options, audioContext, stream, audioNodeVAD, sourceNode, listening = false) {
        this.options = options;
        this.audioContext = audioContext;
        this.stream = stream;
        this.audioNodeVAD = audioNodeVAD;
        this.sourceNode = sourceNode;
        this.listening = listening;
        this.pause = () => {
            this.audioNodeVAD.pause();
            this.listening = false;
        };
        this.start = () => {
            this.audioNodeVAD.start();
            this.listening = true;
        };
        this.destroy = () => {
            if (this.listening) {
                this.pause();
            }
            if (this.options.stream === undefined) {
                this.stream.getTracks().forEach((track) => track.stop());
            }
            this.sourceNode.disconnect();
            this.audioNodeVAD.destroy();
            this.audioContext.close();
        };
        this.setOptions = (options) => {
            this.audioNodeVAD.setFrameProcessorOptions(options);
        };
    }
}
exports.MicVAD = MicVAD;
class AudioNodeVAD {
    static async new(ctx, options = {}) {
        const fullOptions = {
            ...(0, exports.getDefaultRealTimeVADOptions)(options.model ?? exports.DEFAULT_MODEL),
            ...options,
        };
        (0, frame_processor_1.validateOptions)(fullOptions);
        exports.ort.env.wasm.wasmPaths = fullOptions.onnxWASMBasePath;
        if (fullOptions.ortConfig !== undefined) {
            fullOptions.ortConfig(exports.ort);
        }
        const modelFile = fullOptions.model === "v5" ? sileroV5File : sileroLegacyFile;
        const modelURL = fullOptions.baseAssetPath + modelFile;
        const modelFactory = fullOptions.model === "v5" ? models_1.SileroV5.new : models_1.SileroLegacy.new;
        let model;
        try {
            model = await modelFactory(exports.ort, () => (0, default_model_fetcher_1.defaultModelFetcher)(modelURL));
        }
        catch (e) {
            console.error(`Encountered an error while loading model file ${modelURL}`);
            throw e;
        }
        const frameProcessor = new frame_processor_1.FrameProcessor(model.process, model.reset_state, {
            frameSamples: fullOptions.frameSamples,
            positiveSpeechThreshold: fullOptions.positiveSpeechThreshold,
            negativeSpeechThreshold: fullOptions.negativeSpeechThreshold,
            redemptionFrames: fullOptions.redemptionFrames,
            preSpeechPadFrames: fullOptions.preSpeechPadFrames,
            minSpeechFrames: fullOptions.minSpeechFrames,
            submitUserSpeechOnPause: fullOptions.submitUserSpeechOnPause,
        });
        const audioNodeVAD = new AudioNodeVAD(ctx, fullOptions, frameProcessor);
        await audioNodeVAD.setupAudioNode();
        return audioNodeVAD;
    }
    constructor(ctx, options, frameProcessor) {
        this.ctx = ctx;
        this.options = options;
        this.bufferIndex = 0;
        this.pause = () => {
            this.frameProcessor.pause(this.handleFrameProcessorEvent);
        };
        this.start = () => {
            this.frameProcessor.resume();
        };
        this.receive = (node) => {
            node.connect(this.audioNode);
        };
        this.processFrame = async (frame) => {
            await this.frameProcessor.process(frame, this.handleFrameProcessorEvent);
        };
        this.handleFrameProcessorEvent = (ev) => {
            switch (ev.msg) {
                case messages_1.Message.FrameProcessed:
                    this.options.onFrameProcessed(ev.probs, ev.frame);
                    break;
                case messages_1.Message.SpeechStart:
                    this.options.onSpeechStart();
                    break;
                case messages_1.Message.SpeechRealStart:
                    this.options.onSpeechRealStart();
                    break;
                case messages_1.Message.VADMisfire:
                    this.options.onVADMisfire();
                    break;
                case messages_1.Message.SpeechEnd:
                    this.options.onSpeechEnd(ev.audio);
                    break;
            }
        };
        this.destroy = () => {
            if (this.audioNode instanceof AudioWorkletNode) {
                this.audioNode.port.postMessage({
                    message: messages_1.Message.SpeechStop,
                });
            }
            this.audioNode.disconnect();
            this.gainNode?.disconnect();
        };
        this.setFrameProcessorOptions = (options) => {
            this.frameProcessor.options = {
                ...this.frameProcessor.options,
                ...options,
            };
        };
        this.frameProcessor = frameProcessor;
    }
    async setupAudioNode() {
        const hasAudioWorklet = "audioWorklet" in this.ctx && typeof AudioWorkletNode === "function";
        if (hasAudioWorklet) {
            try {
                const workletURL = this.options.baseAssetPath + workletFile;
                await this.ctx.audioWorklet.addModule(workletURL);
                const workletOptions = this.options.workletOptions ?? {};
                workletOptions.processorOptions = {
                    ...(workletOptions.processorOptions ?? {}),
                    frameSamples: this.options.frameSamples,
                };
                this.audioNode = new AudioWorkletNode(this.ctx, "vad-helper-worklet", workletOptions);
                this.audioNode.port.onmessage = async (ev) => {
                    switch (ev.data?.message) {
                        case messages_1.Message.AudioFrame:
                            let buffer = ev.data.data;
                            if (!(buffer instanceof ArrayBuffer)) {
                                buffer = new ArrayBuffer(ev.data.data.byteLength);
                                new Uint8Array(buffer).set(new Uint8Array(ev.data.data));
                            }
                            const frame = new Float32Array(buffer);
                            await this.processFrame(frame);
                            break;
                    }
                };
                return;
            }
            catch (e) {
                console.log("AudioWorklet setup failed, falling back to ScriptProcessor", e);
            }
        }
        // Initialize resampler for ScriptProcessor
        this.resampler = new resampler_1.Resampler({
            nativeSampleRate: this.ctx.sampleRate,
            targetSampleRate: 16000,
            targetFrameSize: this.options.frameSamples ?? 480,
        });
        // Fallback to ScriptProcessor
        const bufferSize = 4096; // Increased for more stable processing
        this.audioNode = this.ctx.createScriptProcessor(bufferSize, 1, 1);
        // Create a gain node with zero gain to handle the audio chain
        this.gainNode = this.ctx.createGain();
        this.gainNode.gain.value = 0;
        let processingAudio = false;
        this.audioNode.onaudioprocess = async (e) => {
            if (processingAudio)
                return;
            processingAudio = true;
            try {
                const input = e.inputBuffer.getChannelData(0);
                const output = e.outputBuffer.getChannelData(0);
                output.fill(0);
                // Process through resampler
                if (this.resampler) {
                    const frames = this.resampler.process(input);
                    for (const frame of frames) {
                        await this.processFrame(frame);
                    }
                }
            }
            catch (error) {
                console.error("Error processing audio:", error);
            }
            finally {
                processingAudio = false;
            }
        };
        // Connect the audio chain
        this.audioNode.connect(this.gainNode);
        this.gainNode.connect(this.ctx.destination);
    }
}
exports.AudioNodeVAD = AudioNodeVAD;
//# sourceMappingURL=real-time-vad.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/resampler.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/resampler.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Resampler = void 0;
const logging_1 = __webpack_require__(/*! ./logging */ "./node_modules/@ricky0123/vad-web/dist/logging.js");
class Resampler {
    constructor(options) {
        this.options = options;
        this.process = (audioFrame) => {
            const outputFrames = [];
            for (const sample of audioFrame) {
                this.inputBuffer.push(sample);
                while (this.hasEnoughDataForFrame()) {
                    const outputFrame = this.generateOutputFrame();
                    outputFrames.push(outputFrame);
                }
            }
            return outputFrames;
        };
        if (options.nativeSampleRate < 16000) {
            logging_1.log.error("nativeSampleRate is too low. Should have 16000 = targetSampleRate <= nativeSampleRate");
        }
        this.inputBuffer = [];
    }
    async *stream(audioInput) {
        for (const sample of audioInput) {
            this.inputBuffer.push(sample);
            while (this.hasEnoughDataForFrame()) {
                const outputFrame = this.generateOutputFrame();
                yield outputFrame;
            }
        }
    }
    hasEnoughDataForFrame() {
        return ((this.inputBuffer.length * this.options.targetSampleRate) /
            this.options.nativeSampleRate >=
            this.options.targetFrameSize);
    }
    generateOutputFrame() {
        const outputFrame = new Float32Array(this.options.targetFrameSize);
        let outputIndex = 0;
        let inputIndex = 0;
        while (outputIndex < this.options.targetFrameSize) {
            let sum = 0;
            let num = 0;
            while (inputIndex <
                Math.min(this.inputBuffer.length, ((outputIndex + 1) * this.options.nativeSampleRate) /
                    this.options.targetSampleRate)) {
                const value = this.inputBuffer[inputIndex];
                if (value !== undefined) {
                    sum += value;
                    num++;
                }
                inputIndex++;
            }
            outputFrame[outputIndex] = sum / num;
            outputIndex++;
        }
        this.inputBuffer = this.inputBuffer.slice(inputIndex);
        return outputFrame;
    }
}
exports.Resampler = Resampler;
//# sourceMappingURL=resampler.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.audioFileToArray = exports.encodeWAV = exports.arrayBufferToBase64 = exports.minFramesForTargetMS = void 0;
function minFramesForTargetMS(targetDuration, frameSamples, sr = 16000) {
    return Math.ceil((targetDuration * sr) / 1000 / frameSamples);
}
exports.minFramesForTargetMS = minFramesForTargetMS;
function arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    const binary = new Array(len);
    for (var i = 0; i < len; i++) {
        const byte = bytes[i];
        if (byte === undefined) {
            break;
        }
        binary[i] = String.fromCharCode(byte);
    }
    return btoa(binary.join(""));
}
exports.arrayBufferToBase64 = arrayBufferToBase64;
/*
This rest of this was mostly copied from https://github.com/linto-ai/WebVoiceSDK
*/
function encodeWAV(samples, format = 3, sampleRate = 16000, numChannels = 1, bitDepth = 32) {
    var bytesPerSample = bitDepth / 8;
    var blockAlign = numChannels * bytesPerSample;
    var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
    var view = new DataView(buffer);
    /* RIFF identifier */
    writeString(view, 0, "RIFF");
    /* RIFF chunk length */
    view.setUint32(4, 36 + samples.length * bytesPerSample, true);
    /* RIFF type */
    writeString(view, 8, "WAVE");
    /* format chunk identifier */
    writeString(view, 12, "fmt ");
    /* format chunk length */
    view.setUint32(16, 16, true);
    /* sample format (raw) */
    view.setUint16(20, format, true);
    /* channel count */
    view.setUint16(22, numChannels, true);
    /* sample rate */
    view.setUint32(24, sampleRate, true);
    /* byte rate (sample rate * block align) */
    view.setUint32(28, sampleRate * blockAlign, true);
    /* block align (channel count * bytes per sample) */
    view.setUint16(32, blockAlign, true);
    /* bits per sample */
    view.setUint16(34, bitDepth, true);
    /* data chunk identifier */
    writeString(view, 36, "data");
    /* data chunk length */
    view.setUint32(40, samples.length * bytesPerSample, true);
    if (format === 1) {
        // Raw PCM
        floatTo16BitPCM(view, 44, samples);
    }
    else {
        writeFloat32(view, 44, samples);
    }
    return buffer;
}
exports.encodeWAV = encodeWAV;
function interleave(inputL, inputR) {
    var length = inputL.length + inputR.length;
    var result = new Float32Array(length);
    var index = 0;
    var inputIndex = 0;
    while (index < length) {
        result[index++] = inputL[inputIndex];
        result[index++] = inputR[inputIndex];
        inputIndex++;
    }
    return result;
}
function writeFloat32(output, offset, input) {
    for (var i = 0; i < input.length; i++, offset += 4) {
        output.setFloat32(offset, input[i], true);
    }
}
function floatTo16BitPCM(output, offset, input) {
    for (var i = 0; i < input.length; i++, offset += 2) {
        var s = Math.max(-1, Math.min(1, input[i]));
        output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
    }
}
function writeString(view, offset, string) {
    for (var i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}
async function audioFileToArray(audioFileData) {
    const ctx = new OfflineAudioContext(1, 1, 44100);
    const reader = new FileReader();
    let audioBuffer = null;
    await new Promise((res) => {
        reader.addEventListener("loadend", (ev) => {
            const audioData = reader.result;
            ctx.decodeAudioData(audioData, (buffer) => {
                audioBuffer = buffer;
                ctx
                    .startRendering()
                    .then((renderedBuffer) => {
                    console.log("Rendering completed successfully");
                    res();
                })
                    .catch((err) => {
                    console.error(`Rendering failed: ${err}`);
                });
            }, (e) => {
                console.log(`Error with decoding audio data: ${e}`);
            });
        });
        reader.readAsArrayBuffer(audioFileData);
    });
    if (audioBuffer === null) {
        throw Error("some shit");
    }
    let _audioBuffer = audioBuffer;
    let out = new Float32Array(_audioBuffer.length);
    for (let i = 0; i < _audioBuffer.length; i++) {
        for (let j = 0; j < _audioBuffer.numberOfChannels; j++) {
            // @ts-ignore
            out[i] += _audioBuffer.getChannelData(j)[i];
        }
    }
    return { audio: out, sampleRate: _audioBuffer.sampleRate };
}
exports.audioFileToArray = audioFileToArray;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/backend-impl.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/backend-impl.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerBackend: () => (/* binding */ registerBackend),
/* harmony export */   resolveBackend: () => (/* binding */ resolveBackend)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const backends = {};
const backendsSortedByPriority = [];
/**
 * Register a backend.
 *
 * @param name - the name as a key to lookup as an execution provider.
 * @param backend - the backend object.
 * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority
 * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.
 *
 * @internal
 */
const registerBackend = (name, backend, priority) => {
    if (backend && typeof backend.init === 'function' && typeof backend.createSessionHandler === 'function') {
        const currentBackend = backends[name];
        if (currentBackend === undefined) {
            backends[name] = { backend, priority };
        }
        else if (currentBackend.priority > priority) {
            // same name is already registered with a higher priority. skip registeration.
            return;
        }
        else if (currentBackend.priority === priority) {
            if (currentBackend.backend !== backend) {
                throw new Error(`cannot register backend "${name}" using priority ${priority}`);
            }
        }
        if (priority >= 0) {
            const i = backendsSortedByPriority.indexOf(name);
            if (i !== -1) {
                backendsSortedByPriority.splice(i, 1);
            }
            for (let i = 0; i < backendsSortedByPriority.length; i++) {
                if (backends[backendsSortedByPriority[i]].priority <= priority) {
                    backendsSortedByPriority.splice(i, 0, name);
                    return;
                }
            }
            backendsSortedByPriority.push(name);
        }
        return;
    }
    throw new TypeError('not a valid backend');
};
/**
 * Resolve backend by specified hints.
 *
 * @param backendHints - a list of execution provider names to lookup. If omitted use registered backends as list.
 * @returns a promise that resolves to the backend.
 *
 * @internal
 */
const resolveBackend = async (backendHints) => {
    const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
    const errors = [];
    for (const backendName of backendNames) {
        const backendInfo = backends[backendName];
        if (backendInfo) {
            if (backendInfo.initialized) {
                return backendInfo.backend;
            }
            else if (backendInfo.aborted) {
                continue; // current backend is unavailable; try next
            }
            const isInitializing = !!backendInfo.initPromise;
            try {
                if (!isInitializing) {
                    backendInfo.initPromise = backendInfo.backend.init();
                }
                await backendInfo.initPromise;
                backendInfo.initialized = true;
                return backendInfo.backend;
            }
            catch (e) {
                if (!isInitializing) {
                    errors.push({ name: backendName, err: e });
                }
                backendInfo.aborted = true;
            }
            finally {
                delete backendInfo.initPromise;
            }
        }
    }
    throw new Error(`no available backend found. ERR: ${errors.map(e => `[${e.name}] ${e.err}`).join(', ')}`);
};
//# sourceMappingURL=backend-impl.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/backend.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/backend.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerBackend: () => (/* reexport safe */ _backend_impl__WEBPACK_IMPORTED_MODULE_0__.registerBackend)
/* harmony export */ });
/* harmony import */ var _backend_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend-impl */ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/backend-impl.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

//# sourceMappingURL=backend.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/env-impl.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/env-impl.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnvImpl: () => (/* binding */ EnvImpl)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
class EnvImpl {
    constructor() {
        this.wasm = {};
        this.webgl = {};
        this.logLevelInternal = 'warning';
    }
    // TODO standadize the getter and setter convention in env for other fields.
    set logLevel(value) {
        if (value === undefined) {
            return;
        }
        if (typeof value !== 'string' || ['verbose', 'info', 'warning', 'error', 'fatal'].indexOf(value) === -1) {
            throw new Error(`Unsupported logging level: ${value}`);
        }
        this.logLevelInternal = value;
    }
    get logLevel() {
        return this.logLevelInternal;
    }
}
//# sourceMappingURL=env-impl.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/env.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/env.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   env: () => (/* binding */ env)
/* harmony export */ });
/* harmony import */ var _env_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env-impl */ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/env-impl.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

/**
 * Represent a set of flags as a global singleton.
 */
const env = new _env_impl__WEBPACK_IMPORTED_MODULE_0__.EnvImpl();
//# sourceMappingURL=env.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/index.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/index.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InferenceSession: () => (/* reexport safe */ _inference_session__WEBPACK_IMPORTED_MODULE_2__.InferenceSession),
/* harmony export */   Tensor: () => (/* reexport safe */ _tensor__WEBPACK_IMPORTED_MODULE_3__.Tensor),
/* harmony export */   env: () => (/* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_1__.env),
/* harmony export */   registerBackend: () => (/* reexport safe */ _backend__WEBPACK_IMPORTED_MODULE_0__.registerBackend)
/* harmony export */ });
/* harmony import */ var _backend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend */ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/backend.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env */ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/env.js");
/* harmony import */ var _inference_session__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./inference-session */ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/inference-session.js");
/* harmony import */ var _tensor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tensor */ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/tensor.js");
/* harmony import */ var _onnx_value__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./onnx-value */ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/onnx-value.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * # ONNX Runtime JavaScript API
 *
 * ONNX Runtime JavaScript API is a unified API for all JavaScript usages, including the following NPM packages:
 *
 * - [onnxruntime-node](https://www.npmjs.com/package/onnxruntime-node)
 * - [onnxruntime-web](https://www.npmjs.com/package/onnxruntime-web)
 * - [onnxruntime-react-native](https://www.npmjs.com/package/onnxruntime-react-native)
 *
 * See also:
 * - [Get Started](https://onnxruntime.ai/docs/get-started/with-javascript.html)
 * - [Inference examples](https://github.com/microsoft/onnxruntime-inference-examples/tree/main/js)
 *
 * @packageDocumentation
 */





//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/inference-session-impl.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/inference-session-impl.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InferenceSession: () => (/* binding */ InferenceSession)
/* harmony export */ });
/* harmony import */ var _backend_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend-impl */ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/backend-impl.js");
/* harmony import */ var _tensor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tensor */ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/tensor.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.


class InferenceSession {
    constructor(handler) {
        this.handler = handler;
    }
    async run(feeds, arg1, arg2) {
        const fetches = {};
        let options = {};
        // check inputs
        if (typeof feeds !== 'object' || feeds === null || feeds instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor || Array.isArray(feeds)) {
            throw new TypeError('\'feeds\' must be an object that use input names as keys and OnnxValue as corresponding values.');
        }
        let isFetchesEmpty = true;
        // determine which override is being used
        if (typeof arg1 === 'object') {
            if (arg1 === null) {
                throw new TypeError('Unexpected argument[1]: cannot be null.');
            }
            if (arg1 instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor) {
                throw new TypeError('\'fetches\' cannot be a Tensor');
            }
            if (Array.isArray(arg1)) {
                if (arg1.length === 0) {
                    throw new TypeError('\'fetches\' cannot be an empty array.');
                }
                isFetchesEmpty = false;
                // output names
                for (const name of arg1) {
                    if (typeof name !== 'string') {
                        throw new TypeError('\'fetches\' must be a string array or an object.');
                    }
                    if (this.outputNames.indexOf(name) === -1) {
                        throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
                    }
                    fetches[name] = null;
                }
                if (typeof arg2 === 'object' && arg2 !== null) {
                    options = arg2;
                }
                else if (typeof arg2 !== 'undefined') {
                    throw new TypeError('\'options\' must be an object.');
                }
            }
            else {
                // decide whether arg1 is fetches or options
                // if any output name is present and its value is valid OnnxValue, we consider it fetches
                let isFetches = false;
                const arg1Keys = Object.getOwnPropertyNames(arg1);
                for (const name of this.outputNames) {
                    if (arg1Keys.indexOf(name) !== -1) {
                        const v = arg1[name];
                        if (v === null || v instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor) {
                            isFetches = true;
                            isFetchesEmpty = false;
                            fetches[name] = v;
                        }
                    }
                }
                if (isFetches) {
                    if (typeof arg2 === 'object' && arg2 !== null) {
                        options = arg2;
                    }
                    else if (typeof arg2 !== 'undefined') {
                        throw new TypeError('\'options\' must be an object.');
                    }
                }
                else {
                    options = arg1;
                }
            }
        }
        else if (typeof arg1 !== 'undefined') {
            throw new TypeError('Unexpected argument[1]: must be \'fetches\' or \'options\'.');
        }
        // check if all inputs are in feed
        for (const name of this.inputNames) {
            if (typeof feeds[name] === 'undefined') {
                throw new Error(`input '${name}' is missing in 'feeds'.`);
            }
        }
        // if no fetches is specified, we use the full output names list
        if (isFetchesEmpty) {
            for (const name of this.outputNames) {
                fetches[name] = null;
            }
        }
        // feeds, fetches and options are prepared
        const results = await this.handler.run(feeds, fetches, options);
        const returnValue = {};
        for (const key in results) {
            if (Object.hasOwnProperty.call(results, key)) {
                returnValue[key] = new _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor(results[key].type, results[key].data, results[key].dims);
            }
        }
        return returnValue;
    }
    static async create(arg0, arg1, arg2, arg3) {
        // either load from a file or buffer
        let filePathOrUint8Array;
        let options = {};
        if (typeof arg0 === 'string') {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            }
            else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
        }
        else if (arg0 instanceof Uint8Array) {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            }
            else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
        }
        else if (arg0 instanceof ArrayBuffer ||
            (typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer)) {
            const buffer = arg0;
            let byteOffset = 0;
            let byteLength = arg0.byteLength;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            }
            else if (typeof arg1 === 'number') {
                byteOffset = arg1;
                if (!Number.isSafeInteger(byteOffset)) {
                    throw new RangeError('\'byteOffset\' must be an integer.');
                }
                if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
                    throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
                }
                byteLength = arg0.byteLength - byteOffset;
                if (typeof arg2 === 'number') {
                    byteLength = arg2;
                    if (!Number.isSafeInteger(byteLength)) {
                        throw new RangeError('\'byteLength\' must be an integer.');
                    }
                    if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                        throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
                    }
                    if (typeof arg3 === 'object' && arg3 !== null) {
                        options = arg3;
                    }
                    else if (typeof arg3 !== 'undefined') {
                        throw new TypeError('\'options\' must be an object.');
                    }
                }
                else if (typeof arg2 !== 'undefined') {
                    throw new TypeError('\'byteLength\' must be a number.');
                }
            }
            else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
        }
        else {
            throw new TypeError('Unexpected argument[0]: must be \'path\' or \'buffer\'.');
        }
        // get backend hints
        const eps = options.executionProviders || [];
        const backendHints = eps.map(i => typeof i === 'string' ? i : i.name);
        const backend = await (0,_backend_impl__WEBPACK_IMPORTED_MODULE_0__.resolveBackend)(backendHints);
        const handler = await backend.createSessionHandler(filePathOrUint8Array, options);
        return new InferenceSession(handler);
    }
    startProfiling() {
        this.handler.startProfiling();
    }
    endProfiling() {
        this.handler.endProfiling();
    }
    get inputNames() {
        return this.handler.inputNames;
    }
    get outputNames() {
        return this.handler.outputNames;
    }
}
//# sourceMappingURL=inference-session-impl.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/inference-session.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/inference-session.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InferenceSession: () => (/* binding */ InferenceSession)
/* harmony export */ });
/* harmony import */ var _inference_session_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inference-session-impl */ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/inference-session-impl.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// eslint-disable-next-line @typescript-eslint/naming-convention
const InferenceSession = _inference_session_impl__WEBPACK_IMPORTED_MODULE_0__.InferenceSession;
//# sourceMappingURL=inference-session.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/onnx-value.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/onnx-value.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

//# sourceMappingURL=onnx-value.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/tensor-impl.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/tensor-impl.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tensor: () => (/* binding */ Tensor)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && typeof BigInt64Array.from === 'function';
const isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && typeof BigUint64Array.from === 'function';
// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.
const NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([
    ['float32', Float32Array],
    ['uint8', Uint8Array],
    ['int8', Int8Array],
    ['uint16', Uint16Array],
    ['int16', Int16Array],
    ['int32', Int32Array],
    ['bool', Uint8Array],
    ['float64', Float64Array],
    ['uint32', Uint32Array],
]);
// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.
const NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([
    [Float32Array, 'float32'],
    [Uint8Array, 'uint8'],
    [Int8Array, 'int8'],
    [Uint16Array, 'uint16'],
    [Int16Array, 'int16'],
    [Int32Array, 'int32'],
    [Float64Array, 'float64'],
    [Uint32Array, 'uint32'],
]);
if (isBigInt64ArrayAvailable) {
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');
}
if (isBigUint64ArrayAvailable) {
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');
}
/**
 * calculate size from dims.
 *
 * @param dims the dims array. May be an illegal input.
 */
const calculateSize = (dims) => {
    let size = 1;
    for (let i = 0; i < dims.length; i++) {
        const dim = dims[i];
        if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {
            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
        }
        if (dim < 0) {
            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
        }
        size *= dim;
    }
    return size;
};
class Tensor {
    constructor(arg0, arg1, arg2) {
        let type;
        let data;
        let dims;
        // check whether arg0 is type or data
        if (typeof arg0 === 'string') {
            //
            // Override: constructor(type, data, ...)
            //
            type = arg0;
            dims = arg2;
            if (arg0 === 'string') {
                // string tensor
                if (!Array.isArray(arg1)) {
                    throw new TypeError('A string tensor\'s data must be a string array.');
                }
                // we don't check whether every element in the array is string; this is too slow. we assume it's correct and
                // error will be populated at inference
                data = arg1;
            }
            else {
                // numeric tensor
                const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
                if (typedArrayConstructor === undefined) {
                    throw new TypeError(`Unsupported tensor type: ${arg0}.`);
                }
                if (Array.isArray(arg1)) {
                    // use 'as any' here because TypeScript's check on type of 'SupportedTypedArrayConstructors.from()' produces
                    // incorrect results.
                    // 'typedArrayConstructor' should be one of the typed array prototype objects.
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    data = typedArrayConstructor.from(arg1);
                }
                else if (arg1 instanceof typedArrayConstructor) {
                    data = arg1;
                }
                else {
                    throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
                }
            }
        }
        else {
            //
            // Override: constructor(data, ...)
            //
            dims = arg1;
            if (Array.isArray(arg0)) {
                // only boolean[] and string[] is supported
                if (arg0.length === 0) {
                    throw new TypeError('Tensor type cannot be inferred from an empty array.');
                }
                const firstElementType = typeof arg0[0];
                if (firstElementType === 'string') {
                    type = 'string';
                    data = arg0;
                }
                else if (firstElementType === 'boolean') {
                    type = 'bool';
                    // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is
                    // wrong type. We use 'as any' to make it happy.
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    data = Uint8Array.from(arg0);
                }
                else {
                    throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
                }
            }
            else {
                // get tensor type from TypedArray
                const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
                if (mappedType === undefined) {
                    throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
                }
                type = mappedType;
                data = arg0;
            }
        }
        // type and data is processed, now processing dims
        if (dims === undefined) {
            // assume 1-D tensor if dims omitted
            dims = [data.length];
        }
        else if (!Array.isArray(dims)) {
            throw new TypeError('A tensor\'s dims must be a number array');
        }
        // perform check
        const size = calculateSize(dims);
        if (size !== data.length) {
            throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);
        }
        this.dims = dims;
        this.type = type;
        this.data = data;
        this.size = size;
    }
    // #endregion
    /**
     * Create a new tensor object from image object
     *
     * @param buffer - Extracted image buffer data - assuming RGBA format
     * @param imageFormat - input image configuration - required configurations height, width, format
     * @param tensorFormat - output tensor configuration - Default is RGB format
     */
    static bufferToTensor(buffer, options) {
        if (buffer === undefined) {
            throw new Error('Image buffer must be defined');
        }
        if (options.height === undefined || options.width === undefined) {
            throw new Error('Image height and width must be defined');
        }
        const { height, width } = options;
        const norm = options.norm;
        let normMean;
        let normBias;
        if (norm === undefined || norm.mean === undefined) {
            normMean = 255;
        }
        else {
            normMean = norm.mean;
        }
        if (norm === undefined || norm.bias === undefined) {
            normBias = 0;
        }
        else {
            normBias = norm.bias;
        }
        const inputformat = options.bitmapFormat !== undefined ? options.bitmapFormat : 'RGBA';
        // default value is RGBA since imagedata and HTMLImageElement uses it
        const outputformat = options.tensorFormat !== undefined ?
            (options.tensorFormat !== undefined ? options.tensorFormat : 'RGB') :
            'RGB';
        const offset = height * width;
        const float32Data = outputformat === 'RGBA' ? new Float32Array(offset * 4) : new Float32Array(offset * 3);
        // Default pointer assignments
        let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;
        // Updating the pointer assignments based on the input image format
        if (inputformat === 'RGB') {
            step = 3;
            rImagePointer = 0;
            gImagePointer = 1;
            bImagePointer = 2;
            aImagePointer = -1;
        }
        // Updating the pointer assignments based on the output tensor format
        if (outputformat === 'RGBA') {
            aTensorPointer = offset * 3;
        }
        else if (outputformat === 'RBG') {
            rTensorPointer = 0;
            bTensorPointer = offset;
            gTensorPointer = offset * 2;
        }
        else if (outputformat === 'BGR') {
            bTensorPointer = 0;
            gTensorPointer = offset;
            rTensorPointer = offset * 2;
        }
        for (let i = 0; i < offset; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
            float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias) / normMean;
            float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias) / normMean;
            float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias) / normMean;
            if (aTensorPointer !== -1 && aImagePointer !== -1) {
                float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias) / normMean;
            }
        }
        // Float32Array -> ort.Tensor
        const outputTensor = outputformat === 'RGBA' ? new Tensor('float32', float32Data, [1, 4, height, width]) :
            new Tensor('float32', float32Data, [1, 3, height, width]);
        return outputTensor;
    }
    static async fromImage(image, options) {
        // checking the type of image object
        const isHTMLImageEle = typeof (HTMLImageElement) !== 'undefined' && image instanceof HTMLImageElement;
        const isImageDataEle = typeof (ImageData) !== 'undefined' && image instanceof ImageData;
        const isImageBitmap = typeof (ImageBitmap) !== 'undefined' && image instanceof ImageBitmap;
        const isURL = typeof (String) !== 'undefined' && (image instanceof String || typeof image === 'string');
        let data;
        let tensorConfig = {};
        // filling and checking image configuration options
        if (isHTMLImageEle) {
            // HTMLImageElement - image object - format is RGBA by default
            const canvas = document.createElement('canvas');
            const pixels2DContext = canvas.getContext('2d');
            if (pixels2DContext != null) {
                let height = image.naturalHeight;
                let width = image.naturalWidth;
                if (options !== undefined && options.resizedHeight !== undefined && options.resizedWidth !== undefined) {
                    height = options.resizedHeight;
                    width = options.resizedWidth;
                }
                if (options !== undefined) {
                    tensorConfig = options;
                    if (options.tensorFormat !== undefined) {
                        throw new Error('Image input config format must be RGBA for HTMLImageElement');
                    }
                    else {
                        tensorConfig.tensorFormat = 'RGBA';
                    }
                    if (options.height !== undefined && options.height !== height) {
                        throw new Error('Image input config height doesn\'t match HTMLImageElement height');
                    }
                    else {
                        tensorConfig.height = height;
                    }
                    if (options.width !== undefined && options.width !== width) {
                        throw new Error('Image input config width doesn\'t match HTMLImageElement width');
                    }
                    else {
                        tensorConfig.width = width;
                    }
                }
                else {
                    tensorConfig.tensorFormat = 'RGBA';
                    tensorConfig.height = height;
                    tensorConfig.width = width;
                }
                canvas.width = width;
                canvas.height = height;
                pixels2DContext.drawImage(image, 0, 0, width, height);
                data = pixels2DContext.getImageData(0, 0, width, height).data;
            }
            else {
                throw new Error('Can not access image data');
            }
        }
        else if (isImageDataEle) {
            // ImageData - image object - format is RGBA by default
            const format = 'RGBA';
            let height;
            let width;
            if (options !== undefined && options.resizedWidth !== undefined && options.resizedHeight !== undefined) {
                height = options.resizedHeight;
                width = options.resizedWidth;
            }
            else {
                height = image.height;
                width = image.width;
            }
            if (options !== undefined) {
                tensorConfig = options;
                if (options.bitmapFormat !== undefined && options.bitmapFormat !== format) {
                    throw new Error('Image input config format must be RGBA for ImageData');
                }
                else {
                    tensorConfig.bitmapFormat = 'RGBA';
                }
            }
            else {
                tensorConfig.bitmapFormat = 'RGBA';
            }
            tensorConfig.height = height;
            tensorConfig.width = width;
            if (options !== undefined) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const pixels2DContext = tempCanvas.getContext('2d');
                if (pixels2DContext != null) {
                    pixels2DContext.putImageData(image, 0, 0);
                    data = pixels2DContext.getImageData(0, 0, width, height).data;
                }
                else {
                    throw new Error('Can not access image data');
                }
            }
            else {
                data = image.data;
            }
        }
        else if (isImageBitmap) {
            // ImageBitmap - image object - format must be provided by user
            if (options === undefined) {
                throw new Error('Please provide image config with format for Imagebitmap');
            }
            if (options.bitmapFormat !== undefined) {
                throw new Error('Image input config format must be defined for ImageBitmap');
            }
            const pixels2DContext = document.createElement('canvas').getContext('2d');
            if (pixels2DContext != null) {
                const height = image.height;
                const width = image.width;
                pixels2DContext.drawImage(image, 0, 0, width, height);
                data = pixels2DContext.getImageData(0, 0, width, height).data;
                if (options !== undefined) {
                    // using square brackets to avoid TS error - type 'never'
                    if (options.height !== undefined && options.height !== height) {
                        throw new Error('Image input config height doesn\'t match ImageBitmap height');
                    }
                    else {
                        tensorConfig.height = height;
                    }
                    // using square brackets to avoid TS error - type 'never'
                    if (options.width !== undefined && options.width !== width) {
                        throw new Error('Image input config width doesn\'t match ImageBitmap width');
                    }
                    else {
                        tensorConfig.width = width;
                    }
                }
                else {
                    tensorConfig.height = height;
                    tensorConfig.width = width;
                }
                return Tensor.bufferToTensor(data, tensorConfig);
            }
            else {
                throw new Error('Can not access image data');
            }
        }
        else if (isURL) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                if (!image || !context) {
                    return reject();
                }
                const newImage = new Image();
                newImage.crossOrigin = 'Anonymous';
                newImage.src = image;
                newImage.onload = () => {
                    canvas.width = newImage.width;
                    canvas.height = newImage.height;
                    context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
                    const img = context.getImageData(0, 0, canvas.width, canvas.height);
                    if (options !== undefined) {
                        // using square brackets to avoid TS error - type 'never'
                        if (options.height !== undefined && options.height !== canvas.height) {
                            throw new Error('Image input config height doesn\'t match ImageBitmap height');
                        }
                        else {
                            tensorConfig.height = canvas.height;
                        }
                        // using square brackets to avoid TS error - type 'never'
                        if (options.width !== undefined && options.width !== canvas.width) {
                            throw new Error('Image input config width doesn\'t match ImageBitmap width');
                        }
                        else {
                            tensorConfig.width = canvas.width;
                        }
                    }
                    else {
                        tensorConfig.height = canvas.height;
                        tensorConfig.width = canvas.width;
                    }
                    resolve(Tensor.bufferToTensor(img.data, tensorConfig));
                };
            });
        }
        else {
            throw new Error('Input data provided is not supported - aborted tensor creation');
        }
        if (data !== undefined) {
            return Tensor.bufferToTensor(data, tensorConfig);
        }
        else {
            throw new Error('Input data provided is not supported - aborted tensor creation');
        }
    }
    toImageData(options) {
        var _a, _b;
        const pixels2DContext = document.createElement('canvas').getContext('2d');
        let image;
        if (pixels2DContext != null) {
            // Default values for height and width & format
            const width = this.dims[3];
            const height = this.dims[2];
            const channels = this.dims[1];
            const inputformat = options !== undefined ? (options.format !== undefined ? options.format : 'RGB') : 'RGB';
            const normMean = options !== undefined ? (((_a = options.norm) === null || _a === void 0 ? void 0 : _a.mean) !== undefined ? options.norm.mean : 255) : 255;
            const normBias = options !== undefined ? (((_b = options.norm) === null || _b === void 0 ? void 0 : _b.bias) !== undefined ? options.norm.bias : 0) : 0;
            const offset = height * width;
            if (options !== undefined) {
                if (options.height !== undefined && options.height !== height) {
                    throw new Error('Image output config height doesn\'t match tensor height');
                }
                if (options.width !== undefined && options.width !== width) {
                    throw new Error('Image output config width doesn\'t match tensor width');
                }
                if (options.format !== undefined && (channels === 4 && options.format !== 'RGBA') ||
                    (channels === 3 && (options.format !== 'RGB' && options.format !== 'BGR'))) {
                    throw new Error('Tensor format doesn\'t match input tensor dims');
                }
            }
            // Default pointer assignments
            const step = 4;
            let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
            let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;
            // Updating the pointer assignments based on the input image format
            if (inputformat === 'RGBA') {
                rTensorPointer = 0;
                gTensorPointer = offset;
                bTensorPointer = offset * 2;
                aTensorPointer = offset * 3;
            }
            else if (inputformat === 'RGB') {
                rTensorPointer = 0;
                gTensorPointer = offset;
                bTensorPointer = offset * 2;
            }
            else if (inputformat === 'RBG') {
                rTensorPointer = 0;
                bTensorPointer = offset;
                gTensorPointer = offset * 2;
            }
            image = pixels2DContext.createImageData(width, height);
            for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
                image.data[rImagePointer] = (this.data[rTensorPointer++] - normBias) * normMean; // R value
                image.data[gImagePointer] = (this.data[gTensorPointer++] - normBias) * normMean; // G value
                image.data[bImagePointer] = (this.data[bTensorPointer++] - normBias) * normMean; // B value
                image.data[aImagePointer] =
                    aTensorPointer === -1 ? 255 : (this.data[aTensorPointer++] - normBias) * normMean; // A value
            }
        }
        else {
            throw new Error('Can not access image data');
        }
        return image;
    }
    // #endregion
    // #region tensor utilities
    reshape(dims) {
        return new Tensor(this.type, this.data, dims);
    }
}
//# sourceMappingURL=tensor-impl.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/tensor.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/tensor.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tensor: () => (/* binding */ Tensor)
/* harmony export */ });
/* harmony import */ var _tensor_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tensor-impl */ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/tensor-impl.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// eslint-disable-next-line @typescript-eslint/naming-convention
const Tensor = _tensor_impl__WEBPACK_IMPORTED_MODULE_0__.Tensor;
//# sourceMappingURL=tensor.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-web/dist/ort-web.min.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-web/dist/ort-web.min.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
* ONNX Runtime Web v1.14.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/
!function(t,e){if(true)module.exports=e(__webpack_require__(/*! onnxruntime-common */ "./node_modules/@ricky0123/vad-web/node_modules/onnxruntime-common/dist/lib/index.js"));else { var r, n; }}(self,(__WEBPACK_EXTERNAL_MODULE__1670__=>(()=>{var __webpack_modules__={3474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return $.buffer!=C&&H($.buffer),F}function r(){return $.buffer!=C&&H($.buffer),N}function i(){return $.buffer!=C&&H($.buffer),L}function o(){return $.buffer!=C&&H($.buffer),R}function a(){return $.buffer!=C&&H($.buffer),j}var s,u,c;t=t||{},s||(s=void 0!==t?t:{}),s.ready=new Promise((function(t,e){u=t,c=e}));var l,p,f,d,h,g,b=Object.assign({},s),m="./this.program",y=(t,e)=>{throw e},_="object"==typeof window,v="function"==typeof importScripts,w="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,x=s.ENVIRONMENT_IS_PTHREAD||!1,T="";function S(t){return s.locateFile?s.locateFile(t,T):T+t}if(w){let e;T=v?n(908).dirname(T)+"/":"//",g=()=>{h||(d=n(1384),h=n(908))},l=function(t,e){return g(),t=h.normalize(t),d.readFileSync(t,e?void 0:"utf8")},f=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),p=(t,e,n)=>{g(),t=h.normalize(t),d.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ut))throw t})),process.on("unhandledRejection",(function(t){throw t})),y=(t,e)=>{if(J())throw process.exitCode=t,e;e instanceof ut||P("exiting due to exception: "+e),process.exit(t)},s.inspect=function(){return"[Emscripten Module object]"};try{e=n(9925)}catch(t){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),t}n.g.Worker=e.Worker}else(_||v)&&(v?T=self.location.href:"undefined"!=typeof document&&document.currentScript&&(T=document.currentScript.src),_scriptDir&&(T=_scriptDir),T=0!==T.indexOf("blob:")?T.substr(0,T.replace(/[?#].*/,"").lastIndexOf("/")+1):"",w||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},v&&(f=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),p=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));w&&"undefined"==typeof performance&&(n.g.performance=n(6953).performance);var O=console.log.bind(console),A=console.warn.bind(console);w&&(g(),O=t=>d.writeSync(1,t+"\n"),A=t=>d.writeSync(2,t+"\n"));var E,I=s.print||O,P=s.printErr||A;Object.assign(s,b),b=null,s.thisProgram&&(m=s.thisProgram),s.quit&&(y=s.quit),s.wasmBinary&&(E=s.wasmBinary);var D=s.noExitRuntime||!1;"object"!=typeof WebAssembly&&it("no native wasm support detected");var $,k,C,F,N,L,R,j,M=!1,U="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function V(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&U)return U.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var i=t[e++];if(128&i){var o=63&t[e++];if(192==(224&i))r+=String.fromCharCode((31&i)<<6|o);else{var a=63&t[e++];65536>(i=224==(240&i)?(15&i)<<12|o<<6|a:(7&i)<<18|o<<12|a<<6|63&t[e++])?r+=String.fromCharCode(i):(i-=65536,r+=String.fromCharCode(55296|i>>10,56320|1023&i))}}else r+=String.fromCharCode(i)}return r}function B(t,e){return(t>>>=0)?V(r(),t,e):""}function z(t,e,n,r){if(!(0<r))return 0;var i=n>>>=0;r=n+r-1;for(var o=0;o<t.length;++o){var a=t.charCodeAt(o);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&t.charCodeAt(++o)),127>=a){if(n>=r)break;e[n++>>>0]=a}else{if(2047>=a){if(n+1>=r)break;e[n++>>>0]=192|a>>6}else{if(65535>=a){if(n+2>=r)break;e[n++>>>0]=224|a>>12}else{if(n+3>=r)break;e[n++>>>0]=240|a>>18,e[n++>>>0]=128|a>>12&63}e[n++>>>0]=128|a>>6&63}e[n++>>>0]=128|63&a}}return e[n>>>0]=0,n-i}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function H(t){C=t,s.HEAP8=F=new Int8Array(t),s.HEAP16=new Int16Array(t),s.HEAP32=L=new Int32Array(t),s.HEAPU8=N=new Uint8Array(t),s.HEAPU16=new Uint16Array(t),s.HEAPU32=R=new Uint32Array(t),s.HEAPF32=new Float32Array(t),s.HEAPF64=j=new Float64Array(t)}x&&(C=s.buffer);var W=s.INITIAL_MEMORY||16777216;if(x)$=s.wasmMemory,C=s.buffer;else if(s.wasmMemory)$=s.wasmMemory;else if(!(($=new WebAssembly.Memory({initial:W/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw P("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),w&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");$&&(C=$.buffer),W=C.byteLength,H(C);var q,X=[],Y=[],K=[],Z=[];function J(){return D||!1}function Q(){var t=s.preRun.shift();X.unshift(t)}var tt,et=0,nt=null,rt=null;function it(t){throw x?postMessage({cmd:"onAbort",arg:t}):s.onAbort&&s.onAbort(t),P(t="Aborted("+t+")"),M=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),c(t),t}function ot(){return tt.startsWith("data:application/octet-stream;base64,")}function at(){var t=tt;try{if(t==tt&&E)return new Uint8Array(E);if(f)return f(t);throw"both async and sync fetching of the wasm failed"}catch(t){it(t)}}tt="ort-wasm-threaded.wasm",ot()||(tt=S(tt));var st={};function ut(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function ct(t){(t=dt.Vb[t])||it(),dt.mc(t)}function lt(t){var e=dt.Cc();if(!e)return 6;dt.ac.push(e),dt.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function pt(t){if(x)return qt(1,1,t);J()||(dt.oc(),s.onExit&&s.onExit(t),M=!0),y(t,new ut(t))}function ft(t,e){if(!e&&x)throw bt(t),"unwind";J()||x||(me(),ht(K),be(0),re[1].length&&ie(1,10),re[2].length&&ie(2,10),dt.oc()),pt(t)}var dt={Yb:[],ac:[],qc:[],Vb:{},fc:function(){x&&dt.Ec()},Pc:function(){},Ec:function(){dt.receiveObjectTransfer=dt.Gc,dt.threadInitTLS=dt.pc,dt.setExitStatus=dt.nc,D=!1},nc:function(){},oc:function(){for(var t of Object.values(dt.Vb))dt.mc(t);for(t of dt.Yb)t.terminate();dt.Yb=[]},mc:function(t){var e=t.Ub;delete dt.Vb[e],dt.Yb.push(t),dt.ac.splice(dt.ac.indexOf(t),1),t.Ub=0,xe(e)},Gc:function(){},pc:function(){dt.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(dt.Bc=t.Ub),n.targetThread&&n.targetThread!=de()){var i=dt.Vb[n.Qc];i?i.postMessage(n,n.transferList):P('Internal error! Worker sent a message "'+r+'" to target pthread '+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?Vt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?ct(n.thread):"killThread"===r?(n=n.thread,r=dt.Vb[n],delete dt.Vb[n],r.terminate(),xe(n),dt.ac.splice(dt.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?dt.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?I("Thread "+n.threadId+": "+n.text):"printErr"===r?P("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?s.onAbort&&s.onAbort(n.arg):r&&P("worker sent an unknown command "+r);dt.Bc=void 0},t.onerror=t=>{throw P("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},w&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:s.mainScriptUrlOrBlob||_scriptDir,wasmMemory:$,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");dt.Yb.push(new Worker(t))},Cc:function(){return 0==dt.Yb.length&&(dt.yc(),dt.Fc(dt.Yb[0])),dt.Yb.pop()}};function ht(t){for(;0<t.length;)t.shift()(s)}function gt(t){var e=Ae();return t=t(),Ee(e),t}function bt(t){if(x)return qt(2,0,t);try{ft(t)}catch(t){t instanceof ut||"unwind"==t||y(1,t)}}s.PThread=dt,s.establishStackSpace=function(){var t=de(),e=i()[t+44>>2>>>0];t=i()[t+48>>2>>>0],Oe(e,e-t),Ee(e)};var mt=[];function yt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=q.get(t)),e}s.invokeEntryPoint=function(t,e){t=yt(t)(e),J()?dt.nc(t):Te(t)};var _t,vt,wt=[],xt=0,Tt=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){o()[this.Sb+4>>2>>>0]=t},this.bc=function(){return o()[this.Sb+4>>2>>>0]},this.wc=function(t){o()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return o()[this.Sb+8>>2>>>0]},this.rc=function(){i()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(i(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(i(),this.Sb>>2,1)},this.cc=function(t){o()[this.Sb+16>>2>>>0]=t},this.tc=function(){return o()[this.Sb+16>>2>>>0]},this.vc=function(){if(De(this.bc()))return o()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Ot(t){return ge(new St(t).Sb)}function At(t,e,n,r){return x?qt(3,1,t,e,n,r):Et(t,e,n,r)}function Et(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return P("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var i=[];return x&&0===i.length?At(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:i},x?(t.Oc="spawnThread",postMessage(t,i),0):lt(t))}function It(t,e,n){return x?qt(4,1,t,e,n):0}function Pt(t,e){if(x)return qt(5,1,t,e)}function Dt(t,e){if(x)return qt(6,1,t,e)}function $t(t,e,n){if(x)return qt(7,1,t,e,n)}function kt(t,e,n){return x?qt(8,1,t,e,n):0}function Ct(t,e){if(x)return qt(9,1,t,e)}function Ft(t,e,n){if(x)return qt(10,1,t,e,n)}function Nt(t,e,n,r){if(x)return qt(11,1,t,e,n,r)}function Lt(t,e,n,r){if(x)return qt(12,1,t,e,n,r)}function Rt(t,e,n,r){if(x)return qt(13,1,t,e,n,r)}function jt(t){if(x)return qt(14,1,t)}function Mt(t,e){if(x)return qt(15,1,t,e)}function Ut(t,e,n){if(x)return qt(16,1,t,e,n)}function Vt(t){Atomics.store(i(),t>>2,1),de()&&we(t),Atomics.compareExchange(i(),t>>2,1,0)}function Bt(t){return o()[t>>>2]+4294967296*i()[t+4>>>2]}function zt(t,e,n,r,i,o){return x?qt(17,1,t,e,n,r,i,o):-52}function Gt(t,e,n,r,i,o){if(x)return qt(18,1,t,e,n,r,i,o)}function Ht(t){var n=G(t)+1,r=he(n);return r&&z(t,e(),r,n),r}function Wt(t,e,n){function r(t){return(t=t.toTimeString().match(/\(([A-Za-z ]+)\)$/))?t[1]:"GMT"}if(x)return qt(19,1,t,e,n);var a=(new Date).getFullYear(),s=new Date(a,0,1),u=new Date(a,6,1);a=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(a,c);i()[t>>2>>>0]=60*l,i()[e>>2>>>0]=Number(a!=c),t=r(s),e=r(u),t=Ht(t),e=Ht(e),c<a?(o()[n>>2>>>0]=t,o()[n+4>>2>>>0]=e):(o()[n>>2>>>0]=e,o()[n+4>>2>>>0]=t)}function qt(t,e){var n=arguments.length-2,r=arguments;return gt((()=>{for(var i=Ie(8*n),o=i>>3,s=0;s<n;s++){var u=r[2+s];a()[o+s>>>0]=u}return ve(t,n,i,e)}))}s.executeNotifiedProxyingQueue=Vt,vt=w?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:x?()=>performance.now()-s.__performance_now_clock_drift:()=>performance.now();var Xt,Yt=[],Kt={};function Zt(){if(!Xt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Kt)void 0===Kt[t]?delete e[t]:e[t]=Kt[t];var n=[];for(t in e)n.push(t+"="+e[t]);Xt=n}return Xt}function Jt(t,n){if(x)return qt(20,1,t,n);var r=0;return Zt().forEach((function(i,a){var s=n+r;for(a=o()[t+4*a>>2>>>0]=s,s=0;s<i.length;++s)e()[a++>>0>>>0]=i.charCodeAt(s);e()[a>>0>>>0]=0,r+=i.length+1})),0}function Qt(t,e){if(x)return qt(21,1,t,e);var n=Zt();o()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),o()[e>>2>>>0]=r,0}function te(t){return x?qt(22,1,t):52}function ee(t,e,n,r){return x?qt(23,1,t,e,n,r):52}function ne(t,e,n,r,i){return x?qt(24,1,t,e,n,r,i):70}var re=[null,[],[]];function ie(t,e){var n=re[t];0===e||10===e?((1===t?I:P)(V(n,0)),n.length=0):n.push(e)}function oe(t,e,n,i){if(x)return qt(25,1,t,e,n,i);for(var a=0,s=0;s<n;s++){var u=o()[e>>2>>>0],c=o()[e+4>>2>>>0];e+=8;for(var l=0;l<c;l++)ie(t,r()[u+l>>>0]);a+=c}return o()[i>>2>>>0]=a,0}var ae=0;function se(t){return 0==t%4&&(0!=t%100||0==t%400)}var ue=[31,29,31,30,31,30,31,31,30,31,30,31],ce=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,o){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function s(t,e){return a(t,e,"0")}function u(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function c(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(se(t.getFullYear())?ue:ce)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=c(new Date(t.getFullYear(),0,4)),n=c(n),0>=u(e,t)?0>=u(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var p=i()[o+40>>2>>>0];for(var f in o={Lc:i()[o>>2>>>0],Kc:i()[o+4>>2>>>0],dc:i()[o+8>>2>>>0],jc:i()[o+12>>2>>>0],ec:i()[o+16>>2>>>0],Xb:i()[o+20>>2>>>0],Tb:i()[o+24>>2>>>0],Wb:i()[o+28>>2>>>0],Rc:i()[o+32>>2>>>0],Jc:i()[o+36>>2>>>0],Mc:p?B(p):""},r=B(r),p={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(f,"g"),p[f]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),h="January February March April May June July August September October November December".split(" ");for(f in p={"%a":function(t){return d[t.Tb].substring(0,3)},"%A":function(t){return d[t.Tb]},"%b":function(t){return h[t.ec].substring(0,3)},"%B":function(t){return h[t.ec]},"%C":function(t){return s((t.Xb+1900)/100|0,2)},"%d":function(t){return s(t.jc,2)},"%e":function(t){return a(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return s(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),s(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(se(t.Xb+1900)?ue:ce)[n++]);return s(t.jc+e,3)},"%m":function(t){return s(t.ec+1,2)},"%M":function(t){return s(t.Kc,2)},"%n":function(){return"\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return s(t.Lc,2)},"%t":function(){return"\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return s(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&se(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&se(t.Xb%400-1))&&e++}return s(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return s(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\0\0"),p)r.includes(f)&&(r=r.replace(new RegExp(f,"g"),p[f](o)));return f=function(t){var e=Array(G(t)+1);return z(t,e,0,e.length),e}(r=r.replace(/\0\0/g,"%")),f.length>n?0:(function(t,n){e().set(t,n>>>0)}(f,t),f.length-1)}dt.fc();var pe=[null,pt,bt,At,It,Pt,Dt,$t,kt,Ct,Ft,Nt,Lt,Rt,jt,Mt,Ut,zt,Gt,Wt,Jt,Qt,te,ee,ne,oe],fe={b:function(t){return he(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),xt--),t.ic(!1),wt.push(t),t.sc(),t.vc()},ma:function(t){throw P("Unexpected exception thrown, this is not properly supported - aborting"),M=!0,t},x:function(){Se(0);var t=wt.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&yt(e)(t.Zb),Ot(t.Zb)}Tt=0},e:function(){var t=Tt;if(!t)return ae=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return ae=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(Pe(o,n,e.Sb+16))return ae=o,t}return ae=n,t},l:function(){var t=Tt;if(!t)return ae=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return ae=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(Pe(o,n,e.Sb+16))return ae=o,t}return ae=n,t},h:function(){var t=Tt;if(!t)return ae=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return ae=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(Pe(o,n,e.Sb+16))return ae=o,t}return ae=n,t},t:Ot,M:function(){var t=wt.pop();t||it("no exception to throw");var e=t.Zb;throw t.kc()||(wt.push(t),t.ic(!0),t.hc(!1),xt++),Tt=e,e},c:function(t,e,n){throw new St(t).fc(e,n),Tt=t,xt++,t},pa:function(){return xt},Fa:function(t){ye(t,!v,1,!_),dt.pc()},T:function(t){x?postMessage({cmd:"cleanupThread",thread:t}):ct(t)},xa:Et,j:function(t){throw Tt||(Tt=t),t},H:It,Ma:Pt,ua:Dt,wa:$t,oa:kt,Ka:Ct,Ca:Ft,Ja:Nt,V:Lt,va:Rt,sa:jt,La:Mt,ta:Ut,Ta:function(){},X:function(){it("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){it("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>Vt(r)));else if(x)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=dt.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Bt(t)),i()[e>>2>>>0]=t.getUTCSeconds(),i()[e+4>>2>>>0]=t.getUTCMinutes(),i()[e+8>>2>>>0]=t.getUTCHours(),i()[e+12>>2>>>0]=t.getUTCDate(),i()[e+16>>2>>>0]=t.getUTCMonth(),i()[e+20>>2>>>0]=t.getUTCFullYear()-1900,i()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,i()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Bt(t)),i()[e>>2>>>0]=t.getSeconds(),i()[e+4>>2>>>0]=t.getMinutes(),i()[e+8>>2>>>0]=t.getHours(),i()[e+12>>2>>>0]=t.getDate(),i()[e+16>>2>>>0]=t.getMonth(),i()[e+20>>2>>>0]=t.getFullYear()-1900,i()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;i()[e+28>>2>>>0]=r,i()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),i()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(i()[t+20>>2>>>0]+1900,i()[t+16>>2>>>0],i()[t+12>>2>>>0],i()[t+8>>2>>>0],i()[t+4>>2>>>0],i()[t>>2>>>0],0),n=i()[t+32>>2>>>0],r=e.getTimezoneOffset(),o=new Date(e.getFullYear(),0,1),a=new Date(e.getFullYear(),6,1).getTimezoneOffset(),s=o.getTimezoneOffset(),u=Math.min(s,a);return 0>n?i()[t+32>>2>>>0]=Number(a!=s&&u==r):0<n!=(u==r)&&(a=Math.max(s,a),e.setTime(e.getTime()+6e4*((0<n?u:a)-r))),i()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-o.getTime())/864e5|0,i()[t+28>>2>>>0]=n,i()[t>>2>>>0]=e.getSeconds(),i()[t+4>>2>>>0]=e.getMinutes(),i()[t+8>>2>>>0]=e.getHours(),i()[t+12>>2>>>0]=e.getDate(),i()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:zt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Wt(e,n,r))},y:function(){it("")},U:function(){if(!w&&!v){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";_t||(_t={}),_t[t]||(_t[t]=1,w&&(t="warning: "+t),P(t))}},ra:function(){return 4294901760},B:vt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return w?n(3993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Yt.length=e,n>>=3;for(var r=0;r<e;r++)Yt[r]=a()[n+r>>>0];return(0>t?st[-t-1]:pe[t]).apply(null,Yt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var i=e*(1+.2/n);i=Math.min(i,t+100663296);var o=Math;i=Math.max(t,i),o=o.min.call(o,4294901760,i+(65536-i%65536)%65536);t:{try{$.grow(o-C.byteLength+65535>>>16),H($.buffer);var a=1;break t}catch(t){}a=void 0}if(a)return!0}return!1},Na:function(){throw"unwind"},Ga:Jt,Ha:Qt,J:ft,I:te,S:ee,ga:ne,R:oe,d:function(){return ae},na:function t(r,i){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(w)try{var e=n(Object(function(){var t=new Error("Cannot find module 'crypto'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>it("randomDevice")}());for(var o=0;o<i;o++)e()[r+o>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ae();try{return yt(t)()}catch(t){if(Ee(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ae();try{return yt(t)(e)}catch(t){if(Ee(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var i=Ae();try{return yt(t)(e,n,r)}catch(t){if(Ee(i),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,i){var o=Ae();try{return yt(t)(e,n,r,i)}catch(t){if(Ee(o),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,i,o){var a=Ae();try{return yt(t)(e,n,r,i,o)}catch(t){if(Ee(a),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,i,o){var a=Ae();try{return yt(t)(e,n,r,i,o)}catch(t){if(Ee(a),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,i,o,a){var s=Ae();try{return yt(t)(e,n,r,i,o,a)}catch(t){if(Ee(s),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,i,o,a,s){var u=Ae();try{return yt(t)(e,n,r,i,o,a,s)}catch(t){if(Ee(u),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,i,o,a,s,u,c,l,p){var f=Ae();try{return yt(t)(e,n,r,i,o,a,s,u,c,l,p)}catch(t){if(Ee(f),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,i,o,a,s){var u=Ae();try{return Me(t,e,n,r,i,o,a,s)}catch(t){if(Ee(u),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,i,o,a){var s=Ae();try{return ke(t,e,n,r,i,o,a)}catch(t){if(Ee(s),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,i){var o=Ae();try{return Ue(t,e,n,r,i)}catch(t){if(Ee(o),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var i=Ae();try{return Re(t,e,n,r)}catch(t){if(Ee(i),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ae();try{return $e(t)}catch(t){if(Ee(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ae();try{return je(t,e)}catch(t){if(Ee(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ae();try{return Ce(t,e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ae();try{yt(t)()}catch(t){if(Ee(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ae();try{yt(t)(e)}catch(t){if(Ee(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ae();try{yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var i=Ae();try{yt(t)(e,n,r)}catch(t){if(Ee(i),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var i=Ae();try{yt(t)(e,n,r)}catch(t){if(Ee(i),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,i){var o=Ae();try{yt(t)(e,n,r,i)}catch(t){if(Ee(o),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,i,o){var a=Ae();try{yt(t)(e,n,r,i,o)}catch(t){if(Ee(a),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,i,o,a){var s=Ae();try{yt(t)(e,n,r,i,o,a)}catch(t){if(Ee(s),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,i,o,a,s){var u=Ae();try{yt(t)(e,n,r,i,o,a,s)}catch(t){if(Ee(u),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,i,o,a,s,u){var c=Ae();try{yt(t)(e,n,r,i,o,a,s,u)}catch(t){if(Ee(c),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,i,o,a,s,u,c,l){var p=Ae();try{yt(t)(e,n,r,i,o,a,s,u,c,l)}catch(t){if(Ee(p),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,i,o,a,s,u,c,l,p,f,d,h,g){var b=Ae();try{yt(t)(e,n,r,i,o,a,s,u,c,l,p,f,d,h,g)}catch(t){if(Ee(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,i,o,a,s){var u=Ae();try{Fe(t,e,n,r,i,o,a,s)}catch(t){if(Ee(u),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,i,o,a,s,u,c,l,p){var f=Ae();try{Le(t,e,n,r,i,o,a,s,u,c,l,p)}catch(t){if(Ee(f),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,i,o){var a=Ae();try{Ne(t,e,n,r,i,o)}catch(t){if(Ee(a),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:$||s.wasmMemory,G:function(t){ae=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){s.asm=t.exports,dt.qc.push(s.asm.sb),q=s.asm.ub,Y.unshift(s.asm.Va),k=e,x||(et--,s.monitorRunDependencies&&s.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!E&&(_||v)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at '"+tt+"'";return t.arrayBuffer()})).catch((function(){return at()}));if(p)return new Promise((function(t,e){p(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return at()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){P("failed to asynchronously prepare wasm: "+t),it(t)}))}var r={a:fe};if(x||(et++,s.monitorRunDependencies&&s.monitorRunDependencies(et)),s.instantiateWasm)try{return s.instantiateWasm(r,t)}catch(t){return P("Module.instantiateWasm callback failed with error: "+t),!1}(E||"function"!=typeof WebAssembly.instantiateStreaming||ot()||tt.startsWith("file://")||w||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return P("wasm streaming compile failed: "+t),P("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(c)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.Va).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.Wa).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.Xa).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.Ya).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.Za).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm._a).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.$a).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.ab).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.bb).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.cb).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm.db).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.eb).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.fb).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.gb).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.hb).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.ib).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.jb).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.kb).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.lb).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.mb).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.nb).apply(null,arguments)};var de=s._pthread_self=function(){return(de=s._pthread_self=s.asm.ob).apply(null,arguments)},he=s._malloc=function(){return(he=s._malloc=s.asm.pb).apply(null,arguments)},ge=s._free=function(){return(ge=s._free=s.asm.qb).apply(null,arguments)},be=s._fflush=function(){return(be=s._fflush=s.asm.rb).apply(null,arguments)};s.__emscripten_tls_init=function(){return(s.__emscripten_tls_init=s.asm.sb).apply(null,arguments)};var me=s.___funcs_on_exit=function(){return(me=s.___funcs_on_exit=s.asm.tb).apply(null,arguments)},ye=s.__emscripten_thread_init=function(){return(ye=s.__emscripten_thread_init=s.asm.vb).apply(null,arguments)};s.__emscripten_thread_crashed=function(){return(s.__emscripten_thread_crashed=s.asm.wb).apply(null,arguments)};var _e,ve=s._emscripten_run_in_main_runtime_thread_js=function(){return(ve=s._emscripten_run_in_main_runtime_thread_js=s.asm.xb).apply(null,arguments)},we=s.__emscripten_proxy_execute_task_queue=function(){return(we=s.__emscripten_proxy_execute_task_queue=s.asm.yb).apply(null,arguments)},xe=s.__emscripten_thread_free_data=function(){return(xe=s.__emscripten_thread_free_data=s.asm.zb).apply(null,arguments)},Te=s.__emscripten_thread_exit=function(){return(Te=s.__emscripten_thread_exit=s.asm.Ab).apply(null,arguments)},Se=s._setThrew=function(){return(Se=s._setThrew=s.asm.Bb).apply(null,arguments)},Oe=s._emscripten_stack_set_limits=function(){return(Oe=s._emscripten_stack_set_limits=s.asm.Cb).apply(null,arguments)},Ae=s.stackSave=function(){return(Ae=s.stackSave=s.asm.Db).apply(null,arguments)},Ee=s.stackRestore=function(){return(Ee=s.stackRestore=s.asm.Eb).apply(null,arguments)},Ie=s.stackAlloc=function(){return(Ie=s.stackAlloc=s.asm.Fb).apply(null,arguments)},Pe=s.___cxa_can_catch=function(){return(Pe=s.___cxa_can_catch=s.asm.Gb).apply(null,arguments)},De=s.___cxa_is_pointer_type=function(){return(De=s.___cxa_is_pointer_type=s.asm.Hb).apply(null,arguments)},$e=s.dynCall_j=function(){return($e=s.dynCall_j=s.asm.Ib).apply(null,arguments)},ke=s.dynCall_iiiiij=function(){return(ke=s.dynCall_iiiiij=s.asm.Jb).apply(null,arguments)},Ce=s.dynCall_jii=function(){return(Ce=s.dynCall_jii=s.asm.Kb).apply(null,arguments)},Fe=s.dynCall_viiiiij=function(){return(Fe=s.dynCall_viiiiij=s.asm.Lb).apply(null,arguments)},Ne=s.dynCall_vjji=function(){return(Ne=s.dynCall_vjji=s.asm.Mb).apply(null,arguments)},Le=s.dynCall_viiijjjii=function(){return(Le=s.dynCall_viiijjjii=s.asm.Nb).apply(null,arguments)},Re=s.dynCall_iij=function(){return(Re=s.dynCall_iij=s.asm.Ob).apply(null,arguments)},je=s.dynCall_ji=function(){return(je=s.dynCall_ji=s.asm.Pb).apply(null,arguments)},Me=s.dynCall_iiiiiij=function(){return(Me=s.dynCall_iiiiiij=s.asm.Qb).apply(null,arguments)},Ue=s.dynCall_iiij=function(){return(Ue=s.dynCall_iiij=s.asm.Rb).apply(null,arguments)};function Ve(){function t(){if(!_e&&(_e=!0,s.calledRun=!0,!M)&&(x||ht(Y),u(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!x)){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;){var t=s.postRun.shift();Z.unshift(t)}ht(Z)}}if(!(0<et))if(x)u(s),x||ht(Y),postMessage({cmd:"loaded"});else{if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)Q();ht(X),0<et||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),t()}),1)):t())}}if(s.UTF8ToString=B,s.stringToUTF8=function(t,e,n){return z(t,r(),e,n)},s.lengthBytesUTF8=G,s.keepRuntimeAlive=J,s.wasmMemory=$,s.stackSave=Ae,s.stackRestore=Ee,s.stackAlloc=Ie,s.ExitStatus=ut,s.PThread=dt,rt=function t(){_e||Ve(),_e||(rt=t)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return Ve(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,i;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,i=e}));var o,a,s,u,c,l,p=Object.assign({},e),f="./this.program",d=(t,e)=>{throw e},h="object"==typeof window,g="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=g?n(908).dirname(m)+"/":"//",l=()=>{c||(u=n(1384),c=n(908))},o=function(t,e){return l(),t=c.normalize(t),u.readFileSync(t,e?void 0:"utf8")},s=t=>((t=o(t,!0)).buffer||(t=new Uint8Array(t)),t),a=(t,e,n)=>{l(),t=c.normalize(t),u.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(f=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof K))throw t})),process.on("unhandledRejection",(function(t){throw t})),d=(t,e)=>{if(w||0<U)throw process.exitCode=t,e;e instanceof K||v("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(h||g)&&(g?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},g&&(s=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),a=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var y,_=e.print||console.log.bind(console),v=e.printErr||console.warn.bind(console);Object.assign(e,p),p=null,e.thisProgram&&(f=e.thisProgram),e.quit&&(d=e.quit),e.wasmBinary&&(y=e.wasmBinary);var w=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&W("no native wasm support detected");var x,T,S,O,A,E,I=!1,P="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function D(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&P)return P.decode(t.subarray(e,n));for(r="";e<n;){var i=t[e++];if(128&i){var o=63&t[e++];if(192==(224&i))r+=String.fromCharCode((31&i)<<6|o);else{var a=63&t[e++];65536>(i=224==(240&i)?(15&i)<<12|o<<6|a:(7&i)<<18|o<<12|a<<6|63&t[e++])?r+=String.fromCharCode(i):(i-=65536,r+=String.fromCharCode(55296|i>>10,56320|1023&i))}}else r+=String.fromCharCode(i)}return r}function $(t,e){return(t>>>=0)?D(O,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var i=n>>>=0;r=n+r-1;for(var o=0;o<t.length;++o){var a=t.charCodeAt(o);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&t.charCodeAt(++o)),127>=a){if(n>=r)break;e[n++>>>0]=a}else{if(2047>=a){if(n+1>=r)break;e[n++>>>0]=192|a>>6}else{if(65535>=a){if(n+2>=r)break;e[n++>>>0]=224|a>>12}else{if(n+3>=r)break;e[n++>>>0]=240|a>>18,e[n++>>>0]=128|a>>12&63}e[n++>>>0]=128|a>>6&63}e[n++>>>0]=128|63&a}}return e[n>>>0]=0,n-i}function C(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function F(){var t=x.buffer;T=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=A=new Int32Array(t),e.HEAPU8=O=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=E=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var N,L=[],R=[],j=[],M=[],U=0;function V(){var t=e.preRun.shift();L.unshift(t)}var B,z=0,G=null,H=null;function W(t){throw e.onAbort&&e.onAbort(t),v(t="Aborted("+t+")"),I=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),i(t),t}function q(){return B.startsWith("data:application/octet-stream;base64,")}if(B="ort-wasm.wasm",!q()){var X=B;B=e.locateFile?e.locateFile(X,m):m+X}function Y(){var t=B;try{if(t==B&&y)return new Uint8Array(y);if(s)return s(t);throw"both async and sync fetching of the wasm failed"}catch(t){W(t)}}function K(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var J=[],Q=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){E[this.zb+4>>2>>>0]=t},this.Eb=function(){return E[this.zb+4>>2>>>0]},this.Sb=function(t){E[this.zb+8>>2>>>0]=t},this.Wb=function(){return E[this.zb+8>>2>>>0]},this.Tb=function(){A[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){A[this.zb>>2>>>0]+=1},this.Xb=function(){var t=A[this.zb>>2>>>0];return A[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){E[this.zb+16>>2>>>0]=t},this.Ob=function(){return E[this.zb+16>>2>>>0]},this.Qb=function(){if(Et(this.Eb()))return E[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return _t(new et(t).zb)}var rt=[];function it(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=N.get(t)),e}function ot(t){var e=C(t)+1,n=yt(e);return n&&k(t,S,n,e),n}var at={};function st(){if(!ut){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:f||"./this.program"};for(t in at)void 0===at[t]?delete e[t]:e[t]=at[t];var n=[];for(t in e)n.push(t+"="+e[t]);ut=n}return ut}var ut,ct=[null,[],[]];function lt(t,e){var n=ct[t];0===e||10===e?((1===t?_:v)(D(n,0)),n.length=0):n.push(e)}var pt=0;function ft(t){return 0==t%4&&(0!=t%100||0==t%400)}var dt=[31,29,31,30,31,30,31,31,30,31,30,31],ht=[31,28,31,30,31,30,31,31,30,31,30,31];function gt(t,e,n,r){function i(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function o(t,e){return i(t,e,"0")}function a(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function u(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ft(t.getFullYear())?dt:ht)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=a(e,t)?0>=a(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var c=A[r+40>>2>>>0];for(var l in r={$b:A[r>>2>>>0],Zb:A[r+4>>2>>>0],Gb:A[r+8>>2>>>0],Kb:A[r+12>>2>>>0],Hb:A[r+16>>2>>>0],Cb:A[r+20>>2>>>0],Ab:A[r+24>>2>>>0],Bb:A[r+28>>2>>>0],bc:A[r+32>>2>>>0],Yb:A[r+36>>2>>>0],ac:c?$(c):""},n=$(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),c[l]);var p="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),f="January February March April May June July August September October November December".split(" ");for(l in c={"%a":function(t){return p[t.Ab].substring(0,3)},"%A":function(t){return p[t.Ab]},"%b":function(t){return f[t.Hb].substring(0,3)},"%B":function(t){return f[t.Hb]},"%C":function(t){return o((t.Cb+1900)/100|0,2)},"%d":function(t){return o(t.Kb,2)},"%e":function(t){return i(t.Kb,2," ")},"%g":function(t){return u(t).toString().substring(2)},"%G":function(t){return u(t)},"%H":function(t){return o(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),o(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(ft(t.Cb+1900)?dt:ht)[n++]);return o(t.Kb+e,3)},"%m":function(t){return o(t.Hb+1,2)},"%M":function(t){return o(t.Zb,2)},"%n":function(){return"\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return o(t.$b,2)},"%t":function(){return"\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return o(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&ft(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&ft(t.Cb%400-1))&&e++}return o(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return o(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\0\0"),c)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),c[l](r)));return l=function(t){var e=Array(C(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\0\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return yt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),Q--),t.Jb(!1),J.push(t),t.Nb(),t.Qb()},ia:function(t){throw v("Unexpected exception thrown, this is not properly supported - aborting"),I=!0,t},w:function(){xt(0);var t=J.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&it(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return pt=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return pt=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(At(o,n,e.zb+16))return pt=o,t}return pt=n,t},k:function(){var t=tt;if(!t)return pt=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return pt=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(At(o,n,e.zb+16))return pt=o,t}return pt=n,t},g:function(){var t=tt;if(!t)return pt=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return pt=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(At(o,n,e.zb+16))return pt=o,t}return pt=n,t},s:nt,L:function(){var t=J.pop();t||W("no exception to throw");var e=t.Db;throw t.Lb()||(J.push(t),t.Jb(!0),t.Ib(!1),Q++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,Q++,t},la:function(){return Q},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){W("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){W("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(E[t>>>2]+4294967296*A[t+4>>>2])),A[e>>2>>>0]=t.getUTCSeconds(),A[e+4>>2>>>0]=t.getUTCMinutes(),A[e+8>>2>>>0]=t.getUTCHours(),A[e+12>>2>>>0]=t.getUTCDate(),A[e+16>>2>>>0]=t.getUTCMonth(),A[e+20>>2>>>0]=t.getUTCFullYear()-1900,A[e+24>>2>>>0]=t.getUTCDay(),A[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(E[t>>>2]+4294967296*A[t+4>>>2])),A[e>>2>>>0]=t.getSeconds(),A[e+4>>2>>>0]=t.getMinutes(),A[e+8>>2>>>0]=t.getHours(),A[e+12>>2>>>0]=t.getDate(),A[e+16>>2>>>0]=t.getMonth(),A[e+20>>2>>>0]=t.getFullYear()-1900,A[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);A[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,A[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),A[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(A[t+20>>2>>>0]+1900,A[t+16>>2>>>0],A[t+12>>2>>>0],A[t+8>>2>>>0],A[t+4>>2>>>0],A[t>>2>>>0],0),n=A[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),a=i.getTimezoneOffset(),s=Math.min(a,o);return 0>n?A[t+32>>2>>>0]=Number(o!=a&&s==r):0<n!=(s==r)&&(o=Math.max(a,o),e.setTime(e.getTime()+6e4*((0<n?s:o)-r))),A[t+24>>2>>>0]=e.getDay(),A[t+28>>2>>>0]=(e.getTime()-i.getTime())/864e5|0,A[t>>2>>>0]=e.getSeconds(),A[t+4>>2>>>0]=e.getMinutes(),A[t+8>>2>>>0]=e.getHours(),A[t+12>>2>>>0]=e.getDate(),A[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\(([A-Za-z ]+)\)$/))?t[1]:"GMT"}var i=(new Date).getFullYear(),o=new Date(i,0,1),a=new Date(i,6,1);i=o.getTimezoneOffset();var s=a.getTimezoneOffset();A[t>>2>>>0]=60*Math.max(i,s),A[e>>2>>>0]=Number(i!=s),t=r(o),e=r(a),t=ot(t),e=ot(e),s<i?(E[n>>2>>>0]=t,E[n+4>>2>>>0]=e):(E[n>>2>>>0]=e,E[n+4>>2>>>0]=t)}(e,n,r))},B:function(){W("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){O.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=O.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var i=Math;r=Math.max(t,r),i=i.min.call(i,4294901760,r+(65536-r%65536)%65536);t:{try{x.grow(i-T.byteLength+65535>>>16),F();var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},va:function(t,e){var n=0;return st().forEach((function(r,i){var o=e+n;for(i=E[t+4*i>>2>>>0]=o,o=0;o<r.length;++o)S[i++>>0>>>0]=r.charCodeAt(o);S[i>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=st();E[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),E[e>>2>>>0]=r,0},ba:function(t){w||0<U||(wt(),Z(j),vt(0),ct[1].length&&lt(1,10),ct[2].length&&lt(2,10)),w||0<U||(e.onExit&&e.onExit(t),I=!0),d(t,new K(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var i=0,o=0;o<n;o++){var a=E[e>>2>>>0],s=E[e+4>>2>>>0];e+=8;for(var u=0;u<s;u++)lt(t,O[a+u>>>0]);i+=s}return E[r>>2>>>0]=i,0},c:function(){return pt},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module 'crypto'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>W("randomDevice")}());for(var i=0;i<r;i++)S[e+i>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},fa:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},J:function(t){var e=Tt();try{return it(t)()}catch(t){if(St(e),t!==t+0)throw t;xt(1,0)}},e:function(t,e){var n=Tt();try{return it(t)(e)}catch(t){if(St(n),t!==t+0)throw t;xt(1,0)}},N:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},O:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},j:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},o:function(t,e,n,r){var i=Tt();try{return it(t)(e,n,r)}catch(t){if(St(i),t!==t+0)throw t;xt(1,0)}},p:function(t,e,n,r,i){var o=Tt();try{return it(t)(e,n,r,i)}catch(t){if(St(o),t!==t+0)throw t;xt(1,0)}},M:function(t,e,n,r,i,o){var a=Tt();try{return it(t)(e,n,r,i,o)}catch(t){if(St(a),t!==t+0)throw t;xt(1,0)}},r:function(t,e,n,r,i,o){var a=Tt();try{return it(t)(e,n,r,i,o)}catch(t){if(St(a),t!==t+0)throw t;xt(1,0)}},v:function(t,e,n,r,i,o,a){var s=Tt();try{return it(t)(e,n,r,i,o,a)}catch(t){if(St(s),t!==t+0)throw t;xt(1,0)}},K:function(t,e,n,r,i,o,a,s){var u=Tt();try{return it(t)(e,n,r,i,o,a,s)}catch(t){if(St(u),t!==t+0)throw t;xt(1,0)}},D:function(t,e,n,r,i,o,a,s,u,c,l,p){var f=Tt();try{return it(t)(e,n,r,i,o,a,s,u,c,l,p)}catch(t){if(St(f),t!==t+0)throw t;xt(1,0)}},X:function(t,e,n,r,i,o,a,s){var u=Tt();try{return Lt(t,e,n,r,i,o,a,s)}catch(t){if(St(u),t!==t+0)throw t;xt(1,0)}},V:function(t,e,n,r,i,o,a){var s=Tt();try{return Pt(t,e,n,r,i,o,a)}catch(t){if(St(s),t!==t+0)throw t;xt(1,0)}},U:function(t,e,n,r,i){var o=Tt();try{return Rt(t,e,n,r,i)}catch(t){if(St(o),t!==t+0)throw t;xt(1,0)}},Z:function(t,e,n,r){var i=Tt();try{return Ft(t,e,n,r)}catch(t){if(St(i),t!==t+0)throw t;xt(1,0)}},W:function(t){var e=Tt();try{return It(t)}catch(t){if(St(e),t!==t+0)throw t;xt(1,0)}},Y:function(t,e){var n=Tt();try{return Nt(t,e)}catch(t){if(St(n),t!==t+0)throw t;xt(1,0)}},T:function(t,e,n){var r=Tt();try{return Dt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},f:function(t){var e=Tt();try{it(t)()}catch(t){if(St(e),t!==t+0)throw t;xt(1,0)}},q:function(t,e){var n=Tt();try{it(t)(e)}catch(t){if(St(n),t!==t+0)throw t;xt(1,0)}},h:function(t,e,n){var r=Tt();try{it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},da:function(t,e,n,r){var i=Tt();try{it(t)(e,n,r)}catch(t){if(St(i),t!==t+0)throw t;xt(1,0)}},l:function(t,e,n,r){var i=Tt();try{it(t)(e,n,r)}catch(t){if(St(i),t!==t+0)throw t;xt(1,0)}},t:function(t,e,n,r,i){var o=Tt();try{it(t)(e,n,r,i)}catch(t){if(St(o),t!==t+0)throw t;xt(1,0)}},u:function(t,e,n,r,i,o){var a=Tt();try{it(t)(e,n,r,i,o)}catch(t){if(St(a),t!==t+0)throw t;xt(1,0)}},x:function(t,e,n,r,i,o,a){var s=Tt();try{it(t)(e,n,r,i,o,a)}catch(t){if(St(s),t!==t+0)throw t;xt(1,0)}},z:function(t,e,n,r,i,o,a,s){var u=Tt();try{it(t)(e,n,r,i,o,a,s)}catch(t){if(St(u),t!==t+0)throw t;xt(1,0)}},ga:function(t,e,n,r,i,o,a,s,u){var c=Tt();try{it(t)(e,n,r,i,o,a,s,u)}catch(t){if(St(c),t!==t+0)throw t;xt(1,0)}},A:function(t,e,n,r,i,o,a,s,u,c,l){var p=Tt();try{it(t)(e,n,r,i,o,a,s,u,c,l)}catch(t){if(St(p),t!==t+0)throw t;xt(1,0)}},C:function(t,e,n,r,i,o,a,s,u,c,l,p,f,d,h,g){var b=Tt();try{it(t)(e,n,r,i,o,a,s,u,c,l,p,f,d,h,g)}catch(t){if(St(b),t!==t+0)throw t;xt(1,0)}},aa:function(t,e,n,r,i,o,a,s){var u=Tt();try{$t(t,e,n,r,i,o,a,s)}catch(t){if(St(u),t!==t+0)throw t;xt(1,0)}},_:function(t,e,n,r,i,o,a,s,u,c,l,p){var f=Tt();try{Ct(t,e,n,r,i,o,a,s,u,c,l,p)}catch(t){if(St(f),t!==t+0)throw t;xt(1,0)}},$:function(t,e,n,r,i,o){var a=Tt();try{kt(t,e,n,r,i,o)}catch(t){if(St(a),t!==t+0)throw t;xt(1,0)}},n:function(t){return t},F:function(t){pt=t},ha:gt,y:function(t,e,n,r){return gt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,x=e.asm.Ka,F(),N=e.asm.ib,R.unshift(e.asm.La),z--,e.monitorRunDependencies&&e.monitorRunDependencies(z),0==z&&(null!==G&&(clearInterval(G),G=null),H&&(t=H,H=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!y&&(h||g)){if("function"==typeof fetch&&!B.startsWith("file://"))return fetch(B,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at '"+B+"'";return t.arrayBuffer()})).catch((function(){return Y()}));if(a)return new Promise((function(t,e){a(B,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return Y()}))}().then((function(t){return WebAssembly.instantiate(t,o)})).then((function(t){return t})).then(t,(function(t){v("failed to asynchronously prepare wasm: "+t),W(t)}))}var o={a:bt};if(z++,e.monitorRunDependencies&&e.monitorRunDependencies(z),e.instantiateWasm)try{return e.instantiateWasm(o,t)}catch(t){return v("Module.instantiateWasm callback failed with error: "+t),!1}(y||"function"!=typeof WebAssembly.instantiateStreaming||q()||B.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(B,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,o).then(n,(function(t){return v("wasm streaming compile failed: "+t),v("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(i)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,yt=e._malloc=function(){return(yt=e._malloc=e.asm.eb).apply(null,arguments)},_t=e._free=function(){return(_t=e._free=e.asm.fb).apply(null,arguments)},vt=e._fflush=function(){return(vt=e._fflush=e.asm.gb).apply(null,arguments)},wt=e.___funcs_on_exit=function(){return(wt=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},xt=e._setThrew=function(){return(xt=e._setThrew=e.asm.jb).apply(null,arguments)},Tt=e.stackSave=function(){return(Tt=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Ot=e.stackAlloc=function(){return(Ot=e.stackAlloc=e.asm.mb).apply(null,arguments)},At=e.___cxa_can_catch=function(){return(At=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Et=e.___cxa_is_pointer_type=function(){return(Et=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},It=e.dynCall_j=function(){return(It=e.dynCall_j=e.asm.pb).apply(null,arguments)},Pt=e.dynCall_iiiiij=function(){return(Pt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Dt=e.dynCall_jii=function(){return(Dt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},$t=e.dynCall_viiiiij=function(){return($t=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Ct=e.dynCall_viiijjjii=function(){return(Ct=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Ft=e.dynCall_iij=function(){return(Ft=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Nt=e.dynCall_ji=function(){return(Nt=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Lt=e.dynCall_iiiiiij=function(){return(Lt=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},Rt=e.dynCall_iiij=function(){return(Rt=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function jt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!I)){if(Z(R),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();M.unshift(t)}Z(M)}}if(!(0<z)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)V();Z(L),0<z||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=$,e.stringToUTF8=function(t,e,n){return k(t,O,e,n)},e.lengthBytesUTF8=C,e.stackSave=Tt,e.stackRestore=St,e.stackAlloc=Ot,H=function t(){mt||jt(),mt||(H=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return jt(),t.ready});t.exports=r},4537:t=>{"use strict";t.exports=function(t,e){for(var n=new Array(arguments.length-1),r=0,i=2,o=!0;i<arguments.length;)n[r++]=arguments[i++];return new Promise((function(i,a){n[r]=function(t){if(o)if(o=!1,t)a(t);else{for(var e=new Array(arguments.length-1),n=0;n<e.length;)e[n++]=arguments[n];i.apply(null,e)}};try{t.apply(e||null,n)}catch(t){o&&(o=!1,a(t))}}))}},7419:(t,e)=>{"use strict";var n=e;n.length=function(t){var e=t.length;if(!e)return 0;for(var n=0;--e%4>1&&"="===t.charAt(e);)++n;return Math.ceil(3*t.length)/4-n};for(var r=new Array(64),i=new Array(123),o=0;o<64;)i[r[o]=o<26?o+65:o<52?o+71:o<62?o-4:o-59|43]=o++;n.encode=function(t,e,n){for(var i,o=null,a=[],s=0,u=0;e<n;){var c=t[e++];switch(u){case 0:a[s++]=r[c>>2],i=(3&c)<<4,u=1;break;case 1:a[s++]=r[i|c>>4],i=(15&c)<<2,u=2;break;case 2:a[s++]=r[i|c>>6],a[s++]=r[63&c],u=0}s>8191&&((o||(o=[])).push(String.fromCharCode.apply(String,a)),s=0)}return u&&(a[s++]=r[i],a[s++]=61,1===u&&(a[s++]=61)),o?(s&&o.push(String.fromCharCode.apply(String,a.slice(0,s))),o.join("")):String.fromCharCode.apply(String,a.slice(0,s))};var a="invalid encoding";n.decode=function(t,e,n){for(var r,o=n,s=0,u=0;u<t.length;){var c=t.charCodeAt(u++);if(61===c&&s>1)break;if(void 0===(c=i[c]))throw Error(a);switch(s){case 0:r=c,s=1;break;case 1:e[n++]=r<<2|(48&c)>>4,r=c,s=2;break;case 2:e[n++]=(15&r)<<4|(60&c)>>2,r=c,s=3;break;case 3:e[n++]=(3&r)<<6|c,s=0}}if(1===s)throw Error(a);return n-o},n.test=function(t){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t)}},9211:t=>{"use strict";function e(){this._listeners={}}t.exports=e,e.prototype.on=function(t,e,n){return(this._listeners[t]||(this._listeners[t]=[])).push({fn:e,ctx:n||this}),this},e.prototype.off=function(t,e){if(void 0===t)this._listeners={};else if(void 0===e)this._listeners[t]=[];else for(var n=this._listeners[t],r=0;r<n.length;)n[r].fn===e?n.splice(r,1):++r;return this},e.prototype.emit=function(t){var e=this._listeners[t];if(e){for(var n=[],r=1;r<arguments.length;)n.push(arguments[r++]);for(r=0;r<e.length;)e[r].fn.apply(e[r++].ctx,n)}return this}},945:t=>{"use strict";function e(t){return"undefined"!=typeof Float32Array?function(){var e=new Float32Array([-0]),n=new Uint8Array(e.buffer),r=128===n[3];function i(t,r,i){e[0]=t,r[i]=n[0],r[i+1]=n[1],r[i+2]=n[2],r[i+3]=n[3]}function o(t,r,i){e[0]=t,r[i]=n[3],r[i+1]=n[2],r[i+2]=n[1],r[i+3]=n[0]}function a(t,r){return n[0]=t[r],n[1]=t[r+1],n[2]=t[r+2],n[3]=t[r+3],e[0]}function s(t,r){return n[3]=t[r],n[2]=t[r+1],n[1]=t[r+2],n[0]=t[r+3],e[0]}t.writeFloatLE=r?i:o,t.writeFloatBE=r?o:i,t.readFloatLE=r?a:s,t.readFloatBE=r?s:a}():function(){function e(t,e,n,r){var i=e<0?1:0;if(i&&(e=-e),0===e)t(1/e>0?0:2147483648,n,r);else if(isNaN(e))t(2143289344,n,r);else if(e>34028234663852886e22)t((i<<31|2139095040)>>>0,n,r);else if(e<11754943508222875e-54)t((i<<31|Math.round(e/1401298464324817e-60))>>>0,n,r);else{var o=Math.floor(Math.log(e)/Math.LN2);t((i<<31|o+127<<23|8388607&Math.round(e*Math.pow(2,-o)*8388608))>>>0,n,r)}}function a(t,e,n){var r=t(e,n),i=2*(r>>31)+1,o=r>>>23&255,a=8388607&r;return 255===o?a?NaN:i*(1/0):0===o?1401298464324817e-60*i*a:i*Math.pow(2,o-150)*(a+8388608)}t.writeFloatLE=e.bind(null,n),t.writeFloatBE=e.bind(null,r),t.readFloatLE=a.bind(null,i),t.readFloatBE=a.bind(null,o)}(),"undefined"!=typeof Float64Array?function(){var e=new Float64Array([-0]),n=new Uint8Array(e.buffer),r=128===n[7];function i(t,r,i){e[0]=t,r[i]=n[0],r[i+1]=n[1],r[i+2]=n[2],r[i+3]=n[3],r[i+4]=n[4],r[i+5]=n[5],r[i+6]=n[6],r[i+7]=n[7]}function o(t,r,i){e[0]=t,r[i]=n[7],r[i+1]=n[6],r[i+2]=n[5],r[i+3]=n[4],r[i+4]=n[3],r[i+5]=n[2],r[i+6]=n[1],r[i+7]=n[0]}function a(t,r){return n[0]=t[r],n[1]=t[r+1],n[2]=t[r+2],n[3]=t[r+3],n[4]=t[r+4],n[5]=t[r+5],n[6]=t[r+6],n[7]=t[r+7],e[0]}function s(t,r){return n[7]=t[r],n[6]=t[r+1],n[5]=t[r+2],n[4]=t[r+3],n[3]=t[r+4],n[2]=t[r+5],n[1]=t[r+6],n[0]=t[r+7],e[0]}t.writeDoubleLE=r?i:o,t.writeDoubleBE=r?o:i,t.readDoubleLE=r?a:s,t.readDoubleBE=r?s:a}():function(){function e(t,e,n,r,i,o){var a=r<0?1:0;if(a&&(r=-r),0===r)t(0,i,o+e),t(1/r>0?0:2147483648,i,o+n);else if(isNaN(r))t(0,i,o+e),t(2146959360,i,o+n);else if(r>17976931348623157e292)t(0,i,o+e),t((a<<31|2146435072)>>>0,i,o+n);else{var s;if(r<22250738585072014e-324)t((s=r/5e-324)>>>0,i,o+e),t((a<<31|s/4294967296)>>>0,i,o+n);else{var u=Math.floor(Math.log(r)/Math.LN2);1024===u&&(u=1023),t(4503599627370496*(s=r*Math.pow(2,-u))>>>0,i,o+e),t((a<<31|u+1023<<20|1048576*s&1048575)>>>0,i,o+n)}}}function a(t,e,n,r,i){var o=t(r,i+e),a=t(r,i+n),s=2*(a>>31)+1,u=a>>>20&2047,c=4294967296*(1048575&a)+o;return 2047===u?c?NaN:s*(1/0):0===u?5e-324*s*c:s*Math.pow(2,u-1075)*(c+4503599627370496)}t.writeDoubleLE=e.bind(null,n,0,4),t.writeDoubleBE=e.bind(null,r,4,0),t.readDoubleLE=a.bind(null,i,0,4),t.readDoubleBE=a.bind(null,o,4,0)}(),t}function n(t,e,n){e[n]=255&t,e[n+1]=t>>>8&255,e[n+2]=t>>>16&255,e[n+3]=t>>>24}function r(t,e,n){e[n]=t>>>24,e[n+1]=t>>>16&255,e[n+2]=t>>>8&255,e[n+3]=255&t}function i(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16|t[e+3]<<24)>>>0}function o(t,e){return(t[e]<<24|t[e+1]<<16|t[e+2]<<8|t[e+3])>>>0}t.exports=e(e)},7199:module=>{"use strict";function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(t){}return null}module.exports=inquire},6662:t=>{"use strict";t.exports=function(t,e,n){var r=n||8192,i=r>>>1,o=null,a=r;return function(n){if(n<1||n>i)return t(n);a+n>r&&(o=t(r),a=0);var s=e.call(o,a,a+=n);return 7&a&&(a=1+(7|a)),s}}},4997:(t,e)=>{"use strict";var n=e;n.length=function(t){for(var e=0,n=0,r=0;r<t.length;++r)(n=t.charCodeAt(r))<128?e+=1:n<2048?e+=2:55296==(64512&n)&&56320==(64512&t.charCodeAt(r+1))?(++r,e+=4):e+=3;return e},n.read=function(t,e,n){if(n-e<1)return"";for(var r,i=null,o=[],a=0;e<n;)(r=t[e++])<128?o[a++]=r:r>191&&r<224?o[a++]=(31&r)<<6|63&t[e++]:r>239&&r<365?(r=((7&r)<<18|(63&t[e++])<<12|(63&t[e++])<<6|63&t[e++])-65536,o[a++]=55296+(r>>10),o[a++]=56320+(1023&r)):o[a++]=(15&r)<<12|(63&t[e++])<<6|63&t[e++],a>8191&&((i||(i=[])).push(String.fromCharCode.apply(String,o)),a=0);return i?(a&&i.push(String.fromCharCode.apply(String,o.slice(0,a))),i.join("")):String.fromCharCode.apply(String,o.slice(0,a))},n.write=function(t,e,n){for(var r,i,o=n,a=0;a<t.length;++a)(r=t.charCodeAt(a))<128?e[n++]=r:r<2048?(e[n++]=r>>6|192,e[n++]=63&r|128):55296==(64512&r)&&56320==(64512&(i=t.charCodeAt(a+1)))?(r=65536+((1023&r)<<10)+(1023&i),++a,e[n++]=r>>18|240,e[n++]=r>>12&63|128,e[n++]=r>>6&63|128,e[n++]=63&r|128):(e[n++]=r>>12|224,e[n++]=r>>6&63|128,e[n++]=63&r|128);return n-o}},3442:(t,e)=>{"use strict";e.__esModule=!0;var n=function(){function t(e){if(!e)throw new TypeError("Invalid argument; `value` has no value.");this.value=t.EMPTY,e&&t.isGuid(e)&&(this.value=e)}return t.isGuid=function(e){var n=e.toString();return e&&(e instanceof t||t.validator.test(n))},t.create=function(){return new t([t.gen(2),t.gen(1),t.gen(1),t.gen(1),t.gen(3)].join("-"))},t.createEmpty=function(){return new t("emptyguid")},t.parse=function(e){return new t(e)},t.raw=function(){return[t.gen(2),t.gen(1),t.gen(1),t.gen(1),t.gen(3)].join("-")},t.gen=function(t){for(var e="",n=0;n<t;n++)e+=(65536*(1+Math.random())|0).toString(16).substring(1);return e},t.prototype.equals=function(e){return t.isGuid(e)&&this.value===e.toString()},t.prototype.isEmpty=function(){return this.value===t.EMPTY},t.prototype.toString=function(){return this.value},t.prototype.toJSON=function(){return{value:this.value}},t.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),t.EMPTY="00000000-0000-0000-0000-000000000000",t}();e.Guid=n},3720:t=>{t.exports=n;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(t){}function n(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function r(t){return!0===(t&&t.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var i={},o={};function a(t,e){var n,r,a;return e?(a=0<=(t>>>=0)&&t<256)&&(r=o[t])?r:(n=u(t,(0|t)<0?-1:0,!0),a&&(o[t]=n),n):(a=-128<=(t|=0)&&t<128)&&(r=i[t])?r:(n=u(t,t<0?-1:0,!1),a&&(i[t]=n),n)}function s(t,e){if(isNaN(t))return e?m:b;if(e){if(t<0)return m;if(t>=d)return x}else{if(t<=-h)return T;if(t+1>=h)return w}return t<0?s(-t,e).neg():u(t%f|0,t/f|0,e)}function u(t,e,r){return new n(t,e,r)}n.fromInt=a,n.fromNumber=s,n.fromBits=u;var c=Math.pow;function l(t,e,n){if(0===t.length)throw Error("empty string");if("NaN"===t||"Infinity"===t||"+Infinity"===t||"-Infinity"===t)return b;if("number"==typeof e?(n=e,e=!1):e=!!e,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return l(t.substring(1),e,n).neg();for(var i=s(c(n,8)),o=b,a=0;a<t.length;a+=8){var u=Math.min(8,t.length-a),p=parseInt(t.substring(a,a+u),n);if(u<8){var f=s(c(n,u));o=o.mul(f).add(s(p))}else o=(o=o.mul(i)).add(s(p))}return o.unsigned=e,o}function p(t,e){return"number"==typeof t?s(t,e):"string"==typeof t?l(t,e):u(t.low,t.high,"boolean"==typeof e?e:t.unsigned)}n.fromString=l,n.fromValue=p;var f=4294967296,d=f*f,h=d/2,g=a(1<<24),b=a(0);n.ZERO=b;var m=a(0,!0);n.UZERO=m;var y=a(1);n.ONE=y;var _=a(1,!0);n.UONE=_;var v=a(-1);n.NEG_ONE=v;var w=u(-1,2147483647,!1);n.MAX_VALUE=w;var x=u(-1,-1,!0);n.MAX_UNSIGNED_VALUE=x;var T=u(0,-2147483648,!1);n.MIN_VALUE=T;var S=n.prototype;S.toInt=function(){return this.unsigned?this.low>>>0:this.low},S.toNumber=function(){return this.unsigned?(this.high>>>0)*f+(this.low>>>0):this.high*f+(this.low>>>0)},S.toString=function(t){if((t=t||10)<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(T)){var e=s(t),n=this.div(e),r=n.mul(e).sub(this);return n.toString(t)+r.toInt().toString(t)}return"-"+this.neg().toString(t)}for(var i=s(c(t,6),this.unsigned),o=this,a="";;){var u=o.div(i),l=(o.sub(u.mul(i)).toInt()>>>0).toString(t);if((o=u).isZero())return l+a;for(;l.length<6;)l="0"+l;a=""+l+a}},S.getHighBits=function(){return this.high},S.getHighBitsUnsigned=function(){return this.high>>>0},S.getLowBits=function(){return this.low},S.getLowBitsUnsigned=function(){return this.low>>>0},S.getNumBitsAbs=function(){if(this.isNegative())return this.eq(T)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&0==(t&1<<e);e--);return 0!=this.high?e+33:e+1},S.isZero=function(){return 0===this.high&&0===this.low},S.eqz=S.isZero,S.isNegative=function(){return!this.unsigned&&this.high<0},S.isPositive=function(){return this.unsigned||this.high>=0},S.isOdd=function(){return 1==(1&this.low)},S.isEven=function(){return 0==(1&this.low)},S.equals=function(t){return r(t)||(t=p(t)),(this.unsigned===t.unsigned||this.high>>>31!=1||t.high>>>31!=1)&&this.high===t.high&&this.low===t.low},S.eq=S.equals,S.notEquals=function(t){return!this.eq(t)},S.neq=S.notEquals,S.ne=S.notEquals,S.lessThan=function(t){return this.comp(t)<0},S.lt=S.lessThan,S.lessThanOrEqual=function(t){return this.comp(t)<=0},S.lte=S.lessThanOrEqual,S.le=S.lessThanOrEqual,S.greaterThan=function(t){return this.comp(t)>0},S.gt=S.greaterThan,S.greaterThanOrEqual=function(t){return this.comp(t)>=0},S.gte=S.greaterThanOrEqual,S.ge=S.greaterThanOrEqual,S.compare=function(t){if(r(t)||(t=p(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},S.comp=S.compare,S.negate=function(){return!this.unsigned&&this.eq(T)?T:this.not().add(y)},S.neg=S.negate,S.add=function(t){r(t)||(t=p(t));var e=this.high>>>16,n=65535&this.high,i=this.low>>>16,o=65535&this.low,a=t.high>>>16,s=65535&t.high,c=t.low>>>16,l=0,f=0,d=0,h=0;return d+=(h+=o+(65535&t.low))>>>16,f+=(d+=i+c)>>>16,l+=(f+=n+s)>>>16,l+=e+a,u((d&=65535)<<16|(h&=65535),(l&=65535)<<16|(f&=65535),this.unsigned)},S.subtract=function(t){return r(t)||(t=p(t)),this.add(t.neg())},S.sub=S.subtract,S.multiply=function(t){if(this.isZero())return b;if(r(t)||(t=p(t)),e)return u(e.mul(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned);if(t.isZero())return b;if(this.eq(T))return t.isOdd()?T:b;if(t.eq(T))return this.isOdd()?T:b;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(g)&&t.lt(g))return s(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,i=65535&this.high,o=this.low>>>16,a=65535&this.low,c=t.high>>>16,l=65535&t.high,f=t.low>>>16,d=65535&t.low,h=0,m=0,y=0,_=0;return y+=(_+=a*d)>>>16,m+=(y+=o*d)>>>16,y&=65535,m+=(y+=a*f)>>>16,h+=(m+=i*d)>>>16,m&=65535,h+=(m+=o*f)>>>16,m&=65535,h+=(m+=a*l)>>>16,h+=n*d+i*f+o*l+a*c,u((y&=65535)<<16|(_&=65535),(h&=65535)<<16|(m&=65535),this.unsigned)},S.mul=S.multiply,S.divide=function(t){if(r(t)||(t=p(t)),t.isZero())throw Error("division by zero");var n,i,o;if(e)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?u((this.unsigned?e.div_u:e.div_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?m:b;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return m;if(t.gt(this.shru(1)))return _;o=m}else{if(this.eq(T))return t.eq(y)||t.eq(v)?T:t.eq(T)?y:(n=this.shr(1).div(t).shl(1)).eq(b)?t.isNegative()?y:v:(i=this.sub(t.mul(n)),o=n.add(i.div(t)));if(t.eq(T))return this.unsigned?m:b;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();o=b}for(i=this;i.gte(t);){n=Math.max(1,Math.floor(i.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),l=a<=48?1:c(2,a-48),f=s(n),d=f.mul(t);d.isNegative()||d.gt(i);)d=(f=s(n-=l,this.unsigned)).mul(t);f.isZero()&&(f=y),o=o.add(f),i=i.sub(d)}return o},S.div=S.divide,S.modulo=function(t){return r(t)||(t=p(t)),e?u((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},S.mod=S.modulo,S.rem=S.modulo,S.not=function(){return u(~this.low,~this.high,this.unsigned)},S.and=function(t){return r(t)||(t=p(t)),u(this.low&t.low,this.high&t.high,this.unsigned)},S.or=function(t){return r(t)||(t=p(t)),u(this.low|t.low,this.high|t.high,this.unsigned)},S.xor=function(t){return r(t)||(t=p(t)),u(this.low^t.low,this.high^t.high,this.unsigned)},S.shiftLeft=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?u(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):u(0,this.low<<t-32,this.unsigned)},S.shl=S.shiftLeft,S.shiftRight=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?u(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):u(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},S.shr=S.shiftRight,S.shiftRightUnsigned=function(t){if(r(t)&&(t=t.toInt()),0==(t&=63))return this;var e=this.high;return t<32?u(this.low>>>t|e<<32-t,e>>>t,this.unsigned):u(32===t?e:e>>>t-32,0,this.unsigned)},S.shru=S.shiftRightUnsigned,S.shr_u=S.shiftRightUnsigned,S.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},S.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},S.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},S.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},S.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},n.fromBytes=function(t,e,r){return r?n.fromBytesLE(t,e):n.fromBytesBE(t,e)},n.fromBytesLE=function(t,e){return new n(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},n.fromBytesBE=function(t,e){return new n(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}},1446:(t,e,n)=>{"use strict";var r,i,o,a=n(2100),s=a.Reader,u=a.Writer,c=a.util,l=a.roots.default||(a.roots.default={});l.onnx=((o={}).Version=(r={},(i=Object.create(r))[r[0]="_START_VERSION"]=0,i[r[1]="IR_VERSION_2017_10_10"]=1,i[r[2]="IR_VERSION_2017_10_30"]=2,i[r[3]="IR_VERSION_2017_11_3"]=3,i[r[4]="IR_VERSION_2019_1_22"]=4,i[r[5]="IR_VERSION"]=5,i),o.AttributeProto=function(){function t(t){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.name="",t.prototype.refAttrName="",t.prototype.docString="",t.prototype.type=0,t.prototype.f=0,t.prototype.i=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.s=c.newBuffer([]),t.prototype.t=null,t.prototype.g=null,t.prototype.floats=c.emptyArray,t.prototype.ints=c.emptyArray,t.prototype.strings=c.emptyArray,t.prototype.tensors=c.emptyArray,t.prototype.graphs=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.name&&t.hasOwnProperty("name")&&e.uint32(10).string(t.name),null!=t.f&&t.hasOwnProperty("f")&&e.uint32(21).float(t.f),null!=t.i&&t.hasOwnProperty("i")&&e.uint32(24).int64(t.i),null!=t.s&&t.hasOwnProperty("s")&&e.uint32(34).bytes(t.s),null!=t.t&&t.hasOwnProperty("t")&&l.onnx.TensorProto.encode(t.t,e.uint32(42).fork()).ldelim(),null!=t.g&&t.hasOwnProperty("g")&&l.onnx.GraphProto.encode(t.g,e.uint32(50).fork()).ldelim(),null!=t.floats&&t.floats.length){e.uint32(58).fork();for(var n=0;n<t.floats.length;++n)e.float(t.floats[n]);e.ldelim()}if(null!=t.ints&&t.ints.length){for(e.uint32(66).fork(),n=0;n<t.ints.length;++n)e.int64(t.ints[n]);e.ldelim()}if(null!=t.strings&&t.strings.length)for(n=0;n<t.strings.length;++n)e.uint32(74).bytes(t.strings[n]);if(null!=t.tensors&&t.tensors.length)for(n=0;n<t.tensors.length;++n)l.onnx.TensorProto.encode(t.tensors[n],e.uint32(82).fork()).ldelim();if(null!=t.graphs&&t.graphs.length)for(n=0;n<t.graphs.length;++n)l.onnx.GraphProto.encode(t.graphs[n],e.uint32(90).fork()).ldelim();return null!=t.docString&&t.hasOwnProperty("docString")&&e.uint32(106).string(t.docString),null!=t.type&&t.hasOwnProperty("type")&&e.uint32(160).int32(t.type),null!=t.refAttrName&&t.hasOwnProperty("refAttrName")&&e.uint32(170).string(t.refAttrName),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.AttributeProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.name=t.string();break;case 21:r.refAttrName=t.string();break;case 13:r.docString=t.string();break;case 20:r.type=t.int32();break;case 2:r.f=t.float();break;case 3:r.i=t.int64();break;case 4:r.s=t.bytes();break;case 5:r.t=l.onnx.TensorProto.decode(t,t.uint32());break;case 6:r.g=l.onnx.GraphProto.decode(t,t.uint32());break;case 7:if(r.floats&&r.floats.length||(r.floats=[]),2==(7&i))for(var o=t.uint32()+t.pos;t.pos<o;)r.floats.push(t.float());else r.floats.push(t.float());break;case 8:if(r.ints&&r.ints.length||(r.ints=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.ints.push(t.int64());else r.ints.push(t.int64());break;case 9:r.strings&&r.strings.length||(r.strings=[]),r.strings.push(t.bytes());break;case 10:r.tensors&&r.tensors.length||(r.tensors=[]),r.tensors.push(l.onnx.TensorProto.decode(t,t.uint32()));break;case 11:r.graphs&&r.graphs.length||(r.graphs=[]),r.graphs.push(l.onnx.GraphProto.decode(t,t.uint32()));break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.name&&t.hasOwnProperty("name")&&!c.isString(t.name))return"name: string expected";if(null!=t.refAttrName&&t.hasOwnProperty("refAttrName")&&!c.isString(t.refAttrName))return"refAttrName: string expected";if(null!=t.docString&&t.hasOwnProperty("docString")&&!c.isString(t.docString))return"docString: string expected";if(null!=t.type&&t.hasOwnProperty("type"))switch(t.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(null!=t.f&&t.hasOwnProperty("f")&&"number"!=typeof t.f)return"f: number expected";if(null!=t.i&&t.hasOwnProperty("i")&&!(c.isInteger(t.i)||t.i&&c.isInteger(t.i.low)&&c.isInteger(t.i.high)))return"i: integer|Long expected";if(null!=t.s&&t.hasOwnProperty("s")&&!(t.s&&"number"==typeof t.s.length||c.isString(t.s)))return"s: buffer expected";if(null!=t.t&&t.hasOwnProperty("t")&&(n=l.onnx.TensorProto.verify(t.t)))return"t."+n;if(null!=t.g&&t.hasOwnProperty("g")&&(n=l.onnx.GraphProto.verify(t.g)))return"g."+n;if(null!=t.floats&&t.hasOwnProperty("floats")){if(!Array.isArray(t.floats))return"floats: array expected";for(var e=0;e<t.floats.length;++e)if("number"!=typeof t.floats[e])return"floats: number[] expected"}if(null!=t.ints&&t.hasOwnProperty("ints")){if(!Array.isArray(t.ints))return"ints: array expected";for(e=0;e<t.ints.length;++e)if(!(c.isInteger(t.ints[e])||t.ints[e]&&c.isInteger(t.ints[e].low)&&c.isInteger(t.ints[e].high)))return"ints: integer|Long[] expected"}if(null!=t.strings&&t.hasOwnProperty("strings")){if(!Array.isArray(t.strings))return"strings: array expected";for(e=0;e<t.strings.length;++e)if(!(t.strings[e]&&"number"==typeof t.strings[e].length||c.isString(t.strings[e])))return"strings: buffer[] expected"}if(null!=t.tensors&&t.hasOwnProperty("tensors")){if(!Array.isArray(t.tensors))return"tensors: array expected";for(e=0;e<t.tensors.length;++e)if(n=l.onnx.TensorProto.verify(t.tensors[e]))return"tensors."+n}if(null!=t.graphs&&t.hasOwnProperty("graphs")){if(!Array.isArray(t.graphs))return"graphs: array expected";for(e=0;e<t.graphs.length;++e){var n;if(n=l.onnx.GraphProto.verify(t.graphs[e]))return"graphs."+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.AttributeProto)return t;var e=new l.onnx.AttributeProto;switch(null!=t.name&&(e.name=String(t.name)),null!=t.refAttrName&&(e.refAttrName=String(t.refAttrName)),null!=t.docString&&(e.docString=String(t.docString)),t.type){case"UNDEFINED":case 0:e.type=0;break;case"FLOAT":case 1:e.type=1;break;case"INT":case 2:e.type=2;break;case"STRING":case 3:e.type=3;break;case"TENSOR":case 4:e.type=4;break;case"GRAPH":case 5:e.type=5;break;case"FLOATS":case 6:e.type=6;break;case"INTS":case 7:e.type=7;break;case"STRINGS":case 8:e.type=8;break;case"TENSORS":case 9:e.type=9;break;case"GRAPHS":case 10:e.type=10}if(null!=t.f&&(e.f=Number(t.f)),null!=t.i&&(c.Long?(e.i=c.Long.fromValue(t.i)).unsigned=!1:"string"==typeof t.i?e.i=parseInt(t.i,10):"number"==typeof t.i?e.i=t.i:"object"==typeof t.i&&(e.i=new c.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber())),null!=t.s&&("string"==typeof t.s?c.base64.decode(t.s,e.s=c.newBuffer(c.base64.length(t.s)),0):t.s.length&&(e.s=t.s)),null!=t.t){if("object"!=typeof t.t)throw TypeError(".onnx.AttributeProto.t: object expected");e.t=l.onnx.TensorProto.fromObject(t.t)}if(null!=t.g){if("object"!=typeof t.g)throw TypeError(".onnx.AttributeProto.g: object expected");e.g=l.onnx.GraphProto.fromObject(t.g)}if(t.floats){if(!Array.isArray(t.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");e.floats=[];for(var n=0;n<t.floats.length;++n)e.floats[n]=Number(t.floats[n])}if(t.ints){if(!Array.isArray(t.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(e.ints=[],n=0;n<t.ints.length;++n)c.Long?(e.ints[n]=c.Long.fromValue(t.ints[n])).unsigned=!1:"string"==typeof t.ints[n]?e.ints[n]=parseInt(t.ints[n],10):"number"==typeof t.ints[n]?e.ints[n]=t.ints[n]:"object"==typeof t.ints[n]&&(e.ints[n]=new c.LongBits(t.ints[n].low>>>0,t.ints[n].high>>>0).toNumber())}if(t.strings){if(!Array.isArray(t.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(e.strings=[],n=0;n<t.strings.length;++n)"string"==typeof t.strings[n]?c.base64.decode(t.strings[n],e.strings[n]=c.newBuffer(c.base64.length(t.strings[n])),0):t.strings[n].length&&(e.strings[n]=t.strings[n])}if(t.tensors){if(!Array.isArray(t.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(e.tensors=[],n=0;n<t.tensors.length;++n){if("object"!=typeof t.tensors[n])throw TypeError(".onnx.AttributeProto.tensors: object expected");e.tensors[n]=l.onnx.TensorProto.fromObject(t.tensors[n])}}if(t.graphs){if(!Array.isArray(t.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(e.graphs=[],n=0;n<t.graphs.length;++n){if("object"!=typeof t.graphs[n])throw TypeError(".onnx.AttributeProto.graphs: object expected");e.graphs[n]=l.onnx.GraphProto.fromObject(t.graphs[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.floats=[],n.ints=[],n.strings=[],n.tensors=[],n.graphs=[]),e.defaults){if(n.name="",n.f=0,c.Long){var r=new c.Long(0,0,!1);n.i=e.longs===String?r.toString():e.longs===Number?r.toNumber():r}else n.i=e.longs===String?"0":0;e.bytes===String?n.s="":(n.s=[],e.bytes!==Array&&(n.s=c.newBuffer(n.s))),n.t=null,n.g=null,n.docString="",n.type=e.enums===String?"UNDEFINED":0,n.refAttrName=""}if(null!=t.name&&t.hasOwnProperty("name")&&(n.name=t.name),null!=t.f&&t.hasOwnProperty("f")&&(n.f=e.json&&!isFinite(t.f)?String(t.f):t.f),null!=t.i&&t.hasOwnProperty("i")&&("number"==typeof t.i?n.i=e.longs===String?String(t.i):t.i:n.i=e.longs===String?c.Long.prototype.toString.call(t.i):e.longs===Number?new c.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber():t.i),null!=t.s&&t.hasOwnProperty("s")&&(n.s=e.bytes===String?c.base64.encode(t.s,0,t.s.length):e.bytes===Array?Array.prototype.slice.call(t.s):t.s),null!=t.t&&t.hasOwnProperty("t")&&(n.t=l.onnx.TensorProto.toObject(t.t,e)),null!=t.g&&t.hasOwnProperty("g")&&(n.g=l.onnx.GraphProto.toObject(t.g,e)),t.floats&&t.floats.length){n.floats=[];for(var i=0;i<t.floats.length;++i)n.floats[i]=e.json&&!isFinite(t.floats[i])?String(t.floats[i]):t.floats[i]}if(t.ints&&t.ints.length)for(n.ints=[],i=0;i<t.ints.length;++i)"number"==typeof t.ints[i]?n.ints[i]=e.longs===String?String(t.ints[i]):t.ints[i]:n.ints[i]=e.longs===String?c.Long.prototype.toString.call(t.ints[i]):e.longs===Number?new c.LongBits(t.ints[i].low>>>0,t.ints[i].high>>>0).toNumber():t.ints[i];if(t.strings&&t.strings.length)for(n.strings=[],i=0;i<t.strings.length;++i)n.strings[i]=e.bytes===String?c.base64.encode(t.strings[i],0,t.strings[i].length):e.bytes===Array?Array.prototype.slice.call(t.strings[i]):t.strings[i];if(t.tensors&&t.tensors.length)for(n.tensors=[],i=0;i<t.tensors.length;++i)n.tensors[i]=l.onnx.TensorProto.toObject(t.tensors[i],e);if(t.graphs&&t.graphs.length)for(n.graphs=[],i=0;i<t.graphs.length;++i)n.graphs[i]=l.onnx.GraphProto.toObject(t.graphs[i],e);return null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),null!=t.type&&t.hasOwnProperty("type")&&(n.type=e.enums===String?l.onnx.AttributeProto.AttributeType[t.type]:t.type),null!=t.refAttrName&&t.hasOwnProperty("refAttrName")&&(n.refAttrName=t.refAttrName),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t.AttributeType=function(){var t={},e=Object.create(t);return e[t[0]="UNDEFINED"]=0,e[t[1]="FLOAT"]=1,e[t[2]="INT"]=2,e[t[3]="STRING"]=3,e[t[4]="TENSOR"]=4,e[t[5]="GRAPH"]=5,e[t[6]="FLOATS"]=6,e[t[7]="INTS"]=7,e[t[8]="STRINGS"]=8,e[t[9]="TENSORS"]=9,e[t[10]="GRAPHS"]=10,e}(),t}(),o.ValueInfoProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.name="",t.prototype.type=null,t.prototype.docString="",t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.name&&t.hasOwnProperty("name")&&e.uint32(10).string(t.name),null!=t.type&&t.hasOwnProperty("type")&&l.onnx.TypeProto.encode(t.type,e.uint32(18).fork()).ldelim(),null!=t.docString&&t.hasOwnProperty("docString")&&e.uint32(26).string(t.docString),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.ValueInfoProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.name=t.string();break;case 2:r.type=l.onnx.TypeProto.decode(t,t.uint32());break;case 3:r.docString=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.name&&t.hasOwnProperty("name")&&!c.isString(t.name))return"name: string expected";if(null!=t.type&&t.hasOwnProperty("type")){var e=l.onnx.TypeProto.verify(t.type);if(e)return"type."+e}return null!=t.docString&&t.hasOwnProperty("docString")&&!c.isString(t.docString)?"docString: string expected":null},t.fromObject=function(t){if(t instanceof l.onnx.ValueInfoProto)return t;var e=new l.onnx.ValueInfoProto;if(null!=t.name&&(e.name=String(t.name)),null!=t.type){if("object"!=typeof t.type)throw TypeError(".onnx.ValueInfoProto.type: object expected");e.type=l.onnx.TypeProto.fromObject(t.type)}return null!=t.docString&&(e.docString=String(t.docString)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.name="",n.type=null,n.docString=""),null!=t.name&&t.hasOwnProperty("name")&&(n.name=t.name),null!=t.type&&t.hasOwnProperty("type")&&(n.type=l.onnx.TypeProto.toObject(t.type,e)),null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.NodeProto=function(){function t(t){if(this.input=[],this.output=[],this.attribute=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.input=c.emptyArray,t.prototype.output=c.emptyArray,t.prototype.name="",t.prototype.opType="",t.prototype.domain="",t.prototype.attribute=c.emptyArray,t.prototype.docString="",t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.input&&t.input.length)for(var n=0;n<t.input.length;++n)e.uint32(10).string(t.input[n]);if(null!=t.output&&t.output.length)for(n=0;n<t.output.length;++n)e.uint32(18).string(t.output[n]);if(null!=t.name&&t.hasOwnProperty("name")&&e.uint32(26).string(t.name),null!=t.opType&&t.hasOwnProperty("opType")&&e.uint32(34).string(t.opType),null!=t.attribute&&t.attribute.length)for(n=0;n<t.attribute.length;++n)l.onnx.AttributeProto.encode(t.attribute[n],e.uint32(42).fork()).ldelim();return null!=t.docString&&t.hasOwnProperty("docString")&&e.uint32(50).string(t.docString),null!=t.domain&&t.hasOwnProperty("domain")&&e.uint32(58).string(t.domain),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.NodeProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.input&&r.input.length||(r.input=[]),r.input.push(t.string());break;case 2:r.output&&r.output.length||(r.output=[]),r.output.push(t.string());break;case 3:r.name=t.string();break;case 4:r.opType=t.string();break;case 7:r.domain=t.string();break;case 5:r.attribute&&r.attribute.length||(r.attribute=[]),r.attribute.push(l.onnx.AttributeProto.decode(t,t.uint32()));break;case 6:r.docString=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.input&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var e=0;e<t.input.length;++e)if(!c.isString(t.input[e]))return"input: string[] expected"}if(null!=t.output&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(e=0;e<t.output.length;++e)if(!c.isString(t.output[e]))return"output: string[] expected"}if(null!=t.name&&t.hasOwnProperty("name")&&!c.isString(t.name))return"name: string expected";if(null!=t.opType&&t.hasOwnProperty("opType")&&!c.isString(t.opType))return"opType: string expected";if(null!=t.domain&&t.hasOwnProperty("domain")&&!c.isString(t.domain))return"domain: string expected";if(null!=t.attribute&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(e=0;e<t.attribute.length;++e){var n=l.onnx.AttributeProto.verify(t.attribute[e]);if(n)return"attribute."+n}}return null!=t.docString&&t.hasOwnProperty("docString")&&!c.isString(t.docString)?"docString: string expected":null},t.fromObject=function(t){if(t instanceof l.onnx.NodeProto)return t;var e=new l.onnx.NodeProto;if(t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.NodeProto.input: array expected");e.input=[];for(var n=0;n<t.input.length;++n)e.input[n]=String(t.input[n])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.NodeProto.output: array expected");for(e.output=[],n=0;n<t.output.length;++n)e.output[n]=String(t.output[n])}if(null!=t.name&&(e.name=String(t.name)),null!=t.opType&&(e.opType=String(t.opType)),null!=t.domain&&(e.domain=String(t.domain)),t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(e.attribute=[],n=0;n<t.attribute.length;++n){if("object"!=typeof t.attribute[n])throw TypeError(".onnx.NodeProto.attribute: object expected");e.attribute[n]=l.onnx.AttributeProto.fromObject(t.attribute[n])}}return null!=t.docString&&(e.docString=String(t.docString)),e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.input=[],n.output=[],n.attribute=[]),e.defaults&&(n.name="",n.opType="",n.docString="",n.domain=""),t.input&&t.input.length){n.input=[];for(var r=0;r<t.input.length;++r)n.input[r]=t.input[r]}if(t.output&&t.output.length)for(n.output=[],r=0;r<t.output.length;++r)n.output[r]=t.output[r];if(null!=t.name&&t.hasOwnProperty("name")&&(n.name=t.name),null!=t.opType&&t.hasOwnProperty("opType")&&(n.opType=t.opType),t.attribute&&t.attribute.length)for(n.attribute=[],r=0;r<t.attribute.length;++r)n.attribute[r]=l.onnx.AttributeProto.toObject(t.attribute[r],e);return null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),null!=t.domain&&t.hasOwnProperty("domain")&&(n.domain=t.domain),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.ModelProto=function(){function t(t){if(this.opsetImport=[],this.metadataProps=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.irVersion=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.opsetImport=c.emptyArray,t.prototype.producerName="",t.prototype.producerVersion="",t.prototype.domain="",t.prototype.modelVersion=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.docString="",t.prototype.graph=null,t.prototype.metadataProps=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.irVersion&&t.hasOwnProperty("irVersion")&&e.uint32(8).int64(t.irVersion),null!=t.producerName&&t.hasOwnProperty("producerName")&&e.uint32(18).string(t.producerName),null!=t.producerVersion&&t.hasOwnProperty("producerVersion")&&e.uint32(26).string(t.producerVersion),null!=t.domain&&t.hasOwnProperty("domain")&&e.uint32(34).string(t.domain),null!=t.modelVersion&&t.hasOwnProperty("modelVersion")&&e.uint32(40).int64(t.modelVersion),null!=t.docString&&t.hasOwnProperty("docString")&&e.uint32(50).string(t.docString),null!=t.graph&&t.hasOwnProperty("graph")&&l.onnx.GraphProto.encode(t.graph,e.uint32(58).fork()).ldelim(),null!=t.opsetImport&&t.opsetImport.length)for(var n=0;n<t.opsetImport.length;++n)l.onnx.OperatorSetIdProto.encode(t.opsetImport[n],e.uint32(66).fork()).ldelim();if(null!=t.metadataProps&&t.metadataProps.length)for(n=0;n<t.metadataProps.length;++n)l.onnx.StringStringEntryProto.encode(t.metadataProps[n],e.uint32(114).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.ModelProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.irVersion=t.int64();break;case 8:r.opsetImport&&r.opsetImport.length||(r.opsetImport=[]),r.opsetImport.push(l.onnx.OperatorSetIdProto.decode(t,t.uint32()));break;case 2:r.producerName=t.string();break;case 3:r.producerVersion=t.string();break;case 4:r.domain=t.string();break;case 5:r.modelVersion=t.int64();break;case 6:r.docString=t.string();break;case 7:r.graph=l.onnx.GraphProto.decode(t,t.uint32());break;case 14:r.metadataProps&&r.metadataProps.length||(r.metadataProps=[]),r.metadataProps.push(l.onnx.StringStringEntryProto.decode(t,t.uint32()));break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.irVersion&&t.hasOwnProperty("irVersion")&&!(c.isInteger(t.irVersion)||t.irVersion&&c.isInteger(t.irVersion.low)&&c.isInteger(t.irVersion.high)))return"irVersion: integer|Long expected";if(null!=t.opsetImport&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var e=0;e<t.opsetImport.length;++e)if(n=l.onnx.OperatorSetIdProto.verify(t.opsetImport[e]))return"opsetImport."+n}if(null!=t.producerName&&t.hasOwnProperty("producerName")&&!c.isString(t.producerName))return"producerName: string expected";if(null!=t.producerVersion&&t.hasOwnProperty("producerVersion")&&!c.isString(t.producerVersion))return"producerVersion: string expected";if(null!=t.domain&&t.hasOwnProperty("domain")&&!c.isString(t.domain))return"domain: string expected";if(null!=t.modelVersion&&t.hasOwnProperty("modelVersion")&&!(c.isInteger(t.modelVersion)||t.modelVersion&&c.isInteger(t.modelVersion.low)&&c.isInteger(t.modelVersion.high)))return"modelVersion: integer|Long expected";if(null!=t.docString&&t.hasOwnProperty("docString")&&!c.isString(t.docString))return"docString: string expected";if(null!=t.graph&&t.hasOwnProperty("graph")&&(n=l.onnx.GraphProto.verify(t.graph)))return"graph."+n;if(null!=t.metadataProps&&t.hasOwnProperty("metadataProps")){if(!Array.isArray(t.metadataProps))return"metadataProps: array expected";for(e=0;e<t.metadataProps.length;++e){var n;if(n=l.onnx.StringStringEntryProto.verify(t.metadataProps[e]))return"metadataProps."+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.ModelProto)return t;var e=new l.onnx.ModelProto;if(null!=t.irVersion&&(c.Long?(e.irVersion=c.Long.fromValue(t.irVersion)).unsigned=!1:"string"==typeof t.irVersion?e.irVersion=parseInt(t.irVersion,10):"number"==typeof t.irVersion?e.irVersion=t.irVersion:"object"==typeof t.irVersion&&(e.irVersion=new c.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber())),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");e.opsetImport=[];for(var n=0;n<t.opsetImport.length;++n){if("object"!=typeof t.opsetImport[n])throw TypeError(".onnx.ModelProto.opsetImport: object expected");e.opsetImport[n]=l.onnx.OperatorSetIdProto.fromObject(t.opsetImport[n])}}if(null!=t.producerName&&(e.producerName=String(t.producerName)),null!=t.producerVersion&&(e.producerVersion=String(t.producerVersion)),null!=t.domain&&(e.domain=String(t.domain)),null!=t.modelVersion&&(c.Long?(e.modelVersion=c.Long.fromValue(t.modelVersion)).unsigned=!1:"string"==typeof t.modelVersion?e.modelVersion=parseInt(t.modelVersion,10):"number"==typeof t.modelVersion?e.modelVersion=t.modelVersion:"object"==typeof t.modelVersion&&(e.modelVersion=new c.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber())),null!=t.docString&&(e.docString=String(t.docString)),null!=t.graph){if("object"!=typeof t.graph)throw TypeError(".onnx.ModelProto.graph: object expected");e.graph=l.onnx.GraphProto.fromObject(t.graph)}if(t.metadataProps){if(!Array.isArray(t.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(e.metadataProps=[],n=0;n<t.metadataProps.length;++n){if("object"!=typeof t.metadataProps[n])throw TypeError(".onnx.ModelProto.metadataProps: object expected");e.metadataProps[n]=l.onnx.StringStringEntryProto.fromObject(t.metadataProps[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.opsetImport=[],n.metadataProps=[]),e.defaults){if(c.Long){var r=new c.Long(0,0,!1);n.irVersion=e.longs===String?r.toString():e.longs===Number?r.toNumber():r}else n.irVersion=e.longs===String?"0":0;n.producerName="",n.producerVersion="",n.domain="",c.Long?(r=new c.Long(0,0,!1),n.modelVersion=e.longs===String?r.toString():e.longs===Number?r.toNumber():r):n.modelVersion=e.longs===String?"0":0,n.docString="",n.graph=null}if(null!=t.irVersion&&t.hasOwnProperty("irVersion")&&("number"==typeof t.irVersion?n.irVersion=e.longs===String?String(t.irVersion):t.irVersion:n.irVersion=e.longs===String?c.Long.prototype.toString.call(t.irVersion):e.longs===Number?new c.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber():t.irVersion),null!=t.producerName&&t.hasOwnProperty("producerName")&&(n.producerName=t.producerName),null!=t.producerVersion&&t.hasOwnProperty("producerVersion")&&(n.producerVersion=t.producerVersion),null!=t.domain&&t.hasOwnProperty("domain")&&(n.domain=t.domain),null!=t.modelVersion&&t.hasOwnProperty("modelVersion")&&("number"==typeof t.modelVersion?n.modelVersion=e.longs===String?String(t.modelVersion):t.modelVersion:n.modelVersion=e.longs===String?c.Long.prototype.toString.call(t.modelVersion):e.longs===Number?new c.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber():t.modelVersion),null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),null!=t.graph&&t.hasOwnProperty("graph")&&(n.graph=l.onnx.GraphProto.toObject(t.graph,e)),t.opsetImport&&t.opsetImport.length){n.opsetImport=[];for(var i=0;i<t.opsetImport.length;++i)n.opsetImport[i]=l.onnx.OperatorSetIdProto.toObject(t.opsetImport[i],e)}if(t.metadataProps&&t.metadataProps.length)for(n.metadataProps=[],i=0;i<t.metadataProps.length;++i)n.metadataProps[i]=l.onnx.StringStringEntryProto.toObject(t.metadataProps[i],e);return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.StringStringEntryProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.key="",t.prototype.value="",t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.key&&t.hasOwnProperty("key")&&e.uint32(10).string(t.key),null!=t.value&&t.hasOwnProperty("value")&&e.uint32(18).string(t.value),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.StringStringEntryProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.key=t.string();break;case 2:r.value=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){return"object"!=typeof t||null===t?"object expected":null!=t.key&&t.hasOwnProperty("key")&&!c.isString(t.key)?"key: string expected":null!=t.value&&t.hasOwnProperty("value")&&!c.isString(t.value)?"value: string expected":null},t.fromObject=function(t){if(t instanceof l.onnx.StringStringEntryProto)return t;var e=new l.onnx.StringStringEntryProto;return null!=t.key&&(e.key=String(t.key)),null!=t.value&&(e.value=String(t.value)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.key="",n.value=""),null!=t.key&&t.hasOwnProperty("key")&&(n.key=t.key),null!=t.value&&t.hasOwnProperty("value")&&(n.value=t.value),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.TensorAnnotation=function(){function t(t){if(this.quantParameterTensorNames=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.tensorName="",t.prototype.quantParameterTensorNames=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.tensorName&&t.hasOwnProperty("tensorName")&&e.uint32(10).string(t.tensorName),null!=t.quantParameterTensorNames&&t.quantParameterTensorNames.length)for(var n=0;n<t.quantParameterTensorNames.length;++n)l.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[n],e.uint32(18).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorAnnotation;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.tensorName=t.string();break;case 2:r.quantParameterTensorNames&&r.quantParameterTensorNames.length||(r.quantParameterTensorNames=[]),r.quantParameterTensorNames.push(l.onnx.StringStringEntryProto.decode(t,t.uint32()));break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.tensorName&&t.hasOwnProperty("tensorName")&&!c.isString(t.tensorName))return"tensorName: string expected";if(null!=t.quantParameterTensorNames&&t.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(t.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var e=0;e<t.quantParameterTensorNames.length;++e){var n=l.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[e]);if(n)return"quantParameterTensorNames."+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.TensorAnnotation)return t;var e=new l.onnx.TensorAnnotation;if(null!=t.tensorName&&(e.tensorName=String(t.tensorName)),t.quantParameterTensorNames){if(!Array.isArray(t.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");e.quantParameterTensorNames=[];for(var n=0;n<t.quantParameterTensorNames.length;++n){if("object"!=typeof t.quantParameterTensorNames[n])throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");e.quantParameterTensorNames[n]=l.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.quantParameterTensorNames=[]),e.defaults&&(n.tensorName=""),null!=t.tensorName&&t.hasOwnProperty("tensorName")&&(n.tensorName=t.tensorName),t.quantParameterTensorNames&&t.quantParameterTensorNames.length){n.quantParameterTensorNames=[];for(var r=0;r<t.quantParameterTensorNames.length;++r)n.quantParameterTensorNames[r]=l.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[r],e)}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.GraphProto=function(){function t(t){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.node=c.emptyArray,t.prototype.name="",t.prototype.initializer=c.emptyArray,t.prototype.docString="",t.prototype.input=c.emptyArray,t.prototype.output=c.emptyArray,t.prototype.valueInfo=c.emptyArray,t.prototype.quantizationAnnotation=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.node&&t.node.length)for(var n=0;n<t.node.length;++n)l.onnx.NodeProto.encode(t.node[n],e.uint32(10).fork()).ldelim();if(null!=t.name&&t.hasOwnProperty("name")&&e.uint32(18).string(t.name),null!=t.initializer&&t.initializer.length)for(n=0;n<t.initializer.length;++n)l.onnx.TensorProto.encode(t.initializer[n],e.uint32(42).fork()).ldelim();if(null!=t.docString&&t.hasOwnProperty("docString")&&e.uint32(82).string(t.docString),null!=t.input&&t.input.length)for(n=0;n<t.input.length;++n)l.onnx.ValueInfoProto.encode(t.input[n],e.uint32(90).fork()).ldelim();if(null!=t.output&&t.output.length)for(n=0;n<t.output.length;++n)l.onnx.ValueInfoProto.encode(t.output[n],e.uint32(98).fork()).ldelim();if(null!=t.valueInfo&&t.valueInfo.length)for(n=0;n<t.valueInfo.length;++n)l.onnx.ValueInfoProto.encode(t.valueInfo[n],e.uint32(106).fork()).ldelim();if(null!=t.quantizationAnnotation&&t.quantizationAnnotation.length)for(n=0;n<t.quantizationAnnotation.length;++n)l.onnx.TensorAnnotation.encode(t.quantizationAnnotation[n],e.uint32(114).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.GraphProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.node&&r.node.length||(r.node=[]),r.node.push(l.onnx.NodeProto.decode(t,t.uint32()));break;case 2:r.name=t.string();break;case 5:r.initializer&&r.initializer.length||(r.initializer=[]),r.initializer.push(l.onnx.TensorProto.decode(t,t.uint32()));break;case 10:r.docString=t.string();break;case 11:r.input&&r.input.length||(r.input=[]),r.input.push(l.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 12:r.output&&r.output.length||(r.output=[]),r.output.push(l.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 13:r.valueInfo&&r.valueInfo.length||(r.valueInfo=[]),r.valueInfo.push(l.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 14:r.quantizationAnnotation&&r.quantizationAnnotation.length||(r.quantizationAnnotation=[]),r.quantizationAnnotation.push(l.onnx.TensorAnnotation.decode(t,t.uint32()));break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.node&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var e=0;e<t.node.length;++e)if(n=l.onnx.NodeProto.verify(t.node[e]))return"node."+n}if(null!=t.name&&t.hasOwnProperty("name")&&!c.isString(t.name))return"name: string expected";if(null!=t.initializer&&t.hasOwnProperty("initializer")){if(!Array.isArray(t.initializer))return"initializer: array expected";for(e=0;e<t.initializer.length;++e)if(n=l.onnx.TensorProto.verify(t.initializer[e]))return"initializer."+n}if(null!=t.docString&&t.hasOwnProperty("docString")&&!c.isString(t.docString))return"docString: string expected";if(null!=t.input&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(e=0;e<t.input.length;++e)if(n=l.onnx.ValueInfoProto.verify(t.input[e]))return"input."+n}if(null!=t.output&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(e=0;e<t.output.length;++e)if(n=l.onnx.ValueInfoProto.verify(t.output[e]))return"output."+n}if(null!=t.valueInfo&&t.hasOwnProperty("valueInfo")){if(!Array.isArray(t.valueInfo))return"valueInfo: array expected";for(e=0;e<t.valueInfo.length;++e)if(n=l.onnx.ValueInfoProto.verify(t.valueInfo[e]))return"valueInfo."+n}if(null!=t.quantizationAnnotation&&t.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(t.quantizationAnnotation))return"quantizationAnnotation: array expected";for(e=0;e<t.quantizationAnnotation.length;++e){var n;if(n=l.onnx.TensorAnnotation.verify(t.quantizationAnnotation[e]))return"quantizationAnnotation."+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.GraphProto)return t;var e=new l.onnx.GraphProto;if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.GraphProto.node: array expected");e.node=[];for(var n=0;n<t.node.length;++n){if("object"!=typeof t.node[n])throw TypeError(".onnx.GraphProto.node: object expected");e.node[n]=l.onnx.NodeProto.fromObject(t.node[n])}}if(null!=t.name&&(e.name=String(t.name)),t.initializer){if(!Array.isArray(t.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(e.initializer=[],n=0;n<t.initializer.length;++n){if("object"!=typeof t.initializer[n])throw TypeError(".onnx.GraphProto.initializer: object expected");e.initializer[n]=l.onnx.TensorProto.fromObject(t.initializer[n])}}if(null!=t.docString&&(e.docString=String(t.docString)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.GraphProto.input: array expected");for(e.input=[],n=0;n<t.input.length;++n){if("object"!=typeof t.input[n])throw TypeError(".onnx.GraphProto.input: object expected");e.input[n]=l.onnx.ValueInfoProto.fromObject(t.input[n])}}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.GraphProto.output: array expected");for(e.output=[],n=0;n<t.output.length;++n){if("object"!=typeof t.output[n])throw TypeError(".onnx.GraphProto.output: object expected");e.output[n]=l.onnx.ValueInfoProto.fromObject(t.output[n])}}if(t.valueInfo){if(!Array.isArray(t.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(e.valueInfo=[],n=0;n<t.valueInfo.length;++n){if("object"!=typeof t.valueInfo[n])throw TypeError(".onnx.GraphProto.valueInfo: object expected");e.valueInfo[n]=l.onnx.ValueInfoProto.fromObject(t.valueInfo[n])}}if(t.quantizationAnnotation){if(!Array.isArray(t.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(e.quantizationAnnotation=[],n=0;n<t.quantizationAnnotation.length;++n){if("object"!=typeof t.quantizationAnnotation[n])throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");e.quantizationAnnotation[n]=l.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.node=[],n.initializer=[],n.input=[],n.output=[],n.valueInfo=[],n.quantizationAnnotation=[]),e.defaults&&(n.name="",n.docString=""),t.node&&t.node.length){n.node=[];for(var r=0;r<t.node.length;++r)n.node[r]=l.onnx.NodeProto.toObject(t.node[r],e)}if(null!=t.name&&t.hasOwnProperty("name")&&(n.name=t.name),t.initializer&&t.initializer.length)for(n.initializer=[],r=0;r<t.initializer.length;++r)n.initializer[r]=l.onnx.TensorProto.toObject(t.initializer[r],e);if(null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),t.input&&t.input.length)for(n.input=[],r=0;r<t.input.length;++r)n.input[r]=l.onnx.ValueInfoProto.toObject(t.input[r],e);if(t.output&&t.output.length)for(n.output=[],r=0;r<t.output.length;++r)n.output[r]=l.onnx.ValueInfoProto.toObject(t.output[r],e);if(t.valueInfo&&t.valueInfo.length)for(n.valueInfo=[],r=0;r<t.valueInfo.length;++r)n.valueInfo[r]=l.onnx.ValueInfoProto.toObject(t.valueInfo[r],e);if(t.quantizationAnnotation&&t.quantizationAnnotation.length)for(n.quantizationAnnotation=[],r=0;r<t.quantizationAnnotation.length;++r)n.quantizationAnnotation[r]=l.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[r],e);return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.TensorProto=function(){function t(t){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.dims=c.emptyArray,t.prototype.dataType=0,t.prototype.segment=null,t.prototype.floatData=c.emptyArray,t.prototype.int32Data=c.emptyArray,t.prototype.stringData=c.emptyArray,t.prototype.int64Data=c.emptyArray,t.prototype.name="",t.prototype.docString="",t.prototype.rawData=c.newBuffer([]),t.prototype.externalData=c.emptyArray,t.prototype.dataLocation=0,t.prototype.doubleData=c.emptyArray,t.prototype.uint64Data=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.dims&&t.dims.length){e.uint32(10).fork();for(var n=0;n<t.dims.length;++n)e.int64(t.dims[n]);e.ldelim()}if(null!=t.dataType&&t.hasOwnProperty("dataType")&&e.uint32(16).int32(t.dataType),null!=t.segment&&t.hasOwnProperty("segment")&&l.onnx.TensorProto.Segment.encode(t.segment,e.uint32(26).fork()).ldelim(),null!=t.floatData&&t.floatData.length){for(e.uint32(34).fork(),n=0;n<t.floatData.length;++n)e.float(t.floatData[n]);e.ldelim()}if(null!=t.int32Data&&t.int32Data.length){for(e.uint32(42).fork(),n=0;n<t.int32Data.length;++n)e.int32(t.int32Data[n]);e.ldelim()}if(null!=t.stringData&&t.stringData.length)for(n=0;n<t.stringData.length;++n)e.uint32(50).bytes(t.stringData[n]);if(null!=t.int64Data&&t.int64Data.length){for(e.uint32(58).fork(),n=0;n<t.int64Data.length;++n)e.int64(t.int64Data[n]);e.ldelim()}if(null!=t.name&&t.hasOwnProperty("name")&&e.uint32(66).string(t.name),null!=t.rawData&&t.hasOwnProperty("rawData")&&e.uint32(74).bytes(t.rawData),null!=t.doubleData&&t.doubleData.length){for(e.uint32(82).fork(),n=0;n<t.doubleData.length;++n)e.double(t.doubleData[n]);e.ldelim()}if(null!=t.uint64Data&&t.uint64Data.length){for(e.uint32(90).fork(),n=0;n<t.uint64Data.length;++n)e.uint64(t.uint64Data[n]);e.ldelim()}if(null!=t.docString&&t.hasOwnProperty("docString")&&e.uint32(98).string(t.docString),null!=t.externalData&&t.externalData.length)for(n=0;n<t.externalData.length;++n)l.onnx.StringStringEntryProto.encode(t.externalData[n],e.uint32(106).fork()).ldelim();return null!=t.dataLocation&&t.hasOwnProperty("dataLocation")&&e.uint32(112).int32(t.dataLocation),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:if(r.dims&&r.dims.length||(r.dims=[]),2==(7&i))for(var o=t.uint32()+t.pos;t.pos<o;)r.dims.push(t.int64());else r.dims.push(t.int64());break;case 2:r.dataType=t.int32();break;case 3:r.segment=l.onnx.TensorProto.Segment.decode(t,t.uint32());break;case 4:if(r.floatData&&r.floatData.length||(r.floatData=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.floatData.push(t.float());else r.floatData.push(t.float());break;case 5:if(r.int32Data&&r.int32Data.length||(r.int32Data=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.int32Data.push(t.int32());else r.int32Data.push(t.int32());break;case 6:r.stringData&&r.stringData.length||(r.stringData=[]),r.stringData.push(t.bytes());break;case 7:if(r.int64Data&&r.int64Data.length||(r.int64Data=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.int64Data.push(t.int64());else r.int64Data.push(t.int64());break;case 8:r.name=t.string();break;case 12:r.docString=t.string();break;case 9:r.rawData=t.bytes();break;case 13:r.externalData&&r.externalData.length||(r.externalData=[]),r.externalData.push(l.onnx.StringStringEntryProto.decode(t,t.uint32()));break;case 14:r.dataLocation=t.int32();break;case 10:if(r.doubleData&&r.doubleData.length||(r.doubleData=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.doubleData.push(t.double());else r.doubleData.push(t.double());break;case 11:if(r.uint64Data&&r.uint64Data.length||(r.uint64Data=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.uint64Data.push(t.uint64());else r.uint64Data.push(t.uint64());break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.dims&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var e=0;e<t.dims.length;++e)if(!(c.isInteger(t.dims[e])||t.dims[e]&&c.isInteger(t.dims[e].low)&&c.isInteger(t.dims[e].high)))return"dims: integer|Long[] expected"}if(null!=t.dataType&&t.hasOwnProperty("dataType")&&!c.isInteger(t.dataType))return"dataType: integer expected";if(null!=t.segment&&t.hasOwnProperty("segment")&&(n=l.onnx.TensorProto.Segment.verify(t.segment)))return"segment."+n;if(null!=t.floatData&&t.hasOwnProperty("floatData")){if(!Array.isArray(t.floatData))return"floatData: array expected";for(e=0;e<t.floatData.length;++e)if("number"!=typeof t.floatData[e])return"floatData: number[] expected"}if(null!=t.int32Data&&t.hasOwnProperty("int32Data")){if(!Array.isArray(t.int32Data))return"int32Data: array expected";for(e=0;e<t.int32Data.length;++e)if(!c.isInteger(t.int32Data[e]))return"int32Data: integer[] expected"}if(null!=t.stringData&&t.hasOwnProperty("stringData")){if(!Array.isArray(t.stringData))return"stringData: array expected";for(e=0;e<t.stringData.length;++e)if(!(t.stringData[e]&&"number"==typeof t.stringData[e].length||c.isString(t.stringData[e])))return"stringData: buffer[] expected"}if(null!=t.int64Data&&t.hasOwnProperty("int64Data")){if(!Array.isArray(t.int64Data))return"int64Data: array expected";for(e=0;e<t.int64Data.length;++e)if(!(c.isInteger(t.int64Data[e])||t.int64Data[e]&&c.isInteger(t.int64Data[e].low)&&c.isInteger(t.int64Data[e].high)))return"int64Data: integer|Long[] expected"}if(null!=t.name&&t.hasOwnProperty("name")&&!c.isString(t.name))return"name: string expected";if(null!=t.docString&&t.hasOwnProperty("docString")&&!c.isString(t.docString))return"docString: string expected";if(null!=t.rawData&&t.hasOwnProperty("rawData")&&!(t.rawData&&"number"==typeof t.rawData.length||c.isString(t.rawData)))return"rawData: buffer expected";if(null!=t.externalData&&t.hasOwnProperty("externalData")){if(!Array.isArray(t.externalData))return"externalData: array expected";for(e=0;e<t.externalData.length;++e){var n;if(n=l.onnx.StringStringEntryProto.verify(t.externalData[e]))return"externalData."+n}}if(null!=t.dataLocation&&t.hasOwnProperty("dataLocation"))switch(t.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(null!=t.doubleData&&t.hasOwnProperty("doubleData")){if(!Array.isArray(t.doubleData))return"doubleData: array expected";for(e=0;e<t.doubleData.length;++e)if("number"!=typeof t.doubleData[e])return"doubleData: number[] expected"}if(null!=t.uint64Data&&t.hasOwnProperty("uint64Data")){if(!Array.isArray(t.uint64Data))return"uint64Data: array expected";for(e=0;e<t.uint64Data.length;++e)if(!(c.isInteger(t.uint64Data[e])||t.uint64Data[e]&&c.isInteger(t.uint64Data[e].low)&&c.isInteger(t.uint64Data[e].high)))return"uint64Data: integer|Long[] expected"}return null},t.fromObject=function(t){if(t instanceof l.onnx.TensorProto)return t;var e=new l.onnx.TensorProto;if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.TensorProto.dims: array expected");e.dims=[];for(var n=0;n<t.dims.length;++n)c.Long?(e.dims[n]=c.Long.fromValue(t.dims[n])).unsigned=!1:"string"==typeof t.dims[n]?e.dims[n]=parseInt(t.dims[n],10):"number"==typeof t.dims[n]?e.dims[n]=t.dims[n]:"object"==typeof t.dims[n]&&(e.dims[n]=new c.LongBits(t.dims[n].low>>>0,t.dims[n].high>>>0).toNumber())}if(null!=t.dataType&&(e.dataType=0|t.dataType),null!=t.segment){if("object"!=typeof t.segment)throw TypeError(".onnx.TensorProto.segment: object expected");e.segment=l.onnx.TensorProto.Segment.fromObject(t.segment)}if(t.floatData){if(!Array.isArray(t.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(e.floatData=[],n=0;n<t.floatData.length;++n)e.floatData[n]=Number(t.floatData[n])}if(t.int32Data){if(!Array.isArray(t.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(e.int32Data=[],n=0;n<t.int32Data.length;++n)e.int32Data[n]=0|t.int32Data[n]}if(t.stringData){if(!Array.isArray(t.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(e.stringData=[],n=0;n<t.stringData.length;++n)"string"==typeof t.stringData[n]?c.base64.decode(t.stringData[n],e.stringData[n]=c.newBuffer(c.base64.length(t.stringData[n])),0):t.stringData[n].length&&(e.stringData[n]=t.stringData[n])}if(t.int64Data){if(!Array.isArray(t.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(e.int64Data=[],n=0;n<t.int64Data.length;++n)c.Long?(e.int64Data[n]=c.Long.fromValue(t.int64Data[n])).unsigned=!1:"string"==typeof t.int64Data[n]?e.int64Data[n]=parseInt(t.int64Data[n],10):"number"==typeof t.int64Data[n]?e.int64Data[n]=t.int64Data[n]:"object"==typeof t.int64Data[n]&&(e.int64Data[n]=new c.LongBits(t.int64Data[n].low>>>0,t.int64Data[n].high>>>0).toNumber())}if(null!=t.name&&(e.name=String(t.name)),null!=t.docString&&(e.docString=String(t.docString)),null!=t.rawData&&("string"==typeof t.rawData?c.base64.decode(t.rawData,e.rawData=c.newBuffer(c.base64.length(t.rawData)),0):t.rawData.length&&(e.rawData=t.rawData)),t.externalData){if(!Array.isArray(t.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(e.externalData=[],n=0;n<t.externalData.length;++n){if("object"!=typeof t.externalData[n])throw TypeError(".onnx.TensorProto.externalData: object expected");e.externalData[n]=l.onnx.StringStringEntryProto.fromObject(t.externalData[n])}}switch(t.dataLocation){case"DEFAULT":case 0:e.dataLocation=0;break;case"EXTERNAL":case 1:e.dataLocation=1}if(t.doubleData){if(!Array.isArray(t.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(e.doubleData=[],n=0;n<t.doubleData.length;++n)e.doubleData[n]=Number(t.doubleData[n])}if(t.uint64Data){if(!Array.isArray(t.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(e.uint64Data=[],n=0;n<t.uint64Data.length;++n)c.Long?(e.uint64Data[n]=c.Long.fromValue(t.uint64Data[n])).unsigned=!0:"string"==typeof t.uint64Data[n]?e.uint64Data[n]=parseInt(t.uint64Data[n],10):"number"==typeof t.uint64Data[n]?e.uint64Data[n]=t.uint64Data[n]:"object"==typeof t.uint64Data[n]&&(e.uint64Data[n]=new c.LongBits(t.uint64Data[n].low>>>0,t.uint64Data[n].high>>>0).toNumber(!0))}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.dims=[],n.floatData=[],n.int32Data=[],n.stringData=[],n.int64Data=[],n.doubleData=[],n.uint64Data=[],n.externalData=[]),e.defaults&&(n.dataType=0,n.segment=null,n.name="",e.bytes===String?n.rawData="":(n.rawData=[],e.bytes!==Array&&(n.rawData=c.newBuffer(n.rawData))),n.docString="",n.dataLocation=e.enums===String?"DEFAULT":0),t.dims&&t.dims.length){n.dims=[];for(var r=0;r<t.dims.length;++r)"number"==typeof t.dims[r]?n.dims[r]=e.longs===String?String(t.dims[r]):t.dims[r]:n.dims[r]=e.longs===String?c.Long.prototype.toString.call(t.dims[r]):e.longs===Number?new c.LongBits(t.dims[r].low>>>0,t.dims[r].high>>>0).toNumber():t.dims[r]}if(null!=t.dataType&&t.hasOwnProperty("dataType")&&(n.dataType=t.dataType),null!=t.segment&&t.hasOwnProperty("segment")&&(n.segment=l.onnx.TensorProto.Segment.toObject(t.segment,e)),t.floatData&&t.floatData.length)for(n.floatData=[],r=0;r<t.floatData.length;++r)n.floatData[r]=e.json&&!isFinite(t.floatData[r])?String(t.floatData[r]):t.floatData[r];if(t.int32Data&&t.int32Data.length)for(n.int32Data=[],r=0;r<t.int32Data.length;++r)n.int32Data[r]=t.int32Data[r];if(t.stringData&&t.stringData.length)for(n.stringData=[],r=0;r<t.stringData.length;++r)n.stringData[r]=e.bytes===String?c.base64.encode(t.stringData[r],0,t.stringData[r].length):e.bytes===Array?Array.prototype.slice.call(t.stringData[r]):t.stringData[r];if(t.int64Data&&t.int64Data.length)for(n.int64Data=[],r=0;r<t.int64Data.length;++r)"number"==typeof t.int64Data[r]?n.int64Data[r]=e.longs===String?String(t.int64Data[r]):t.int64Data[r]:n.int64Data[r]=e.longs===String?c.Long.prototype.toString.call(t.int64Data[r]):e.longs===Number?new c.LongBits(t.int64Data[r].low>>>0,t.int64Data[r].high>>>0).toNumber():t.int64Data[r];if(null!=t.name&&t.hasOwnProperty("name")&&(n.name=t.name),null!=t.rawData&&t.hasOwnProperty("rawData")&&(n.rawData=e.bytes===String?c.base64.encode(t.rawData,0,t.rawData.length):e.bytes===Array?Array.prototype.slice.call(t.rawData):t.rawData),t.doubleData&&t.doubleData.length)for(n.doubleData=[],r=0;r<t.doubleData.length;++r)n.doubleData[r]=e.json&&!isFinite(t.doubleData[r])?String(t.doubleData[r]):t.doubleData[r];if(t.uint64Data&&t.uint64Data.length)for(n.uint64Data=[],r=0;r<t.uint64Data.length;++r)"number"==typeof t.uint64Data[r]?n.uint64Data[r]=e.longs===String?String(t.uint64Data[r]):t.uint64Data[r]:n.uint64Data[r]=e.longs===String?c.Long.prototype.toString.call(t.uint64Data[r]):e.longs===Number?new c.LongBits(t.uint64Data[r].low>>>0,t.uint64Data[r].high>>>0).toNumber(!0):t.uint64Data[r];if(null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),t.externalData&&t.externalData.length)for(n.externalData=[],r=0;r<t.externalData.length;++r)n.externalData[r]=l.onnx.StringStringEntryProto.toObject(t.externalData[r],e);return null!=t.dataLocation&&t.hasOwnProperty("dataLocation")&&(n.dataLocation=e.enums===String?l.onnx.TensorProto.DataLocation[t.dataLocation]:t.dataLocation),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t.DataType=function(){var t={},e=Object.create(t);return e[t[0]="UNDEFINED"]=0,e[t[1]="FLOAT"]=1,e[t[2]="UINT8"]=2,e[t[3]="INT8"]=3,e[t[4]="UINT16"]=4,e[t[5]="INT16"]=5,e[t[6]="INT32"]=6,e[t[7]="INT64"]=7,e[t[8]="STRING"]=8,e[t[9]="BOOL"]=9,e[t[10]="FLOAT16"]=10,e[t[11]="DOUBLE"]=11,e[t[12]="UINT32"]=12,e[t[13]="UINT64"]=13,e[t[14]="COMPLEX64"]=14,e[t[15]="COMPLEX128"]=15,e[t[16]="BFLOAT16"]=16,e}(),t.Segment=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.begin=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.end=c.Long?c.Long.fromBits(0,0,!1):0,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.begin&&t.hasOwnProperty("begin")&&e.uint32(8).int64(t.begin),null!=t.end&&t.hasOwnProperty("end")&&e.uint32(16).int64(t.end),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorProto.Segment;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.begin=t.int64();break;case 2:r.end=t.int64();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){return"object"!=typeof t||null===t?"object expected":null!=t.begin&&t.hasOwnProperty("begin")&&!(c.isInteger(t.begin)||t.begin&&c.isInteger(t.begin.low)&&c.isInteger(t.begin.high))?"begin: integer|Long expected":null!=t.end&&t.hasOwnProperty("end")&&!(c.isInteger(t.end)||t.end&&c.isInteger(t.end.low)&&c.isInteger(t.end.high))?"end: integer|Long expected":null},t.fromObject=function(t){if(t instanceof l.onnx.TensorProto.Segment)return t;var e=new l.onnx.TensorProto.Segment;return null!=t.begin&&(c.Long?(e.begin=c.Long.fromValue(t.begin)).unsigned=!1:"string"==typeof t.begin?e.begin=parseInt(t.begin,10):"number"==typeof t.begin?e.begin=t.begin:"object"==typeof t.begin&&(e.begin=new c.LongBits(t.begin.low>>>0,t.begin.high>>>0).toNumber())),null!=t.end&&(c.Long?(e.end=c.Long.fromValue(t.end)).unsigned=!1:"string"==typeof t.end?e.end=parseInt(t.end,10):"number"==typeof t.end?e.end=t.end:"object"==typeof t.end&&(e.end=new c.LongBits(t.end.low>>>0,t.end.high>>>0).toNumber())),e},t.toObject=function(t,e){e||(e={});var n={};if(e.defaults){if(c.Long){var r=new c.Long(0,0,!1);n.begin=e.longs===String?r.toString():e.longs===Number?r.toNumber():r}else n.begin=e.longs===String?"0":0;c.Long?(r=new c.Long(0,0,!1),n.end=e.longs===String?r.toString():e.longs===Number?r.toNumber():r):n.end=e.longs===String?"0":0}return null!=t.begin&&t.hasOwnProperty("begin")&&("number"==typeof t.begin?n.begin=e.longs===String?String(t.begin):t.begin:n.begin=e.longs===String?c.Long.prototype.toString.call(t.begin):e.longs===Number?new c.LongBits(t.begin.low>>>0,t.begin.high>>>0).toNumber():t.begin),null!=t.end&&t.hasOwnProperty("end")&&("number"==typeof t.end?n.end=e.longs===String?String(t.end):t.end:n.end=e.longs===String?c.Long.prototype.toString.call(t.end):e.longs===Number?new c.LongBits(t.end.low>>>0,t.end.high>>>0).toNumber():t.end),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),t.DataLocation=function(){var t={},e=Object.create(t);return e[t[0]="DEFAULT"]=0,e[t[1]="EXTERNAL"]=1,e}(),t}(),o.TensorShapeProto=function(){function t(t){if(this.dim=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.dim=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.dim&&t.dim.length)for(var n=0;n<t.dim.length;++n)l.onnx.TensorShapeProto.Dimension.encode(t.dim[n],e.uint32(10).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorShapeProto;t.pos<n;){var i=t.uint32();i>>>3==1?(r.dim&&r.dim.length||(r.dim=[]),r.dim.push(l.onnx.TensorShapeProto.Dimension.decode(t,t.uint32()))):t.skipType(7&i)}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.dim&&t.hasOwnProperty("dim")){if(!Array.isArray(t.dim))return"dim: array expected";for(var e=0;e<t.dim.length;++e){var n=l.onnx.TensorShapeProto.Dimension.verify(t.dim[e]);if(n)return"dim."+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.TensorShapeProto)return t;var e=new l.onnx.TensorShapeProto;if(t.dim){if(!Array.isArray(t.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");e.dim=[];for(var n=0;n<t.dim.length;++n){if("object"!=typeof t.dim[n])throw TypeError(".onnx.TensorShapeProto.dim: object expected");e.dim[n]=l.onnx.TensorShapeProto.Dimension.fromObject(t.dim[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.dim=[]),t.dim&&t.dim.length){n.dim=[];for(var r=0;r<t.dim.length;++r)n.dim[r]=l.onnx.TensorShapeProto.Dimension.toObject(t.dim[r],e)}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t.Dimension=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}var e;return t.prototype.dimValue=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.dimParam="",t.prototype.denotation="",Object.defineProperty(t.prototype,"value",{get:c.oneOfGetter(e=["dimValue","dimParam"]),set:c.oneOfSetter(e)}),t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.dimValue&&t.hasOwnProperty("dimValue")&&e.uint32(8).int64(t.dimValue),null!=t.dimParam&&t.hasOwnProperty("dimParam")&&e.uint32(18).string(t.dimParam),null!=t.denotation&&t.hasOwnProperty("denotation")&&e.uint32(26).string(t.denotation),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorShapeProto.Dimension;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.dimValue=t.int64();break;case 2:r.dimParam=t.string();break;case 3:r.denotation=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";var e={};if(null!=t.dimValue&&t.hasOwnProperty("dimValue")&&(e.value=1,!(c.isInteger(t.dimValue)||t.dimValue&&c.isInteger(t.dimValue.low)&&c.isInteger(t.dimValue.high))))return"dimValue: integer|Long expected";if(null!=t.dimParam&&t.hasOwnProperty("dimParam")){if(1===e.value)return"value: multiple values";if(e.value=1,!c.isString(t.dimParam))return"dimParam: string expected"}return null!=t.denotation&&t.hasOwnProperty("denotation")&&!c.isString(t.denotation)?"denotation: string expected":null},t.fromObject=function(t){if(t instanceof l.onnx.TensorShapeProto.Dimension)return t;var e=new l.onnx.TensorShapeProto.Dimension;return null!=t.dimValue&&(c.Long?(e.dimValue=c.Long.fromValue(t.dimValue)).unsigned=!1:"string"==typeof t.dimValue?e.dimValue=parseInt(t.dimValue,10):"number"==typeof t.dimValue?e.dimValue=t.dimValue:"object"==typeof t.dimValue&&(e.dimValue=new c.LongBits(t.dimValue.low>>>0,t.dimValue.high>>>0).toNumber())),null!=t.dimParam&&(e.dimParam=String(t.dimParam)),null!=t.denotation&&(e.denotation=String(t.denotation)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.denotation=""),null!=t.dimValue&&t.hasOwnProperty("dimValue")&&("number"==typeof t.dimValue?n.dimValue=e.longs===String?String(t.dimValue):t.dimValue:n.dimValue=e.longs===String?c.Long.prototype.toString.call(t.dimValue):e.longs===Number?new c.LongBits(t.dimValue.low>>>0,t.dimValue.high>>>0).toNumber():t.dimValue,e.oneofs&&(n.value="dimValue")),null!=t.dimParam&&t.hasOwnProperty("dimParam")&&(n.dimParam=t.dimParam,e.oneofs&&(n.value="dimParam")),null!=t.denotation&&t.hasOwnProperty("denotation")&&(n.denotation=t.denotation),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),t}(),o.TypeProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}var e;return t.prototype.tensorType=null,t.prototype.denotation="",Object.defineProperty(t.prototype,"value",{get:c.oneOfGetter(e=["tensorType"]),set:c.oneOfSetter(e)}),t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.tensorType&&t.hasOwnProperty("tensorType")&&l.onnx.TypeProto.Tensor.encode(t.tensorType,e.uint32(10).fork()).ldelim(),null!=t.denotation&&t.hasOwnProperty("denotation")&&e.uint32(50).string(t.denotation),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TypeProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.tensorType=l.onnx.TypeProto.Tensor.decode(t,t.uint32());break;case 6:r.denotation=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.tensorType&&t.hasOwnProperty("tensorType")){var e=l.onnx.TypeProto.Tensor.verify(t.tensorType);if(e)return"tensorType."+e}return null!=t.denotation&&t.hasOwnProperty("denotation")&&!c.isString(t.denotation)?"denotation: string expected":null},t.fromObject=function(t){if(t instanceof l.onnx.TypeProto)return t;var e=new l.onnx.TypeProto;if(null!=t.tensorType){if("object"!=typeof t.tensorType)throw TypeError(".onnx.TypeProto.tensorType: object expected");e.tensorType=l.onnx.TypeProto.Tensor.fromObject(t.tensorType)}return null!=t.denotation&&(e.denotation=String(t.denotation)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.denotation=""),null!=t.tensorType&&t.hasOwnProperty("tensorType")&&(n.tensorType=l.onnx.TypeProto.Tensor.toObject(t.tensorType,e),e.oneofs&&(n.value="tensorType")),null!=t.denotation&&t.hasOwnProperty("denotation")&&(n.denotation=t.denotation),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t.Tensor=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.elemType&&t.hasOwnProperty("elemType")&&e.uint32(8).int32(t.elemType),null!=t.shape&&t.hasOwnProperty("shape")&&l.onnx.TensorShapeProto.encode(t.shape,e.uint32(18).fork()).ldelim(),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TypeProto.Tensor;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.elemType=t.int32();break;case 2:r.shape=l.onnx.TensorShapeProto.decode(t,t.uint32());break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.elemType&&t.hasOwnProperty("elemType")&&!c.isInteger(t.elemType))return"elemType: integer expected";if(null!=t.shape&&t.hasOwnProperty("shape")){var e=l.onnx.TensorShapeProto.verify(t.shape);if(e)return"shape."+e}return null},t.fromObject=function(t){if(t instanceof l.onnx.TypeProto.Tensor)return t;var e=new l.onnx.TypeProto.Tensor;if(null!=t.elemType&&(e.elemType=0|t.elemType),null!=t.shape){if("object"!=typeof t.shape)throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");e.shape=l.onnx.TensorShapeProto.fromObject(t.shape)}return e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.elemType=0,n.shape=null),null!=t.elemType&&t.hasOwnProperty("elemType")&&(n.elemType=t.elemType),null!=t.shape&&t.hasOwnProperty("shape")&&(n.shape=l.onnx.TensorShapeProto.toObject(t.shape,e)),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),t}(),o.OperatorSetIdProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.domain="",t.prototype.version=c.Long?c.Long.fromBits(0,0,!1):0,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.domain&&t.hasOwnProperty("domain")&&e.uint32(10).string(t.domain),null!=t.version&&t.hasOwnProperty("version")&&e.uint32(16).int64(t.version),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.OperatorSetIdProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.domain=t.string();break;case 2:r.version=t.int64();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){return"object"!=typeof t||null===t?"object expected":null!=t.domain&&t.hasOwnProperty("domain")&&!c.isString(t.domain)?"domain: string expected":null!=t.version&&t.hasOwnProperty("version")&&!(c.isInteger(t.version)||t.version&&c.isInteger(t.version.low)&&c.isInteger(t.version.high))?"version: integer|Long expected":null},t.fromObject=function(t){if(t instanceof l.onnx.OperatorSetIdProto)return t;var e=new l.onnx.OperatorSetIdProto;return null!=t.domain&&(e.domain=String(t.domain)),null!=t.version&&(c.Long?(e.version=c.Long.fromValue(t.version)).unsigned=!1:"string"==typeof t.version?e.version=parseInt(t.version,10):"number"==typeof t.version?e.version=t.version:"object"==typeof t.version&&(e.version=new c.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber())),e},t.toObject=function(t,e){e||(e={});var n={};if(e.defaults)if(n.domain="",c.Long){var r=new c.Long(0,0,!1);n.version=e.longs===String?r.toString():e.longs===Number?r.toNumber():r}else n.version=e.longs===String?"0":0;return null!=t.domain&&t.hasOwnProperty("domain")&&(n.domain=t.domain),null!=t.version&&t.hasOwnProperty("version")&&("number"==typeof t.version?n.version=e.longs===String?String(t.version):t.version:n.version=e.longs===String?c.Long.prototype.toString.call(t.version):e.longs===Number?new c.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber():t.version),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o),t.exports=l},2100:(t,e,n)=>{"use strict";t.exports=n(9482)},9482:(t,e,n)=>{"use strict";var r=e;function i(){r.util._configure(),r.Writer._configure(r.BufferWriter),r.Reader._configure(r.BufferReader)}r.build="minimal",r.Writer=n(1173),r.BufferWriter=n(3155),r.Reader=n(1408),r.BufferReader=n(593),r.util=n(9693),r.rpc=n(5994),r.roots=n(5054),r.configure=i,i()},1408:(t,e,n)=>{"use strict";t.exports=u;var r,i=n(9693),o=i.LongBits,a=i.utf8;function s(t,e){return RangeError("index out of range: "+t.pos+" + "+(e||1)+" > "+t.len)}function u(t){this.buf=t,this.pos=0,this.len=t.length}var c,l="undefined"!=typeof Uint8Array?function(t){if(t instanceof Uint8Array||Array.isArray(t))return new u(t);throw Error("illegal buffer")}:function(t){if(Array.isArray(t))return new u(t);throw Error("illegal buffer")},p=function(){return i.Buffer?function(t){return(u.create=function(t){return i.Buffer.isBuffer(t)?new r(t):l(t)})(t)}:l};function f(){var t=new o(0,0),e=0;if(!(this.len-this.pos>4)){for(;e<3;++e){if(this.pos>=this.len)throw s(this);if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*e)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(127&this.buf[this.pos++])<<7*e)>>>0,t}for(;e<4;++e)if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*e)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(127&this.buf[this.pos])<<28)>>>0,t.hi=(t.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return t;if(e=0,this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*e+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw s(this);if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*e+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}function d(t,e){return(t[e-4]|t[e-3]<<8|t[e-2]<<16|t[e-1]<<24)>>>0}function h(){if(this.pos+8>this.len)throw s(this,8);return new o(d(this.buf,this.pos+=4),d(this.buf,this.pos+=4))}u.create=p(),u.prototype._slice=i.Array.prototype.subarray||i.Array.prototype.slice,u.prototype.uint32=(c=4294967295,function(){if(c=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return c;if(c=(c|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return c;if(c=(c|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return c;if(c=(c|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return c;if(c=(c|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return c;if((this.pos+=5)>this.len)throw this.pos=this.len,s(this,10);return c}),u.prototype.int32=function(){return 0|this.uint32()},u.prototype.sint32=function(){var t=this.uint32();return t>>>1^-(1&t)|0},u.prototype.bool=function(){return 0!==this.uint32()},u.prototype.fixed32=function(){if(this.pos+4>this.len)throw s(this,4);return d(this.buf,this.pos+=4)},u.prototype.sfixed32=function(){if(this.pos+4>this.len)throw s(this,4);return 0|d(this.buf,this.pos+=4)},u.prototype.float=function(){if(this.pos+4>this.len)throw s(this,4);var t=i.float.readFloatLE(this.buf,this.pos);return this.pos+=4,t},u.prototype.double=function(){if(this.pos+8>this.len)throw s(this,4);var t=i.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,t},u.prototype.bytes=function(){var t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw s(this,t);return this.pos+=t,Array.isArray(this.buf)?this.buf.slice(e,n):e===n?new this.buf.constructor(0):this._slice.call(this.buf,e,n)},u.prototype.string=function(){var t=this.bytes();return a.read(t,0,t.length)},u.prototype.skip=function(t){if("number"==typeof t){if(this.pos+t>this.len)throw s(this,t);this.pos+=t}else do{if(this.pos>=this.len)throw s(this)}while(128&this.buf[this.pos++]);return this},u.prototype.skipType=function(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(t=7&this.uint32());)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+t+" at offset "+this.pos)}return this},u._configure=function(t){r=t,u.create=p(),r._configure();var e=i.Long?"toLong":"toNumber";i.merge(u.prototype,{int64:function(){return f.call(this)[e](!1)},uint64:function(){return f.call(this)[e](!0)},sint64:function(){return f.call(this).zzDecode()[e](!1)},fixed64:function(){return h.call(this)[e](!0)},sfixed64:function(){return h.call(this)[e](!1)}})}},593:(t,e,n)=>{"use strict";t.exports=o;var r=n(1408);(o.prototype=Object.create(r.prototype)).constructor=o;var i=n(9693);function o(t){r.call(this,t)}o._configure=function(){i.Buffer&&(o.prototype._slice=i.Buffer.prototype.slice)},o.prototype.string=function(){var t=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+t,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+t,this.len))},o._configure()},5054:t=>{"use strict";t.exports={}},5994:(t,e,n)=>{"use strict";e.Service=n(7948)},7948:(t,e,n)=>{"use strict";t.exports=i;var r=n(9693);function i(t,e,n){if("function"!=typeof t)throw TypeError("rpcImpl must be a function");r.EventEmitter.call(this),this.rpcImpl=t,this.requestDelimited=Boolean(e),this.responseDelimited=Boolean(n)}(i.prototype=Object.create(r.EventEmitter.prototype)).constructor=i,i.prototype.rpcCall=function t(e,n,i,o,a){if(!o)throw TypeError("request must be specified");var s=this;if(!a)return r.asPromise(t,s,e,n,i,o);if(s.rpcImpl)try{return s.rpcImpl(e,n[s.requestDelimited?"encodeDelimited":"encode"](o).finish(),(function(t,n){if(t)return s.emit("error",t,e),a(t);if(null!==n){if(!(n instanceof i))try{n=i[s.responseDelimited?"decodeDelimited":"decode"](n)}catch(t){return s.emit("error",t,e),a(t)}return s.emit("data",n,e),a(null,n)}s.end(!0)}))}catch(t){return s.emit("error",t,e),void setTimeout((function(){a(t)}),0)}else setTimeout((function(){a(Error("already ended"))}),0)},i.prototype.end=function(t){return this.rpcImpl&&(t||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(t,e,n)=>{"use strict";t.exports=i;var r=n(9693);function i(t,e){this.lo=t>>>0,this.hi=e>>>0}var o=i.zero=new i(0,0);o.toNumber=function(){return 0},o.zzEncode=o.zzDecode=function(){return this},o.length=function(){return 1};var a=i.zeroHash="\0\0\0\0\0\0\0\0";i.fromNumber=function(t){if(0===t)return o;var e=t<0;e&&(t=-t);var n=t>>>0,r=(t-n)/4294967296>>>0;return e&&(r=~r>>>0,n=~n>>>0,++n>4294967295&&(n=0,++r>4294967295&&(r=0))),new i(n,r)},i.from=function(t){if("number"==typeof t)return i.fromNumber(t);if(r.isString(t)){if(!r.Long)return i.fromNumber(parseInt(t,10));t=r.Long.fromString(t)}return t.low||t.high?new i(t.low>>>0,t.high>>>0):o},i.prototype.toNumber=function(t){if(!t&&this.hi>>>31){var e=1+~this.lo>>>0,n=~this.hi>>>0;return e||(n=n+1>>>0),-(e+4294967296*n)}return this.lo+4294967296*this.hi},i.prototype.toLong=function(t){return r.Long?new r.Long(0|this.lo,0|this.hi,Boolean(t)):{low:0|this.lo,high:0|this.hi,unsigned:Boolean(t)}};var s=String.prototype.charCodeAt;i.fromHash=function(t){return t===a?o:new i((s.call(t,0)|s.call(t,1)<<8|s.call(t,2)<<16|s.call(t,3)<<24)>>>0,(s.call(t,4)|s.call(t,5)<<8|s.call(t,6)<<16|s.call(t,7)<<24)>>>0)},i.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},i.prototype.zzEncode=function(){var t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this},i.prototype.zzDecode=function(){var t=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this},i.prototype.length=function(){var t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return 0===n?0===e?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}},9693:function(t,e,n){"use strict";var r=e;function i(t,e,n){for(var r=Object.keys(e),i=0;i<r.length;++i)void 0!==t[r[i]]&&n||(t[r[i]]=e[r[i]]);return t}function o(t){function e(t,n){if(!(this instanceof e))return new e(t,n);Object.defineProperty(this,"message",{get:function(){return t}}),Error.captureStackTrace?Error.captureStackTrace(this,e):Object.defineProperty(this,"stack",{value:(new Error).stack||""}),n&&i(this,n)}return(e.prototype=Object.create(Error.prototype)).constructor=e,Object.defineProperty(e.prototype,"name",{get:function(){return t}}),e.prototype.toString=function(){return this.name+": "+this.message},e}r.asPromise=n(4537),r.base64=n(7419),r.EventEmitter=n(9211),r.float=n(945),r.inquire=n(7199),r.utf8=n(4997),r.pool=n(6662),r.LongBits=n(1945),r.isNode=Boolean(void 0!==n.g&&n.g&&n.g.process&&n.g.process.versions&&n.g.process.versions.node),r.global=r.isNode&&n.g||"undefined"!=typeof window&&window||"undefined"!=typeof self&&self||this,r.emptyArray=Object.freeze?Object.freeze([]):[],r.emptyObject=Object.freeze?Object.freeze({}):{},r.isInteger=Number.isInteger||function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t},r.isString=function(t){return"string"==typeof t||t instanceof String},r.isObject=function(t){return t&&"object"==typeof t},r.isset=r.isSet=function(t,e){var n=t[e];return!(null==n||!t.hasOwnProperty(e))&&("object"!=typeof n||(Array.isArray(n)?n.length:Object.keys(n).length)>0)},r.Buffer=function(){try{var t=r.inquire("buffer").Buffer;return t.prototype.utf8Write?t:null}catch(t){return null}}(),r._Buffer_from=null,r._Buffer_allocUnsafe=null,r.newBuffer=function(t){return"number"==typeof t?r.Buffer?r._Buffer_allocUnsafe(t):new r.Array(t):r.Buffer?r._Buffer_from(t):"undefined"==typeof Uint8Array?t:new Uint8Array(t)},r.Array="undefined"!=typeof Uint8Array?Uint8Array:Array,r.Long=r.global.dcodeIO&&r.global.dcodeIO.Long||r.global.Long||r.inquire("long"),r.key2Re=/^true|false|0|1$/,r.key32Re=/^-?(?:0|[1-9][0-9]*)$/,r.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,r.longToHash=function(t){return t?r.LongBits.from(t).toHash():r.LongBits.zeroHash},r.longFromHash=function(t,e){var n=r.LongBits.fromHash(t);return r.Long?r.Long.fromBits(n.lo,n.hi,e):n.toNumber(Boolean(e))},r.merge=i,r.lcFirst=function(t){return t.charAt(0).toLowerCase()+t.substring(1)},r.newError=o,r.ProtocolError=o("ProtocolError"),r.oneOfGetter=function(t){for(var e={},n=0;n<t.length;++n)e[t[n]]=1;return function(){for(var t=Object.keys(this),n=t.length-1;n>-1;--n)if(1===e[t[n]]&&void 0!==this[t[n]]&&null!==this[t[n]])return t[n]}},r.oneOfSetter=function(t){return function(e){for(var n=0;n<t.length;++n)t[n]!==e&&delete this[t[n]]}},r.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},r._configure=function(){var t=r.Buffer;t?(r._Buffer_from=t.from!==Uint8Array.from&&t.from||function(e,n){return new t(e,n)},r._Buffer_allocUnsafe=t.allocUnsafe||function(e){return new t(e)}):r._Buffer_from=r._Buffer_allocUnsafe=null}},1173:(t,e,n)=>{"use strict";t.exports=p;var r,i=n(9693),o=i.LongBits,a=i.base64,s=i.utf8;function u(t,e,n){this.fn=t,this.len=e,this.next=void 0,this.val=n}function c(){}function l(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}function p(){this.len=0,this.head=new u(c,0,0),this.tail=this.head,this.states=null}var f=function(){return i.Buffer?function(){return(p.create=function(){return new r})()}:function(){return new p}};function d(t,e,n){e[n]=255&t}function h(t,e){this.len=t,this.next=void 0,this.val=e}function g(t,e,n){for(;t.hi;)e[n++]=127&t.lo|128,t.lo=(t.lo>>>7|t.hi<<25)>>>0,t.hi>>>=7;for(;t.lo>127;)e[n++]=127&t.lo|128,t.lo=t.lo>>>7;e[n++]=t.lo}function b(t,e,n){e[n]=255&t,e[n+1]=t>>>8&255,e[n+2]=t>>>16&255,e[n+3]=t>>>24}p.create=f(),p.alloc=function(t){return new i.Array(t)},i.Array!==Array&&(p.alloc=i.pool(p.alloc,i.Array.prototype.subarray)),p.prototype._push=function(t,e,n){return this.tail=this.tail.next=new u(t,e,n),this.len+=e,this},h.prototype=Object.create(u.prototype),h.prototype.fn=function(t,e,n){for(;t>127;)e[n++]=127&t|128,t>>>=7;e[n]=t},p.prototype.uint32=function(t){return this.len+=(this.tail=this.tail.next=new h((t>>>=0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this},p.prototype.int32=function(t){return t<0?this._push(g,10,o.fromNumber(t)):this.uint32(t)},p.prototype.sint32=function(t){return this.uint32((t<<1^t>>31)>>>0)},p.prototype.uint64=function(t){var e=o.from(t);return this._push(g,e.length(),e)},p.prototype.int64=p.prototype.uint64,p.prototype.sint64=function(t){var e=o.from(t).zzEncode();return this._push(g,e.length(),e)},p.prototype.bool=function(t){return this._push(d,1,t?1:0)},p.prototype.fixed32=function(t){return this._push(b,4,t>>>0)},p.prototype.sfixed32=p.prototype.fixed32,p.prototype.fixed64=function(t){var e=o.from(t);return this._push(b,4,e.lo)._push(b,4,e.hi)},p.prototype.sfixed64=p.prototype.fixed64,p.prototype.float=function(t){return this._push(i.float.writeFloatLE,4,t)},p.prototype.double=function(t){return this._push(i.float.writeDoubleLE,8,t)};var m=i.Array.prototype.set?function(t,e,n){e.set(t,n)}:function(t,e,n){for(var r=0;r<t.length;++r)e[n+r]=t[r]};p.prototype.bytes=function(t){var e=t.length>>>0;if(!e)return this._push(d,1,0);if(i.isString(t)){var n=p.alloc(e=a.length(t));a.decode(t,n,0),t=n}return this.uint32(e)._push(m,e,t)},p.prototype.string=function(t){var e=s.length(t);return e?this.uint32(e)._push(s.write,e,t):this._push(d,1,0)},p.prototype.fork=function(){return this.states=new l(this),this.head=this.tail=new u(c,0,0),this.len=0,this},p.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new u(c,0,0),this.len=0),this},p.prototype.ldelim=function(){var t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n&&(this.tail.next=t.next,this.tail=e,this.len+=n),this},p.prototype.finish=function(){for(var t=this.head.next,e=this.constructor.alloc(this.len),n=0;t;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e},p._configure=function(t){r=t,p.create=f(),r._configure()}},3155:(t,e,n)=>{"use strict";t.exports=o;var r=n(1173);(o.prototype=Object.create(r.prototype)).constructor=o;var i=n(9693);function o(){r.call(this)}function a(t,e,n){t.length<40?i.utf8.write(t,e,n):e.utf8Write?e.utf8Write(t,n):e.write(t,n)}o._configure=function(){o.alloc=i._Buffer_allocUnsafe,o.writeBytesBuffer=i.Buffer&&i.Buffer.prototype instanceof Uint8Array&&"set"===i.Buffer.prototype.set.name?function(t,e,n){e.set(t,n)}:function(t,e,n){if(t.copy)t.copy(e,n,0,t.length);else for(var r=0;r<t.length;)e[n++]=t[r++]}},o.prototype.bytes=function(t){i.isString(t)&&(t=i._Buffer_from(t,"base64"));var e=t.length>>>0;return this.uint32(e),e&&this._push(o.writeBytesBuffer,e,t),this},o.prototype.string=function(t){var e=i.Buffer.byteLength(t);return this.uint32(e),e&&this._push(a,e,t),this},o._configure()},7714:(t,e,n)=>{"use strict";e.R=void 0;const r=n(6919),i=n(7448);e.R=new class{async init(){}async createSessionHandler(t,e){const n=new r.Session(e);return await n.loadModel(t),new i.OnnxjsSessionHandler(n)}}},4200:(t,e,n)=>{"use strict";e.c8=e.rX=void 0;const r=n(1670),i=n(5381),o=n(2157),a=n(2306);e.rX=()=>{if(("number"!=typeof r.env.wasm.initTimeout||r.env.wasm.initTimeout<0)&&(r.env.wasm.initTimeout=0),"boolean"!=typeof r.env.wasm.simd&&(r.env.wasm.simd=!0),"boolean"!=typeof r.env.wasm.proxy&&(r.env.wasm.proxy=!1),"number"!=typeof r.env.wasm.numThreads||!Number.isInteger(r.env.wasm.numThreads)||r.env.wasm.numThreads<=0){const t="undefined"==typeof navigator?(0,i.cpus)().length:navigator.hardwareConcurrency;r.env.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},e.c8=new class{async init(){(0,e.rX)(),await(0,o.initWasm)()}async createSessionHandler(t,e){const n=new a.OnnxruntimeWebAssemblySessionHandler;return await n.loadModel(t,e),Promise.resolve(n)}}},6018:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),i=this&&this.__exportStar||function(t,e){for(var n in t)"default"===n||Object.prototype.hasOwnProperty.call(e,n)||r(e,t,n)};Object.defineProperty(e,"__esModule",{value:!0}),i(n(1670),e);const o=n(1670);{const t=n(7714).R;(0,o.registerBackend)("webgl",t,-10)}{const t=n(4200).c8;(0,o.registerBackend)("cpu",t,10),(0,o.registerBackend)("wasm",t,10),(0,o.registerBackend)("xnnpack",t,9)}},246:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createAttributeWithCacheKey=void 0;class n{constructor(t){Object.assign(this,t)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((t=>`${this[t]}`)).join(";")),this._cacheKey}}e.createAttributeWithCacheKey=t=>new n(t)},7778:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Attribute=void 0;const r=n(1446),i=n(9395),o=n(9162),a=n(2517);var s=i.onnxruntime.experimental.fbs;class u{constructor(t){if(this._attributes=new Map,null!=t){for(const e of t)e instanceof r.onnx.AttributeProto?this._attributes.set(e.name,[u.getValue(e),u.getType(e)]):e instanceof s.Attribute&&this._attributes.set(e.name(),[u.getValue(e),u.getType(e)]);if(this._attributes.size<t.length)throw new Error("duplicated attribute names")}}set(t,e,n){this._attributes.set(t,[n,e])}delete(t){this._attributes.delete(t)}getFloat(t,e){return this.get(t,"float",e)}getInt(t,e){return this.get(t,"int",e)}getString(t,e){return this.get(t,"string",e)}getTensor(t,e){return this.get(t,"tensor",e)}getFloats(t,e){return this.get(t,"floats",e)}getInts(t,e){return this.get(t,"ints",e)}getStrings(t,e){return this.get(t,"strings",e)}getTensors(t,e){return this.get(t,"tensors",e)}get(t,e,n){const r=this._attributes.get(t);if(void 0===r){if(void 0!==n)return n;throw new Error(`required attribute not found: ${t}`)}if(r[1]!==e)throw new Error(`type mismatch: expected ${e} but got ${r[1]}`);return r[0]}static getType(t){const e=t instanceof r.onnx.AttributeProto?t.type:t.type();switch(e){case r.onnx.AttributeProto.AttributeType.FLOAT:return"float";case r.onnx.AttributeProto.AttributeType.INT:return"int";case r.onnx.AttributeProto.AttributeType.STRING:return"string";case r.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case r.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case r.onnx.AttributeProto.AttributeType.INTS:return"ints";case r.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case r.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${r.onnx.AttributeProto.AttributeType[e]}`)}}static getValue(t){const e=t instanceof r.onnx.AttributeProto?t.type:t.type();if(e===r.onnx.AttributeProto.AttributeType.GRAPH||e===r.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const n=this.getValueNoCheck(t);if(e===r.onnx.AttributeProto.AttributeType.INT&&a.LongUtil.isLong(n))return a.LongUtil.longToNumber(n);if(e===r.onnx.AttributeProto.AttributeType.INTS){const t=n,e=new Array(t.length);for(let n=0;n<t.length;n++){const r=t[n];e[n]=a.LongUtil.longToNumber(r)}return e}if(e===r.onnx.AttributeProto.AttributeType.TENSOR)return t instanceof r.onnx.AttributeProto?o.Tensor.fromProto(n):o.Tensor.fromOrtTensor(n);if(e===r.onnx.AttributeProto.AttributeType.TENSORS){if(t instanceof r.onnx.AttributeProto)return n.map((t=>o.Tensor.fromProto(t)));if(t instanceof s.Attribute)return n.map((t=>o.Tensor.fromOrtTensor(t)))}if(e===r.onnx.AttributeProto.AttributeType.STRING&&t instanceof r.onnx.AttributeProto){const t=n;return(0,a.decodeUtf8String)(t)}return e===r.onnx.AttributeProto.AttributeType.STRINGS&&t instanceof r.onnx.AttributeProto?n.map(a.decodeUtf8String):n}static getValueNoCheck(t){return t instanceof r.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(t):this.getValueNoCheckFromOrtFormat(t)}static getValueNoCheckFromOnnxFormat(t){switch(t.type){case r.onnx.AttributeProto.AttributeType.FLOAT:return t.f;case r.onnx.AttributeProto.AttributeType.INT:return t.i;case r.onnx.AttributeProto.AttributeType.STRING:return t.s;case r.onnx.AttributeProto.AttributeType.TENSOR:return t.t;case r.onnx.AttributeProto.AttributeType.GRAPH:return t.g;case r.onnx.AttributeProto.AttributeType.FLOATS:return t.floats;case r.onnx.AttributeProto.AttributeType.INTS:return t.ints;case r.onnx.AttributeProto.AttributeType.STRINGS:return t.strings;case r.onnx.AttributeProto.AttributeType.TENSORS:return t.tensors;case r.onnx.AttributeProto.AttributeType.GRAPHS:return t.graphs;default:throw new Error(`unsupported attribute type: ${r.onnx.AttributeProto.AttributeType[t.type]}`)}}static getValueNoCheckFromOrtFormat(t){switch(t.type()){case s.AttributeType.FLOAT:return t.f();case s.AttributeType.INT:return t.i();case s.AttributeType.STRING:return t.s();case s.AttributeType.TENSOR:return t.t();case s.AttributeType.GRAPH:return t.g();case s.AttributeType.FLOATS:return t.floatsArray();case s.AttributeType.INTS:{const e=[];for(let n=0;n<t.intsLength();n++)e.push(t.ints(n));return e}case s.AttributeType.STRINGS:{const e=[];for(let n=0;n<t.stringsLength();n++)e.push(t.strings(n));return e}case s.AttributeType.TENSORS:{const e=[];for(let n=0;n<t.tensorsLength();n++)e.push(t.tensors(n));return e}default:throw new Error(`unsupported attribute type: ${s.AttributeType[t.type()]}`)}}}e.Attribute=u},7091:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.resolveBackend=e.backend=void 0;const r=n(5038),i=new Map;async function o(t){const n=e.backend;if(void 0!==n[t]&&function(t){const e=t;return"initialize"in e&&"function"==typeof e.initialize&&"createSessionHandler"in e&&"function"==typeof e.createSessionHandler&&"dispose"in e&&"function"==typeof e.dispose}(n[t])){const e=n[t];let r=e.initialize();if("object"==typeof r&&"then"in r&&(r=await r),r)return i.set(t,e),e}}e.backend={webgl:new r.WebGLBackend},e.resolveBackend=async function t(e){if(!e)return t(["webgl"]);{const t="string"==typeof e?[e]:e;for(const e of t){const t=i.get(e);if(t)return t;const n=await o(e);if(n)return n}}throw new Error("no available backend to use")}},5038:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLBackend=void 0;const r=n(1670),i=n(6231),o=n(6416),a=n(7305);e.WebGLBackend=class{get contextId(){return r.env.webgl.contextId}set contextId(t){r.env.webgl.contextId=t}get matmulMaxBatchSize(){return r.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(t){r.env.webgl.matmulMaxBatchSize=t}get textureCacheMode(){return r.env.webgl.textureCacheMode}set textureCacheMode(t){r.env.webgl.textureCacheMode=t}get pack(){return r.env.webgl.pack}set pack(t){r.env.webgl.pack=t}get async(){return r.env.webgl.async}set async(t){r.env.webgl.async=t}initialize(){try{return this.glContext=(0,a.createWebGLContext)(this.contextId),"number"!=typeof this.matmulMaxBatchSize&&(this.matmulMaxBatchSize=16),"string"!=typeof this.textureCacheMode&&(this.textureCacheMode="full"),"boolean"!=typeof this.pack&&(this.pack=!1),"boolean"!=typeof this.async&&(this.async=!1),i.Logger.setWithEnv(r.env),i.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(t){return i.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${t}`),!1}}createSessionHandler(t){return new o.WebGLSessionHandler(this,t)}dispose(){this.glContext.dispose()}}},5107:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.CoordsGlslLib=void 0;const r=n(2517),i=n(8520),o=n(5060),a=n(7859),s=n(9390);class u extends i.GlslLib{constructor(t){super(t)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new i.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ")}}coordsToOffset(){return{coordsToOffset:new i.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ")}}getOutputSamplingSnippet(){const t=this.context.outputTextureLayout;return t.isPacked?this.getPackedOutputSamplingSnippet(t):this.getUnpackedOutputSamplingSnippet(t)}getPackedOutputSamplingSnippet(t){const e=t.unpackedShape,n=[t.width,t.height],r={},a="getOutputCoords";switch(e.length){case 0:r[a]=this.getOutputScalarCoords();break;case 1:r[a]=this.getOutputPacked1DCoords(e,n);break;case 2:r[a]=this.getOutputPacked2DCoords(e,n);break;case 3:r[a]=this.getOutputPacked3DCoords(e,n);break;default:r[a]=this.getOutputPackedNDCoords(e,n)}const s=`\n      void setOutput(vec4 val) {\n        ${(0,o.getGlsl)(this.context.glContext.version).output} = val;\n      }\n    `;return r.floatTextureSetRGBA=new i.GlslLibRoutine(s),r}getUnpackedOutputSamplingSnippet(t){const e=t.unpackedShape,n=[t.width,t.height],r={},a="getOutputCoords";switch(e.length){case 0:r[a]=this.getOutputScalarCoords();break;case 1:r[a]=this.getOutputUnpacked1DCoords(e,n);break;case 2:r[a]=this.getOutputUnpacked2DCoords(e,n);break;case 3:r[a]=this.getOutputUnpacked3DCoords(e,n);break;case 4:r[a]=this.getOutputUnpacked4DCoords(e,n);break;case 5:r[a]=this.getOutputUnpacked5DCoords(e,n);break;case 6:r[a]=this.getOutputUnpacked6DCoords(e,n);break;default:throw new Error(`Unsupported output dimensionality: ${e.length}`)}const s=`\n        void setOutput(float val) {\n          ${(0,o.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\n        }\n    `;return r.floatTextureSetR=new i.GlslLibRoutine(s),r}getOutputScalarCoords(){return new i.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ")}getOutputPacked1DCoords(t,e){const n=e;let r="";return 1===n[0]?(r=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${n[1]}.0);\n          }\n        `,new i.GlslLibRoutine(r)):1===n[1]?(r=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${n[0]}.0);\n          }\n        `,new i.GlslLibRoutine(r)):(r=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${n[0]}, ${n[1]}));\n          return 2 * (resTexRC.y * ${n[0]} + resTexRC.x);\n        }\n      `,new i.GlslLibRoutine(r))}getOutputPacked2DCoords(t,e){let n="";if(r.ArrayUtil.arraysEqual(t,e))return n=`\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${e[0]}, ${e[1]}));\n        }\n      `,new i.GlslLibRoutine(n);const o=e,a=Math.ceil(t[1]/2);return n=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${o[0]}, ${o[1]}));\n\n          int index = resTexRC.y * ${o[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${a}) * 2;\n          int c = 2 * (index / ${a});\n\n          return ivec2(r, c);\n        }\n      `,new i.GlslLibRoutine(n)}getOutputPacked3DCoords(t,e){const n=[e[0],e[1]],r=Math.ceil(t[2]/2),o=r*Math.ceil(t[1]/2),a=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${n[0]}, ${n[1]}));\n          int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n          int b = index / ${o};\n          index -= b * ${o};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${r}) * 2;\n          int c = 2 * (index / ${r});\n\n          return ivec3(b, r, c);\n        }\n      `;return new i.GlslLibRoutine(a)}getOutputPackedNDCoords(t,e){const n=[e[0],e[1]],r=Math.ceil(t[t.length-1]/2),o=r*Math.ceil(t[t.length-2]/2);let a=o,s="",u="b, r, c";for(let e=2;e<t.length-1;e++)a*=t[t.length-e-1],s=`\n      int b${e} = index / ${a};\n      index -= b${e} * ${a};\n    `+s,u=`b${e}, `+u;const c=`\n      ivec${t.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n        ${s}\n\n        int b = index / ${o};\n        index -= b * ${o};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${r}) * 2;\n        int c = 2 * (index / ${r});\n\n        return ivec${t.length}(${u});\n      }\n    `;return new i.GlslLibRoutine(c)}getOutputUnpacked1DCoords(t,e){const n=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          return resTexRC.y * ${e[0]} + resTexRC.x;\n        }\n      `;return new i.GlslLibRoutine(n)}getOutputUnpacked2DCoords(t,e){const n=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\n          int r = index / ${t[1]};\n          int c = index - r * ${t[1]};\n          return ivec2(r, c);\n        }\n      `;return new i.GlslLibRoutine(n)}getOutputUnpacked3DCoords(t,e){let n="";const r=t.length;let o=null;r<2&&(o=[]),o=new Array(r-1),o[r-2]=t[r-1];for(let e=r-3;e>=0;--e)o[e]=o[e+1]*t[e+1];const a=["r","c","d"],s=o.map(((t,e)=>`int ${a[e]} = index / ${t}; ${e===o.length-1?`int ${a[e+1]} = index - ${a[e]} * ${t}`:`index -= ${a[e]} * ${t}`};`)).join("");return n=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\n          ${s}\n          return ivec3(r, c, d);\n        }\n      `,new i.GlslLibRoutine(n)}getOutputUnpacked4DCoords(t,e){let n="";const r=t.length;let o=null;r<2&&(o=[]),o=new Array(r-1),o[r-2]=t[r-1];for(let e=r-3;e>=0;--e)o[e]=o[e+1]*t[e+1];const a=["r","c","d","d2"],s=o.map(((t,e)=>`int ${a[e]} = index / ${t}; ${e===o.length-1?`int ${a[e+1]} = index - ${a[e]} * ${t}`:`index -= ${a[e]} * ${t}`};`)).join("");return n=`\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\n          ${s}\n          return ivec4(r, c, d, d2);\n        }\n      `,new i.GlslLibRoutine(n)}getOutputUnpacked5DCoords(t,e){let n="";const r=t.length;let o=null;r<2&&(o=[]),o=new Array(r-1),o[r-2]=t[r-1];for(let e=r-3;e>=0;--e)o[e]=o[e+1]*t[e+1];const a=["r","c","d","d2","d3"],s=o.map(((t,e)=>`int ${a[e]} = index / ${t}; ${e===o.length-1?`int ${a[e+1]} = index - ${a[e]} * ${t}`:`index -= ${a[e]} * ${t}`};`)).join("");return n=`\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\n          ${s}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `,new i.GlslLibRoutine(n)}getOutputUnpacked6DCoords(t,e){let n="";const r=t.length;let o=null;r<2&&(o=[]),o=new Array(r-1),o[r-2]=t[r-1];for(let e=r-3;e>=0;--e)o[e]=o[e+1]*t[e+1];const a=["r","c","d","d2","d3","d4"],s=o.map(((t,e)=>`int ${a[e]} = index / ${t}; ${e===o.length-1?`int ${a[e+1]} = index - ${a[e]} * ${t}`:`index -= ${a[e]} * ${t}`};`)).join("");return n=`\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${e[0]}, ${e[1]}));\n         int index = resTexRC.y * ${e[0]} + resTexRC.x;\n         ${s}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `,new i.GlslLibRoutine(n)}getCommonUtilFuncs(){const t={};let e="uvFromFlat";t[e]=new i.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "),e="packedUVfrom1D",t[e]=new i.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),e="packedUVfrom2D",t[e]=new i.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),e="packedUVfrom3D",t[e]=new i.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),e="sampleTexture";const n=(0,o.getGlsl)(this.context.glContext.version);return t[e]=new i.GlslLibRoutine(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${n.texture2D}(textureSampler, uv).r;\n        }`),t}getInputsSamplingSnippets(){const t={},e=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach(((n,r)=>{const i=this.context.inputTextureLayouts[r],o=(0,s.generateShaderFuncNameFromInputSamplerName)(n);i.isPacked?t[o]=this.getPackedSamplerFromInput(o,n,i):t[o]=this.getUnpackedSamplerFromInput(o,n,i);const a=(0,s.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n);i.unpackedShape.length<=e.unpackedShape.length&&(i.isPacked?t[a]=this.getPackedSamplerAtOutputCoords(a,i,e,n):t[a]=this.getUnpackedSamplerAtOutputCoords(a,i,e,n))})),t}getPackedSamplerAtOutputCoords(t,e,n,o){const a=e.unpackedShape,u=n.unpackedShape,c=o,l=(0,s.generateShaderFuncNameFromInputSamplerName)(c),p=a.length,f=u.length,d=r.BroadcastUtil.getBroadcastDims(a,u),h=(0,s.getCoordsDataType)(f),g=f-p;let b;const m=(0,s.getGlChannels)();b=0===p?"":f<2&&d.length>=1?"coords = 0;":d.map((t=>`coords.${m[t+g]} = 0;`)).join("\n");let y="";y=f<2&&p>0?"coords":a.map(((t,e)=>`coords.${m[e+g]}`)).join(", ");let _="return outputValue;";const v=1===r.ShapeUtil.size(a),w=1===r.ShapeUtil.size(u);if(1!==p||v||w){if(v&&!w)_=1===f?"\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        ":"\n          return vec4(outputValue.x);\n        ";else if(d.length){const t=p-2,e=p-1;d.indexOf(t)>-1&&d.indexOf(e)>-1?_="return vec4(outputValue.x);":d.indexOf(t)>-1?_="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":d.indexOf(e)>-1&&(_="return vec4(outputValue.xx, outputValue.zz);")}}else _="\n        return vec4(outputValue.xy, outputValue.xy);\n      ";const x=`\n      vec4 ${t}() {\n        ${h} coords = getOutputCoords();\n        \n        int lastDim = coords.${m[f-1]};\n        coords.${m[f-1]} = coords.${m[f-2]};\n        coords.${m[f-2]} = lastDim;\n      \n        ${b}\n        vec4 outputValue = ${l}(${y});\n        ${_}\n      }\n    `;return new i.GlslLibRoutine(x,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(t,e,n,o){const a=[n.width,n.height],u=[e.width,e.height],c=e.unpackedShape.length,l=n.unpackedShape.length,p=e.unpackedShape,f=n.unpackedShape,d=(0,s.generateShaderFuncNameFromInputSamplerName)(o);if(c===l&&r.ArrayUtil.arraysEqual(u,a)){const e=`\n          float ${t}() {\n            return sampleTexture(${o}, TexCoords);\n          }\n        `;return new i.GlslLibRoutine(e,["coordinates.sampleTexture"])}const h=(0,s.getCoordsDataType)(l),g=r.BroadcastUtil.getBroadcastDims(p,f),b=l-c;let m;const y=(0,s.getGlChannels)();m=0===c?"":l<2&&g.length>=1?"coords = 0;":g.map((t=>`coords.${y[t+b]} = 0;`)).join("\n");let _="";_=l<2&&c>0?"coords":e.unpackedShape.map(((t,e)=>`coords.${y[e+b]}`)).join(", ");const v=`\n        float ${t}() {\n          ${h} coords = getOutputCoords();\n          ${m}\n          return ${d}(${_});\n        }\n      `;return new i.GlslLibRoutine(v,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(t,e,n){switch(n.unpackedShape.length){case 0:return this.getPackedSamplerScalar(t,e);case 1:return this.getPackedSampler1D(t,e,n);case 2:return this.getPackedSampler2D(t,e,n);case 3:return this.getPackedSampler3D(t,e,n);default:return this.getPackedSamplerND(t,e,n)}}getUnpackedSamplerFromInput(t,e,n){const r=n.unpackedShape;switch(r.length){case 0:return this.getUnpackedSamplerScalar(t,e,n);case 1:return this.getUnpackedSampler1D(t,e,n);case 2:return this.getUnpackedSampler2D(t,e,n);case 3:return this.getUnpackedSampler3D(t,e,n);case 4:return this.getUnpackedSampler4D(t,e,n);case 5:return this.getUnpackedSampler5D(t,e,n);case 6:return this.getUnpackedSampler6D(t,e,n);default:throw new Error(`Unsupported dimension ${r.length}-D`)}}getPackedSamplerScalar(t,e){const n=`\n          vec4 ${t}() {\n            return ${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${e}, halfCR);\n          }\n        `;return new i.GlslLibRoutine(n)}getPackedSampler1D(t,e,n){const r=[n.width,n.height],a=[r[1],r[0]],s=(0,o.getGlsl)(this.context.glContext.version),u=`vec4 ${t}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${a[0]}, ${a[1]}, index);\n      return ${s.texture2D}(${e}, uv);\n    }`;return new i.GlslLibRoutine(u,["coordinates.packedUVfrom1D"])}getPackedSampler2D(t,e,n){const a=n.unpackedShape,s=[n.width,n.height],u=(0,o.getGlsl)(this.context.glContext.version),c=s[0],l=s[1];if(null!=s&&r.ArrayUtil.arraysEqual(a,s)){const n=`vec4 ${t}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${c}.0);\n        return ${u.texture2D}(${e}, uv);\n      }`;return new i.GlslLibRoutine(n)}const p=s,f=Math.ceil(a[1]/2),d=`vec4 ${t}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${f}, row, col);\n      return ${u.texture2D}(${e}, uv);\n    }`;return new i.GlslLibRoutine(d,["coordinates.packedUVfrom2D"])}getPackedSampler3D(t,e,n){const r=n.unpackedShape,a=[n.width,n.height],u=[a[0],a[1]],c=(0,o.getGlsl)(this.context.glContext.version);if(1===r[0]){const o=r.slice(1),a=[1,2],u=(0,s.squeezeInputShape)(r,o),c=["b","row","col"],l=JSON.parse(JSON.stringify(n));l.unpackedShape=u;const p=this.getPackedSamplerFromInput(t,e,l),f=`${p.routineBody}\n      vec4 ${t}(int b, int row, int col) {\n        return ${t}(${(0,s.getSqueezedParams)(c,a)});\n      } `;return new i.GlslLibRoutine(f,p.dependencies)}const l=u[0],p=u[1],f=Math.ceil(r[2]/2),d=`vec4 ${t}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${p}, ${l}, ${f*Math.ceil(r[1]/2)}, ${f}, b, row, col);\n      return ${c.texture2D}(${e}, uv);}`;return new i.GlslLibRoutine(d,["coordinates.packedUVfrom3D"])}getPackedSamplerND(t,e,n){const r=n.unpackedShape,a=r.length,s=[n.width,n.height],u=(0,o.getGlsl)(this.context.glContext.version),c=[s[0],s[1]],l=c[1],p=c[0],f=Math.ceil(r[a-1]/2);let d=f*Math.ceil(r[a-2]/2),h="int b, int row, int col",g=`b * ${d} + (row / 2) * ${f} + (col / 2)`;for(let t=2;t<a-1;t++)h=`int b${t}, `+h,d*=r[a-t-1],g=`b${t} * ${d} + `+g;const b=`vec4 ${t}(${h}) {\n      int index = ${g};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${l});\n      return ${u.texture2D}(${e}, uv);\n    }`;return new i.GlslLibRoutine(b)}getUnpackedSamplerScalar(t,e,n){const[r,o]=[n.width,n.height];if(1===r&&1===o){const n=`\n          float ${t}() {\n            return sampleTexture(${e}, halfCR);\n          }\n        `;return new i.GlslLibRoutine(n,["coordinates.sampleTexture"])}const a=`\n        float ${t}() {\n          int offset_${e} = coordsToOffset(TexCoords, ${r}, ${o});\n          vec2 uv = uvFromFlat(${r}, ${o}, offset_${e});\n          return sampleTexture(${e}, uv);\n        }\n      `;return new i.GlslLibRoutine(a,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(t,e,n){const r=n.width,o=n.height;if(1===o&&1===r){const n=`\n        float ${t}(int index) {\n          return sampleTexture(${e}, halfCR);\n        }\n      `;return new i.GlslLibRoutine(n,["coordinates.sampleTexture"])}if(1===o){const n=`\n          float ${t}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${r}.0, 0.5);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new i.GlslLibRoutine(n,["coordinates.sampleTexture"])}if(1===r){const n=`\n          float ${t}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${o}.0);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new i.GlslLibRoutine(n,["coordinates.sampleTexture"])}const a=`\n        float ${t}(int index) {\n          vec2 uv = uvFromFlat(${r}, ${o}, index);\n          return sampleTexture(${e}, uv);\n        }\n      `;return new i.GlslLibRoutine(a,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(t,e,n){const o=n.unpackedShape,u=[n.height,n.width];if(null!=u&&r.ArrayUtil.arraysEqual(o,u)){const n=`\n          float ${t}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u[1]}.0, ${u[0]}.0);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new i.GlslLibRoutine(n,["coordinates.sampleTexture"])}const{newShape:c,keptDims:l}=(0,a.squeezeShape)(o),p=c;if(p.length<o.length){const r=(0,s.squeezeInputShape)(o,p),a=JSON.parse(JSON.stringify(n));a.unpackedShape=r;const u=["col","row"],c=`\n          ${this.getUnpackedSamplerFromInput(t,e,a).routineBody}\n          float ${t}(int row, int col) {\n            return ${t}(${(0,s.getSqueezedParams)(u,l)});\n          }\n        `;return new i.GlslLibRoutine(c,["coordinates.sampleTexture"])}const f=u[1],d=u[0];if(1===d){const n=`\n          float ${t}(int row, int col) {\n            int offset_${e} = coordsToOffset(TexCoords, ${f}, ${d});\n            float index = dot(vec3(row, col, offset_${e}), vec3(${o[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${f}.0);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new i.GlslLibRoutine(n,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(1===f){const n=`\n          float ${t}(int row, int col) {\n            int offset_${e} = coordsToOffset(TexCoords, ${f}, ${d});\n            float index = dot(vec3(row, col, offset_${e}), vec3(${o[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new i.GlslLibRoutine(n,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const h=`\n        float ${t}(int row, int col) {\n          int index = col * ${o[1]} + row;\n          vec2 uv = uvFromFlat(${f}, ${d}, index);\n          return sampleTexture(${e}, uv);\n        }\n      `;return new i.GlslLibRoutine(h,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(t,e,n){const r=n.unpackedShape,o=r[1]*r[2],u=r[2],{newShape:c,keptDims:l}=(0,a.squeezeShape)(r),p=c;if(p.length<r.length){const o=(0,s.squeezeInputShape)(r,p),a=["batch","col","row"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=o;const c=this.getUnpackedSamplerFromInput(t,e,u),f=l.reverse(),d=`\n          ${c.routineBody}\n          float ${t}(int batch, int row, int col) {\n            return ${t}(${(0,s.getSqueezedParams)(a,f)});\n          }\n        `;return new i.GlslLibRoutine(d,c.dependencies)}const f=`\n          float ${t}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${o} + col * ${u} + row;\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n            return sampleTexture(${e}, uv);\n          }\n      `;return new i.GlslLibRoutine(f,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(t,e,n){const r=n.unpackedShape,o=r[3],a=r[2]*o,s=`\n        float ${t}(int row, int col, int depth, int depth2) {\n          int index = row * ${r[1]*a} + col * ${a} +\n              depth2 * ${o} + depth;\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n          return sampleTexture(${e}, uv);\n        }\n      `;return new i.GlslLibRoutine(s,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(t,e,n){const r=n.unpackedShape,o=r[4],u=r[3]*o,c=r[2]*u,l=r[1]*c,{newShape:p,keptDims:f}=(0,a.squeezeShape)(r);if(p.length<r.length){const o=(0,s.squeezeInputShape)(r,p),a=["row","col","depth","depth2","depth3"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=o;const c=`\n          ${this.getUnpackedSamplerFromInput(t,e,u).routineBody}\n          float ${t}(int row, int col, int depth, int depth2, int depth3) {\n            return ${t}(${(0,s.getSqueezedParams)(a,f)});\n          }\n        `;return new i.GlslLibRoutine(c,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const d=`\n        float ${t}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${l} + col * ${c} + depth * ${u} +\n          depth3 * ${o} + depth2;\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n          return sampleTexture(${e}, uv);\n        }\n      `;return new i.GlslLibRoutine(d,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(t,e,n){const r=n.unpackedShape,o=r[5],u=r[4]*o,c=r[3]*u,l=r[2]*c,p=r[1]*l,{newShape:f,keptDims:d}=(0,a.squeezeShape)(r);if(f.length<r.length){const o=(0,s.squeezeInputShape)(r,f),a=["row","col","depth","depth2","depth3","depth4"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=o;const c=`\n            ${this.getUnpackedSamplerFromInput(t,e,u).routineBody}\n            float ${t}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${t}(${(0,s.getSqueezedParams)(a,d)});\n            }\n          `;return new i.GlslLibRoutine(c,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const h=`\n          float ${t}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${p} + col * ${l} + depth * ${c} +\n            depth2 * ${u} + depth3 * ${o} + depth4;\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new i.GlslLibRoutine(h,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const t=this.context.outputTextureLayout,e=t.shape.length,n=t.strides,r=t.width,o=t.height,a=[];for(let t=0;t<e-1;++t)a.push(`\n        c[${t}] = offset / ${n[t]};`),a.push(`\n        offset -= c[${t}] * ${n[t]};`);a.push(`\n        c[${e-1}] = offset;`);const s=`\n      void toVec(vec2 texCoords, out int c[${e}]) {\n        int offset = coordsToOffset(texCoords, ${r}, ${o});\n        ${a.join("")}\n      }\n      void toVec(int offset, out int c[${e}]) {\n        ${a.join("")}\n      }\n    `;return{toVec:new i.GlslLibRoutine(s,["coordinates.coordsToOffset"])}}valueFrom(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const r=this.context.inputTextureLayouts[n],o=(r.unpackedShape.length>0?r.unpackedShape:r.shape).length;let a=`_${e}`;t[a]=new i.GlslLibRoutine(this.getValueFromSingle(e,o,r.width,r.height,!1),[`shapeUtils.indicesToOffset${a}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),a+="_T",t[a]=new i.GlslLibRoutine(this.getValueFromSingle(e,o,r.width,r.height,!0),[`shapeUtils.indicesToOffset${a}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])})),t}getValueFromSingle(t,e,n,r,i){let a=`_${t}`;return i&&(a+="_T"),`\n        float ${a}(int m[${e}]) {\n          int offset = indicesToOffset${a}(m);\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\n          float value = getColorAsFloat(${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${t}, coords));\n          return value;\n        }\n        `}getPackedValueFrom(t,e,n,r,i){let a=`_${t}_Pack`;return i&&(a+="_T"),`\n        vec4 ${a}(int m[${e}]) {\n          int offset = indicesToOffset_${t}(m);\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\n          return ${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${t}, coords);\n        }\n        `}}e.CoordsGlslLib=u},8520:(t,e)=>{"use strict";var n;Object.defineProperty(e,"__esModule",{value:!0}),e.TopologicalSortGlslRoutines=e.GlslLibRoutineNode=e.GlslLibRoutine=e.GlslLib=e.GlslContext=e.FunctionType=void 0,(n=e.FunctionType||(e.FunctionType={}))[n.ValueBased=0]="ValueBased",n[n.Positional=1]="Positional",e.GlslContext=class{constructor(t,e,n,r){this.glContext=t,this.programInfo=e,this.inputTextureLayouts=n,this.outputTextureLayout=r}},e.GlslLib=class{constructor(t){this.context=t}},e.GlslLibRoutine=class{constructor(t,e){this.routineBody=t,this.dependencies=e}},e.GlslLibRoutineNode=class{constructor(t,e,n){this.name=t,this.dependencies=n||[],e&&(this.routineBody=e)}addDependency(t){t&&this.dependencies.push(t)}},e.TopologicalSortGlslRoutines=class{static returnOrderedNodes(t){if(!t||0===t.length)return[];if(1===t.length)return t;const e=new Set,n=new Set,r=new Array;return this.createOrderedNodes(t,e,n,r),r}static createOrderedNodes(t,e,n,r){for(let i=0;i<t.length;++i)this.dfsTraverse(t[i],e,n,r)}static dfsTraverse(t,e,n,r){if(!t||n.has(t.name))return;if(e.has(t.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");e.add(t.name);const i=t.dependencies;if(i&&i.length>0)for(let t=0;t<i.length;++t)this.dfsTraverse(i[t],e,n,r);r.push(t),n.add(t.name),e.delete(t.name)}}},7341:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.EncodingGlslLib=void 0;const r=n(8520);class i extends r.GlslLib{constructor(t){super(t)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new r.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ")}}decodeFloat32(){return{decode:new r.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ")}}encodeUint8(){const t=i.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new r.GlslLibRoutine(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${t}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `)}}decodeUint8(){const t=i.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new r.GlslLibRoutine(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${t}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `)}}static isLittleEndian(){const t=new ArrayBuffer(4),e=new Uint32Array(t),n=new Uint8Array(t);if(e[0]=3735928559,239===n[0])return!0;if(222===n[0])return!1;throw new Error("unknown endianness")}}e.EncodingGlslLib=i},9894:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.FragColorGlslLib=void 0;const r=n(8520),i=n(5060);class o extends r.GlslLib{constructor(t){super(t)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const t=(0,i.getGlsl)(this.context.glContext.version);return{setFragColor:new r.GlslLibRoutine(`\n        void setFragColor(float value) {\n            ${t.output} = encode(value);\n        }\n        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new r.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ",["encoding.decode"])}}}e.FragColorGlslLib=o},2848:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.replaceInlines=void 0;const n=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;e.replaceInlines=function(t){const e={};let r;for(;null!==(r=n.exec(t));){const t=r[3].split(",").map((t=>{const e=t.trim().split(" ");return e&&2===e.length?{type:e[0],name:e[1]}:null})).filter((t=>null!==t));e[r[2]]={params:t,body:r[4]}}for(const n in e){const i="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",n),o=new RegExp(i,"gm");for(;null!==(r=o.exec(t));){const i=r[1],o=r[2],a=r[3].split(","),s=i?`${i} ${o};`:"";let u=e[n].body,c="";e[n].params.forEach(((t,e)=>{t&&(c+=`${t.type} ${t.name} = ${a[e]};\n`)})),u=`${c}\n ${u}`,u=u.replace("return",`${o} = `);const l=`\n      ${s}\n      {\n        ${u}\n      }\n      `;t=t.replace(r[0],l)}}return t.replace(n,"")}},8879:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.GlslPreprocessor=void 0;const r=n(8520),i=n(2848),o=n(5483),a=n(5060);e.GlslPreprocessor=class{constructor(t,e,n,i){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new r.GlslContext(t,e,n,i),Object.keys(o.glslRegistry).forEach((t=>{const e=new o.glslRegistry[t](this.context);this.libs[t]=e}));const a=this.glslLibRoutineDependencyGraph;for(const t in this.libs){const e=this.libs[t].getFunctions();for(const n in e){const i=t+"."+n;let o;a[i]?(o=a[i],o.routineBody=e[n].routineBody):(o=new r.GlslLibRoutineNode(i,e[n].routineBody),a[i]=o);const s=e[n].dependencies;if(s)for(let t=0;t<s.length;++t)if(a[s[t]])o.addDependency(a[s[t]]);else{const e=new r.GlslLibRoutineNode(s[t]);a[s[t]]=e,o.addDependency(e)}}}}preprocess(){const t=this.context.programInfo;let e=t.shaderSource;return this.context.programInfo.hasMain||(e=`${e}\n      ${(0,a.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),e=(0,i.replaceInlines)(e),`${(0,a.getFragShaderPreamble)(this.context.glContext.version)}\n    ${this.getUniforms(t.inputNames,t.variables)}\n    ${this.getImports(e)}\n    ${e}`}getImports(t){const e=this.selectGlslLibRoutinesToBeIncluded(t);if(0===e.length)return"";let n="";for(let t=0;t<e.length;++t){if(!e[t].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${e[t].name}`);n+=e[t].routineBody+"\n"}return n}selectGlslLibRoutinesToBeIncluded(t){const e=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n=>{const r=n.split(".")[1];-1!==t.indexOf(r)&&e.push(this.glslLibRoutineDependencyGraph[n])})),r.TopologicalSortGlslRoutines.returnOrderedNodes(e)}getUniforms(t,e){const n=[];if(t)for(const e of t)n.push(`uniform sampler2D ${e};`);if(e)for(const t of e)n.push(`uniform ${t.type} ${t.name}${t.arrayLength?`[${t.arrayLength}]`:""};`);return n.join("\n")}}},5483:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.glslRegistry=void 0;const r=n(5107),i=n(7341),o=n(9894),a=n(2655),s=n(3891);e.glslRegistry={encoding:i.EncodingGlslLib,fragcolor:o.FragColorGlslLib,vec:s.VecGlslLib,shapeUtils:a.ShapeUtilsGlslLib,coordinates:r.CoordsGlslLib}},2655:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.ShapeUtilsGlslLib=void 0;const r=n(8520);class i extends r.GlslLib{constructor(t){super(t)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const t=this.context.outputTextureLayout.shape.length,e={};return this.context.programInfo.inputNames.forEach(((n,i)=>{const o=this.context.inputTextureLayouts[i].unpackedShape;if(o.length<=t){const i=o.length,a=t-i,s=`bcastIndices_${n}`;let u="";for(let t=0;t<i;++t)u+=`\n          realIndices[${t}] = int( mod(float(bcastedIndices[${a+t}]), ${o[t]}.0) );\n          `;const c=`\n        void ${s} (int bcastedIndices[${t}], out int realIndices[${i}]) {\n          ${u}\n        }\n        `;e[s]=new r.GlslLibRoutine(c)}})),e}bcastMatmulIndex(){const t=this.context.outputTextureLayout.shape.length,e={};return this.context.programInfo.inputNames.forEach(((n,i)=>{const o=this.context.inputTextureLayouts[i].shape;if(!(o.length<2||o.length>t)){const i=o.length,a=t-i,s=`bcastMatmulIndices_${n}`;let u="";for(let t=0;t<i-2;++t)u+=`\n          realIndices[${t}] = int( mod(float(bcastedIndices[${a+t}]), ${o[t]}.0) );\n          `;const c=`\n        void ${s}(int bcastedIndices[${t}], out int realIndices[${i}]) {\n          ${u}\n          realIndices[${i-1}] = bcastedIndices[${t-1}];\n          realIndices[${i-2}] = bcastedIndices[${t-2}];\n        }\n        `;e[s]=new r.GlslLibRoutine(c)}})),e}indicesToOffset(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const o=this.context.inputTextureLayouts[n].shape,a=this.context.inputTextureLayouts[n].strides,s=o.length;let u=`indicesToOffset_${e}`;t[u]=new r.GlslLibRoutine(i.indexToOffsetSingle(u,s,a)),u=`indicesToOffset_${e}_T`,t[u]=new r.GlslLibRoutine(i.indexToOffsetSingle(u,s,a.slice().reverse()))})),t}static indexToOffsetSingle(t,e,n){let r="";for(let t=e-1;t>=0;--t)r+=`\n        offset += indices[${t}] * ${n[t]};\n        `;return`\n      int ${t}(int indices[${e}]) {\n        int offset = 0;\n        ${r}\n        return offset;\n      }\n      `}offsetToIndices(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const o=this.context.inputTextureLayouts[n].shape,a=this.context.inputTextureLayouts[n].strides,s=o.length;let u=`offsetToIndices_${e}`;t[u]=new r.GlslLibRoutine(i.offsetToIndicesSingle(u,s,a)),u=`offsetToIndices_${e}_T`,t[u]=new r.GlslLibRoutine(i.offsetToIndicesSingle(u,s,a.slice().reverse()))})),t}static offsetToIndicesSingle(t,e,n){const r=[];for(let t=0;t<e-1;++t)r.push(`\n      indices[${t}] = offset / ${n[t]};`),r.push(`\n        offset -= indices[${t}] * ${n[t]};`);return r.push(`\n      indices[${e-1}] = offset;`),`\n      void ${t}(int offset, out int indices[${e}]) {\n        ${r.join("")}\n      }\n      `}incrementIndices(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const i=this.context.inputTextureLayouts[n].shape,o=i.length,a=`incrementIndices_${e}`;let s="";for(let t=0;t<o;++t)s+=`\n        shape[${t}] = ${i[t]};`;const u=`\n        void ${a}(int axis, out int indices[${o}]) {\n          int shape[${o}];\n          ${s};\n          for(int i = ${o} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `;t[a]=new r.GlslLibRoutine(u)})),t}}e.ShapeUtilsGlslLib=i},5060:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getDefaultFragShaderMain=e.getFragShaderPreamble=e.getVertexShaderSource=e.getGlsl=void 0;const n={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},r={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function i(t){return 1===t?n:r}e.getGlsl=i,e.getVertexShaderSource=function(t){const e=i(t);return`${e.version}\n      precision highp float;\n      ${e.attribute} vec3 position;\n      ${e.attribute} vec2 textureCoord;\n\n      ${e.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`},e.getFragShaderPreamble=function(t){const e=i(t);return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFrag} vec2 TexCoords;\n    ${e.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `},e.getDefaultFragShaderMain=function(t,e){return`\n  void main() {\n    int indices[${e}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${i(t).output} = result;\n  }\n  `}},3891:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.VecGlslLib=void 0;const r=n(8520);class i extends r.GlslLib{constructor(t){super(t)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const t=this.context.outputTextureLayout.shape.length,e={add:"+=",sub:"-=",mul:"*=",div:"/="},n={};for(const i in e){const o=`${i}Vec`;let a="";for(let n=0;n<t;++n)a+=`\n          dest[${n}] ${e[i]} src[${n}];\n          `;const s=`\n        void ${o}(int src[${t}], out int dest[${t}]) {\n          ${a}\n        }\n        `;n[o]=new r.GlslLibRoutine(s)}return n}copyVec(){const t=this.context.outputTextureLayout.shape.length;let e="";for(let n=0;n<t;++n)e+=`\n        dest[${n}] = src[${n}];\n        `;const n=`\n      void copyVec(int src[${t}], out int dest[${t}]) {\n        ${e}\n      }\n      `;return{copyVec:new r.GlslLibRoutine(n)}}setVecItem(){const t=this.context.outputTextureLayout.shape.length;let e=`\n        if(index < 0)\n            index =${t} + index;\n        if (index == 0)\n            m[0] = value;\n        `;for(let n=1;n<t-1;++n)e+=`\n        else if (index == ${n})\n            m[${n}] = value;\n            `;e+=`\n        else\n            m[${t-1}] = value;\n        `;const n=`\n      void setVecItem(out int m[${t}], int index, int value) {\n        ${e}\n      }\n        `;return{setVecItem:new r.GlslLibRoutine(n)}}getVecItem(){const t=this.context.outputTextureLayout.shape.length;let e=`\n        if(index < 0)\n            index = ${t} + index;\n        if (index == 0)\n            return m[0];\n      `;for(let n=1;n<t-1;++n)e+=`\n        else if (index == ${n})\n            return m[${n}];\n      `;e+=`\n        else\n            return m[${t-1}];\n        `;const n=`\n      int getVecItem(int m[${t}], int index) {\n        ${e}\n      }\n    `;return{getVecItem:new r.GlslLibRoutine(n)}}}e.VecGlslLib=i},8316:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLInferenceHandler=void 0;const r=n(6231),i=n(9162),o=n(2517),a=n(2403),s=n(7019),u=n(8710),c=n(5611),l=n(4057),p=n(2039);e.WebGLInferenceHandler=class{constructor(t){this.session=t,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(t,e){return(0,l.calculateTextureWidthAndHeight)(this.session.layoutStrategy,t,e)}executeProgram(t,e){if(e.length<t.inputNames.length)throw new Error(`Input size mustn't be less than ${t.inputNames.length}.`);if(t.inputNames.length!==t.inputTypes.length)throw new Error("input names size does not match input types");const n=[];for(let r=0;r<t.inputNames.length;++r)n[r]=this.getOrCreateTextureData(e[r],t.inputTypes[r]);const r=((t,e)=>{const n=e.map((t=>`${t.unpackedShape.join(",")};${t.width}x${t.height}`)).join("_");let r=t.name;return t.cacheHint&&(r+="["+t.cacheHint+"]"),r+=":"+n,r})(t,n);let i=this.session.programManager.getArtifact(r);const o=i?i.programInfo:"function"==typeof t.get?t.get():t,a=(0,l.createTextureLayoutFromTextureType)(this.session.layoutStrategy,o.output.dims,o.output.textureType),s=this.createTextureData(a,o.output.type);return i||(i=this.session.programManager.build(o,n,s),this.session.programManager.setArtifact(r,i)),this.runProgram(i,n,s),s}run(t,e){return this.executeProgram(t,e).tensor}runProgram(t,e,n){for(let n=0;n<e.length;++n)if(!!e[n].isPacked!=(t.programInfo.inputTypes[n]===p.TextureType.packed))throw new Error(`input[${n}] property packed inconsistent`);if(!!n.isPacked!=(t.programInfo.output.textureType===p.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(t,e,n)}getOrCreateTextureData(t,e){let n=this.getTextureData(t.dataId,e===p.TextureType.packed);if(!n&&(n=this.getTextureData(t.dataId,e!==p.TextureType.packed),n))return e===p.TextureType.packed?this.pack(n):this.unpack(n);if(!n){const r=(0,l.createTextureLayoutFromTextureType)(this.session.layoutStrategy,t.dims,e);if(e===p.TextureType.packedLastDimension){const n=1,r=4,i=t.dims;if(4===i.length){const o=[i[0],Math.ceil(i[1]*i[2]*i[3]/r)],a=(0,l.createTextureLayoutFromTextureType)(this.session.layoutStrategy,o,e);let s=t.numberData;if(i[1]*i[2]*i[3]%r!=0){const e=i[0],o=i[1]*i[2]*i[3],a=Math.ceil(o*n/r)*r;s=new Float32Array(e*a);for(let r=0;r<e;++r){const e=r*o,i=r*a+r%n*o;s.set(t.numberData.subarray(e,e+o),i)}}return this.createTextureData(a,t.type,s,t,1)}}if(e===p.TextureType.packed){const e=(0,l.createTextureLayoutFromShape)(this.session.layoutStrategy,t.dims,1,[],{reverseWH:!0}),r=this.createTextureData(e,t.type,t.numberData,t,1);n=this.pack(r)}else n=this.createTextureData(r,t.type,t.numberData,t,1)}return n}createTextureDataFromLayoutBindTensor(t,e,n,r){return this.createTextureData(t,e,n,r,1)}createTextureData(t,e,n,i,o){r.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(t)}]`);const a=this.session.textureManager.createTextureFromLayout(e,t,n,o);return this.createTextureDataFromTexture(t,e,a,i)}reshapeUnpacked(t,e){const n=this.getOrCreateTextureData(t,p.TextureType.unpacked),r={channels:n.channels,height:n.height,width:n.width,shape:0!==e.length?e:[1],strides:o.ShapeUtil.computeStrides(e),unpackedShape:e};return this.createTextureDataFromTexture(r,t.type,n.texture).tensor}reshapePacked(t,e){const n=this.getOrCreateTextureData(t,p.TextureType.packed);if((0,s.isReshapeCheap)(t.dims,e)){const r={channels:n.channels,height:n.height,width:n.width,shape:0!==e.length?e:[1],strides:o.ShapeUtil.computeStrides(e),unpackedShape:e,isPacked:!0};return this.createTextureDataFromTexture(r,t.type,n.texture).tensor}const r=(0,s.processDims3D)(t.dims),i=(0,s.processDims3D)(e),a=this.reshapePacked(t,r),u=this.run((0,s.createPackedReshape3DProgramInfoLoader)(this,a,i),[a]);return this.reshapePacked(u,e)}cast(t,e){const n=this.getOrCreateTextureData(t,p.TextureType.unpacked);return this.createTextureDataFromTexture(n,e,n.texture).tensor}createTextureDataFromTexture(t,e,n,r,o){const a=Object.assign(Object.assign({},t),{tensor:r||new i.Tensor(t.unpackedShape,e,(t=>this.readTexture(a)),(async t=>this.readTextureAsync(a)),void 0,o),texture:n});return this.setTextureData(a.tensor.dataId,a,t.isPacked),a}getTextureData(t,e=!1){return this.session.isInitializer(t)?this.session.getTextureData(t,e):e?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,e,n=!1){this.session.isInitializer(t)?this.session.setTextureData(t,e,n):(n?this.packedTextureDataCache:this.unpackedTextureDataCache).set(t,e)}isTextureLayoutCached(t,e=!1){return!!this.getTextureData(t.dataId,e)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((t=>this.session.textureManager.releaseTexture(t))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((t=>this.session.textureManager.releaseTexture(t))),this.unpackedTextureDataCache=new Map}readTexture(t){return t.isPacked?this.readTexture(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat((0,u.encodeAsUint8)(this,t))}async readTextureAsync(t){return t.isPacked?this.readTextureAsync(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat((0,u.encodeAsUint8)(this,t))}pack(t){return this.executeProgram((0,a.createPackProgramInfoLoader)(this,t.tensor),[t.tensor])}unpack(t){return this.executeProgram((0,c.createUnpackProgramInfoLoader)(this,t.tensor),[t.tensor])}}},1640:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return i(e,t),e};Object.defineProperty(e,"__esModule",{value:!0}),e.WEBGL_OP_RESOLVE_RULES=void 0;const a=n(2898),s=o(n(7839)),u=n(4196),c=n(2069),l=n(8138),p=n(9663),f=n(5193),d=n(7992),h=n(1253),g=n(4776),b=n(6572),m=n(3346),y=n(5623),_=n(2870),v=n(2143),w=n(4939),x=n(718),T=n(2268),S=n(8117),O=n(2278),A=n(5524),E=n(5975),I=n(3933),P=n(6558),D=n(5723),$=n(3738),k=o(n(4909)),C=n(8428),F=n(9793);e.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",k.abs],["Acos","","7+",k.acos],["Add","","7+",s.add],["And","","7+",s.and],["Asin","","7+",k.asin],["Atan","","7+",k.atan],["AveragePool","","7+",v.averagePool,v.parseAveragePoolAttributes],["BatchNormalization","","7+",a.batchNormalization,a.parseBatchNormalizationAttributes],["Cast","","6+",u.cast,u.parseCastAttributes],["Ceil","","6+",k.ceil],["Clip","","6-10",k.clip,k.parseClipAttributes],["Clip","","11+",k.clipV11],["Concat","","4+",c.concat,c.parseConcatAttributes],["Conv","","1+",l.conv,l.parseConvAttributes],["ConvTranspose","","1+",p.convTranspose,p.parseConvTransposeAttributes],["Cos","","7+",k.cos],["Div","","7+",s.div],["Dropout","","7+",k.identity],["DepthToSpace","","1+",f.depthToSpace,f.parseDepthToSpaceAttributes],["Equal","","7+",s.equal],["Elu","","6+",k.elu,k.parseEluAttributes],["Exp","","6+",k.exp],["Flatten","","1+",d.flatten,d.parseFlattenAttributes],["Floor","","6+",k.floor],["FusedConv","com.microsoft","1+",l.conv,l.parseConvAttributes],["Gather","","1+",h.gather,h.parseGatherAttributes],["Gemm","","7-10",g.gemm,g.parseGemmAttributesV7],["Gemm","","11+",g.gemm,g.parseGemmAttributesV11],["GlobalAveragePool","","1+",v.globalAveragePool,v.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",v.globalMaxPool],["Greater","","7+",s.greater],["Identity","","1+",k.identity],["ImageScaler","","1+",b.imageScaler,b.parseImageScalerAttributes],["InstanceNormalization","","6+",m.instanceNormalization,m.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",k.leakyRelu,k.parseLeakyReluAttributes],["Less","","7+",s.less],["Log","","6+",k.log],["MatMul","","1+",y.matMul,y.parseMatMulAttributes],["MaxPool","","1+",v.maxPool,v.parseMaxPoolAttributes],["Mul","","7+",s.mul],["Neg","","6+",k.neg],["Not","","1+",k.not],["Or","","7+",s.or],["Pad","","2-10",_.padV2,_.parsePadAttributesV2],["Pad","","11+",_.padV11,_.parsePadAttributesV11],["Pow","","7+",s.pow],["PRelu","","7+",s.pRelu],["ReduceLogSum","","1+",w.reduceLogSum,w.parseReduceAttributes],["ReduceMax","","1+",w.reduceMax,w.parseReduceAttributes],["ReduceMean","","1+",w.reduceMean,w.parseReduceAttributes],["ReduceMin","","1+",w.reduceMin,w.parseReduceAttributes],["ReduceProd","","1+",w.reduceProd,w.parseReduceAttributes],["ReduceSum","","1-12",w.reduceSum,w.parseReduceAttributes],["ReduceSumSquare","","1+",w.reduceLogSumSquare,w.parseReduceAttributes],["Relu","","6+",k.relu],["Reshape","","5+",x.reshape],["Resize","","10",T.resize,T.parseResizeAttributesV10],["Resize","","11+",T.resize,T.parseResizeAttributesV11],["Shape","","1+",S.shape],["Sigmoid","","6+",k.sigmoid],["Sin","","7+",k.sin],["Slice","","10+",O.sliceV10],["Slice","","1-9",O.slice,O.parseSliceAttributes],["Softmax","","1-12",A.softmax,A.parseSoftmaxAttributes],["Softmax","","13+",A.softmaxV13,A.parseSoftmaxAttributesV13],["Split","","2-12",E.split,E.parseSplitAttributes],["Sqrt","","6+",k.sqrt],["Squeeze","","1-12",I.squeeze,I.parseSqueezeAttributes],["Squeeze","","13+",I.squeezeV13],["Sub","","7+",s.sub],["Sum","","6+",P.sum],["Tan","","7+",k.tan],["Tanh","","6+",k.tanh],["Tile","","6+",D.tile],["Transpose","","1+",$.transpose,$.parseTransposeAttributes],["Upsample","","7-8",F.upsample,F.parseUpsampleAttributesV7],["Upsample","","9",F.upsample,F.parseUpsampleAttributesV9],["Unsqueeze","","1-12",C.unsqueeze,C.parseUnsqueezeAttributes],["Unsqueeze","","13+",C.unsqueezeV13],["Xor","","7+",s.xor]]},2898:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseBatchNormalizationAttributes=e.batchNormalization=void 0;const r=n(246),i=n(5060),o=n(2039),a={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]};e.batchNormalization=(t,e,n)=>(u(e),[t.run(Object.assign(Object.assign({},a),{cacheHint:n.cacheKey,get:()=>s(t,e,n)}),e)]),e.parseBatchNormalizationAttributes=t=>{const e=t.attributes.getFloat("epsilon",1e-5),n=t.attributes.getFloat("momentum",.9),i=t.attributes.getInt("spatial",1);return(0,r.createAttributeWithCacheKey)({epsilon:e,momentum:n,spatial:i})};const s=(t,e,n)=>{const r=(0,i.getGlsl)(t.session.backend.glContext.version),s=e[0].dims.length,[u,c]=t.calculateTextureWidthAndHeight(e[1].dims,o.TextureType.unpacked),l=`\n  float process(int[${s}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${u}, ${c});\n    float scale = getColorAsFloat(${r.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${r.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${r.texture2D}(Variance, position));\n    float b = getColorAsFloat(${r.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;\n  }`;return Object.assign(Object.assign({},a),{output:{dims:e[0].dims,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:l})},u=t=>{if(!t||5!==t.length)throw new Error("BatchNormalization requires 5 inputs.");const e=t[0],n=t[1],r=t[2],i=t[3],o=t[4];if(e.dims.length<3||1!==n.dims.length||1!==r.dims.length||1!==i.dims.length||1!==o.dims.length)throw new Error("invalid input shape.");if(n.dims[0]!==e.dims[1]||r.dims[0]!==e.dims[1]||i.dims[0]!==e.dims[1]||o.dims[0]!==e.dims[1])throw new Error("invalid input shape.");if("float32"!==e.type&&"float64"!==e.type||"float32"!==n.type&&"float64"!==n.type||"float32"!==r.type&&"float64"!==r.type||"float32"!==i.type&&"float64"!==i.type||"float32"!==o.type&&"float64"!==o.type)throw new Error("invalid input tensor types.")}},7839:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.xor=e.sub=e.pRelu=e.pow=e.or=e.mul=e.less=e.greater=e.equal=e.div=e.and=e.add=e.glslPRelu=e.glslPow=e.glslXor=e.glslOr=e.glslAnd=e.glslLess=e.glslGreater=e.glslEqual=e.glslSub=e.glslMul=e.glslDiv=e.glslAdd=void 0;const r=n(2517),i=n(8520),o=n(5060),a=n(2039);function s(){const t="add_";return{body:`\n  float ${t}(float a, float b) {\n    return a + b;\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function u(){const t="div_";return{body:`\n  float ${t}(float a, float b) {\n    return a / b;\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function c(){const t="mul_";return{body:`\n  float ${t}(float a, float b) {\n    return a * b;\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function l(){const t="sub_";return{body:`\n  float ${t}(float a, float b) {\n    return a - b;\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function p(){const t="equal_";return{body:`\n  float ${t}(float a, float b) {\n    return float(a == b);\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function f(){const t="greater_";return{body:`\n  float ${t}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function d(){const t="less_";return{body:`\n  float ${t}(float a, float b) {\n    return float(a < b);\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function h(){const t="and_";return{body:`\n  float ${t}(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function g(){const t="or_";return{body:`\n  float ${t}(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function b(){const t="xor_";return{body:`\n  float ${t}(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function m(){return function(t){const e=`${t}_`;return{body:`\n  float ${e}(float a, float b) {\n    return ${t}(a, b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return ${t}(v1, v2);\n  }\n  `,name:e,type:i.FunctionType.ValueBased}}("pow")}function y(){const t="prelu_";return{body:`\n  float ${t}(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}e.glslAdd=s,e.glslDiv=u,e.glslMul=c,e.glslSub=l,e.glslEqual=p,e.glslGreater=f,e.glslLess=d,e.glslAnd=h,e.glslOr=g,e.glslXor=b,e.glslPow=m,e.glslPRelu=y;const _=(t,e,n,r=e[0].type,i)=>{const o=t.session.pack?a.TextureType.packed:a.TextureType.unpacked;return{name:n.name,inputNames:["A","B"],inputTypes:[o,o],cacheHint:i,get:()=>v(t,e,n,r)}},v=(t,e,n,i=e[0].type)=>{const s=t.session.pack?a.TextureType.packed:a.TextureType.unpacked,u=!r.ShapeUtil.areEqual(e[0].dims,e[1].dims);let c=e[0].dims;const l=t.session.pack;if(u){const a=r.BroadcastUtil.calcShape(e[0].dims,e[1].dims,!1);if(!a)throw new Error("Can't perform binary op on the given tensors");c=a;const u=c.length,p=0!==e[0].dims.length?e[0].dims.length:1,f=0!==e[1].dims.length?e[1].dims.length:1,d=0!==e[0].dims.length?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",h=0!==e[1].dims.length?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",g=(0,o.getGlsl)(t.session.backend.glContext.version),b=l?`\n      ${n.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${n.name}(a, b);\n        ${g.output} = result;\n      }`:`\n      ${n.body}\n      float process(int indices[${u}]) {\n        int aindices[${p}];\n        int bindices[${f}];\n        ${d}\n        ${h}\n        return ${n.name}(_A(aindices), _B(bindices));\n      }`;return{name:n.name,inputNames:["A","B"],inputTypes:[s,s],output:{dims:c,type:i,textureType:s},shaderSource:b,hasMain:l}}const p=(0,o.getGlsl)(t.session.backend.glContext.version),f=`\n    ${n.body}\n    void main() {\n      vec4 v1 = ${p.texture2D}(A, TexCoords);\n      vec4 v2 = ${p.texture2D}(B, TexCoords);\n      vec4 result = ${n.name}(v1, v2);\n      ${p.output} = result;\n    }\n    `;return{name:n.name,inputNames:["A","B"],inputTypes:[s,s],output:{dims:e[0].dims,type:i,textureType:s},shaderSource:f,hasMain:!0}};e.add=(t,e)=>[t.run(_(t,e,s()),e)],e.and=(t,e)=>[t.run(_(t,e,h(),"bool"),e)],e.div=(t,e)=>[t.run(_(t,e,u()),e)],e.equal=(t,e)=>[t.run(_(t,e,p(),"bool"),e)],e.greater=(t,e)=>[t.run(_(t,e,f(),"bool"),e)],e.less=(t,e)=>[t.run(_(t,e,d(),"bool"),e)],e.mul=(t,e)=>[t.run(_(t,e,c()),e)],e.or=(t,e)=>[t.run(_(t,e,g(),"bool"),e)],e.pow=(t,e)=>[t.run(_(t,e,m()),e)],e.pRelu=(t,e)=>[t.run(_(t,e,y()),e)],e.sub=(t,e)=>[t.run(_(t,e,l()),e)],e.xor=(t,e)=>[t.run(_(t,e,b(),"bool"),e)]},4196:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseCastAttributes=e.cast=void 0;const r=n(2517);e.cast=(t,e,n)=>(i(e),[t.cast(e[0],n)]),e.parseCastAttributes=t=>r.ProtoUtil.tensorDataTypeFromProto(t.attributes.getInt("to"));const i=t=>{if(!t||1!==t.length)throw new Error("Cast requires 1 input.");if("string"===t[0].type)throw new Error("Invalid input type.")}},1163:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createPackedConcatProgramInfoLoader=void 0;const r=n(5060),i=n(2039),o=n(9390),a=n(2827);e.createPackedConcatProgramInfoLoader=(t,e,n)=>{const u=(c=e.length,l=n.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:c},((t,e)=>`X${e}`)),inputTypes:Array(c).fill(i.TextureType.packed),cacheHint:l});var c,l;return Object.assign(Object.assign({},u),{get:()=>((t,e,n,u)=>{const c=n[0].dims.slice();if(u>=c.length||u<-1*c.length)throw new Error("axis specified for concat doesn't match input dimensionality");u<0&&(u=c.length+u);const l=c.slice(0);for(let t=1;t<n.length;t++){const e=n[t].dims.slice();for(let t=0;t<c.length;t++)if(t===u)l[u]+=e[t];else if(c[t]!==e[t])throw new Error("non concat dimensions must match")}const p=l.length,f=(0,a.getChannels)("coords",p),d=(0,o.getCoordsDataType)(p),h=(0,a.unpackFromChannel)(),g=n.map((t=>t.dims)),b=(0,o.getGlChannels)(p),m=new Array(g.length-1);m[0]=g[0][u];for(let t=1;t<m.length;t++)m[t]=m[t-1]+g[t][u];const y=b[u],_=b.slice(-2),v=b.join();let w=`if (${y} < ${m[0]}) {\n        return getChannel(\n            getX0(${v}), vec2(${_.join()}));\n        }`;for(let t=1;t<m.length;t++){const e=m[t-1];w+=`\n            if (${y} < ${m[t]}  && ${y} >= ${m[t-1]}) {\n              return getChannel(\n                getX${t}(${s(b,y,e)}),\n                vec2(${s(_,y,e)}));\n            }`}const x=m.length,T=m[m.length-1];w+=`\n            return getChannel(\n              getX${x}(${s(b,y,T)}),\n              vec2(${s(_,y,T)}));`;const S=(0,r.getGlsl)(t.session.backend.glContext.version),O=`\n          ${h}\n          float getValue(${b.map((t=>"int "+t))}) {\n            ${w}\n          }\n\n          void main() {\n            ${d} coords = getOutputCoords();\n            int lastDim = coords.${b[p-1]};\n            coords.${b[p-1]} = coords.${b[p-2]};\n            coords.${b[p-2]} = lastDim;\n\n            vec4 result = vec4(getValue(${f}), 0., 0., 0.);\n\n            ${f[p-1]} = ${f[p-1]} + 1;\n            if (${f[p-1]} < ${l[p-1]}) {\n              result.g = getValue(${f});\n            }\n\n            ${f[p-2]} = ${f[p-2]} + 1;\n            if (${f[p-2]} < ${l[p-2]}) {\n              result.a = getValue(${f});\n            }\n\n            ${f[p-1]} = ${f[p-1]} - 1;\n            if (${f[p-2]} < ${l[p-2]} &&\n                ${f[p-1]} < ${l[p-1]}) {\n              result.b = getValue(${f});\n            }\n            ${S.output} = result;\n          }\n        `;return Object.assign(Object.assign({},e),{output:{dims:l,type:n[0].type,textureType:i.TextureType.packed},shaderSource:O,hasMain:!0})})(t,u,e,n.axis)})};const s=(t,e,n)=>{const r=t.indexOf(e);return t.map(((t,e)=>e===r?`${t} - ${n}`:t)).join()}},2069:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseConcatAttributes=e.concat=void 0;const r=n(246),i=n(2039),o=n(1163);e.concat=(t,e,n)=>(p(e),t.session.pack&&e[0].dims.length>1?[t.run((0,o.createPackedConcatProgramInfoLoader)(t,e,n),e)]:[t.run(a(t,e,n),e)]);const a=(t,e,n)=>{const r=(o=e.length,a=n.cacheKey,{name:"Concat",inputNames:Array.from({length:o},((t,e)=>`X${e}`)),inputTypes:Array(o).fill(i.TextureType.unpacked),cacheHint:a});var o,a;return Object.assign(Object.assign({},r),{get:()=>((t,e,n,r)=>{const o=n[0].dims.slice();if(r>=o.length||r<-1*o.length)throw new Error("axis specified for concat doesn't match input dimensionality");r<0&&(r=o.length+r);const a=o.slice(0);for(let t=1;t<n.length;t++){const e=n[t].dims.slice();for(let t=0;t<o.length;t++)if(t===r)a[r]+=e[t];else if(o[t]!==e[t])throw new Error("non concat dimensions must match")}const p=a.length,f=new Array(n.length);let d=0;for(let t=0;t<f.length;++t)d+=n[t].dims[r],f[t]=d;let h="";h=n.length<5?s(f):u(f);const g=`\n        ${c(n.length,p)}\n        ${l(f)}\n        ${h}\n        float process(int indices[${p}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${r}]);\n\n          if(textureIndex != 0) {\n            indices[${r}] = indices[${r}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;return Object.assign(Object.assign({},e),{output:{dims:a,type:n[0].type,textureType:i.TextureType.unpacked},shaderSource:g})})(0,r,e,n.axis)})},s=t=>`int getTextureWhereDataResides(int index) {\n      ${t.map(((t,e)=>`if(index<${t}) {return ${e};}\n`)).join("")}\n    }`,u=t=>s(t),c=(t,e)=>{const n=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e}]) {`];for(let e=0;e<t;++e)0===e?n.push(`\tif (textureIndex == ${e}) { return _X${e}(indices); }`):e===t-1?n.push(`\telse { return _X${e}(indices); }`):n.push(`\telse if (textureIndex == ${e}) { return _X${e}(indices); }`);return n.push("\t}"),n.join("\n")},l=t=>{const e=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let n=0;n<t.length;++n)0===n?e.push(`\tif (index == ${n}) { return ${t[n]}; }`):n===t.length-1?e.push(`\telse { return ${t[n]}; }`):e.push(`\telse if (index == ${n}) { return ${t[n]}; }`);return e.push("\t}"),e.join("\n")};e.parseConcatAttributes=t=>(0,r.createAttributeWithCacheKey)({axis:t.attributes.getInt("axis")});const p=t=>{if(!t||t.length<1)throw new Error("too few inputs");const e=t[0].type,n=t[0].dims.length;if("string"===e)throw new Error("string tensor is not supported yet");for(const r of t){if(r.type!==e)throw new Error("input tensors should be one type");if(r.dims.length!==n)throw new Error("input tensors should have the same shape")}}},4770:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createUnpackedGroupedConvProgramInfoLoader=void 0;const r=n(6231),i=n(5060),o=n(2039),a=n(8138),s=n(2823);e.createUnpackedGroupedConvProgramInfoLoader=(t,e,n)=>{const u=(c=e.length>2,l=n.cacheKey,{name:"GroupedConv",inputNames:c?["X","W","Bias"]:["X","W"],inputTypes:c?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],cacheHint:l});var c,l;return Object.assign(Object.assign({},u),{get:()=>((t,e,n,u)=>{const c=e.length>2?"value += getBias(output_channel);":"",l=e[0].dims.slice(),p=e[1].dims.slice(),f=p[0]/u.group;r.Logger.verbose("GroupedConv",`autpPad:${u.autoPad}, dilations:${u.dilations}, group:${u.group}, kernelShape:${u.kernelShape}, pads:${u.pads}, strides:${u.strides}`);const d=(0,a.calculateOutputShape)(l,p,u.dilations,u.pads,u.strides),h=(0,i.getGlsl)(t.session.backend.glContext.version),{activationFunction:g,applyActivation:b}=(0,s.getActivationSnippet)(u),m=`\n  const ivec2 strides = ivec2(${u.strides[0]}, ${u.strides[1]});\n  const ivec2 pads = ivec2(${u.pads[0]}, ${u.pads[1]});\n  ${g}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${f};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {\n      int input_channel = group_id * ${p[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${u.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${l[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${u.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${l[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${c}\n    ${b}\n    ${h.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},n),{output:{dims:d,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:m,hasMain:!0})})(t,e,u,n)})}},1386:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.conv2DPacked=e.conv2DPackedPointwise=void 0;const r=n(8138),i=n(8555),o=n(708);e.conv2DPackedPointwise=(t,e,n)=>{const i=e[0].dims,a=e[1].dims,s=(0,r.calculateOutputShape)(i,a,n.dilations,n.pads,n.strides),u=t.reshapePacked(e[0],[i[1],i[2]*i[3]]),c=t.reshapePacked(e[1],[a[0],a[1]]),l=e.length>2?[c,u,e[2]]:[c,u],p=t.run((0,o.createPackedMatmulProgramInfoLoader)(t,l,n),l);return t.reshapePacked(p,s)},e.conv2DPacked=(t,e,n)=>{const a=e[0].dims,s=e[1].dims,u=(0,r.calculateOutputShape)(a,s,n.dilations,n.pads,n.strides),c=t.run((0,i.createPackedIm2ColProgramInfoLoader)(t,e[0],e[1],u,n),[e[0]]),l=t.reshapePacked(e[1],[s[0],s[1]*s[2]*s[3]]),p=3===e.length?[l,c,e[2]]:[l,c],f=t.run((0,o.createPackedMatmulProgramInfoLoader)(t,p,n),p);return t.reshapePacked(f,u)}},9663:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseConvTransposeAttributes=e.convTranspose=void 0;const r=n(246),i=n(5060),o=n(2039),a=n(2823),s=(t,e,n,r,i,o)=>(t-1)*e+n+(r-1)*i+1-o,u=(t,e,n,r,i)=>{const o=Math.floor(t/2);"SAME_UPPER"===e?(n[r]=o,n[i]=t-o):"SAME_LOWER"===e&&(n[r]=t-o,n[i]=o)};e.convTranspose=(t,e,n)=>(f(e,n),c(t,e,n));const c=(t,e,n)=>{const r=p(n,e);return[l(t,e,r)]},l=(t,e,n)=>t.run(((t,e,n)=>{const r=(s=e.length>2,u=n.cacheKey,{name:"ConvTranspose",inputNames:s?["X","W","B"]:["X","W"],inputTypes:s?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],cacheHint:u});var s,u;return Object.assign(Object.assign({},r),{get:()=>((t,e,n,r)=>{const s=e.length>2?"getB(output_channel)":"0.0",u=e[0].dims,c=e[1].dims,l=c[1],p=c[0]/r.group,f=[e[0].dims[0],e[1].dims[1]*r.group,...r.outputShape],d=(0,i.getGlsl)(t.session.backend.glContext.version),{activationFunction:h,applyActivation:g}=(0,a.getActivationSnippet)(r),b=`\n  const ivec2 strides = ivec2(${r.strides[0]}, ${r.strides[1]});\n  const ivec2 pads = ivec2(${r.pads[0]}, ${r.pads[1]});\n  ${h}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${l};\n    int wOutChannel = output_channel - group_id * ${l};\n\n    float value = ${s};\n    for (int inChannelOffset = 0; inChannelOffset < ${p}; inChannelOffset++) {\n      int input_channel = group_id * ${p} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${c[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${c[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${r.dilations[0]}, wHOff * ${r.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${u[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${u[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${g}\n    ${d.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},n),{output:{dims:f,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:b,hasMain:!0})})(t,e,r,n)})})(t,e,n),e),p=(t,e)=>{const n=t.kernelShape.slice();if(0===t.kernelShape.length)for(let t=2;t<e[1].dims.length;++t)n.push(e[1].dims[t]);const r=t.pads.slice(),i=t.outputShape.slice();((t,e,n,r,i,o,a,c)=>{const l=t.length-2,p=0===c.length;for(let f=0;f<l;++f){const d=p?t[f+2]*o[f]:c[f],h=s(t[f+2],o[f],i[f],e[f],n[f],d);u(h,r,i,f,f+l),p&&c.push(o[f]*(t[f+2]-1)+a[f]+(e[f]-1)*n[f]+1-i[f]-i[f+l])}})(e[0].dims,n,t.dilations,t.autoPad,r,t.strides,t.outputPadding,i);const o=Object.assign({},t);return Object.assign(o,{kernelShape:n,pads:r,outputShape:i,cacheKey:t.cacheKey}),o};e.parseConvTransposeAttributes=t=>{const e=t.attributes,n=(0,a.parseInternalActivationAttributes)(e),i=e.getString("auto_pad","NOTSET"),o=e.getInts("dilations",[1,1]),s=e.getInt("group",1),u=e.getInts("kernel_shape",[]),c=e.getInts("output_padding",[0,0]),l=e.getInts("output_shape",[]),p=e.getInts("pads",[0,0,0,0]),f=e.getInts("strides",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:i,dilations:o,group:s,kernelShape:u,outputPadding:c,outputShape:l,pads:p,strides:f},n))};const f=(t,e)=>{if(!t||2!==t.length&&3!==t.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==t[0].dims.length||4!==t[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(t[0].dims[1]!==t[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const n=t[1].dims[1]*e.group;if(3===t.length&&(1!==t[2].dims.length||t[2].dims[0]!==n))throw new Error("invalid bias");const r=t[0].dims.length-2;if(e.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(e.strides.length!==r)throw new Error(`strides should be ${r}D`);if(e.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(e.outputPadding.length!==r)throw new Error(`output_padding should be ${r}D`);if(0!==e.kernelShape.length&&e.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==e.outputShape.length&&e.outputShape.length!==t[0].dims.length-2)throw new Error("invalid output shape");if("float32"!==t[0].type||"float32"!==t[1].type)throw new Error("ConvTranspose input(X,W) should be float tensor");if(3===t.length&&"float32"!==t[2].type)throw new Error("ConvTranspose input(bias) should be float tensor")}},8138:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseConvAttributes=e.conv=e.calculateOutputShape=void 0;const r=n(246),i=n(2517),o=n(4770),a=n(1386),s=n(9828),u=n(2823),c=n(3248),l=n(5623);e.calculateOutputShape=(t,e,n,r,i)=>{const o=t[0],a=t.slice(2),s=a.length,u=e[0],c=e.slice(2).map(((t,e)=>t+(t-1)*(n[e]-1))),l=a.map(((t,e)=>t+r[e]+r[e+s])).map(((t,e)=>Math.floor((t-c[e]+i[e])/i[e])));return[o,u].concat(...l)},e.conv=(t,e,n)=>(g(e,n),p(t,e,n));const p=(t,e,n)=>{const r=h(n,e),i=t.session.pack,s=1===r.kernelShape[0]&&1===r.kernelShape[1];return r.group>1?[t.run((0,o.createUnpackedGroupedConvProgramInfoLoader)(t,e,r),e)]:s&&i?[f(t,e,r)]:i&&4===e[0].dims.length&&1===e[0].dims[0]&&!s?[(0,a.conv2DPacked)(t,e,r)]:[d(t,e,r)]},f=(t,n,r)=>{const i=n[0].dims,o=n[1].dims,a=(0,e.calculateOutputShape)(i,o,r.dilations,r.pads,r.strides),s=t.reshapeUnpacked(n[0],[i[1],i[2]*i[3]]),u=t.reshapeUnpacked(n[1],[o[0],o[1]]),c=n.length>2?[u,s,n[2]]:[u,s],p=t.run((0,l.createMatmulProgramInfoLoader)(c,r),c);return t.reshapeUnpacked(p,a)},d=(t,n,r)=>{const i=n[0].dims,o=n[1].dims,a=(0,e.calculateOutputShape)(i,o,r.dilations,r.pads,r.strides),u=t.run((0,c.createIm2ColProgramInfoLoader)(t,n[0],n[1],a,r),[n[0]]),l=3===n.length?[u,n[1],n[2]]:[u,n[1]];return t.run((0,s.createDotProductProgramInfoLoader)(t,n,a,r),l)},h=(t,e)=>{const n=t.kernelShape.slice();if(0===t.kernelShape.length)for(let t=2;t<e[1].dims.length;++t)n.push(e[1].dims[t]);const r=t.pads.slice();i.PoolConvUtil.adjustPadsBasedOnAutoPad(e[0].dims,t.strides,t.dilations,n,r,t.autoPad);const o=Object.assign({},t);return Object.assign(o,{kernelShape:n,pads:r,cacheKey:t.cacheKey}),o};e.parseConvAttributes=t=>{const e=t.attributes,n=(0,u.parseInternalActivationAttributes)(e),i=e.getString("auto_pad","NOTSET"),o=e.getInts("dilations",[1,1]),a=e.getInt("group",1),s=e.getInts("kernel_shape",[]),c=e.getInts("pads",[0,0,0,0]),l=e.getInts("strides",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:i,dilations:o,group:a,kernelShape:s,pads:c,strides:l},n))};const g=(t,e)=>{if(!t||2!==t.length&&3!==t.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==t[0].dims.length||4!==t[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(t[0].dims[1]!==t[1].dims[1]*e.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===t.length&&(1!==t[2].dims.length||t[1].dims[0]!==t[2].dims[0]))throw new Error("invalid bias");const n=t[0].dims.length-2;if(e.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(e.strides.length!==n)throw new Error(`strides should be ${n}D`);if(e.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==e.kernelShape.length&&e.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if("float32"!==t[0].type||"float32"!==t[1].type)throw new Error("Conv input(X,W) should be float tensor");if(3===t.length&&"float32"!==t[2].type)throw new Error("Conv input(bias) should be float tensor")}},5193:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseDepthToSpaceAttributes=e.depthToSpace=void 0;const r=n(3738);e.depthToSpace=(t,e,n)=>{i(e);const o=n.blocksize,a=o*o,s="DCR"===n.mode?[0,3,4,1,5,2]:[0,1,4,2,5,3],u="DCR"===n.mode?[e[0].dims[0],o,o,e[0].dims[1]/a,e[0].dims[2],e[0].dims[3]]:[e[0].dims[0],e[0].dims[1]/a,o,o,e[0].dims[2],e[0].dims[3]],c=t.reshapeUnpacked(e[0],u),l={perm:s,cacheKey:`${s}`},[p]=(0,r.transpose)(t,[c],l),f=[e[0].dims[0],e[0].dims[1]/a,e[0].dims[2]*o,e[0].dims[3]*o];return[t.reshapeUnpacked(p,f)]},e.parseDepthToSpaceAttributes=t=>{const e=t.attributes.getInt("blocksize");if(e<1)throw new Error(`blocksize must be >= 1, but got : ${e} for DepthToSpace`);const n=t.attributes.getString("mode","DCR");if("DCR"!==n&&"CRD"!==n)throw new Error(`unrecognized mode: ${n} for DepthToSpace`);return{mode:n,blocksize:e}};const i=t=>{if(1!==t.length)throw new Error(`DepthToSpace expect 1 inputs, but got ${t.length}`);if("string"===t[0].type||4!==t[0].dims.length)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},9828:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createDotProductProgramInfoLoader=void 0;const r=n(2517),i=n(5060),o=n(2039),a=n(2823),s=n(3248);e.createDotProductProgramInfoLoader=(t,e,n,u)=>{const c=((t,e)=>({name:"ConvDotProduct",inputNames:t?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:t?[o.TextureType.unpacked,o.TextureType.packedLastDimension,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.packedLastDimension],cacheKey:e.activationCacheKey}))(e.length>2,u);return Object.assign(Object.assign({},c),{get:()=>((t,e,n,u,c)=>{const l=n[0].dims,p=n[1].dims,f=[p[0],Math.ceil(l[1]*p[2]*p[3]/4)],d=(0,s.calculateIm2ColDims)(l,p,u),[h,g]=t.calculateTextureWidthAndHeight(f,o.TextureType.packedLastDimension),b=r.ShapeUtil.computeStrides(d),[m,y]=t.calculateTextureWidthAndHeight(d,o.TextureType.packedLastDimension),_=u.length,v=n.length<3?"0.0":"_B(b)",w=Math.ceil(l[1]*p[2]*p[3]/4),{activationFunction:x,applyActivation:T}=(0,a.getActivationSnippet)(c),S=(0,i.getGlsl)(t.session.backend.glContext.version),O=`\n${x}\nfloat process(int indices[${_}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${b[0]} + im2col[1] * ${b[1]} + im2col[2] * ${b[2]};\n  int kernelOffset = indices[1] * ${f[1]};\n  float value = ${v};\n  for (int i = 0; i < ${w}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${m}, ${y});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h}, ${g});\n    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${T}\n  return value;\n}`;return Object.assign(Object.assign({},e),{output:{dims:u,type:n[0].type,textureType:o.TextureType.unpacked},shaderSource:O})})(t,c,e,n,u)})}},7992:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseFlattenAttributes=e.flatten=void 0;const r=n(2517);e.flatten=(t,e,n)=>{i(e,n);const o=r.ShapeUtil.flattenShape(e[0].dims,n);return[t.reshapeUnpacked(e[0],o)]},e.parseFlattenAttributes=t=>t.attributes.getInt("axis",1);const i=(t,e)=>{if(!t||1!==t.length)throw new Error("Flatten requires 1 input.");const n=t[0].dims.length;if(0===n)throw new Error("scalar tensor is not supported.");if(e<-n||e>n)throw new Error("Invalid axis");if("string"===t[0].type)throw new Error("string tensor is not supported.")}},2823:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseInternalActivationAttributes=e.getActivationSnippet=void 0;const r=n(2517),i=n(4909);e.getActivationSnippet=function(t){let e;switch(t.activation){case"Relu":e=(0,i.glslRelu)();break;case"Sigmoid":e=(0,i.glslSigmoid)();break;case"Clip":e=(0,i.glslClip)(t.clipMin,t.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const n=e.name;return{activationFunction:e.body,applyActivation:`value = ${n}_(value);`}},e.parseInternalActivationAttributes=t=>{const e=t.getString("activation","");if("Clip"===e){const[n,i]=t.getFloats("activation_params",[r.MIN_CLIP,r.MAX_CLIP]);return{activation:e,clipMax:i,clipMin:n,activationCacheKey:`${e}:${n},${i}`}}return{activation:e,activationCacheKey:e}}},1253:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseGatherAttributes=e.gather=void 0;const r=n(246),i=n(782),o=n(2517),a=n(2039);e.gather=(t,e,n)=>(c(e,n.axis),[t.run(u(t,e,n),e)]),e.parseGatherAttributes=t=>(0,r.createAttributeWithCacheKey)({axis:t.attributes.getInt("axis",0)});const s={name:"Gather",inputNames:["A","B"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked]},u=(t,e,n)=>{const r=Object.assign(Object.assign({},s),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((t,e,n,r)=>{const i=n[0].dims.slice(),s=n[1].dims.slice(),u=new Array(i.length+s.length-1);r=o.ShapeUtil.normalizeAxis(r,i.length);const c=[];for(let t=0;t<u.length;t++)t<r?(u[t]=i[t],c.push(`inputIdx[${t}] = outputIdx[${t}];`)):t<r+s.length?(u[t]=s[t-r],c.push(`indexDataIdx[${t-r}] = outputIdx[${t}];`)):(u[t]=i[t-s.length+1],c.push(`inputIdx[${t-s.length+1}] = outputIdx[${t}];`));const l=`\n      float process(int outputIdx[${u.length||1}]) {\n        int inputIdx[${i.length}];\n        int indexDataIdx[${s.length||1}];\n        indexDataIdx[0] = 0;\n        ${c.join("\n        ")}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${r}] = idx < 0 ? idx + ${i[r]} : idx;\n        return _A(inputIdx);\n      }`;return Object.assign(Object.assign({},e),{output:{dims:u,type:n[0].type,textureType:a.TextureType.unpacked},shaderSource:l})})(0,r,e,n.axis)})},c=(t,e)=>{if(!t||2!==t.length)throw new Error("Gather requires 2 inputs.");const n=t[0].dims.length;if(n<1)throw new Error("Invalid input shape.");if(e<-n||e>n-1)throw new Error("Invalid axis.");if(-1===i.NUMBER_TYPES.indexOf(t[0].type))throw new Error("Invaid input type.");if("int32"!==t[1].type&&"int16"!==t[1].type)throw new Error("Invaid input type.")}},4776:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseGemmAttributesV11=e.parseGemmAttributesV7=e.gemm=void 0;const r=n(246),i=n(2517),o=n(2039);e.gemm=(t,e,n)=>(c(e,n),[t.run(s(e,n),e)]);const a=(t,e)=>{const n=0!==t.attributes.getInt("transA",0),i=0!==t.attributes.getInt("transB",0),o=t.attributes.getFloat("alpha",1),a=t.attributes.getFloat("beta",1);return(0,r.createAttributeWithCacheKey)({transA:n,transB:i,alpha:o,beta:a,isOptionalC:e})};e.parseGemmAttributesV7=t=>a(t,!1),e.parseGemmAttributesV11=t=>a(t,!0);const s=(t,e)=>{const n={name:"Gemm",inputNames:3===t.length?["A","B","C"]:["A","B"],inputTypes:3===t.length?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],key:e.cacheKey};return Object.assign(Object.assign({},n),{get:()=>u(n,t,e)})},u=(t,e,n)=>{const r=e[0].dims.slice(),a=e[1].dims.slice(),[s,u]=i.GemmUtil.getShapeOfGemmResult(r,n.transA,a,n.transB,3===e.length?e[2].dims:void 0),c=[s,u];if(!c)throw new Error("Can't use gemm on the given tensors");let l=r[r.length-1],p="";n.transA&&(l=r[0]),n.transA&&n.transB?p="value += _A_T(a) * _B_T(b);":n.transA&&!n.transB?p="value += _A_T(a) * _B(b);":!n.transA&&n.transB?p="value += _A(a) * _B_T(b);":n.transA||n.transB||(p="value += _A(a) * _B(b);");const f=c.length,d=`\n      float process(int indices[${f}]) {\n          int a[${f}];\n          int b[${f}];\n          ${3===e.length?`int c[${e[2].dims.length}];`:""}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${3===e.length?"bcastIndices_C(indices, c);":""}\n\n          float value = 0.0;\n          for (int k=0; k<${l}; ++k) {\n              a[${f-1}] = k;\n              b[${f-2}] = k;\n              ${p}\n          }\n\n          value = value * alpha;\n          ${3===e.length?"value += beta * _C(c);":""}\n          return value;\n      }`;return Object.assign(Object.assign({},t),{output:{dims:c,type:e[0].type,textureType:o.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:n.alpha},{name:"beta",type:"float",data:n.beta}],shaderSource:d})},c=(t,e)=>{if(!t)throw new Error("Input is missing");if(e.isOptionalC&&(t.length<2||t.length>3))throw new Error("Invaid input shape.");if(!e.isOptionalC&&3!==t.length)throw new Error("Gemm requires 3 inputs");if(3===t.length&&1!==t[2].dims.length&&2!==t[2].dims.length)throw new Error("Invalid input shape of C");if("float32"!==t[0].type&&"float64"!==t[0].type||"float32"!==t[1].type&&"float64"!==t[1].type||3===t.length&&"float32"!==t[2].type&&"float64"!==t[2].type)throw new Error("Invalid input type.");if(t[0].type!==t[1].type||3===t.length&&t[0].type!==t[2].type)throw new Error("Input types are mismatched")}},8555:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createPackedIm2ColProgramInfoLoader=void 0;const r=n(5060),i=n(2039),o=n(2827);e.createPackedIm2ColProgramInfoLoader=(t,e,n,a,s)=>{const u=(c=s.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[i.TextureType.packed],cacheHint:c});var c;return Object.assign(Object.assign({},u),{get:()=>((t,e,n,a,s,u)=>{const c=n.dims,l=a.dims,p=s.length,f=[l[1]*l[2]*l[3],s[2]*s[3]],d=l[2]*l[3],h=(0,o.unpackFromChannel)(),g=(0,r.getGlsl)(t.session.backend.glContext.version);let b="";for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)b+=`\n            blockIndex = rc.x + ${e};\n            pos = rc.y + ${t};\n\n            if(blockIndex < ${f[1]} && pos < ${f[0]}) {\n              offsetY = int(blockIndex / (${s[p-1]})) * ${u.strides[0]} -\n                ${u.pads[0]};\n              d0 = offsetY + ${u.dilations[0]} * (imod(pos, ${d}) / ${l[2]});\n\n              if(d0 < ${c[2]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${s[p-1]}) * ${u.strides[1]} -\n                  ${u.pads[1]};\n                d1 = offsetX + ${u.dilations[1]} * imod(imod(pos, ${d}), ${l[2]});\n\n                if(d1 < ${c[3]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${d}.);\n                    innerDims = vec2(d0, d1);\n                    result[${2*t+e}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;const m=`\n      ${h}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${b}\n          ${g.output} = result;\n      }\n            `;return Object.assign(Object.assign({},e),{output:{dims:f,type:n.type,textureType:i.TextureType.packed},shaderSource:m,hasMain:!0})})(t,u,e,n,a,s)})}},3248:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.calculateIm2ColDims=e.createIm2ColProgramInfoLoader=void 0;const r=n(2039);e.createIm2ColProgramInfoLoader=(t,n,i,o,a)=>{const s=(u=a.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[r.TextureType.unpacked],cacheHint:u});var u;return Object.assign(Object.assign({},s),{get:()=>((t,n,i,o,a,s)=>{const u=i.dims,c=o.dims,l=a.length,p=(0,e.calculateIm2ColDims)(u,c,a,4),f=`\n        const int XC = ${u[1]};\n        const int XH = ${u[2]};\n        const int XW = ${u[3]};\n        const int KH = ${s.kernelShape[0]};\n        const int KW = ${s.kernelShape[1]};\n        const int dilationH = ${s.dilations[0]};\n        const int dilationW = ${s.dilations[1]};\n        const int strideH = ${s.strides[0]};\n        const int strideW = ${s.strides[1]};\n        const int padH = ${s.pads[0]};\n        const int padW = ${s.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${l}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${u.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;return Object.assign(Object.assign({},n),{output:{dims:p,type:i.type,textureType:r.TextureType.packedLastDimension},shaderSource:f})})(0,s,n,i,o,a)})},e.calculateIm2ColDims=(t,e,n,r=4)=>[n[0],n[2],n[3],Math.ceil(t[1]*e[2]*e[3]/r)]},6572:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseImageScalerAttributes=e.imageScaler=void 0;const r=n(246),i=n(2039);e.imageScaler=(t,e,n)=>(u(e),[t.run(a(t,e,n),e)]),e.parseImageScalerAttributes=t=>{const e=t.attributes.getFloat("scale"),n=t.attributes.getFloats("bias");return(0,r.createAttributeWithCacheKey)({scale:e,bias:n})};const o={name:"ImageScaler",inputNames:["X"],inputTypes:[i.TextureType.unpacked]},a=(t,e,n)=>{const r=Object.assign(Object.assign({},o),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((t,e,n,r)=>{const o=n[0].dims.slice(),a=o.length,u=`\n      ${s(r.bias.length)}\n      float process(int indices[${a}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;return Object.assign(Object.assign({},e),{output:{dims:o,type:n[0].type,textureType:i.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:r.bias.length,data:r.bias},{name:"scale",type:"float",data:r.scale}],shaderSource:u})})(0,r,e,n)})},s=t=>{const e=[`float getBias(float bias[${t}], int channel) {`];for(let n=0;n<t;++n)0===n?e.push(`\tif (channel == ${n}) { return bias[${n}]; }`):n===t-1?e.push(`\telse { return bias[${n}]; }`):e.push(`\telse if (channel == ${n}) { return bias[${n}]; }`);return e.push("\t}"),e.join("\n")},u=t=>{if(!t||1!==t.length)throw new Error("ImageScaler requires 1 input.");if(4!==t[0].dims.length)throw new Error("Invalid input shape.");if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("Invalid input type.")}},3346:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseInstanceNormalizationAttributes=e.instanceNormalization=void 0;const r=n(5060),i=n(2039);e.instanceNormalization=(t,e,n)=>{c(e);const r=t.run(a(e[0]),e);return[t.run(u(t,e[0],n,r.dims),[e[0],r,e[1],e[2]])]},e.parseInstanceNormalizationAttributes=t=>t.attributes.getFloat("epsilon",1e-5);const o={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[i.TextureType.unpacked]},a=t=>Object.assign(Object.assign({},o),{get:()=>((t,e)=>{const n=e.dims.slice(),r=n[1],o=n[2]*n[3],a=[n[0],r],s=`\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${n[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${n[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${o});\n        temp = 0.0;\n        for(int a2=0; a2<${n[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${n[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${o});\n\n        return v;\n      }`;return Object.assign(Object.assign({},t),{output:{dims:a,type:e.type,textureType:i.TextureType.packedLastDimension},shaderSource:s})})(o,t)}),s={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[i.TextureType.unpacked,i.TextureType.packedLastDimension,i.TextureType.unpacked,i.TextureType.unpacked]},u=(t,e,n,o)=>{const a=Object.assign(Object.assign({},s),{cacheHint:`${n}`});return Object.assign(Object.assign({},a),{get:()=>((t,e,n,o,a)=>{const s=(0,r.getGlsl)(t.session.backend.glContext.version),[u,c]=t.calculateTextureWidthAndHeight(a,i.TextureType.packedLastDimension),[l,p]=[u/4,c],f=`\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${l}, ${p});\n        return ${s.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;return Object.assign(Object.assign({},e),{output:{dims:n.dims,type:n.type,textureType:i.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:o}],shaderSource:f})})(t,a,e,n,o)})},c=t=>{if(!t||3!==t.length)throw new Error("InstanceNormalization requires 3 inputs.");const e=t[0],n=t[1],r=t[2];if(e.dims.length<3||1!==n.dims.length||1!==r.dims.length)throw new Error("Invalid input shape.");if(n.dims[0]!==e.dims[1]||r.dims[0]!==e.dims[1])throw new Error("Input shapes are mismatched.");if("float32"!==e.type&&"float64"!==e.type||"float32"!==n.type&&"float64"!==n.type||"float32"!==r.type&&"float64"!==r.type)throw new Error("Invalid input type.");if(4!==t[0].dims.length)throw new Error("Only support 4-D input shape.")}},708:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createPackedMatmulProgramInfoLoader=void 0;const r=n(2517),i=n(5060),o=n(2039),a=n(9390),s=n(2823),u=n(5623);e.createPackedMatmulProgramInfoLoader=(t,e,n)=>{const c=(l=e.length>2,p=n.activationCacheKey,{name:"MatMul (packed)",inputNames:l?["A","B","Bias"]:["A","B"],inputTypes:l?[o.TextureType.packed,o.TextureType.packed,o.TextureType.packed]:[o.TextureType.packed,o.TextureType.packed],cacheHint:p});var l,p;return Object.assign(Object.assign({},c),{get:()=>((t,e,n,c)=>{const l=n.length>2,p=l?"value += getBiasForMatmul();":"",f=n[0].dims,d=n[1].dims,h=r.BroadcastUtil.calcShape(f,d,!0),g=!r.ShapeUtil.areEqual(n[0].dims,n[1].dims);if(!h)throw new Error("Can't use matmul on the given tensors");const b=f[f.length-1],m=Math.ceil(b/2),y=f.length,_=d.length,v=(0,i.getGlsl)(t.session.backend.glContext.version),w=(0,a.getCoordsDataType)(h.length),x=h.length,T=(0,a.getGlChannels)(),{activationFunction:S,applyActivation:O}=(0,s.getActivationSnippet)(c),A=l?`${(0,u.getBiasForMatmul)(w,T,n[2].dims,h,!0)}`:"",E=g?`${function(t,e,n,i){let o=[],a=[];const s=n[0].dims,u=n[1].dims,c=s.length,l=u.length,p=i.length,f=p-c,d=p-l;o=s.map(((t,n)=>`coords.${e[n+f]}`)),o[c-1]="i*2",o.join(", "),a=u.map(((t,n)=>`coords.${e[n+d]}`)),a[l-2]="i*2",a.join(", ");const h=r.BroadcastUtil.getBroadcastDims(s,i),g=r.BroadcastUtil.getBroadcastDims(u,i),b=h.map((t=>`coords.${e[t+f]} = 0;`)).join("\n"),m=g.map((t=>`coords.${e[t+d]} = 0;`)).join("\n"),y=`int lastDim = coords.${e[p-1]};\n  coords.${e[p-1]} = coords.${e[p-2]};\n  coords.${e[p-2]} = lastDim;`;return`\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${t} coords = getOutputCoords();\n  ${y}\n  ${b}\n  vec4 outputValue = getA(${o});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${t} coords = getOutputCoords();\n  ${y}\n  ${m}\n  vec4 outputValue = getB(${a});\n  return outputValue;\n}`}(w,T,n,h)}`:"",I=g?"getAAtOutCoordsMatmul(i)":`getA(${function(t,e){let n="";for(let r=0;r<e-2;r++)n+=`rc.${t[r]}, `;return n+=`rc.${t[e-2]}, i*2`,n}(T,y)})`,P=g?"getBAtOutCoordsMatmul(i)":`getB(${function(t,e){let n="";for(let r=0;r<e-2;r++)n+=`rc.${t[r]}, `;return n+=`i*2, rc.${t[e-1]}`,n}(T,_)})`,D=`\n            ${E}\n            ${A}\n            ${S}\n            void main() {\n              ${g?"":`${w} rc =\n          getOutputCoords(); int lastDim = rc.${T[x-1]}; rc.${T[x-1]} =\n          rc.${T[x-2]}; rc.${T[x-2]} = lastDim;\n      `}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${m}; i++) {\n                vec4 a = ${I};\n                vec4 b = ${P};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${p}\n              ${O}\n              ${v.output} = value;\n            }`;return Object.assign(Object.assign({},e),{output:{dims:h,type:n[0].type,textureType:o.TextureType.packed},shaderSource:D,hasMain:!0})})(t,c,e,n)})}},5623:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getBiasForMatmul=e.createMatmulProgramInfoLoader=e.parseMatMulAttributes=e.matMul=void 0;const r=n(2517),i=n(2039),o=n(9390),a=n(2823),s=n(708);function u(t,e){const n=(s=t.length>2,u=e.activationCacheKey,{name:"MatMul",inputNames:s?["A","B","Bias"]:["A","B"],inputTypes:s?[i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked]:[i.TextureType.unpacked,i.TextureType.unpacked],cacheHint:u});var s,u;return Object.assign(Object.assign({},n),{get:()=>function(t,e,n){const s=e[0].dims,u=e[1].dims,c=r.BroadcastUtil.calcShape(s,u,!0);if(!c)throw new Error("Can't use matmul on the given tensors");const p=(0,o.getCoordsDataType)(c.length),f=(0,o.getGlChannels)(),{activationFunction:d,applyActivation:h}=(0,a.getActivationSnippet)(n),g=e.length>2,b=g?"value += getBiasForMatmul();":"",m=g?`${l(p,f,e[2].dims,c,!1)}`:"",y=c.length,_=s.length,v=u.length,w=`\n    ${d}\n    ${m}\n    float process(int indices[${y}]) {\n        int a[${_}];\n        int b[${v}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${s[s.length-1]}; ++k) {\n            a[${_-1}] = k;\n            b[${v-2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${b}\n        ${h}\n        return value;\n    }`;return Object.assign(Object.assign({},t),{output:{dims:c,type:e[0].type,textureType:i.TextureType.unpacked},shaderSource:w})}(n,t,e)})}e.matMul=(t,e,n)=>(c(e),t.session.pack?[t.run((0,s.createPackedMatmulProgramInfoLoader)(t,e,n),e)]:[t.run(u(e,n),e)]),e.parseMatMulAttributes=t=>(0,a.parseInternalActivationAttributes)(t.attributes),e.createMatmulProgramInfoLoader=u;const c=t=>{if(!t||2!==t.length)throw new Error("MatMul requires 2 inputs.");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error("shared dimension does not match.");if("float32"!==t[0].type&&"float64"!==t[0].type||"float32"!==t[1].type&&"float64"!==t[1].type)throw new Error("inputs should be float type");if(t[0].type!==t[1].type)throw new Error("inputs types should match")};function l(t,e,n,i,o){let a="";const s=n.length,u=i.length,c=u-s;a=u<2&&s>0?"coords":n.map(((t,n)=>`coords.${e[n+c]}`)).join(", ");const l=r.BroadcastUtil.getBroadcastDims(n,i).map((t=>`coords.${e[t+c]} = 0;`)).join("\n");let p="vec4(outputValue.xx, outputValue.yy)";return 1===r.ShapeUtil.size(n)&&(p="vec4(outputValue.x)"),o?`\nvec4 getBiasForMatmul() {\n  ${t} coords = getOutputCoords();\n  ${l}\n  vec4 outputValue = getBias(${a});\n  return ${p};\n}`:`\nfloat getBiasForMatmul() {\n  ${t} coords = getOutputCoords();\n  ${l}\n  return getBias(coords.x);\n}`}e.getBiasForMatmul=l},2403:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createPackProgramInfoLoader=void 0;const r=n(5060),i=n(2039),o=n(9390),a=n(2827),s={name:"pack",inputNames:["A"],inputTypes:[i.TextureType.unpackedReversed]};e.createPackProgramInfoLoader=(t,e)=>Object.assign(Object.assign({},s),{get:()=>((t,e)=>{const n=(0,r.getGlsl)(t.session.backend.glContext.version),u=e.dims,c=u.length,l=e.dims.length,p=(0,o.getCoordsDataType)(l),f=(0,a.getChannels)("rc",l),d=(h=l,g=f,b=u[u.length-2],m=u[u.length-1],0===h||1===h?"":`\n    int r = ${g[h-2]};\n    int c = ${g[h-1]};\n    int rp1 = ${g[h-2]} + 1;\n    int cp1 = ${g[h-1]} + 1;\n    bool rEdge = rp1 >= ${m};\n    bool cEdge = cp1 >= ${b};\n    `);var h,g,b,m;let y;y=0===c?[1,1]:1===c?[u[0],1]:[u[l-1],u[l-2]];const _=function(t,e,n){if(0===t)return"false";if(1===t)return`rc > ${e[0]}`;let r="";for(let i=t-2;i<t;i++)r+=`${n[i]} >= ${e[i-t+2]}`,i<t-1&&(r+="||");return r}(l,y,f),v=function(t,e){const n=t.length;if(0===n)return"getA(), 0, 0, 0";if(1===n)return`getA(rc),\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\n            0, 0`;let r="";if(n>2)for(let t=0;t<n-2;++t)r+=`${e[t]},`;return`getA(${r}r, c),\n          rEdge ? 0. : getA(${r}rp1, c),\n          cEdge ? 0. : getA(${r}r, cp1),\n          rEdge || cEdge ? 0. : getA(${r}rp1, cp1)`}(u,f),w=`\n        void main() {\n          ${p} rc = getOutputCoords();\n\n          if(${_}) {\n            ${n.output} = vec4(0);\n          } else {\n            ${d}\n\n            ${n.output} = vec4(${v});\n          }\n        }\n      `;return Object.assign(Object.assign({},s),{hasMain:!0,output:{dims:e.dims,type:e.type,textureType:i.TextureType.packed},shaderSource:w})})(t,e)})},2827:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.unpackFromChannel=e.getChannels=e.getVecChannels=void 0;const r=n(9390);function i(t,e){return(0,r.getGlChannels)(e).map((e=>`${t}.${e}`))}e.getVecChannels=i,e.getChannels=function(t,e){return 1===e?[t]:i(t,e)},e.unpackFromChannel=function(){return"\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  "}},2870:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parsePadAttributesV11=e.padV11=e.parsePadAttributesV2=e.padV2=void 0;const r=n(246),i=n(2517),o=n(5060),a=n(2039),s={name:"Pad",inputNames:["A"],inputTypes:[a.TextureType.unpacked]};e.padV2=(t,e,n)=>(l(e),[t.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>c(t,e[0],n)}),e)]),e.parsePadAttributesV2=t=>{const e=t.attributes.getString("mode","constant"),n=t.attributes.getFloat("value",0),i=t.attributes.getInts("pads");return(0,r.createAttributeWithCacheKey)({mode:e,value:n,pads:i})},e.padV11=(t,n,r)=>{p(n);const i=u(t,n,r);return(0,e.padV2)(t,[n[0]],i)},e.parsePadAttributesV11=t=>t.attributes.getString("mode","constant");const u=(t,e,n)=>{if(!t.session.isInitializer(e[1].dataId)||e.length>=3&&!t.session.isInitializer(e[2].dataId))throw new Error("dynamic pad attributes are not allowed");const i=Array.from(e[1].integerData),o=e.length>=3?e[2].floatData[0]:0;return(0,r.createAttributeWithCacheKey)({mode:n,pads:i,value:o})},c=(t,e,n)=>{const r=i.ShapeUtil.padShape(e.dims.slice(),n.pads),o=r.length,s=`\n      ${f(t,e,n)}\n      float process(int[${o}] indices) {\n          return padA(indices);\n      }`;return{name:"Pad",inputNames:["A"],inputTypes:[a.TextureType.unpacked],output:{dims:r,type:e.type,textureType:a.TextureType.unpacked},shaderSource:s}},l=t=>{if(!t||1!==t.length)throw new Error("Pad requires 1 input");if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("Invalid input type.")},p=t=>{if(!t||2!==t.length&&3!==t.length)throw new Error("Pad requires 2 or 3 inputs");if("int32"!==t[1].type)throw new Error("Invalid input type.");if(t.length>=3&&"string"===t[2].type)throw new Error("Invalid input type.")},f=(t,e,n)=>{const r=(0,o.getGlsl)(t.session.backend.glContext.version),[s,u]=t.calculateTextureWidthAndHeight(e.dims,a.TextureType.unpacked),c=i.ShapeUtil.computeStrides(e.dims);switch(n.mode){case"constant":return d(r,e.dims,c,s,u,n.pads,n.value);case"reflect":return h(r,e.dims,c,s,u,n.pads);case"edge":return g(r,e.dims,c,s,u,n.pads);default:throw new Error("Invalid mode")}},d=(t,e,n,r,i,o,a)=>{const s=e.length;let u="";for(let t=s-1;t>=0;--t)u+=`\n        k = m[${t}] - ${o[t]};\n        if (k < 0)  return constant;\n        if (k >= ${e[t]}) return constant;\n        offset += k * ${n[t]};\n        `;return`\n      float padA(int m[${s}]) {\n        const float constant = float(${a});\n        int offset = 0;\n        int k = 0;\n        ${u}\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\n        return value;\n      }\n      `},h=(t,e,n,r,i,o)=>{const a=e.length;let s="";for(let t=a-1;t>=0;--t)s+=`\n        k = m[${t}] - ${o[t]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2*(e[t]-1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${e[t]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${n[t]};\n        `;return`\n      float padA(int m[${a}]) {\n        int offset = 0;\n        int k = 0;\n        ${s}\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\n        return value;\n      }\n      `},g=(t,e,n,r,i,o)=>{const a=e.length;let s="";for(let t=a-1;t>=0;--t)s+=`\n        k = m[${t}] - ${o[t]};\n        if (k < 0)  k = 0;\n        if (k >= ${e[t]}) k = ${e[t]-1};\n        offset += k * ${n[t]};\n      `;return`\n      float padA(int m[${a}]) {\n        int offset = 0;\n        int k = 0;\n        ${s}\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\n        return value;\n      }\n      `}},2143:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.globalMaxPool=e.parseMaxPoolAttributes=e.maxPool=e.parseGlobalAveragePoolAttributes=e.globalAveragePool=e.parseAveragePoolAttributes=e.averagePool=void 0;const r=n(246),i=n(2517),o=n(2039);e.averagePool=(t,e,n)=>{p(e);const r={name:"AveragePool",inputNames:["X"],inputTypes:[o.TextureType.unpacked],cacheHint:n.cacheKey};return[t.run(Object.assign(Object.assign({},r),{get:()=>a(e,r,!1,n)}),e)]},e.parseAveragePoolAttributes=t=>{const e=t.attributes.getString("auto_pad","NOTSET"),n=t.attributes.getInt("ceil_mode",0),i=0!==t.attributes.getInt("count_include_pad",0),o=t.attributes.getInts("kernel_shape"),a=t.attributes.getInts("strides",[]),s=t.attributes.getInts("pads",[]);if(0!==n)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,r.createAttributeWithCacheKey)({autoPad:e,ceilMode:n,countIncludePad:i,kernelShape:o,strides:a,pads:s})};const a=(t,e,n,r)=>{const[a,s]=u(t,r,n),c=i.ShapeUtil.size(a.kernelShape);let l="";a.countIncludePad?l+=`value /= float(${c});`:l+=`value /= float(${c} - pad);`;const p=`\n        ${f(t[0].dims,a,"value += _X(x);",l,"0.0")}\n      `;return Object.assign(Object.assign({},e),{output:{dims:s,type:t[0].type,textureType:o.TextureType.unpacked},shaderSource:p})};e.globalAveragePool=(t,e,n)=>{p(e);const r={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[o.TextureType.unpacked],cacheHint:`${n.countIncludePad}`};return[t.run(Object.assign(Object.assign({},r),{get:()=>a(e,r,!0,n)}),e)]},e.parseGlobalAveragePoolAttributes=t=>{const e=0!==t.attributes.getInt("count_include_pad",0);return(0,r.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:e,kernelShape:[],strides:[],pads:[]})},e.maxPool=(t,e,n)=>{p(e);const r={name:"MaxPool",inputNames:["X"],inputTypes:[o.TextureType.unpacked],cacheHint:n.cacheKey};return[t.run(Object.assign(Object.assign({},r),{get:()=>s(e,r,!1,n)}),e)]},e.parseMaxPoolAttributes=t=>{const e=t.attributes.getString("auto_pad","NOTSET"),n=t.attributes.getInt("ceil_mode",0),i=t.attributes.getInts("kernel_shape"),o=t.attributes.getInts("strides",[]),a=t.attributes.getInts("pads",[]),s=t.attributes.getInt("storage_order",0),u=t.attributes.getInts("dilations",[]);if(0!==s)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==n)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,r.createAttributeWithCacheKey)({autoPad:e,ceilMode:n,countIncludePad:!1,kernelShape:i,strides:o,pads:a,storageOrder:s,dilations:u})};const s=(t,e,n,r)=>{const[i,a]=u(t,r,n),s=`\n      ${f(t[0].dims,i,"\n      value = max(_X(x), value);\n    ","","-1e5")}\n    `;return Object.assign(Object.assign({},e),{output:{dims:a,type:t[0].type,textureType:o.TextureType.unpacked},shaderSource:s})},u=(t,e,n)=>{const r=t[0].dims.slice(),o=Object.hasOwnProperty.call(e,"dilations"),a=e.kernelShape.slice(),s=e.strides.slice(),u=o?e.dilations.slice():[],c=e.pads.slice();i.PoolConvUtil.adjustPoolAttributes(n,r,a,s,u,c);const l=i.PoolConvUtil.computePoolOutputShape(n,r,s,u,a,c,e.autoPad),p=Object.assign({},e);return o?Object.assign(p,{kernelShape:a,strides:s,pads:c,dilations:u,cacheKey:e.cacheKey}):Object.assign(p,{kernelShape:a,strides:s,pads:c,cacheKey:e.cacheKey}),[p,l]},c={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},l={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[o.TextureType.unpacked]};e.globalMaxPool=(t,e)=>(p(e),[t.run(Object.assign(Object.assign({},l),{get:()=>s(e,l,!0,c)}),e)]);const p=t=>{if(!t||1!==t.length)throw new Error("Pool ops requires 1 input.");if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("Invalid input type.")},f=(t,e,n,r,o)=>{const a=t.length;if(e.kernelShape.length<=2){const i=e.kernelShape[e.kernelShape.length-1],s=e.strides[e.strides.length-1],u=e.pads[e.pads.length/2-1],c=e.pads[e.pads.length-1],l=t[a-1];let p="",f="",d="";if(p=u+c!==0?`\n          for (int i = 0; i < ${i}; i++) {\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\n            if (x[${a} - 1] < 0 || x[${a} - 1] >= ${l}) {\n              pad++;\n              continue;\n            }\n            ${n}\n          }`:`\n          for (int i = 0; i < ${i}; i++) {\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\n            ${n}\n          }`,2===e.kernelShape.length){const n=e.kernelShape[e.kernelShape.length-2],r=e.strides[e.strides.length-2],o=e.pads[e.pads.length/2-2],s=e.pads[e.pads.length-2],u=t[a-2];f=o+s!==0?`\n            for (int j = 0; j < ${n}; j++) {\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${o} + j;\n              if (x[${a} - 2] < 0 || x[${a} - 2] >= ${u}) {\n                pad+= ${i};\n                continue;\n              }\n          `:`\n            for (int j = 0; j < ${n}; j++) {\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${o} + j;\n            `,d="\n          }\n        "}return`\n        float process(int indices[${a}]) {\n          int x[${a}];\n          copyVec(indices, x);\n\n          float value = ${o};\n          int pad = 0;\n          ${f}\n          ${p}\n          ${d}\n          ${r}\n          return value;\n        }\n      `}{const s=i.ShapeUtil.size(e.kernelShape),u=i.ShapeUtil.computeStrides(e.kernelShape),c=u.length,l=e.pads.length,p=h(c),f=d(t,"inputDims"),g=d(e.pads,"pads"),b=d(u,"kernelStrides"),m=d(e.strides,"strides");let y="";return y=e.pads.reduce(((t,e)=>t+e))?`\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${n}\n          }`:`\n          }\n          ${n}\n        `,`\n        ${p}\n        float process(int indices[${a}]) {\n          int x[${a}];\n          copyVec(indices, x);\n          int offset[${c}];\n          int pads[${l}];\n          int inputDims[${a}];\n          int kernelStrides[${c}];\n          int strides[${c}];\n          ${g}\n          ${f}\n          ${m}\n          ${b}\n\n          float value = ${o};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${s}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${a} - ${c}; j < ${a}; j++) {\n              x[j] = indices[j] * strides[j - ${a} + ${c}]\n                + offset[j - ${a} + ${c}] - pads[j - 2];\n              ${y}\n          }\n          ${r}\n\n          return value;\n        }\n      `}},d=(t,e)=>{let n="";for(let r=0;r<t.length;r++)n+=`\n      ${e}[${r}] = ${t[r]};\n    `;return n},h=t=>`\n  void offsetToIndices(int offset, int[${t}] strides, out int[${t}] indices) {\n    if (${t} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${t} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${t} - 1] = offset;\n  }`},4939:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.reduceLogSumSquare=e.reduceLogSum=e.reduceProd=e.reduceMin=e.reduceMax=e.reduceMean=e.reduceSum=e.parseReduceAttributes=void 0;const r=n(246),i=n(782),o=n(2517),a=n(2039),s=(t,e,n,r,i)=>{c(e);const o={name:r,inputNames:["A"],inputTypes:[a.TextureType.unpacked]};return[t.run(Object.assign(Object.assign({},o),{cacheHint:n.cacheKey,get:()=>u(t,e,n,r,i,o)}),e)]};e.parseReduceAttributes=t=>{const e=t.attributes.getInts("axes",[]),n=1===t.attributes.getInt("keepdims",1);return(0,r.createAttributeWithCacheKey)({axes:e,keepDims:n})};const u=(t,e,n,r,i,s)=>{const u=[],c=e[0].dims.length||1,l=[],p=o.ShapeUtil.normalizeAxes(n.axes,e[0].dims.length),f=i(e,p);let d=f[1];for(let t=0;t<e[0].dims.length;t++)p.indexOf(t)>=0||0===p.length?(n.keepDims&&u.push(1),d=`\n          for(int j${t} = 0; j${t} < ${e[0].dims[t]}; j${t}++) {\n            inputIdx[${t}] = j${t};\n            ${d}\n          }`):(l.push(`inputIdx[${t}] = outputIdx[${u.length}];`),u.push(e[0].dims[t]));const h=`\n      float process(int outputIdx[${u.length||1}]) {\n        float value;                 // final result\n        int inputIdx[${c}];      // addressing input data\n        ${l.join("\n")}\n        ${f[0]}       // init ops for reduce max/min\n        ${d}\n        ${f[2]}       // final computation for reduce mean\n        return value;\n      }`;return Object.assign(Object.assign({},s),{output:{dims:u,type:e[0].type,textureType:a.TextureType.unpacked},shaderSource:h})},c=t=>{if(!t||1!==t.length)throw new Error("Reduce op requires 1 input.");if(-1===i.NUMBER_TYPES.indexOf(t[0].type))throw new Error("Invalid input type.")};e.reduceSum=(t,e,n)=>s(t,e,n,"ReduceSum",(()=>["value = 0.0;","value += _A(inputIdx);",""])),e.reduceMean=(t,e,n)=>s(t,e,n,"ReduceMean",((t,e)=>{let n=1;for(let r=0;r<t[0].dims.length;r++)(e.indexOf(r)>=0||0===e.length)&&(n*=t[0].dims[r]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${n}.;`]})),e.reduceMax=(t,e,n)=>s(t,e,n,"ReduceMax",((t,e)=>{const n=[];for(let r=0;r<t[0].dims.length;r++)(e.indexOf(r)>=0||0===e.length)&&n.push(`inputIdx[${r}] = 0;`);return[`${n.join("\n")}\nvalue = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]})),e.reduceMin=(t,e,n)=>s(t,e,n,"ReduceMin",((t,e)=>{const n=[];for(let r=0;r<t[0].dims.length;r++)(e.indexOf(r)>=0||0===e.length)&&n.push(`inputIdx[${r}] = 0;`);return[`${n.join("\n")}\nvalue = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]})),e.reduceProd=(t,e,n)=>s(t,e,n,"ReduceProd",(()=>["value = 1.0;","value *= _A(inputIdx);",""])),e.reduceLogSum=(t,e,n)=>s(t,e,n,"ReduceLogSum",(()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"])),e.reduceLogSumSquare=(t,e,n)=>s(t,e,n,"ReduceLogSumSquare",(()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""]))},7019:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isReshapeCheap=e.processDims3D=e.createPackedReshape3DProgramInfoLoader=void 0;const r=n(2517),i=n(5060),o=n(2039),a=n(2827);e.createPackedReshape3DProgramInfoLoader=(t,e,n)=>{const s=(t=>({name:"Reshape (packed)",inputTypes:[o.TextureType.packed],inputNames:["A"],cacheHint:`${t}`}))(n);return Object.assign(Object.assign({},s),{get:()=>((t,e,n,s)=>{const u=e.dims,c=s;let l="";for(let t=0;t<4;t++){let e="";switch(t){case 0:e="outputCoords = rc;";break;case 1:e="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:e="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:e="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}l+=`\n        ${e}\n        ${t>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${t}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${t>0?"}":""}\n      `}const p=(0,i.getGlsl)(t.session.backend.glContext.version),f=`\n      ${function(t){const e=r.ShapeUtil.computeStrides(t),n=["b","r","c"],i="index";return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${e.map(((t,r)=>`int ${n[r]} = ${i} / ${t}; ${r===e.length-1?`int ${n[r+1]} = ${i} - ${n[r]} * ${t}`:`index -= ${n[r]} * ${t}`};`)).join("")}\n      return ivec3(b, r, c);\n    }\n  `}(u)}\n      ${function(t){const e=r.ShapeUtil.computeStrides(t);return`\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${e[0]} + coords.z * ${e[1]} + coords.y;\n  }\n`}(c)}\n      ${(0,a.unpackFromChannel)()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${c[2]};\n        int cols = ${c[1]};\n\n        ${l}\n        ${p.output} = result;\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:c,type:e.type,textureType:o.TextureType.packed},shaderSource:f,hasMain:!0})})(t,e,s,n)})},e.processDims3D=function(t){if(0===t.length)return[1,1,1];let e=1;for(let n=0;n<t.length-2;++n)e*=t[n];return[e,t.length>1?t[t.length-2]:1,t[t.length-1]]},e.isReshapeCheap=function(t,e){let n=!1;return n=0===t.length||0===e.length||(t.length<2||e.length<2?t[t.length-1]===e[e.length-1]:t[t.length-1]===e[e.length-1]&&t[t.length-2]===e[e.length-2]),n}},718:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.reshape=void 0;const r=n(2517);e.reshape=(t,e)=>{const n=r.ShapeUtil.calculateReshapedDims(e[0].dims,e[1].integerData);return t.session.pack?[t.reshapePacked(e[0],n)]:[t.reshapeUnpacked(e[0],n)]}},2268:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseResizeAttributesV11=e.parseResizeAttributesV10=e.resize=void 0;const r=n(5060),i=n(2039),o=n(9390),a=n(2827),s=n(9793),u={name:"Resize",inputNames:["A"],inputTypes:[i.TextureType.packed]};e.resize=(t,e,n)=>((0,s.validateInputs)(e,n),[t.run(Object.assign(Object.assign({},u),{cacheHint:n.cacheKey,get:()=>c(t,e,n)}),e)]),e.parseResizeAttributesV10=t=>(0,s.parseUpsampleAttributes)(t,10),e.parseResizeAttributesV11=t=>(0,s.parseUpsampleAttributes)(t,11);const c=(t,e,n)=>{const s=(0,r.getGlsl)(t.session.backend.glContext.version),[c,p]=l(e,n);if(c.every((t=>1===t))&&"tf_crop_and_resize"!==n.coordinateTransformMode)return Object.assign(Object.assign({},u),{output:{dims:p,type:e[0].type,textureType:i.TextureType.packed},hasMain:!0,shaderSource:`void main() {\n                    vec4 v = ${s.texture2D}(X, TexCoords);\n                    ${s.output} = v;\n                }`});const f=p.length;if(f<2)throw new Error(`output dimension should be at least 2, but got ${f}`);const d=p[f-2],h=p[f-1],g=e[0].dims;if(f!==g.length)throw new Error(`output dimension should match input ${g.length}, but got ${f}`);const b=g[f-2],m=g[f-1],y=c[f-2],_=c[f-1];let v="";if("linear"!==n.mode)throw new Error(`resize (packed) does not support mode: '${n.mode}'`);switch(n.coordinateTransformMode){case"asymmetric":v="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";break;case"half_pixel":v="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";break;case"pytorch_half_pixel":v=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${h}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${d}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${h}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${d}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;break;case"align_corners":v=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${h}.0 - 1.0, ${d}.0 - 1.0, ${h}.0 - 1.0,\n                            ${d}.0 - 1.0);\n                        vec4 original = vec4(${m}.0 - 1.0, ${b}.0 - 1.0, ${m}.0 - 1.0,\n                            ${b}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n.coordinateTransformMode}'`)}const w=(0,o.getCoordsDataType)(f),x=`\n            const vec2 inputWH = vec2(${b}.0, ${m}.0);\n            const vec4 scaleWHWH = vec4(float(${y}), float(${_}), float(${y}), float(${_}));\n            ${(0,a.unpackFromChannel)()}\n            ${v}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${w} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${d-1};\n                bool hasNextCol = rc.z < ${h-1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${s.output} = vec4(newValue);\n            }\n        `;return Object.assign(Object.assign({},u),{output:{dims:p,type:e[0].type,textureType:i.TextureType.packed},hasMain:!0,shaderSource:x})},l=(t,e)=>{const n=t[0].dims;let r,i=e.scales;if(0===i.length){const o=t[e.scalesInputIdx];if(o&&0!==o.size){if(t[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");i=p(o,e.mode,e.isResize)}else{const o=t[e.sizesInputIdx];if(!o||0===o.size)throw new Error("Either scales or sizes MUST be provided as input.");r=Array.from(o.integerData),i=f(r,n,e.mode,e.isResize)}}else if(t[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const o=r||n.map(((t,e)=>Math.floor(t*i[e])));return[i,o]},p=(t,e,n)=>{const r=Array.from(t.floatData);return(0,s.scalesValidation)(r,e,n),r},f=(t,e,n,r)=>{const i=e.length,o=new Array(i);for(let n=0,r=i;n<r;n++)if(0===e[n]){if(0!==t[n])throw new Error("Input dim is zero but required output dim is non-zero.");o[n]=1}else o[n]=t[n]/e[n];return(0,s.scalesValidation)(o,n,r),o}},8117:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.shape=void 0;const r=n(9162);e.shape=(t,e)=>(i(e),[new r.Tensor([e[0].dims.length],"int32",void 0,void 0,new Int32Array(e[0].dims))]);const i=t=>{if(!t||1!==t.length)throw new Error("Shape requires 1 input.")}},2278:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.sliceV10=e.parseSliceAttributes=e.slice=void 0;const r=n(246),i=n(782),o=n(2517),a=n(2039),s={name:"Slice",inputNames:["A"],inputTypes:[a.TextureType.unpacked]};e.slice=(t,e,n)=>(c(e),[t.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>u(t,e[0],n)}),e)]),e.parseSliceAttributes=t=>{const e=t.attributes.getInts("starts"),n=t.attributes.getInts("ends"),i=t.attributes.getInts("axes",[]);return(0,r.createAttributeWithCacheKey)({starts:e,ends:n,axes:i})};const u=(t,e,n)=>{const r=0===n.axes.length?e.dims.slice(0).map(((t,e)=>e)):n.axes,i=o.ShapeUtil.normalizeAxes(r,e.dims.length),u=n.starts.map(((t,n)=>t>e.dims[i[n]]-1?e.dims[i[n]]:o.ShapeUtil.normalizeAxis(t,e.dims[i[n]]))),c=n.ends.map(((t,n)=>t>e.dims[i[n]]-1?e.dims[i[n]]:o.ShapeUtil.normalizeAxis(t,e.dims[i[n]]))),l=e.dims.slice(),p=[];for(let t=0;t<i.length;t++)l[i[t]]=c[t]-u[t],u[t]>0&&p.push(`outputIdx[${i[t]}] += ${u[t]};`);const f=`\n      float process(int outputIdx[${l.length}]) {\n        ${p.join("\n      ")}\n        return _A(outputIdx);\n      }`;return Object.assign(Object.assign({},s),{output:{dims:l,type:e.type,textureType:a.TextureType.unpacked},shaderSource:f})},c=t=>{if(!t||1!==t.length)throw new Error("Slice requires 1 input.");if(-1===i.NUMBER_TYPES.indexOf(t[0].type))throw new Error("Invalid input type.")};e.sliceV10=(t,e)=>{p(e);const n=l(t,e);return[t.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>u(t,e[0],n)}),[e[0]])]};const l=(t,e)=>{if(!t.session.isInitializer(e[1].dataId)||!t.session.isInitializer(e[2].dataId)||e.length>=4&&!t.session.isInitializer(e[3].dataId)||e.length>=5&&!t.session.isInitializer(e[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(e.length>=5&&e[4].integerData.some((t=>1!==t)))throw new Error("currently non-1 steps is not supported for Slice");const n=Array.from(e[1].integerData),r=Array.from(e[2].integerData),i=e.length>=4?Array.from(e[3].integerData):[];return{starts:n,ends:r,axes:i,cacheKey:`${i};${n};${r}`}},p=t=>{if(!t||t.length<3||t.length>5)throw new Error("Invalid input number.");if("int32"!==t[1].type||1!==t[1].dims.length)throw new Error("Invalid input type.");if("int32"!==t[2].type||1!==t[2].dims.length)throw new Error("Invalid input type.");if(t.length>=4&&("int32"!==t[3].type||1!==t[3].dims.length))throw new Error("Invalid input type.");if(t.length>=5&&("int32"!==t[4].type||1!==t[4].dims.length))throw new Error("Invalid input type.")}},5524:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.softmaxV13=e.parseSoftmaxAttributesV13=e.parseSoftmaxAttributes=e.softmax=void 0;const r=n(246),i=n(2517),o=n(5060),a=n(2039),s=n(3738),u={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[a.TextureType.unpacked]},c={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked]},l={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]};e.softmax=(t,e,n)=>{g(e);const r=e[0].dims.slice(),o=i.ShapeUtil.normalizeAxis(n.axis,r.length),a=i.ShapeUtil.sizeToDimension(r,o),s=i.ShapeUtil.sizeFromDimension(r,o);return p(t,e,n,a,s)},e.parseSoftmaxAttributes=t=>(0,r.createAttributeWithCacheKey)({axis:t.attributes.getInt("axis",1)}),e.parseSoftmaxAttributesV13=t=>(0,r.createAttributeWithCacheKey)({axis:t.attributes.getInt("axis",-1)}),e.softmaxV13=(t,e,n)=>{g(e);const o=e[0].dims.slice(),a=i.ShapeUtil.normalizeAxis(n.axis,o.length),u=o.length,c=a!==u-1,l=[];let f,d=[],h=[];c&&(d=Array.from({length:u}).map(((t,e)=>e)),d[a]=u-1,d[u-1]=a,d.map((t=>l.push(o[t]))),f=(0,r.createAttributeWithCacheKey)({perm:d}),h=(0,s.transpose)(t,e,f));const b=c?i.ShapeUtil.sizeToDimension(l,u-1):i.ShapeUtil.sizeToDimension(o,u-1),m=c?i.ShapeUtil.sizeFromDimension(l,u-1):i.ShapeUtil.sizeFromDimension(o,u-1),y=p(t,c?h:e,n,b,m);return c?(0,s.transpose)(t,y,f):y};const p=(t,e,n,r,i)=>{const o=f(t,e[0],r,i,[r]),a=t.run(Object.assign(Object.assign({},u),{cacheHint:n.cacheKey,get:()=>o}),e),s=d(t,e[0],r,i,o.output.dims,[r]),p=t.run(Object.assign(Object.assign({},c),{cacheHint:n.cacheKey,get:()=>s}),[e[0],a]),g=h(t,e[0],r,i,o.output.dims,s.output.dims);return[t.run(Object.assign(Object.assign({},l),{cacheHint:n.cacheKey,get:()=>g}),[e[0],a,p])]},f=(t,e,n,r,i)=>{const[s,c]=t.calculateTextureWidthAndHeight(e.dims,a.TextureType.unpacked),l=i.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==i.length)throw new Error("Dimensionality of the output should be 1");if(i[0]!==n)throw new Error("Shape of the output should be equal to logical row count");const p=(0,o.getGlsl)(t.session.backend.glContext.version),f=`\n      float process(int[${l}] indices) {\n        int logical_row_start_offset = indices[0] * ${r};\n\n        float max = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s},\n        ${c} )));\n        for(int i=1; i<${r}; ++i)\n        {\n          float current = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${s}, ${c})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;return Object.assign(Object.assign({},u),{output:{dims:i,type:e.type,textureType:a.TextureType.unpacked},shaderSource:f})},d=(t,e,n,r,i,s)=>{const[u,l]=t.calculateTextureWidthAndHeight(e.dims,a.TextureType.unpacked),p=s.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==s.length)throw new Error("Dimensionality of the output should be 1");if(s[0]!==n)throw new Error("Shape of the output should be equal to logical row count");if(1!==i.length)throw new Error("Dimensionality of the intermediate results should be 1");if(i[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");const f=`\n      float process(int[${p}] indices) {\n        int logical_row_start_offset = indices[0] * ${r};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${r}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${(0,o.getGlsl)(t.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${u}, ${l}))) - max);\n        }\n\n        return norm_factor;\n      }`;return Object.assign(Object.assign({},c),{output:{dims:s,type:e.type,textureType:a.TextureType.unpacked},shaderSource:f})},h=(t,e,n,r,i,o)=>{const[s,u]=t.calculateTextureWidthAndHeight(e.dims,a.TextureType.unpacked),c=e.dims.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==i.length||1!==o.length)throw new Error("Dimensionality of the intermediate results should be 1");if(i[0]!==n||o[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");const p=`\n      float process(int[${c}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${s}, ${u});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${r};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;return Object.assign(Object.assign({},l),{output:{dims:e.dims,type:e.type,textureType:a.TextureType.unpacked},shaderSource:p})},g=t=>{if(!t||1!==t.length)throw new Error("Softmax requires 1 input.");if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("Invalid input type")}},5975:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseSplitAttributes=e.split=void 0;const r=n(246),i=n(2517),o=n(2039),a={name:"Split",inputNames:["A"],inputTypes:[o.TextureType.unpacked]};e.split=(t,e,n)=>{c(e);const r=i.ShapeUtil.normalizeAxis(n.axis,e[0].dims.length),o=s(t,e,r,n),l=[];for(let i=0;i<o;++i)l.push(t.run(Object.assign(Object.assign({},a),{cacheHint:`${n.cacheKey};${i}`,get:()=>u(t,e[0],n,r,i)}),e));return l},e.parseSplitAttributes=t=>{const e=t.attributes.getInt("axis",0),n=t.attributes.getInts("split",[]),i=t.outputs.length;return(0,r.createAttributeWithCacheKey)({axis:e,split:n,numOutputs:i})};const s=(t,e,n,r)=>{const[,o]=i.SplitUtil.splitShape(e[0].dims,n,r.split,r.numOutputs);return o.length},u=(t,e,n,r,s)=>{const[u,c]=i.SplitUtil.splitShape(e.dims,r,n.split,n.numOutputs),l=c[s],p=u[s],f=`\n      float process(int indices[${p.length}]) {\n        indices[${r}] += ${l};\n        return _A(indices);\n      }\n    `;return Object.assign(Object.assign({},a),{cacheHint:`${n.cacheKey}:${s}`,output:{dims:p,type:e.type,textureType:o.TextureType.unpacked},shaderSource:f})},c=t=>{if(!t||1!==t.length)throw new Error("Split requires one input.");if("int8"!==t[0].type&&"uint8"!==t[0].type&&"int16"!==t[0].type&&"uint16"!==t[0].type&&"int32"!==t[0].type&&"uint32"!==t[0].type&&"float32"!==t[0].type&&"float64"!==t[0].type&&"bool"!==t[0].type)throw new Error("Invalid input type.")}},3933:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseSqueezeAttributes=e.squeezeV13=e.squeeze=void 0;const r=n(2517);e.squeeze=(t,e,n)=>{i(e);const o=r.ShapeUtil.squeezeShape(e[0].dims,n);return[t.reshapeUnpacked(e[0],o)]},e.squeezeV13=(t,n)=>(o(n),(0,e.squeeze)(t,[n[0]],Array.from(n[1].integerData))),e.parseSqueezeAttributes=t=>t.attributes.getInts("axes");const i=t=>{if(!t||1!==t.length)throw new Error("Squeeze requires 1 input.");if("string"===t[0].type)throw new Error("invalid input tensor types.")},o=t=>{if(!t||2!==t.length)throw new Error("Squeeze requires 2 inputs.");if("int32"!==t[1].type)throw new Error("Invalid input type.")}},6558:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.sum=void 0;const r=n(5060),i=n(2039);e.sum=(t,e)=>{a(e);const n={name:"Sum",inputNames:e.map(((t,e)=>`X${e}`)),inputTypes:new Array(e.length).fill(i.TextureType.unpacked)};return[t.run(Object.assign(Object.assign({},n),{get:()=>o(t,e,n)}),e)]};const o=(t,e,n)=>{const o=(0,r.getGlsl)(t.session.backend.glContext.version),a=e[0].dims.slice(),s=`\n      void main() {\n        vec4 result = ${e.map(((t,e)=>`${o.texture2D}(X${e},TexCoords)`)).join(" + ")};\n        ${o.output} = result;\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:a,type:e[0].type,textureType:i.TextureType.unpacked},hasMain:!0,shaderSource:s})},a=t=>{if(!t||0===t.length)throw new Error("Sum requires inputs.");const e=t[0].dims.length;for(let n=1;n<t.length;n++){if(e!==t[n].dims.length)throw new Error("Input shapes are mismatched.");for(let r=0;r<e;r++)if(t[0].dims[r]!==t[n].dims[r])throw new Error("Input shapes are not matched.")}if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("Invalid input type.");for(let e=1;e<t.length;e++)if(t[0].type!==t[e].type)throw new Error("Input types are not matched.")}},5723:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.tile=void 0;const r=n(782),i=n(2039);e.tile=(t,e)=>{a(e);const n={name:"Tile",inputNames:["A"],inputTypes:[i.TextureType.unpacked]};return[t.run(Object.assign(Object.assign({},n),{get:()=>o(t,e,n)}),e)]};const o=(t,e,n)=>{const r=e[0].dims.slice(),o=new Array(r.length),a=[];for(let t=0;t<r.length;t++)o[t]=r[t]*e[1].numberData[t],a.push(`inputIdx[${t}] = int(mod(float(outputIdx[${t}]), ${r[t]}.));`);const s=o.length,u=`\n      float process(int outputIdx[${s}]) {\n        int inputIdx[${s}];\n        ${a.join("\n")}\n        return _A(inputIdx);\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:o,type:e[0].type,textureType:i.TextureType.unpacked},shaderSource:u})},a=t=>{if(!t||2!==t.length)throw new Error("Tile requires 2 input.");if(1!==t[1].dims.length)throw new Error("The second input shape must 1 dimension.");if(t[1].dims[0]!==t[0].dims.length)throw new Error("Invalid input shape.");if(-1===r.NUMBER_TYPES.indexOf(t[0].type))throw new Error("Invalid input type.");if("int32"!==t[1].type&&"int16"!==t[1].type)throw new Error("Invalid repeat type.")}},3738:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseTransposeAttributes=e.transpose=void 0;const r=n(246),i=n(2517),o=n(2039),a={name:"Transpose",inputNames:["A"],inputTypes:[o.TextureType.unpacked]};e.transpose=(t,e,n)=>(p(e),[t.run(Object.assign(Object.assign({},a),{cacheHint:n.cacheKey,get:()=>s(t,e[0],n.perm)}),e)]),e.parseTransposeAttributes=t=>(0,r.createAttributeWithCacheKey)({perm:t.attributes.getInts("perm",[])});const s=(t,e,n)=>{const r=e.dims;n=u(r,n);const i=c(r,n),s=r.length,p=`\n      ${l("perm",n,s)}\n      float process(int indices[${s}]) {\n        int a[${s}];\n        perm(a, indices);\n        return _A(a);\n      }`;return Object.assign(Object.assign({},a),{output:{dims:i,type:e.type,textureType:o.TextureType.unpacked},shaderSource:p})},u=(t,e)=>(e&&e.length!==t.length&&(e=[...t.keys()].reverse()),e),c=(t,e)=>(e=u(t,e),i.ShapeUtil.sortBasedOnPerm(t,e)),l=(t,e,n)=>{const r=[];r.push(`void ${t}(out int a[${n}], int src[${n}]) {`);for(let t=0;t<n;++t)r.push(`\ta[${e[t]}]=src[${t}];`);return r.push("\t}"),r.join("\n")},p=t=>{if(!t||1!==t.length)throw new Error("Transpose requires 1 input.");if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("input should be float tensor")}},8710:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.encodeAsUint8=void 0;const r=n(5060),i=n(2039);e.encodeAsUint8=(t,e)=>{const n=e.shape,o=(0,r.getGlsl)(t.session.backend.glContext.version),a=`\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${o.texture2D}(X,TexCoords).r;\n      ${o.output} = encodeAsUint8(value);\n    }`,s={name:"Uint8Encode",inputTypes:[i.TextureType.unpacked],inputNames:["X"],output:{dims:n,type:e.tensor.type,textureType:i.TextureType.downloadUint8AsFloat},shaderSource:a,hasMain:!0};return t.executeProgram(s,[e.tensor])}},4909:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.tanh=e.tan=e.sqrt=e.sin=e.sigmoid=e.relu=e.not=e.neg=e.log=e.parseLeakyReluAttributes=e.leakyRelu=e.identity=e.floor=e.exp=e.parseEluAttributes=e.elu=e.cos=e.ceil=e.clipV11=e.parseClipAttributes=e.clip=e.atan=e.asin=e.acos=e.abs=e.glslTanh=e.glslTan=e.glslSqrt=e.glslSigmoid=e.glslRelu=e.glslSin=e.glslNot=e.glslNeg=e.glslLog=e.glslLeakyRelu=e.glslIdentity=e.glslClip=e.glslFloor=e.glslExp=e.glslElu=e.glslCos=e.glslCeil=e.glslAtan=e.glslAsin=e.glslAcos=e.glslAbs=void 0;const r=n(246),i=n(2517),o=n(8520),a=n(5060),s=n(2039);function u(){return P("abs")}function c(){return P("acos")}function l(){return P("asin")}function p(){return P("atan")}function f(){return P("ceil")}function d(){return P("cos")}function h(t){const e="elu";return{body:`\n  const float alpha = float(${t});\n\n  float ${e}_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 ${e}_(vec4 v) {\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function g(){return P("exp")}function b(){return P("floor")}function m(t,e){const n="clip";return{body:`\n  const float min = float(${t});\n  const float max = float(${e});\n\n  float ${n}_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 ${n}_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `,name:n,type:o.FunctionType.ValueBased}}function y(){const t="indentity";return{body:`\n  float ${t}_(float a) {\n    return a;\n  }\n  vec4 ${t}_(vec4 v) {\n    return v;\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}function _(t){const e="leakyRelu";return{body:`\n  const float alpha = float(${t});\n\n  float ${e}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function v(){return P("log")}function w(){const t="neg";return{body:`\n  float ${t}_(float a) {\n    return -a;\n  }\n  vec4 ${t}_(vec4 v) {\n    return -v;\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}function x(){const t="not";return{body:`\n  float ${t}_(float a) {\n    return float( ! bool(a) );\n  }\n  bool ${t}_(bool a) {\n    return !a;\n  }\n  vec4 ${t}_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 ${t}_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}function T(){return P("sin")}function S(){const t="relu";return{body:`\n  float ${t}_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 ${t}_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}function O(){const t="sigmoid";return{body:`\n  float ${t}_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 ${t}_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}function A(){return P("sqrt")}function E(){return P("tan")}function I(){const t="tanh";return{body:`\n  float ${t}_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 ${t}_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}function P(t){return{body:`\n  float ${t}_(float a) {\n    return ${t}(a);\n  }\n  vec4 ${t}_(vec4 v) {\n    return ${t}(v);\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}e.glslAbs=u,e.glslAcos=c,e.glslAsin=l,e.glslAtan=p,e.glslCeil=f,e.glslCos=d,e.glslElu=h,e.glslExp=g,e.glslFloor=b,e.glslClip=m,e.glslIdentity=y,e.glslLeakyRelu=_,e.glslLog=v,e.glslNeg=w,e.glslNot=x,e.glslSin=T,e.glslRelu=S,e.glslSigmoid=O,e.glslSqrt=A,e.glslTan=E,e.glslTanh=I;const D=(t,e,n,r)=>{const i=t.session.pack?s.TextureType.packed:s.TextureType.unpacked,o={name:n.name,inputTypes:[i],inputNames:["A"],cacheHint:r};return Object.assign(Object.assign({},o),{get:()=>((t,e,n,r)=>{const i=t.session.pack?s.TextureType.packed:s.TextureType.unpacked,o=(0,a.getGlsl)(t.session.backend.glContext.version);return Object.assign(Object.assign({},e),{output:{dims:n.dims,type:n.type,textureType:i},shaderSource:`\n     ${r.body}\n     void main() {\n       vec4 v = ${o.texture2D}(A, TexCoords);\n       v = ${r.name}_(v);\n       ${o.output} = v;\n     }\n     `,hasMain:!0})})(t,o,e,n)})};e.abs=(t,e)=>[t.run(D(t,e[0],u()),e)],e.acos=(t,e)=>[t.run(D(t,e[0],c()),e)],e.asin=(t,e)=>[t.run(D(t,e[0],l()),e)],e.atan=(t,e)=>[t.run(D(t,e[0],p()),e)],e.clip=(t,e,n)=>[t.run(D(t,e[0],m(n.min,n.max),n.cacheKey),e)],e.parseClipAttributes=t=>(0,r.createAttributeWithCacheKey)({min:t.attributes.getFloat("min",i.MIN_CLIP),max:t.attributes.getFloat("max",i.MAX_CLIP)}),e.clipV11=(t,n)=>{const r=$(t,n);return(0,e.clip)(t,[n[0]],r)};const $=(t,e)=>{if(e.length>=3&&(!t.session.isInitializer(e[1].dataId)||!t.session.isInitializer(e[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const n=e.length>=3?e[1].numberData[0]:i.MIN_CLIP,o=e.length>=3?e[2].numberData[0]:i.MAX_CLIP;return(0,r.createAttributeWithCacheKey)({min:n,max:o})};e.ceil=(t,e)=>[t.run(D(t,e[0],f()),e)],e.cos=(t,e)=>[t.run(D(t,e[0],d()),e)],e.elu=(t,e,n)=>[t.run(D(t,e[0],h(n.alpha),n.cacheKey),e)],e.parseEluAttributes=t=>(0,r.createAttributeWithCacheKey)({alpha:t.attributes.getFloat("alpha",1)}),e.exp=(t,e)=>[t.run(D(t,e[0],g()),e)],e.floor=(t,e)=>[t.run(D(t,e[0],b()),e)],e.identity=(t,e)=>[t.run(D(t,e[0],y()),e)],e.leakyRelu=(t,e,n)=>[t.run(D(t,e[0],_(n.alpha),n.cacheKey),e)],e.parseLeakyReluAttributes=t=>(0,r.createAttributeWithCacheKey)({alpha:t.attributes.getFloat("alpha",.01)}),e.log=(t,e)=>[t.run(D(t,e[0],v()),e)],e.neg=(t,e)=>[t.run(D(t,e[0],w()),e)],e.not=(t,e)=>[t.run(D(t,e[0],x()),e)],e.relu=(t,e)=>[t.run(D(t,e[0],S()),e)],e.sigmoid=(t,e)=>[t.run(D(t,e[0],O()),e)],e.sin=(t,e)=>[t.run(D(t,e[0],T()),e)],e.sqrt=(t,e)=>[t.run(D(t,e[0],A()),e)],e.tan=(t,e)=>[t.run(D(t,e[0],E()),e)],e.tanh=(t,e)=>[t.run(D(t,e[0],I()),e)]},5611:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createUnpackProgramInfoLoader=e.createUnpackProgramInfo=void 0;const r=n(5060),i=n(2039),o=n(9390),a=n(2827),s={name:"unpack",inputNames:["A"],inputTypes:[i.TextureType.packed]};e.createUnpackProgramInfo=(t,e)=>{const n=e.dims.length,u=(0,a.getChannels)("rc",n),c=u.slice(-2),l=(0,o.getCoordsDataType)(n),p=(0,a.unpackFromChannel)(),f=0===e.dims.length?"":function(t,e){if(1===t)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}(n,u),d=n<=1?"rc":`vec2(${c.join(",")})`,h=`\n    ${p}\n    void main() {\n      ${l} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${f});\n\n       ${(0,r.getGlsl)(t.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${d}), 0, 0, 0);\n     }\n   `;return Object.assign(Object.assign({},s),{hasMain:!0,output:{dims:e.dims,type:e.type,textureType:i.TextureType.unpacked},shaderSource:h})},e.createUnpackProgramInfoLoader=(t,n)=>Object.assign(Object.assign({},s),{get:()=>(0,e.createUnpackProgramInfo)(t,n)})},8428:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseUnsqueezeAttributes=e.unsqueezeV13=e.unsqueeze=void 0;const r=n(2517);e.unsqueeze=(t,e,n)=>{i(e);const o=r.ShapeUtil.unsqueezeShape(e[0].dims,n);return[t.reshapeUnpacked(e[0],o)]},e.unsqueezeV13=(t,n)=>(o(n),(0,e.unsqueeze)(t,[n[0]],Array.from(n[1].integerData))),e.parseUnsqueezeAttributes=t=>t.attributes.getInts("axes");const i=t=>{if(!t||1!==t.length)throw new Error("Unsqueeze requires 1 input.");if("string"===t[0].type)throw new Error("invalid input tensor types.")},o=t=>{if(!t||2!==t.length)throw new Error("Unsqueeze requires 2 inputs.");if("int32"!==t[1].type)throw new Error("Invalid input type.")}},9793:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.scalesValidation=e.validateInputs=e.parseUpsampleAttributes=e.parseUpsampleAttributesV9=e.parseUpsampleAttributesV7=e.upsample=void 0;const r=n(246),i=n(5060),o=n(2039),a={name:"Upsample",inputNames:["X"],inputTypes:[o.TextureType.unpacked]};e.upsample=(t,n,r)=>((0,e.validateInputs)(n,r),[t.run(Object.assign(Object.assign({},a),{cacheHint:r.cacheKey,get:()=>s(t,n,r)}),n)]),e.parseUpsampleAttributesV7=t=>(0,e.parseUpsampleAttributes)(t,7),e.parseUpsampleAttributesV9=t=>(0,e.parseUpsampleAttributes)(t,9),e.parseUpsampleAttributes=(t,n)=>{const i=n>=10,o=t.attributes.getString("mode","nearest");if("nearest"!==o&&"linear"!==o&&(n<11||"cubic"!==o))throw new Error(`unrecognized mode: ${o}`);let a=[];n<9&&(a=t.attributes.getFloats("scales"),(0,e.scalesValidation)(a,o,i));const s=t.attributes.getFloat("extrapolation_value",0),u=n>10?t.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(-1===["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(u))throw new Error(`coordinate_transform_mode '${u}' is not supported`);const c="tf_crop_and_resize"===u,l=c,p="nearest"===o&&n>=11?t.attributes.getString("nearest_mode","round_prefer_floor"):"";if(-1===["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(p))throw new Error(`nearest_mode '${p}' is not supported`);const f=t.attributes.getFloat("cubic_coeff_a",-.75),d=0!==t.attributes.getInt("exclude_outside",0);if(d&&"cubic"!==o)throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const h=n<11||"nearest"===o&&"asymmetric"===u&&"floor"===p;let g=0,b=0,m=0;return n>10?t.inputs.length>2?(g=1,b=2,m=3):(b=1,m=2):9===n&&(b=1),(0,r.createAttributeWithCacheKey)({opset:n,isResize:i,mode:o,scales:a,extrapolationValue:s,coordinateTransformMode:u,useExtrapolation:l,needRoiInput:c,nearestMode:p,cubicCoefficientA:f,excludeOutside:d,useNearest2xOptimization:h,roiInputIdx:g,scalesInputIdx:b,sizesInputIdx:m})};const s=(t,e,n)=>{const r=(0,i.getGlsl)(t.session.backend.glContext.version),[s,u]=t.calculateTextureWidthAndHeight(e[0].dims,o.TextureType.unpacked),c=e[0].dims.map(((t,e)=>Math.floor(t*n.scales[e]))),[l,p]=t.calculateTextureWidthAndHeight(c,o.TextureType.unpacked),f=c.length,d=new Array(f),h=new Array(f);let g=`\n      int output_pitches[${f}];\n      int input_pitches[${f}];\n      `;for(let t=f-1;t>=0;t--)d[t]=t===f-1?1:d[t+1]*c[t+1],h[t]=t===f-1?1:h[t+1]*e[0].dims[t+1],g+=`\n        output_pitches[${t}] = ${d[t]};\n        input_pitches[${t}] = ${h[t]};\n        `;const b=`\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${s}, ${u});\n        float value = getColorAsFloat(${r.texture2D}(X, coords));\n        return value;\n      }\n      `,m="nearest"===n.mode?`\n    ${b}\n    float process(int indices[${f}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\n\n      ${g}\n\n      int d, m;\n      for (int dim = 0; dim < ${f}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }`:4===f?`\n    ${b}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\n\n      ${g}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${e[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }`:`\n    ${b}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\n\n      ${g}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${e[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;return Object.assign(Object.assign({},a),{output:{dims:c,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:m,variables:[{name:"scales",type:"int",arrayLength:n.scales.length,data:n.scales.map((t=>Math.ceil(t)))}]})};e.validateInputs=(t,e)=>{if(!t||e.opset<9&&1!==t.length||e.opset>=9&&e.opset<11&&2!==t.length||e.opset>=11&&t.length<2)throw new Error("invalid inputs.");if(e.scales.length>0&&t[0].dims.length!==e.scales.length)throw new Error("Invalid input shape.");if("string"===t[0].type)throw new Error("Invalid input tensor types.")},e.scalesValidation=(t,e,n)=>{if(n){for(const e of t)if(e<=0)throw new Error("Scale value should be greater than 0.")}else for(const e of t)if(e<1)throw new Error("Scale value should be greater than or equal to 1.");if(!("linear"!==e&&"cubic"!==e||2===t.length||4===t.length&&1===t[0]&&1===t[1]))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n?"Resize":"Upsample"} opeartor.`)}},1958:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.ProgramManager=void 0;const r=n(1670),i=n(6231),o=n(8879),a=n(5060);e.ProgramManager=class{constructor(t,e,n){this.profiler=t,this.glContext=e,this.textureLayoutStrategy=n,this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,e){this.repo.set(t,e)}run(t,e,n){var r;this.profiler.event("op",`ProgramManager.run ${null!==(r=t.programInfo.name)&&void 0!==r?r:"unknown kernel"}`,(()=>{var r;const o=this.glContext.gl,a=t.program;o.useProgram(a);try{this.bindOutput(n),this.attributesBound||this.bindAttributes(t.attribLocations),this.bindUniforms(t.uniformLocations,null!==(r=t.programInfo.variables)&&void 0!==r?r:[],e)}catch(e){throw i.Logger.error("ProgramManager",t.programInfo.shaderSource),e}this.profiler.event("backend","GlContext.draw()",(()=>{this.glContext.draw()}))}),this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach((t=>this.glContext.deleteProgram(t.program)))}build(t,e,n){return this.profiler.event("backend","ProgramManager.build",(()=>{const r=new o.GlslPreprocessor(this.glContext,t,e,n),i=r.preprocess(),a=this.compile(i);return{programInfo:t,program:a,uniformLocations:this.getUniformLocations(a,r.context.programInfo.inputNames,r.context.programInfo.variables),attribLocations:this.getAttribLocations(a)}}))}compile(t){if(!this.vertexShader){i.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const t=(0,a.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(t,this.glContext.gl.VERTEX_SHADER)}r.env.debug&&i.Logger.verbose("ProrgramManager",`FragShader:\n${t}\n`);const e=this.glContext.compileShader(t,this.glContext.gl.FRAGMENT_SHADER),n=this.glContext.createProgram(this.vertexShader,e);return this.glContext.deleteShader(e),n}bindOutput(t){const e=t.width,n=t.height;i.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${e}/${n}, shape=${t.shape}, type=${t.tensor.type}`),this.glContext.attachFramebuffer(t.texture,e,n)}bindAttributes(t){const e=t.position,n=t.textureCoord;this.glContext.setVertexAttributes(e,n),this.attributesBound=!0}bindUniforms(t,e,n){var r;const i=this.glContext.gl;let o=0;for(const{name:a,type:s,location:u,arrayLength:c}of t){const t=null===(r=e.find((t=>t.name===a)))||void 0===r?void 0:r.data;if("sampler2D"!==s&&!t)throw new Error(`variable '${a}' does not have data defined in program info`);switch(s){case"sampler2D":this.bindTexture(n[o],u,o),o++;break;case"float":c?i.uniform1fv(u,t):i.uniform1f(u,t);break;case"int":c?i.uniform1iv(u,t):i.uniform1i(u,t);break;default:throw new Error(`Uniform not implemented: ${s}`)}}}bindTexture(t,e,n){this.glContext.bindTextureToUniform(t.texture,n,e)}getAttribLocations(t){return{position:this.getAttribLocation(t,"position"),textureCoord:this.getAttribLocation(t,"textureCoord")}}getUniformLocations(t,e,n){const r=[];if(e)for(const n of e)r.push({name:n,type:"sampler2D",location:this.getUniformLocation(t,n)});if(n)for(const e of n)r.push(Object.assign(Object.assign({},e),{location:this.getUniformLocation(t,e.name)}));return r}getUniformLocation(t,e){const n=this.glContext.gl.getUniformLocation(t,e);if(null===n)throw new Error(`Uniform ${e} not found.`);return n}getAttribLocation(t,e){return this.glContext.gl.getAttribLocation(t,e)}}},6416:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLSessionHandler=void 0;const r=n(6231),i=n(1047),o=n(8316),a=n(1640),s=n(1958),u=n(7859),c=n(5702);e.WebGLSessionHandler=class{constructor(t,e){this.backend=t,this.context=e,this.layoutStrategy=new u.PreferLogicalStrategy(t.glContext.maxTextureSize),this.programManager=new s.ProgramManager(this.context.profiler,t.glContext,this.layoutStrategy),this.textureManager=new c.TextureManager(t.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:"full"===t.textureCacheMode}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=t.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new o.WebGLInferenceHandler(this)}onGraphInitialized(t){const e=t.getValues().filter((t=>-1===t.from&&t.tensor)).map((t=>t.tensor.dataId));this.initializers=new Set(e)}isInitializer(t){return!!this.initializers&&this.initializers.has(t)}addInitializer(t){this.initializers.add(t)}getTextureData(t,e){return e?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,e,n=!1){r.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),n?this.packedTextureDataCache.set(t,e):this.unpackedTextureDataCache.set(t,e)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((t=>this.textureManager.releaseTexture(t,!0))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((t=>this.textureManager.releaseTexture(t,!0))),this.unpackedTextureDataCache=new Map}resolve(t,e,n){const r=(0,i.resolveOperator)(t,e,a.WEBGL_OP_RESOLVE_RULES);return{impl:r.opImpl,context:r.opInit?r.opInit(t,n):t}}}},7769:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Uint8DataEncoder=e.RGBAFloatDataEncoder=e.RedFloat32DataEncoder=void 0;const r=n(6231);e.RedFloat32DataEncoder=class{constructor(t,e=1){if(1===e)this.internalFormat=t.R32F,this.format=t.RED,this.textureType=t.FLOAT,this.channelSize=e;else{if(4!==e)throw new Error(`Invalid number of channels: ${e}`);this.internalFormat=t.RGBA32F,this.format=t.RGBA,this.textureType=t.FLOAT,this.channelSize=e}}encode(t,e){let n,i;return t.constructor!==Float32Array&&(r.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),i=new Float32Array(t)),e*this.channelSize>t.length?(r.Logger.warning("Encoder","Source data too small. Allocating larger array"),i=t,n=this.allocate(e*this.channelSize),i.forEach(((t,e)=>n[e]=t))):(i=t,n=i),n}allocate(t){return new Float32Array(4*t)}decode(t,e){return 1===this.channelSize?t.filter(((t,e)=>e%4==0)).subarray(0,e):t.subarray(0,e)}},e.RGBAFloatDataEncoder=class{constructor(t,e=1,n){if(1!==e&&4!==e)throw new Error(`Invalid number of channels: ${e}`);this.internalFormat=t.RGBA,this.format=t.RGBA,this.channelSize=e,this.textureType=n||t.FLOAT}encode(t,e){let n=t;return 1===this.channelSize&&(r.Logger.verbose("Encoder","Exploding into a larger array"),n=this.allocate(e),t.forEach(((t,e)=>n[4*e]=t))),n}allocate(t){return new Float32Array(4*t)}decode(t,e){return 1===this.channelSize?t.filter(((t,e)=>e%4==0)).subarray(0,e):t.subarray(0,e)}},e.Uint8DataEncoder=class{constructor(t,e=1){if(this.channelSize=4,1===e)this.internalFormat=t.ALPHA,this.format=t.ALPHA,this.textureType=t.UNSIGNED_BYTE,this.channelSize=e;else{if(4!==e)throw new Error(`Invalid number of channels: ${e}`);this.internalFormat=t.RGBA,this.format=t.RGBA,this.textureType=t.UNSIGNED_BYTE,this.channelSize=e}}encode(t,e){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}allocate(t){return new Uint8Array(t*this.channelSize)}decode(t,e){if(t instanceof Uint8Array)return t.subarray(0,e);throw new Error(`Invalid array type: ${t.constructor}`)}}},7859:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getBatchDim=e.sizeToSquarishShape=e.getRowsCols=e.sizeFromShape=e.isInt=e.parseAxisParam=e.squeezeShape=e.PreferLogicalStrategy=e.AlwaysKeepOriginalSizeStrategy=void 0;const r=n(6231),i=n(2517);function o(t,e){const n=[],r=[],i=null!=e&&Array.isArray(e)&&0===e.length,o=null==e||i?null:a(e,t).sort();let s=0;for(let e=0;e<t.length;++e){if(null!=o){if(o[s]===e&&1!==t[e])throw new Error(`Can't squeeze axis ${e} since its dim '${t[e]}' is not 1`);(null==o[s]||o[s]>e)&&1===t[e]&&(n.push(t[e]),r.push(e)),o[s]<=e&&s++}1!==t[e]&&(n.push(t[e]),r.push(e))}return{newShape:n,keptDims:r}}function a(t,e){const n=e.length;return t=null==t?e.map(((t,e)=>e)):[].concat(t),(0,i.assert)(t.every((t=>t>=-n&&t<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`)),(0,i.assert)(t.every(s),(()=>`All values in axis param must be integers but got axis ${t}`)),t.map((t=>t<0?n+t:t))}function s(t){return t%1==0}function u(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function c(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}e.AlwaysKeepOriginalSizeStrategy=class{constructor(t){this.maxTextureSize=t}computeTextureWH(t,e){if(0===t.length)return[1,1];const n=this.maxTextureSize;if(e&&void 0!==e.breakAxis){const i=e.breakAxis>=t.length?1:t.slice(e.breakAxis).reduce(((t,e)=>t*e)),o=e.breakAxis<=0?1:t.slice(0,e.breakAxis).reduce(((t,e)=>t*e));if(!(i>n||o>n))return[i,o];r.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${t}, breakAxis:${e.breakAxis}`)}const i=t.reduce(((t,e)=>t*e));let o=Math.floor(Math.sqrt(i));for(;o<n&&o<i&&i%o!=0;o++);if(o>=n||i%o!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${t}`);return[o,i/o]}},e.PreferLogicalStrategy=class{constructor(t){this.maxTextureSize=t}computeTextureWH(t,e){const n=this.computeTexture(t,e);return e&&e.isPacked&&(n[0]/=2,n[1]/=2),e&&e.reverseWH?[n[1],n[0]]:n}computeTexture(t,e){const n=e&&e.isPacked;if(0===t.length)return n?[2,2]:[1,1];let i=this.maxTextureSize;if(e&&void 0!==e.breakAxis){const n=e.breakAxis>=t.length?1:t.slice(e.breakAxis).reduce(((t,e)=>t*e)),o=e.breakAxis<=0?1:t.slice(0,e.breakAxis).reduce(((t,e)=>t*e));if(!(n>i||o>i))return[n,o];r.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${t}, breakAxis:${e.breakAxis}`)}let a=t.slice(0);if(n&&(i*=2,a=a.map(((t,e)=>e>=a.length-2?a[e]%2==0?a[e]:a[e]+1:a[e])),1===a.length&&(a=[2,a[0]])),2!==a.length){const t=o(a);a=t.newShape}const s=u(a);return a.length<=1&&s<=i?[1,s]:2===a.length&&a[0]<=i&&a[1]<=i?a:3===a.length&&a[0]*a[1]<=i&&a[2]<=i?[a[0]*a[1],a[2]]:3===a.length&&a[0]<=i&&a[1]*a[2]<=i?[a[0],a[1]*a[2]]:4===a.length&&a[0]*a[1]*a[2]<=i&&a[3]<=i?[a[0]*a[1]*a[2],a[3]]:4===a.length&&a[0]<=i&&a[1]*a[2]*a[3]<=i?[a[0],a[1]*a[2]*a[3]]:n?c(s/4).map((t=>2*t)):c(s)}},e.squeezeShape=o,e.parseAxisParam=a,e.isInt=s,e.sizeFromShape=u,e.getRowsCols=function(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]},e.sizeToSquarishShape=c,e.getBatchDim=function(t,e=2){return u(t.slice(0,t.length-e))}},4057:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createTextureLayoutFromShape=e.calculateTextureWidthAndHeight=e.createTextureLayoutFromTextureType=void 0;const r=n(2517),i=n(2039);e.createTextureLayoutFromTextureType=(t,n,r)=>{const o=r===i.TextureType.unpacked||r===i.TextureType.unpackedReversed?1:4,a=r===i.TextureType.packed,s=r===i.TextureType.unpackedReversed||r===i.TextureType.packed,u=r===i.TextureType.packedLastDimension?n.length-1:void 0,c=r===i.TextureType.packedLastDimension?n.map(((t,e)=>e===n.length-1?4*t:t)):void 0;return(0,e.createTextureLayoutFromShape)(t,n,o,c,{isPacked:a,reverseWH:s,breakAxis:u})},e.calculateTextureWidthAndHeight=(t,n,r)=>{const i=(0,e.createTextureLayoutFromTextureType)(t,n,r);return[i.width,i.height]},e.createTextureLayoutFromShape=(t,e,n=1,i,o)=>{const a=!(!o||!o.isPacked),[s,u]=t.computeTextureWH(a&&i||e,o),c=e.length;let l=e.slice(0);if(0===c&&(l=[1]),1===n)i=e;else if(a){if(4!==n)throw new Error("a packed texture must be 4-channel");i=e,c>0&&(l[c-1]=Math.ceil(l[c-1]/2)),c>1&&(l[c-2]=Math.ceil(l[c-2]/2))}else if(!i)throw new Error("Unpacked shape is needed when using channels > 1");return{width:s,height:u,channels:n,isPacked:a,shape:l,strides:r.ShapeUtil.computeStrides(l),unpackedShape:i,reversedWH:o&&o.reverseWH}}},5702:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.TextureManager=void 0;const r=n(6231);e.TextureManager=class{constructor(t,e,n,r){this.glContext=t,this.layoutStrategy=e,this.profiler=n,this.config=r,this.pendingRead=new Map,r.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(t,e,n,i){const o=this.toEncoderType(t),a=this.glContext.getEncoder(o,e.channels||1,i);if(e.isPacked&&1===i)throw new Error("not implemented");const s=e.width,u=e.height;let c,l;if(this.config.reuseTextures){c=`${s}x${u}_${a.format}_${a.internalFormat}_${a.textureType}`,l=this.inUseTextures.get(c),l||(l=[],this.inUseTextures.set(c,l));const e=this.idleTextures.get(c);if(e&&e.length>0){const r=e.pop();return l.push(r),1===i&&this.glContext.updateTexture(r,s,u,a,this.toTextureData(t,n)),r}}r.Logger.verbose("TextureManager",`Creating new texture of size ${e.width}x${e.height}`);const p=this.glContext.allocateTexture(s,u,a,this.toTextureData(t,n));return this.config.reuseTextures&&(l.push(p),this.textureLookup.set(p,c)),p}readTexture(t,e,n){return n||(n=1),this.profiler.event("backend","TextureManager.readTexture",(()=>{const r=t.shape.reduce(((t,e)=>t*e))*n,i=this.glContext.readTexture(t.texture,t.width,t.height,r,this.toEncoderType(e),n);return this.toTensorData(e,i)}))}async readTextureAsync(t,e,n){const r=t.tensor.dataId;if(n||(n=1),this.pendingRead.has(r)){const t=this.pendingRead.get(r);return new Promise((e=>null==t?void 0:t.push(e)))}return this.profiler.event("backend","TextureManager.readTextureAsync",(async()=>{this.pendingRead.set(r,[]);const i=t.shape.reduce(((t,e)=>t*e))*n;await this.glContext.createAndWaitForFence();const o=this.glContext.readTexture(t.texture,t.width,t.height,i,this.toEncoderType(e),n),a=this.toTensorData(e,o),s=this.pendingRead.get(r);return this.pendingRead.delete(r),null==s||s.forEach((t=>t(a))),a}))}readUint8TextureAsFloat(t){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",(()=>{const e=t.shape.reduce(((t,e)=>t*e)),n=this.glContext.readTexture(t.texture,t.width,t.height,4*e,"byte",4);return new Float32Array(n.buffer,n.byteOffset,e)}))}releaseTexture(t,e){let n;if(this.config.reuseTextures&&(n=this.textureLookup.get(t.texture),n)){e&&this.textureLookup.delete(n);const r=this.inUseTextures.get(n);if(r){const e=r.indexOf(t.texture);if(-1!==e){r.splice(e,1);let i=this.idleTextures.get(n);i||(i=[],this.idleTextures.set(n,i)),i.push(t.texture)}}}n&&!e||(r.Logger.verbose("TextureManager",`Deleting texture of size ${t.width}x${t.height}`),this.glContext.deleteTexture(t.texture))}toTensorData(t,e){switch(t){case"int16":return e instanceof Int16Array?e:Int16Array.from(e);case"int32":return e instanceof Int32Array?e:Int32Array.from(e);case"int8":return e instanceof Int8Array?e:Int8Array.from(e);case"uint16":return e instanceof Uint16Array?e:Uint16Array.from(e);case"uint32":return e instanceof Uint32Array?e:Uint32Array.from(e);case"uint8":case"bool":return e instanceof Uint8Array?e:Uint8Array.from(e);case"float32":return e instanceof Float32Array?e:Float32Array.from(e);case"float64":return e instanceof Float64Array?e:Float64Array.from(e);default:throw new Error(`TensorData type ${t} is not supported`)}}toTextureData(t,e){if(e)return e instanceof Float32Array?e:new Float32Array(e)}toEncoderType(t){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},2039:(t,e)=>{"use strict";var n;Object.defineProperty(e,"__esModule",{value:!0}),e.TextureType=void 0,(n=e.TextureType||(e.TextureType={}))[n.unpacked=0]="unpacked",n[n.unpackedReversed=1]="unpackedReversed",n[n.packed=2]="packed",n[n.downloadUint8AsFloat=3]="downloadUint8AsFloat",n[n.packedLastDimension=4]="packedLastDimension"},9390:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getGlChannels=e.getCoordsDataType=e.getSqueezedParams=e.squeezeInputShape=e.generateShaderFuncNameFromInputSamplerNameAtOutCoords=e.generateShaderFuncNameFromInputSamplerName=e.repeatedTry=e.getPackedShape=void 0;const r=n(2517);e.getPackedShape=function(t){const e=t.length;return t.slice(0,e-1).concat(t[e-1]/4)},e.repeatedTry=async function(t,e=(t=>0),n){return new Promise(((r,i)=>{let o=0;const a=()=>{if(t())return void r();o++;const s=e(o);null!=n&&o>=n?i():setTimeout(a,s)};a()}))},e.generateShaderFuncNameFromInputSamplerName=function(t){return(0,r.assert)(void 0!==t&&0!==t.length,(()=>"empty string found for sampler name")),"get"+t.charAt(0).toUpperCase()+t.slice(1)},e.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(t){return(0,r.assert)(void 0!==t&&0!==t.length,(()=>"empty string found for sampler name")),"get"+t.charAt(0).toUpperCase()+t.slice(1)+"AtOutCoords"},e.squeezeInputShape=function(t,e){let n=JSON.parse(JSON.stringify(t));return n=e,n},e.getSqueezedParams=function(t,e){return e.map((e=>t[e])).join(", ")},e.getCoordsDataType=function(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)},e.getGlChannels=function(t=6){return["x","y","z","w","u","v"].slice(0,t)}},7305:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createNewWebGLContext=e.createWebGLContext=void 0;const r=n(6231),i=n(1713),o={};function a(t){const e=function(){if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas)throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const t=document.createElement("canvas");return t.width=1,t.height=1,t}();let n;const o={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!t||"webgl2"===t)&&(n=e.getContext("webgl2",o),n))try{return new i.WebGLContext(n,2)}catch(t){r.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${t}`)}if((!t||"webgl"===t)&&(n=e.getContext("webgl",o)||e.getContext("experimental-webgl",o),n))try{return new i.WebGLContext(n,1)}catch(t){r.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${t}`)}throw new Error("WebGL is not supported")}e.createWebGLContext=function t(e){let n;e&&"webgl2"!==e||!("webgl2"in o)?e&&"webgl"!==e||!("webgl"in o)||(n=o.webgl):n=o.webgl2,n=n||a(e),e=e||1===n.version?"webgl":"webgl2";const r=n.gl;return o[e]=n,r.isContextLost()?(delete o[e],t(e)):(r.disable(r.DEPTH_TEST),r.disable(r.STENCIL_TEST),r.disable(r.BLEND),r.disable(r.DITHER),r.disable(r.POLYGON_OFFSET_FILL),r.disable(r.SAMPLE_COVERAGE),r.enable(r.SCISSOR_TEST),r.enable(r.CULL_FACE),r.cullFace(r.BACK),n)},e.createNewWebGLContext=a},1713:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return i(e,t),e};Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLContext=e.linearSearchLastTrue=void 0;const a=n(1670),s=o(n(7769)),u=n(9390);function c(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}e.linearSearchLastTrue=c,e.WebGLContext=class{constructor(t,e){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=t,this.version=e,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(t,e,n,r){const i=this.gl,o=i.createTexture();i.bindTexture(i.TEXTURE_2D,o),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE);const a=r?n.encode(r,t*e):null;return i.texImage2D(i.TEXTURE_2D,0,n.internalFormat,t,e,0,n.format,n.textureType,a),this.checkError(),o}updateTexture(t,e,n,r,i){const o=this.gl;o.bindTexture(o.TEXTURE_2D,t);const a=r.encode(i,e*n);o.texSubImage2D(o.TEXTURE_2D,0,0,0,e,n,r.format,r.textureType,a),this.checkError()}attachFramebuffer(t,e,n){const r=this.gl;r.bindTexture(r.TEXTURE_2D,t),r.bindFramebuffer(r.FRAMEBUFFER,this.framebuffer),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0),this.checkError(),r.viewport(0,0,e,n),r.scissor(0,0,e,n)}readTexture(t,e,n,r,i,o){const a=this.gl;o||(o=1),this.frameBufferBound||this.attachFramebuffer(t,e,n);const s=this.getEncoder(i,o),u=s.allocate(e*n);return a.bindTexture(a.TEXTURE_2D,t),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,t,0),a.readPixels(0,0,e,n,a.RGBA,s.textureType,u),this.checkError(),s.decode(u,r)}isFramebufferReady(){return!0}getActiveTexture(){const t=this.gl;return"TEXTURE"+(t.getParameter(this.gl.ACTIVE_TEXTURE)-t.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(t,e){const n=this.gl;n.vertexAttribPointer(t,3,n.FLOAT,!1,20,0),n.enableVertexAttribArray(t),-1!==e&&(n.vertexAttribPointer(e,2,n.FLOAT,!1,20,12),n.enableVertexAttribArray(e)),this.checkError()}createProgram(t,e){const n=this.gl,r=n.createProgram();return n.attachShader(r,t),n.attachShader(r,e),n.linkProgram(r),r}compileShader(t,e){const n=this.gl,r=n.createShader(e);if(!r)throw new Error(`createShader() returned null with type ${e}`);if(n.shaderSource(r,t),n.compileShader(r),!1===n.getShaderParameter(r,n.COMPILE_STATUS))throw new Error(`Failed to compile shader: ${n.getShaderInfoLog(r)}\nShader source:\n${t}`);return r}deleteShader(t){this.gl.deleteShader(t)}bindTextureToUniform(t,e,n){const r=this.gl;r.activeTexture(r.TEXTURE0+e),this.checkError(),r.bindTexture(r.TEXTURE_2D,t),this.checkError(),r.uniform1i(n,e),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(a.env.debug){const t=this.gl,e=t.getError();let n="";switch(e){case t.NO_ERROR:return;case t.INVALID_ENUM:n="INVALID_ENUM";break;case t.INVALID_VALUE:n="INVALID_VALUE";break;case t.INVALID_OPERATION:n="INVALID_OPERATION";break;case t.INVALID_FRAMEBUFFER_OPERATION:n="INVALID_FRAMEBUFFER_OPERATION";break;case t.OUT_OF_MEMORY:n="OUT_OF_MEMORY";break;case t.CONTEXT_LOST_WEBGL:n="CONTEXT_LOST_WEBGL";break;default:n=`Unknown WebGL Error: ${e.toString(16)}`}throw new Error(n)}}deleteTexture(t){this.gl.deleteTexture(t)}deleteProgram(t){this.gl.deleteProgram(t)}getEncoder(t,e,n=0){if(2===this.version)return new s.RedFloat32DataEncoder(this.gl,e);switch(t){case"float":return 1===n||this.isRenderFloat32Supported?new s.RGBAFloatDataEncoder(this.gl,e):new s.RGBAFloatDataEncoder(this.gl,e,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new s.Uint8DataEncoder(this.gl,e);default:throw new Error(`Invalid dataType: ${t}`)}}clearActiveTextures(){const t=this.gl;for(let e=0;e<this.maxTextureImageUnits;++e)t.activeTexture(t.TEXTURE0+e),t.bindTexture(t.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(this.framebuffer),t.bindBuffer(t.ARRAY_BUFFER,null),t.deleteBuffer(this.vertexbuffer),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const t=this.gl,e=t.createBuffer();if(!e)throw new Error("createBuffer() returned null");const n=this.createDefaultGeometry();return t.bindBuffer(t.ARRAY_BUFFER,e),t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW),this.checkError(),e}createFramebuffer(){const t=this.gl.createFramebuffer();if(!t)throw new Error("createFramebuffer returned null");return t}queryVitalParameters(){const t=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),1===this.version&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=t.getParameter(t.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){2===this.version?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const t=this.gl,e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e);const n=2===this.version?t.RGBA32F:t.RGBA;t.texImage2D(t.TEXTURE_2D,0,n,1,1,0,t.RGBA,t.FLOAT,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(e),t.deleteFramebuffer(r),i}checkRenderFloat32(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else{if(!this.textureFloatExtension)return!1;if(!this.gl.getExtension("WEBGL_color_buffer_float"))return!1}return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const t=this.gl;let e,n,r,i,o;try{e=t.createTexture(),n=t.createFramebuffer(),t.bindTexture(t.TEXTURE_2D,e);const a=2===this.version?t.RGBA32F:t.RGBA;return t.texImage2D(t.TEXTURE_2D,0,a,1,1,0,t.RGBA,t.FLOAT,null),t.bindFramebuffer(t.FRAMEBUFFER,n),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0),t.enable(t.BLEND),r=t.createShader(t.VERTEX_SHADER),!!r&&(t.shaderSource(r,"void main(){}"),t.compileShader(r),i=t.createShader(t.FRAGMENT_SHADER),!!i&&(t.shaderSource(i,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),t.compileShader(i),o=t.createProgram(),!!o&&(t.attachShader(o,r),t.attachShader(o,i),t.linkProgram(o),t.useProgram(o),t.drawArrays(t.POINTS,0,1),t.getError()===t.NO_ERROR)))}finally{t.disable(t.BLEND),o&&t.deleteProgram(o),r&&t.deleteShader(r),i&&t.deleteShader(i),n&&(t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(n)),e&&(t.bindTexture(t.TEXTURE_2D,null),t.deleteTexture(e))}}beginTimer(){if(2===this.version&&this.disjointTimerQueryWebgl2Extension){const t=this.gl,e=this.disjointTimerQueryWebgl2Extension,n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const t=this.gl,e=this.disjointTimerQueryWebgl2Extension;t.endQuery(e.TIME_ELAPSED_EXT)}}isTimerResultAvailable(t){let e=!1,n=!1;if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const r=this.gl,i=this.disjointTimerQueryWebgl2Extension;e=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE),n=r.getParameter(i.GPU_DISJOINT_EXT)}return e&&!n}getTimerResult(t){let e=0;if(2!==this.version)throw new Error("WebGL1 profiling currently not supported");{const n=this.gl;e=n.getQueryParameter(t,n.QUERY_RESULT),n.deleteQuery(t)}return e/1e6}async waitForQueryAndGetTime(t){return await(0,u.repeatedTry)((()=>this.isTimerResultAvailable(t))),this.getTimerResult(t)}async createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e;const n=t,r=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0);return t.flush(),e=null===r?()=>!0:()=>{const t=n.clientWaitSync(r,0,0);return t===n.ALREADY_SIGNALED||t===n.CONDITION_SATISFIED},{query:r,isFencePassed:e}}async pollFence(t){return new Promise((e=>{this.addItemToPoll((()=>t.isFencePassed()),(()=>e()))}))}pollItems(){const t=c(this.itemsToPoll.map((t=>t.isDoneFn)));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}async addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||await(0,u.repeatedTry)((()=>(this.pollItems(),0===this.itemsToPoll.length)))}}},1036:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.ExecutionPlan=void 0;const r=n(6231);class i{constructor(t,e){this.op=t,this.node=e}}e.ExecutionPlan=class{constructor(t,e,n){this.graph=t,this.profiler=n,this.initialize(e)}initialize(t){this.profiler.event("session","ExecutionPlan.initialize",(()=>{const e=this.graph.getNodes();if(e.length!==t.length)throw new Error("The size of nodes and OPs do not match.");this._ops=t.map(((t,n)=>new i(t,e[n]))),this.reset(),this._starter=[],this._ops.forEach(((t,e)=>{let n=!0;for(const e of t.node.inputs)if(!this._values[e]&&-1===this.graph.getInputIndices().indexOf(e)){n=!1;break}n&&this._starter.push(e)}))}))}reset(){this._values=this.graph.getValues().map((t=>t.tensor))}async execute(t,e){return this.profiler.event("session","ExecutionPlan.execute",(async()=>{this.reset();const n=t.createInferenceHandler(),i=this.graph.getInputIndices();if(e.length!==i.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${e.length} expected: ${i.length}`);e.forEach(((t,e)=>{const n=i[e];this._values[n]=t}));const o=this._starter.slice(0),a=this.graph.getValues(),s=this.graph.getNodes();let u=0;for(;u<o.length;){const t=o[u++],e=this._ops[t],i=e.node.inputs.map((t=>this._values[t]));if(-1!==i.indexOf(void 0))throw new Error(`unresolved input detected: op: ${e.node}`);const c=i;r.Logger.verbose("ExecPlan",`Runing op:${e.node.name} (${c.map(((t,n)=>`'${e.node.inputs[n]}': ${t.type}[${t.dims.join(",")}]`)).join(", ")})`);const l=await this.profiler.event("node",e.node.name,(async()=>e.op.impl(n,c,e.op.context)));if(l.length!==e.node.outputs.length)throw new Error("the size of output does not match model definition.");l.forEach(((t,n)=>{const r=e.node.outputs[n];if(this._values[r])throw new Error(`output [${r}] already has value: op:${e.node.name}`);this._values[r]=t}));const p=new Set;l.forEach(((t,n)=>{const r=e.node.outputs[n];for(const t of a[r].to){const e=s[t];let n=!0;for(const t of e.inputs)if(!this._values[t]){n=!1;break}n&&p.add(t)}})),o.push(...p)}const c=[];for(let t=0;t<this.graph.getOutputIndices().length;t++){const e=this.graph.getOutputIndices()[t],n=this._values[e];if(void 0===n)throw new Error(`required output [${e}] does not have value`);0===e?await n.getData():n.data,c.push(n)}return r.Logger.verbose("ExecPlan","disposing of inferenceHandler"),n.dispose(),c}))}}},7070:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Graph=void 0;const r=n(1446),i=n(7778),o=n(9395),a=n(9162),s=n(2517);var u=o.onnxruntime.experimental.fbs;e.Graph={from:(t,e)=>new p(t,e)};class c{constructor(t){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,t&&(this.type=s.ProtoUtil.tensorValueTypeFromProto(t.type.tensorType))}get from(){return this._from}get to(){return this._to}}class l{constructor(t,e){t instanceof r.onnx.NodeProto?(this.name=t.name,this.opType=t.opType,this.attributes=new i.Attribute(t.attribute)):t instanceof u.Node&&(this.name=null!=e?e:t.name(),this.opType=t.opType(),this.attributes=new i.Attribute(s.ProtoUtil.tensorAttributesFromORTFormat(t))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class p{constructor(t,e){if(!t)throw new TypeError("graph is empty");this.buildGraph(t),this.transformGraph(e),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(t){if(t instanceof r.onnx.GraphProto)this.buildGraphFromOnnxFormat(t);else{if(!(t instanceof u.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(t)}}buildGraphFromOnnxFormat(t){const e=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const n=new Map;if(!t.input)throw new Error("missing information in graph: input");const r=[];for(const n of t.input){if(e.has(n.name))throw new Error(`duplicated input name: ${n.name}`);const t=this._allData.push(new c(n))-1;e.set(n.name,t),r.push(n.name)}if(!t.initializer)throw new Error("missing information in graph: initializer");for(const n of t.initializer){let t=e.get(n.name);if(void 0===t){const r=new c;r.type={shape:{dims:s.ProtoUtil.tensorDimsFromProto(n.dims)},tensorType:s.ProtoUtil.tensorDataTypeFromProto(n.dataType)},t=this._allData.push(r)-1,e.set(n.name,t)}this._allData[t]._from=-1,this._allData[t].tensor=a.Tensor.fromProto(n)}for(let t=0;t<this._allData.length;t++)this._allData[t].tensor||(this._allInputIndices.push(t),this._allInputNames.push(r[t]));if(!t.output)throw new Error("missing information in graph: output");for(const n of t.output){if(e.has(n.name))throw new Error(`duplicated output name: ${n.name}`);const t=this._allData.push(new c(n))-1;e.set(n.name,t),this._allOutputIndices.push(t),this._allOutputNames.push(n.name)}if(!t.node)throw new Error("missing information in graph: node");for(const e of t.node){if(!e.name)for(let t=0;;t++){const r=`unnamed_${e.opType}_${t}`;if(!n.has(r)){e.name=r;break}}if(n.has(e.name))throw new Error(`duplicated node name: ${e.name}`);const t=this._nodes.push(new l(e))-1;n.set(e.name,t)}for(let n=0;n<this._nodes.length;n++){const r=this._nodes[n],i=t.node[n];if(!i.output)throw new Error(`missing output for node: ${i.name}`);for(const t of i.output){let o=e.get(t);if(void 0===o&&(o=this._allData.push(new c)-1,e.set(t,o)),r.outputs.push(o),void 0!==this._allData[o]._from)throw new Error(`multiple nodes output to one data value: ${o}`);if(this._allData[o]._from=n,"Constant"===i.opType){if(!i.attribute||1!==i.attribute.length||!i.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!i.output||1!==i.output.length)throw new Error("missing output or incorrect number of outputs for this Constant operator");r.outputs.pop(),r.executeNode=!1,this._allData[o]._from=-1,this._allData[o].tensor=a.Tensor.fromProto(i.attribute[0].t)}}}for(let n=0;n<this._nodes.length;n++){const r=this._nodes[n],i=t.node[n];if(!i.input)throw new Error(`missing input for node: ${i.name}`);for(const t of i.input){const o=e.get(t);if(void 0===o){if(""===t&&3===i.input.length&&"Resize"===i.opType)continue;throw new Error(`unrecognized input '${t}' for node: ${i.name}`)}r.inputs.push(o),this._allData[o]._to.push(n)}}return!0}buildGraphFromOrtFormat(t){var e,n,r;const i=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const o=new Map,p=[];for(let o=0;o<t.inputsLength();o++){const a=t.inputs(o);if(i.has(a))throw new Error(`duplicated input name: ${a}`);for(let o=0;o<t.nodeArgsLength();o++)if((null===(e=t.nodeArgs(o))||void 0===e?void 0:e.name())===a){const e=new c;if((null===(r=null===(n=t.nodeArgs(o))||void 0===n?void 0:n.type())||void 0===r?void 0:r.valueType())!==u.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const l=t.nodeArgs(o).type().value(new u.TensorTypeAndShape),f=s.ProtoUtil.tensorDataTypeFromProto(l.elemType()),d=l.shape(),h=[];for(let t=0;t<d.dimLength();t++)h.push(s.LongUtil.longToNumber(d.dim(t).value().dimValue()));e.type={shape:{dims:h},tensorType:f};const g=this._allData.push(e)-1;i.set(a,g),p.push(a)}}for(let e=0;e<t.initializersLength();e++){const n=t.initializers(e);let r=i.get(n.name());if(void 0===r){const t=new c,e=s.ProtoUtil.tensorDimsFromORTFormat(n),o=s.ProtoUtil.tensorDataTypeFromProto(n.dataType());t.type={shape:{dims:e},tensorType:o},r=this._allData.push(t)-1,i.set(n.name(),r)}this._allData[r]._from=-1,this._allData[r].tensor=a.Tensor.fromOrtTensor(n)}for(let t=0;t<this._allData.length;t++)this._allData[t].tensor||(this._allInputIndices.push(t),this._allInputNames.push(p[t]));for(let e=0;e<t.outputsLength();e++){const n=t.outputs(e);if(i.has(n))throw new Error(`duplicated output name: ${n}`);const r=this._allData.push(new c)-1;i.set(n,r),this._allOutputIndices.push(r),this._allOutputNames.push(n)}if(!t.nodes)throw new Error("missing information in graph: node");for(let e=0;e<t.nodesLength();e++){const n=t.nodes(e);let r=n.name();if(!r)for(let t=0;r=`unnamed_${n.opType()}_${t}`,o.has(r);t++);if(o.has(r))throw new Error(`duplicated node name: ${r}`);const i=this._nodes.push(new l(n,r))-1;o.set(r,i)}for(let e=0;e<this._nodes.length;e++){const n=this._nodes[e],r=t.nodes(e);if(null==r)throw new Error(`No node exists at index ${e}`);if(0===(null==r?void 0:r.outputsLength()))throw new Error(`missing output for node: ${r.name}`);for(let t=0;t<(null==r?void 0:r.outputsLength());t++){const o=null==r?void 0:r.outputs(t);let s=i.get(o);if(void 0===s&&(s=this._allData.push(new c)-1,i.set(o,s)),n.outputs.push(s),void 0!==this._allData[s]._from)throw new Error(`multiple nodes output to one data value: ${s}`);if(this._allData[s]._from=e,"Constant"===r.opType()){if(1!==r.attributesLength()||!r.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(1!==r.outputsLength())throw new Error("missing output or incorrect number of outputs for this Constant operator");n.outputs.pop(),n.executeNode=!1,this._allData[s]._from=-1,this._allData[s].tensor=a.Tensor.fromOrtTensor(r.attributes(0).t())}}}for(let e=0;e<this._nodes.length;e++){const n=this._nodes[e],r=t.nodes(e);if(0===r.inputsLength())throw new Error(`missing input for node: ${r.name}`);for(let t=0;t<r.inputsLength();t++){const o=r.inputs(t),a=i.get(o);if(void 0===a)throw new Error(`unrecognized input '${o}' for node: ${r.name()}`);n.inputs.push(a),this._allData[a]._to.push(e)}}}checkIsAcyclic(){const t=new Set;this._allInputIndices.forEach((e=>{this._allData[e]._to.forEach((e=>{t.add(e)}))}));const e=Array.from(t),n=new Array(this._nodes.length).fill("white");for(;e.length>0;){const t=e.pop();"gray"===n[t]?n[t]="black":(e.push(t),n[t]="gray",this._nodes[t].outputs.forEach((r=>{const i=this._allData[r];if(void 0!==i.tensor)throw new Error("node outputs should not be initialized");if(i._from!==t)throw new Error("from property of the Value object doesn't match index of Node being processed");i._to.forEach((t=>{if("gray"===n[t])throw new Error("model graph is cyclic");"white"===n[t]&&e.push(t)}))})))}}transformGraph(t){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),t&&t.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let t=0;for(let e=0;e<this._nodes.length;e++)this._nodes[e].executeNode?t>0&&(this._nodes[e].inputs.forEach((n=>{const r=this._allData[n]._to.indexOf(e+t);-1!==r&&(this._allData[n]._to[r]=e)})),this._nodes[e].outputs.forEach((n=>{this._allData[n]._from&&this._allData[n]._from===e+t&&(this._allData[n]._from=e)}))):(t++,this._nodes[e].outputs.forEach((t=>{this._allData[t]._from=-2})),this._nodes.splice(e,1),e--);t=0;for(let e=0;e<this._allData.length;e++)if(-2!==this._allData[e].from||-1!==this._allOutputIndices.indexOf(e+t)){if(t>0){let n=-1;void 0!==this._allData[e].from&&-1!==this._allData[e].from?(n=this._nodes[this._allData[e].from].outputs.indexOf(e+t),-1!==n&&(this._nodes[this._allData[e].from].outputs[n]=e)):(n=this._allInputIndices.indexOf(e+t),-1!==n&&(this._allInputIndices[n]=e)),this._allData[e].to.forEach((r=>{n=this._nodes[r].inputs.indexOf(e+t),-1!==n&&(this._nodes[r].inputs[n]=e)})),0===this._allData[e].to.length&&(n=this._allOutputIndices.indexOf(e+t),-1!==n&&(this._allOutputIndices[n]=e))}}else t++,this._allData.splice(e,1),e--}deleteNode(t){const e=this._nodes[t];if(e.outputs.length>1)for(let t=1;t<e.outputs.length;t++)if(this._allData[e.outputs[t]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");e.executeNode=!1;const n=e.inputs[0],r=e.outputs[0],i=this._allData[r].to,o=this._allData[n].to.indexOf(t);if(-1===o)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[n].to.splice(o,1),this._allData[r]._to=[];const a=this._allOutputIndices.indexOf(r);if(-1!==a&&(this._allOutputIndices[a]=n),i&&i.length>0)for(const t of i){const e=this._nodes[t].inputs.indexOf(r);if(-1===e)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[t].inputs[e]=n,this._allData[n].to.push(t)}}removeAllDropoutNodes(){let t=0;for(const e of this._nodes){if("Dropout"===e.opType){if(1!==e.inputs.length)throw new Error("Dropout nodes should only contain one input. ");if(1!==e.outputs.length&&2!==e.outputs.length)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(2===e.outputs.length&&0!==this._allData[e.outputs[1]]._to.length)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(t)}t++}}removeAllIdentityNodes(){let t=0;for(const e of this._nodes)"Identity"===e.opType&&this.deleteNode(t),t++}isActivation(t){switch(t.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const t of this._nodes)if("Conv"===t.opType){const e=this._allData[t.outputs[0]]._to;if(1===e.length&&this.isActivation(this._nodes[e[0]])){const n=this._nodes[e[0]];if("Clip"===n.opType)if(1===n.inputs.length)try{t.attributes.set("activation_params","floats",[n.attributes.getFloat("min"),n.attributes.getFloat("max")])}catch(e){t.attributes.set("activation_params","floats",[s.MIN_CLIP,s.MAX_CLIP])}else{if(!(n.inputs.length>=3&&void 0!==this._allData[n.inputs[1]].tensor&&void 0!==this._allData[n.inputs[2]].tensor))continue;t.attributes.set("activation_params","floats",[this._allData[n.inputs[1]].tensor.floatData[0],this._allData[n.inputs[2]].tensor.floatData[0]])}t.attributes.set("activation","string",n.opType),this.deleteNode(e[0])}}}}},6231:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.now=e.Profiler=e.Logger=void 0;const n={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},r={none:new class{log(t,e,n){}},console:new class{log(t,e,n){console.log(`${this.color(t)} ${n?"[35m"+n+"[0m ":""}${e}`)}color(t){switch(t){case"verbose":return"[34;40mv[0m";case"info":return"[32mi[0m";case"warning":return"[30;43mw[0m";case"error":return"[31;40me[0m";case"fatal":return"[101mf[0m";default:throw new Error(`unsupported severity: ${t}`)}}}},i={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let o={"":i};function a(t,e,n,r){if(void 0===e)return i=t,{verbose:a.verbose.bind(null,i),info:a.info.bind(null,i),warning:a.warning.bind(null,i),error:a.error.bind(null,i),fatal:a.fatal.bind(null,i)};if(void 0===n)s(t,e);else if("number"==typeof n&&void 0===r)s(t,e);else if("string"==typeof n&&void 0===r)s(t,n,0,e);else{if("string"!=typeof n||"number"!=typeof r)throw new TypeError("input is valid");s(t,n,0,e)}var i}function s(t,e,i,a){const s=o[a||""]||o[""];n[t]<n[s.minimalSeverity]||(s.logDateTime&&(e=`${(new Date).toISOString()}|${e}`),s.logSourceLocation,r[s.provider].log(t,e,a))}!function(t){function e(t){o={},n("",t||{})}function n(t,n){if("*"===t)e(n);else{const e=o[t]||i;o[t]={provider:n.provider||e.provider,minimalSeverity:n.minimalSeverity||e.minimalSeverity,logDateTime:void 0===n.logDateTime?e.logDateTime:n.logDateTime,logSourceLocation:void 0===n.logSourceLocation?e.logSourceLocation:n.logSourceLocation}}}t.verbose=function(e,n){t("verbose",e,n)},t.info=function(e,n){t("info",e,n)},t.warning=function(e,n){t("warning",e,n)},t.error=function(e,n){t("error",e,n)},t.fatal=function(e,n){t("fatal",e,n)},t.reset=e,t.set=n,t.setWithEnv=function(t){const e={};t.logLevel&&(e.minimalSeverity=t.logLevel),n("",e)}}(a||(a={})),e.Logger=a;class u{constructor(t,e,n,r,i,o){this.category=t,this.name=e,this.startTime=n,this.endCallback=r,this.timer=i,this.ctx=o}end(){return this.endCallback(this)}async checkTimer(){if(void 0===this.ctx||void 0===this.timer)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class c{constructor(t,e,n,r){this.category=t,this.name=e,this.startTime=n,this.endTime=r}}e.Profiler=class{static create(t){return void 0===t?new this:new this(t.maxNumberEvents,t.flushBatchSize,t.flushIntervalInMilliseconds)}constructor(t,e,n){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=void 0===t?1e4:t,this._flushBatchSize=void 0===e?10:e,this._flushIntervalInMilliseconds=void 0===n?5e3:n}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,e.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(t,e,n,r){const i=this._started?this.begin(t,e,r):void 0;let o=!1;const a=n();if(a&&"function"==typeof a.then)return o=!0,new Promise(((t,e)=>{a.then((async e=>{i&&await i.end(),t(e)}),(async t=>{i&&await i.end(),e(t)}))}));if(!o&&i){const t=i.end();if(t&&"function"==typeof t.then)return new Promise(((e,n)=>{t.then((()=>{e(a)}),(t=>{n(t)}))}))}return a}begin(t,n,r){if(!this._started)throw new Error("profiler is not started yet");if(void 0===r){const r=(0,e.now)();return this.flush(r),new u(t,n,r,(t=>this.endSync(t)))}{const e=r.beginTimer();return new u(t,n,0,(async t=>this.end(t)),e,r)}}async end(t){const e=await t.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new c(t.category,t.name,t.startTime,e)),this.flush(e))}endSync(t){const n=(0,e.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new c(t.category,t.name,t.startTime,n)),this.flush(n))}logOneEvent(t){e.Logger.verbose(`Profiler.${t.category}`,`${(t.endTime-t.startTime).toFixed(2)}ms on event '${t.name}' at ${t.endTime.toFixed(2)}`)}flush(t){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||t-this._flushTime>=this._flushIntervalInMilliseconds){for(const t=this._flushPointer;this._flushPointer<t+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,e.now)()}}get started(){return this._started}},e.now="undefined"!=typeof performance&&performance.now?()=>performance.now():Date.now},2644:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Model=void 0;const r=n(5686),i=n(1446),o=n(7070),a=n(9395),s=n(2517);var u=a.onnxruntime.experimental.fbs;e.Model=class{constructor(){}load(t,e,n){if(!n)try{return void this.loadFromOnnxFormat(t,e)}catch(t){if(void 0!==n)throw t}this.loadFromOrtFormat(t,e)}loadFromOnnxFormat(t,e){const n=i.onnx.ModelProto.decode(t);if(s.LongUtil.longToNumber(n.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=n.opsetImport.map((t=>({domain:t.domain,version:s.LongUtil.longToNumber(t.version)}))),this._graph=o.Graph.from(n.graph,e)}loadFromOrtFormat(t,e){const n=new r.flatbuffers.ByteBuffer(t),i=u.InferenceSession.getRootAsInferenceSession(n).model();if(s.LongUtil.longToNumber(i.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let t=0;t<i.opsetImportLength();t++){const e=i.opsetImport(t);this._opsets.push({domain:null==e?void 0:e.domain(),version:s.LongUtil.longToNumber(e.version())})}this._graph=o.Graph.from(i.graph(),e)}get graph(){return this._graph}get opsets(){return this._opsets}}},782:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.FLOAT_TYPES=e.INT_TYPES=e.NUMBER_TYPES=void 0,e.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],e.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],e.FLOAT_TYPES=["float32","float64"]},1047:(t,e)=>{"use strict";function n(t,e){if(e.endsWith("+")){const n=Number.parseInt(e.substring(0,e.length-1),10);return!isNaN(n)&&n<=t}if(2===e.split("-").length){const n=e.split("-"),r=Number.parseInt(n[0],10),i=Number.parseInt(n[1],10);return!isNaN(r)&&!isNaN(i)&&r<=t&&t<=i}return Number.parseInt(e,10)===t}Object.defineProperty(e,"__esModule",{value:!0}),e.resolveOperator=void 0,e.resolveOperator=function(t,e,r){for(const i of r){const r=i[0],o=i[1],a=i[2],s=i[3],u=i[4];if(t.opType===r)for(const t of e)if((t.domain===o||"ai.onnx"===t.domain&&""===o)&&n(t.version,a))return{opImpl:s,opInit:u}}throw new TypeError(`cannot resolve operator '${t.opType}' with opsets: ${e.map((t=>`${t.domain||"ai.onnx"} v${t.version}`)).join(", ")}`)}},9395:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.onnxruntime=void 0;const r=n(5686);var i,o;i=e.onnxruntime||(e.onnxruntime={}),function(t){let e;!function(t){t[t.UNDEFINED=0]="UNDEFINED",t[t.FLOAT=1]="FLOAT",t[t.INT=2]="INT",t[t.STRING=3]="STRING",t[t.TENSOR=4]="TENSOR",t[t.GRAPH=5]="GRAPH",t[t.FLOATS=6]="FLOATS",t[t.INTS=7]="INTS",t[t.STRINGS=8]="STRINGS",t[t.TENSORS=9]="TENSORS",t[t.GRAPHS=10]="GRAPHS",t[t.SPARSE_TENSOR=11]="SPARSE_TENSOR",t[t.SPARSE_TENSORS=12]="SPARSE_TENSORS"}(e=t.AttributeType||(t.AttributeType={}))}((o=i.experimental||(i.experimental={})).fbs||(o.fbs={})),function(t){!function(t){!function(t){let e;!function(t){t[t.UNKNOWN=0]="UNKNOWN",t[t.VALUE=1]="VALUE",t[t.PARAM=2]="PARAM"}(e=t.DimensionValueType||(t.DimensionValueType={}))}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){let e;!function(t){t[t.UNDEFINED=0]="UNDEFINED",t[t.FLOAT=1]="FLOAT",t[t.UINT8=2]="UINT8",t[t.INT8=3]="INT8",t[t.UINT16=4]="UINT16",t[t.INT16=5]="INT16",t[t.INT32=6]="INT32",t[t.INT64=7]="INT64",t[t.STRING=8]="STRING",t[t.BOOL=9]="BOOL",t[t.FLOAT16=10]="FLOAT16",t[t.DOUBLE=11]="DOUBLE",t[t.UINT32=12]="UINT32",t[t.UINT64=13]="UINT64",t[t.COMPLEX64=14]="COMPLEX64",t[t.COMPLEX128=15]="COMPLEX128",t[t.BFLOAT16=16]="BFLOAT16"}(e=t.TensorDataType||(t.TensorDataType={}))}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){let e;!function(t){t[t.Primitive=0]="Primitive",t[t.Fused=1]="Fused"}(e=t.NodeType||(t.NodeType={}))}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){let e;!function(t){t[t.NONE=0]="NONE",t[t.tensor_type=1]="tensor_type",t[t.sequence_type=2]="sequence_type",t[t.map_type=3]="map_type"}(e=t.TypeInfoValue||(t.TypeInfoValue={}))}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShape(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShape(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}dim(e,n){let r=this.bb.__offset(this.bb_pos,4);return r?(n||new t.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}dimLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startShape(t){t.startObject(1)}static addDim(t,e){t.addFieldOffset(0,e,0)}static createDimVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startDimVector(t,e){t.startVector(4,e,4)}static endShape(t){return t.endObject()}static createShape(t,e){return n.startShape(t),n.addDim(t,e),n.endShape(t)}}e.Shape=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsDimension(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsDimension(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}value(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}denotation(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}static startDimension(t){t.startObject(2)}static addValue(t,e){t.addFieldOffset(0,e,0)}static addDenotation(t,e){t.addFieldOffset(1,e,0)}static endDimension(t){return t.endObject()}static createDimension(t,e,r){return n.startDimension(t),n.addValue(t,e),n.addDenotation(t,r),n.endDimension(t)}}e.Dimension=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsDimensionValue(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsDimensionValue(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}dimType(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt8(this.bb_pos+e):t.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}dimParam(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}static startDimensionValue(t){t.startObject(3)}static addDimType(e,n){e.addFieldInt8(0,n,t.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(t,e){t.addFieldInt64(1,e,t.createLong(0,0))}static addDimParam(t,e){t.addFieldOffset(2,e,0)}static endDimensionValue(t){return t.endObject()}static createDimensionValue(t,e,r,i){return n.startDimensionValue(t),n.addDimType(t,e),n.addDimValue(t,r),n.addDimParam(t,i),n.endDimensionValue(t)}}e.DimensionValue=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTensorTypeAndShape(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTensorTypeAndShape(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}elemType(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.TensorDataType.UNDEFINED}shape(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startTensorTypeAndShape(t){t.startObject(2)}static addElemType(e,n){e.addFieldInt32(0,n,t.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(t,e){t.addFieldOffset(1,e,0)}static endTensorTypeAndShape(t){return t.endObject()}static createTensorTypeAndShape(t,e,r){return n.startTensorTypeAndShape(t),n.addElemType(t,e),n.addShape(t,r),n.endTensorTypeAndShape(t)}}e.TensorTypeAndShape=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsMapType(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsMapType(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}keyType(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.TensorDataType.UNDEFINED}valueType(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startMapType(t){t.startObject(2)}static addKeyType(e,n){e.addFieldInt32(0,n,t.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(t,e){t.addFieldOffset(1,e,0)}static endMapType(t){return t.endObject()}static createMapType(t,e,r){return n.startMapType(t),n.addKeyType(t,e),n.addValueType(t,r),n.endMapType(t)}}e.MapType=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSequenceType(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSequenceType(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}elemType(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSequenceType(t){t.startObject(1)}static addElemType(t,e){t.addFieldOffset(0,e,0)}static endSequenceType(t){return t.endObject()}static createSequenceType(t,e){return n.startSequenceType(t),n.addElemType(t,e),n.endSequenceType(t)}}e.SequenceType=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){(t.fbs||(t.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(t,e,n,r){return t.prep(4,12),t.writeInt32(r),t.writeInt32(n),t.writeInt32(e),t.offset()}}}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsNodeEdge(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsNodeEdge(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}nodeIndex(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb_pos+t):0}inputEdges(e,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+r)+12*e,this.bb):null}inputEdgesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}outputEdges(e,n){let r=this.bb.__offset(this.bb_pos,8);return r?(n||new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+r)+12*e,this.bb):null}outputEdgesLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startNodeEdge(t){t.startObject(3)}static addNodeIndex(t,e){t.addFieldInt32(0,e,0)}static addInputEdges(t,e){t.addFieldOffset(1,e,0)}static startInputEdgesVector(t,e){t.startVector(12,e,4)}static addOutputEdges(t,e){t.addFieldOffset(2,e,0)}static startOutputEdgesVector(t,e){t.startVector(12,e,4)}static endNodeEdge(t){return t.endObject()}static createNodeEdge(t,e,r,i){return n.startNodeEdge(t),n.addNodeIndex(t,e),n.addInputEdges(t,r),n.addOutputEdges(t,i),n.endNodeEdge(t)}}e.NodeEdge=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsNode(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsNode(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}domain(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}sinceVersion(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readInt32(this.bb_pos+t):0}index(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readUint32(this.bb_pos+t):0}opType(t){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,t):null}type(){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.NodeType.Primitive}executionProviderType(t){let e=this.bb.__offset(this.bb_pos,18);return e?this.bb.__string(this.bb_pos+e,t):null}inputs(t,e){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}inputsLength(){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}outputs(t,e){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}outputsLength(){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__vector_len(this.bb_pos+t):0}attributes(e,n){let r=this.bb.__offset(this.bb_pos,24);return r?(n||new t.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}attributesLength(){let t=this.bb.__offset(this.bb_pos,24);return t?this.bb.__vector_len(this.bb_pos+t):0}inputArgCounts(t){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}inputArgCountsLength(){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.__vector_len(this.bb_pos+t):0}inputArgCountsArray(){let t=this.bb.__offset(this.bb_pos,26);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}implicitInputs(t,e){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}implicitInputsLength(){let t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__vector_len(this.bb_pos+t):0}static startNode(t){t.startObject(13)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addDomain(t,e){t.addFieldOffset(2,e,0)}static addSinceVersion(t,e){t.addFieldInt32(3,e,0)}static addIndex(t,e){t.addFieldInt32(4,e,0)}static addOpType(t,e){t.addFieldOffset(5,e,0)}static addType(e,n){e.addFieldInt32(6,n,t.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(t,e){t.addFieldOffset(7,e,0)}static addInputs(t,e){t.addFieldOffset(8,e,0)}static createInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInputsVector(t,e){t.startVector(4,e,4)}static addOutputs(t,e){t.addFieldOffset(9,e,0)}static createOutputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOutputsVector(t,e){t.startVector(4,e,4)}static addAttributes(t,e){t.addFieldOffset(10,e,0)}static createAttributesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startAttributesVector(t,e){t.startVector(4,e,4)}static addInputArgCounts(t,e){t.addFieldOffset(11,e,0)}static createInputArgCountsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addInt32(e[n]);return t.endVector()}static startInputArgCountsVector(t,e){t.startVector(4,e,4)}static addImplicitInputs(t,e){t.addFieldOffset(12,e,0)}static createImplicitInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startImplicitInputsVector(t,e){t.startVector(4,e,4)}static endNode(t){return t.endObject()}static createNode(t,e,r,i,o,a,s,u,c,l,p,f,d,h){return n.startNode(t),n.addName(t,e),n.addDocString(t,r),n.addDomain(t,i),n.addSinceVersion(t,o),n.addIndex(t,a),n.addOpType(t,s),n.addType(t,u),n.addExecutionProviderType(t,c),n.addInputs(t,l),n.addOutputs(t,p),n.addAttributes(t,f),n.addInputArgCounts(t,d),n.addImplicitInputs(t,h),n.endNode(t)}}e.Node=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsValueInfo(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsValueInfo(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}type(e){let n=this.bb.__offset(this.bb_pos,8);return n?(e||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startValueInfo(t){t.startObject(3)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addType(t,e){t.addFieldOffset(2,e,0)}static endValueInfo(t){return t.endObject()}static createValueInfo(t,e,r,i){return n.startValueInfo(t),n.addName(t,e),n.addDocString(t,r),n.addType(t,i),n.endValueInfo(t)}}e.ValueInfo=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTypeInfo(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTypeInfo(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}denotation(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}valueType(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint8(this.bb_pos+e):t.experimental.fbs.TypeInfoValue.NONE}value(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__union(t,this.bb_pos+e):null}static startTypeInfo(t){t.startObject(3)}static addDenotation(t,e){t.addFieldOffset(0,e,0)}static addValueType(e,n){e.addFieldInt8(1,n,t.experimental.fbs.TypeInfoValue.NONE)}static addValue(t,e){t.addFieldOffset(2,e,0)}static endTypeInfo(t){return t.endObject()}static createTypeInfo(t,e,r,i){return n.startTypeInfo(t),n.addDenotation(t,e),n.addValueType(t,r),n.addValue(t,i),n.endTypeInfo(t)}}e.TypeInfo=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){class e{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsOperatorSetId(t,n){return(n||new e).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsOperatorSetId(t,n){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(n||new e).__init(t.readInt32(t.position())+t.position(),t)}domain(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}version(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}static startOperatorSetId(t){t.startObject(2)}static addDomain(t,e){t.addFieldOffset(0,e,0)}static addVersion(t,e){t.addFieldInt64(1,e,t.createLong(0,0))}static endOperatorSetId(t){return t.endObject()}static createOperatorSetId(t,n,r){return e.startOperatorSetId(t),e.addDomain(t,n),e.addVersion(t,r),e.endOperatorSetId(t)}}t.OperatorSetId=e}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTensor(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTensor(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}dims(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}dimsLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}dataType(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.TensorDataType.UNDEFINED}rawData(t){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint8(this.bb.__vector(this.bb_pos+e)+t):0}rawDataLength(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}rawDataArray(){let t=this.bb.__offset(this.bb_pos,12);return t?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}stringData(t,e){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}stringDataLength(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}static startTensor(t){t.startObject(6)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addDims(t,e){t.addFieldOffset(2,e,0)}static createDimsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startDimsVector(t,e){t.startVector(8,e,8)}static addDataType(e,n){e.addFieldInt32(3,n,t.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(t,e){t.addFieldOffset(4,e,0)}static createRawDataVector(t,e){t.startVector(1,e.length,1);for(let n=e.length-1;n>=0;n--)t.addInt8(e[n]);return t.endVector()}static startRawDataVector(t,e){t.startVector(1,e,1)}static addStringData(t,e){t.addFieldOffset(5,e,0)}static createStringDataVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startStringDataVector(t,e){t.startVector(4,e,4)}static endTensor(t){return t.endObject()}static createTensor(t,e,r,i,o,a,s){return n.startTensor(t),n.addName(t,e),n.addDocString(t,r),n.addDims(t,i),n.addDataType(t,o),n.addRawData(t,a),n.addStringData(t,s),n.endTensor(t)}}e.Tensor=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSparseTensor(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSparseTensor(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}values(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}indices(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}dims(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}dimsLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startSparseTensor(t){t.startObject(3)}static addValues(t,e){t.addFieldOffset(0,e,0)}static addIndices(t,e){t.addFieldOffset(1,e,0)}static addDims(t,e){t.addFieldOffset(2,e,0)}static createDimsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startDimsVector(t,e){t.startVector(8,e,8)}static endSparseTensor(t){return t.endObject()}static createSparseTensor(t,e,r,i){return n.startSparseTensor(t),n.addValues(t,e),n.addIndices(t,r),n.addDims(t,i),n.endSparseTensor(t)}}e.SparseTensor=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAttribute(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAttribute(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}type(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.AttributeType.UNDEFINED}f(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}i(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}s(t){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,t):null}t(e){let n=this.bb.__offset(this.bb_pos,16);return n?(e||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}g(e){let n=this.bb.__offset(this.bb_pos,18);return n?(e||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}floats(t){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}floatsLength(){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}floatsArray(){let t=this.bb.__offset(this.bb_pos,20);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ints(t){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}intsLength(){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__vector_len(this.bb_pos+t):0}strings(t,e){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}stringsLength(){let t=this.bb.__offset(this.bb_pos,24);return t?this.bb.__vector_len(this.bb_pos+t):0}tensors(e,n){let r=this.bb.__offset(this.bb_pos,26);return r?(n||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}tensorsLength(){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.__vector_len(this.bb_pos+t):0}graphs(e,n){let r=this.bb.__offset(this.bb_pos,28);return r?(n||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}graphsLength(){let t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__vector_len(this.bb_pos+t):0}static startAttribute(t){t.startObject(13)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addType(e,n){e.addFieldInt32(2,n,t.experimental.fbs.AttributeType.UNDEFINED)}static addF(t,e){t.addFieldFloat32(3,e,0)}static addI(t,e){t.addFieldInt64(4,e,t.createLong(0,0))}static addS(t,e){t.addFieldOffset(5,e,0)}static addT(t,e){t.addFieldOffset(6,e,0)}static addG(t,e){t.addFieldOffset(7,e,0)}static addFloats(t,e){t.addFieldOffset(8,e,0)}static createFloatsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addFloat32(e[n]);return t.endVector()}static startFloatsVector(t,e){t.startVector(4,e,4)}static addInts(t,e){t.addFieldOffset(9,e,0)}static createIntsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startIntsVector(t,e){t.startVector(8,e,8)}static addStrings(t,e){t.addFieldOffset(10,e,0)}static createStringsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startStringsVector(t,e){t.startVector(4,e,4)}static addTensors(t,e){t.addFieldOffset(11,e,0)}static createTensorsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startTensorsVector(t,e){t.startVector(4,e,4)}static addGraphs(t,e){t.addFieldOffset(12,e,0)}static createGraphsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startGraphsVector(t,e){t.startVector(4,e,4)}static endAttribute(t){return t.endObject()}static createAttribute(t,e,r,i,o,a,s,u,c,l,p,f,d,h){return n.startAttribute(t),n.addName(t,e),n.addDocString(t,r),n.addType(t,i),n.addF(t,o),n.addI(t,a),n.addS(t,s),n.addT(t,u),n.addG(t,c),n.addFloats(t,l),n.addInts(t,p),n.addStrings(t,f),n.addTensors(t,d),n.addGraphs(t,h),n.endAttribute(t)}}e.Attribute=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsGraph(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsGraph(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}initializers(e,n){let r=this.bb.__offset(this.bb_pos,4);return r?(n||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}initializersLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}nodeArgs(e,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new t.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}nodeArgsLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}nodes(e,n){let r=this.bb.__offset(this.bb_pos,8);return r?(n||new t.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}nodesLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}maxNodeIndex(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readUint32(this.bb_pos+t):0}nodeEdges(e,n){let r=this.bb.__offset(this.bb_pos,12);return r?(n||new t.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}nodeEdgesLength(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}inputs(t,e){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}inputsLength(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}outputs(t,e){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}outputsLength(){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}sparseInitializers(e,n){let r=this.bb.__offset(this.bb_pos,18);return r?(n||new t.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}sparseInitializersLength(){let t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}static startGraph(t){t.startObject(8)}static addInitializers(t,e){t.addFieldOffset(0,e,0)}static createInitializersVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInitializersVector(t,e){t.startVector(4,e,4)}static addNodeArgs(t,e){t.addFieldOffset(1,e,0)}static createNodeArgsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodeArgsVector(t,e){t.startVector(4,e,4)}static addNodes(t,e){t.addFieldOffset(2,e,0)}static createNodesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodesVector(t,e){t.startVector(4,e,4)}static addMaxNodeIndex(t,e){t.addFieldInt32(3,e,0)}static addNodeEdges(t,e){t.addFieldOffset(4,e,0)}static createNodeEdgesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodeEdgesVector(t,e){t.startVector(4,e,4)}static addInputs(t,e){t.addFieldOffset(5,e,0)}static createInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInputsVector(t,e){t.startVector(4,e,4)}static addOutputs(t,e){t.addFieldOffset(6,e,0)}static createOutputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOutputsVector(t,e){t.startVector(4,e,4)}static addSparseInitializers(t,e){t.addFieldOffset(7,e,0)}static createSparseInitializersVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startSparseInitializersVector(t,e){t.startVector(4,e,4)}static endGraph(t){return t.endObject()}static createGraph(t,e,r,i,o,a,s,u,c){return n.startGraph(t),n.addInitializers(t,e),n.addNodeArgs(t,r),n.addNodes(t,i),n.addMaxNodeIndex(t,o),n.addNodeEdges(t,a),n.addInputs(t,s),n.addOutputs(t,u),n.addSparseInitializers(t,c),n.endGraph(t)}}e.Graph=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsModel(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsModel(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}irVersion(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}opsetImport(e,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new t.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}opsetImportLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}producerName(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}producerVersion(t){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.__string(this.bb_pos+e,t):null}domain(t){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__string(this.bb_pos+e,t):null}modelVersion(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}docString(t){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.__string(this.bb_pos+e,t):null}graph(e){let n=this.bb.__offset(this.bb_pos,18);return n?(e||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}graphDocString(t){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__string(this.bb_pos+e,t):null}static startModel(t){t.startObject(9)}static addIrVersion(t,e){t.addFieldInt64(0,e,t.createLong(0,0))}static addOpsetImport(t,e){t.addFieldOffset(1,e,0)}static createOpsetImportVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOpsetImportVector(t,e){t.startVector(4,e,4)}static addProducerName(t,e){t.addFieldOffset(2,e,0)}static addProducerVersion(t,e){t.addFieldOffset(3,e,0)}static addDomain(t,e){t.addFieldOffset(4,e,0)}static addModelVersion(t,e){t.addFieldInt64(5,e,t.createLong(0,0))}static addDocString(t,e){t.addFieldOffset(6,e,0)}static addGraph(t,e){t.addFieldOffset(7,e,0)}static addGraphDocString(t,e){t.addFieldOffset(8,e,0)}static endModel(t){return t.endObject()}static createModel(t,e,r,i,o,a,s,u,c,l){return n.startModel(t),n.addIrVersion(t,e),n.addOpsetImport(t,r),n.addProducerName(t,i),n.addProducerVersion(t,o),n.addDomain(t,a),n.addModelVersion(t,s),n.addDocString(t,u),n.addGraph(t,c),n.addGraphDocString(t,l),n.endModel(t)}}e.Model=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){class e{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsKernelCreateInfos(t,n){return(n||new e).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsKernelCreateInfos(t,n){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(n||new e).__init(t.readInt32(t.position())+t.position(),t)}nodeIndices(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}nodeIndicesLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}nodeIndicesArray(){let t=this.bb.__offset(this.bb_pos,4);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}kernelDefHashes(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}kernelDefHashesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}static startKernelCreateInfos(t){t.startObject(2)}static addNodeIndices(t,e){t.addFieldOffset(0,e,0)}static createNodeIndicesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addInt32(e[n]);return t.endVector()}static startNodeIndicesVector(t,e){t.startVector(4,e,4)}static addKernelDefHashes(t,e){t.addFieldOffset(1,e,0)}static createKernelDefHashesVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startKernelDefHashesVector(t,e){t.startVector(8,e,8)}static endKernelCreateInfos(t){return t.endObject()}static createKernelCreateInfos(t,n,r){return e.startKernelCreateInfos(t),e.addNodeIndices(t,n),e.addKernelDefHashes(t,r),e.endKernelCreateInfos(t)}}t.KernelCreateInfos=e}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSubGraphSessionState(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSubGraphSessionState(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}graphId(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}sessionState(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSubGraphSessionState(t){t.startObject(2)}static addGraphId(t,e){t.addFieldOffset(0,e,0)}static addSessionState(t,e){t.addFieldOffset(1,e,0)}static endSubGraphSessionState(t){let e=t.endObject();return t.requiredField(e,4),e}static createSubGraphSessionState(t,e,r){return n.startSubGraphSessionState(t),n.addGraphId(t,e),n.addSessionState(t,r),n.endSubGraphSessionState(t)}}e.SubGraphSessionState=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSessionState(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSessionState(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}kernels(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}subGraphSessionStates(e,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new t.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}subGraphSessionStatesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}static startSessionState(t){t.startObject(2)}static addKernels(t,e){t.addFieldOffset(0,e,0)}static addSubGraphSessionStates(t,e){t.addFieldOffset(1,e,0)}static createSubGraphSessionStatesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startSubGraphSessionStatesVector(t,e){t.startVector(4,e,4)}static endSessionState(t){return t.endObject()}static createSessionState(t,e,r){return n.startSessionState(t),n.addKernels(t,e),n.addSubGraphSessionStates(t,r),n.endSessionState(t)}}e.SessionState=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsInferenceSession(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsInferenceSession(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static bufferHasIdentifier(t){return t.__has_identifier("ORTM")}ortVersion(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}model(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}sessionState(e){let n=this.bb.__offset(this.bb_pos,8);return n?(e||new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startInferenceSession(t){t.startObject(3)}static addOrtVersion(t,e){t.addFieldOffset(0,e,0)}static addModel(t,e){t.addFieldOffset(1,e,0)}static addSessionState(t,e){t.addFieldOffset(2,e,0)}static endInferenceSession(t){return t.endObject()}static finishInferenceSessionBuffer(t,e){t.finish(e,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(t,e){t.finish(e,"ORTM",!0)}static createInferenceSession(t,e,r,i){return n.startInferenceSession(t),n.addOrtVersion(t,e),n.addModel(t,r),n.addSessionState(t,i),n.endInferenceSession(t)}}e.InferenceSession=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={}))},7448:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.OnnxjsSessionHandler=void 0;const r=n(1670),i=n(9162);e.OnnxjsSessionHandler=class{constructor(t){this.session=t,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(t,e,n){const o=new Map;for(const e in t)if(Object.hasOwnProperty.call(t,e)){const n=t[e];o.set(e,new i.Tensor(n.dims,n.type,void 0,void 0,n.data))}const a=await this.session.run(o),s={};return a.forEach(((t,e)=>{s[e]=new r.Tensor(t.type,t.data,t.dims)})),s}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Session=void 0;const r=n(7067),i=n(1296),o=n(7091),a=n(1036),s=n(6231),u=n(2644);e.Session=class{constructor(t={}){this._initialized=!1,this.backendHint=t.backendHint,this.profiler=s.Profiler.create(t.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(t,e,n){await this.profiler.event("session","Session.loadModel",(async()=>{const a=await(0,o.resolveBackend)(this.backendHint);if(this.sessionHandler=a.createSessionHandler(this.context),this._model=new u.Model,"string"==typeof t){const e=t.endsWith(".ort");if("undefined"==typeof fetch){const n=await(0,i.promisify)(r.readFile)(t);this.initialize(n,e)}else{const n=await fetch(t),r=await n.arrayBuffer();this.initialize(new Uint8Array(r),e)}}else if(ArrayBuffer.isView(t))this.initialize(t);else{const r=new Uint8Array(t,e||0,n||t.byteLength);this.initialize(r)}}))}initialize(t,e){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",(()=>{const n=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(t,n,e),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new a.ExecutionPlan(this._model.graph,this._ops,this.profiler)})),this._initialized=!0}async run(t){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",(async()=>{const e=this.normalizeAndValidateInputs(t),n=await this._executionPlan.execute(this.sessionHandler,e);return this.createOutput(n)}))}normalizeAndValidateInputs(t){const e=this._model.graph.getInputNames();if(Array.isArray(t)){if(t.length!==e.length)throw new Error(`incorrect input array length: expected ${e.length} but got ${t.length}`)}else{if(t.size!==e.length)throw new Error(`incorrect input map size: expected ${e.length} but got ${t.size}`);const n=new Array(t.size);let r=0;for(let i=0;i<e.length;++i){const o=t.get(e[i]);if(!o)throw new Error(`missing input tensor for: '${name}'`);n[r++]=o}t=n}if(this.context.graphInputTypes&&0!==this.context.graphInputTypes.length&&this.context.graphInputDims&&0!==this.context.graphInputDims.length)this.validateInputTensorDims(this.context.graphInputDims,t,!1);else{const e=this._model.graph.getInputIndices(),n=this._model.graph.getValues(),r=new Array(e.length);for(let i=0;i<e.length;++i){const o=n[e[i]];r[i]=o.type.shape.dims,this.context.graphInputTypes.push(o.type.tensorType),this.context.graphInputDims.push(t[i].dims)}this.validateInputTensorDims(r,t,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,t),t}validateInputTensorTypes(t,e){for(let n=0;n<e.length;n++){const r=t[n],i=e[n].type;if(r!==i)throw new Error(`input tensor[${n}] check failed: expected type '${r}' but got ${i}`)}}validateInputTensorDims(t,e,n){for(let r=0;r<e.length;r++){const i=t[r],o=e[r].dims;if(!this.compareTensorDims(i,o,n))throw new Error(`input tensor[${r}] check failed: expected shape '[${i.join(",")}]' but got [${o.join(",")}]`)}}compareTensorDims(t,e,n){if(t.length!==e.length)return!1;for(let r=0;r<t.length;++r)if(t[r]!==e[r]&&(!n||0!==t[r]))return!1;return!0}createOutput(t){const e=this._model.graph.getOutputNames();if(t.length!==e.length)throw new Error("expected number of outputs do not match number of generated outputs");const n=new Map;for(let r=0;r<e.length;++r)n.set(e[r],t[r]);return n}initializeOps(t){const e=t.getNodes();this._ops=new Array(e.length);for(let n=0;n<e.length;n++)this._ops[n]=this.sessionHandler.resolve(e[n],this._model.opsets,t)}}},9162:function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.Tensor=void 0;const i=n(3442),o=r(n(3720)),a=n(1446),s=n(9395),u=n(2517);var c=s.onnxruntime.experimental.fbs;class l{get data(){if(void 0===this.cache){const t=this.dataProvider(this.dataId);if(t.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=t}return this.cache}get stringData(){if("string"!==this.type)throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if("string"!==this.type)return this.data;throw new TypeError("type cannot be non-number (string)")}get(t){return this.data[u.ShapeUtil.indicesToOffset(t,this.strides)]}set(t,e){this.data[u.ShapeUtil.indicesToOffset(t,this.strides)]=e}async getData(){return void 0===this.cache&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=u.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(t,e,n,r,o,a=i.Guid.create()){this.dims=t,this.type=e,this.dataProvider=n,this.asyncDataProvider=r,this.cache=o,this.dataId=a,this.size=u.ShapeUtil.validateDimsAndCalcSize(t);const s=this.size,c=void 0===n&&void 0===r&&void 0===o;if(void 0!==o&&o.length!==s)throw new RangeError("Input dims doesn't match data length.");if("string"===e){if(!(void 0===o||Array.isArray(o)&&o.every((t=>"string"==typeof t))))throw new TypeError("cache should be a string array");c&&(this.cache=new Array(s))}else{if(void 0!==o){const t=f(e);if(!(o instanceof t))throw new TypeError(`cache should be type ${t.name}`)}if(c){const t=new ArrayBuffer(s*function(t){switch(t){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${t}`)}}(e));this.cache=function(t,e){return new(f(e))(t)}(t,e)}}}static fromProto(t){if(!t)throw new Error("cannot construct Value from an empty tensor");const e=u.ProtoUtil.tensorDataTypeFromProto(t.dataType),n=u.ProtoUtil.tensorDimsFromProto(t.dims),r=new l(n,e);if("string"===e)t.stringData.forEach(((t,e)=>{r.data[e]=(0,u.decodeUtf8String)(t)}));else if(t.rawData&&"number"==typeof t.rawData.byteLength&&t.rawData.byteLength>0){const e=r.data,n=new DataView(t.rawData.buffer,t.rawData.byteOffset,t.rawData.byteLength),i=p(t.dataType),o=t.rawData.byteLength/i;if(t.rawData.byteLength%i!=0)throw new Error("invalid buffer length");if(e.length!==o)throw new Error("buffer length mismatch");for(let r=0;r<o;r++){const o=h(n,t.dataType,r*i);e[r]=o}}else{let e;switch(t.dataType){case a.onnx.TensorProto.DataType.FLOAT:e=t.floatData;break;case a.onnx.TensorProto.DataType.INT32:case a.onnx.TensorProto.DataType.INT16:case a.onnx.TensorProto.DataType.UINT16:case a.onnx.TensorProto.DataType.INT8:case a.onnx.TensorProto.DataType.UINT8:case a.onnx.TensorProto.DataType.BOOL:e=t.int32Data;break;case a.onnx.TensorProto.DataType.INT64:e=t.int64Data;break;case a.onnx.TensorProto.DataType.DOUBLE:e=t.doubleData;break;case a.onnx.TensorProto.DataType.UINT32:case a.onnx.TensorProto.DataType.UINT64:e=t.uint64Data;break;default:throw new Error("unspecific error")}if(null==e)throw new Error("failed to populate data from a tensorproto value");const n=r.data;if(n.length!==e.length)throw new Error("array length mismatch");for(let r=0;r<e.length;r++){const i=e[r];o.default.isLong(i)?n[r]=d(i,t.dataType):n[r]=i}}return r}static fromData(t,e,n){return new l(e,n,void 0,void 0,t)}static fromOrtTensor(t){if(!t)throw new Error("cannot construct Value from an empty tensor");const e=u.ProtoUtil.tensorDimsFromORTFormat(t),n=u.ProtoUtil.tensorDataTypeFromProto(t.dataType()),r=new l(e,n);if("string"===n)for(let e=0;e<t.stringDataLength();e++)r.data[e]=t.stringData(e);else if(t.rawDataArray()&&"number"==typeof t.rawDataLength()&&t.rawDataLength()>0){const e=r.data,n=new DataView(t.rawDataArray().buffer,t.rawDataArray().byteOffset,t.rawDataLength()),i=p(t.dataType()),o=t.rawDataLength()/i;if(t.rawDataLength()%i!=0)throw new Error("invalid buffer length");if(e.length!==o)throw new Error("buffer length mismatch");for(let r=0;r<o;r++){const o=h(n,t.dataType(),r*i);e[r]=o}}return r}}function p(t){switch(t){case a.onnx.TensorProto.DataType.UINT8:case a.onnx.TensorProto.DataType.INT8:case a.onnx.TensorProto.DataType.BOOL:return 1;case a.onnx.TensorProto.DataType.UINT16:case a.onnx.TensorProto.DataType.INT16:return 2;case a.onnx.TensorProto.DataType.FLOAT:case a.onnx.TensorProto.DataType.INT32:case a.onnx.TensorProto.DataType.UINT32:return 4;case a.onnx.TensorProto.DataType.INT64:case a.onnx.TensorProto.DataType.DOUBLE:case a.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${a.onnx.TensorProto.DataType[t]}`)}}function f(t){switch(t){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function d(t,e){if(e===a.onnx.TensorProto.DataType.INT64||e===c.TensorDataType.INT64){if(t.greaterThanOrEqual(2147483648)||t.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(e!==a.onnx.TensorProto.DataType.UINT32&&e!==c.TensorDataType.UINT32&&e!==a.onnx.TensorProto.DataType.UINT64&&e!==c.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${a.onnx.TensorProto.DataType[e]}`);if(t.greaterThanOrEqual(4294967296)||t.lessThan(0))throw new TypeError("uint64 is not supported")}return t.toNumber()}function h(t,e,n){switch(e){case a.onnx.TensorProto.DataType.BOOL:case a.onnx.TensorProto.DataType.UINT8:return t.getUint8(n);case a.onnx.TensorProto.DataType.INT8:return t.getInt8(n);case a.onnx.TensorProto.DataType.UINT16:return t.getUint16(n,!0);case a.onnx.TensorProto.DataType.INT16:return t.getInt16(n,!0);case a.onnx.TensorProto.DataType.FLOAT:return t.getFloat32(n,!0);case a.onnx.TensorProto.DataType.INT32:return t.getInt32(n,!0);case a.onnx.TensorProto.DataType.UINT32:return t.getUint32(n,!0);case a.onnx.TensorProto.DataType.INT64:return d(o.default.fromBits(t.getUint32(n,!0),t.getUint32(n+4,!0),!1),e);case a.onnx.TensorProto.DataType.DOUBLE:return t.getFloat64(n,!0);case a.onnx.TensorProto.DataType.UINT64:return d(o.default.fromBits(t.getUint32(n,!0),t.getUint32(n+4,!0),!0),e);default:throw new Error(`cannot read from DataView for type ${a.onnx.TensorProto.DataType[e]}`)}}e.Tensor=l},2517:function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.decodeUtf8String=e.MAX_CLIP=e.MIN_CLIP=e.PoolConvUtil=e.ReduceUtil=e.SplitUtil=e.MathUtil=e.ShapeUtil=e.LongUtil=e.ProtoUtil=e.GemmUtil=e.arrayCopyHelper=e.BroadcastUtil=e.MatMulUtil=e.ArrayUtil=e.assert=e.checkInputsShape=void 0;const i=n(5686),o=r(n(3720)),a=n(1446),s=n(9162);e.checkInputsShape=function(t,...e){if(!t||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].dims||t[n].dims.length!==e[n])return!1;return!0},e.assert=function(t,e){if(!t)throw new Error("string"==typeof e?e:e())},e.ArrayUtil=class{static arraysEqual(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}};class u{static preprocessInputShapes(t,e){return[1===t.length?[1,t[0]]:t,1===e.length?[e[0],1]:e]}static postprocessOutputShape(t,e,n){1===e&&t.splice(t.length-2,1),1===n&&t.pop()}static calcMatMulShape(t,e){return t[1]!==e[0]?void 0:[t[0],e[1]]}}e.MatMulUtil=u;class c{static calcShape(t,e,n=!1){const r=t.length,i=e.length;if(0===r)return e;if(0===i)return t;const o=Math.max(t.length,e.length),a=new Array(o);if(n){if(r<2||i<2)return;const n=u.calcMatMulShape([t[r-2],t[r-1]],[e[i-2],e[i-1]]);if(void 0===n)return;[a[o-2],a[o-1]]=n}for(let s=n?3:1;s<=o;s++){const n=r-s<0?1:t[r-s],u=i-s<0?1:e[i-s];if(n!==u&&n>1&&u>1)return;a[o-s]=Math.max(n,u)}return a}static index(t,e){const n=new Array(e.length);return c.fillIndex(t,e,n),n}static fillIndex(t,e,n){const r=t.length-e.length;for(let i=0;i<e.length;i++)n[i]=t[r+i]%e[i]}static calc(t,e,n,r,i){const o=c.calcShape(t.dims,e.dims);if(o){if(r&&!f.areEqual(o,t.dims))return;const a=f.size(o),u=r?t:new s.Tensor(o,i||t.type);if(0===o.length)u.set([],n(t.get([]),e.get([])));else{const r=new Array(o.length),i=new Array(t.dims.length),s=new Array(e.dims.length);let l,p=0,f=0,d=!1,h=!1;0===t.dims.length&&(p=t.get([]),d=!0),0===e.dims.length&&(f=e.get([]),h=!0);for(let g=0;g<a;g++){l=g;for(let t=o.length-1;t>=0;t--)r[t]=l%o[t],l=Math.floor(l/o[t]);d||(c.fillIndex(r,t.dims,i),p=t.get(i)),h||(c.fillIndex(r,e.dims,s),f=e.get(s)),u.set(r,n(p,f))}}return u}}static isValidBroadcast(t,e){const n=t.length,r=e.length;if(n>r)return!1;for(let i=1;i<=n;i++)if(1!==t[n-i]&&t[n-i]!==e[r-i])return!1;return!0}static getBroadcastDims(t,e){const n=t.length,r=[];for(let i=0;i<n;i++){const o=n-1-i,a=t[o]||1;(e[e.length-1-i]||1)>1&&1===a&&r.unshift(o)}return r}}e.BroadcastUtil=c,e.arrayCopyHelper=function(t,e,n,r,i){if(r<0||r>=e.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=t.length)throw new Error("targetIndex out of bounds");if(r+i>e.length)throw new Error("source indices to be copied are outside bounds");if(n+i>t.length)throw new Error("target array is too small to hold result");for(let o=0;o<i;o++)t[n+o]=e[r+o]},e.GemmUtil=class{static getShapeOfGemmResult(t,e,n,r,i){if(2!==t.length||2!==n.length)throw new Error("shape need to be of size 2");let o,a,s;e?(o=t[1],a=t[0]):(o=t[0],a=t[1]);let u=-1;if(r?(s=n[0],u=1):(s=n[1],u=0),n[u]!==a)throw new Error("dimension mismatch");if(o<=0||s<=0||a<=0)throw new Error("invalid shape specified");if(i&&!c.isValidBroadcast(i,[o,s]))throw new Error("gemm: invalid bias shape for broadcast");return[o,s,a]}};class l{static tensorDataTypeFromProto(t){switch(t){case a.onnx.TensorProto.DataType.INT8:return"int8";case a.onnx.TensorProto.DataType.UINT8:return"uint8";case a.onnx.TensorProto.DataType.BOOL:return"bool";case a.onnx.TensorProto.DataType.INT16:return"int16";case a.onnx.TensorProto.DataType.UINT16:return"uint16";case a.onnx.TensorProto.DataType.INT32:return"int32";case a.onnx.TensorProto.DataType.UINT32:return"uint32";case a.onnx.TensorProto.DataType.FLOAT:return"float32";case a.onnx.TensorProto.DataType.DOUBLE:return"float64";case a.onnx.TensorProto.DataType.STRING:return"string";case a.onnx.TensorProto.DataType.INT64:return"int32";case a.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${a.onnx.TensorProto.DataType[t]}`)}}static tensorDataTypeStringToEnum(t){switch(t){case"int8":return a.onnx.TensorProto.DataType.INT8;case"uint8":return a.onnx.TensorProto.DataType.UINT8;case"bool":return a.onnx.TensorProto.DataType.BOOL;case"int16":return a.onnx.TensorProto.DataType.INT16;case"uint16":return a.onnx.TensorProto.DataType.UINT16;case"int32":return a.onnx.TensorProto.DataType.INT32;case"uint32":return a.onnx.TensorProto.DataType.UINT32;case"float32":return a.onnx.TensorProto.DataType.FLOAT;case"float64":return a.onnx.TensorProto.DataType.DOUBLE;case"string":return a.onnx.TensorProto.DataType.STRING;case"int64":return a.onnx.TensorProto.DataType.INT64;case"uint64":return a.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${t}`)}}static tensorDimsFromProto(t){return t.map((t=>o.default.isLong(t)?t.toNumber():t))}static tensorValueTypeFromProto(t){return{tensorType:l.tensorDataTypeFromProto(t.elemType),shape:{dims:l.tensorDimsFromProto(t.shape.dim.map((t=>t.dimValue)))}}}static tensorDimsFromORTFormat(t){const e=[];for(let n=0;n<t.dimsLength();n++)e.push(p.longToNumber(t.dims(n)));return e}static tensorAttributesFromORTFormat(t){const e=[];for(let n=0;n<t.attributesLength();n++)e.push(t.attributes(n));return e}}e.ProtoUtil=l;class p{static longToNumber(t,e){return o.default.isLong(t)?t.toNumber():t instanceof i.flatbuffers.Long?o.default.fromValue({low:t.low,high:t.high,unsigned:null!=e&&e}).toNumber():t}static isLong(t){return o.default.isLong(t)||t instanceof i.flatbuffers.Long}}e.LongUtil=p;class f{static size(t){return f.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,e){if(e<0||e>t.length)throw new Error(`invalid dimension of ${e} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return f.getSizeFromDimensionRange(t,e,t.length)}static sizeToDimension(t,e){if(e<0||e>t.length)throw new Error(`invalid dimension of ${e} for sizeToDimension as Tensor has ${t.length} dimensions.`);return f.getSizeFromDimensionRange(t,0,e)}static getSizeFromDimensionRange(t,e,n){let r=1;for(let i=e;i<n;i++){if(t[i]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");r*=t[i]}return r}static computeStrides(t){const e=t.length;if(0===e)return[];if(1===e)return[1];const n=new Array(e);n[e-1]=1,n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}static transpose(t){return t.slice().reverse()}static indicesToOffset(t,e,n){void 0===n&&(n=t.length);let r=0;for(let i=0;i<n;++i)r+=e[i]*t[i];return r}static offsetToIndices(t,e){const n=e.length;if(0===n)return[];if(1===n)return[t*e[0]];const r=new Array(e.length);for(let n=0;n<r.length-1;++n)r[n]=Math.floor(t/e[n]),t-=r[n]*e[n];return r[r.length-1]=t,r}static normalizeAxis(t,e){if(t<-e&&t>=e)throw new Error("unsupported axis for this operation.");return t<0?t+e:t}static normalizeAxes(t,e){return t.map((t=>this.normalizeAxis(t,e)))}static incrementIndex(t,e,n){if(0===e.length||0===t.length)throw new Error("Index incrementing unsupported for scalar Tensor");if(void 0===n)n=e.length;else if(n<=0||n>e.length)throw new Error("Incorrect axis to increment on");for(let r=n-1;r>=0&&(t[r]++,!(t[r]<e[r]));--r)t[r]=0}static calculateReshapedDims(t,e){if(0===e.length){if(0===t.length||1===f.size(t))return[];throw new Error("cannot reshape to a scalar Tensor")}const n=e.length,r=new Array(n);let i=-1,o=1;for(let a=0;a<n;a++){if(e[a]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(-1===e[a]){if(-1!==i)throw new Error("at most one dimension in shape hints can be -1");i=a}else{if(0===e[a]){if(a>=t.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");r[a]=t[a]}else r[a]=e[a];o*=r[a]}}const a=f.size(t);if(-1!==i){if(a%o!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${t}] Output shape: [${e}]`);r[i]=a/o}else if(o!==a)throw new Error("reshapedDims and originalDims don't have matching sizes");return r}static sortBasedOnPerm(t,e){return e?e.map((e=>t[e])):t.slice().reverse()}static padShape(t,e){const n=t.length;return t.map(((t,r)=>t+e[r]+e[r+n]))}static areEqual(t,e){return t.length===e.length&&t.every(((t,n)=>t===e[n]))}static validateDimsAndCalcSize(t){if(t.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let e=1;for(const n of t){if(!Number.isInteger(n))throw new TypeError(`Invalid shape: ${n} is not an integer`);if(n<0||n>2147483647)throw new TypeError(`Invalid shape: length ${n} is not allowed`);e*=n}return e}static flattenShape(t,e){e<0&&(e+=t.length);const n=t.reduce(((t,e)=>t*e),1),r=t.slice(e).reduce(((t,e)=>t*e),1);return[n/r,r]}static squeezeShape(t,e){const n=new Array;e=f.normalizeAxes(e,t.length);for(let r=0;r<t.length;r++){const i=e.indexOf(r)>=0;if(i&&1!==t[r])throw new Error("squeeze an axis of size different than 1");(0===e.length&&t[r]>1||e.length>0&&!i)&&n.push(t[r])}return n}static unsqueezeShape(t,e){const n=new Array(t.length+e.length);n.fill(0);for(let t=0;t<e.length;t++){const r=f.normalizeAxis(e[t],n.length);if(r>=n.length)throw new Error("'axes' has an out of range axis");if(0!==n[r])throw new Error("'axes' has a duplicate axis");n[r]=1}let r=0;for(let e=0;e<n.length;e++)0===n[e]&&(n[e]=t[r++]);if(r!==t.length)throw new Error("the unsqueezed dimension could not be established");return n}}e.ShapeUtil=f,e.MathUtil=class{static sqr(t,e,n,r,i){if(r<0||r>=e.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=t.length)throw new Error("targetIndex out of bounds");if(r+i>e.length)throw new Error("source indices to be copied are outside bounds");if(n+i>t.length)throw new Error("target array is too small to hold result");for(let o=0;o<i;o++)t[n+o]+=Math.pow(e[r+o],2)}static axpy(t,e,n,r,i,o){if(r<0||r>=e.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=t.length)throw new Error("targetIndex out of bounds");if(r+i>e.length)throw new Error("source indices to be copied are outside bounds");if(n+i>t.length)throw new Error("target array is too small to hold result");for(let a=0;a<i;a++)t[n+a]+=o*e[r+a]}static powx(t,e,n,r,i,o){if(r<0||r>=e.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=t.length)throw new Error("targetIndex out of bounds");if(r+i>e.length)throw new Error("source indices to be copied are outside bounds");if(n+i>t.length)throw new Error("target array is too small to hold result");for(let a=0;a<i;a++)t[n+a]=Math.pow(e[r+a],o)}static mul(t,e,n,r,i){if(r<0||r>=e.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=t.length)throw new Error("targetIndex out of bounds");if(r+i>e.length)throw new Error("source indices to be copied are outside bounds");if(n+i>t.length)throw new Error("target array is too small to hold result");for(let o=0;o<i;o++)t[n+o]=e[r+o]*t[n+o]}};class d{static splitShape(t,e,n,r){if(0===n.length){if(!r)throw new Error("need to know number of outputs when the 'split' attribute is not specified");d.determineSplit(t[e],r,n)}const i=[],o=[0];for(let r=0;r<n.length;++r){0!==r&&o.push(o[r-1]+n[r-1]);const a=t.slice();a[e]=n[r],i.push(a)}return[i,o]}static determineSplit(t,e,n){if(t%e!=0)throw new Error("cannot split tensor to equal sized parts");for(let r=0;r<e;++r)n.push(t/e)}}e.SplitUtil=d;class h{static calcReduce(t,e,n,r,i){const o=t.dims.slice(0);0===e.length&&o.forEach(((t,n)=>e.push(n)));const a=h.calcReduceShape(o,e,!0),u=f.size(a),l=new s.Tensor(a,t.type),p=f.computeStrides(a),d=f.computeStrides(o),g=new Array(o.length);for(let n=0;n<u;n++){const a=f.offsetToIndices(n,p);c.fillIndex(a,o,g),l.set(a,h.calcReduceByAxis(t.numberData,e,o,0,f.indicesToOffset(g,d),r,i))}return n?l:new s.Tensor(h.calcReduceShape(o,e,n),l.type,void 0,void 0,l.data,l.dataId)}static calcReduceByAxis(t,e,n,r,i,o,a){let s=0;if(r>=e.length)return o(t[i]);const u=e[r],c=u>=n.length?1:f.size(n.slice(u+1));for(let l=0;l<n[u];l++)s=0===l?h.calcReduceByAxis(t,e,n,r+1,i,o,a):a(s,h.calcReduceByAxis(t,e,n,r+1,i,o,a)),i+=c;return s}static calcReduceShape(t,e,n){const r=t.slice();for(let t=0;t<e.length;t++)r[e[t]]=n?1:0;return r.filter((t=>0!==t))}}e.ReduceUtil=h;class g{static adjustPoolAttributes(t,e,n,r,i,o){if(!t&&n.length!==e.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let t=0;t<e.length-2;t++)t>=n.length?n.push(e[t+2]):n[t]=e[t+2];for(let t=0;t<n.length;t++)if(t<r.length){if(r[t]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let t=0;t<n.length;t++)if(t<i.length){if(i[t]<0)throw new Error("dilations should be greater than or equal to 1")}else i.push(1);for(let t=0;t<2*n.length;t++)if(t<o.length){if(o[t]<0)throw new Error("pad should be greater than or equal to 1")}else o.push(0);for(let t=0;t<n.length;t++){if(n[t]<=0)throw new Error("kernel shapes need to be greater than 0");if(o[t]>=n[t]||o[t+n.length]>=n[t])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,e,n,r,i,o){if(o){if(i.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(e.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let a=0;a<t.length-2;a++)g.adjustPadAndReturnShape(t[a+2],e[a],n[a],r[a],i,a,a+t.length-2,o)}}static computePoolOutputShape(t,e,n,r,i,o,a){if(e.length<=0)throw new Error("input shape must be of size greater than 0");const s=[e[0],e[1]];return g.computeShapeHelper(t,e,s,n,r,i,o,a),s}static computeConvOutputShape(t,e,n,r,i,o,a){if(t.length<=0||e.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const s=[t[0],e[0]];return g.computeShapeHelper(!1,t,s,n,r,i,o,a),s}static computeShapeHelper(t,e,n,r,i,o,a,s){if(t)for(let t=0;t<e.length-2;t++)n.push(1);else for(let t=0;t<e.length-2;t++)n.push(g.adjustPadAndReturnShape(e[t+2],r[t],i[t],o[t],a,t,t+e.length-2,s))}static adjustPadAndReturnShape(t,e,n,r,i,o,a,s){const u=n*(r-1)+1;if(!s||"NOTSET"===s)return Math.floor((t+i[o]+i[a]-u)/e+1);switch(s){case"VALID":return i[o]=0,i[a]=0,Math.floor((t-u)/e+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const n=((t+e-1)/e-1)*e+r-t;return i[o]="SAME_LOWER"===s?Math.floor((n+1)/2):Math.floor(n/2),i[a]=n-i[o],Math.floor((t+n-r)/e+1)}default:throw new Error("Unsupported AutoPad type")}}}e.PoolConvUtil=g,e.MIN_CLIP=-34028234663852886e22,e.MAX_CLIP=34028234663852886e22,e.decodeUtf8String=function(t){return(new TextDecoder).decode(t)}},7967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,i)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,o])=>{const a=n?n+t:t;if("object"==typeof o)(0,e.iterateExtraOptions)(o,a+".",r,i);else if("string"==typeof o||"number"==typeof o)i(a,o.toString());else{if("boolean"!=typeof o)throw new Error("Can't handle extra config type: "+typeof o);i(a,o?"1":"0")}}))}},2157:function(t,e,n){"use strict";var r,i=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),o=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),a=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&i(e,t,n);return o(e,t),e};Object.defineProperty(e,"__esModule",{value:!0}),e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=e.initWasm=void 0;const s=n(1670),u=a(n(349)),c=n(6361),l=()=>!!s.env.wasm.proxy&&"undefined"!=typeof document;let p,f,d,h=!1,g=!1,b=!1;const m=[],y=[],_=[],v=[],w=[],x=[],T=()=>{if(h||!g||b||!p)throw new Error("worker not ready")},S=t=>{switch(t.data.type){case"init-wasm":h=!1,t.data.err?(b=!0,f[1](t.data.err)):(g=!0,f[0]());break;case"init-ort":t.data.err?d[1](t.data.err):d[0]();break;case"create_allocate":t.data.err?m.shift()[1](t.data.err):m.shift()[0](t.data.out);break;case"create_finalize":t.data.err?y.shift()[1](t.data.err):y.shift()[0](t.data.out);break;case"create":t.data.err?_.shift()[1](t.data.err):_.shift()[0](t.data.out);break;case"release":t.data.err?v.shift()[1](t.data.err):v.shift()[0]();break;case"run":t.data.err?w.shift()[1](t.data.err):w.shift()[0](t.data.out);break;case"end-profiling":t.data.err?x.shift()[1](t.data.err):x.shift()[0]()}},O="undefined"!=typeof document?null===(r=null===document||void 0===document?void 0:document.currentScript)||void 0===r?void 0:r.src:void 0;e.initWasm=async()=>{if(l()){if(g)return;if(h)throw new Error("multiple calls to 'initWasm()' detected.");if(b)throw new Error("previous call to 'initWasm()' failed.");return h=!0,void 0===s.env.wasm.wasmPaths&&O&&0!==O.indexOf("blob:")&&(s.env.wasm.wasmPaths=O.substr(0,+O.lastIndexOf("/")+1)),new Promise(((t,e)=>{null==p||p.terminate(),p=n(9710).Z(),p.onmessage=S,f=[t,e];const r={type:"init-wasm",in:s.env.wasm};p.postMessage(r)}))}return(0,c.initializeWebAssembly)(s.env.wasm)},e.initOrt=async(t,e)=>{if(l())return T(),new Promise(((n,r)=>{d=[n,r];const i={type:"init-ort",in:{numThreads:t,loggingLevel:e}};p.postMessage(i)}));u.initOrt(t,e)},e.createSessionAllocate=async t=>l()?(T(),new Promise(((e,n)=>{m.push([e,n]);const r={type:"create_allocate",in:{model:t}};p.postMessage(r,[t.buffer])}))):u.createSessionAllocate(t),e.createSessionFinalize=async(t,e)=>l()?(T(),new Promise(((n,r)=>{y.push([n,r]);const i={type:"create_finalize",in:{modeldata:t,options:e}};p.postMessage(i)}))):u.createSessionFinalize(t,e),e.createSession=async(t,e)=>l()?(T(),new Promise(((n,r)=>{_.push([n,r]);const i={type:"create",in:{model:t,options:e}};p.postMessage(i,[t.buffer])}))):u.createSession(t,e),e.releaseSession=async t=>{if(l())return T(),new Promise(((e,n)=>{v.push([e,n]);const r={type:"release",in:t};p.postMessage(r)}));u.releaseSession(t)},e.run=async(t,e,n,r,i)=>l()?(T(),new Promise(((o,a)=>{w.push([o,a]);const s={type:"run",in:{sessionId:t,inputIndices:e,inputs:n,outputIndices:r,options:i}};p.postMessage(s,u.extractTransferableBuffers(n))}))):u.run(t,e,n,r,i),e.endProfiling=async t=>{if(l())return T(),new Promise(((e,n)=>{x.push([e,n]);const r={type:"end-profiling",in:t};p.postMessage(r)}));u.endProfiling(t)}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(7967),i=n(4983),o=n(6361);e.setRunOptions=t=>{const e=(0,o.getInstance)();let n=0;const a=[],s=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(s.terminate=!1);let o=0;if(void 0!==(null==t?void 0:t.tag)&&(o=(0,i.allocWasmString)(t.tag,a)),n=e._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,o),0===n)throw new Error("Can't create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const o=(0,i.allocWasmString)(t,a),s=(0,i.allocWasmString)(r,a);if(0!==e._OrtAddRunConfigEntry(n,o,s))throw new Error(`Can't set a run config entry: ${t} - ${r}`)})),[n,a]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),a.forEach(e._free),t}}},2306:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.OnnxruntimeWebAssemblySessionHandler=void 0;const r=n(2806),i=n(1670),o=n(2850),a=n(2157);let s;e.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(t){const e=await fetch(t),n=await e.arrayBuffer();return(0,a.createSessionAllocate)(new Uint8Array(n))}async loadModel(t,e){if(s||(await(0,a.initOrt)(i.env.wasm.numThreads,(t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}})(i.env.logLevel)),s=!0),"string"==typeof t)if("undefined"==typeof fetch){const n=await(0,o.promisify)(r.readFile)(t);[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSession)(n,e)}else{const n=await this.createSessionAllocate(t);[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSessionFinalize)(n,e)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSession)(t,e)}async dispose(){return(0,a.releaseSession)(this.sessionId)}async run(t,e,n){const r=[],o=[];Object.entries(t).forEach((t=>{const e=t[0],n=t[1],i=this.inputNames.indexOf(e);if(-1===i)throw new Error(`invalid input '${e}'`);r.push(n),o.push(i)}));const s=[];Object.entries(e).forEach((t=>{const e=t[0],n=this.outputNames.indexOf(e);if(-1===n)throw new Error(`invalid output '${e}'`);s.push(n)}));const u=await(0,a.run)(this.sessionId,o,r.map((t=>[t.type,t.dims,t.data])),s,n),c={};for(let t=0;t<u.length;t++)c[this.outputNames[s[t]]]=new i.Tensor(u[t][0],u[t][2],u[t][1]);return c}startProfiling(){}endProfiling(){(0,a.endProfiling)(this.sessionId)}}},4919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(7967),i=n(4983),o=n(6361);e.setSessionOptions=t=>{const e=(0,o.getInstance)();let n=0;const a=[],s=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(s);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(s.graphOptimizationLevel="all");const u=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(s.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(s.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(s.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(s.executionMode="sequential");const c=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(s.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,i.allocWasmString)(t.logId,a)),void 0===(null==t?void 0:t.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(s.enableProfiling=!1),n=e._OrtCreateSessionOptions(u,!!s.enableCpuMemArena,!!s.enableMemPattern,c,!!s.enableProfiling,0,l,s.logSeverityLevel,s.logVerbosityLevel),0===n)throw new Error("Can't create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const a=(0,i.allocWasmString)(e,n);if(0!==(0,o.getInstance)()._OrtAppendExecutionProvider(t,a))throw new Error(`Can't append execution provider: ${e}`)}})(n,t.executionProviders,a),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const o=(0,i.allocWasmString)(t,a),s=(0,i.allocWasmString)(r,a);if(0!==e._OrtAddSessionConfigEntry(n,o,s))throw new Error(`Can't set a session config entry: ${t} - ${r}`)})),[n,a]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),a.forEach(e._free),t}}},4983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(6361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),i=n.lengthBytesUTF8(t)+1,o=n._malloc(i);return n.stringToUTF8(t,o,i),e.push(o),o}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),i=n(4919),o=n(4983),a=n(6361);e.initOrt=(t,e)=>{const n=(0,a.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can't initialize onnxruntime. error code = ${n}`)};const s=new Map;e.createSessionAllocate=t=>{const e=(0,a.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,a.getInstance)();let r=0,o=0,u=[];try{if([o,u]=(0,i.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],o),0===r)throw new Error("Can't create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(o),u.forEach(n._free)}const c=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),p=[],f=[],d=[],h=[];for(let t=0;t<c;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can't get an input name");f.push(e),p.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can't get an output name");h.push(e),d.push(n.UTF8ToString(e))}return s.set(r,[r,f,h]),[r,p,d]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,a.getInstance)(),n=s.get(t);if(!n)throw new Error("invalid session id");const r=n[0],i=n[1],o=n[2];i.forEach(e._OrtFree),o.forEach(e._OrtFree),e._OrtReleaseSession(r),s.delete(t)};const u=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},c=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,i,p)=>{const f=(0,a.getInstance)(),d=s.get(t);if(!d)throw new Error("invalid session id");const h=d[0],g=d[1],b=d[2],m=e.length,y=i.length;let _=0,v=[];const w=[],x=[];try{[_,v]=(0,r.setRunOptions)(p);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],i=n[t][2];let a,s;if(Array.isArray(i)){s=4*i.length,a=f._malloc(s),x.push(a);let t=a/4;for(let e=0;e<i.length;e++){if("string"!=typeof i[e])throw new TypeError(`tensor data at index ${e} is not a string`);f.HEAPU32[t++]=(0,o.allocWasmString)(i[e],x)}}else s=i.byteLength,a=f._malloc(s),x.push(a),f.HEAPU8.set(new Uint8Array(i.buffer,i.byteOffset,s),a);const c=f.stackSave(),l=f.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>f.HEAP32[t++]=e));const n=f._OrtCreateTensor(u(e),a,s,l,r.length);if(0===n)throw new Error("Can't create a tensor");w.push(n)}finally{f.stackRestore(c)}}const t=f.stackSave(),a=f.stackAlloc(4*m),s=f.stackAlloc(4*m),d=f.stackAlloc(4*y),T=f.stackAlloc(4*y);try{let n=a/4,r=s/4,o=d/4,u=T/4;for(let t=0;t<m;t++)f.HEAPU32[n++]=w[t],f.HEAPU32[r++]=g[e[t]];for(let t=0;t<y;t++)f.HEAPU32[o++]=0,f.HEAPU32[u++]=b[i[t]];let p=f._OrtRun(h,s,a,m,T,y,d,_);const v=[];if(0===p)for(let t=0;t<y;t++){const e=f.HEAPU32[d/4+t],n=f.stackSave(),r=f.stackAlloc(16);let i,o=0;try{if(p=f._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==p)throw new Error(`Can't access output tensor data. error code = ${p}`);let t=r/4;const a=f.HEAPU32[t++];o=f.HEAPU32[t++];const s=f.HEAPU32[t++],u=f.HEAPU32[t++],d=[];for(let t=0;t<u;t++)d.push(f.HEAPU32[s/4+t]);f._OrtFree(s);const h=0===d.length?1:d.reduce(((t,e)=>t*e));if(i=c(a),"string"===i){const t=[];let e=o/4;for(let n=0;n<h;n++){const r=f.HEAPU32[e++],i=n===h-1?void 0:f.HEAPU32[e]-r;t.push(f.UTF8ToString(r,i))}v.push([i,d,t])}else{const t=new(l(i))(h);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(f.HEAPU8.subarray(o,o+t.byteLength)),v.push([i,d,t])}}finally{f.stackRestore(n),"string"===i&&o&&f._free(o),f._OrtReleaseTensor(e)}}if(0===p)return v;throw new Error(`failed to call OrtRun(). error code = ${p}.`)}finally{f.stackRestore(t)}}finally{w.forEach(f._OrtReleaseTensor),x.forEach(f._free),f._OrtReleaseRunOptions(_),v.forEach(f._free)}},e.endProfiling=t=>{const e=(0,a.getInstance)(),n=s.get(t);if(!n)throw new Error("invalid session id");const r=n[0],i=e._OrtEndProfiling(r);if(0===i)throw new Error("Can't get an profile file name");e._OrtFree(i)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},6361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return i(e,t),e},a=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const s=o(n(6449)),u=a(n(932)),c=n(3474);let l,p=!1,f=!1,d=!1;const h=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(p)return Promise.resolve();if(f)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(d)throw new Error("previous call to 'initializeWebAssembly()' failed.");f=!0;const e=t.initTimeout,r=t.numThreads,i=t.simd,o=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),a=i&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),g="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=h(!1,o),m=h(a,o),y="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let _=!1;const v=[];if(e>0&&v.push(new Promise((t=>{setTimeout((()=>{_=!0,t()}),e)}))),v.push(new Promise(((t,e)=>{const r=o?c:u.default,i={locateFile:(t,e)=>o&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(4154)],{type:"text/javascript"})):t===b?null!=y?y:(null!=g?g:e)+m:e+t};if(o)if("undefined"==typeof Blob)i.mainScriptUrlOrBlob=s.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;i.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(i).then((e=>{f=!1,p=!0,l=e,t()}),(t=>{f=!1,d=!0,e(t)}))}))),await Promise.race(v),_)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(p&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!p||f||d||(f=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,f=!1,p=!1,d=!0)}},9710:(t,e,n)=>{"use strict";n.d(e,{Z:()=>o});var r=n(477),i=n.n(r);function o(){return i()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n',"Worker",void 0,void 0)}},477:t=>{"use strict";t.exports=function(t,e,n,r){var i=self||window;try{try{var o;try{o=new i.Blob([t])}catch(e){(o=new(i.BlobBuilder||i.WebKitBlobBuilder||i.MozBlobBuilder||i.MSBlobBuilder)).append(t),o=o.getBlob()}var a=i.URL||i.webkitURL,s=a.createObjectURL(o),u=new i[e](s,n);return a.revokeObjectURL(s),u}catch(r){return new i[e]("data:application/javascript,".concat(encodeURIComponent(t)),n)}}catch(t){if(!r)throw Error("Inline worker is not supported");return new i[e](r,n)}}},4154:t=>{"use strict";t.exports='"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\n'},1670:t=>{"use strict";t.exports=__WEBPACK_EXTERNAL_MODULE__1670__},7067:()=>{},1296:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(t,e,n)=>{"use strict";n.r(e),n.d(e,{flatbuffers:()=>r});var r={};r.Offset,r.Table,r.SIZEOF_SHORT=2,r.SIZEOF_INT=4,r.FILE_IDENTIFIER_LENGTH=4,r.SIZE_PREFIX_LENGTH=4,r.Encoding={UTF8_BYTES:1,UTF16_STRING:2},r.int32=new Int32Array(2),r.float32=new Float32Array(r.int32.buffer),r.float64=new Float64Array(r.int32.buffer),r.isLittleEndian=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0],r.Long=function(t,e){this.low=0|t,this.high=0|e},r.Long.create=function(t,e){return 0==t&&0==e?r.Long.ZERO:new r.Long(t,e)},r.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},r.Long.prototype.equals=function(t){return this.low==t.low&&this.high==t.high},r.Long.ZERO=new r.Long(0,0),r.Builder=function(t){if(t)e=t;else var e=1024;this.bb=r.ByteBuffer.allocate(e),this.space=e,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.forceDefaults=function(t){this.force_defaults=t},r.Builder.prototype.dataBuffer=function(){return this.bb},r.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},r.Builder.prototype.prep=function(t,e){t>this.minalign&&(this.minalign=t);for(var n=1+~(this.bb.capacity()-this.space+e)&t-1;this.space<n+t+e;){var i=this.bb.capacity();this.bb=r.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-i}this.pad(n)},r.Builder.prototype.pad=function(t){for(var e=0;e<t;e++)this.bb.writeInt8(--this.space,0)},r.Builder.prototype.writeInt8=function(t){this.bb.writeInt8(this.space-=1,t)},r.Builder.prototype.writeInt16=function(t){this.bb.writeInt16(this.space-=2,t)},r.Builder.prototype.writeInt32=function(t){this.bb.writeInt32(this.space-=4,t)},r.Builder.prototype.writeInt64=function(t){this.bb.writeInt64(this.space-=8,t)},r.Builder.prototype.writeFloat32=function(t){this.bb.writeFloat32(this.space-=4,t)},r.Builder.prototype.writeFloat64=function(t){this.bb.writeFloat64(this.space-=8,t)},r.Builder.prototype.addInt8=function(t){this.prep(1,0),this.writeInt8(t)},r.Builder.prototype.addInt16=function(t){this.prep(2,0),this.writeInt16(t)},r.Builder.prototype.addInt32=function(t){this.prep(4,0),this.writeInt32(t)},r.Builder.prototype.addInt64=function(t){this.prep(8,0),this.writeInt64(t)},r.Builder.prototype.addFloat32=function(t){this.prep(4,0),this.writeFloat32(t)},r.Builder.prototype.addFloat64=function(t){this.prep(8,0),this.writeFloat64(t)},r.Builder.prototype.addFieldInt8=function(t,e,n){(this.force_defaults||e!=n)&&(this.addInt8(e),this.slot(t))},r.Builder.prototype.addFieldInt16=function(t,e,n){(this.force_defaults||e!=n)&&(this.addInt16(e),this.slot(t))},r.Builder.prototype.addFieldInt32=function(t,e,n){(this.force_defaults||e!=n)&&(this.addInt32(e),this.slot(t))},r.Builder.prototype.addFieldInt64=function(t,e,n){!this.force_defaults&&e.equals(n)||(this.addInt64(e),this.slot(t))},r.Builder.prototype.addFieldFloat32=function(t,e,n){(this.force_defaults||e!=n)&&(this.addFloat32(e),this.slot(t))},r.Builder.prototype.addFieldFloat64=function(t,e,n){(this.force_defaults||e!=n)&&(this.addFloat64(e),this.slot(t))},r.Builder.prototype.addFieldOffset=function(t,e,n){(this.force_defaults||e!=n)&&(this.addOffset(e),this.slot(t))},r.Builder.prototype.addFieldStruct=function(t,e,n){e!=n&&(this.nested(e),this.slot(t))},r.Builder.prototype.nested=function(t){if(t!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},r.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},r.Builder.prototype.slot=function(t){this.vtable[t]=this.offset()},r.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},r.Builder.growByteBuffer=function(t){var e=t.capacity();if(3221225472&e)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var n=e<<1,i=r.ByteBuffer.allocate(n);return i.setPosition(n-e),i.bytes().set(t.bytes(),n-e),i},r.Builder.prototype.addOffset=function(t){this.prep(r.SIZEOF_INT,0),this.writeInt32(this.offset()-t+r.SIZEOF_INT)},r.Builder.prototype.startObject=function(t){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=t;for(var e=0;e<t;e++)this.vtable[e]=0;this.isNested=!0,this.object_start=this.offset()},r.Builder.prototype.endObject=function(){if(null==this.vtable||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var t=this.offset(),e=this.vtable_in_use-1;e>=0&&0==this.vtable[e];e--);for(var n=e+1;e>=0;e--)this.addInt16(0!=this.vtable[e]?t-this.vtable[e]:0);this.addInt16(t-this.object_start);var i=(n+2)*r.SIZEOF_SHORT;this.addInt16(i);var o=0,a=this.space;t:for(e=0;e<this.vtables.length;e++){var s=this.bb.capacity()-this.vtables[e];if(i==this.bb.readInt16(s)){for(var u=r.SIZEOF_SHORT;u<i;u+=r.SIZEOF_SHORT)if(this.bb.readInt16(a+u)!=this.bb.readInt16(s+u))continue t;o=this.vtables[e];break}}return o?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,o-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t},r.Builder.prototype.finish=function(t,e,n){var i=n?r.SIZE_PREFIX_LENGTH:0;if(e){var o=e;if(this.prep(this.minalign,r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH+i),o.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+r.FILE_IDENTIFIER_LENGTH);for(var a=r.FILE_IDENTIFIER_LENGTH-1;a>=0;a--)this.writeInt8(o.charCodeAt(a))}this.prep(this.minalign,r.SIZEOF_INT+i),this.addOffset(t),i&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},r.Builder.prototype.finishSizePrefixed=function(t,e){this.finish(t,e,!0)},r.Builder.prototype.requiredField=function(t,e){var n=this.bb.capacity()-t,r=n-this.bb.readInt32(n);if(0==this.bb.readInt16(r+e))throw new Error("FlatBuffers: field "+e+" must be set")},r.Builder.prototype.startVector=function(t,e,n){this.notNested(),this.vector_num_elems=e,this.prep(r.SIZEOF_INT,t*e),this.prep(n,t*e)},r.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},r.Builder.prototype.createString=function(t){if(t instanceof Uint8Array)var e=t;else{e=[];for(var n=0;n<t.length;){var r,i=t.charCodeAt(n++);(r=i<55296||i>=56320?i:(i<<10)+t.charCodeAt(n++)+-56613888)<128?e.push(r):(r<2048?e.push(r>>6&31|192):(r<65536?e.push(r>>12&15|224):e.push(r>>18&7|240,r>>12&63|128),e.push(r>>6&63|128)),e.push(63&r|128))}}this.addInt8(0),this.startVector(1,e.length,1),this.bb.setPosition(this.space-=e.length),n=0;for(var o=this.space,a=this.bb.bytes();n<e.length;n++)a[o++]=e[n];return this.endVector()},r.Builder.prototype.createLong=function(t,e){return r.Long.create(t,e)},r.ByteBuffer=function(t){this.bytes_=t,this.position_=0},r.ByteBuffer.allocate=function(t){return new r.ByteBuffer(new Uint8Array(t))},r.ByteBuffer.prototype.clear=function(){this.position_=0},r.ByteBuffer.prototype.bytes=function(){return this.bytes_},r.ByteBuffer.prototype.position=function(){return this.position_},r.ByteBuffer.prototype.setPosition=function(t){this.position_=t},r.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},r.ByteBuffer.prototype.readInt8=function(t){return this.readUint8(t)<<24>>24},r.ByteBuffer.prototype.readUint8=function(t){return this.bytes_[t]},r.ByteBuffer.prototype.readInt16=function(t){return this.readUint16(t)<<16>>16},r.ByteBuffer.prototype.readUint16=function(t){return this.bytes_[t]|this.bytes_[t+1]<<8},r.ByteBuffer.prototype.readInt32=function(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24},r.ByteBuffer.prototype.readUint32=function(t){return this.readInt32(t)>>>0},r.ByteBuffer.prototype.readInt64=function(t){return new r.Long(this.readInt32(t),this.readInt32(t+4))},r.ByteBuffer.prototype.readUint64=function(t){return new r.Long(this.readUint32(t),this.readUint32(t+4))},r.ByteBuffer.prototype.readFloat32=function(t){return r.int32[0]=this.readInt32(t),r.float32[0]},r.ByteBuffer.prototype.readFloat64=function(t){return r.int32[r.isLittleEndian?0:1]=this.readInt32(t),r.int32[r.isLittleEndian?1:0]=this.readInt32(t+4),r.float64[0]},r.ByteBuffer.prototype.writeInt8=function(t,e){this.bytes_[t]=e},r.ByteBuffer.prototype.writeUint8=function(t,e){this.bytes_[t]=e},r.ByteBuffer.prototype.writeInt16=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8},r.ByteBuffer.prototype.writeUint16=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8},r.ByteBuffer.prototype.writeInt32=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24},r.ByteBuffer.prototype.writeUint32=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24},r.ByteBuffer.prototype.writeInt64=function(t,e){this.writeInt32(t,e.low),this.writeInt32(t+4,e.high)},r.ByteBuffer.prototype.writeUint64=function(t,e){this.writeUint32(t,e.low),this.writeUint32(t+4,e.high)},r.ByteBuffer.prototype.writeFloat32=function(t,e){r.float32[0]=e,this.writeInt32(t,r.int32[0])},r.ByteBuffer.prototype.writeFloat64=function(t,e){r.float64[0]=e,this.writeInt32(t,r.int32[r.isLittleEndian?0:1]),this.writeInt32(t+4,r.int32[r.isLittleEndian?1:0])},r.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var t="",e=0;e<r.FILE_IDENTIFIER_LENGTH;e++)t+=String.fromCharCode(this.readInt8(this.position_+r.SIZEOF_INT+e));return t},r.ByteBuffer.prototype.__offset=function(t,e){var n=t-this.readInt32(t);return e<this.readInt16(n)?this.readInt16(n+e):0},r.ByteBuffer.prototype.__union=function(t,e){return t.bb_pos=e+this.readInt32(e),t.bb=this,t},r.ByteBuffer.prototype.__string=function(t,e){t+=this.readInt32(t);var n=this.readInt32(t),i="",o=0;if(t+=r.SIZEOF_INT,e===r.Encoding.UTF8_BYTES)return this.bytes_.subarray(t,t+n);for(;o<n;){var a,s=this.readUint8(t+o++);if(s<192)a=s;else{var u=this.readUint8(t+o++);if(s<224)a=(31&s)<<6|63&u;else{var c=this.readUint8(t+o++);a=s<240?(15&s)<<12|(63&u)<<6|63&c:(7&s)<<18|(63&u)<<12|(63&c)<<6|63&this.readUint8(t+o++)}}a<65536?i+=String.fromCharCode(a):(a-=65536,i+=String.fromCharCode(55296+(a>>10),56320+(1023&a)))}return i},r.ByteBuffer.prototype.__indirect=function(t){return t+this.readInt32(t)},r.ByteBuffer.prototype.__vector=function(t){return t+this.readInt32(t)+r.SIZEOF_INT},r.ByteBuffer.prototype.__vector_len=function(t){return this.readInt32(t+this.readInt32(t))},r.ByteBuffer.prototype.__has_identifier=function(t){if(t.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+r.FILE_IDENTIFIER_LENGTH);for(var e=0;e<r.FILE_IDENTIFIER_LENGTH;e++)if(t.charCodeAt(e)!=this.readInt8(this.position_+r.SIZEOF_INT+e))return!1;return!0},r.ByteBuffer.prototype.createLong=function(t,e){return r.Long.create(t,e)}}},__webpack_module_cache__={};function __nested_webpack_require_546802__(t){var e=__webpack_module_cache__[t];if(void 0!==e)return e.exports;var n=__webpack_module_cache__[t]={exports:{}};return __webpack_modules__[t].call(n.exports,n,n.exports,__nested_webpack_require_546802__),n.exports}__nested_webpack_require_546802__.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return __nested_webpack_require_546802__.d(e,{a:e}),e},__nested_webpack_require_546802__.d=(t,e)=>{for(var n in e)__nested_webpack_require_546802__.o(e,n)&&!__nested_webpack_require_546802__.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},__nested_webpack_require_546802__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),__nested_webpack_require_546802__.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),__nested_webpack_require_546802__.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var __nested_webpack_exports__=__nested_webpack_require_546802__(6018);return __nested_webpack_exports__})()));
//# sourceMappingURL=ort-web.min.js.map

/***/ }),

/***/ "./src/LoggingModule.js":
/*!******************************!*\
  !*** ./src/LoggingModule.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   logger: () => (/* binding */ logger),
/* harmony export */   serializeStateValue: () => (/* binding */ serializeStateValue)
/* harmony export */ });
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function serializeStateValue(stateValue) {
  if (typeof stateValue === "string") {
    return stateValue;
  }
  if (_typeof(stateValue) === 'object' && stateValue !== null) {
    return Object.keys(stateValue).map(function (key) {
      var nestedValue = stateValue[key];
      if (_typeof(nestedValue) === 'object' && nestedValue !== null) {
        return "".concat(key, ":{").concat(serializeStateValue(nestedValue), "}");
      }
      return "".concat(key, ":").concat(nestedValue);
    }).join(",");
  }
  return String(stateValue);
}
var Logger = /*#__PURE__*/function () {
  function Logger() {
    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "SayPi";
    _classCallCheck(this, Logger);
    this.prefix = prefix;
    // TODO: Make debugMode configurable, e.g., via storage or a global flag
    this.debugMode = true; // Default to true for easier development, can be changed
  }
  return _createClass(Logger, [{
    key: "setDebugMode",
    value: function setDebugMode(enabled) {
      this.debugMode = enabled;
    }
  }, {
    key: "_formatArgs",
    value: function _formatArgs(args) {
      return args.map(function (arg) {
        return _typeof(arg) === 'object' && arg !== null && !(arg instanceof Error) ? JSON.stringify(arg, null, 2) : arg;
      });
    }
  }, {
    key: "log",
    value: function log() {
      var _console;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_console = console).log.apply(_console, ["[".concat(this.prefix, "]")].concat(_toConsumableArray(this._formatArgs(args))));
    }
  }, {
    key: "debug",
    value: function debug() {
      if (this.debugMode) {
        var _console2;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        (_console2 = console).debug.apply(_console2, ["[".concat(this.prefix, " DEBUG]")].concat(_toConsumableArray(this._formatArgs(args))));
      }
    }
  }, {
    key: "info",
    value: function info() {
      var _console3;
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      // Alias for log
      (_console3 = console).info.apply(_console3, ["[".concat(this.prefix, " INFO]")].concat(_toConsumableArray(this._formatArgs(args))));
    }
  }, {
    key: "warn",
    value: function warn() {
      var _console4;
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      (_console4 = console).warn.apply(_console4, ["[".concat(this.prefix, " WARNING]")].concat(_toConsumableArray(this._formatArgs(args))));
    }
  }, {
    key: "error",
    value: function error() {
      var _console5;
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      (_console5 = console).error.apply(_console5, ["[".concat(this.prefix, " ERROR]")].concat(_toConsumableArray(this._formatArgs(args))));
    }
  }, {
    key: "group",
    value: function group(label) {
      console.group("[".concat(this.prefix, "] ").concat(label));
    }
  }, {
    key: "groupEnd",
    value: function groupEnd() {
      console.groupEnd();
    }
  }, {
    key: "reportError",
    value: function reportError(error) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var additionalMessage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
      var errorMessage = additionalMessage ? "".concat(additionalMessage, ": ").concat(error.message || String(error)) : error.message || String(error);
      var errorInfo = {
        message: errorMessage,
        stack: error.stack,
        context: context,
        timestamp: new Date().toISOString(),
        prefix: this.prefix
      };
      this.error(errorMessage, "Context:", context, "Stack:", error.stack);
      try {
        chrome.runtime.sendMessage({
          type: "LOG_ERROR_REPORT",
          // Changed type to be more specific
          error: errorInfo,
          origin: "logger-reportError" // Identify the source of this message
        })["catch"](function (e) {
          // This catch is for sendMessage itself failing (e.g. if background isn't ready)
          console.error("[Logger] Failed to send error report to background:", e, errorInfo);
        });
      } catch (e) {
        // Catch synchronous errors from sendMessage, though less common
        console.error("[Logger] Synchronous error sending error report to background:", e, errorInfo);
      }
      return errorInfo;
    }
  }]);
}(); // Export a single instance of the logger
var logger = new Logger("SayPi");

// Example usage (optional, for testing):
// logger.setDebugMode(true);
// logger.debug("This is a debug message", { a: 1 });
// logger.info("This is an info message");
// logger.warn("This is a warning");
// try {
//   throw new Error("Test error for reporting");
// } catch (e) {
//   logger.reportError(e, { customContext: "Test context" }, "Caught an exception");
// }

/***/ }),

/***/ "./src/audio/AudioEncoder.ts":
/*!***********************************!*\
  !*** ./src/audio/AudioEncoder.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   convertToWavBlob: () => (/* binding */ convertToWavBlob),
/* harmony export */   convertToWavBuffer: () => (/* binding */ convertToWavBuffer)
/* harmony export */ });
/* harmony import */ var _WavEncoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WavEncoder */ "./src/audio/WavEncoder.ts");

/**
 * Convert a Float32Array of audio samples to a WAV array buffer
 * @param audioData - The audio samples
 * @returns - The audio in WAV format as an ArrayBuffer
 */
function convertToWavBuffer(audioData) {
    const arrayBuffer = (0,_WavEncoder__WEBPACK_IMPORTED_MODULE_0__.encodeWAV)(audioData);
    return arrayBuffer;
}
/**
 * Convert a Float32Array of audio samples to a WAV Blob
 * @param audioData - The audio samples
 * @returns - The audio in WAV format
 */
function convertToWavBlob(audioData) {
    const arrayBuffer = convertToWavBuffer(audioData);
    return new Blob([arrayBuffer], { type: "audio/wav" });
}


/***/ }),

/***/ "./src/audio/WavEncoder.ts":
/*!*********************************!*\
  !*** ./src/audio/WavEncoder.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrayBufferToBase64: () => (/* binding */ arrayBufferToBase64),
/* harmony export */   encodeWAV: () => (/* binding */ encodeWAV),
/* harmony export */   minFramesForTargetMS: () => (/* binding */ minFramesForTargetMS)
/* harmony export */ });
// Most of the code here come from ricky0123/vad-web
// Who in turn copied it from linto-ai/WebVoiceSDK
function minFramesForTargetMS(targetDuration, frameSamples, sr = 16000) {
    return Math.ceil((targetDuration * sr) / 1000 / frameSamples);
}
function arrayBufferToBase64(buffer) {
    var binary = "";
    var bytes = new Uint8Array(buffer);
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}
/*
  This rest of this was mostly copied from https://github.com/linto-ai/WebVoiceSDK
  */
// this function is used to encode the Float32Array audio data produced from a MicVAD
// as a WAV file audio buffer
function encodeWAV(samples, format = 3, sampleRate = 16000, numChannels = 1, bitDepth = 32) {
    var bytesPerSample = bitDepth / 8;
    var blockAlign = numChannels * bytesPerSample;
    var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
    var view = new DataView(buffer);
    /* RIFF identifier */
    writeString(view, 0, "RIFF");
    /* RIFF chunk length */
    view.setUint32(4, 36 + samples.length * bytesPerSample, true);
    /* RIFF type */
    writeString(view, 8, "WAVE");
    /* format chunk identifier */
    writeString(view, 12, "fmt ");
    /* format chunk length */
    view.setUint32(16, 16, true);
    /* sample format (raw) */
    view.setUint16(20, format, true);
    /* channel count */
    view.setUint16(22, numChannels, true);
    /* sample rate */
    view.setUint32(24, sampleRate, true);
    /* byte rate (sample rate * block align) */
    view.setUint32(28, sampleRate * blockAlign, true);
    /* block align (channel count * bytes per sample) */
    view.setUint16(32, blockAlign, true);
    /* bits per sample */
    view.setUint16(34, bitDepth, true);
    /* data chunk identifier */
    writeString(view, 36, "data");
    /* data chunk length */
    view.setUint32(40, samples.length * bytesPerSample, true);
    if (format === 1) {
        // Raw PCM
        floatTo16BitPCM(view, 44, samples);
    }
    else {
        writeFloat32(view, 44, samples);
    }
    return buffer;
}
function interleave(inputL, inputR) {
    var length = inputL.length + inputR.length;
    var result = new Float32Array(length);
    var index = 0;
    var inputIndex = 0;
    while (index < length) {
        result[index++] = inputL[inputIndex];
        result[index++] = inputR[inputIndex];
        inputIndex++;
    }
    return result;
}
function writeFloat32(output, offset, input) {
    for (var i = 0; i < input.length; i++, offset += 4) {
        output.setFloat32(offset, input[i], true);
    }
}
function floatTo16BitPCM(output, offset, input) {
    for (var i = 0; i < input.length; i++, offset += 2) {
        var s = Math.max(-1, Math.min(1, input[i]));
        output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
    }
}
function writeString(view, offset, string) {
    for (var i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!****************************************!*\
  !*** ./src/offscreen/vad_offscreen.ts ***!
  \****************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ricky0123_vad_web__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ricky0123/vad-web */ "./node_modules/@ricky0123/vad-web/dist/index.js");
/* harmony import */ var _audio_AudioEncoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../audio/AudioEncoder */ "./src/audio/AudioEncoder.ts");
/* harmony import */ var _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../LoggingModule.js */ "./src/LoggingModule.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

 // Assuming this is needed for onSpeechEnd
 // Import the enhanced logger
// If getResourceUrl or similar is needed from another module, import it.
// For now, we assume paths will be relative or constructed via chrome.runtime.getURL()
_LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.log("[SayPi VAD Offscreen] Script loaded.");
let currentActiveTabId = null;
let vadInstance = null;
let stream = null;
let speechStartTime = 0;
// Function to get resource URLs within the extension package
function getExtensionFileUrl(relativePath) {
    console.log("[SayPi VAD Offscreen] Getting extension file URL for:", relativePath);
    return chrome.runtime.getURL(relativePath);
}
const commonMicVADOptions = {
    // model: "v5", // This will be default if not specified, or can be explicit
    ortConfig: (ort) => {
        // Paths need to be accessible from the extension's root
        // The files are in `public/` folder as per manifest.json web_accessible_resources
        ort.env.wasm.wasmPaths = {
            'ort-wasm.wasm': getExtensionFileUrl('public/ort-wasm.wasm'),
            'ort-wasm-simd.wasm': getExtensionFileUrl('public/ort-wasm-simd.wasm'),
            'ort-wasm-threaded.wasm': getExtensionFileUrl('public/ort-wasm-threaded.wasm'),
            'ort-wasm-simd-threaded.wasm': getExtensionFileUrl('public/ort-wasm-simd-threaded.wasm'),
        };
        ort.env.wasm.numThreads = 1;
        ort.env.wasm.simd = false; // Start with SIMD false for broader compatibility, can be true if issues are resolved.
        _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.debug("[SayPi VAD Offscreen] ORT config applied:", ort.env.wasm.wasmPaths);
    },
    positiveSpeechThreshold: 0.8,
    minSpeechFrames: 3,
    preSpeechPadFrames: 10,
    model: "v5",
    //workletURL: getExtensionFileUrl('public/vad.worklet.bundle.min.js'), // Consider browser detection for .js vs .min.js if needed
    // modelURL: getExtensionFileUrl('public/silero_vad.onnx'), // Ensure this path is correct and model is web_accessible
    onSpeechStart: () => {
        _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.debug("[SayPi VAD Offscreen] Speech started.");
        speechStartTime = Date.now();
        if (currentActiveTabId !== null) {
            chrome.runtime.sendMessage({
                type: "VAD_SPEECH_START",
                targetTabId: currentActiveTabId,
                origin: "offscreen-document",
            });
        }
    },
    onSpeechEnd: (rawAudioData) => {
        const speechStopTime = Date.now();
        const speechDuration = speechStopTime - speechStartTime;
        const audioBlob = (0,_audio_AudioEncoder__WEBPACK_IMPORTED_MODULE_1__.convertToWavBlob)(rawAudioData);
        _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.debug(`[SayPi VAD Offscreen] Speech ended. Duration: ${speechDuration}ms, Size: ${audioBlob.size} bytes`);
        if (currentActiveTabId !== null) {
            // Sending the blob directly might be too large for runtime.sendMessage.
            // Consider alternative for large data or just send notification.
            // For now, just sending the event and duration.
            chrome.runtime.sendMessage({
                type: "VAD_SPEECH_END",
                duration: speechDuration,
                // blob: audioBlob, // Potentially too large, handle appropriately
                targetTabId: currentActiveTabId,
                origin: "offscreen-document",
            });
            // TODO: If blob needs to be sent, use a different mechanism or confirm size limits.
        }
    },
    onVADMisfire: () => {
        _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.debug("[SayPi VAD Offscreen] VAD misfire.");
        if (currentActiveTabId !== null) {
            chrome.runtime.sendMessage({
                type: "VAD_MISFIRE",
                targetTabId: currentActiveTabId,
                origin: "offscreen-document",
            });
        }
    },
    onFrameProcessed(probabilities) {
        // This can be chatty, enable for debugging if necessary
        // console.log("[SayPi VAD Offscreen] Frame processed:", probabilities);
        if (currentActiveTabId !== null) {
            chrome.runtime.sendMessage({
                type: "VAD_FRAME_PROCESSED",
                probabilities,
                targetTabId: currentActiveTabId,
                origin: "offscreen-document",
            });
        }
    },
};
function tryInitializeVAD(attemptName, customOptions, currentStream) {
    return __awaiter(this, void 0, void 0, function* () {
        _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.log(`[SayPi VAD Offscreen] Attempting VAD initialization: ${attemptName}`);
        const baseOptions = {
            ortConfig: (ort) => {
                var _a, _b, _c, _d;
                ort.env.wasm.wasmPaths = {
                    'ort-wasm.wasm': getExtensionFileUrl('public/ort-wasm.wasm'),
                    'ort-wasm-simd.wasm': getExtensionFileUrl('public/ort-wasm-simd.wasm'),
                    'ort-wasm-threaded.wasm': getExtensionFileUrl('public/ort-wasm-threaded.wasm'),
                    'ort-wasm-simd-threaded.wasm': getExtensionFileUrl('public/ort-wasm-simd-threaded.wasm'),
                };
                // Apply simd/numThreads from customOptions or use defaults
                ort.env.wasm.simd = (_b = (_a = customOptions.ortConfig) === null || _a === void 0 ? void 0 : _a.simd) !== null && _b !== void 0 ? _b : false;
                ort.env.wasm.numThreads = (_d = (_c = customOptions.ortConfig) === null || _c === void 0 ? void 0 : _c.numThreads) !== null && _d !== void 0 ? _d : 1;
                _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.debug(`[SayPi VAD Offscreen] ${attemptName} - ORT config applied:`, ort.env.wasm);
            },
            positiveSpeechThreshold: commonMicVADOptions.positiveSpeechThreshold,
            minSpeechFrames: commonMicVADOptions.minSpeechFrames,
            preSpeechPadFrames: commonMicVADOptions.preSpeechPadFrames,
            onSpeechStart: commonMicVADOptions.onSpeechStart,
            onSpeechEnd: commonMicVADOptions.onSpeechEnd,
            onVADMisfire: commonMicVADOptions.onVADMisfire,
            onFrameProcessed: commonMicVADOptions.onFrameProcessed,
            stream: currentStream,
            model: "v5",
            //workletURL: getExtensionFileUrl('public/vad.worklet.bundle.min.js'), // Consider browser detection for .js vs .min.js if needed
        };
        // Merge customOptions deeply, especially for ortConfig parts if provided separately
        const finalOptions = Object.assign(Object.assign({}, baseOptions), customOptions);
        if (customOptions.ortConfig && baseOptions.ortConfig) { // Need to merge ortConfig properties
            finalOptions.ortConfig = (ort) => {
                var _a, _b;
                baseOptions.ortConfig(ort); // Apply base wasmPaths etc.
                // Then let customOptions override specifics like simd/numThreads if they were meant for ortConfig directly
                const customOrtSimd = (_a = customOptions.ortConfig) === null || _a === void 0 ? void 0 : _a.simd;
                const customOrtNumThreads = (_b = customOptions.ortConfig) === null || _b === void 0 ? void 0 : _b.numThreads;
                if (typeof customOrtSimd === 'boolean')
                    ort.env.wasm.simd = customOrtSimd;
                if (typeof customOrtNumThreads === 'number')
                    ort.env.wasm.numThreads = customOrtNumThreads;
                _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.debug(`[SayPi VAD Offscreen] ${attemptName} - Merged ORT config - SIMD: ${ort.env.wasm.simd}, Threads: ${ort.env.wasm.numThreads}`);
            };
        }
        else if (customOptions.ortConfig) {
            finalOptions.ortConfig = customOptions.ortConfig;
        }
        _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.debug(`[SayPi VAD Offscreen] ${attemptName} - Final VAD Options:`, finalOptions);
        return _ricky0123_vad_web__WEBPACK_IMPORTED_MODULE_0__.MicVAD.new(finalOptions);
    });
}
function initializeVAD() {
    return __awaiter(this, arguments, void 0, function* (options = {}) {
        if (vadInstance) {
            _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.log("[SayPi VAD Offscreen] VAD already initialized.");
            return { success: true, mode: "existing" };
        }
        try {
            _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.log("[SayPi VAD Offscreen] Acquiring microphone stream for VAD initialization...");
            stream = yield navigator.mediaDevices.getUserMedia({
                audio: {
                    channelCount: 1,
                    echoCancellation: true, // Recommended for VAD
                    autoGainControl: true, // Recommended for VAD
                    noiseSuppression: true, // Recommended for VAD
                }
            });
            _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.log("[SayPi VAD Offscreen] Microphone stream acquired.");
        }
        catch (error) {
            _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.reportError(error, { function: 'initializeVAD', step: 'getUserMedia' }, "Mic stream acquisition failed");
            return { success: false, error: `Mic stream error: ${error.message || "Unknown error"}`, mode: "failed_mic" };
        }
        let lastError = null;
        // Attempt 1: Optimistic (SIMD, some threading)
        try {
            const threads = navigator.hardwareConcurrency && navigator.hardwareConcurrency > 1 ? Math.min(2, navigator.hardwareConcurrency) : 1;
            vadInstance = yield tryInitializeVAD("Attempt 1: SIMD/Threaded", { ortConfig: (ort) => { ort.env.wasm.simd = true; ort.env.wasm.numThreads = threads; } }, stream);
            _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.log("[SayPi VAD Offscreen] MicVAD instance created (Attempt 1).");
            return { success: true, mode: "simd_threaded" };
        }
        catch (error) {
            _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.warn("[SayPi VAD Offscreen] Attempt 1 (SIMD/Threaded) failed:", error);
            lastError = error;
        }
        // Attempt 2: Safe Fallback (No SIMD, Single Thread - as per original commonMicVADOptions)
        try {
            vadInstance = yield tryInitializeVAD("Attempt 2: No SIMD/Single Thread", { ortConfig: (ort) => { ort.env.wasm.simd = false; ort.env.wasm.numThreads = 1; } }, stream);
            _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.log("[SayPi VAD Offscreen] MicVAD instance created (Attempt 2).");
            return { success: true, mode: "no_simd_single_thread" };
        }
        catch (error) {
            _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.warn("[SayPi VAD Offscreen] Attempt 2 (No SIMD/Single Thread) failed:", error);
            lastError = error;
        }
        // Attempt 3: Minimal Config (No SIMD, Single Thread, adjusted VAD params)
        try {
            vadInstance = yield tryInitializeVAD("Attempt 3: Minimal Params", {
                ortConfig: (ort) => { ort.env.wasm.simd = false; ort.env.wasm.numThreads = 1; },
                positiveSpeechThreshold: 0.75, // Slightly more lenient
                minSpeechFrames: 2, // Fewer frames
                preSpeechPadFrames: 5, // Less padding
            }, stream);
            _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.log("[SayPi VAD Offscreen] MicVAD instance created (Attempt 3).");
            return { success: true, mode: "minimal_params" };
        }
        catch (error) {
            _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.reportError(error, { function: 'initializeVAD', step: 'Attempt 3 Minimal Params', previousError: lastError }, "All VAD init attempts failed");
            if (stream) { // Clean up stream if all attempts failed
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            const finalErrorMessage = error instanceof Error ? error.message : String(error);
            return { success: false, error: finalErrorMessage || "Unknown VAD initialization error after all fallbacks", mode: "failed_all" };
        }
    });
}
function startVAD(tabId) {
    return __awaiter(this, void 0, void 0, function* () {
        currentActiveTabId = tabId;
        if (!vadInstance) {
            const initResult = yield initializeVAD();
            if (!initResult.success) {
                return initResult;
            }
        }
        try {
            if (vadInstance) {
                _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.log("[SayPi VAD Offscreen] Starting VAD...");
                vadInstance.start();
                return { success: true };
            }
            return { success: false, error: "VAD instance not available after init attempt." };
        }
        catch (error) {
            _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.reportError(error, { function: 'startVAD', tabId }, "Error starting VAD");
            return { success: false, error: error.message || "Unknown VAD start error" };
        }
    });
}
function stopVAD() {
    return __awaiter(this, void 0, void 0, function* () {
        if (vadInstance) {
            try {
                _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.log("[SayPi VAD Offscreen] Stopping VAD...");
                vadInstance.pause(); // Use pause, or destroy if it's a full stop
                return { success: true };
            }
            catch (error) {
                _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.reportError(error, { function: 'stopVAD' }, "Error stopping VAD");
                return { success: false, error: error.message || "Unknown VAD stop error" };
            }
        }
        return { success: false, error: "VAD not initialized or already stopped." };
    });
}
function destroyVAD() {
    _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.log("[SayPi VAD Offscreen] Destroying VAD...");
    if (vadInstance) {
        vadInstance.destroy();
        vadInstance = null;
    }
    if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
    }
    currentActiveTabId = null;
    return { success: true };
}
// Listen for messages from the background script
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    // Ensure messages are from the background script or an expected internal source if any
    // sender.id is the extension ID. For messages from background, sender.url might be undefined or background script URL
    // We are expecting messages forwarded by background.js which will have `message.origin === 'content-script'`
    // and `message.sourceTabId`
    if (message.origin !== "content-script" || message.sourceTabId === undefined) {
        // console.debug("[SayPi VAD Offscreen] Ignoring message not from content script via background:", message);
        return;
    }
    _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.debug("[SayPi VAD Offscreen] Received message from background:", message);
    const { type, options, sourceTabId } = message; // `sourceTabId` is the original tabId from content script
    let promise = null;
    switch (type) {
        case "VAD_INITIALIZE_REQUEST":
            promise = initializeVAD(options);
            break;
        case "VAD_START_REQUEST":
            promise = startVAD(sourceTabId);
            break;
        case "VAD_STOP_REQUEST":
            promise = stopVAD();
            break;
        case "VAD_DESTROY_REQUEST":
            // No async operation here, just a direct call
            sendResponse(destroyVAD());
            return false; // Indicate synchronous response for this specific case if sendResponse is used directly
        default:
            _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.warn("[SayPi VAD Offscreen] Unknown message type received:", type);
            sendResponse({ success: false, error: "Unknown message type" });
            return false;
    }
    if (promise) {
        promise.then(response => {
            // Send response back to the originating content script via background
            chrome.runtime.sendMessage({
                type: `OFFSCREEN_${type}_RESPONSE`,
                payload: response,
                targetTabId: sourceTabId, // ensure this is the original tabId
                origin: "offscreen-document",
            });
        }).catch(error => {
            _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.reportError(error, { function: 'onMessage Listener', messageType: type, tabId: sourceTabId }, "Error processing VAD request");
            chrome.runtime.sendMessage({
                type: `OFFSCREEN_${type}_ERROR`,
                payload: { success: false, error: error.message || "Unhandled promise rejection" },
                targetTabId: sourceTabId,
                origin: "offscreen-document",
            });
        });
        return true; // Indicate that sendResponse will be called asynchronously
    }
    return false; // Default to synchronous if no promise was handled
});

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOEJBQThCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsU0FBUztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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UTtnQkFDakIsV0FBVyxFQUFFLFdBQVcsRUFBRSxvQ0FBb0M7Z0JBQzlELE1BQU0sRUFBRSxvQkFBb0I7YUFDN0IsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ2YscURBQU0sQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLEVBQUUsUUFBUSxFQUFFLG9CQUFvQixFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxFQUFFLDhCQUE4QixDQUFDLENBQUM7WUFDckksTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUM7Z0JBQ3pCLElBQUksRUFBRSxhQUFhLElBQUksUUFBUTtnQkFDL0IsT0FBTyxFQUFFLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLE9BQU8sSUFBSSw2QkFBNkIsRUFBRTtnQkFDbEYsV0FBVyxFQUFFLFdBQVc7Z0JBQ3hCLE1BQU0sRUFBRSxvQkFBb0I7YUFDN0IsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDSCxPQUFPLElBQUksQ0FBQyxDQUFDLDJEQUEyRDtJQUMxRSxDQUFDO0lBQ0QsT0FBTyxLQUFLLENBQUMsQ0FBQyxtREFBbUQ7QUFDbkUsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL0ByaWNreTAxMjMvdmFkLXdlYi9kaXN0L2Fzc2V0LXBhdGguanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvZGlzdC9kZWZhdWx0LW1vZGVsLWZldGNoZXIuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvZGlzdC9mcmFtZS1wcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL0ByaWNreTAxMjMvdmFkLXdlYi9kaXN0L2xvZ2dpbmcuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvZGlzdC9tZXNzYWdlcy5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL0ByaWNreTAxMjMvdmFkLXdlYi9kaXN0L21vZGVscy9jb21tb24uanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvZGlzdC9tb2RlbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvZGlzdC9tb2RlbHMvbGVnYWN5LmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvQHJpY2t5MDEyMy92YWQtd2ViL2Rpc3QvbW9kZWxzL3Y1LmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvQHJpY2t5MDEyMy92YWQtd2ViL2Rpc3Qvbm9uLXJlYWwtdGltZS12YWQuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvZGlzdC9yZWFsLXRpbWUtdmFkLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvQHJpY2t5MDEyMy92YWQtd2ViL2Rpc3QvcmVzYW1wbGVyLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvQHJpY2t5MDEyMy92YWQtd2ViL2Rpc3QvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9iYWNrZW5kLWltcGwuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9iYWNrZW5kLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvQHJpY2t5MDEyMy92YWQtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvZW52LWltcGwuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9lbnYuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL0ByaWNreTAxMjMvdmFkLXdlYi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvbGliL2luZmVyZW5jZS1zZXNzaW9uLWltcGwuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL0ByaWNreTAxMjMvdmFkLXdlYi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvbGliL29ubngtdmFsdWUuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi90ZW5zb3ItaW1wbC5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL0ByaWNreTAxMjMvdmFkLXdlYi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvbGliL3RlbnNvci5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL0ByaWNreTAxMjMvdmFkLXdlYi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0LXdlYi5taW4uanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL3NyYy9Mb2dnaW5nTW9kdWxlLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9zcmMvYXVkaW8vQXVkaW9FbmNvZGVyLnRzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9zcmMvYXVkaW8vV2F2RW5jb2Rlci50cyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL3NyYy9vZmZzY3JlZW4vdmFkX29mZnNjcmVlbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmFzZUFzc2V0UGF0aCA9IHZvaWQgMDtcbi8vIG5leHRqc0AxNCBidW5kbGVyIG1heSBhdHRlbXB0IHRvIGV4ZWN1dGUgdGhpcyBkdXJpbmcgU1NSIGFuZCBjcmFzaFxuY29uc3QgaXNXZWIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5jb25zdCBjdXJyZW50U2NyaXB0ID0gaXNXZWJcbiAgICA/IHdpbmRvdy5kb2N1bWVudC5jdXJyZW50U2NyaXB0XG4gICAgOiBudWxsO1xubGV0IGJhc2VQYXRoID0gXCIvXCI7XG5pZiAoY3VycmVudFNjcmlwdCkge1xuICAgIGJhc2VQYXRoID0gY3VycmVudFNjcmlwdC5zcmNcbiAgICAgICAgLnJlcGxhY2UoLyMuKiQvLCBcIlwiKVxuICAgICAgICAucmVwbGFjZSgvXFw/LiokLywgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoL1xcL1teXFwvXSskLywgXCIvXCIpO1xufVxuZXhwb3J0cy5iYXNlQXNzZXRQYXRoID0gYmFzZVBhdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NldC1wYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0TW9kZWxGZXRjaGVyID0gdm9pZCAwO1xuY29uc3QgZGVmYXVsdE1vZGVsRmV0Y2hlciA9IChwYXRoKSA9PiB7XG4gICAgcmV0dXJuIGZldGNoKHBhdGgpLnRoZW4oKG1vZGVsKSA9PiBtb2RlbC5hcnJheUJ1ZmZlcigpKTtcbn07XG5leHBvcnRzLmRlZmF1bHRNb2RlbEZldGNoZXIgPSBkZWZhdWx0TW9kZWxGZXRjaGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdC1tb2RlbC1mZXRjaGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLypcblNvbWUgb2YgdGhpcyBjb2RlLCB0b2dldGhlciB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMgZm91bmQgaW4gaW5kZXgudHMsXG53ZXJlIHRha2VuIChvciB0b29rIGluc3BpcmF0aW9uKSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zbmFrZXJzNC9zaWxlcm8tdmFkXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GcmFtZVByb2Nlc3NvciA9IGV4cG9ydHMudmFsaWRhdGVPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0VjVGcmFtZVByb2Nlc3Nvck9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRMZWdhY3lGcmFtZVByb2Nlc3Nvck9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzXCIpO1xuY29uc3QgUkVDT01NRU5ERURfRlJBTUVfU0FNUExFUyA9IFs1MTIsIDEwMjQsIDE1MzZdO1xuZXhwb3J0cy5kZWZhdWx0TGVnYWN5RnJhbWVQcm9jZXNzb3JPcHRpb25zID0ge1xuICAgIHBvc2l0aXZlU3BlZWNoVGhyZXNob2xkOiAwLjUsXG4gICAgbmVnYXRpdmVTcGVlY2hUaHJlc2hvbGQ6IDAuNSAtIDAuMTUsXG4gICAgcHJlU3BlZWNoUGFkRnJhbWVzOiAxLFxuICAgIHJlZGVtcHRpb25GcmFtZXM6IDgsXG4gICAgZnJhbWVTYW1wbGVzOiAxNTM2LFxuICAgIG1pblNwZWVjaEZyYW1lczogMyxcbiAgICBzdWJtaXRVc2VyU3BlZWNoT25QYXVzZTogZmFsc2UsXG59O1xuZXhwb3J0cy5kZWZhdWx0VjVGcmFtZVByb2Nlc3Nvck9wdGlvbnMgPSB7XG4gICAgcG9zaXRpdmVTcGVlY2hUaHJlc2hvbGQ6IDAuNSxcbiAgICBuZWdhdGl2ZVNwZWVjaFRocmVzaG9sZDogMC41IC0gMC4xNSxcbiAgICBwcmVTcGVlY2hQYWRGcmFtZXM6IDMsXG4gICAgcmVkZW1wdGlvbkZyYW1lczogMjQsXG4gICAgZnJhbWVTYW1wbGVzOiA1MTIsXG4gICAgbWluU3BlZWNoRnJhbWVzOiA5LFxuICAgIHN1Ym1pdFVzZXJTcGVlY2hPblBhdXNlOiBmYWxzZSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmICghUkVDT01NRU5ERURfRlJBTUVfU0FNUExFUy5pbmNsdWRlcyhvcHRpb25zLmZyYW1lU2FtcGxlcykpIHtcbiAgICAgICAgbG9nZ2luZ18xLmxvZy53YXJuKFwiWW91IGFyZSB1c2luZyBhbiB1bnVzdWFsIGZyYW1lIHNpemVcIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnBvc2l0aXZlU3BlZWNoVGhyZXNob2xkIDwgMCB8fFxuICAgICAgICBvcHRpb25zLnBvc2l0aXZlU3BlZWNoVGhyZXNob2xkID4gMSkge1xuICAgICAgICBsb2dnaW5nXzEubG9nLmVycm9yKFwicG9zaXRpdmVTcGVlY2hUaHJlc2hvbGQgc2hvdWxkIGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVwiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubmVnYXRpdmVTcGVlY2hUaHJlc2hvbGQgPCAwIHx8XG4gICAgICAgIG9wdGlvbnMubmVnYXRpdmVTcGVlY2hUaHJlc2hvbGQgPiBvcHRpb25zLnBvc2l0aXZlU3BlZWNoVGhyZXNob2xkKSB7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2cuZXJyb3IoXCJuZWdhdGl2ZVNwZWVjaFRocmVzaG9sZCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCBwb3NpdGl2ZVNwZWVjaFRocmVzaG9sZFwiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucHJlU3BlZWNoUGFkRnJhbWVzIDwgMCkge1xuICAgICAgICBsb2dnaW5nXzEubG9nLmVycm9yKFwicHJlU3BlZWNoUGFkRnJhbWVzIHNob3VsZCBiZSBwb3NpdGl2ZVwiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVkZW1wdGlvbkZyYW1lcyA8IDApIHtcbiAgICAgICAgbG9nZ2luZ18xLmxvZy5lcnJvcihcInJlZGVtcHRpb25GcmFtZXMgc2hvdWxkIGJlIHBvc2l0aXZlXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVPcHRpb25zID0gdmFsaWRhdGVPcHRpb25zO1xuY29uc3QgY29uY2F0QXJyYXlzID0gKGFycmF5cykgPT4ge1xuICAgIGNvbnN0IHNpemVzID0gYXJyYXlzLnJlZHVjZSgob3V0LCBuZXh0KSA9PiB7XG4gICAgICAgIG91dC5wdXNoKG91dC5hdCgtMSkgKyBuZXh0Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfSwgWzBdKTtcbiAgICBjb25zdCBvdXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZXMuYXQoLTEpKTtcbiAgICBhcnJheXMuZm9yRWFjaCgoYXJyLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBwbGFjZSA9IHNpemVzW2luZGV4XTtcbiAgICAgICAgb3V0QXJyYXkuc2V0KGFyciwgcGxhY2UpO1xuICAgIH0pO1xuICAgIHJldHVybiBvdXRBcnJheTtcbn07XG5jbGFzcyBGcmFtZVByb2Nlc3NvciB7XG4gICAgY29uc3RydWN0b3IobW9kZWxQcm9jZXNzRnVuYywgbW9kZWxSZXNldEZ1bmMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tb2RlbFByb2Nlc3NGdW5jID0gbW9kZWxQcm9jZXNzRnVuYztcbiAgICAgICAgdGhpcy5tb2RlbFJlc2V0RnVuYyA9IG1vZGVsUmVzZXRGdW5jO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnNwZWFraW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVkZW1wdGlvbkNvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLnNwZWVjaEZyYW1lQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNwZWVjaFJlYWxTdGFydEZpcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVzZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNwZWFraW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNwZWVjaFJlYWxTdGFydEZpcmVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvQnVmZmVyID0gW107XG4gICAgICAgICAgICB0aGlzLm1vZGVsUmVzZXRGdW5jKCk7XG4gICAgICAgICAgICB0aGlzLnJlZGVtcHRpb25Db3VudGVyID0gMDtcbiAgICAgICAgICAgIHRoaXMuc3BlZWNoRnJhbWVDb3VudCA9IDA7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGF1c2UgPSAoaGFuZGxlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN1Ym1pdFVzZXJTcGVlY2hPblBhdXNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRTZWdtZW50KGhhbmRsZUV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXN1bWUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5kU2VnbWVudCA9IChoYW5kbGVFdmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXVkaW9CdWZmZXIgPSB0aGlzLmF1ZGlvQnVmZmVyO1xuICAgICAgICAgICAgdGhpcy5hdWRpb0J1ZmZlciA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgc3BlYWtpbmcgPSB0aGlzLnNwZWFraW5nO1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgaWYgKHNwZWFraW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BlZWNoRnJhbWVDb3VudCA9IGF1ZGlvQnVmZmVyLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmlzU3BlZWNoID8gKGFjYyArIDEpIDogYWNjO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIGlmIChzcGVlY2hGcmFtZUNvdW50ID49IHRoaXMub3B0aW9ucy5taW5TcGVlY2hGcmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXVkaW8gPSBjb25jYXRBcnJheXMoYXVkaW9CdWZmZXIubWFwKChpdGVtKSA9PiBpdGVtLmZyYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50KHsgbXNnOiBtZXNzYWdlc18xLk1lc3NhZ2UuU3BlZWNoRW5kLCBhdWRpbyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50KHsgbXNnOiBtZXNzYWdlc18xLk1lc3NhZ2UuVkFETWlzZmlyZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvY2VzcyA9IGFzeW5jIChmcmFtZSwgaGFuZGxlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9icyA9IGF3YWl0IHRoaXMubW9kZWxQcm9jZXNzRnVuYyhmcmFtZSk7XG4gICAgICAgICAgICBjb25zdCBpc1NwZWVjaCA9IHByb2JzLmlzU3BlZWNoID49IHRoaXMub3B0aW9ucy5wb3NpdGl2ZVNwZWVjaFRocmVzaG9sZDtcbiAgICAgICAgICAgIGhhbmRsZUV2ZW50KHsgcHJvYnMsIG1zZzogbWVzc2FnZXNfMS5NZXNzYWdlLkZyYW1lUHJvY2Vzc2VkLCBmcmFtZSB9KTtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9CdWZmZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgZnJhbWUsXG4gICAgICAgICAgICAgICAgaXNTcGVlY2gsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc1NwZWVjaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3BlZWNoRnJhbWVDb3VudCsrO1xuICAgICAgICAgICAgICAgIHRoaXMucmVkZW1wdGlvbkNvdW50ZXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3BlZWNoICYmICF0aGlzLnNwZWFraW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVha2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaGFuZGxlRXZlbnQoeyBtc2c6IG1lc3NhZ2VzXzEuTWVzc2FnZS5TcGVlY2hTdGFydCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNwZWFraW5nICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hGcmFtZUNvdW50ID09PSB0aGlzLm9wdGlvbnMubWluU3BlZWNoRnJhbWVzICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuc3BlZWNoUmVhbFN0YXJ0RmlyZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVjaFJlYWxTdGFydEZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBoYW5kbGVFdmVudCh7IG1zZzogbWVzc2FnZXNfMS5NZXNzYWdlLlNwZWVjaFJlYWxTdGFydCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9icy5pc1NwZWVjaCA8IHRoaXMub3B0aW9ucy5uZWdhdGl2ZVNwZWVjaFRocmVzaG9sZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3BlYWtpbmcgJiZcbiAgICAgICAgICAgICAgICArK3RoaXMucmVkZW1wdGlvbkNvdW50ZXIgPj0gdGhpcy5vcHRpb25zLnJlZGVtcHRpb25GcmFtZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZGVtcHRpb25Db3VudGVyID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVjaEZyYW1lQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuc3BlYWtpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVjaFJlYWxTdGFydEZpcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgYXVkaW9CdWZmZXIgPSB0aGlzLmF1ZGlvQnVmZmVyO1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9CdWZmZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzcGVlY2hGcmFtZUNvdW50ID0gYXVkaW9CdWZmZXIucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaXNTcGVlY2ggPyAoYWNjICsgMSkgOiBhY2M7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWVjaEZyYW1lQ291bnQgPj0gdGhpcy5vcHRpb25zLm1pblNwZWVjaEZyYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdWRpbyA9IGNvbmNhdEFycmF5cyhhdWRpb0J1ZmZlci5tYXAoKGl0ZW0pID0+IGl0ZW0uZnJhbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXZlbnQoeyBtc2c6IG1lc3NhZ2VzXzEuTWVzc2FnZS5TcGVlY2hFbmQsIGF1ZGlvIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXZlbnQoeyBtc2c6IG1lc3NhZ2VzXzEuTWVzc2FnZS5WQURNaXNmaXJlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5zcGVha2luZykge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmF1ZGlvQnVmZmVyLmxlbmd0aCA+IHRoaXMub3B0aW9ucy5wcmVTcGVlY2hQYWRGcmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdWRpb0J1ZmZlci5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVjaEZyYW1lQ291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmF1ZGlvQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG59XG5leHBvcnRzLkZyYW1lUHJvY2Vzc29yID0gRnJhbWVQcm9jZXNzb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcmFtZS1wcm9jZXNzb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldERlZmF1bHRSZWFsVGltZVZBRE9wdGlvbnMgPSBleHBvcnRzLk1pY1ZBRCA9IGV4cG9ydHMuREVGQVVMVF9NT0RFTCA9IGV4cG9ydHMuQXVkaW9Ob2RlVkFEID0gZXhwb3J0cy51dGlscyA9IGV4cG9ydHMuTm9uUmVhbFRpbWVWQUQgPSBleHBvcnRzLk1lc3NhZ2UgPSBleHBvcnRzLkZyYW1lUHJvY2Vzc29yID0gZXhwb3J0cy5kZWZhdWx0TW9kZWxGZXRjaGVyID0gZXhwb3J0cy5iYXNlQXNzZXRQYXRoID0gdm9pZCAwO1xudmFyIGFzc2V0X3BhdGhfMSA9IHJlcXVpcmUoXCIuL2Fzc2V0LXBhdGhcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJiYXNlQXNzZXRQYXRoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhc3NldF9wYXRoXzEuYmFzZUFzc2V0UGF0aDsgfSB9KTtcbnZhciBkZWZhdWx0X21vZGVsX2ZldGNoZXJfMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHQtbW9kZWwtZmV0Y2hlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRNb2RlbEZldGNoZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlZmF1bHRfbW9kZWxfZmV0Y2hlcl8xLmRlZmF1bHRNb2RlbEZldGNoZXI7IH0gfSk7XG52YXIgZnJhbWVfcHJvY2Vzc29yXzEgPSByZXF1aXJlKFwiLi9mcmFtZS1wcm9jZXNzb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGcmFtZVByb2Nlc3NvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJhbWVfcHJvY2Vzc29yXzEuRnJhbWVQcm9jZXNzb3I7IH0gfSk7XG52YXIgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5NZXNzYWdlOyB9IH0pO1xudmFyIG5vbl9yZWFsX3RpbWVfdmFkXzEgPSByZXF1aXJlKFwiLi9ub24tcmVhbC10aW1lLXZhZFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vblJlYWxUaW1lVkFEXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBub25fcmVhbF90aW1lX3ZhZF8xLk5vblJlYWxUaW1lVkFEOyB9IH0pO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZXhwb3J0cy51dGlscyA9IHtcbiAgICBhdWRpb0ZpbGVUb0FycmF5OiB1dGlsc18xLmF1ZGlvRmlsZVRvQXJyYXksXG4gICAgbWluRnJhbWVzRm9yVGFyZ2V0TVM6IHV0aWxzXzEubWluRnJhbWVzRm9yVGFyZ2V0TVMsXG4gICAgYXJyYXlCdWZmZXJUb0Jhc2U2NDogdXRpbHNfMS5hcnJheUJ1ZmZlclRvQmFzZTY0LFxuICAgIGVuY29kZVdBVjogdXRpbHNfMS5lbmNvZGVXQVYsXG59O1xudmFyIHJlYWxfdGltZV92YWRfMSA9IHJlcXVpcmUoXCIuL3JlYWwtdGltZS12YWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBdWRpb05vZGVWQURcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWxfdGltZV92YWRfMS5BdWRpb05vZGVWQUQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJERUZBVUxUX01PREVMXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFsX3RpbWVfdmFkXzEuREVGQVVMVF9NT0RFTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1pY1ZBRFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhbF90aW1lX3ZhZF8xLk1pY1ZBRDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldERlZmF1bHRSZWFsVGltZVZBRE9wdGlvbnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWxfdGltZV92YWRfMS5nZXREZWZhdWx0UmVhbFRpbWVWQURPcHRpb25zOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmxvZyA9IGV4cG9ydHMuTE9HX1BSRUZJWCA9IHZvaWQgMDtcbmV4cG9ydHMuTE9HX1BSRUZJWCA9IFwiW1ZBRF1cIjtcbmNvbnN0IGxldmVscyA9IFtcImVycm9yXCIsIFwiZGVidWdcIiwgXCJ3YXJuXCJdO1xuZnVuY3Rpb24gZ2V0TG9nKGxldmVsKSB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnNvbGVbbGV2ZWxdKGV4cG9ydHMuTE9HX1BSRUZJWCwgLi4uYXJncyk7XG4gICAgfTtcbn1cbmNvbnN0IF9sb2cgPSBsZXZlbHMucmVkdWNlKChhY2MsIGxldmVsKSA9PiB7XG4gICAgYWNjW2xldmVsXSA9IGdldExvZyhsZXZlbCk7XG4gICAgcmV0dXJuIGFjYztcbn0sIHt9KTtcbmV4cG9ydHMubG9nID0gX2xvZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lc3NhZ2UgPSB2b2lkIDA7XG52YXIgTWVzc2FnZTtcbihmdW5jdGlvbiAoTWVzc2FnZSkge1xuICAgIE1lc3NhZ2VbXCJBdWRpb0ZyYW1lXCJdID0gXCJBVURJT19GUkFNRVwiO1xuICAgIE1lc3NhZ2VbXCJTcGVlY2hTdGFydFwiXSA9IFwiU1BFRUNIX1NUQVJUXCI7XG4gICAgTWVzc2FnZVtcIlZBRE1pc2ZpcmVcIl0gPSBcIlZBRF9NSVNGSVJFXCI7XG4gICAgTWVzc2FnZVtcIlNwZWVjaEVuZFwiXSA9IFwiU1BFRUNIX0VORFwiO1xuICAgIE1lc3NhZ2VbXCJTcGVlY2hTdG9wXCJdID0gXCJTUEVFQ0hfU1RPUFwiO1xuICAgIE1lc3NhZ2VbXCJTcGVlY2hSZWFsU3RhcnRcIl0gPSBcIlNQRUVDSF9SRUFMX1NUQVJUXCI7XG4gICAgTWVzc2FnZVtcIkZyYW1lUHJvY2Vzc2VkXCJdID0gXCJGUkFNRV9QUk9DRVNTRURcIjtcbn0pKE1lc3NhZ2UgfHwgKGV4cG9ydHMuTWVzc2FnZSA9IE1lc3NhZ2UgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2lsZXJvVjUgPSBleHBvcnRzLlNpbGVyb0xlZ2FjeSA9IHZvaWQgMDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb21tb25cIiksIGV4cG9ydHMpO1xudmFyIGxlZ2FjeV8xID0gcmVxdWlyZShcIi4vbGVnYWN5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2lsZXJvTGVnYWN5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsZWdhY3lfMS5TaWxlcm9MZWdhY3k7IH0gfSk7XG52YXIgdjVfMSA9IHJlcXVpcmUoXCIuL3Y1XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2lsZXJvVjVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHY1XzEuU2lsZXJvVjU7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2lsZXJvTGVnYWN5ID0gdm9pZCAwO1xuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmdcIik7XG5jbGFzcyBTaWxlcm9MZWdhY3kge1xuICAgIGNvbnN0cnVjdG9yKG9ydEluc3RhbmNlLCBfc2Vzc2lvbiwgX2gsIF9jLCBfc3IpIHtcbiAgICAgICAgdGhpcy5vcnRJbnN0YW5jZSA9IG9ydEluc3RhbmNlO1xuICAgICAgICB0aGlzLl9zZXNzaW9uID0gX3Nlc3Npb247XG4gICAgICAgIHRoaXMuX2ggPSBfaDtcbiAgICAgICAgdGhpcy5fYyA9IF9jO1xuICAgICAgICB0aGlzLl9zciA9IF9zcjtcbiAgICAgICAgdGhpcy5yZXNldF9zdGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHplcm9lcyA9IEFycmF5KDIgKiA2NCkuZmlsbCgwKTtcbiAgICAgICAgICAgIHRoaXMuX2ggPSBuZXcgdGhpcy5vcnRJbnN0YW5jZS5UZW5zb3IoXCJmbG9hdDMyXCIsIHplcm9lcywgWzIsIDEsIDY0XSk7XG4gICAgICAgICAgICB0aGlzLl9jID0gbmV3IHRoaXMub3J0SW5zdGFuY2UuVGVuc29yKFwiZmxvYXQzMlwiLCB6ZXJvZXMsIFsyLCAxLCA2NF0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb2Nlc3MgPSBhc3luYyAoYXVkaW9GcmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdCA9IG5ldyB0aGlzLm9ydEluc3RhbmNlLlRlbnNvcihcImZsb2F0MzJcIiwgYXVkaW9GcmFtZSwgW1xuICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgYXVkaW9GcmFtZS5sZW5ndGgsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogdCxcbiAgICAgICAgICAgICAgICBoOiB0aGlzLl9oLFxuICAgICAgICAgICAgICAgIGM6IHRoaXMuX2MsXG4gICAgICAgICAgICAgICAgc3I6IHRoaXMuX3NyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG91dCA9IGF3YWl0IHRoaXMuX3Nlc3Npb24ucnVuKGlucHV0cyk7XG4gICAgICAgICAgICB0aGlzLl9oID0gb3V0W1wiaG5cIl07XG4gICAgICAgICAgICB0aGlzLl9jID0gb3V0W1wiY25cIl07XG4gICAgICAgICAgICBjb25zdCBbaXNTcGVlY2hdID0gb3V0W1wib3V0cHV0XCJdPy5kYXRhO1xuICAgICAgICAgICAgY29uc3Qgbm90U3BlZWNoID0gMSAtIGlzU3BlZWNoO1xuICAgICAgICAgICAgcmV0dXJuIHsgbm90U3BlZWNoLCBpc1NwZWVjaCB9O1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuU2lsZXJvTGVnYWN5ID0gU2lsZXJvTGVnYWN5O1xuX2EgPSBTaWxlcm9MZWdhY3k7XG5TaWxlcm9MZWdhY3kubmV3ID0gYXN5bmMgKG9ydEluc3RhbmNlLCBtb2RlbEZldGNoZXIpID0+IHtcbiAgICBsb2dnaW5nXzEubG9nLmRlYnVnKFwiaW5pdGlhbGl6aW5nIHZhZFwiKTtcbiAgICBjb25zdCBtb2RlbEFycmF5QnVmZmVyID0gYXdhaXQgbW9kZWxGZXRjaGVyKCk7XG4gICAgY29uc3QgX3Nlc3Npb24gPSBhd2FpdCBvcnRJbnN0YW5jZS5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZShtb2RlbEFycmF5QnVmZmVyKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgX3NyID0gbmV3IG9ydEluc3RhbmNlLlRlbnNvcihcImludDY0XCIsIFsxNjAwMG5dKTtcbiAgICBjb25zdCB6ZXJvZXMgPSBBcnJheSgyICogNjQpLmZpbGwoMCk7XG4gICAgY29uc3QgX2ggPSBuZXcgb3J0SW5zdGFuY2UuVGVuc29yKFwiZmxvYXQzMlwiLCB6ZXJvZXMsIFsyLCAxLCA2NF0pO1xuICAgIGNvbnN0IF9jID0gbmV3IG9ydEluc3RhbmNlLlRlbnNvcihcImZsb2F0MzJcIiwgemVyb2VzLCBbMiwgMSwgNjRdKTtcbiAgICBsb2dnaW5nXzEubG9nLmRlYnVnKFwidmFkIGlzIGluaXRpYWxpemVkXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gbmV3IF9hKG9ydEluc3RhbmNlLCBfc2Vzc2lvbiwgX2gsIF9jLCBfc3IpO1xuICAgIHJldHVybiBtb2RlbDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWdhY3kuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpbGVyb1Y1ID0gdm9pZCAwO1xuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4uL2xvZ2dpbmdcIik7XG5mdW5jdGlvbiBnZXROZXdTdGF0ZShvcnRJbnN0YW5jZSkge1xuICAgIGNvbnN0IHplcm9lcyA9IEFycmF5KDIgKiAxMjgpLmZpbGwoMCk7XG4gICAgcmV0dXJuIG5ldyBvcnRJbnN0YW5jZS5UZW5zb3IoXCJmbG9hdDMyXCIsIHplcm9lcywgWzIsIDEsIDEyOF0pO1xufVxuY2xhc3MgU2lsZXJvVjUge1xuICAgIGNvbnN0cnVjdG9yKF9zZXNzaW9uLCBfc3RhdGUsIF9zciwgb3J0SW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fc2Vzc2lvbiA9IF9zZXNzaW9uO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IF9zdGF0ZTtcbiAgICAgICAgdGhpcy5fc3IgPSBfc3I7XG4gICAgICAgIHRoaXMub3J0SW5zdGFuY2UgPSBvcnRJbnN0YW5jZTtcbiAgICAgICAgdGhpcy5yZXNldF9zdGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gZ2V0TmV3U3RhdGUodGhpcy5vcnRJbnN0YW5jZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvY2VzcyA9IGFzeW5jIChhdWRpb0ZyYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0ID0gbmV3IHRoaXMub3J0SW5zdGFuY2UuVGVuc29yKFwiZmxvYXQzMlwiLCBhdWRpb0ZyYW1lLCBbXG4gICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICBhdWRpb0ZyYW1lLmxlbmd0aCxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0ge1xuICAgICAgICAgICAgICAgIGlucHV0OiB0LFxuICAgICAgICAgICAgICAgIHN0YXRlOiB0aGlzLl9zdGF0ZSxcbiAgICAgICAgICAgICAgICBzcjogdGhpcy5fc3IsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0gYXdhaXQgdGhpcy5fc2Vzc2lvbi5ydW4oaW5wdXRzKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gb3V0W1wic3RhdGVOXCJdO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgW2lzU3BlZWNoXSA9IG91dFtcIm91dHB1dFwiXT8uZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IG5vdFNwZWVjaCA9IDEgLSBpc1NwZWVjaDtcbiAgICAgICAgICAgIHJldHVybiB7IG5vdFNwZWVjaCwgaXNTcGVlY2ggfTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlNpbGVyb1Y1ID0gU2lsZXJvVjU7XG5fYSA9IFNpbGVyb1Y1O1xuU2lsZXJvVjUubmV3ID0gYXN5bmMgKG9ydEluc3RhbmNlLCBtb2RlbEZldGNoZXIpID0+IHtcbiAgICBsb2dnaW5nXzEubG9nLmRlYnVnKFwiTG9hZGluZyBWQUQuLi5cIik7XG4gICAgY29uc3QgbW9kZWxBcnJheUJ1ZmZlciA9IGF3YWl0IG1vZGVsRmV0Y2hlcigpO1xuICAgIGNvbnN0IF9zZXNzaW9uID0gYXdhaXQgb3J0SW5zdGFuY2UuSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUobW9kZWxBcnJheUJ1ZmZlcik7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IF9zciA9IG5ldyBvcnRJbnN0YW5jZS5UZW5zb3IoXCJpbnQ2NFwiLCBbMTYwMDBuXSk7XG4gICAgY29uc3QgX3N0YXRlID0gZ2V0TmV3U3RhdGUob3J0SW5zdGFuY2UpO1xuICAgIGxvZ2dpbmdfMS5sb2cuZGVidWcoXCIuLi5maW5pc2hlZCBsb2FkaW5nIFZBRFwiKTtcbiAgICByZXR1cm4gbmV3IF9hKF9zZXNzaW9uLCBfc3RhdGUsIF9zciwgb3J0SW5zdGFuY2UpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXY1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vblJlYWxUaW1lVkFEID0gZXhwb3J0cy5kZWZhdWx0Tm9uUmVhbFRpbWVWQURPcHRpb25zID0gdm9pZCAwO1xuY29uc3Qgb3J0SW5zdGFuY2UgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIm9ubnhydW50aW1lLXdlYlwiKSk7XG5jb25zdCBhc3NldF9wYXRoXzEgPSByZXF1aXJlKFwiLi9hc3NldC1wYXRoXCIpO1xuY29uc3QgZGVmYXVsdF9tb2RlbF9mZXRjaGVyXzEgPSByZXF1aXJlKFwiLi9kZWZhdWx0LW1vZGVsLWZldGNoZXJcIik7XG5jb25zdCBmcmFtZV9wcm9jZXNzb3JfMSA9IHJlcXVpcmUoXCIuL2ZyYW1lLXByb2Nlc3NvclwiKTtcbmNvbnN0IG1lc3NhZ2VzXzEgPSByZXF1aXJlKFwiLi9tZXNzYWdlc1wiKTtcbmNvbnN0IG1vZGVsc18xID0gcmVxdWlyZShcIi4vbW9kZWxzXCIpO1xuY29uc3QgcmVzYW1wbGVyXzEgPSByZXF1aXJlKFwiLi9yZXNhbXBsZXJcIik7XG5leHBvcnRzLmRlZmF1bHROb25SZWFsVGltZVZBRE9wdGlvbnMgPSB7XG4gICAgLi4uZnJhbWVfcHJvY2Vzc29yXzEuZGVmYXVsdExlZ2FjeUZyYW1lUHJvY2Vzc29yT3B0aW9ucyxcbiAgICBvcnRDb25maWc6IHVuZGVmaW5lZCxcbiAgICBtb2RlbFVSTDogYXNzZXRfcGF0aF8xLmJhc2VBc3NldFBhdGggKyBcInNpbGVyb192YWRfbGVnYWN5Lm9ubnhcIixcbiAgICBtb2RlbEZldGNoZXI6IGRlZmF1bHRfbW9kZWxfZmV0Y2hlcl8xLmRlZmF1bHRNb2RlbEZldGNoZXIsXG59O1xuY2xhc3MgTm9uUmVhbFRpbWVWQUQge1xuICAgIHN0YXRpYyBhc3luYyBuZXcob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGZ1bGxPcHRpb25zID0ge1xuICAgICAgICAgICAgLi4uZXhwb3J0cy5kZWZhdWx0Tm9uUmVhbFRpbWVWQURPcHRpb25zLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgKDAsIGZyYW1lX3Byb2Nlc3Nvcl8xLnZhbGlkYXRlT3B0aW9ucykoZnVsbE9wdGlvbnMpO1xuICAgICAgICBpZiAoZnVsbE9wdGlvbnMub3J0Q29uZmlnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZ1bGxPcHRpb25zLm9ydENvbmZpZyhvcnRJbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWxGZXRjaGVyID0gKCkgPT4gZnVsbE9wdGlvbnMubW9kZWxGZXRjaGVyKGZ1bGxPcHRpb25zLm1vZGVsVVJMKTtcbiAgICAgICAgY29uc3QgbW9kZWwgPSBhd2FpdCBtb2RlbHNfMS5TaWxlcm9MZWdhY3kubmV3KG9ydEluc3RhbmNlLCBtb2RlbEZldGNoZXIpO1xuICAgICAgICBjb25zdCBmcmFtZVByb2Nlc3NvciA9IG5ldyBmcmFtZV9wcm9jZXNzb3JfMS5GcmFtZVByb2Nlc3Nvcihtb2RlbC5wcm9jZXNzLCBtb2RlbC5yZXNldF9zdGF0ZSwge1xuICAgICAgICAgICAgZnJhbWVTYW1wbGVzOiBmdWxsT3B0aW9ucy5mcmFtZVNhbXBsZXMsXG4gICAgICAgICAgICBwb3NpdGl2ZVNwZWVjaFRocmVzaG9sZDogZnVsbE9wdGlvbnMucG9zaXRpdmVTcGVlY2hUaHJlc2hvbGQsXG4gICAgICAgICAgICBuZWdhdGl2ZVNwZWVjaFRocmVzaG9sZDogZnVsbE9wdGlvbnMubmVnYXRpdmVTcGVlY2hUaHJlc2hvbGQsXG4gICAgICAgICAgICByZWRlbXB0aW9uRnJhbWVzOiBmdWxsT3B0aW9ucy5yZWRlbXB0aW9uRnJhbWVzLFxuICAgICAgICAgICAgcHJlU3BlZWNoUGFkRnJhbWVzOiBmdWxsT3B0aW9ucy5wcmVTcGVlY2hQYWRGcmFtZXMsXG4gICAgICAgICAgICBtaW5TcGVlY2hGcmFtZXM6IGZ1bGxPcHRpb25zLm1pblNwZWVjaEZyYW1lcyxcbiAgICAgICAgICAgIHN1Ym1pdFVzZXJTcGVlY2hPblBhdXNlOiBmdWxsT3B0aW9ucy5zdWJtaXRVc2VyU3BlZWNoT25QYXVzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGZyYW1lUHJvY2Vzc29yLnJlc3VtZSgpO1xuICAgICAgICBjb25zdCB2YWQgPSBuZXcgdGhpcyhtb2RlbEZldGNoZXIsIG9ydEluc3RhbmNlLCBmdWxsT3B0aW9ucywgZnJhbWVQcm9jZXNzb3IpO1xuICAgICAgICByZXR1cm4gdmFkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbEZldGNoZXIsIG9ydCwgb3B0aW9ucywgZnJhbWVQcm9jZXNzb3IpIHtcbiAgICAgICAgdGhpcy5tb2RlbEZldGNoZXIgPSBtb2RlbEZldGNoZXI7XG4gICAgICAgIHRoaXMub3J0ID0gb3J0O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmZyYW1lUHJvY2Vzc29yID0gZnJhbWVQcm9jZXNzb3I7XG4gICAgfVxuICAgIGFzeW5jICpydW4oaW5wdXRBdWRpbywgc2FtcGxlUmF0ZSkge1xuICAgICAgICBjb25zdCByZXNhbXBsZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgbmF0aXZlU2FtcGxlUmF0ZTogc2FtcGxlUmF0ZSxcbiAgICAgICAgICAgIHRhcmdldFNhbXBsZVJhdGU6IDE2MDAwLFxuICAgICAgICAgICAgdGFyZ2V0RnJhbWVTaXplOiB0aGlzLm9wdGlvbnMuZnJhbWVTYW1wbGVzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNhbXBsZXIgPSBuZXcgcmVzYW1wbGVyXzEuUmVzYW1wbGVyKHJlc2FtcGxlck9wdGlvbnMpO1xuICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICBsZXQgZW5kID0gMDtcbiAgICAgICAgbGV0IGZyYW1lSW5kZXggPSAwO1xuICAgICAgICBsZXQgbWVzc2FnZUNvbnRhaW5lciA9IFtdO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGZyYW1lIG9mIHJlc2FtcGxlci5zdHJlYW0oaW5wdXRBdWRpbykpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZnJhbWVQcm9jZXNzb3IucHJvY2VzcyhmcmFtZSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZUNvbnRhaW5lci5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBtZXNzYWdlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC5tc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLk1lc3NhZ2UuU3BlZWNoU3RhcnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IChmcmFtZUluZGV4ICogdGhpcy5vcHRpb25zLmZyYW1lU2FtcGxlcykgLyAxNjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuTWVzc2FnZS5TcGVlY2hFbmQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSAoKGZyYW1lSW5kZXggKyAxKSAqIHRoaXMub3B0aW9ucy5mcmFtZVNhbXBsZXMpIC8gMTY7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB7IGF1ZGlvOiBldmVudC5hdWRpbywgc3RhcnQsIGVuZCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBtc2csIGF1ZGlvIH0gPSB0aGlzLmZyYW1lUHJvY2Vzc29yLmVuZFNlZ21lbnQoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBtZXNzYWdlQ29udGFpbmVyLnB1c2goZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBtZXNzYWdlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50Lm1zZykge1xuICAgICAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5NZXNzYWdlLlNwZWVjaEVuZDpcbiAgICAgICAgICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW86IGV2ZW50LmF1ZGlvLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IChmcmFtZUluZGV4ICogdGhpcy5vcHRpb25zLmZyYW1lU2FtcGxlcykgLyAxNixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTm9uUmVhbFRpbWVWQUQgPSBOb25SZWFsVGltZVZBRDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vbi1yZWFsLXRpbWUtdmFkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF1ZGlvTm9kZVZBRCA9IGV4cG9ydHMuTWljVkFEID0gZXhwb3J0cy5nZXREZWZhdWx0UmVhbFRpbWVWQURPcHRpb25zID0gZXhwb3J0cy5vcnQgPSBleHBvcnRzLkRFRkFVTFRfTU9ERUwgPSB2b2lkIDA7XG5jb25zdCBvcnRJbnN0YW5jZSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwib25ueHJ1bnRpbWUtd2ViXCIpKTtcbmNvbnN0IGRlZmF1bHRfbW9kZWxfZmV0Y2hlcl8xID0gcmVxdWlyZShcIi4vZGVmYXVsdC1tb2RlbC1mZXRjaGVyXCIpO1xuY29uc3QgZnJhbWVfcHJvY2Vzc29yXzEgPSByZXF1aXJlKFwiLi9mcmFtZS1wcm9jZXNzb3JcIik7XG5jb25zdCBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzXCIpO1xuY29uc3QgbW9kZWxzXzEgPSByZXF1aXJlKFwiLi9tb2RlbHNcIik7XG5jb25zdCByZXNhbXBsZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc2FtcGxlclwiKTtcbmV4cG9ydHMuREVGQVVMVF9NT0RFTCA9IFwibGVnYWN5XCI7XG5leHBvcnRzLm9ydCA9IG9ydEluc3RhbmNlO1xuY29uc3Qgd29ya2xldEZpbGUgPSBcInZhZC53b3JrbGV0LmJ1bmRsZS5taW4uanNcIjtcbmNvbnN0IHNpbGVyb1Y1RmlsZSA9IFwic2lsZXJvX3ZhZF92NS5vbm54XCI7XG5jb25zdCBzaWxlcm9MZWdhY3lGaWxlID0gXCJzaWxlcm9fdmFkX2xlZ2FjeS5vbm54XCI7XG5jb25zdCBnZXREZWZhdWx0UmVhbFRpbWVWQURPcHRpb25zID0gKG1vZGVsKSA9PiB7XG4gICAgY29uc3QgZnJhbWVQcm9jZXNzb3JPcHRpb25zID0gbW9kZWwgPT09IFwidjVcIlxuICAgICAgICA/IGZyYW1lX3Byb2Nlc3Nvcl8xLmRlZmF1bHRWNUZyYW1lUHJvY2Vzc29yT3B0aW9uc1xuICAgICAgICA6IGZyYW1lX3Byb2Nlc3Nvcl8xLmRlZmF1bHRMZWdhY3lGcmFtZVByb2Nlc3Nvck9wdGlvbnM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZnJhbWVQcm9jZXNzb3JPcHRpb25zLFxuICAgICAgICBvbkZyYW1lUHJvY2Vzc2VkOiAocHJvYmFiaWxpdGllcywgZnJhbWUpID0+IHsgfSxcbiAgICAgICAgb25WQURNaXNmaXJlOiAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nLmRlYnVnKFwiVkFEIG1pc2ZpcmVcIik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3BlZWNoU3RhcnQ6ICgpID0+IHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2cuZGVidWcoXCJEZXRlY3RlZCBzcGVlY2ggc3RhcnRcIik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3BlZWNoRW5kOiAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nLmRlYnVnKFwiRGV0ZWN0ZWQgc3BlZWNoIGVuZFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TcGVlY2hSZWFsU3RhcnQ6ICgpID0+IHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2cuZGVidWcoXCJEZXRlY3RlZCByZWFsIHNwZWVjaCBzdGFydFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgYmFzZUFzc2V0UGF0aDogXCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0ByaWNreTAxMjMvdmFkLXdlYkBsYXRlc3QvZGlzdC9cIixcbiAgICAgICAgb25ueFdBU01CYXNlUGF0aDogXCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL29ubnhydW50aW1lLXdlYkAxLjE0LjAvZGlzdC9cIixcbiAgICAgICAgc3RyZWFtOiB1bmRlZmluZWQsXG4gICAgICAgIG9ydENvbmZpZzogdW5kZWZpbmVkLFxuICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgIHdvcmtsZXRPcHRpb25zOiB7fSxcbiAgICB9O1xufTtcbmV4cG9ydHMuZ2V0RGVmYXVsdFJlYWxUaW1lVkFET3B0aW9ucyA9IGdldERlZmF1bHRSZWFsVGltZVZBRE9wdGlvbnM7XG5jbGFzcyBNaWNWQUQge1xuICAgIHN0YXRpYyBhc3luYyBuZXcob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGZ1bGxPcHRpb25zID0ge1xuICAgICAgICAgICAgLi4uKDAsIGV4cG9ydHMuZ2V0RGVmYXVsdFJlYWxUaW1lVkFET3B0aW9ucykob3B0aW9ucy5tb2RlbCA/PyBleHBvcnRzLkRFRkFVTFRfTU9ERUwpLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgKDAsIGZyYW1lX3Byb2Nlc3Nvcl8xLnZhbGlkYXRlT3B0aW9ucykoZnVsbE9wdGlvbnMpO1xuICAgICAgICBsZXQgc3RyZWFtO1xuICAgICAgICBpZiAoZnVsbE9wdGlvbnMuc3RyZWFtID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICAgICAgICAgICAgYXVkaW86IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZnVsbE9wdGlvbnMuYWRkaXRpb25hbEF1ZGlvQ29uc3RyYWludHMsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgICAgICAgICAgICAgZWNob0NhbmNlbGxhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXV0b0dhaW5Db250cm9sOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBub2lzZVN1cHByZXNzaW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3RyZWFtID0gZnVsbE9wdGlvbnMuc3RyZWFtO1xuICAgICAgICBjb25zdCBhdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBuZXcgTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGUoYXVkaW9Db250ZXh0LCB7XG4gICAgICAgICAgICBtZWRpYVN0cmVhbTogc3RyZWFtLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYXVkaW9Ob2RlVkFEID0gYXdhaXQgQXVkaW9Ob2RlVkFELm5ldyhhdWRpb0NvbnRleHQsIGZ1bGxPcHRpb25zKTtcbiAgICAgICAgYXVkaW9Ob2RlVkFELnJlY2VpdmUoc291cmNlTm9kZSk7XG4gICAgICAgIHJldHVybiBuZXcgTWljVkFEKGZ1bGxPcHRpb25zLCBhdWRpb0NvbnRleHQsIHN0cmVhbSwgYXVkaW9Ob2RlVkFELCBzb3VyY2VOb2RlKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYXVkaW9Db250ZXh0LCBzdHJlYW0sIGF1ZGlvTm9kZVZBRCwgc291cmNlTm9kZSwgbGlzdGVuaW5nID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICB0aGlzLmF1ZGlvTm9kZVZBRCA9IGF1ZGlvTm9kZVZBRDtcbiAgICAgICAgdGhpcy5zb3VyY2VOb2RlID0gc291cmNlTm9kZTtcbiAgICAgICAgdGhpcy5saXN0ZW5pbmcgPSBsaXN0ZW5pbmc7XG4gICAgICAgIHRoaXMucGF1c2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvTm9kZVZBRC5wYXVzZSgpO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdGFydCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9Ob2RlVkFELnN0YXJ0KCk7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmluZyA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc291cmNlTm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvTm9kZVZBRC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dC5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMgPSAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgdGhpcy5hdWRpb05vZGVWQUQuc2V0RnJhbWVQcm9jZXNzb3JPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTWljVkFEID0gTWljVkFEO1xuY2xhc3MgQXVkaW9Ob2RlVkFEIHtcbiAgICBzdGF0aWMgYXN5bmMgbmV3KGN0eCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGZ1bGxPcHRpb25zID0ge1xuICAgICAgICAgICAgLi4uKDAsIGV4cG9ydHMuZ2V0RGVmYXVsdFJlYWxUaW1lVkFET3B0aW9ucykob3B0aW9ucy5tb2RlbCA/PyBleHBvcnRzLkRFRkFVTFRfTU9ERUwpLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgKDAsIGZyYW1lX3Byb2Nlc3Nvcl8xLnZhbGlkYXRlT3B0aW9ucykoZnVsbE9wdGlvbnMpO1xuICAgICAgICBleHBvcnRzLm9ydC5lbnYud2FzbS53YXNtUGF0aHMgPSBmdWxsT3B0aW9ucy5vbm54V0FTTUJhc2VQYXRoO1xuICAgICAgICBpZiAoZnVsbE9wdGlvbnMub3J0Q29uZmlnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZ1bGxPcHRpb25zLm9ydENvbmZpZyhleHBvcnRzLm9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWxGaWxlID0gZnVsbE9wdGlvbnMubW9kZWwgPT09IFwidjVcIiA/IHNpbGVyb1Y1RmlsZSA6IHNpbGVyb0xlZ2FjeUZpbGU7XG4gICAgICAgIGNvbnN0IG1vZGVsVVJMID0gZnVsbE9wdGlvbnMuYmFzZUFzc2V0UGF0aCArIG1vZGVsRmlsZTtcbiAgICAgICAgY29uc3QgbW9kZWxGYWN0b3J5ID0gZnVsbE9wdGlvbnMubW9kZWwgPT09IFwidjVcIiA/IG1vZGVsc18xLlNpbGVyb1Y1Lm5ldyA6IG1vZGVsc18xLlNpbGVyb0xlZ2FjeS5uZXc7XG4gICAgICAgIGxldCBtb2RlbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1vZGVsID0gYXdhaXQgbW9kZWxGYWN0b3J5KGV4cG9ydHMub3J0LCAoKSA9PiAoMCwgZGVmYXVsdF9tb2RlbF9mZXRjaGVyXzEuZGVmYXVsdE1vZGVsRmV0Y2hlcikobW9kZWxVUkwpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgbG9hZGluZyBtb2RlbCBmaWxlICR7bW9kZWxVUkx9YCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYW1lUHJvY2Vzc29yID0gbmV3IGZyYW1lX3Byb2Nlc3Nvcl8xLkZyYW1lUHJvY2Vzc29yKG1vZGVsLnByb2Nlc3MsIG1vZGVsLnJlc2V0X3N0YXRlLCB7XG4gICAgICAgICAgICBmcmFtZVNhbXBsZXM6IGZ1bGxPcHRpb25zLmZyYW1lU2FtcGxlcyxcbiAgICAgICAgICAgIHBvc2l0aXZlU3BlZWNoVGhyZXNob2xkOiBmdWxsT3B0aW9ucy5wb3NpdGl2ZVNwZWVjaFRocmVzaG9sZCxcbiAgICAgICAgICAgIG5lZ2F0aXZlU3BlZWNoVGhyZXNob2xkOiBmdWxsT3B0aW9ucy5uZWdhdGl2ZVNwZWVjaFRocmVzaG9sZCxcbiAgICAgICAgICAgIHJlZGVtcHRpb25GcmFtZXM6IGZ1bGxPcHRpb25zLnJlZGVtcHRpb25GcmFtZXMsXG4gICAgICAgICAgICBwcmVTcGVlY2hQYWRGcmFtZXM6IGZ1bGxPcHRpb25zLnByZVNwZWVjaFBhZEZyYW1lcyxcbiAgICAgICAgICAgIG1pblNwZWVjaEZyYW1lczogZnVsbE9wdGlvbnMubWluU3BlZWNoRnJhbWVzLFxuICAgICAgICAgICAgc3VibWl0VXNlclNwZWVjaE9uUGF1c2U6IGZ1bGxPcHRpb25zLnN1Ym1pdFVzZXJTcGVlY2hPblBhdXNlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYXVkaW9Ob2RlVkFEID0gbmV3IEF1ZGlvTm9kZVZBRChjdHgsIGZ1bGxPcHRpb25zLCBmcmFtZVByb2Nlc3Nvcik7XG4gICAgICAgIGF3YWl0IGF1ZGlvTm9kZVZBRC5zZXR1cEF1ZGlvTm9kZSgpO1xuICAgICAgICByZXR1cm4gYXVkaW9Ob2RlVkFEO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihjdHgsIG9wdGlvbnMsIGZyYW1lUHJvY2Vzc29yKSB7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmJ1ZmZlckluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wYXVzZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZnJhbWVQcm9jZXNzb3IucGF1c2UodGhpcy5oYW5kbGVGcmFtZVByb2Nlc3NvckV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdGFydCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZnJhbWVQcm9jZXNzb3IucmVzdW1lKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVjZWl2ZSA9IChub2RlKSA9PiB7XG4gICAgICAgICAgICBub2RlLmNvbm5lY3QodGhpcy5hdWRpb05vZGUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb2Nlc3NGcmFtZSA9IGFzeW5jIChmcmFtZSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5mcmFtZVByb2Nlc3Nvci5wcm9jZXNzKGZyYW1lLCB0aGlzLmhhbmRsZUZyYW1lUHJvY2Vzc29yRXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUZyYW1lUHJvY2Vzc29yRXZlbnQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXYubXNnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLk1lc3NhZ2UuRnJhbWVQcm9jZXNzZWQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkZyYW1lUHJvY2Vzc2VkKGV2LnByb2JzLCBldi5mcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5NZXNzYWdlLlNwZWVjaFN0YXJ0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25TcGVlY2hTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuTWVzc2FnZS5TcGVlY2hSZWFsU3RhcnQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vblNwZWVjaFJlYWxTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuTWVzc2FnZS5WQURNaXNmaXJlOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25WQURNaXNmaXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5NZXNzYWdlLlNwZWVjaEVuZDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uU3BlZWNoRW5kKGV2LmF1ZGlvKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1ZGlvTm9kZSBpbnN0YW5jZW9mIEF1ZGlvV29ya2xldE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvTm9kZS5wb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZXNfMS5NZXNzYWdlLlNwZWVjaFN0b3AsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmF1ZGlvTm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmdhaW5Ob2RlPy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0RnJhbWVQcm9jZXNzb3JPcHRpb25zID0gKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZnJhbWVQcm9jZXNzb3Iub3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZyYW1lUHJvY2Vzc29yLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZnJhbWVQcm9jZXNzb3IgPSBmcmFtZVByb2Nlc3NvcjtcbiAgICB9XG4gICAgYXN5bmMgc2V0dXBBdWRpb05vZGUoKSB7XG4gICAgICAgIGNvbnN0IGhhc0F1ZGlvV29ya2xldCA9IFwiYXVkaW9Xb3JrbGV0XCIgaW4gdGhpcy5jdHggJiYgdHlwZW9mIEF1ZGlvV29ya2xldE5vZGUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgaWYgKGhhc0F1ZGlvV29ya2xldCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3b3JrbGV0VVJMID0gdGhpcy5vcHRpb25zLmJhc2VBc3NldFBhdGggKyB3b3JrbGV0RmlsZTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmN0eC5hdWRpb1dvcmtsZXQuYWRkTW9kdWxlKHdvcmtsZXRVUkwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmtsZXRPcHRpb25zID0gdGhpcy5vcHRpb25zLndvcmtsZXRPcHRpb25zID8/IHt9O1xuICAgICAgICAgICAgICAgIHdvcmtsZXRPcHRpb25zLnByb2Nlc3Nvck9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLih3b3JrbGV0T3B0aW9ucy5wcm9jZXNzb3JPcHRpb25zID8/IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVTYW1wbGVzOiB0aGlzLm9wdGlvbnMuZnJhbWVTYW1wbGVzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb05vZGUgPSBuZXcgQXVkaW9Xb3JrbGV0Tm9kZSh0aGlzLmN0eCwgXCJ2YWQtaGVscGVyLXdvcmtsZXRcIiwgd29ya2xldE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9Ob2RlLnBvcnQub25tZXNzYWdlID0gYXN5bmMgKGV2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXYuZGF0YT8ubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLk1lc3NhZ2UuQXVkaW9GcmFtZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYnVmZmVyID0gZXYuZGF0YS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoZXYuZGF0YS5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShidWZmZXIpLnNldChuZXcgVWludDhBcnJheShldi5kYXRhLmRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJhbWUgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzRnJhbWUoZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQXVkaW9Xb3JrbGV0IHNldHVwIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIFNjcmlwdFByb2Nlc3NvclwiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbml0aWFsaXplIHJlc2FtcGxlciBmb3IgU2NyaXB0UHJvY2Vzc29yXG4gICAgICAgIHRoaXMucmVzYW1wbGVyID0gbmV3IHJlc2FtcGxlcl8xLlJlc2FtcGxlcih7XG4gICAgICAgICAgICBuYXRpdmVTYW1wbGVSYXRlOiB0aGlzLmN0eC5zYW1wbGVSYXRlLFxuICAgICAgICAgICAgdGFyZ2V0U2FtcGxlUmF0ZTogMTYwMDAsXG4gICAgICAgICAgICB0YXJnZXRGcmFtZVNpemU6IHRoaXMub3B0aW9ucy5mcmFtZVNhbXBsZXMgPz8gNDgwLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gU2NyaXB0UHJvY2Vzc29yXG4gICAgICAgIGNvbnN0IGJ1ZmZlclNpemUgPSA0MDk2OyAvLyBJbmNyZWFzZWQgZm9yIG1vcmUgc3RhYmxlIHByb2Nlc3NpbmdcbiAgICAgICAgdGhpcy5hdWRpb05vZGUgPSB0aGlzLmN0eC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoYnVmZmVyU2l6ZSwgMSwgMSk7XG4gICAgICAgIC8vIENyZWF0ZSBhIGdhaW4gbm9kZSB3aXRoIHplcm8gZ2FpbiB0byBoYW5kbGUgdGhlIGF1ZGlvIGNoYWluXG4gICAgICAgIHRoaXMuZ2Fpbk5vZGUgPSB0aGlzLmN0eC5jcmVhdGVHYWluKCk7XG4gICAgICAgIHRoaXMuZ2Fpbk5vZGUuZ2Fpbi52YWx1ZSA9IDA7XG4gICAgICAgIGxldCBwcm9jZXNzaW5nQXVkaW8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdWRpb05vZGUub25hdWRpb3Byb2Nlc3MgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3NpbmdBdWRpbylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBwcm9jZXNzaW5nQXVkaW8gPSB0cnVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IGUuaW5wdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gZS5vdXRwdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmZpbGwoMCk7XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0aHJvdWdoIHJlc2FtcGxlclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc2FtcGxlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmFtZXMgPSB0aGlzLnJlc2FtcGxlci5wcm9jZXNzKGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmcmFtZSBvZiBmcmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0ZyYW1lKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwcm9jZXNzaW5nIGF1ZGlvOlwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nQXVkaW8gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29ubmVjdCB0aGUgYXVkaW8gY2hhaW5cbiAgICAgICAgdGhpcy5hdWRpb05vZGUuY29ubmVjdCh0aGlzLmdhaW5Ob2RlKTtcbiAgICAgICAgdGhpcy5nYWluTm9kZS5jb25uZWN0KHRoaXMuY3R4LmRlc3RpbmF0aW9uKTtcbiAgICB9XG59XG5leHBvcnRzLkF1ZGlvTm9kZVZBRCA9IEF1ZGlvTm9kZVZBRDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWwtdGltZS12YWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlc2FtcGxlciA9IHZvaWQgMDtcbmNvbnN0IGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jbGFzcyBSZXNhbXBsZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5wcm9jZXNzID0gKGF1ZGlvRnJhbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dEZyYW1lcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzYW1wbGUgb2YgYXVkaW9GcmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRCdWZmZXIucHVzaChzYW1wbGUpO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmhhc0Vub3VnaERhdGFGb3JGcmFtZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dEZyYW1lID0gdGhpcy5nZW5lcmF0ZU91dHB1dEZyYW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dEZyYW1lcy5wdXNoKG91dHB1dEZyYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0RnJhbWVzO1xuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5uYXRpdmVTYW1wbGVSYXRlIDwgMTYwMDApIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2cuZXJyb3IoXCJuYXRpdmVTYW1wbGVSYXRlIGlzIHRvbyBsb3cuIFNob3VsZCBoYXZlIDE2MDAwID0gdGFyZ2V0U2FtcGxlUmF0ZSA8PSBuYXRpdmVTYW1wbGVSYXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXRCdWZmZXIgPSBbXTtcbiAgICB9XG4gICAgYXN5bmMgKnN0cmVhbShhdWRpb0lucHV0KSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2FtcGxlIG9mIGF1ZGlvSW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRCdWZmZXIucHVzaChzYW1wbGUpO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaGFzRW5vdWdoRGF0YUZvckZyYW1lKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRGcmFtZSA9IHRoaXMuZ2VuZXJhdGVPdXRwdXRGcmFtZSgpO1xuICAgICAgICAgICAgICAgIHlpZWxkIG91dHB1dEZyYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGhhc0Vub3VnaERhdGFGb3JGcmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5pbnB1dEJ1ZmZlci5sZW5ndGggKiB0aGlzLm9wdGlvbnMudGFyZ2V0U2FtcGxlUmF0ZSkgL1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm5hdGl2ZVNhbXBsZVJhdGUgPj1cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy50YXJnZXRGcmFtZVNpemUpO1xuICAgIH1cbiAgICBnZW5lcmF0ZU91dHB1dEZyYW1lKCkge1xuICAgICAgICBjb25zdCBvdXRwdXRGcmFtZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5vcHRpb25zLnRhcmdldEZyYW1lU2l6ZSk7XG4gICAgICAgIGxldCBvdXRwdXRJbmRleCA9IDA7XG4gICAgICAgIGxldCBpbnB1dEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKG91dHB1dEluZGV4IDwgdGhpcy5vcHRpb25zLnRhcmdldEZyYW1lU2l6ZSkge1xuICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICBsZXQgbnVtID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpbnB1dEluZGV4IDxcbiAgICAgICAgICAgICAgICBNYXRoLm1pbih0aGlzLmlucHV0QnVmZmVyLmxlbmd0aCwgKChvdXRwdXRJbmRleCArIDEpICogdGhpcy5vcHRpb25zLm5hdGl2ZVNhbXBsZVJhdGUpIC9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRhcmdldFNhbXBsZVJhdGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0QnVmZmVyW2lucHV0SW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbnVtKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlucHV0SW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dEZyYW1lW291dHB1dEluZGV4XSA9IHN1bSAvIG51bTtcbiAgICAgICAgICAgIG91dHB1dEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnB1dEJ1ZmZlciA9IHRoaXMuaW5wdXRCdWZmZXIuc2xpY2UoaW5wdXRJbmRleCk7XG4gICAgICAgIHJldHVybiBvdXRwdXRGcmFtZTtcbiAgICB9XG59XG5leHBvcnRzLlJlc2FtcGxlciA9IFJlc2FtcGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc2FtcGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXVkaW9GaWxlVG9BcnJheSA9IGV4cG9ydHMuZW5jb2RlV0FWID0gZXhwb3J0cy5hcnJheUJ1ZmZlclRvQmFzZTY0ID0gZXhwb3J0cy5taW5GcmFtZXNGb3JUYXJnZXRNUyA9IHZvaWQgMDtcbmZ1bmN0aW9uIG1pbkZyYW1lc0ZvclRhcmdldE1TKHRhcmdldER1cmF0aW9uLCBmcmFtZVNhbXBsZXMsIHNyID0gMTYwMDApIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKCh0YXJnZXREdXJhdGlvbiAqIHNyKSAvIDEwMDAgLyBmcmFtZVNhbXBsZXMpO1xufVxuZXhwb3J0cy5taW5GcmFtZXNGb3JUYXJnZXRNUyA9IG1pbkZyYW1lc0ZvclRhcmdldE1TO1xuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NChidWZmZXIpIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgY29uc3QgbGVuID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBiaW5hcnkgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBieXRlc1tpXTtcbiAgICAgICAgaWYgKGJ5dGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYmluYXJ5W2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EoYmluYXJ5LmpvaW4oXCJcIikpO1xufVxuZXhwb3J0cy5hcnJheUJ1ZmZlclRvQmFzZTY0ID0gYXJyYXlCdWZmZXJUb0Jhc2U2NDtcbi8qXG5UaGlzIHJlc3Qgb2YgdGhpcyB3YXMgbW9zdGx5IGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9saW50by1haS9XZWJWb2ljZVNES1xuKi9cbmZ1bmN0aW9uIGVuY29kZVdBVihzYW1wbGVzLCBmb3JtYXQgPSAzLCBzYW1wbGVSYXRlID0gMTYwMDAsIG51bUNoYW5uZWxzID0gMSwgYml0RGVwdGggPSAzMikge1xuICAgIHZhciBieXRlc1BlclNhbXBsZSA9IGJpdERlcHRoIC8gODtcbiAgICB2YXIgYmxvY2tBbGlnbiA9IG51bUNoYW5uZWxzICogYnl0ZXNQZXJTYW1wbGU7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig0NCArIHNhbXBsZXMubGVuZ3RoICogYnl0ZXNQZXJTYW1wbGUpO1xuICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgLyogUklGRiBpZGVudGlmaWVyICovXG4gICAgd3JpdGVTdHJpbmcodmlldywgMCwgXCJSSUZGXCIpO1xuICAgIC8qIFJJRkYgY2h1bmsgbGVuZ3RoICovXG4gICAgdmlldy5zZXRVaW50MzIoNCwgMzYgKyBzYW1wbGVzLmxlbmd0aCAqIGJ5dGVzUGVyU2FtcGxlLCB0cnVlKTtcbiAgICAvKiBSSUZGIHR5cGUgKi9cbiAgICB3cml0ZVN0cmluZyh2aWV3LCA4LCBcIldBVkVcIik7XG4gICAgLyogZm9ybWF0IGNodW5rIGlkZW50aWZpZXIgKi9cbiAgICB3cml0ZVN0cmluZyh2aWV3LCAxMiwgXCJmbXQgXCIpO1xuICAgIC8qIGZvcm1hdCBjaHVuayBsZW5ndGggKi9cbiAgICB2aWV3LnNldFVpbnQzMigxNiwgMTYsIHRydWUpO1xuICAgIC8qIHNhbXBsZSBmb3JtYXQgKHJhdykgKi9cbiAgICB2aWV3LnNldFVpbnQxNigyMCwgZm9ybWF0LCB0cnVlKTtcbiAgICAvKiBjaGFubmVsIGNvdW50ICovXG4gICAgdmlldy5zZXRVaW50MTYoMjIsIG51bUNoYW5uZWxzLCB0cnVlKTtcbiAgICAvKiBzYW1wbGUgcmF0ZSAqL1xuICAgIHZpZXcuc2V0VWludDMyKDI0LCBzYW1wbGVSYXRlLCB0cnVlKTtcbiAgICAvKiBieXRlIHJhdGUgKHNhbXBsZSByYXRlICogYmxvY2sgYWxpZ24pICovXG4gICAgdmlldy5zZXRVaW50MzIoMjgsIHNhbXBsZVJhdGUgKiBibG9ja0FsaWduLCB0cnVlKTtcbiAgICAvKiBibG9jayBhbGlnbiAoY2hhbm5lbCBjb3VudCAqIGJ5dGVzIHBlciBzYW1wbGUpICovXG4gICAgdmlldy5zZXRVaW50MTYoMzIsIGJsb2NrQWxpZ24sIHRydWUpO1xuICAgIC8qIGJpdHMgcGVyIHNhbXBsZSAqL1xuICAgIHZpZXcuc2V0VWludDE2KDM0LCBiaXREZXB0aCwgdHJ1ZSk7XG4gICAgLyogZGF0YSBjaHVuayBpZGVudGlmaWVyICovXG4gICAgd3JpdGVTdHJpbmcodmlldywgMzYsIFwiZGF0YVwiKTtcbiAgICAvKiBkYXRhIGNodW5rIGxlbmd0aCAqL1xuICAgIHZpZXcuc2V0VWludDMyKDQwLCBzYW1wbGVzLmxlbmd0aCAqIGJ5dGVzUGVyU2FtcGxlLCB0cnVlKTtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIC8vIFJhdyBQQ01cbiAgICAgICAgZmxvYXRUbzE2Qml0UENNKHZpZXcsIDQ0LCBzYW1wbGVzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvYXQzMih2aWV3LCA0NCwgc2FtcGxlcyk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLmVuY29kZVdBViA9IGVuY29kZVdBVjtcbmZ1bmN0aW9uIGludGVybGVhdmUoaW5wdXRMLCBpbnB1dFIpIHtcbiAgICB2YXIgbGVuZ3RoID0gaW5wdXRMLmxlbmd0aCArIGlucHV0Ui5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkobGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpbnB1dEluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4KytdID0gaW5wdXRMW2lucHV0SW5kZXhdO1xuICAgICAgICByZXN1bHRbaW5kZXgrK10gPSBpbnB1dFJbaW5wdXRJbmRleF07XG4gICAgICAgIGlucHV0SW5kZXgrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHdyaXRlRmxvYXQzMihvdXRwdXQsIG9mZnNldCwgaW5wdXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICBvdXRwdXQuc2V0RmxvYXQzMihvZmZzZXQsIGlucHV0W2ldLCB0cnVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmbG9hdFRvMTZCaXRQQ00ob3V0cHV0LCBvZmZzZXQsIGlucHV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKywgb2Zmc2V0ICs9IDIpIHtcbiAgICAgICAgdmFyIHMgPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgaW5wdXRbaV0pKTtcbiAgICAgICAgb3V0cHV0LnNldEludDE2KG9mZnNldCwgcyA8IDAgPyBzICogMHg4MDAwIDogcyAqIDB4N2ZmZiwgdHJ1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JpdGVTdHJpbmcodmlldywgb2Zmc2V0LCBzdHJpbmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIGksIHN0cmluZy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBhdWRpb0ZpbGVUb0FycmF5KGF1ZGlvRmlsZURhdGEpIHtcbiAgICBjb25zdCBjdHggPSBuZXcgT2ZmbGluZUF1ZGlvQ29udGV4dCgxLCAxLCA0NDEwMCk7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBsZXQgYXVkaW9CdWZmZXIgPSBudWxsO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZW5kXCIsIChldikgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXVkaW9EYXRhID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgIGN0eC5kZWNvZGVBdWRpb0RhdGEoYXVkaW9EYXRhLCAoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgYXVkaW9CdWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICAgICAgY3R4XG4gICAgICAgICAgICAgICAgICAgIC5zdGFydFJlbmRlcmluZygpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChyZW5kZXJlZEJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJlbmRlcmluZyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXMoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBSZW5kZXJpbmcgZmFpbGVkOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVycm9yIHdpdGggZGVjb2RpbmcgYXVkaW8gZGF0YTogJHtlfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYXVkaW9GaWxlRGF0YSk7XG4gICAgfSk7XG4gICAgaWYgKGF1ZGlvQnVmZmVyID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwic29tZSBzaGl0XCIpO1xuICAgIH1cbiAgICBsZXQgX2F1ZGlvQnVmZmVyID0gYXVkaW9CdWZmZXI7XG4gICAgbGV0IG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoX2F1ZGlvQnVmZmVyLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfYXVkaW9CdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBfYXVkaW9CdWZmZXIubnVtYmVyT2ZDaGFubmVsczsgaisrKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBvdXRbaV0gKz0gX2F1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKGopW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGF1ZGlvOiBvdXQsIHNhbXBsZVJhdGU6IF9hdWRpb0J1ZmZlci5zYW1wbGVSYXRlIH07XG59XG5leHBvcnRzLmF1ZGlvRmlsZVRvQXJyYXkgPSBhdWRpb0ZpbGVUb0FycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5jb25zdCBiYWNrZW5kcyA9IHt9O1xuY29uc3QgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5ID0gW107XG4vKipcbiAqIFJlZ2lzdGVyIGEgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIGFzIGEga2V5IHRvIGxvb2t1cCBhcyBhbiBleGVjdXRpb24gcHJvdmlkZXIuXG4gKiBAcGFyYW0gYmFja2VuZCAtIHRoZSBiYWNrZW5kIG9iamVjdC5cbiAqIEBwYXJhbSBwcmlvcml0eSAtIGFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgcHJpb3JpdHkgb2YgdGhlIGJhY2tlbmQuIEhpZ2hlciBudW1iZXIgbWVhbnMgaGlnaGVyIHByaW9yaXR5LiBpZiBwcmlvcml0eVxuICogPCAwLCBpdCB3aWxsIGJlIGNvbnNpZGVyZWQgYXMgYSAnYmV0YScgdmVyc2lvbiBhbmQgd2lsbCBub3QgYmUgdXNlZCBhcyBhIGZhbGxiYWNrIGJhY2tlbmQgYnkgZGVmYXVsdC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyQmFja2VuZCA9IChuYW1lLCBiYWNrZW5kLCBwcmlvcml0eSkgPT4ge1xuICAgIGlmIChiYWNrZW5kICYmIHR5cGVvZiBiYWNrZW5kLmluaXQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGJhY2tlbmQuY3JlYXRlU2Vzc2lvbkhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEJhY2tlbmQgPSBiYWNrZW5kc1tuYW1lXTtcbiAgICAgICAgaWYgKGN1cnJlbnRCYWNrZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJhY2tlbmRzW25hbWVdID0geyBiYWNrZW5kLCBwcmlvcml0eSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRCYWNrZW5kLnByaW9yaXR5ID4gcHJpb3JpdHkpIHtcbiAgICAgICAgICAgIC8vIHNhbWUgbmFtZSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgd2l0aCBhIGhpZ2hlciBwcmlvcml0eS4gc2tpcCByZWdpc3RlcmF0aW9uLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRCYWNrZW5kLnByaW9yaXR5ID09PSBwcmlvcml0eSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRCYWNrZW5kLmJhY2tlbmQgIT09IGJhY2tlbmQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWdpc3RlciBiYWNrZW5kIFwiJHtuYW1lfVwiIHVzaW5nIHByaW9yaXR5ICR7cHJpb3JpdHl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaW9yaXR5ID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChiYWNrZW5kc1tiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHlbaV1dLnByaW9yaXR5IDw9IHByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5zcGxpY2UoaSwgMCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkucHVzaChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIHZhbGlkIGJhY2tlbmQnKTtcbn07XG4vKipcbiAqIFJlc29sdmUgYmFja2VuZCBieSBzcGVjaWZpZWQgaGludHMuXG4gKlxuICogQHBhcmFtIGJhY2tlbmRIaW50cyAtIGEgbGlzdCBvZiBleGVjdXRpb24gcHJvdmlkZXIgbmFtZXMgdG8gbG9va3VwLiBJZiBvbWl0dGVkIHVzZSByZWdpc3RlcmVkIGJhY2tlbmRzIGFzIGxpc3QuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgYmFja2VuZC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmVCYWNrZW5kID0gYXN5bmMgKGJhY2tlbmRIaW50cykgPT4ge1xuICAgIGNvbnN0IGJhY2tlbmROYW1lcyA9IGJhY2tlbmRIaW50cy5sZW5ndGggPT09IDAgPyBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkgOiBiYWNrZW5kSGludHM7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgZm9yIChjb25zdCBiYWNrZW5kTmFtZSBvZiBiYWNrZW5kTmFtZXMpIHtcbiAgICAgICAgY29uc3QgYmFja2VuZEluZm8gPSBiYWNrZW5kc1tiYWNrZW5kTmFtZV07XG4gICAgICAgIGlmIChiYWNrZW5kSW5mbykge1xuICAgICAgICAgICAgaWYgKGJhY2tlbmRJbmZvLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhY2tlbmRJbmZvLmJhY2tlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiYWNrZW5kSW5mby5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIGN1cnJlbnQgYmFja2VuZCBpcyB1bmF2YWlsYWJsZTsgdHJ5IG5leHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzSW5pdGlhbGl6aW5nID0gISFiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0luaXRpYWxpemluZykge1xuICAgICAgICAgICAgICAgICAgICBiYWNrZW5kSW5mby5pbml0UHJvbWlzZSA9IGJhY2tlbmRJbmZvLmJhY2tlbmQuaW5pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgICAgICAgICAgICBiYWNrZW5kSW5mby5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhY2tlbmRJbmZvLmJhY2tlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNJbml0aWFsaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goeyBuYW1lOiBiYWNrZW5kTmFtZSwgZXJyOiBlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiYWNrZW5kSW5mby5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIGF2YWlsYWJsZSBiYWNrZW5kIGZvdW5kLiBFUlI6ICR7ZXJyb3JzLm1hcChlID0+IGBbJHtlLm5hbWV9XSAke2UuZXJyfWApLmpvaW4oJywgJyl9YCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja2VuZC1pbXBsLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuZXhwb3J0IHsgcmVnaXN0ZXJCYWNrZW5kIH0gZnJvbSAnLi9iYWNrZW5kLWltcGwnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja2VuZC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmV4cG9ydCBjbGFzcyBFbnZJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy53YXNtID0ge307XG4gICAgICAgIHRoaXMud2ViZ2wgPSB7fTtcbiAgICAgICAgdGhpcy5sb2dMZXZlbEludGVybmFsID0gJ3dhcm5pbmcnO1xuICAgIH1cbiAgICAvLyBUT0RPIHN0YW5kYWRpemUgdGhlIGdldHRlciBhbmQgc2V0dGVyIGNvbnZlbnRpb24gaW4gZW52IGZvciBvdGhlciBmaWVsZHMuXG4gICAgc2V0IGxvZ0xldmVsKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgWyd2ZXJib3NlJywgJ2luZm8nLCAnd2FybmluZycsICdlcnJvcicsICdmYXRhbCddLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nTGV2ZWxJbnRlcm5hbCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgbG9nTGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0xldmVsSW50ZXJuYWw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52LWltcGwuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5pbXBvcnQgeyBFbnZJbXBsIH0gZnJvbSAnLi9lbnYtaW1wbCc7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBhcyBhIGdsb2JhbCBzaW5nbGV0b24uXG4gKi9cbmV4cG9ydCBjb25zdCBlbnYgPSBuZXcgRW52SW1wbCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuLyoqXG4gKiAjIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSVxuICpcbiAqIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSSBpcyBhIHVuaWZpZWQgQVBJIGZvciBhbGwgSmF2YVNjcmlwdCB1c2FnZXMsIGluY2x1ZGluZyB0aGUgZm9sbG93aW5nIE5QTSBwYWNrYWdlczpcbiAqXG4gKiAtIFtvbm54cnVudGltZS1ub2RlXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS1ub2RlKVxuICogLSBbb25ueHJ1bnRpbWUtd2ViXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS13ZWIpXG4gKiAtIFtvbm54cnVudGltZS1yZWFjdC1uYXRpdmVdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL29ubnhydW50aW1lLXJlYWN0LW5hdGl2ZSlcbiAqXG4gKiBTZWUgYWxzbzpcbiAqIC0gW0dldCBTdGFydGVkXShodHRwczovL29ubnhydW50aW1lLmFpL2RvY3MvZ2V0LXN0YXJ0ZWQvd2l0aC1qYXZhc2NyaXB0Lmh0bWwpXG4gKiAtIFtJbmZlcmVuY2UgZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUtaW5mZXJlbmNlLWV4YW1wbGVzL3RyZWUvbWFpbi9qcylcbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuZXhwb3J0ICogZnJvbSAnLi9iYWNrZW5kJztcbmV4cG9ydCAqIGZyb20gJy4vZW52JztcbmV4cG9ydCAqIGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24nO1xuZXhwb3J0ICogZnJvbSAnLi90ZW5zb3InO1xuZXhwb3J0ICogZnJvbSAnLi9vbm54LXZhbHVlJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuaW1wb3J0IHsgcmVzb2x2ZUJhY2tlbmQgfSBmcm9tICcuL2JhY2tlbmQtaW1wbCc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuL3RlbnNvcic7XG5leHBvcnQgY2xhc3MgSW5mZXJlbmNlU2Vzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoaGFuZGxlcikge1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIH1cbiAgICBhc3luYyBydW4oZmVlZHMsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgZmV0Y2hlcyA9IHt9O1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgICAgICAvLyBjaGVjayBpbnB1dHNcbiAgICAgICAgaWYgKHR5cGVvZiBmZWVkcyAhPT0gJ29iamVjdCcgfHwgZmVlZHMgPT09IG51bGwgfHwgZmVlZHMgaW5zdGFuY2VvZiBUZW5zb3IgfHwgQXJyYXkuaXNBcnJheShmZWVkcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2ZlZWRzXFwnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgdXNlIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNGZXRjaGVzRW1wdHkgPSB0cnVlO1xuICAgICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggb3ZlcnJpZGUgaXMgYmVpbmcgdXNlZFxuICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoYXJnMSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgYXJndW1lbnRbMV06IGNhbm5vdCBiZSBudWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIGNhbm5vdCBiZSBhIFRlbnNvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnZmV0Y2hlc1xcJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gb3V0cHV0IG5hbWVzXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnZmV0Y2hlc1xcJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke25hbWV9LmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlY2lkZSB3aGV0aGVyIGFyZzEgaXMgZmV0Y2hlcyBvciBvcHRpb25zXG4gICAgICAgICAgICAgICAgLy8gaWYgYW55IG91dHB1dCBuYW1lIGlzIHByZXNlbnQgYW5kIGl0cyB2YWx1ZSBpcyB2YWxpZCBPbm54VmFsdWUsIHdlIGNvbnNpZGVyIGl0IGZldGNoZXNcbiAgICAgICAgICAgICAgICBsZXQgaXNGZXRjaGVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnMUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmcxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5vdXRwdXROYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnMUtleXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBhcmcxW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgPT09IG51bGwgfHwgdiBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRmV0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGZXRjaGVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaGVzW25hbWVdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNGZXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgJiYgYXJnMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBtdXN0IGJlIFxcJ2ZldGNoZXNcXCcgb3IgXFwnb3B0aW9uc1xcJy4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiBhbGwgaW5wdXRzIGFyZSBpbiBmZWVkXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmlucHV0TmFtZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmVlZHNbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCAnJHtuYW1lfScgaXMgbWlzc2luZyBpbiAnZmVlZHMnLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG5vIGZldGNoZXMgaXMgc3BlY2lmaWVkLCB3ZSB1c2UgdGhlIGZ1bGwgb3V0cHV0IG5hbWVzIGxpc3RcbiAgICAgICAgaWYgKGlzRmV0Y2hlc0VtcHR5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5vdXRwdXROYW1lcykge1xuICAgICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZlZWRzLCBmZXRjaGVzIGFuZCBvcHRpb25zIGFyZSBwcmVwYXJlZFxuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5oYW5kbGVyLnJ1bihmZWVkcywgZmV0Y2hlcywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IG5ldyBUZW5zb3IocmVzdWx0c1trZXldLnR5cGUsIHJlc3VsdHNba2V5XS5kYXRhLCByZXN1bHRzW2tleV0uZGltcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgLy8gZWl0aGVyIGxvYWQgZnJvbSBhIGZpbGUgb3IgYnVmZmVyXG4gICAgICAgIGxldCBmaWxlUGF0aE9yVWludDhBcnJheTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZmlsZVBhdGhPclVpbnQ4QXJyYXkgPSBhcmcwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0JyAmJiBhcmcxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZzAgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IGFyZzA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJnMCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICAgICAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBhcmcwIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhcmcwO1xuICAgICAgICAgICAgbGV0IGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IGJ5dGVMZW5ndGggPSBhcmcwLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgPSBhcmcxO1xuICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2J5dGVPZmZzZXRcXCcgbXVzdCBiZSBhbiBpbnRlZ2VyLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYnl0ZU9mZnNldCA+PSBidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVPZmZzZXQnIGlzIG91dCBvZiByYW5nZSBbMCwgJHtidWZmZXIuYnl0ZUxlbmd0aH0pLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBieXRlTGVuZ3RoID0gYXJnMC5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGggPSBhcmcyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJ5dGVMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnYnl0ZUxlbmd0aFxcJyBtdXN0IGJlIGFuIGludGVnZXIuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVMZW5ndGgnIGlzIG91dCBvZiByYW5nZSAoMCwgJHtidWZmZXIuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXR9XS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZzMgPT09ICdvYmplY3QnICYmIGFyZzMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmczO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmczICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnYnl0ZUxlbmd0aFxcJyBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlIFxcJ3BhdGhcXCcgb3IgXFwnYnVmZmVyXFwnLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBiYWNrZW5kIGhpbnRzXG4gICAgICAgIGNvbnN0IGVwcyA9IG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzIHx8IFtdO1xuICAgICAgICBjb25zdCBiYWNrZW5kSGludHMgPSBlcHMubWFwKGkgPT4gdHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSk7XG4gICAgICAgIGNvbnN0IGJhY2tlbmQgPSBhd2FpdCByZXNvbHZlQmFja2VuZChiYWNrZW5kSGludHMpO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gYXdhaXQgYmFja2VuZC5jcmVhdGVTZXNzaW9uSGFuZGxlcihmaWxlUGF0aE9yVWludDhBcnJheSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgSW5mZXJlbmNlU2Vzc2lvbihoYW5kbGVyKTtcbiAgICB9XG4gICAgc3RhcnRQcm9maWxpbmcoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlci5zdGFydFByb2ZpbGluZygpO1xuICAgIH1cbiAgICBlbmRQcm9maWxpbmcoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlci5lbmRQcm9maWxpbmcoKTtcbiAgICB9XG4gICAgZ2V0IGlucHV0TmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lcztcbiAgICB9XG4gICAgZ2V0IG91dHB1dE5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE5hbWVzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZmVyZW5jZS1zZXNzaW9uLWltcGwuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIGFzIEluZmVyZW5jZVNlc3Npb25JbXBsIH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjb25zdCBJbmZlcmVuY2VTZXNzaW9uID0gSW5mZXJlbmNlU2Vzc2lvbkltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZlcmVuY2Utc2Vzc2lvbi5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ubngtdmFsdWUuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5jb25zdCBpc0JpZ0ludDY0QXJyYXlBdmFpbGFibGUgPSB0eXBlb2YgQmlnSW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEJpZ0ludDY0QXJyYXkuZnJvbSA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IGlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUgPSB0eXBlb2YgQmlnVWludDY0QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBCaWdVaW50NjRBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nO1xuLy8gYSBydW50aW1lIG1hcCB0aGF0IG1hcHMgdHlwZSBzdHJpbmcgdG8gVHlwZWRBcnJheSBjb25zdHJ1Y3Rvci4gU2hvdWxkIG1hdGNoIFRlbnNvci5EYXRhVHlwZU1hcC5cbmNvbnN0IE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAgPSBuZXcgTWFwKFtcbiAgICBbJ2Zsb2F0MzInLCBGbG9hdDMyQXJyYXldLFxuICAgIFsndWludDgnLCBVaW50OEFycmF5XSxcbiAgICBbJ2ludDgnLCBJbnQ4QXJyYXldLFxuICAgIFsndWludDE2JywgVWludDE2QXJyYXldLFxuICAgIFsnaW50MTYnLCBJbnQxNkFycmF5XSxcbiAgICBbJ2ludDMyJywgSW50MzJBcnJheV0sXG4gICAgWydib29sJywgVWludDhBcnJheV0sXG4gICAgWydmbG9hdDY0JywgRmxvYXQ2NEFycmF5XSxcbiAgICBbJ3VpbnQzMicsIFVpbnQzMkFycmF5XSxcbl0pO1xuLy8gYSBydW50aW1lIG1hcCB0aGF0IG1hcHMgdHlwZSBzdHJpbmcgdG8gVHlwZWRBcnJheSBjb25zdHJ1Y3Rvci4gU2hvdWxkIG1hdGNoIFRlbnNvci5EYXRhVHlwZU1hcC5cbmNvbnN0IE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAgPSBuZXcgTWFwKFtcbiAgICBbRmxvYXQzMkFycmF5LCAnZmxvYXQzMiddLFxuICAgIFtVaW50OEFycmF5LCAndWludDgnXSxcbiAgICBbSW50OEFycmF5LCAnaW50OCddLFxuICAgIFtVaW50MTZBcnJheSwgJ3VpbnQxNiddLFxuICAgIFtJbnQxNkFycmF5LCAnaW50MTYnXSxcbiAgICBbSW50MzJBcnJheSwgJ2ludDMyJ10sXG4gICAgW0Zsb2F0NjRBcnJheSwgJ2Zsb2F0NjQnXSxcbiAgICBbVWludDMyQXJyYXksICd1aW50MzInXSxcbl0pO1xuaWYgKGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSkge1xuICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdpbnQ2NCcsIEJpZ0ludDY0QXJyYXkpO1xuICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEJpZ0ludDY0QXJyYXksICdpbnQ2NCcpO1xufVxuaWYgKGlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUpIHtcbiAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgndWludDY0JywgQmlnVWludDY0QXJyYXkpO1xuICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEJpZ1VpbnQ2NEFycmF5LCAndWludDY0Jyk7XG59XG4vKipcbiAqIGNhbGN1bGF0ZSBzaXplIGZyb20gZGltcy5cbiAqXG4gKiBAcGFyYW0gZGltcyB0aGUgZGltcyBhcnJheS4gTWF5IGJlIGFuIGlsbGVnYWwgaW5wdXQuXG4gKi9cbmNvbnN0IGNhbGN1bGF0ZVNpemUgPSAoZGltcykgPT4ge1xuICAgIGxldCBzaXplID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGltID0gZGltc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBkaW0gIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBkaW1zWyR7aX1dIG11c3QgYmUgYW4gaW50ZWdlciwgZ290OiAke2RpbX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGltIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGRpbXNbJHtpfV0gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBnb3Q6ICR7ZGltfWApO1xuICAgICAgICB9XG4gICAgICAgIHNpemUgKj0gZGltO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn07XG5leHBvcnQgY2xhc3MgVGVuc29yIHtcbiAgICBjb25zdHJ1Y3RvcihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGxldCB0eXBlO1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgbGV0IGRpbXM7XG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYXJnMCBpcyB0eXBlIG9yIGRhdGFcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIE92ZXJyaWRlOiBjb25zdHJ1Y3Rvcih0eXBlLCBkYXRhLCAuLi4pXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdHlwZSA9IGFyZzA7XG4gICAgICAgICAgICBkaW1zID0gYXJnMjtcbiAgICAgICAgICAgIGlmIChhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIHN0cmluZyB0ZW5zb3JcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBzdHJpbmcgdGVuc29yXFwncyBkYXRhIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGNoZWNrIHdoZXRoZXIgZXZlcnkgZWxlbWVudCBpbiB0aGUgYXJyYXkgaXMgc3RyaW5nOyB0aGlzIGlzIHRvbyBzbG93LiB3ZSBhc3N1bWUgaXQncyBjb3JyZWN0IGFuZFxuICAgICAgICAgICAgICAgIC8vIGVycm9yIHdpbGwgYmUgcG9wdWxhdGVkIGF0IGluZmVyZW5jZVxuICAgICAgICAgICAgICAgIGRhdGEgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbnVtZXJpYyB0ZW5zb3JcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLmdldChhcmcwKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZWRBcnJheUNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdGVuc29yIHR5cGU6ICR7YXJnMH0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSAnYXMgYW55JyBoZXJlIGJlY2F1c2UgVHlwZVNjcmlwdCdzIGNoZWNrIG9uIHR5cGUgb2YgJ1N1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMuZnJvbSgpJyBwcm9kdWNlc1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmNvcnJlY3QgcmVzdWx0cy5cbiAgICAgICAgICAgICAgICAgICAgLy8gJ3R5cGVkQXJyYXlDb25zdHJ1Y3Rvcicgc2hvdWxkIGJlIG9uZSBvZiB0aGUgdHlwZWQgYXJyYXkgcHJvdG90eXBlIG9iamVjdHMuXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0eXBlZEFycmF5Q29uc3RydWN0b3IuZnJvbShhcmcxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJnMSBpbnN0YW5jZW9mIHR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXJnMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgJHt0eXBlfSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiAke3R5cGVkQXJyYXlDb25zdHJ1Y3Rvcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKGRhdGEsIC4uLilcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBkaW1zID0gYXJnMTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBib29sZWFuW10gYW5kIHN0cmluZ1tdIGlzIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgIGlmIChhcmcwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUZW5zb3IgdHlwZSBjYW5ub3QgYmUgaW5mZXJyZWQgZnJvbSBhbiBlbXB0eSBhcnJheS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RFbGVtZW50VHlwZSA9IHR5cGVvZiBhcmcwWzBdO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEVsZW1lbnRUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBhcmcwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaXJzdEVsZW1lbnRUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdib29sJztcbiAgICAgICAgICAgICAgICAgICAgLy8gJ2FyZzAnIGlzIG9mIHR5cGUgJ2Jvb2xlYW5bXScuIFVpbnQ4QXJyYXkuZnJvbShib29sZWFuW10pIGFjdHVhbGx5IHdvcmtzLCBidXQgdHlwZXNjcmlwdCB0aGlua3MgdGhpcyBpc1xuICAgICAgICAgICAgICAgICAgICAvLyB3cm9uZyB0eXBlLiBXZSB1c2UgJ2FzIGFueScgdG8gbWFrZSBpdCBoYXBweS5cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShhcmcwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZWxlbWVudCB0eXBlIG9mIGRhdGEgYXJyYXk6ICR7Zmlyc3RFbGVtZW50VHlwZX0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRlbnNvciB0eXBlIGZyb20gVHlwZWRBcnJheVxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcHBlZFR5cGUgPSBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLmdldChhcmcwLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUgZm9yIHRlbnNvciBkYXRhOiAke2FyZzAuY29uc3RydWN0b3J9LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eXBlID0gbWFwcGVkVHlwZTtcbiAgICAgICAgICAgICAgICBkYXRhID0gYXJnMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0eXBlIGFuZCBkYXRhIGlzIHByb2Nlc3NlZCwgbm93IHByb2Nlc3NpbmcgZGltc1xuICAgICAgICBpZiAoZGltcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBhc3N1bWUgMS1EIHRlbnNvciBpZiBkaW1zIG9taXR0ZWRcbiAgICAgICAgICAgIGRpbXMgPSBbZGF0YS5sZW5ndGhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGRpbXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHRlbnNvclxcJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGVyZm9ybSBjaGVja1xuICAgICAgICBjb25zdCBzaXplID0gY2FsY3VsYXRlU2l6ZShkaW1zKTtcbiAgICAgICAgaWYgKHNpemUgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvcidzIHNpemUoJHtzaXplfSkgZG9lcyBub3QgbWF0Y2ggZGF0YSBsZW5ndGgoJHtkYXRhLmxlbmd0aH0pLmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGltcyA9IGRpbXM7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIGltYWdlIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIGJ1ZmZlciAtIEV4dHJhY3RlZCBpbWFnZSBidWZmZXIgZGF0YSAtIGFzc3VtaW5nIFJHQkEgZm9ybWF0XG4gICAgICogQHBhcmFtIGltYWdlRm9ybWF0IC0gaW5wdXQgaW1hZ2UgY29uZmlndXJhdGlvbiAtIHJlcXVpcmVkIGNvbmZpZ3VyYXRpb25zIGhlaWdodCwgd2lkdGgsIGZvcm1hdFxuICAgICAqIEBwYXJhbSB0ZW5zb3JGb3JtYXQgLSBvdXRwdXQgdGVuc29yIGNvbmZpZ3VyYXRpb24gLSBEZWZhdWx0IGlzIFJHQiBmb3JtYXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYnVmZmVyVG9UZW5zb3IoYnVmZmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBidWZmZXIgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaGVpZ2h0ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGhlaWdodCBhbmQgd2lkdGggbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBub3JtID0gb3B0aW9ucy5ub3JtO1xuICAgICAgICBsZXQgbm9ybU1lYW47XG4gICAgICAgIGxldCBub3JtQmlhcztcbiAgICAgICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLm1lYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybU1lYW4gPSAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub3JtTWVhbiA9IG5vcm0ubWVhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0uYmlhcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub3JtQmlhcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub3JtQmlhcyA9IG5vcm0uYmlhcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnMuYml0bWFwRm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJpdG1hcEZvcm1hdCA6ICdSR0JBJztcbiAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZSBpcyBSR0JBIHNpbmNlIGltYWdlZGF0YSBhbmQgSFRNTEltYWdlRWxlbWVudCB1c2VzIGl0XG4gICAgICAgIGNvbnN0IG91dHB1dGZvcm1hdCA9IG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgKG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRlbnNvckZvcm1hdCA6ICdSR0InKSA6XG4gICAgICAgICAgICAnUkdCJztcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaGVpZ2h0ICogd2lkdGg7XG4gICAgICAgIGNvbnN0IGZsb2F0MzJEYXRhID0gb3V0cHV0Zm9ybWF0ID09PSAnUkdCQScgPyBuZXcgRmxvYXQzMkFycmF5KG9mZnNldCAqIDQpIDogbmV3IEZsb2F0MzJBcnJheShvZmZzZXQgKiAzKTtcbiAgICAgICAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXG4gICAgICAgIGxldCBzdGVwID0gNCwgckltYWdlUG9pbnRlciA9IDAsIGdJbWFnZVBvaW50ZXIgPSAxLCBiSW1hZ2VQb2ludGVyID0gMiwgYUltYWdlUG9pbnRlciA9IDM7XG4gICAgICAgIGxldCByVGVuc29yUG9pbnRlciA9IDAsIGdUZW5zb3JQb2ludGVyID0gb2Zmc2V0LCBiVGVuc29yUG9pbnRlciA9IG9mZnNldCAqIDIsIGFUZW5zb3JQb2ludGVyID0gLTE7XG4gICAgICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgICAgICAgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCJykge1xuICAgICAgICAgICAgc3RlcCA9IDM7XG4gICAgICAgICAgICBySW1hZ2VQb2ludGVyID0gMDtcbiAgICAgICAgICAgIGdJbWFnZVBvaW50ZXIgPSAxO1xuICAgICAgICAgICAgYkltYWdlUG9pbnRlciA9IDI7XG4gICAgICAgICAgICBhSW1hZ2VQb2ludGVyID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIG91dHB1dCB0ZW5zb3IgZm9ybWF0XG4gICAgICAgIGlmIChvdXRwdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgICAgICAgICAgYVRlbnNvclBvaW50ZXIgPSBvZmZzZXQgKiAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcbiAgICAgICAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgICAgICAgIGJUZW5zb3JQb2ludGVyID0gb2Zmc2V0O1xuICAgICAgICAgICAgZ1RlbnNvclBvaW50ZXIgPSBvZmZzZXQgKiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ0JHUicpIHtcbiAgICAgICAgICAgIGJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgICAgICAgIGdUZW5zb3JQb2ludGVyID0gb2Zmc2V0O1xuICAgICAgICAgICAgclRlbnNvclBvaW50ZXIgPSBvZmZzZXQgKiAyO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2Zmc2V0OyBpKyssIHJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYkltYWdlUG9pbnRlciArPSBzdGVwLCBnSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGFJbWFnZVBvaW50ZXIgKz0gc3RlcCkge1xuICAgICAgICAgICAgZmxvYXQzMkRhdGFbclRlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW3JJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXMpIC8gbm9ybU1lYW47XG4gICAgICAgICAgICBmbG9hdDMyRGF0YVtnVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbZ0ltYWdlUG9pbnRlcl0gKyBub3JtQmlhcykgLyBub3JtTWVhbjtcbiAgICAgICAgICAgIGZsb2F0MzJEYXRhW2JUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlcltiSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzKSAvIG5vcm1NZWFuO1xuICAgICAgICAgICAgaWYgKGFUZW5zb3JQb2ludGVyICE9PSAtMSAmJiBhSW1hZ2VQb2ludGVyICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGZsb2F0MzJEYXRhW2FUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlclthSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzKSAvIG5vcm1NZWFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZsb2F0MzJBcnJheSAtPiBvcnQuVGVuc29yXG4gICAgICAgIGNvbnN0IG91dHB1dFRlbnNvciA9IG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnID8gbmV3IFRlbnNvcignZmxvYXQzMicsIGZsb2F0MzJEYXRhLCBbMSwgNCwgaGVpZ2h0LCB3aWR0aF0pIDpcbiAgICAgICAgICAgIG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBmbG9hdDMyRGF0YSwgWzEsIDMsIGhlaWdodCwgd2lkdGhdKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dFRlbnNvcjtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGZyb21JbWFnZShpbWFnZSwgb3B0aW9ucykge1xuICAgICAgICAvLyBjaGVja2luZyB0aGUgdHlwZSBvZiBpbWFnZSBvYmplY3RcbiAgICAgICAgY29uc3QgaXNIVE1MSW1hZ2VFbGUgPSB0eXBlb2YgKEhUTUxJbWFnZUVsZW1lbnQpICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGlzSW1hZ2VEYXRhRWxlID0gdHlwZW9mIChJbWFnZURhdGEpICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlRGF0YTtcbiAgICAgICAgY29uc3QgaXNJbWFnZUJpdG1hcCA9IHR5cGVvZiAoSW1hZ2VCaXRtYXApICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwO1xuICAgICAgICBjb25zdCBpc1VSTCA9IHR5cGVvZiAoU3RyaW5nKSAhPT0gJ3VuZGVmaW5lZCcgJiYgKGltYWdlIGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycpO1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgbGV0IHRlbnNvckNvbmZpZyA9IHt9O1xuICAgICAgICAvLyBmaWxsaW5nIGFuZCBjaGVja2luZyBpbWFnZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgICAgaWYgKGlzSFRNTEltYWdlRWxlKSB7XG4gICAgICAgICAgICAvLyBIVE1MSW1hZ2VFbGVtZW50IC0gaW1hZ2Ugb2JqZWN0IC0gZm9ybWF0IGlzIFJHQkEgYnkgZGVmYXVsdFxuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IGltYWdlLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZEhlaWdodCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZFdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5yZXNpemVkSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZyA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRlbnNvckZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBSR0JBIGZvciBIVE1MSW1hZ2VFbGVtZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcudGVuc29yRm9ybWF0ID0gJ1JHQkEnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhlaWdodCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaW5wdXQgY29uZmlnIGhlaWdodCBkb2VzblxcJ3QgbWF0Y2ggSFRNTEltYWdlRWxlbWVudCBoZWlnaHQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgd2lkdGggZG9lc25cXCd0IG1hdGNoIEhUTUxJbWFnZUVsZW1lbnQgd2lkdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcudGVuc29yRm9ybWF0ID0gJ1JHQkEnO1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICBwaXhlbHMyRENvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNJbWFnZURhdGFFbGUpIHtcbiAgICAgICAgICAgIC8vIEltYWdlRGF0YSAtIGltYWdlIG9iamVjdCAtIGZvcm1hdCBpcyBSR0JBIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgICAgIGxldCBoZWlnaHQ7XG4gICAgICAgICAgICBsZXQgd2lkdGg7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZFdpZHRoICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkSGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBvcHRpb25zLnJlc2l6ZWRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBvcHRpb25zLnJlc2l6ZWRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZyA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYml0bWFwRm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5iaXRtYXBGb3JtYXQgIT09IGZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBSR0JBIGZvciBJbWFnZURhdGEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy5iaXRtYXBGb3JtYXQgPSAnUkdCQSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLmJpdG1hcEZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbnNvckNvbmZpZy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0ZW5zb3JDb25maWcud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzMkRDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gaW1hZ2UuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0ltYWdlQml0bWFwKSB7XG4gICAgICAgICAgICAvLyBJbWFnZUJpdG1hcCAtIGltYWdlIG9iamVjdCAtIGZvcm1hdCBtdXN0IGJlIHByb3ZpZGVkIGJ5IHVzZXJcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGltYWdlIGNvbmZpZyB3aXRoIGZvcm1hdCBmb3IgSW1hZ2ViaXRtYXAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmJpdG1hcEZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgZGVmaW5lZCBmb3IgSW1hZ2VCaXRtYXAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICBwaXhlbHMyRENvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNpbmcgc3F1YXJlIGJyYWNrZXRzIHRvIGF2b2lkIFRTIGVycm9yIC0gdHlwZSAnbmV2ZXInXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhlaWdodCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaW5wdXQgY29uZmlnIGhlaWdodCBkb2VzblxcJ3QgbWF0Y2ggSW1hZ2VCaXRtYXAgaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzaW5nIHNxdWFyZSBicmFja2V0cyB0byBhdm9pZCBUUyBlcnJvciAtIHR5cGUgJ25ldmVyJ1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy53aWR0aCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGlucHV0IGNvbmZpZyB3aWR0aCBkb2VzblxcJ3QgbWF0Y2ggSW1hZ2VCaXRtYXAgd2lkdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRlbnNvci5idWZmZXJUb1RlbnNvcihkYXRhLCB0ZW5zb3JDb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNVUkwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIGlmICghaW1hZ2UgfHwgIWNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIG5ld0ltYWdlLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgICAgICAgICAgICAgbmV3SW1hZ2Uuc3JjID0gaW1hZ2U7XG4gICAgICAgICAgICAgICAgbmV3SW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBuZXdJbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IG5ld0ltYWdlLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UobmV3SW1hZ2UsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZyA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzaW5nIHNxdWFyZSBicmFja2V0cyB0byBhdm9pZCBUUyBlcnJvciAtIHR5cGUgJ25ldmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5oZWlnaHQgIT09IGNhbnZhcy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGlucHV0IGNvbmZpZyBoZWlnaHQgZG9lc25cXCd0IG1hdGNoIEltYWdlQml0bWFwIGhlaWdodCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyBzcXVhcmUgYnJhY2tldHMgdG8gYXZvaWQgVFMgZXJyb3IgLSB0eXBlICduZXZlcidcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy53aWR0aCAhPT0gY2FudmFzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgd2lkdGggZG9lc25cXCd0IG1hdGNoIEltYWdlQml0bWFwIHdpZHRoJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFRlbnNvci5idWZmZXJUb1RlbnNvcihpbWcuZGF0YSwgdGVuc29yQ29uZmlnKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBUZW5zb3IuYnVmZmVyVG9UZW5zb3IoZGF0YSwgdGVuc29yQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0ltYWdlRGF0YShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGxldCBpbWFnZTtcbiAgICAgICAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aCAmIGZvcm1hdFxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmRpbXNbM107XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmRpbXNbMl07XG4gICAgICAgICAgICBjb25zdCBjaGFubmVscyA9IHRoaXMuZGltc1sxXTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gKG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6ICdSR0InKSA6ICdSR0InO1xuICAgICAgICAgICAgY29uc3Qgbm9ybU1lYW4gPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyAoKChfYSA9IG9wdGlvbnMubm9ybSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lYW4pICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5vcm0ubWVhbiA6IDI1NSkgOiAyNTU7XG4gICAgICAgICAgICBjb25zdCBub3JtQmlhcyA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/ICgoKF9iID0gb3B0aW9ucy5ub3JtKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmlhcykgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubm9ybS5iaWFzIDogMCkgOiAwO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaGVpZ2h0ICogd2lkdGg7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIG91dHB1dCBjb25maWcgaGVpZ2h0IGRvZXNuXFwndCBtYXRjaCB0ZW5zb3IgaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy53aWR0aCAhPT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBvdXRwdXQgY29uZmlnIHdpZHRoIGRvZXNuXFwndCBtYXRjaCB0ZW5zb3Igd2lkdGgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgKGNoYW5uZWxzID09PSA0ICYmIG9wdGlvbnMuZm9ybWF0ICE9PSAnUkdCQScpIHx8XG4gICAgICAgICAgICAgICAgICAgIChjaGFubmVscyA9PT0gMyAmJiAob3B0aW9ucy5mb3JtYXQgIT09ICdSR0InICYmIG9wdGlvbnMuZm9ybWF0ICE9PSAnQkdSJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGVuc29yIGZvcm1hdCBkb2VzblxcJ3QgbWF0Y2ggaW5wdXQgdGVuc29yIGRpbXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSA0O1xuICAgICAgICAgICAgbGV0IHJJbWFnZVBvaW50ZXIgPSAwLCBnSW1hZ2VQb2ludGVyID0gMSwgYkltYWdlUG9pbnRlciA9IDIsIGFJbWFnZVBvaW50ZXIgPSAzO1xuICAgICAgICAgICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCwgZ1RlbnNvclBvaW50ZXIgPSBvZmZzZXQsIGJUZW5zb3JQb2ludGVyID0gb2Zmc2V0ICogMiwgYVRlbnNvclBvaW50ZXIgPSAtMTtcbiAgICAgICAgICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgICAgICAgICAgIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgICAgICAgICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgICAgICAgICAgIGdUZW5zb3JQb2ludGVyID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJUZW5zb3JQb2ludGVyID0gb2Zmc2V0ICogMjtcbiAgICAgICAgICAgICAgICBhVGVuc29yUG9pbnRlciA9IG9mZnNldCAqIDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgICAgICAgICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICAgICAgICAgICAgZ1RlbnNvclBvaW50ZXIgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgYlRlbnNvclBvaW50ZXIgPSBvZmZzZXQgKiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgICAgICAgICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgICAgICAgICAgIGJUZW5zb3JQb2ludGVyID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGdUZW5zb3JQb2ludGVyID0gb2Zmc2V0ICogMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltYWdlID0gcGl4ZWxzMkRDb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0ICogd2lkdGg7IHJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgZ0ltYWdlUG9pbnRlciArPSBzdGVwLCBiSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGFJbWFnZVBvaW50ZXIgKz0gc3RlcCwgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2UuZGF0YVtySW1hZ2VQb2ludGVyXSA9ICh0aGlzLmRhdGFbclRlbnNvclBvaW50ZXIrK10gLSBub3JtQmlhcykgKiBub3JtTWVhbjsgLy8gUiB2YWx1ZVxuICAgICAgICAgICAgICAgIGltYWdlLmRhdGFbZ0ltYWdlUG9pbnRlcl0gPSAodGhpcy5kYXRhW2dUZW5zb3JQb2ludGVyKytdIC0gbm9ybUJpYXMpICogbm9ybU1lYW47IC8vIEcgdmFsdWVcbiAgICAgICAgICAgICAgICBpbWFnZS5kYXRhW2JJbWFnZVBvaW50ZXJdID0gKHRoaXMuZGF0YVtiVGVuc29yUG9pbnRlcisrXSAtIG5vcm1CaWFzKSAqIG5vcm1NZWFuOyAvLyBCIHZhbHVlXG4gICAgICAgICAgICAgICAgaW1hZ2UuZGF0YVthSW1hZ2VQb2ludGVyXSA9XG4gICAgICAgICAgICAgICAgICAgIGFUZW5zb3JQb2ludGVyID09PSAtMSA/IDI1NSA6ICh0aGlzLmRhdGFbYVRlbnNvclBvaW50ZXIrK10gLSBub3JtQmlhcykgKiBub3JtTWVhbjsgLy8gQSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uXG4gICAgLy8gI3JlZ2lvbiB0ZW5zb3IgdXRpbGl0aWVzXG4gICAgcmVzaGFwZShkaW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKHRoaXMudHlwZSwgdGhpcy5kYXRhLCBkaW1zKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW5zb3ItaW1wbC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmltcG9ydCB7IFRlbnNvciBhcyBUZW5zb3JJbXBsIH0gZnJvbSAnLi90ZW5zb3ItaW1wbCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgVGVuc29yID0gVGVuc29ySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbnNvci5qcy5tYXAiLCIvKiFcbiogT05OWCBSdW50aW1lIFdlYiB2MS4xNC4wXG4qIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qL1xuIWZ1bmN0aW9uKHQsZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZShyZXF1aXJlKFwib25ueHJ1bnRpbWUtY29tbW9uXCIpKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgbj1cIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9lKHJlcXVpcmUoXCJvbm54cnVudGltZS1jb21tb25cIikpOmUodC5vcnQpO2Zvcih2YXIgciBpbiBuKShcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzOnQpW3JdPW5bcl19fShzZWxmLChfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18xNjcwX189PigoKT0+e3ZhciBfX3dlYnBhY2tfbW9kdWxlc19fPXszNDc0Oih0LGUsbik9Pnt2YXIgX3NjcmlwdERpcixyPShfc2NyaXB0RGlyPShfc2NyaXB0RGlyPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDApfHxcIi9pbmRleC5qc1wiLGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gJC5idWZmZXIhPUMmJkgoJC5idWZmZXIpLEZ9ZnVuY3Rpb24gcigpe3JldHVybiAkLmJ1ZmZlciE9QyYmSCgkLmJ1ZmZlciksTn1mdW5jdGlvbiBpKCl7cmV0dXJuICQuYnVmZmVyIT1DJiZIKCQuYnVmZmVyKSxMfWZ1bmN0aW9uIG8oKXtyZXR1cm4gJC5idWZmZXIhPUMmJkgoJC5idWZmZXIpLFJ9ZnVuY3Rpb24gYSgpe3JldHVybiAkLmJ1ZmZlciE9QyYmSCgkLmJ1ZmZlciksan12YXIgcyx1LGM7dD10fHx7fSxzfHwocz12b2lkIDAhPT10P3Q6e30pLHMucmVhZHk9bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7dT10LGM9ZX0pKTt2YXIgbCxwLGYsZCxoLGcsYj1PYmplY3QuYXNzaWduKHt9LHMpLG09XCIuL3RoaXMucHJvZ3JhbVwiLHk9KHQsZSk9Pnt0aHJvdyBlfSxfPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3csdj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpbXBvcnRTY3JpcHRzLHc9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLHg9cy5FTlZJUk9OTUVOVF9JU19QVEhSRUFEfHwhMSxUPVwiXCI7ZnVuY3Rpb24gUyh0KXtyZXR1cm4gcy5sb2NhdGVGaWxlP3MubG9jYXRlRmlsZSh0LFQpOlQrdH1pZih3KXtsZXQgZTtUPXY/big5MDgpLmRpcm5hbWUoVCkrXCIvXCI6XCIvL1wiLGc9KCk9PntofHwoZD1uKDEzODQpLGg9big5MDgpKX0sbD1mdW5jdGlvbih0LGUpe3JldHVybiBnKCksdD1oLm5vcm1hbGl6ZSh0KSxkLnJlYWRGaWxlU3luYyh0LGU/dm9pZCAwOlwidXRmOFwiKX0sZj10PT4oKHQ9bCh0LCEwKSkuYnVmZmVyfHwodD1uZXcgVWludDhBcnJheSh0KSksdCkscD0odCxlLG4pPT57ZygpLHQ9aC5ub3JtYWxpemUodCksZC5yZWFkRmlsZSh0LChmdW5jdGlvbih0LHIpe3Q/bih0KTplKHIuYnVmZmVyKX0pKX0sMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYobT1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLChmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiB1dCkpdGhyb3cgdH0pKSxwcm9jZXNzLm9uKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsKGZ1bmN0aW9uKHQpe3Rocm93IHR9KSkseT0odCxlKT0+e2lmKEooKSl0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPXQsZTtlIGluc3RhbmNlb2YgdXR8fFAoXCJleGl0aW5nIGR1ZSB0byBleGNlcHRpb246IFwiK2UpLHByb2Nlc3MuZXhpdCh0KX0scy5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifTt0cnl7ZT1uKDk5MjUpfWNhdGNoKHQpe3Rocm93IGNvbnNvbGUuZXJyb3IoJ1RoZSBcIndvcmtlcl90aHJlYWRzXCIgbW9kdWxlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBub2RlLmpzIGJ1aWxkIC0gcGVyaGFwcyBhIG5ld2VyIHZlcnNpb24gaXMgbmVlZGVkPycpLHR9bi5nLldvcmtlcj1lLldvcmtlcn1lbHNlKF98fHYpJiYodj9UPXNlbGYubG9jYXRpb24uaHJlZjpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihUPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxfc2NyaXB0RGlyJiYoVD1fc2NyaXB0RGlyKSxUPTAhPT1ULmluZGV4T2YoXCJibG9iOlwiKT9ULnN1YnN0cigwLFQucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIix3fHwobD10PT57dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBlLm9wZW4oXCJHRVRcIix0LCExKSxlLnNlbmQobnVsbCksZS5yZXNwb25zZVRleHR9LHYmJihmPXQ9Pnt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGUub3BlbihcIkdFVFwiLHQsITEpLGUucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixlLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoZS5yZXNwb25zZSl9KSxwPSh0LGUsbik9Pnt2YXIgcj1uZXcgWE1MSHR0cFJlcXVlc3Q7ci5vcGVuKFwiR0VUXCIsdCwhMCksci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLHIub25sb2FkPSgpPT57MjAwPT1yLnN0YXR1c3x8MD09ci5zdGF0dXMmJnIucmVzcG9uc2U/ZShyLnJlc3BvbnNlKTpuKCl9LHIub25lcnJvcj1uLHIuc2VuZChudWxsKX0pKTt3JiZcInVuZGVmaW5lZFwiPT10eXBlb2YgcGVyZm9ybWFuY2UmJihuLmcucGVyZm9ybWFuY2U9big2OTUzKS5wZXJmb3JtYW5jZSk7dmFyIE89Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxBPWNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO3cmJihnKCksTz10PT5kLndyaXRlU3luYygxLHQrXCJcXG5cIiksQT10PT5kLndyaXRlU3luYygyLHQrXCJcXG5cIikpO3ZhciBFLEk9cy5wcmludHx8TyxQPXMucHJpbnRFcnJ8fEE7T2JqZWN0LmFzc2lnbihzLGIpLGI9bnVsbCxzLnRoaXNQcm9ncmFtJiYobT1zLnRoaXNQcm9ncmFtKSxzLnF1aXQmJih5PXMucXVpdCkscy53YXNtQmluYXJ5JiYoRT1zLndhc21CaW5hcnkpO3ZhciBEPXMubm9FeGl0UnVudGltZXx8ITE7XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZpdChcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyICQsayxDLEYsTixMLFIsaixNPSExLFU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwO2Z1bmN0aW9uIFYodCxlLG4pe3ZhciByPShlPj4+PTApK247Zm9yKG49ZTt0W25dJiYhKG4+PXIpOykrK247aWYoMTY8bi1lJiZ0LmJ1ZmZlciYmVSlyZXR1cm4gVS5kZWNvZGUodC5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcj90LnNsaWNlKGUsbik6dC5zdWJhcnJheShlLG4pKTtmb3Iocj1cIlwiO2U8bjspe3ZhciBpPXRbZSsrXTtpZigxMjgmaSl7dmFyIG89NjMmdFtlKytdO2lmKDE5Mj09KDIyNCZpKSlyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzMSZpKTw8NnxvKTtlbHNle3ZhciBhPTYzJnRbZSsrXTs2NTUzNj4oaT0yMjQ9PSgyNDAmaSk/KDE1JmkpPDwxMnxvPDw2fGE6KDcmaSk8PDE4fG88PDEyfGE8PDZ8NjMmdFtlKytdKT9yKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGkpOihpLT02NTUzNixyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGk+PjEwLDU2MzIwfDEwMjMmaSkpfX1lbHNlIHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoaSl9cmV0dXJuIHJ9ZnVuY3Rpb24gQih0LGUpe3JldHVybih0Pj4+PTApP1YocigpLHQsZSk6XCJcIn1mdW5jdGlvbiB6KHQsZSxuLHIpe2lmKCEoMDxyKSlyZXR1cm4gMDt2YXIgaT1uPj4+PTA7cj1uK3ItMTtmb3IodmFyIG89MDtvPHQubGVuZ3RoOysrbyl7dmFyIGE9dC5jaGFyQ29kZUF0KG8pO2lmKDU1Mjk2PD1hJiY1NzM0Mz49YSYmKGE9NjU1MzYrKCgxMDIzJmEpPDwxMCl8MTAyMyZ0LmNoYXJDb2RlQXQoKytvKSksMTI3Pj1hKXtpZihuPj1yKWJyZWFrO2VbbisrPj4+MF09YX1lbHNle2lmKDIwNDc+PWEpe2lmKG4rMT49cilicmVhaztlW24rKz4+PjBdPTE5MnxhPj42fWVsc2V7aWYoNjU1MzU+PWEpe2lmKG4rMj49cilicmVhaztlW24rKz4+PjBdPTIyNHxhPj4xMn1lbHNle2lmKG4rMz49cilicmVhaztlW24rKz4+PjBdPTI0MHxhPj4xOCxlW24rKz4+PjBdPTEyOHxhPj4xMiY2M31lW24rKz4+PjBdPTEyOHxhPj42JjYzfWVbbisrPj4+MF09MTI4fDYzJmF9fXJldHVybiBlW24+Pj4wXT0wLG4taX1mdW5jdGlvbiBHKHQpe2Zvcih2YXIgZT0wLG49MDtuPHQubGVuZ3RoOysrbil7dmFyIHI9dC5jaGFyQ29kZUF0KG4pOzEyNz49cj9lKys6MjA0Nz49cj9lKz0yOjU1Mjk2PD1yJiY1NzM0Mz49cj8oZSs9NCwrK24pOmUrPTN9cmV0dXJuIGV9ZnVuY3Rpb24gSCh0KXtDPXQscy5IRUFQOD1GPW5ldyBJbnQ4QXJyYXkodCkscy5IRUFQMTY9bmV3IEludDE2QXJyYXkodCkscy5IRUFQMzI9TD1uZXcgSW50MzJBcnJheSh0KSxzLkhFQVBVOD1OPW5ldyBVaW50OEFycmF5KHQpLHMuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkodCkscy5IRUFQVTMyPVI9bmV3IFVpbnQzMkFycmF5KHQpLHMuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KHQpLHMuSEVBUEY2ND1qPW5ldyBGbG9hdDY0QXJyYXkodCl9eCYmKEM9cy5idWZmZXIpO3ZhciBXPXMuSU5JVElBTF9NRU1PUll8fDE2Nzc3MjE2O2lmKHgpJD1zLndhc21NZW1vcnksQz1zLmJ1ZmZlcjtlbHNlIGlmKHMud2FzbU1lbW9yeSkkPXMud2FzbU1lbW9yeTtlbHNlIGlmKCEoKCQ9bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpXLzY1NTM2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSkpLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSl0aHJvdyBQKFwicmVxdWVzdGVkIGEgc2hhcmVkIFdlYkFzc2VtYmx5Lk1lbW9yeSBidXQgdGhlIHJldHVybmVkIGJ1ZmZlciBpcyBub3QgYSBTaGFyZWRBcnJheUJ1ZmZlciwgaW5kaWNhdGluZyB0aGF0IHdoaWxlIHRoZSBicm93c2VyIGhhcyBTaGFyZWRBcnJheUJ1ZmZlciBpdCBkb2VzIG5vdCBoYXZlIFdlYkFzc2VtYmx5IHRocmVhZHMgc3VwcG9ydCAtIHlvdSBtYXkgbmVlZCB0byBzZXQgYSBmbGFnXCIpLHcmJmNvbnNvbGUubG9nKFwiKG9uIG5vZGUgeW91IG1heSBuZWVkOiAtLWV4cGVyaW1lbnRhbC13YXNtLXRocmVhZHMgLS1leHBlcmltZW50YWwtd2FzbS1idWxrLW1lbW9yeSBhbmQgYWxzbyB1c2UgYSByZWNlbnQgdmVyc2lvbilcIiksRXJyb3IoXCJiYWQgbWVtb3J5XCIpOyQmJihDPSQuYnVmZmVyKSxXPUMuYnl0ZUxlbmd0aCxIKEMpO3ZhciBxLFg9W10sWT1bXSxLPVtdLFo9W107ZnVuY3Rpb24gSigpe3JldHVybiBEfHwhMX1mdW5jdGlvbiBRKCl7dmFyIHQ9cy5wcmVSdW4uc2hpZnQoKTtYLnVuc2hpZnQodCl9dmFyIHR0LGV0PTAsbnQ9bnVsbCxydD1udWxsO2Z1bmN0aW9uIGl0KHQpe3Rocm93IHg/cG9zdE1lc3NhZ2Uoe2NtZDpcIm9uQWJvcnRcIixhcmc6dH0pOnMub25BYm9ydCYmcy5vbkFib3J0KHQpLFAodD1cIkFib3J0ZWQoXCIrdCtcIilcIiksTT0hMCx0PW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IodCtcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksYyh0KSx0fWZ1bmN0aW9uIG90KCl7cmV0dXJuIHR0LnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpfWZ1bmN0aW9uIGF0KCl7dmFyIHQ9dHQ7dHJ5e2lmKHQ9PXR0JiZFKXJldHVybiBuZXcgVWludDhBcnJheShFKTtpZihmKXJldHVybiBmKHQpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWNhdGNoKHQpe2l0KHQpfX10dD1cIm9ydC13YXNtLXRocmVhZGVkLndhc21cIixvdCgpfHwodHQ9Uyh0dCkpO3ZhciBzdD17fTtmdW5jdGlvbiB1dCh0KXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPVwiUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdChcIit0K1wiKVwiLHRoaXMuc3RhdHVzPXR9ZnVuY3Rpb24gY3QodCl7KHQ9ZHQuVmJbdF0pfHxpdCgpLGR0Lm1jKHQpfWZ1bmN0aW9uIGx0KHQpe3ZhciBlPWR0LkNjKCk7aWYoIWUpcmV0dXJuIDY7ZHQuYWMucHVzaChlKSxkdC5WYlt0LlViXT1lLGUuVWI9dC5VYjt2YXIgbj17Y21kOlwicnVuXCIsc3RhcnRfcm91dGluZTp0LkljLGFyZzp0LnpjLHB0aHJlYWRfcHRyOnQuVWJ9O3JldHVybiBlLiRiPSgpPT57bi50aW1lPXBlcmZvcm1hbmNlLm5vdygpLGUucG9zdE1lc3NhZ2Uobix0Lk5jKX0sZS5sb2FkZWQmJihlLiRiKCksZGVsZXRlIGUuJGIpLDB9ZnVuY3Rpb24gcHQodCl7aWYoeClyZXR1cm4gcXQoMSwxLHQpO0ooKXx8KGR0Lm9jKCkscy5vbkV4aXQmJnMub25FeGl0KHQpLE09ITApLHkodCxuZXcgdXQodCkpfWZ1bmN0aW9uIGZ0KHQsZSl7aWYoIWUmJngpdGhyb3cgYnQodCksXCJ1bndpbmRcIjtKKCl8fHh8fChtZSgpLGh0KEspLGJlKDApLHJlWzFdLmxlbmd0aCYmaWUoMSwxMCkscmVbMl0ubGVuZ3RoJiZpZSgyLDEwKSxkdC5vYygpKSxwdCh0KX12YXIgZHQ9e1liOltdLGFjOltdLHFjOltdLFZiOnt9LGZjOmZ1bmN0aW9uKCl7eCYmZHQuRWMoKX0sUGM6ZnVuY3Rpb24oKXt9LEVjOmZ1bmN0aW9uKCl7ZHQucmVjZWl2ZU9iamVjdFRyYW5zZmVyPWR0LkdjLGR0LnRocmVhZEluaXRUTFM9ZHQucGMsZHQuc2V0RXhpdFN0YXR1cz1kdC5uYyxEPSExfSxuYzpmdW5jdGlvbigpe30sb2M6ZnVuY3Rpb24oKXtmb3IodmFyIHQgb2YgT2JqZWN0LnZhbHVlcyhkdC5WYikpZHQubWModCk7Zm9yKHQgb2YgZHQuWWIpdC50ZXJtaW5hdGUoKTtkdC5ZYj1bXX0sbWM6ZnVuY3Rpb24odCl7dmFyIGU9dC5VYjtkZWxldGUgZHQuVmJbZV0sZHQuWWIucHVzaCh0KSxkdC5hYy5zcGxpY2UoZHQuYWMuaW5kZXhPZih0KSwxKSx0LlViPTAseGUoZSl9LEdjOmZ1bmN0aW9uKCl7fSxwYzpmdW5jdGlvbigpe2R0LnFjLmZvckVhY2goKHQ9PnQoKSkpfSxGYzpmdW5jdGlvbih0LGUpe3Qub25tZXNzYWdlPW49Pnt2YXIgcj0obj1uLmRhdGEpLmNtZDtpZih0LlViJiYoZHQuQmM9dC5VYiksbi50YXJnZXRUaHJlYWQmJm4udGFyZ2V0VGhyZWFkIT1kZSgpKXt2YXIgaT1kdC5WYltuLlFjXTtpP2kucG9zdE1lc3NhZ2UobixuLnRyYW5zZmVyTGlzdCk6UCgnSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIicrcisnXCIgdG8gdGFyZ2V0IHB0aHJlYWQgJytuLnRhcmdldFRocmVhZCtcIiwgYnV0IHRoYXQgdGhyZWFkIG5vIGxvbmdlciBleGlzdHMhXCIpfWVsc2VcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCI9PT1yP1Z0KG4ucXVldWUpOlwic3Bhd25UaHJlYWRcIj09PXI/bHQobik6XCJjbGVhbnVwVGhyZWFkXCI9PT1yP2N0KG4udGhyZWFkKTpcImtpbGxUaHJlYWRcIj09PXI/KG49bi50aHJlYWQscj1kdC5WYltuXSxkZWxldGUgZHQuVmJbbl0sci50ZXJtaW5hdGUoKSx4ZShuKSxkdC5hYy5zcGxpY2UoZHQuYWMuaW5kZXhPZihyKSwxKSxyLlViPTApOlwiY2FuY2VsVGhyZWFkXCI9PT1yP2R0LlZiW24udGhyZWFkXS5wb3N0TWVzc2FnZSh7Y21kOlwiY2FuY2VsXCJ9KTpcImxvYWRlZFwiPT09cj8odC5sb2FkZWQ9ITAsZSYmZSh0KSx0LiRiJiYodC4kYigpLGRlbGV0ZSB0LiRiKSk6XCJwcmludFwiPT09cj9JKFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJwcmludEVyclwiPT09cj9QKFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJhbGVydFwiPT09cj9hbGVydChcIlRocmVhZCBcIituLnRocmVhZElkK1wiOiBcIituLnRleHQpOlwic2V0aW1tZWRpYXRlXCI9PT1uLnRhcmdldD90LnBvc3RNZXNzYWdlKG4pOlwib25BYm9ydFwiPT09cj9zLm9uQWJvcnQmJnMub25BYm9ydChuLmFyZyk6ciYmUChcIndvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCBcIityKTtkdC5CYz12b2lkIDB9LHQub25lcnJvcj10PT57dGhyb3cgUChcIndvcmtlciBzZW50IGFuIGVycm9yISBcIit0LmZpbGVuYW1lK1wiOlwiK3QubGluZW5vK1wiOiBcIit0Lm1lc3NhZ2UpLHR9LHcmJih0Lm9uKFwibWVzc2FnZVwiLChmdW5jdGlvbihlKXt0Lm9ubWVzc2FnZSh7ZGF0YTplfSl9KSksdC5vbihcImVycm9yXCIsKGZ1bmN0aW9uKGUpe3Qub25lcnJvcihlKX0pKSx0Lm9uKFwiZGV0YWNoZWRFeGl0XCIsKGZ1bmN0aW9uKCl7fSkpKSx0LnBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkXCIsdXJsT3JCbG9iOnMubWFpblNjcmlwdFVybE9yQmxvYnx8X3NjcmlwdERpcix3YXNtTWVtb3J5OiQsd2FzbU1vZHVsZTprfSl9LHljOmZ1bmN0aW9uKCl7dmFyIHQ9UyhcIm9ydC13YXNtLXRocmVhZGVkLndvcmtlci5qc1wiKTtkdC5ZYi5wdXNoKG5ldyBXb3JrZXIodCkpfSxDYzpmdW5jdGlvbigpe3JldHVybiAwPT1kdC5ZYi5sZW5ndGgmJihkdC55YygpLGR0LkZjKGR0LlliWzBdKSksZHQuWWIucG9wKCl9fTtmdW5jdGlvbiBodCh0KXtmb3IoOzA8dC5sZW5ndGg7KXQuc2hpZnQoKShzKX1mdW5jdGlvbiBndCh0KXt2YXIgZT1BZSgpO3JldHVybiB0PXQoKSxFZShlKSx0fWZ1bmN0aW9uIGJ0KHQpe2lmKHgpcmV0dXJuIHF0KDIsMCx0KTt0cnl7ZnQodCl9Y2F0Y2godCl7dCBpbnN0YW5jZW9mIHV0fHxcInVud2luZFwiPT10fHx5KDEsdCl9fXMuUFRocmVhZD1kdCxzLmVzdGFibGlzaFN0YWNrU3BhY2U9ZnVuY3Rpb24oKXt2YXIgdD1kZSgpLGU9aSgpW3QrNDQ+PjI+Pj4wXTt0PWkoKVt0KzQ4Pj4yPj4+MF0sT2UoZSxlLXQpLEVlKGUpfTt2YXIgbXQ9W107ZnVuY3Rpb24geXQodCl7dmFyIGU9bXRbdF07cmV0dXJuIGV8fCh0Pj1tdC5sZW5ndGgmJihtdC5sZW5ndGg9dCsxKSxtdFt0XT1lPXEuZ2V0KHQpKSxlfXMuaW52b2tlRW50cnlQb2ludD1mdW5jdGlvbih0LGUpe3Q9eXQodCkoZSksSigpP2R0Lm5jKHQpOlRlKHQpfTt2YXIgX3QsdnQsd3Q9W10seHQ9MCxUdD0wO2Z1bmN0aW9uIFN0KHQpe3RoaXMuWmI9dCx0aGlzLlNiPXQtMjQsdGhpcy54Yz1mdW5jdGlvbih0KXtvKClbdGhpcy5TYis0Pj4yPj4+MF09dH0sdGhpcy5iYz1mdW5jdGlvbigpe3JldHVybiBvKClbdGhpcy5TYis0Pj4yPj4+MF19LHRoaXMud2M9ZnVuY3Rpb24odCl7bygpW3RoaXMuU2IrOD4+Mj4+PjBdPXR9LHRoaXMuRGM9ZnVuY3Rpb24oKXtyZXR1cm4gbygpW3RoaXMuU2IrOD4+Mj4+PjBdfSx0aGlzLnJjPWZ1bmN0aW9uKCl7aSgpW3RoaXMuU2I+PjI+Pj4wXT0wfSx0aGlzLmhjPWZ1bmN0aW9uKHQpe3Q9dD8xOjAsZSgpW3RoaXMuU2IrMTI+PjA+Pj4wXT10fSx0aGlzLnVjPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPWUoKVt0aGlzLlNiKzEyPj4wPj4+MF19LHRoaXMuaWM9ZnVuY3Rpb24odCl7dD10PzE6MCxlKClbdGhpcy5TYisxMz4+MD4+PjBdPXR9LHRoaXMua2M9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9ZSgpW3RoaXMuU2IrMTM+PjA+Pj4wXX0sdGhpcy5mYz1mdW5jdGlvbih0LGUpe3RoaXMuY2MoMCksdGhpcy54Yyh0KSx0aGlzLndjKGUpLHRoaXMucmMoKSx0aGlzLmhjKCExKSx0aGlzLmljKCExKX0sdGhpcy5zYz1mdW5jdGlvbigpe0F0b21pY3MuYWRkKGkoKSx0aGlzLlNiPj4yLDEpfSx0aGlzLkhjPWZ1bmN0aW9uKCl7cmV0dXJuIDE9PT1BdG9taWNzLnN1YihpKCksdGhpcy5TYj4+MiwxKX0sdGhpcy5jYz1mdW5jdGlvbih0KXtvKClbdGhpcy5TYisxNj4+Mj4+PjBdPXR9LHRoaXMudGM9ZnVuY3Rpb24oKXtyZXR1cm4gbygpW3RoaXMuU2IrMTY+PjI+Pj4wXX0sdGhpcy52Yz1mdW5jdGlvbigpe2lmKERlKHRoaXMuYmMoKSkpcmV0dXJuIG8oKVt0aGlzLlpiPj4yPj4+MF07dmFyIHQ9dGhpcy50YygpO3JldHVybiAwIT09dD90OnRoaXMuWmJ9fWZ1bmN0aW9uIE90KHQpe3JldHVybiBnZShuZXcgU3QodCkuU2IpfWZ1bmN0aW9uIEF0KHQsZSxuLHIpe3JldHVybiB4P3F0KDMsMSx0LGUsbixyKTpFdCh0LGUsbixyKX1mdW5jdGlvbiBFdCh0LGUsbixyKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIpcmV0dXJuIFAoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciBpPVtdO3JldHVybiB4JiYwPT09aS5sZW5ndGg/QXQodCxlLG4scik6KHQ9e0ljOm4sVWI6dCx6YzpyLE5jOml9LHg/KHQuT2M9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKHQsaSksMCk6bHQodCkpfWZ1bmN0aW9uIEl0KHQsZSxuKXtyZXR1cm4geD9xdCg0LDEsdCxlLG4pOjB9ZnVuY3Rpb24gUHQodCxlKXtpZih4KXJldHVybiBxdCg1LDEsdCxlKX1mdW5jdGlvbiBEdCh0LGUpe2lmKHgpcmV0dXJuIHF0KDYsMSx0LGUpfWZ1bmN0aW9uICR0KHQsZSxuKXtpZih4KXJldHVybiBxdCg3LDEsdCxlLG4pfWZ1bmN0aW9uIGt0KHQsZSxuKXtyZXR1cm4geD9xdCg4LDEsdCxlLG4pOjB9ZnVuY3Rpb24gQ3QodCxlKXtpZih4KXJldHVybiBxdCg5LDEsdCxlKX1mdW5jdGlvbiBGdCh0LGUsbil7aWYoeClyZXR1cm4gcXQoMTAsMSx0LGUsbil9ZnVuY3Rpb24gTnQodCxlLG4scil7aWYoeClyZXR1cm4gcXQoMTEsMSx0LGUsbixyKX1mdW5jdGlvbiBMdCh0LGUsbixyKXtpZih4KXJldHVybiBxdCgxMiwxLHQsZSxuLHIpfWZ1bmN0aW9uIFJ0KHQsZSxuLHIpe2lmKHgpcmV0dXJuIHF0KDEzLDEsdCxlLG4scil9ZnVuY3Rpb24ganQodCl7aWYoeClyZXR1cm4gcXQoMTQsMSx0KX1mdW5jdGlvbiBNdCh0LGUpe2lmKHgpcmV0dXJuIHF0KDE1LDEsdCxlKX1mdW5jdGlvbiBVdCh0LGUsbil7aWYoeClyZXR1cm4gcXQoMTYsMSx0LGUsbil9ZnVuY3Rpb24gVnQodCl7QXRvbWljcy5zdG9yZShpKCksdD4+MiwxKSxkZSgpJiZ3ZSh0KSxBdG9taWNzLmNvbXBhcmVFeGNoYW5nZShpKCksdD4+MiwxLDApfWZ1bmN0aW9uIEJ0KHQpe3JldHVybiBvKClbdD4+PjJdKzQyOTQ5NjcyOTYqaSgpW3QrND4+PjJdfWZ1bmN0aW9uIHp0KHQsZSxuLHIsaSxvKXtyZXR1cm4geD9xdCgxNywxLHQsZSxuLHIsaSxvKTotNTJ9ZnVuY3Rpb24gR3QodCxlLG4scixpLG8pe2lmKHgpcmV0dXJuIHF0KDE4LDEsdCxlLG4scixpLG8pfWZ1bmN0aW9uIEh0KHQpe3ZhciBuPUcodCkrMSxyPWhlKG4pO3JldHVybiByJiZ6KHQsZSgpLHIsbikscn1mdW5jdGlvbiBXdCh0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4odD10LnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLykpP3RbMV06XCJHTVRcIn1pZih4KXJldHVybiBxdCgxOSwxLHQsZSxuKTt2YXIgYT0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCkscz1uZXcgRGF0ZShhLDAsMSksdT1uZXcgRGF0ZShhLDYsMSk7YT1zLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGM9dS5nZXRUaW1lem9uZU9mZnNldCgpLGw9TWF0aC5tYXgoYSxjKTtpKClbdD4+Mj4+PjBdPTYwKmwsaSgpW2U+PjI+Pj4wXT1OdW1iZXIoYSE9YyksdD1yKHMpLGU9cih1KSx0PUh0KHQpLGU9SHQoZSksYzxhPyhvKClbbj4+Mj4+PjBdPXQsbygpW24rND4+Mj4+PjBdPWUpOihvKClbbj4+Mj4+PjBdPWUsbygpW24rND4+Mj4+PjBdPXQpfWZ1bmN0aW9uIHF0KHQsZSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aC0yLHI9YXJndW1lbnRzO3JldHVybiBndCgoKCk9Pntmb3IodmFyIGk9SWUoOCpuKSxvPWk+PjMscz0wO3M8bjtzKyspe3ZhciB1PXJbMitzXTthKClbbytzPj4+MF09dX1yZXR1cm4gdmUodCxuLGksZSl9KSl9cy5leGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlPVZ0LHZ0PXc/KCk9Pnt2YXIgdD1wcm9jZXNzLmhydGltZSgpO3JldHVybiAxZTMqdFswXSt0WzFdLzFlNn06eD8oKT0+cGVyZm9ybWFuY2Uubm93KCktcy5fX3BlcmZvcm1hbmNlX25vd19jbG9ja19kcmlmdDooKT0+cGVyZm9ybWFuY2Uubm93KCk7dmFyIFh0LFl0PVtdLEt0PXt9O2Z1bmN0aW9uIFp0KCl7aWYoIVh0KXt2YXIgdCxlPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOihcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOm18fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKHQgaW4gS3Qpdm9pZCAwPT09S3RbdF0/ZGVsZXRlIGVbdF06ZVt0XT1LdFt0XTt2YXIgbj1bXTtmb3IodCBpbiBlKW4ucHVzaCh0K1wiPVwiK2VbdF0pO1h0PW59cmV0dXJuIFh0fWZ1bmN0aW9uIEp0KHQsbil7aWYoeClyZXR1cm4gcXQoMjAsMSx0LG4pO3ZhciByPTA7cmV0dXJuIFp0KCkuZm9yRWFjaCgoZnVuY3Rpb24oaSxhKXt2YXIgcz1uK3I7Zm9yKGE9bygpW3QrNCphPj4yPj4+MF09cyxzPTA7czxpLmxlbmd0aDsrK3MpZSgpW2ErKz4+MD4+PjBdPWkuY2hhckNvZGVBdChzKTtlKClbYT4+MD4+PjBdPTAscis9aS5sZW5ndGgrMX0pKSwwfWZ1bmN0aW9uIFF0KHQsZSl7aWYoeClyZXR1cm4gcXQoMjEsMSx0LGUpO3ZhciBuPVp0KCk7bygpW3Q+PjI+Pj4wXT1uLmxlbmd0aDt2YXIgcj0wO3JldHVybiBuLmZvckVhY2goKGZ1bmN0aW9uKHQpe3IrPXQubGVuZ3RoKzF9KSksbygpW2U+PjI+Pj4wXT1yLDB9ZnVuY3Rpb24gdGUodCl7cmV0dXJuIHg/cXQoMjIsMSx0KTo1Mn1mdW5jdGlvbiBlZSh0LGUsbixyKXtyZXR1cm4geD9xdCgyMywxLHQsZSxuLHIpOjUyfWZ1bmN0aW9uIG5lKHQsZSxuLHIsaSl7cmV0dXJuIHg/cXQoMjQsMSx0LGUsbixyLGkpOjcwfXZhciByZT1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gaWUodCxlKXt2YXIgbj1yZVt0XTswPT09ZXx8MTA9PT1lPygoMT09PXQ/STpQKShWKG4sMCkpLG4ubGVuZ3RoPTApOm4ucHVzaChlKX1mdW5jdGlvbiBvZSh0LGUsbixpKXtpZih4KXJldHVybiBxdCgyNSwxLHQsZSxuLGkpO2Zvcih2YXIgYT0wLHM9MDtzPG47cysrKXt2YXIgdT1vKClbZT4+Mj4+PjBdLGM9bygpW2UrND4+Mj4+PjBdO2UrPTg7Zm9yKHZhciBsPTA7bDxjO2wrKylpZSh0LHIoKVt1K2w+Pj4wXSk7YSs9Y31yZXR1cm4gbygpW2k+PjI+Pj4wXT1hLDB9dmFyIGFlPTA7ZnVuY3Rpb24gc2UodCl7cmV0dXJuIDA9PXQlNCYmKDAhPXQlMTAwfHwwPT10JTQwMCl9dmFyIHVlPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sY2U9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBsZSh0LG4scixvKXtmdW5jdGlvbiBhKHQsZSxuKXtmb3IodD1cIm51bWJlclwiPT10eXBlb2YgdD90LnRvU3RyaW5nKCk6dHx8XCJcIjt0Lmxlbmd0aDxlOyl0PW5bMF0rdDtyZXR1cm4gdH1mdW5jdGlvbiBzKHQsZSl7cmV0dXJuIGEodCxlLFwiMFwiKX1mdW5jdGlvbiB1KHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gMD50Py0xOjA8dD8xOjB9dmFyIHI7cmV0dXJuIDA9PT0ocj1uKHQuZ2V0RnVsbFllYXIoKS1lLmdldEZ1bGxZZWFyKCkpKSYmMD09PShyPW4odC5nZXRNb250aCgpLWUuZ2V0TW9udGgoKSkpJiYocj1uKHQuZ2V0RGF0ZSgpLWUuZ2V0RGF0ZSgpKSkscn1mdW5jdGlvbiBjKHQpe3N3aXRjaCh0LmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIHQ7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIGwodCl7dmFyIGU9dC5XYjtmb3IodD1uZXcgRGF0ZShuZXcgRGF0ZSh0LlhiKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8ZTspe3ZhciBuPXQuZ2V0TW9udGgoKSxyPShzZSh0LmdldEZ1bGxZZWFyKCkpP3VlOmNlKVtuXTtpZighKGU+ci10LmdldERhdGUoKSkpe3Quc2V0RGF0ZSh0LmdldERhdGUoKStlKTticmVha31lLT1yLXQuZ2V0RGF0ZSgpKzEsdC5zZXREYXRlKDEpLDExPm4/dC5zZXRNb250aChuKzEpOih0LnNldE1vbnRoKDApLHQuc2V0RnVsbFllYXIodC5nZXRGdWxsWWVhcigpKzEpKX1yZXR1cm4gbj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCkrMSwwLDQpLGU9YyhuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCw0KSksbj1jKG4pLDA+PXUoZSx0KT8wPj11KG4sdCk/dC5nZXRGdWxsWWVhcigpKzE6dC5nZXRGdWxsWWVhcigpOnQuZ2V0RnVsbFllYXIoKS0xfXZhciBwPWkoKVtvKzQwPj4yPj4+MF07Zm9yKHZhciBmIGluIG89e0xjOmkoKVtvPj4yPj4+MF0sS2M6aSgpW28rND4+Mj4+PjBdLGRjOmkoKVtvKzg+PjI+Pj4wXSxqYzppKClbbysxMj4+Mj4+PjBdLGVjOmkoKVtvKzE2Pj4yPj4+MF0sWGI6aSgpW28rMjA+PjI+Pj4wXSxUYjppKClbbysyND4+Mj4+PjBdLFdiOmkoKVtvKzI4Pj4yPj4+MF0sUmM6aSgpW28rMzI+PjI+Pj4wXSxKYzppKClbbyszNj4+Mj4+PjBdLE1jOnA/QihwKTpcIlwifSxyPUIocikscD17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9KXI9ci5yZXBsYWNlKG5ldyBSZWdFeHAoZixcImdcIikscFtmXSk7dmFyIGQ9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxoPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtmb3IoZiBpbiBwPXtcIiVhXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGRbdC5UYl0uc3Vic3RyaW5nKDAsMyl9LFwiJUFcIjpmdW5jdGlvbih0KXtyZXR1cm4gZFt0LlRiXX0sXCIlYlwiOmZ1bmN0aW9uKHQpe3JldHVybiBoW3QuZWNdLnN1YnN0cmluZygwLDMpfSxcIiVCXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGhbdC5lY119LFwiJUNcIjpmdW5jdGlvbih0KXtyZXR1cm4gcygodC5YYisxOTAwKS8xMDB8MCwyKX0sXCIlZFwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuamMsMil9LFwiJWVcIjpmdW5jdGlvbih0KXtyZXR1cm4gYSh0LmpjLDIsXCIgXCIpfSxcIiVnXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGwodCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJUdcIjpmdW5jdGlvbih0KXtyZXR1cm4gbCh0KX0sXCIlSFwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuZGMsMil9LFwiJUlcIjpmdW5jdGlvbih0KXtyZXR1cm4gMD09KHQ9dC5kYyk/dD0xMjoxMjx0JiYodC09MTIpLHModCwyKX0sXCIlalwiOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49MDtuPD10LmVjLTE7ZSs9KHNlKHQuWGIrMTkwMCk/dWU6Y2UpW24rK10pO3JldHVybiBzKHQuamMrZSwzKX0sXCIlbVwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuZWMrMSwyKX0sXCIlTVwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuS2MsMil9LFwiJW5cIjpmdW5jdGlvbigpe3JldHVyblwiXFxuXCJ9LFwiJXBcIjpmdW5jdGlvbih0KXtyZXR1cm4gMDw9dC5kYyYmMTI+dC5kYz9cIkFNXCI6XCJQTVwifSxcIiVTXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHModC5MYywyKX0sXCIldFwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXHRcIn0sXCIldVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LlRifHw3fSxcIiVVXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHMoTWF0aC5mbG9vcigodC5XYis3LXQuVGIpLzcpLDIpfSxcIiVWXCI6ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5mbG9vcigodC5XYis3LSh0LlRiKzYpJTcpLzcpO2lmKDI+PSh0LlRiKzM3MS10LldiLTIpJTcmJmUrKyxlKTUzPT1lJiYoND09KG49KHQuVGIrMzcxLXQuV2IpJTcpfHwzPT1uJiZzZSh0LlhiKXx8KGU9MSkpO2Vsc2V7ZT01Mjt2YXIgbj0odC5UYis3LXQuV2ItMSklNzsoND09bnx8NT09biYmc2UodC5YYiU0MDAtMSkpJiZlKyt9cmV0dXJuIHMoZSwyKX0sXCIld1wiOmZ1bmN0aW9uKHQpe3JldHVybiB0LlRifSxcIiVXXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHMoTWF0aC5mbG9vcigodC5XYis3LSh0LlRiKzYpJTcpLzcpLDIpfSxcIiV5XCI6ZnVuY3Rpb24odCl7cmV0dXJuKHQuWGIrMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJVlcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5YYisxOTAwfSxcIiV6XCI6ZnVuY3Rpb24odCl7dmFyIGU9MDw9KHQ9dC5KYyk7cmV0dXJuIHQ9TWF0aC5hYnModCkvNjAsKGU/XCIrXCI6XCItXCIpK1N0cmluZyhcIjAwMDBcIisodC82MCoxMDArdCU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOmZ1bmN0aW9uKHQpe3JldHVybiB0Lk1jfSxcIiUlXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIiVcIn19LHI9ci5yZXBsYWNlKC8lJS9nLFwiXFwwXFwwXCIpLHApci5pbmNsdWRlcyhmKSYmKHI9ci5yZXBsYWNlKG5ldyBSZWdFeHAoZixcImdcIikscFtmXShvKSkpO3JldHVybiBmPWZ1bmN0aW9uKHQpe3ZhciBlPUFycmF5KEcodCkrMSk7cmV0dXJuIHoodCxlLDAsZS5sZW5ndGgpLGV9KHI9ci5yZXBsYWNlKC9cXDBcXDAvZyxcIiVcIikpLGYubGVuZ3RoPm4/MDooZnVuY3Rpb24odCxuKXtlKCkuc2V0KHQsbj4+PjApfShmLHQpLGYubGVuZ3RoLTEpfWR0LmZjKCk7dmFyIHBlPVtudWxsLHB0LGJ0LEF0LEl0LFB0LER0LCR0LGt0LEN0LEZ0LE50LEx0LFJ0LGp0LE10LFV0LHp0LEd0LFd0LEp0LFF0LHRlLGVlLG5lLG9lXSxmZT17YjpmdW5jdGlvbih0KXtyZXR1cm4gaGUodCsyNCkrMjR9LG46ZnVuY3Rpb24odCl7cmV0dXJuKHQ9bmV3IFN0KHQpKS51YygpfHwodC5oYyghMCkseHQtLSksdC5pYyghMSksd3QucHVzaCh0KSx0LnNjKCksdC52YygpfSxtYTpmdW5jdGlvbih0KXt0aHJvdyBQKFwiVW5leHBlY3RlZCBleGNlcHRpb24gdGhyb3duLCB0aGlzIGlzIG5vdCBwcm9wZXJseSBzdXBwb3J0ZWQgLSBhYm9ydGluZ1wiKSxNPSEwLHR9LHg6ZnVuY3Rpb24oKXtTZSgwKTt2YXIgdD13dC5wb3AoKTtpZih0LkhjKCkmJiF0LmtjKCkpe3ZhciBlPXQuRGMoKTtlJiZ5dChlKSh0LlpiKSxPdCh0LlpiKX1UdD0wfSxlOmZ1bmN0aW9uKCl7dmFyIHQ9VHQ7aWYoIXQpcmV0dXJuIGFlPTA7dmFyIGU9bmV3IFN0KHQpO2UuY2ModCk7dmFyIG49ZS5iYygpO2lmKCFuKXJldHVybiBhZT0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihQZShvLG4sZS5TYisxNikpcmV0dXJuIGFlPW8sdH1yZXR1cm4gYWU9bix0fSxsOmZ1bmN0aW9uKCl7dmFyIHQ9VHQ7aWYoIXQpcmV0dXJuIGFlPTA7dmFyIGU9bmV3IFN0KHQpO2UuY2ModCk7dmFyIG49ZS5iYygpO2lmKCFuKXJldHVybiBhZT0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihQZShvLG4sZS5TYisxNikpcmV0dXJuIGFlPW8sdH1yZXR1cm4gYWU9bix0fSxoOmZ1bmN0aW9uKCl7dmFyIHQ9VHQ7aWYoIXQpcmV0dXJuIGFlPTA7dmFyIGU9bmV3IFN0KHQpO2UuY2ModCk7dmFyIG49ZS5iYygpO2lmKCFuKXJldHVybiBhZT0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihQZShvLG4sZS5TYisxNikpcmV0dXJuIGFlPW8sdH1yZXR1cm4gYWU9bix0fSx0Ok90LE06ZnVuY3Rpb24oKXt2YXIgdD13dC5wb3AoKTt0fHxpdChcIm5vIGV4Y2VwdGlvbiB0byB0aHJvd1wiKTt2YXIgZT10LlpiO3Rocm93IHQua2MoKXx8KHd0LnB1c2godCksdC5pYyghMCksdC5oYyghMSkseHQrKyksVHQ9ZSxlfSxjOmZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgU3QodCkuZmMoZSxuKSxUdD10LHh0KyssdH0scGE6ZnVuY3Rpb24oKXtyZXR1cm4geHR9LEZhOmZ1bmN0aW9uKHQpe3llKHQsIXYsMSwhXyksZHQucGMoKX0sVDpmdW5jdGlvbih0KXt4P3Bvc3RNZXNzYWdlKHtjbWQ6XCJjbGVhbnVwVGhyZWFkXCIsdGhyZWFkOnR9KTpjdCh0KX0seGE6RXQsajpmdW5jdGlvbih0KXt0aHJvdyBUdHx8KFR0PXQpLHR9LEg6SXQsTWE6UHQsdWE6RHQsd2E6JHQsb2E6a3QsS2E6Q3QsQ2E6RnQsSmE6TnQsVjpMdCx2YTpSdCxzYTpqdCxMYTpNdCx0YTpVdCxUYTpmdW5jdGlvbigpe30sWDpmdW5jdGlvbigpe2l0KFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LFVhOmZ1bmN0aW9uKCl7aXQoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0sVzpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfSx5YTpmdW5jdGlvbigpe3JldHVybiAyMDk3MTUyfSxPYTpmdW5jdGlvbigpe3JldHVybiEwfSx6YTpmdW5jdGlvbih0LGUsbixyKXtpZih0PT1lKXNldFRpbWVvdXQoKCgpPT5WdChyKSkpO2Vsc2UgaWYoeClwb3N0TWVzc2FnZSh7dGFyZ2V0VGhyZWFkOnQsY21kOlwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIixxdWV1ZTpyfSk7ZWxzZXtpZighKHQ9ZHQuVmJbdF0pKXJldHVybjt0LnBvc3RNZXNzYWdlKHtjbWQ6XCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiLHF1ZXVlOnJ9KX1yZXR1cm4gMX0sRWE6ZnVuY3Rpb24oKXtyZXR1cm4tMX0sUGE6ZnVuY3Rpb24odCxlKXt0PW5ldyBEYXRlKDFlMypCdCh0KSksaSgpW2U+PjI+Pj4wXT10LmdldFVUQ1NlY29uZHMoKSxpKClbZSs0Pj4yPj4+MF09dC5nZXRVVENNaW51dGVzKCksaSgpW2UrOD4+Mj4+PjBdPXQuZ2V0VVRDSG91cnMoKSxpKClbZSsxMj4+Mj4+PjBdPXQuZ2V0VVRDRGF0ZSgpLGkoKVtlKzE2Pj4yPj4+MF09dC5nZXRVVENNb250aCgpLGkoKVtlKzIwPj4yPj4+MF09dC5nZXRVVENGdWxsWWVhcigpLTE5MDAsaSgpW2UrMjQ+PjI+Pj4wXT10LmdldFVUQ0RheSgpLHQ9KHQuZ2V0VGltZSgpLURhdGUuVVRDKHQuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDAsaSgpW2UrMjg+PjI+Pj4wXT10fSxRYTpmdW5jdGlvbih0LGUpe3Q9bmV3IERhdGUoMWUzKkJ0KHQpKSxpKClbZT4+Mj4+PjBdPXQuZ2V0U2Vjb25kcygpLGkoKVtlKzQ+PjI+Pj4wXT10LmdldE1pbnV0ZXMoKSxpKClbZSs4Pj4yPj4+MF09dC5nZXRIb3VycygpLGkoKVtlKzEyPj4yPj4+MF09dC5nZXREYXRlKCksaSgpW2UrMTY+PjI+Pj4wXT10LmdldE1vbnRoKCksaSgpW2UrMjA+PjI+Pj4wXT10LmdldEZ1bGxZZWFyKCktMTkwMCxpKClbZSsyND4+Mj4+PjBdPXQuZ2V0RGF5KCk7dmFyIG49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSkscj0odC5nZXRUaW1lKCktbi5nZXRUaW1lKCkpLzg2NGU1fDA7aSgpW2UrMjg+PjI+Pj4wXT1yLGkoKVtlKzM2Pj4yPj4+MF09LTYwKnQuZ2V0VGltZXpvbmVPZmZzZXQoKSxyPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksdD0wfChyIT0obj1uLmdldFRpbWV6b25lT2Zmc2V0KCkpJiZ0LmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKG4scikpLGkoKVtlKzMyPj4yPj4+MF09dH0sUmE6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IERhdGUoaSgpW3QrMjA+PjI+Pj4wXSsxOTAwLGkoKVt0KzE2Pj4yPj4+MF0saSgpW3QrMTI+PjI+Pj4wXSxpKClbdCs4Pj4yPj4+MF0saSgpW3QrND4+Mj4+PjBdLGkoKVt0Pj4yPj4+MF0sMCksbj1pKClbdCszMj4+Mj4+PjBdLHI9ZS5nZXRUaW1lem9uZU9mZnNldCgpLG89bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMSksYT1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLHM9by5nZXRUaW1lem9uZU9mZnNldCgpLHU9TWF0aC5taW4ocyxhKTtyZXR1cm4gMD5uP2koKVt0KzMyPj4yPj4+MF09TnVtYmVyKGEhPXMmJnU9PXIpOjA8biE9KHU9PXIpJiYoYT1NYXRoLm1heChzLGEpLGUuc2V0VGltZShlLmdldFRpbWUoKSs2ZTQqKCgwPG4/dTphKS1yKSkpLGkoKVt0KzI0Pj4yPj4+MF09ZS5nZXREYXkoKSxuPShlLmdldFRpbWUoKS1vLmdldFRpbWUoKSkvODY0ZTV8MCxpKClbdCsyOD4+Mj4+PjBdPW4saSgpW3Q+PjI+Pj4wXT1lLmdldFNlY29uZHMoKSxpKClbdCs0Pj4yPj4+MF09ZS5nZXRNaW51dGVzKCksaSgpW3QrOD4+Mj4+PjBdPWUuZ2V0SG91cnMoKSxpKClbdCsxMj4+Mj4+PjBdPWUuZ2V0RGF0ZSgpLGkoKVt0KzE2Pj4yPj4+MF09ZS5nZXRNb250aCgpLGUuZ2V0VGltZSgpLzFlM3wwfSxBYTp6dCxCYTpHdCxTYTpmdW5jdGlvbiB0KGUsbixyKXt0LkFjfHwodC5BYz0hMCxXdChlLG4scikpfSx5OmZ1bmN0aW9uKCl7aXQoXCJcIil9LFU6ZnVuY3Rpb24oKXtpZighdyYmIXYpe3ZhciB0PVwiQmxvY2tpbmcgb24gdGhlIG1haW4gdGhyZWFkIGlzIHZlcnkgZGFuZ2Vyb3VzLCBzZWUgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZy9kb2NzL3BvcnRpbmcvcHRocmVhZHMuaHRtbCNibG9ja2luZy1vbi10aGUtbWFpbi1icm93c2VyLXRocmVhZFwiO190fHwoX3Q9e30pLF90W3RdfHwoX3RbdF09MSx3JiYodD1cIndhcm5pbmc6IFwiK3QpLFAodCkpfX0scmE6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sQjp2dCxJYTpmdW5jdGlvbih0LGUsbil7cigpLmNvcHlXaXRoaW4odD4+PjAsZT4+PjAsZStuPj4+MCl9LEY6ZnVuY3Rpb24oKXtyZXR1cm4gdz9uKDM5OTMpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3l9LERhOmZ1bmN0aW9uKHQsZSxuKXtZdC5sZW5ndGg9ZSxuPj49Mztmb3IodmFyIHI9MDtyPGU7cisrKVl0W3JdPWEoKVtuK3I+Pj4wXTtyZXR1cm4oMD50P3N0Wy10LTFdOnBlW3RdKS5hcHBseShudWxsLFl0KX0scWE6ZnVuY3Rpb24odCl7dmFyIGU9cigpLmxlbmd0aDtpZigodD4+Pj0wKTw9ZXx8NDI5NDkwMTc2MDx0KXJldHVybiExO2Zvcih2YXIgbj0xOzQ+PW47bio9Mil7dmFyIGk9ZSooMSsuMi9uKTtpPU1hdGgubWluKGksdCsxMDA2NjMyOTYpO3ZhciBvPU1hdGg7aT1NYXRoLm1heCh0LGkpLG89by5taW4uY2FsbChvLDQyOTQ5MDE3NjAsaSsoNjU1MzYtaSU2NTUzNiklNjU1MzYpO3Q6e3RyeXskLmdyb3coby1DLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNiksSCgkLmJ1ZmZlcik7dmFyIGE9MTticmVhayB0fWNhdGNoKHQpe31hPXZvaWQgMH1pZihhKXJldHVybiEwfXJldHVybiExfSxOYTpmdW5jdGlvbigpe3Rocm93XCJ1bndpbmRcIn0sR2E6SnQsSGE6UXQsSjpmdCxJOnRlLFM6ZWUsZ2E6bmUsUjpvZSxkOmZ1bmN0aW9uKCl7cmV0dXJuIGFlfSxuYTpmdW5jdGlvbiB0KHIsaSl7dC5sY3x8KHQubGM9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+KGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdFswXSl9aWYodyl0cnl7dmFyIGU9bihPYmplY3QoZnVuY3Rpb24oKXt2YXIgdD1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ2NyeXB0bydcIik7dGhyb3cgdC5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLHR9KCkpKTtyZXR1cm4oKT0+ZS5yYW5kb21CeXRlcygxKVswXX1jYXRjaCh0KXt9cmV0dXJuKCk9Pml0KFwicmFuZG9tRGV2aWNlXCIpfSgpKTtmb3IodmFyIG89MDtvPGk7bysrKWUoKVtyK28+PjA+Pj4wXT10LmxjKCk7cmV0dXJuIDB9LGlhOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGphOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LEs6ZnVuY3Rpb24odCl7dmFyIGU9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKCl9Y2F0Y2godCl7aWYoRWUoZSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxmOmZ1bmN0aW9uKHQsZSl7dmFyIG49QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUpfWNhdGNoKHQpe2lmKEVlKG4pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sUDpmdW5jdGlvbih0LGUsbil7dmFyIHI9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbil9Y2F0Y2godCl7aWYoRWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxROmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGs6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4pfWNhdGNoKHQpe2lmKEVlKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0scDpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKEVlKGkpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0scTpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4scixpKX1jYXRjaCh0KXtpZihFZShvKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LE46ZnVuY3Rpb24odCxlLG4scixpLG8pe3ZhciBhPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4scixpLG8pfWNhdGNoKHQpe2lmKEVlKGEpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sczpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbixyLGksbyl9Y2F0Y2godCl7aWYoRWUoYSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSx3OmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEpe3ZhciBzPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4scixpLG8sYSl9Y2F0Y2godCl7aWYoRWUocyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxMOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKEVlKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sRTpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMsdSxjLGwscCl7dmFyIGY9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbixyLGksbyxhLHMsdSxjLGwscCl9Y2F0Y2godCl7aWYoRWUoZiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxhYTpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMpe3ZhciB1PUFlKCk7dHJ5e3JldHVybiBNZSh0LGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKEVlKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sXzpmdW5jdGlvbih0LGUsbixyLGksbyxhKXt2YXIgcz1BZSgpO3RyeXtyZXR1cm4ga2UodCxlLG4scixpLG8sYSl9Y2F0Y2godCl7aWYoRWUocyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxaOmZ1bmN0aW9uKHQsZSxuLHIsaSl7dmFyIG89QWUoKTt0cnl7cmV0dXJuIFVlKHQsZSxuLHIsaSl9Y2F0Y2godCl7aWYoRWUobyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxjYTpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1BZSgpO3RyeXtyZXR1cm4gUmUodCxlLG4scil9Y2F0Y2godCl7aWYoRWUoaSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSwkOmZ1bmN0aW9uKHQpe3ZhciBlPUFlKCk7dHJ5e3JldHVybiAkZSh0KX1jYXRjaCh0KXtpZihFZShlKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGJhOmZ1bmN0aW9uKHQsZSl7dmFyIG49QWUoKTt0cnl7cmV0dXJuIGplKHQsZSl9Y2F0Y2godCl7aWYoRWUobiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxZOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4gQ2UodCxlLG4pfWNhdGNoKHQpe2lmKEVlKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sZzpmdW5jdGlvbih0KXt2YXIgZT1BZSgpO3RyeXt5dCh0KSgpfWNhdGNoKHQpe2lmKEVlKGUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0scjpmdW5jdGlvbih0LGUpe3ZhciBuPUFlKCk7dHJ5e3l0KHQpKGUpfWNhdGNoKHQpe2lmKEVlKG4pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0saTpmdW5jdGlvbih0LGUsbil7dmFyIHI9QWUoKTt0cnl7eXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGhhOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPUFlKCk7dHJ5e3l0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihFZShpKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LG06ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9QWUoKTt0cnl7eXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKEVlKGkpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sdjpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPUFlKCk7dHJ5e3l0KHQpKGUsbixyLGkpfWNhdGNoKHQpe2lmKEVlKG8pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sdTpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9QWUoKTt0cnl7eXQodCkoZSxuLHIsaSxvKX1jYXRjaCh0KXtpZihFZShhKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LE86ZnVuY3Rpb24odCxlLG4scixpLG8sYSl7dmFyIHM9QWUoKTt0cnl7eXQodCkoZSxuLHIsaSxvLGEpfWNhdGNoKHQpe2lmKEVlKHMpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sQTpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMpe3ZhciB1PUFlKCk7dHJ5e3l0KHQpKGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKEVlKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sa2E6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzLHUpe3ZhciBjPUFlKCk7dHJ5e3l0KHQpKGUsbixyLGksbyxhLHMsdSl9Y2F0Y2godCl7aWYoRWUoYyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxDOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCl7dmFyIHA9QWUoKTt0cnl7eXQodCkoZSxuLHIsaSxvLGEscyx1LGMsbCl9Y2F0Y2godCl7aWYoRWUocCksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxEOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwLGYsZCxoLGcpe3ZhciBiPUFlKCk7dHJ5e3l0KHQpKGUsbixyLGksbyxhLHMsdSxjLGwscCxmLGQsaCxnKX1jYXRjaCh0KXtpZihFZShiKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGZhOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9QWUoKTt0cnl7RmUodCxlLG4scixpLG8sYSxzKX1jYXRjaCh0KXtpZihFZSh1KSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGRhOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwKXt2YXIgZj1BZSgpO3RyeXtMZSh0LGUsbixyLGksbyxhLHMsdSxjLGwscCl9Y2F0Y2godCl7aWYoRWUoZiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxlYTpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9QWUoKTt0cnl7TmUodCxlLG4scixpLG8pfWNhdGNoKHQpe2lmKEVlKGEpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sbzpmdW5jdGlvbih0KXtyZXR1cm4gdH0sYTokfHxzLndhc21NZW1vcnksRzpmdW5jdGlvbih0KXthZT10fSxsYTpsZSx6OmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiBsZSh0LGUsbixyKX19OyFmdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtzLmFzbT10LmV4cG9ydHMsZHQucWMucHVzaChzLmFzbS5zYikscT1zLmFzbS51YixZLnVuc2hpZnQocy5hc20uVmEpLGs9ZSx4fHwoZXQtLSxzLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJnMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhldCksMD09ZXQmJihudWxsIT09bnQmJihjbGVhckludGVydmFsKG50KSxudD1udWxsKSxydCYmKHQ9cnQscnQ9bnVsbCx0KCkpKSl9ZnVuY3Rpb24gZShlKXt0KGUuaW5zdGFuY2UsZS5tb2R1bGUpfWZ1bmN0aW9uIG4odCl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoIUUmJihffHx2KSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZmV0Y2gmJiF0dC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSlyZXR1cm4gZmV0Y2godHQse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKHQpe2lmKCF0Lm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIit0dCtcIidcIjtyZXR1cm4gdC5hcnJheUJ1ZmZlcigpfSkpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBhdCgpfSkpO2lmKHApcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe3AodHQsKGZ1bmN0aW9uKGUpe3QobmV3IFVpbnQ4QXJyYXkoZSkpfSksZSl9KSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIGF0KCl9KSl9KCkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHQscil9KSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSkudGhlbih0LChmdW5jdGlvbih0KXtQKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrdCksaXQodCl9KSl9dmFyIHI9e2E6ZmV9O2lmKHh8fChldCsrLHMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmcy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKGV0KSkscy5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBzLmluc3RhbnRpYXRlV2FzbShyLHQpfWNhdGNoKHQpe3JldHVybiBQKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrdCksITF9KEV8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxvdCgpfHx0dC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8d3x8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/bihlKTpmZXRjaCh0dCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHQscikudGhlbihlLChmdW5jdGlvbih0KXtyZXR1cm4gUChcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIit0KSxQKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksbihlKX0pKX0pKSkuY2F0Y2goYyl9KCkscy5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fX193YXNtX2NhbGxfY3RvcnM9cy5hc20uVmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0SW5pdD1mdW5jdGlvbigpe3JldHVybihzLl9PcnRJbml0PXMuYXNtLldhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPXMuYXNtLlhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPXMuYXNtLllhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9cy5hc20uWmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1zLmFzbS5fYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRDcmVhdGVTZXNzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydENyZWF0ZVNlc3Npb249cy5hc20uJGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0UmVsZWFzZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0UmVsZWFzZVNlc3Npb249cy5hc20uYWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0SW5wdXRDb3VudD1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRJbnB1dENvdW50PXMuYXNtLmJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldE91dHB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEdldE91dHB1dENvdW50PXMuYXNtLmNiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldElucHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRJbnB1dE5hbWU9cy5hc20uZGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0T3V0cHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRPdXRwdXROYW1lPXMuYXNtLmViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0RnJlZT1zLmFzbS5mYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRDcmVhdGVUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0Q3JlYXRlVGVuc29yPXMuYXNtLmdiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldFRlbnNvckRhdGE9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0R2V0VGVuc29yRGF0YT1zLmFzbS5oYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRSZWxlYXNlVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VUZW5zb3I9cy5hc20uaWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybihzLl9PcnRDcmVhdGVSdW5PcHRpb25zPXMuYXNtLmpiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PXMuYXNtLmtiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydFJlbGVhc2VSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VSdW5PcHRpb25zPXMuYXNtLmxiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydFJ1bj1mdW5jdGlvbigpe3JldHVybihzLl9PcnRSdW49cy5hc20ubWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0RW5kUHJvZmlsaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEVuZFByb2ZpbGluZz1zLmFzbS5uYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgZGU9cy5fcHRocmVhZF9zZWxmPWZ1bmN0aW9uKCl7cmV0dXJuKGRlPXMuX3B0aHJlYWRfc2VsZj1zLmFzbS5vYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxoZT1zLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oaGU9cy5fbWFsbG9jPXMuYXNtLnBiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGdlPXMuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4oZ2U9cy5fZnJlZT1zLmFzbS5xYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxiZT1zLl9mZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4oYmU9cy5fZmZsdXNoPXMuYXNtLnJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3MuX19lbXNjcmlwdGVuX3Rsc19pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19lbXNjcmlwdGVuX3Rsc19pbml0PXMuYXNtLnNiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBtZT1zLl9fX2Z1bmNzX29uX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4obWU9cy5fX19mdW5jc19vbl9leGl0PXMuYXNtLnRiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHllPXMuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHllPXMuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PXMuYXNtLnZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3MuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPXMuYXNtLndiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZSx2ZT1zLl9lbXNjcmlwdGVuX3J1bl9pbl9tYWluX3J1bnRpbWVfdGhyZWFkX2pzPWZ1bmN0aW9uKCl7cmV0dXJuKHZlPXMuX2Vtc2NyaXB0ZW5fcnVuX2luX21haW5fcnVudGltZV90aHJlYWRfanM9cy5hc20ueGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sd2U9cy5fX2Vtc2NyaXB0ZW5fcHJveHlfZXhlY3V0ZV90YXNrX3F1ZXVlPWZ1bmN0aW9uKCl7cmV0dXJuKHdlPXMuX19lbXNjcmlwdGVuX3Byb3h5X2V4ZWN1dGVfdGFza19xdWV1ZT1zLmFzbS55YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx4ZT1zLl9fZW1zY3JpcHRlbl90aHJlYWRfZnJlZV9kYXRhPWZ1bmN0aW9uKCl7cmV0dXJuKHhlPXMuX19lbXNjcmlwdGVuX3RocmVhZF9mcmVlX2RhdGE9cy5hc20uemIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVGU9cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4oVGU9cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9cy5hc20uQWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU2U9cy5fc2V0VGhyZXc9ZnVuY3Rpb24oKXtyZXR1cm4oU2U9cy5fc2V0VGhyZXc9cy5hc20uQmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sT2U9cy5fZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzPWZ1bmN0aW9uKCl7cmV0dXJuKE9lPXMuX2Vtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0cz1zLmFzbS5DYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBZT1zLnN0YWNrU2F2ZT1mdW5jdGlvbigpe3JldHVybihBZT1zLnN0YWNrU2F2ZT1zLmFzbS5EYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFZT1zLnN0YWNrUmVzdG9yZT1mdW5jdGlvbigpe3JldHVybihFZT1zLnN0YWNrUmVzdG9yZT1zLmFzbS5FYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxJZT1zLnN0YWNrQWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oSWU9cy5zdGFja0FsbG9jPXMuYXNtLkZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFBlPXMuX19fY3hhX2Nhbl9jYXRjaD1mdW5jdGlvbigpe3JldHVybihQZT1zLl9fX2N4YV9jYW5fY2F0Y2g9cy5hc20uR2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRGU9cy5fX19jeGFfaXNfcG9pbnRlcl90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuKERlPXMuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1zLmFzbS5IYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSwkZT1zLmR5bkNhbGxfaj1mdW5jdGlvbigpe3JldHVybigkZT1zLmR5bkNhbGxfaj1zLmFzbS5JYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxrZT1zLmR5bkNhbGxfaWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKGtlPXMuZHluQ2FsbF9paWlpaWo9cy5hc20uSmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQ2U9cy5keW5DYWxsX2ppaT1mdW5jdGlvbigpe3JldHVybihDZT1zLmR5bkNhbGxfamlpPXMuYXNtLktiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEZlPXMuZHluQ2FsbF92aWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKEZlPXMuZHluQ2FsbF92aWlpaWlqPXMuYXNtLkxiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE5lPXMuZHluQ2FsbF92amppPWZ1bmN0aW9uKCl7cmV0dXJuKE5lPXMuZHluQ2FsbF92amppPXMuYXNtLk1iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LExlPXMuZHluQ2FsbF92aWlpampqaWk9ZnVuY3Rpb24oKXtyZXR1cm4oTGU9cy5keW5DYWxsX3ZpaWlqamppaT1zLmFzbS5OYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxSZT1zLmR5bkNhbGxfaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKFJlPXMuZHluQ2FsbF9paWo9cy5hc20uT2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0samU9cy5keW5DYWxsX2ppPWZ1bmN0aW9uKCl7cmV0dXJuKGplPXMuZHluQ2FsbF9qaT1zLmFzbS5QYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxNZT1zLmR5bkNhbGxfaWlpaWlpaj1mdW5jdGlvbigpe3JldHVybihNZT1zLmR5bkNhbGxfaWlpaWlpaj1zLmFzbS5RYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxVZT1zLmR5bkNhbGxfaWlpaj1mdW5jdGlvbigpe3JldHVybihVZT1zLmR5bkNhbGxfaWlpaj1zLmFzbS5SYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiBWZSgpe2Z1bmN0aW9uIHQoKXtpZighX2UmJihfZT0hMCxzLmNhbGxlZFJ1bj0hMCwhTSkmJih4fHxodChZKSx1KHMpLHMub25SdW50aW1lSW5pdGlhbGl6ZWQmJnMub25SdW50aW1lSW5pdGlhbGl6ZWQoKSwheCkpe2lmKHMucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2Ygcy5wb3N0UnVuJiYocy5wb3N0UnVuPVtzLnBvc3RSdW5dKTtzLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIHQ9cy5wb3N0UnVuLnNoaWZ0KCk7Wi51bnNoaWZ0KHQpfWh0KFopfX1pZighKDA8ZXQpKWlmKHgpdShzKSx4fHxodChZKSxwb3N0TWVzc2FnZSh7Y21kOlwibG9hZGVkXCJ9KTtlbHNle2lmKHMucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBzLnByZVJ1biYmKHMucHJlUnVuPVtzLnByZVJ1bl0pO3MucHJlUnVuLmxlbmd0aDspUSgpO2h0KFgpLDA8ZXR8fChzLnNldFN0YXR1cz8ocy5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtzLnNldFN0YXR1cyhcIlwiKX0pLDEpLHQoKX0pLDEpKTp0KCkpfX1pZihzLlVURjhUb1N0cmluZz1CLHMuc3RyaW5nVG9VVEY4PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4geih0LHIoKSxlLG4pfSxzLmxlbmd0aEJ5dGVzVVRGOD1HLHMua2VlcFJ1bnRpbWVBbGl2ZT1KLHMud2FzbU1lbW9yeT0kLHMuc3RhY2tTYXZlPUFlLHMuc3RhY2tSZXN0b3JlPUVlLHMuc3RhY2tBbGxvYz1JZSxzLkV4aXRTdGF0dXM9dXQscy5QVGhyZWFkPWR0LHJ0PWZ1bmN0aW9uIHQoKXtfZXx8VmUoKSxfZXx8KHJ0PXQpfSxzLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHMucHJlSW5pdCYmKHMucHJlSW5pdD1bcy5wcmVJbml0XSk7MDxzLnByZUluaXQubGVuZ3RoOylzLnByZUluaXQucG9wKCkoKTtyZXR1cm4gVmUoKSx0LnJlYWR5fSk7dC5leHBvcnRzPXJ9LDkzMjoodCxlLG4pPT57dmFyIF9zY3JpcHREaXIscj0oX3NjcmlwdERpcj0oX3NjcmlwdERpcj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwKXx8XCIvaW5kZXguanNcIixmdW5jdGlvbih0KXt2YXIgZSxyLGk7dD10fHx7fSxlfHwoZT12b2lkIDAhPT10P3Q6e30pLGUucmVhZHk9bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7cj10LGk9ZX0pKTt2YXIgbyxhLHMsdSxjLGwscD1PYmplY3QuYXNzaWduKHt9LGUpLGY9XCIuL3RoaXMucHJvZ3JhbVwiLGQ9KHQsZSk9Pnt0aHJvdyBlfSxoPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3csZz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpbXBvcnRTY3JpcHRzLGI9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLG09XCJcIjtiPyhtPWc/big5MDgpLmRpcm5hbWUobSkrXCIvXCI6XCIvL1wiLGw9KCk9PntjfHwodT1uKDEzODQpLGM9big5MDgpKX0sbz1mdW5jdGlvbih0LGUpe3JldHVybiBsKCksdD1jLm5vcm1hbGl6ZSh0KSx1LnJlYWRGaWxlU3luYyh0LGU/dm9pZCAwOlwidXRmOFwiKX0scz10PT4oKHQ9byh0LCEwKSkuYnVmZmVyfHwodD1uZXcgVWludDhBcnJheSh0KSksdCksYT0odCxlLG4pPT57bCgpLHQ9Yy5ub3JtYWxpemUodCksdS5yZWFkRmlsZSh0LChmdW5jdGlvbih0LHIpe3Q/bih0KTplKHIuYnVmZmVyKX0pKX0sMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYoZj1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLChmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBLKSl0aHJvdyB0fSkpLHByb2Nlc3Mub24oXCJ1bmhhbmRsZWRSZWplY3Rpb25cIiwoZnVuY3Rpb24odCl7dGhyb3cgdH0pKSxkPSh0LGUpPT57aWYod3x8MDxVKXRocm93IHByb2Nlc3MuZXhpdENvZGU9dCxlO2UgaW5zdGFuY2VvZiBLfHx2KFwiZXhpdGluZyBkdWUgdG8gZXhjZXB0aW9uOiBcIitlKSxwcm9jZXNzLmV4aXQodCl9LGUuaW5zcGVjdD1mdW5jdGlvbigpe3JldHVyblwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn0pOihofHxnKSYmKGc/bT1zZWxmLmxvY2F0aW9uLmhyZWY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYobT1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksX3NjcmlwdERpciYmKG09X3NjcmlwdERpciksbT0wIT09bS5pbmRleE9mKFwiYmxvYjpcIik/bS5zdWJzdHIoMCxtLnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOlwiXCIsbz10PT57dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBlLm9wZW4oXCJHRVRcIix0LCExKSxlLnNlbmQobnVsbCksZS5yZXNwb25zZVRleHR9LGcmJihzPXQ9Pnt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGUub3BlbihcIkdFVFwiLHQsITEpLGUucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixlLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoZS5yZXNwb25zZSl9KSxhPSh0LGUsbik9Pnt2YXIgcj1uZXcgWE1MSHR0cFJlcXVlc3Q7ci5vcGVuKFwiR0VUXCIsdCwhMCksci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLHIub25sb2FkPSgpPT57MjAwPT1yLnN0YXR1c3x8MD09ci5zdGF0dXMmJnIucmVzcG9uc2U/ZShyLnJlc3BvbnNlKTpuKCl9LHIub25lcnJvcj1uLHIuc2VuZChudWxsKX0pO3ZhciB5LF89ZS5wcmludHx8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSx2PWUucHJpbnRFcnJ8fGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO09iamVjdC5hc3NpZ24oZSxwKSxwPW51bGwsZS50aGlzUHJvZ3JhbSYmKGY9ZS50aGlzUHJvZ3JhbSksZS5xdWl0JiYoZD1lLnF1aXQpLGUud2FzbUJpbmFyeSYmKHk9ZS53YXNtQmluYXJ5KTt2YXIgdz1lLm5vRXhpdFJ1bnRpbWV8fCExO1wib2JqZWN0XCIhPXR5cGVvZiBXZWJBc3NlbWJseSYmVyhcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIHgsVCxTLE8sQSxFLEk9ITEsUD1cInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDA7ZnVuY3Rpb24gRCh0LGUsbil7dmFyIHI9KGU+Pj49MCkrbjtmb3Iobj1lO3Rbbl0mJiEobj49cik7KSsrbjtpZigxNjxuLWUmJnQuYnVmZmVyJiZQKXJldHVybiBQLmRlY29kZSh0LnN1YmFycmF5KGUsbikpO2ZvcihyPVwiXCI7ZTxuOyl7dmFyIGk9dFtlKytdO2lmKDEyOCZpKXt2YXIgbz02MyZ0W2UrK107aWYoMTkyPT0oMjI0JmkpKXIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMxJmkpPDw2fG8pO2Vsc2V7dmFyIGE9NjMmdFtlKytdOzY1NTM2PihpPTIyND09KDI0MCZpKT8oMTUmaSk8PDEyfG88PDZ8YTooNyZpKTw8MTh8bzw8MTJ8YTw8Nnw2MyZ0W2UrK10pP3IrPVN0cmluZy5mcm9tQ2hhckNvZGUoaSk6KGktPTY1NTM2LHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8aT4+MTAsNTYzMjB8MTAyMyZpKSl9fWVsc2Ugcis9U3RyaW5nLmZyb21DaGFyQ29kZShpKX1yZXR1cm4gcn1mdW5jdGlvbiAkKHQsZSl7cmV0dXJuKHQ+Pj49MCk/RChPLHQsZSk6XCJcIn1mdW5jdGlvbiBrKHQsZSxuLHIpe2lmKCEoMDxyKSlyZXR1cm4gMDt2YXIgaT1uPj4+PTA7cj1uK3ItMTtmb3IodmFyIG89MDtvPHQubGVuZ3RoOysrbyl7dmFyIGE9dC5jaGFyQ29kZUF0KG8pO2lmKDU1Mjk2PD1hJiY1NzM0Mz49YSYmKGE9NjU1MzYrKCgxMDIzJmEpPDwxMCl8MTAyMyZ0LmNoYXJDb2RlQXQoKytvKSksMTI3Pj1hKXtpZihuPj1yKWJyZWFrO2VbbisrPj4+MF09YX1lbHNle2lmKDIwNDc+PWEpe2lmKG4rMT49cilicmVhaztlW24rKz4+PjBdPTE5MnxhPj42fWVsc2V7aWYoNjU1MzU+PWEpe2lmKG4rMj49cilicmVhaztlW24rKz4+PjBdPTIyNHxhPj4xMn1lbHNle2lmKG4rMz49cilicmVhaztlW24rKz4+PjBdPTI0MHxhPj4xOCxlW24rKz4+PjBdPTEyOHxhPj4xMiY2M31lW24rKz4+PjBdPTEyOHxhPj42JjYzfWVbbisrPj4+MF09MTI4fDYzJmF9fXJldHVybiBlW24+Pj4wXT0wLG4taX1mdW5jdGlvbiBDKHQpe2Zvcih2YXIgZT0wLG49MDtuPHQubGVuZ3RoOysrbil7dmFyIHI9dC5jaGFyQ29kZUF0KG4pOzEyNz49cj9lKys6MjA0Nz49cj9lKz0yOjU1Mjk2PD1yJiY1NzM0Mz49cj8oZSs9NCwrK24pOmUrPTN9cmV0dXJuIGV9ZnVuY3Rpb24gRigpe3ZhciB0PXguYnVmZmVyO1Q9dCxlLkhFQVA4PVM9bmV3IEludDhBcnJheSh0KSxlLkhFQVAxNj1uZXcgSW50MTZBcnJheSh0KSxlLkhFQVAzMj1BPW5ldyBJbnQzMkFycmF5KHQpLGUuSEVBUFU4PU89bmV3IFVpbnQ4QXJyYXkodCksZS5IRUFQVTE2PW5ldyBVaW50MTZBcnJheSh0KSxlLkhFQVBVMzI9RT1uZXcgVWludDMyQXJyYXkodCksZS5IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkodCksZS5IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkodCl9dmFyIE4sTD1bXSxSPVtdLGo9W10sTT1bXSxVPTA7ZnVuY3Rpb24gVigpe3ZhciB0PWUucHJlUnVuLnNoaWZ0KCk7TC51bnNoaWZ0KHQpfXZhciBCLHo9MCxHPW51bGwsSD1udWxsO2Z1bmN0aW9uIFcodCl7dGhyb3cgZS5vbkFib3J0JiZlLm9uQWJvcnQodCksdih0PVwiQWJvcnRlZChcIit0K1wiKVwiKSxJPSEwLHQ9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih0K1wiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiKSxpKHQpLHR9ZnVuY3Rpb24gcSgpe3JldHVybiBCLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpfWlmKEI9XCJvcnQtd2FzbS53YXNtXCIsIXEoKSl7dmFyIFg9QjtCPWUubG9jYXRlRmlsZT9lLmxvY2F0ZUZpbGUoWCxtKTptK1h9ZnVuY3Rpb24gWSgpe3ZhciB0PUI7dHJ5e2lmKHQ9PUImJnkpcmV0dXJuIG5ldyBVaW50OEFycmF5KHkpO2lmKHMpcmV0dXJuIHModCk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9Y2F0Y2godCl7Vyh0KX19ZnVuY3Rpb24gSyh0KXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPVwiUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdChcIit0K1wiKVwiLHRoaXMuc3RhdHVzPXR9ZnVuY3Rpb24gWih0KXtmb3IoOzA8dC5sZW5ndGg7KXQuc2hpZnQoKShlKX12YXIgSj1bXSxRPTAsdHQ9MDtmdW5jdGlvbiBldCh0KXt0aGlzLkRiPXQsdGhpcy56Yj10LTI0LHRoaXMuVWI9ZnVuY3Rpb24odCl7RVt0aGlzLnpiKzQ+PjI+Pj4wXT10fSx0aGlzLkViPWZ1bmN0aW9uKCl7cmV0dXJuIEVbdGhpcy56Yis0Pj4yPj4+MF19LHRoaXMuU2I9ZnVuY3Rpb24odCl7RVt0aGlzLnpiKzg+PjI+Pj4wXT10fSx0aGlzLldiPWZ1bmN0aW9uKCl7cmV0dXJuIEVbdGhpcy56Yis4Pj4yPj4+MF19LHRoaXMuVGI9ZnVuY3Rpb24oKXtBW3RoaXMuemI+PjI+Pj4wXT0wfSx0aGlzLkliPWZ1bmN0aW9uKHQpe1NbdGhpcy56YisxMj4+MD4+PjBdPXQ/MTowfSx0aGlzLlBiPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPVNbdGhpcy56YisxMj4+MD4+PjBdfSx0aGlzLkpiPWZ1bmN0aW9uKHQpe1NbdGhpcy56YisxMz4+MD4+PjBdPXQ/MTowfSx0aGlzLkxiPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPVNbdGhpcy56YisxMz4+MD4+PjBdfSx0aGlzLlJiPWZ1bmN0aW9uKHQsZSl7dGhpcy5GYigwKSx0aGlzLlViKHQpLHRoaXMuU2IoZSksdGhpcy5UYigpLHRoaXMuSWIoITEpLHRoaXMuSmIoITEpfSx0aGlzLk5iPWZ1bmN0aW9uKCl7QVt0aGlzLnpiPj4yPj4+MF0rPTF9LHRoaXMuWGI9ZnVuY3Rpb24oKXt2YXIgdD1BW3RoaXMuemI+PjI+Pj4wXTtyZXR1cm4gQVt0aGlzLnpiPj4yPj4+MF09dC0xLDE9PT10fSx0aGlzLkZiPWZ1bmN0aW9uKHQpe0VbdGhpcy56YisxNj4+Mj4+PjBdPXR9LHRoaXMuT2I9ZnVuY3Rpb24oKXtyZXR1cm4gRVt0aGlzLnpiKzE2Pj4yPj4+MF19LHRoaXMuUWI9ZnVuY3Rpb24oKXtpZihFdCh0aGlzLkViKCkpKXJldHVybiBFW3RoaXMuRGI+PjI+Pj4wXTt2YXIgdD10aGlzLk9iKCk7cmV0dXJuIDAhPT10P3Q6dGhpcy5EYn19ZnVuY3Rpb24gbnQodCl7cmV0dXJuIF90KG5ldyBldCh0KS56Yil9dmFyIHJ0PVtdO2Z1bmN0aW9uIGl0KHQpe3ZhciBlPXJ0W3RdO3JldHVybiBlfHwodD49cnQubGVuZ3RoJiYocnQubGVuZ3RoPXQrMSkscnRbdF09ZT1OLmdldCh0KSksZX1mdW5jdGlvbiBvdCh0KXt2YXIgZT1DKHQpKzEsbj15dChlKTtyZXR1cm4gbiYmayh0LFMsbixlKSxufXZhciBhdD17fTtmdW5jdGlvbiBzdCgpe2lmKCF1dCl7dmFyIHQsZT17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzooXCJvYmplY3RcIj09dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzpmfHxcIi4vdGhpcy5wcm9ncmFtXCJ9O2Zvcih0IGluIGF0KXZvaWQgMD09PWF0W3RdP2RlbGV0ZSBlW3RdOmVbdF09YXRbdF07dmFyIG49W107Zm9yKHQgaW4gZSluLnB1c2godCtcIj1cIitlW3RdKTt1dD1ufXJldHVybiB1dH12YXIgdXQsY3Q9W251bGwsW10sW11dO2Z1bmN0aW9uIGx0KHQsZSl7dmFyIG49Y3RbdF07MD09PWV8fDEwPT09ZT8oKDE9PT10P186dikoRChuLDApKSxuLmxlbmd0aD0wKTpuLnB1c2goZSl9dmFyIHB0PTA7ZnVuY3Rpb24gZnQodCl7cmV0dXJuIDA9PXQlNCYmKDAhPXQlMTAwfHwwPT10JTQwMCl9dmFyIGR0PVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0saHQ9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBndCh0LGUsbixyKXtmdW5jdGlvbiBpKHQsZSxuKXtmb3IodD1cIm51bWJlclwiPT10eXBlb2YgdD90LnRvU3RyaW5nKCk6dHx8XCJcIjt0Lmxlbmd0aDxlOyl0PW5bMF0rdDtyZXR1cm4gdH1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIGkodCxlLFwiMFwiKX1mdW5jdGlvbiBhKHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gMD50Py0xOjA8dD8xOjB9dmFyIHI7cmV0dXJuIDA9PT0ocj1uKHQuZ2V0RnVsbFllYXIoKS1lLmdldEZ1bGxZZWFyKCkpKSYmMD09PShyPW4odC5nZXRNb250aCgpLWUuZ2V0TW9udGgoKSkpJiYocj1uKHQuZ2V0RGF0ZSgpLWUuZ2V0RGF0ZSgpKSkscn1mdW5jdGlvbiBzKHQpe3N3aXRjaCh0LmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIHQ7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIHUodCl7dmFyIGU9dC5CYjtmb3IodD1uZXcgRGF0ZShuZXcgRGF0ZSh0LkNiKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8ZTspe3ZhciBuPXQuZ2V0TW9udGgoKSxyPShmdCh0LmdldEZ1bGxZZWFyKCkpP2R0Omh0KVtuXTtpZighKGU+ci10LmdldERhdGUoKSkpe3Quc2V0RGF0ZSh0LmdldERhdGUoKStlKTticmVha31lLT1yLXQuZ2V0RGF0ZSgpKzEsdC5zZXREYXRlKDEpLDExPm4/dC5zZXRNb250aChuKzEpOih0LnNldE1vbnRoKDApLHQuc2V0RnVsbFllYXIodC5nZXRGdWxsWWVhcigpKzEpKX1yZXR1cm4gbj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCkrMSwwLDQpLGU9cyhuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCw0KSksbj1zKG4pLDA+PWEoZSx0KT8wPj1hKG4sdCk/dC5nZXRGdWxsWWVhcigpKzE6dC5nZXRGdWxsWWVhcigpOnQuZ2V0RnVsbFllYXIoKS0xfXZhciBjPUFbcis0MD4+Mj4+PjBdO2Zvcih2YXIgbCBpbiByPXskYjpBW3I+PjI+Pj4wXSxaYjpBW3IrND4+Mj4+PjBdLEdiOkFbcis4Pj4yPj4+MF0sS2I6QVtyKzEyPj4yPj4+MF0sSGI6QVtyKzE2Pj4yPj4+MF0sQ2I6QVtyKzIwPj4yPj4+MF0sQWI6QVtyKzI0Pj4yPj4+MF0sQmI6QVtyKzI4Pj4yPj4+MF0sYmM6QVtyKzMyPj4yPj4+MF0sWWI6QVtyKzM2Pj4yPj4+MF0sYWM6Yz8kKGMpOlwiXCJ9LG49JChuKSxjPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcIiVFY1wiOlwiJWNcIixcIiVFQ1wiOlwiJUNcIixcIiVFeFwiOlwiJW0vJWQvJXlcIixcIiVFWFwiOlwiJUg6JU06JVNcIixcIiVFeVwiOlwiJXlcIixcIiVFWVwiOlwiJVlcIixcIiVPZFwiOlwiJWRcIixcIiVPZVwiOlwiJWVcIixcIiVPSFwiOlwiJUhcIixcIiVPSVwiOlwiJUlcIixcIiVPbVwiOlwiJW1cIixcIiVPTVwiOlwiJU1cIixcIiVPU1wiOlwiJVNcIixcIiVPdVwiOlwiJXVcIixcIiVPVVwiOlwiJVVcIixcIiVPVlwiOlwiJVZcIixcIiVPd1wiOlwiJXdcIixcIiVPV1wiOlwiJVdcIixcIiVPeVwiOlwiJXlcIn0pbj1uLnJlcGxhY2UobmV3IFJlZ0V4cChsLFwiZ1wiKSxjW2xdKTt2YXIgcD1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLGY9XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpO2ZvcihsIGluIGM9e1wiJWFcIjpmdW5jdGlvbih0KXtyZXR1cm4gcFt0LkFiXS5zdWJzdHJpbmcoMCwzKX0sXCIlQVwiOmZ1bmN0aW9uKHQpe3JldHVybiBwW3QuQWJdfSxcIiViXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGZbdC5IYl0uc3Vic3RyaW5nKDAsMyl9LFwiJUJcIjpmdW5jdGlvbih0KXtyZXR1cm4gZlt0LkhiXX0sXCIlQ1wiOmZ1bmN0aW9uKHQpe3JldHVybiBvKCh0LkNiKzE5MDApLzEwMHwwLDIpfSxcIiVkXCI6ZnVuY3Rpb24odCl7cmV0dXJuIG8odC5LYiwyKX0sXCIlZVwiOmZ1bmN0aW9uKHQpe3JldHVybiBpKHQuS2IsMixcIiBcIil9LFwiJWdcIjpmdW5jdGlvbih0KXtyZXR1cm4gdSh0KS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlR1wiOmZ1bmN0aW9uKHQpe3JldHVybiB1KHQpfSxcIiVIXCI6ZnVuY3Rpb24odCl7cmV0dXJuIG8odC5HYiwyKX0sXCIlSVwiOmZ1bmN0aW9uKHQpe3JldHVybiAwPT0odD10LkdiKT90PTEyOjEyPHQmJih0LT0xMiksbyh0LDIpfSxcIiVqXCI6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj0wO248PXQuSGItMTtlKz0oZnQodC5DYisxOTAwKT9kdDpodClbbisrXSk7cmV0dXJuIG8odC5LYitlLDMpfSxcIiVtXCI6ZnVuY3Rpb24odCl7cmV0dXJuIG8odC5IYisxLDIpfSxcIiVNXCI6ZnVuY3Rpb24odCl7cmV0dXJuIG8odC5aYiwyKX0sXCIlblwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXG5cIn0sXCIlcFwiOmZ1bmN0aW9uKHQpe3JldHVybiAwPD10LkdiJiYxMj50LkdiP1wiQU1cIjpcIlBNXCJ9LFwiJVNcIjpmdW5jdGlvbih0KXtyZXR1cm4gbyh0LiRiLDIpfSxcIiV0XCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcdFwifSxcIiV1XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuQWJ8fDd9LFwiJVVcIjpmdW5jdGlvbih0KXtyZXR1cm4gbyhNYXRoLmZsb29yKCh0LkJiKzctdC5BYikvNyksMil9LFwiJVZcIjpmdW5jdGlvbih0KXt2YXIgZT1NYXRoLmZsb29yKCh0LkJiKzctKHQuQWIrNiklNykvNyk7aWYoMj49KHQuQWIrMzcxLXQuQmItMiklNyYmZSsrLGUpNTM9PWUmJig0PT0obj0odC5BYiszNzEtdC5CYiklNyl8fDM9PW4mJmZ0KHQuQ2IpfHwoZT0xKSk7ZWxzZXtlPTUyO3ZhciBuPSh0LkFiKzctdC5CYi0xKSU3Oyg0PT1ufHw1PT1uJiZmdCh0LkNiJTQwMC0xKSkmJmUrK31yZXR1cm4gbyhlLDIpfSxcIiV3XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuQWJ9LFwiJVdcIjpmdW5jdGlvbih0KXtyZXR1cm4gbyhNYXRoLmZsb29yKCh0LkJiKzctKHQuQWIrNiklNykvNyksMil9LFwiJXlcIjpmdW5jdGlvbih0KXtyZXR1cm4odC5DYisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlWVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LkNiKzE5MDB9LFwiJXpcIjpmdW5jdGlvbih0KXt2YXIgZT0wPD0odD10LlliKTtyZXR1cm4gdD1NYXRoLmFicyh0KS82MCwoZT9cIitcIjpcIi1cIikrU3RyaW5nKFwiMDAwMFwiKyh0LzYwKjEwMCt0JTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuYWN9LFwiJSVcIjpmdW5jdGlvbigpe3JldHVyblwiJVwifX0sbj1uLnJlcGxhY2UoLyUlL2csXCJcXDBcXDBcIiksYyluLmluY2x1ZGVzKGwpJiYobj1uLnJlcGxhY2UobmV3IFJlZ0V4cChsLFwiZ1wiKSxjW2xdKHIpKSk7cmV0dXJuIGw9ZnVuY3Rpb24odCl7dmFyIGU9QXJyYXkoQyh0KSsxKTtyZXR1cm4gayh0LGUsMCxlLmxlbmd0aCksZX0obj1uLnJlcGxhY2UoL1xcMFxcMC9nLFwiJVwiKSksbC5sZW5ndGg+ZT8wOihTLnNldChsLHQ+Pj4wKSxsLmxlbmd0aC0xKX12YXIgYnQ9e2E6ZnVuY3Rpb24odCl7cmV0dXJuIHl0KHQrMjQpKzI0fSxtOmZ1bmN0aW9uKHQpe3JldHVybih0PW5ldyBldCh0KSkuUGIoKXx8KHQuSWIoITApLFEtLSksdC5KYighMSksSi5wdXNoKHQpLHQuTmIoKSx0LlFiKCl9LGlhOmZ1bmN0aW9uKHQpe3Rocm93IHYoXCJVbmV4cGVjdGVkIGV4Y2VwdGlvbiB0aHJvd24sIHRoaXMgaXMgbm90IHByb3Blcmx5IHN1cHBvcnRlZCAtIGFib3J0aW5nXCIpLEk9ITAsdH0sdzpmdW5jdGlvbigpe3h0KDApO3ZhciB0PUoucG9wKCk7aWYodC5YYigpJiYhdC5MYigpKXt2YXIgZT10LldiKCk7ZSYmaXQoZSkodC5EYiksbnQodC5EYil9dHQ9MH0sZDpmdW5jdGlvbigpe3ZhciB0PXR0O2lmKCF0KXJldHVybiBwdD0wO3ZhciBlPW5ldyBldCh0KTtlLkZiKHQpO3ZhciBuPWUuRWIoKTtpZighbilyZXR1cm4gcHQ9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGk9MDtpPHIubGVuZ3RoO2krKyl7dmFyIG89cltpXTtpZigwPT09b3x8bz09PW4pYnJlYWs7aWYoQXQobyxuLGUuemIrMTYpKXJldHVybiBwdD1vLHR9cmV0dXJuIHB0PW4sdH0sazpmdW5jdGlvbigpe3ZhciB0PXR0O2lmKCF0KXJldHVybiBwdD0wO3ZhciBlPW5ldyBldCh0KTtlLkZiKHQpO3ZhciBuPWUuRWIoKTtpZighbilyZXR1cm4gcHQ9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGk9MDtpPHIubGVuZ3RoO2krKyl7dmFyIG89cltpXTtpZigwPT09b3x8bz09PW4pYnJlYWs7aWYoQXQobyxuLGUuemIrMTYpKXJldHVybiBwdD1vLHR9cmV0dXJuIHB0PW4sdH0sZzpmdW5jdGlvbigpe3ZhciB0PXR0O2lmKCF0KXJldHVybiBwdD0wO3ZhciBlPW5ldyBldCh0KTtlLkZiKHQpO3ZhciBuPWUuRWIoKTtpZighbilyZXR1cm4gcHQ9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGk9MDtpPHIubGVuZ3RoO2krKyl7dmFyIG89cltpXTtpZigwPT09b3x8bz09PW4pYnJlYWs7aWYoQXQobyxuLGUuemIrMTYpKXJldHVybiBwdD1vLHR9cmV0dXJuIHB0PW4sdH0sczpudCxMOmZ1bmN0aW9uKCl7dmFyIHQ9Si5wb3AoKTt0fHxXKFwibm8gZXhjZXB0aW9uIHRvIHRocm93XCIpO3ZhciBlPXQuRGI7dGhyb3cgdC5MYigpfHwoSi5wdXNoKHQpLHQuSmIoITApLHQuSWIoITEpLFErKyksdHQ9ZSxlfSxiOmZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgZXQodCkuUmIoZSxuKSx0dD10LFErKyx0fSxsYTpmdW5jdGlvbigpe3JldHVybiBRfSxpOmZ1bmN0aW9uKHQpe3Rocm93IHR0fHwodHQ9dCksdH0sSDpmdW5jdGlvbigpe3JldHVybiAwfSxCYTpmdW5jdGlvbigpe30scGE6ZnVuY3Rpb24oKXt9LHJhOmZ1bmN0aW9uKCl7fSxrYTpmdW5jdGlvbigpe3JldHVybiAwfSx6YTpmdW5jdGlvbigpe30sdWE6ZnVuY3Rpb24oKXt9LHlhOmZ1bmN0aW9uKCl7fSxSOmZ1bmN0aW9uKCl7fSxxYTpmdW5jdGlvbigpe30sbmE6ZnVuY3Rpb24oKXt9LEFhOmZ1bmN0aW9uKCl7fSxvYTpmdW5jdGlvbigpe30sSGE6ZnVuY3Rpb24oKXt9LEphOmZ1bmN0aW9uKCl7VyhcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxJYTpmdW5jdGlvbigpe1coXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0sUzpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfSxDYTpmdW5jdGlvbigpe3JldHVybiEwfSxEYTpmdW5jdGlvbih0LGUpe3Q9bmV3IERhdGUoMWUzKihFW3Q+Pj4yXSs0Mjk0OTY3Mjk2KkFbdCs0Pj4+Ml0pKSxBW2U+PjI+Pj4wXT10LmdldFVUQ1NlY29uZHMoKSxBW2UrND4+Mj4+PjBdPXQuZ2V0VVRDTWludXRlcygpLEFbZSs4Pj4yPj4+MF09dC5nZXRVVENIb3VycygpLEFbZSsxMj4+Mj4+PjBdPXQuZ2V0VVRDRGF0ZSgpLEFbZSsxNj4+Mj4+PjBdPXQuZ2V0VVRDTW9udGgoKSxBW2UrMjA+PjI+Pj4wXT10LmdldFVUQ0Z1bGxZZWFyKCktMTkwMCxBW2UrMjQ+PjI+Pj4wXT10LmdldFVUQ0RheSgpLEFbZSsyOD4+Mj4+PjBdPSh0LmdldFRpbWUoKS1EYXRlLlVUQyh0LmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwfSxFYTpmdW5jdGlvbih0LGUpe3Q9bmV3IERhdGUoMWUzKihFW3Q+Pj4yXSs0Mjk0OTY3Mjk2KkFbdCs0Pj4+Ml0pKSxBW2U+PjI+Pj4wXT10LmdldFNlY29uZHMoKSxBW2UrND4+Mj4+PjBdPXQuZ2V0TWludXRlcygpLEFbZSs4Pj4yPj4+MF09dC5nZXRIb3VycygpLEFbZSsxMj4+Mj4+PjBdPXQuZ2V0RGF0ZSgpLEFbZSsxNj4+Mj4+PjBdPXQuZ2V0TW9udGgoKSxBW2UrMjA+PjI+Pj4wXT10LmdldEZ1bGxZZWFyKCktMTkwMCxBW2UrMjQ+PjI+Pj4wXT10LmdldERheSgpO3ZhciBuPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDEpO0FbZSsyOD4+Mj4+PjBdPSh0LmdldFRpbWUoKS1uLmdldFRpbWUoKSkvODY0ZTV8MCxBW2UrMzY+PjI+Pj4wXT0tNjAqdC5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciByPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7bj1uLmdldFRpbWV6b25lT2Zmc2V0KCksQVtlKzMyPj4yPj4+MF09MHwociE9biYmdC5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbihuLHIpKX0sRmE6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IERhdGUoQVt0KzIwPj4yPj4+MF0rMTkwMCxBW3QrMTY+PjI+Pj4wXSxBW3QrMTI+PjI+Pj4wXSxBW3QrOD4+Mj4+PjBdLEFbdCs0Pj4yPj4+MF0sQVt0Pj4yPj4+MF0sMCksbj1BW3QrMzI+PjI+Pj4wXSxyPWUuZ2V0VGltZXpvbmVPZmZzZXQoKSxpPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDEpLG89bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxhPWkuZ2V0VGltZXpvbmVPZmZzZXQoKSxzPU1hdGgubWluKGEsbyk7cmV0dXJuIDA+bj9BW3QrMzI+PjI+Pj4wXT1OdW1iZXIobyE9YSYmcz09cik6MDxuIT0ocz09cikmJihvPU1hdGgubWF4KGEsbyksZS5zZXRUaW1lKGUuZ2V0VGltZSgpKzZlNCooKDA8bj9zOm8pLXIpKSksQVt0KzI0Pj4yPj4+MF09ZS5nZXREYXkoKSxBW3QrMjg+PjI+Pj4wXT0oZS5nZXRUaW1lKCktaS5nZXRUaW1lKCkpLzg2NGU1fDAsQVt0Pj4yPj4+MF09ZS5nZXRTZWNvbmRzKCksQVt0KzQ+PjI+Pj4wXT1lLmdldE1pbnV0ZXMoKSxBW3QrOD4+Mj4+PjBdPWUuZ2V0SG91cnMoKSxBW3QrMTI+PjI+Pj4wXT1lLmdldERhdGUoKSxBW3QrMTY+PjI+Pj4wXT1lLmdldE1vbnRoKCksZS5nZXRUaW1lKCkvMWUzfDB9LHNhOmZ1bmN0aW9uKCl7cmV0dXJuLTUyfSx0YTpmdW5jdGlvbigpe30sR2E6ZnVuY3Rpb24gdChlLG4scil7dC5WYnx8KHQuVmI9ITAsZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuKHQ9dC50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFwoKFtBLVphLXogXSspXFwpJC8pKT90WzFdOlwiR01UXCJ9dmFyIGk9KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpLG89bmV3IERhdGUoaSwwLDEpLGE9bmV3IERhdGUoaSw2LDEpO2k9by5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBzPWEuZ2V0VGltZXpvbmVPZmZzZXQoKTtBW3Q+PjI+Pj4wXT02MCpNYXRoLm1heChpLHMpLEFbZT4+Mj4+PjBdPU51bWJlcihpIT1zKSx0PXIobyksZT1yKGEpLHQ9b3QodCksZT1vdChlKSxzPGk/KEVbbj4+Mj4+PjBdPXQsRVtuKzQ+PjI+Pj4wXT1lKTooRVtuPj4yPj4+MF09ZSxFW24rND4+Mj4+PjBdPXQpfShlLG4scikpfSxCOmZ1bmN0aW9uKCl7VyhcIlwiKX0sbWE6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sSTpiPygpPT57dmFyIHQ9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gMWUzKnRbMF0rdFsxXS8xZTZ9OigpPT5wZXJmb3JtYW5jZS5ub3coKSx4YTpmdW5jdGlvbih0LGUsbil7Ty5jb3B5V2l0aGluKHQ+Pj4wLGU+Pj4wLGUrbj4+PjApfSxHOmZ1bmN0aW9uKHQpe3ZhciBlPU8ubGVuZ3RoO2lmKDQyOTQ5MDE3NjA8KHQ+Pj49MCkpcmV0dXJuITE7Zm9yKHZhciBuPTE7ND49bjtuKj0yKXt2YXIgcj1lKigxKy4yL24pO3I9TWF0aC5taW4ocix0KzEwMDY2MzI5Nik7dmFyIGk9TWF0aDtyPU1hdGgubWF4KHQsciksaT1pLm1pbi5jYWxsKGksNDI5NDkwMTc2MCxyKyg2NTUzNi1yJTY1NTM2KSU2NTUzNik7dDp7dHJ5e3guZ3JvdyhpLVQuYnl0ZUxlbmd0aCs2NTUzNT4+PjE2KSxGKCk7dmFyIG89MTticmVhayB0fWNhdGNoKHQpe31vPXZvaWQgMH1pZihvKXJldHVybiEwfXJldHVybiExfSx2YTpmdW5jdGlvbih0LGUpe3ZhciBuPTA7cmV0dXJuIHN0KCkuZm9yRWFjaCgoZnVuY3Rpb24ocixpKXt2YXIgbz1lK247Zm9yKGk9RVt0KzQqaT4+Mj4+PjBdPW8sbz0wO288ci5sZW5ndGg7KytvKVNbaSsrPj4wPj4+MF09ci5jaGFyQ29kZUF0KG8pO1NbaT4+MD4+PjBdPTAsbis9ci5sZW5ndGgrMX0pKSwwfSx3YTpmdW5jdGlvbih0LGUpe3ZhciBuPXN0KCk7RVt0Pj4yPj4+MF09bi5sZW5ndGg7dmFyIHI9MDtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbih0KXtyKz10Lmxlbmd0aCsxfSkpLEVbZT4+Mj4+PjBdPXIsMH0sYmE6ZnVuY3Rpb24odCl7d3x8MDxVfHwod3QoKSxaKGopLHZ0KDApLGN0WzFdLmxlbmd0aCYmbHQoMSwxMCksY3RbMl0ubGVuZ3RoJiZsdCgyLDEwKSksd3x8MDxVfHwoZS5vbkV4aXQmJmUub25FeGl0KHQpLEk9ITApLGQodCxuZXcgSyh0KSl9LEU6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LFE6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LGNhOmZ1bmN0aW9uKCl7cmV0dXJuIDcwfSxQOmZ1bmN0aW9uKHQsZSxuLHIpe2Zvcih2YXIgaT0wLG89MDtvPG47bysrKXt2YXIgYT1FW2U+PjI+Pj4wXSxzPUVbZSs0Pj4yPj4+MF07ZSs9ODtmb3IodmFyIHU9MDt1PHM7dSsrKWx0KHQsT1thK3U+Pj4wXSk7aSs9c31yZXR1cm4gRVtyPj4yPj4+MF09aSwwfSxjOmZ1bmN0aW9uKCl7cmV0dXJuIHB0fSxqYTpmdW5jdGlvbiB0KGUscil7dC5NYnx8KHQuTWI9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+KGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdFswXSl9aWYoYil0cnl7dmFyIGU9bihPYmplY3QoZnVuY3Rpb24oKXt2YXIgdD1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ2NyeXB0bydcIik7dGhyb3cgdC5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLHR9KCkpKTtyZXR1cm4oKT0+ZS5yYW5kb21CeXRlcygxKVswXX1jYXRjaCh0KXt9cmV0dXJuKCk9PlcoXCJyYW5kb21EZXZpY2VcIil9KCkpO2Zvcih2YXIgaT0wO2k8cjtpKyspU1tlK2k+PjA+Pj4wXT10Lk1iKCk7cmV0dXJuIDB9LGVhOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LGZhOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LEo6ZnVuY3Rpb24odCl7dmFyIGU9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKCl9Y2F0Y2godCl7aWYoU3QoZSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxlOmZ1bmN0aW9uKHQsZSl7dmFyIG49VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUpfWNhdGNoKHQpe2lmKFN0KG4pLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sTjpmdW5jdGlvbih0LGUsbil7dmFyIHI9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxPOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LGo6ZnVuY3Rpb24odCxlLG4pe3ZhciByPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sbzpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKFN0KGkpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0scDpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4scixpKX1jYXRjaCh0KXtpZihTdChvKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LE06ZnVuY3Rpb24odCxlLG4scixpLG8pe3ZhciBhPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4scixpLG8pfWNhdGNoKHQpe2lmKFN0KGEpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0scjpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbixyLGksbyl9Y2F0Y2godCl7aWYoU3QoYSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSx2OmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEpe3ZhciBzPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4scixpLG8sYSl9Y2F0Y2godCl7aWYoU3QocyksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxLOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKFN0KHUpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sRDpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMsdSxjLGwscCl7dmFyIGY9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbixyLGksbyxhLHMsdSxjLGwscCl9Y2F0Y2godCl7aWYoU3QoZiksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxYOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9VHQoKTt0cnl7cmV0dXJuIEx0KHQsZSxuLHIsaSxvLGEscyl9Y2F0Y2godCl7aWYoU3QodSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxWOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEpe3ZhciBzPVR0KCk7dHJ5e3JldHVybiBQdCh0LGUsbixyLGksbyxhKX1jYXRjaCh0KXtpZihTdChzKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LFU6ZnVuY3Rpb24odCxlLG4scixpKXt2YXIgbz1UdCgpO3RyeXtyZXR1cm4gUnQodCxlLG4scixpKX1jYXRjaCh0KXtpZihTdChvKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LFo6ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9VHQoKTt0cnl7cmV0dXJuIEZ0KHQsZSxuLHIpfWNhdGNoKHQpe2lmKFN0KGkpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sVzpmdW5jdGlvbih0KXt2YXIgZT1UdCgpO3RyeXtyZXR1cm4gSXQodCl9Y2F0Y2godCl7aWYoU3QoZSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxZOmZ1bmN0aW9uKHQsZSl7dmFyIG49VHQoKTt0cnl7cmV0dXJuIE50KHQsZSl9Y2F0Y2godCl7aWYoU3QobiksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxUOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1UdCgpO3RyeXtyZXR1cm4gRHQodCxlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sZjpmdW5jdGlvbih0KXt2YXIgZT1UdCgpO3RyeXtpdCh0KSgpfWNhdGNoKHQpe2lmKFN0KGUpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0scTpmdW5jdGlvbih0LGUpe3ZhciBuPVR0KCk7dHJ5e2l0KHQpKGUpfWNhdGNoKHQpe2lmKFN0KG4pLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0saDpmdW5jdGlvbih0LGUsbil7dmFyIHI9VHQoKTt0cnl7aXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LGRhOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPVR0KCk7dHJ5e2l0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihTdChpKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LGw6ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9VHQoKTt0cnl7aXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKFN0KGkpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sdDpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPVR0KCk7dHJ5e2l0KHQpKGUsbixyLGkpfWNhdGNoKHQpe2lmKFN0KG8pLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sdTpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9VHQoKTt0cnl7aXQodCkoZSxuLHIsaSxvKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LHg6ZnVuY3Rpb24odCxlLG4scixpLG8sYSl7dmFyIHM9VHQoKTt0cnl7aXQodCkoZSxuLHIsaSxvLGEpfWNhdGNoKHQpe2lmKFN0KHMpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sejpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMpe3ZhciB1PVR0KCk7dHJ5e2l0KHQpKGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKFN0KHUpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sZ2E6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzLHUpe3ZhciBjPVR0KCk7dHJ5e2l0KHQpKGUsbixyLGksbyxhLHMsdSl9Y2F0Y2godCl7aWYoU3QoYyksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxBOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCl7dmFyIHA9VHQoKTt0cnl7aXQodCkoZSxuLHIsaSxvLGEscyx1LGMsbCl9Y2F0Y2godCl7aWYoU3QocCksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxDOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwLGYsZCxoLGcpe3ZhciBiPVR0KCk7dHJ5e2l0KHQpKGUsbixyLGksbyxhLHMsdSxjLGwscCxmLGQsaCxnKX1jYXRjaCh0KXtpZihTdChiKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LGFhOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9VHQoKTt0cnl7JHQodCxlLG4scixpLG8sYSxzKX1jYXRjaCh0KXtpZihTdCh1KSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LF86ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzLHUsYyxsLHApe3ZhciBmPVR0KCk7dHJ5e0N0KHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwKX1jYXRjaCh0KXtpZihTdChmKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LCQ6ZnVuY3Rpb24odCxlLG4scixpLG8pe3ZhciBhPVR0KCk7dHJ5e2t0KHQsZSxuLHIsaSxvKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LG46ZnVuY3Rpb24odCl7cmV0dXJuIHR9LEY6ZnVuY3Rpb24odCl7cHQ9dH0saGE6Z3QseTpmdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gZ3QodCxlLG4scil9fTshZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2UuYXNtPXQuZXhwb3J0cyx4PWUuYXNtLkthLEYoKSxOPWUuYXNtLmliLFIudW5zaGlmdChlLmFzbS5MYSksei0tLGUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKHopLDA9PXomJihudWxsIT09RyYmKGNsZWFySW50ZXJ2YWwoRyksRz1udWxsKSxIJiYodD1ILEg9bnVsbCx0KCkpKX1mdW5jdGlvbiBuKGUpe3QoZS5pbnN0YW5jZSl9ZnVuY3Rpb24gcih0KXtyZXR1cm4gZnVuY3Rpb24oKXtpZigheSYmKGh8fGcpKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBmZXRjaCYmIUIuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpcmV0dXJuIGZldGNoKEIse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKHQpe2lmKCF0Lm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIitCK1wiJ1wiO3JldHVybiB0LmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIFkoKX0pKTtpZihhKXJldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxlKXthKEIsKGZ1bmN0aW9uKGUpe3QobmV3IFVpbnQ4QXJyYXkoZSkpfSksZSl9KSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIFkoKX0pKX0oKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUodCxvKX0pKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gdH0pKS50aGVuKHQsKGZ1bmN0aW9uKHQpe3YoXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIit0KSxXKHQpfSkpfXZhciBvPXthOmJ0fTtpZih6KyssZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoeiksZS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBlLmluc3RhbnRpYXRlV2FzbShvLHQpfWNhdGNoKHQpe3JldHVybiB2KFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrdCksITF9KHl8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxxKCl8fEIuc3RhcnRzV2l0aChcImZpbGU6Ly9cIil8fGJ8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGZldGNoP3Iobik6ZmV0Y2goQix7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHQsbykudGhlbihuLChmdW5jdGlvbih0KXtyZXR1cm4gdihcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIit0KSx2KFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIikscihuKX0pKX0pKSkuY2F0Y2goaSl9KCksZS5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fX193YXNtX2NhbGxfY3RvcnM9ZS5hc20uTGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0SW5pdD1mdW5jdGlvbigpe3JldHVybihlLl9PcnRJbml0PWUuYXNtLk1hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPWUuYXNtLk5hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWUuYXNtLk9hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9ZS5hc20uUGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1lLmFzbS5RYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRDcmVhdGVTZXNzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydENyZWF0ZVNlc3Npb249ZS5hc20uUmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UmVsZWFzZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVNlc3Npb249ZS5hc20uU2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0SW5wdXRDb3VudD1mdW5jdGlvbigpe3JldHVybihlLl9PcnRHZXRJbnB1dENvdW50PWUuYXNtLlRhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEdldE91dHB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldE91dHB1dENvdW50PWUuYXNtLlVhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEdldElucHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRHZXRJbnB1dE5hbWU9ZS5hc20uVmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0T3V0cHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRHZXRPdXRwdXROYW1lPWUuYXNtLldhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0RnJlZT1lLmFzbS5YYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRDcmVhdGVUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0Q3JlYXRlVGVuc29yPWUuYXNtLllhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEdldFRlbnNvckRhdGE9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0R2V0VGVuc29yRGF0YT1lLmFzbS5aYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRSZWxlYXNlVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydFJlbGVhc2VUZW5zb3I9ZS5hc20uX2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybihlLl9PcnRDcmVhdGVSdW5PcHRpb25zPWUuYXNtLiRhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWUuYXNtLmFiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydFJlbGVhc2VSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydFJlbGVhc2VSdW5PcHRpb25zPWUuYXNtLmJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydFJ1bj1mdW5jdGlvbigpe3JldHVybihlLl9PcnRSdW49ZS5hc20uY2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0RW5kUHJvZmlsaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEVuZFByb2ZpbGluZz1lLmFzbS5kYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgbXQseXQ9ZS5fbWFsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKHl0PWUuX21hbGxvYz1lLmFzbS5lYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxfdD1lLl9mcmVlPWZ1bmN0aW9uKCl7cmV0dXJuKF90PWUuX2ZyZWU9ZS5hc20uZmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdnQ9ZS5fZmZsdXNoPWZ1bmN0aW9uKCl7cmV0dXJuKHZ0PWUuX2ZmbHVzaD1lLmFzbS5nYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx3dD1lLl9fX2Z1bmNzX29uX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4od3Q9ZS5fX19mdW5jc19vbl9leGl0PWUuYXNtLmhiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHh0PWUuX3NldFRocmV3PWZ1bmN0aW9uKCl7cmV0dXJuKHh0PWUuX3NldFRocmV3PWUuYXNtLmpiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFR0PWUuc3RhY2tTYXZlPWZ1bmN0aW9uKCl7cmV0dXJuKFR0PWUuc3RhY2tTYXZlPWUuYXNtLmtiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFN0PWUuc3RhY2tSZXN0b3JlPWZ1bmN0aW9uKCl7cmV0dXJuKFN0PWUuc3RhY2tSZXN0b3JlPWUuYXNtLmxiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE90PWUuc3RhY2tBbGxvYz1mdW5jdGlvbigpe3JldHVybihPdD1lLnN0YWNrQWxsb2M9ZS5hc20ubWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQXQ9ZS5fX19jeGFfY2FuX2NhdGNoPWZ1bmN0aW9uKCl7cmV0dXJuKEF0PWUuX19fY3hhX2Nhbl9jYXRjaD1lLmFzbS5uYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFdD1lLl9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4oRXQ9ZS5fX19jeGFfaXNfcG9pbnRlcl90eXBlPWUuYXNtLm9iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEl0PWUuZHluQ2FsbF9qPWZ1bmN0aW9uKCl7cmV0dXJuKEl0PWUuZHluQ2FsbF9qPWUuYXNtLnBiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFB0PWUuZHluQ2FsbF9paWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oUHQ9ZS5keW5DYWxsX2lpaWlpaj1lLmFzbS5xYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxEdD1lLmR5bkNhbGxfamlpPWZ1bmN0aW9uKCl7cmV0dXJuKER0PWUuZHluQ2FsbF9qaWk9ZS5hc20ucmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sJHQ9ZS5keW5DYWxsX3ZpaWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oJHQ9ZS5keW5DYWxsX3ZpaWlpaWo9ZS5hc20uc2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sa3Q9ZS5keW5DYWxsX3Zqamk9ZnVuY3Rpb24oKXtyZXR1cm4oa3Q9ZS5keW5DYWxsX3Zqamk9ZS5hc20udGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQ3Q9ZS5keW5DYWxsX3ZpaWlqamppaT1mdW5jdGlvbigpe3JldHVybihDdD1lLmR5bkNhbGxfdmlpaWpqamlpPWUuYXNtLnViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEZ0PWUuZHluQ2FsbF9paWo9ZnVuY3Rpb24oKXtyZXR1cm4oRnQ9ZS5keW5DYWxsX2lpaj1lLmFzbS52YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxOdD1lLmR5bkNhbGxfamk9ZnVuY3Rpb24oKXtyZXR1cm4oTnQ9ZS5keW5DYWxsX2ppPWUuYXNtLndiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEx0PWUuZHluQ2FsbF9paWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKEx0PWUuZHluQ2FsbF9paWlpaWlqPWUuYXNtLnhiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFJ0PWUuZHluQ2FsbF9paWlqPWZ1bmN0aW9uKCl7cmV0dXJuKFJ0PWUuZHluQ2FsbF9paWlqPWUuYXNtLnliKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIGp0KCl7ZnVuY3Rpb24gdCgpe2lmKCFtdCYmKG10PSEwLGUuY2FsbGVkUnVuPSEwLCFJKSl7aWYoWihSKSxyKGUpLGUub25SdW50aW1lSW5pdGlhbGl6ZWQmJmUub25SdW50aW1lSW5pdGlhbGl6ZWQoKSxlLnBvc3RSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUucG9zdFJ1biYmKGUucG9zdFJ1bj1bZS5wb3N0UnVuXSk7ZS5wb3N0UnVuLmxlbmd0aDspe3ZhciB0PWUucG9zdFJ1bi5zaGlmdCgpO00udW5zaGlmdCh0KX1aKE0pfX1pZighKDA8eikpe2lmKGUucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnByZVJ1biYmKGUucHJlUnVuPVtlLnByZVJ1bl0pO2UucHJlUnVuLmxlbmd0aDspVigpO1ooTCksMDx6fHwoZS5zZXRTdGF0dXM/KGUuc2V0U3RhdHVzKFwiUnVubmluZy4uLlwiKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZS5zZXRTdGF0dXMoXCJcIil9KSwxKSx0KCl9KSwxKSk6dCgpKX19aWYoZS5VVEY4VG9TdHJpbmc9JCxlLnN0cmluZ1RvVVRGOD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGsodCxPLGUsbil9LGUubGVuZ3RoQnl0ZXNVVEY4PUMsZS5zdGFja1NhdmU9VHQsZS5zdGFja1Jlc3RvcmU9U3QsZS5zdGFja0FsbG9jPU90LEg9ZnVuY3Rpb24gdCgpe210fHxqdCgpLG10fHwoSD10KX0sZS5wcmVJbml0KWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnByZUluaXQmJihlLnByZUluaXQ9W2UucHJlSW5pdF0pOzA8ZS5wcmVJbml0Lmxlbmd0aDspZS5wcmVJbml0LnBvcCgpKCk7cmV0dXJuIGp0KCksdC5yZWFkeX0pO3QuZXhwb3J0cz1yfSw0NTM3OnQ9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSkscj0wLGk9MixvPSEwO2k8YXJndW1lbnRzLmxlbmd0aDspbltyKytdPWFyZ3VtZW50c1tpKytdO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oaSxhKXtuW3JdPWZ1bmN0aW9uKHQpe2lmKG8paWYobz0hMSx0KWEodCk7ZWxzZXtmb3IodmFyIGU9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSksbj0wO248ZS5sZW5ndGg7KWVbbisrXT1hcmd1bWVudHNbbl07aS5hcHBseShudWxsLGUpfX07dHJ5e3QuYXBwbHkoZXx8bnVsbCxuKX1jYXRjaCh0KXtvJiYobz0hMSxhKHQpKX19KSl9fSw3NDE5Oih0LGUpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ZTtuLmxlbmd0aD1mdW5jdGlvbih0KXt2YXIgZT10Lmxlbmd0aDtpZighZSlyZXR1cm4gMDtmb3IodmFyIG49MDstLWUlND4xJiZcIj1cIj09PXQuY2hhckF0KGUpOykrK247cmV0dXJuIE1hdGguY2VpbCgzKnQubGVuZ3RoKS80LW59O2Zvcih2YXIgcj1uZXcgQXJyYXkoNjQpLGk9bmV3IEFycmF5KDEyMyksbz0wO288NjQ7KWlbcltvXT1vPDI2P28rNjU6bzw1Mj9vKzcxOm88NjI/by00Om8tNTl8NDNdPW8rKztuLmVuY29kZT1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpLG89bnVsbCxhPVtdLHM9MCx1PTA7ZTxuOyl7dmFyIGM9dFtlKytdO3N3aXRjaCh1KXtjYXNlIDA6YVtzKytdPXJbYz4+Ml0saT0oMyZjKTw8NCx1PTE7YnJlYWs7Y2FzZSAxOmFbcysrXT1yW2l8Yz4+NF0saT0oMTUmYyk8PDIsdT0yO2JyZWFrO2Nhc2UgMjphW3MrK109cltpfGM+PjZdLGFbcysrXT1yWzYzJmNdLHU9MH1zPjgxOTEmJigob3x8KG89W10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGEpKSxzPTApfXJldHVybiB1JiYoYVtzKytdPXJbaV0sYVtzKytdPTYxLDE9PT11JiYoYVtzKytdPTYxKSksbz8ocyYmby5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGEuc2xpY2UoMCxzKSkpLG8uam9pbihcIlwiKSk6U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsYS5zbGljZSgwLHMpKX07dmFyIGE9XCJpbnZhbGlkIGVuY29kaW5nXCI7bi5kZWNvZGU9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcixvPW4scz0wLHU9MDt1PHQubGVuZ3RoOyl7dmFyIGM9dC5jaGFyQ29kZUF0KHUrKyk7aWYoNjE9PT1jJiZzPjEpYnJlYWs7aWYodm9pZCAwPT09KGM9aVtjXSkpdGhyb3cgRXJyb3IoYSk7c3dpdGNoKHMpe2Nhc2UgMDpyPWMscz0xO2JyZWFrO2Nhc2UgMTplW24rK109cjw8MnwoNDgmYyk+PjQscj1jLHM9MjticmVhaztjYXNlIDI6ZVtuKytdPSgxNSZyKTw8NHwoNjAmYyk+PjIscj1jLHM9MzticmVhaztjYXNlIDM6ZVtuKytdPSgzJnIpPDw2fGMscz0wfX1pZigxPT09cyl0aHJvdyBFcnJvcihhKTtyZXR1cm4gbi1vfSxuLnRlc3Q9ZnVuY3Rpb24odCl7cmV0dXJuL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvLnRlc3QodCl9fSw5MjExOnQ9PntcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBlKCl7dGhpcy5fbGlzdGVuZXJzPXt9fXQuZXhwb3J0cz1lLGUucHJvdG90eXBlLm9uPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4odGhpcy5fbGlzdGVuZXJzW3RdfHwodGhpcy5fbGlzdGVuZXJzW3RdPVtdKSkucHVzaCh7Zm46ZSxjdHg6bnx8dGhpc30pLHRoaXN9LGUucHJvdG90eXBlLm9mZj1mdW5jdGlvbih0LGUpe2lmKHZvaWQgMD09PXQpdGhpcy5fbGlzdGVuZXJzPXt9O2Vsc2UgaWYodm9pZCAwPT09ZSl0aGlzLl9saXN0ZW5lcnNbdF09W107ZWxzZSBmb3IodmFyIG49dGhpcy5fbGlzdGVuZXJzW3RdLHI9MDtyPG4ubGVuZ3RoOyluW3JdLmZuPT09ZT9uLnNwbGljZShyLDEpOisrcjtyZXR1cm4gdGhpc30sZS5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLl9saXN0ZW5lcnNbdF07aWYoZSl7Zm9yKHZhciBuPVtdLHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7KW4ucHVzaChhcmd1bWVudHNbcisrXSk7Zm9yKHI9MDtyPGUubGVuZ3RoOyllW3JdLmZuLmFwcGx5KGVbcisrXS5jdHgsbil9cmV0dXJuIHRoaXN9fSw5NDU6dD0+e1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUodCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEZsb2F0MzJBcnJheT9mdW5jdGlvbigpe3ZhciBlPW5ldyBGbG9hdDMyQXJyYXkoWy0wXSksbj1uZXcgVWludDhBcnJheShlLmJ1ZmZlcikscj0xMjg9PT1uWzNdO2Z1bmN0aW9uIGkodCxyLGkpe2VbMF09dCxyW2ldPW5bMF0scltpKzFdPW5bMV0scltpKzJdPW5bMl0scltpKzNdPW5bM119ZnVuY3Rpb24gbyh0LHIsaSl7ZVswXT10LHJbaV09blszXSxyW2krMV09blsyXSxyW2krMl09blsxXSxyW2krM109blswXX1mdW5jdGlvbiBhKHQscil7cmV0dXJuIG5bMF09dFtyXSxuWzFdPXRbcisxXSxuWzJdPXRbcisyXSxuWzNdPXRbciszXSxlWzBdfWZ1bmN0aW9uIHModCxyKXtyZXR1cm4gblszXT10W3JdLG5bMl09dFtyKzFdLG5bMV09dFtyKzJdLG5bMF09dFtyKzNdLGVbMF19dC53cml0ZUZsb2F0TEU9cj9pOm8sdC53cml0ZUZsb2F0QkU9cj9vOmksdC5yZWFkRmxvYXRMRT1yP2E6cyx0LnJlYWRGbG9hdEJFPXI/czphfSgpOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LGUsbixyKXt2YXIgaT1lPDA/MTowO2lmKGkmJihlPS1lKSwwPT09ZSl0KDEvZT4wPzA6MjE0NzQ4MzY0OCxuLHIpO2Vsc2UgaWYoaXNOYU4oZSkpdCgyMTQzMjg5MzQ0LG4scik7ZWxzZSBpZihlPjM0MDI4MjM0NjYzODUyODg2ZTIyKXQoKGk8PDMxfDIxMzkwOTUwNDApPj4+MCxuLHIpO2Vsc2UgaWYoZTwxMTc1NDk0MzUwODIyMjg3NWUtNTQpdCgoaTw8MzF8TWF0aC5yb3VuZChlLzE0MDEyOTg0NjQzMjQ4MTdlLTYwKSk+Pj4wLG4scik7ZWxzZXt2YXIgbz1NYXRoLmZsb29yKE1hdGgubG9nKGUpL01hdGguTE4yKTt0KChpPDwzMXxvKzEyNzw8MjN8ODM4ODYwNyZNYXRoLnJvdW5kKGUqTWF0aC5wb3coMiwtbykqODM4ODYwOCkpPj4+MCxuLHIpfX1mdW5jdGlvbiBhKHQsZSxuKXt2YXIgcj10KGUsbiksaT0yKihyPj4zMSkrMSxvPXI+Pj4yMyYyNTUsYT04Mzg4NjA3JnI7cmV0dXJuIDI1NT09PW8/YT9OYU46aSooMS8wKTowPT09bz8xNDAxMjk4NDY0MzI0ODE3ZS02MCppKmE6aSpNYXRoLnBvdygyLG8tMTUwKSooYSs4Mzg4NjA4KX10LndyaXRlRmxvYXRMRT1lLmJpbmQobnVsbCxuKSx0LndyaXRlRmxvYXRCRT1lLmJpbmQobnVsbCxyKSx0LnJlYWRGbG9hdExFPWEuYmluZChudWxsLGkpLHQucmVhZEZsb2F0QkU9YS5iaW5kKG51bGwsbyl9KCksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEZsb2F0NjRBcnJheT9mdW5jdGlvbigpe3ZhciBlPW5ldyBGbG9hdDY0QXJyYXkoWy0wXSksbj1uZXcgVWludDhBcnJheShlLmJ1ZmZlcikscj0xMjg9PT1uWzddO2Z1bmN0aW9uIGkodCxyLGkpe2VbMF09dCxyW2ldPW5bMF0scltpKzFdPW5bMV0scltpKzJdPW5bMl0scltpKzNdPW5bM10scltpKzRdPW5bNF0scltpKzVdPW5bNV0scltpKzZdPW5bNl0scltpKzddPW5bN119ZnVuY3Rpb24gbyh0LHIsaSl7ZVswXT10LHJbaV09bls3XSxyW2krMV09bls2XSxyW2krMl09bls1XSxyW2krM109bls0XSxyW2krNF09blszXSxyW2krNV09blsyXSxyW2krNl09blsxXSxyW2krN109blswXX1mdW5jdGlvbiBhKHQscil7cmV0dXJuIG5bMF09dFtyXSxuWzFdPXRbcisxXSxuWzJdPXRbcisyXSxuWzNdPXRbciszXSxuWzRdPXRbcis0XSxuWzVdPXRbcis1XSxuWzZdPXRbcis2XSxuWzddPXRbcis3XSxlWzBdfWZ1bmN0aW9uIHModCxyKXtyZXR1cm4gbls3XT10W3JdLG5bNl09dFtyKzFdLG5bNV09dFtyKzJdLG5bNF09dFtyKzNdLG5bM109dFtyKzRdLG5bMl09dFtyKzVdLG5bMV09dFtyKzZdLG5bMF09dFtyKzddLGVbMF19dC53cml0ZURvdWJsZUxFPXI/aTpvLHQud3JpdGVEb3VibGVCRT1yP286aSx0LnJlYWREb3VibGVMRT1yP2E6cyx0LnJlYWREb3VibGVCRT1yP3M6YX0oKTpmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxlLG4scixpLG8pe3ZhciBhPXI8MD8xOjA7aWYoYSYmKHI9LXIpLDA9PT1yKXQoMCxpLG8rZSksdCgxL3I+MD8wOjIxNDc0ODM2NDgsaSxvK24pO2Vsc2UgaWYoaXNOYU4ocikpdCgwLGksbytlKSx0KDIxNDY5NTkzNjAsaSxvK24pO2Vsc2UgaWYocj4xNzk3NjkzMTM0ODYyMzE1N2UyOTIpdCgwLGksbytlKSx0KChhPDwzMXwyMTQ2NDM1MDcyKT4+PjAsaSxvK24pO2Vsc2V7dmFyIHM7aWYocjwyMjI1MDczODU4NTA3MjAxNGUtMzI0KXQoKHM9ci81ZS0zMjQpPj4+MCxpLG8rZSksdCgoYTw8MzF8cy80Mjk0OTY3Mjk2KT4+PjAsaSxvK24pO2Vsc2V7dmFyIHU9TWF0aC5mbG9vcihNYXRoLmxvZyhyKS9NYXRoLkxOMik7MTAyND09PXUmJih1PTEwMjMpLHQoNDUwMzU5OTYyNzM3MDQ5Nioocz1yKk1hdGgucG93KDIsLXUpKT4+PjAsaSxvK2UpLHQoKGE8PDMxfHUrMTAyMzw8MjB8MTA0ODU3NipzJjEwNDg1NzUpPj4+MCxpLG8rbil9fX1mdW5jdGlvbiBhKHQsZSxuLHIsaSl7dmFyIG89dChyLGkrZSksYT10KHIsaStuKSxzPTIqKGE+PjMxKSsxLHU9YT4+PjIwJjIwNDcsYz00Mjk0OTY3Mjk2KigxMDQ4NTc1JmEpK287cmV0dXJuIDIwNDc9PT11P2M/TmFOOnMqKDEvMCk6MD09PXU/NWUtMzI0KnMqYzpzKk1hdGgucG93KDIsdS0xMDc1KSooYys0NTAzNTk5NjI3MzcwNDk2KX10LndyaXRlRG91YmxlTEU9ZS5iaW5kKG51bGwsbiwwLDQpLHQud3JpdGVEb3VibGVCRT1lLmJpbmQobnVsbCxyLDQsMCksdC5yZWFkRG91YmxlTEU9YS5iaW5kKG51bGwsaSwwLDQpLHQucmVhZERvdWJsZUJFPWEuYmluZChudWxsLG8sNCwwKX0oKSx0fWZ1bmN0aW9uIG4odCxlLG4pe2Vbbl09MjU1JnQsZVtuKzFdPXQ+Pj44JjI1NSxlW24rMl09dD4+PjE2JjI1NSxlW24rM109dD4+PjI0fWZ1bmN0aW9uIHIodCxlLG4pe2Vbbl09dD4+PjI0LGVbbisxXT10Pj4+MTYmMjU1LGVbbisyXT10Pj4+OCYyNTUsZVtuKzNdPTI1NSZ0fWZ1bmN0aW9uIGkodCxlKXtyZXR1cm4odFtlXXx0W2UrMV08PDh8dFtlKzJdPDwxNnx0W2UrM108PDI0KT4+PjB9ZnVuY3Rpb24gbyh0LGUpe3JldHVybih0W2VdPDwyNHx0W2UrMV08PDE2fHRbZSsyXTw8OHx0W2UrM10pPj4+MH10LmV4cG9ydHM9ZShlKX0sNzE5OTptb2R1bGU9PntcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpbnF1aXJlKG1vZHVsZU5hbWUpe3RyeXt2YXIgbW9kPWV2YWwoXCJxdWlyZVwiLnJlcGxhY2UoL14vLFwicmVcIikpKG1vZHVsZU5hbWUpO2lmKG1vZCYmKG1vZC5sZW5ndGh8fE9iamVjdC5rZXlzKG1vZCkubGVuZ3RoKSlyZXR1cm4gbW9kfWNhdGNoKHQpe31yZXR1cm4gbnVsbH1tb2R1bGUuZXhwb3J0cz1pbnF1aXJlfSw2NjYyOnQ9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW58fDgxOTIsaT1yPj4+MSxvPW51bGwsYT1yO3JldHVybiBmdW5jdGlvbihuKXtpZihuPDF8fG4+aSlyZXR1cm4gdChuKTthK24+ciYmKG89dChyKSxhPTApO3ZhciBzPWUuY2FsbChvLGEsYSs9bik7cmV0dXJuIDcmYSYmKGE9MSsoN3xhKSksc319fSw0OTk3Oih0LGUpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ZTtuLmxlbmd0aD1mdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPTAscj0wO3I8dC5sZW5ndGg7KytyKShuPXQuY2hhckNvZGVBdChyKSk8MTI4P2UrPTE6bjwyMDQ4P2UrPTI6NTUyOTY9PSg2NDUxMiZuKSYmNTYzMjA9PSg2NDUxMiZ0LmNoYXJDb2RlQXQocisxKSk/KCsrcixlKz00KTplKz0zO3JldHVybiBlfSxuLnJlYWQ9ZnVuY3Rpb24odCxlLG4pe2lmKG4tZTwxKXJldHVyblwiXCI7Zm9yKHZhciByLGk9bnVsbCxvPVtdLGE9MDtlPG47KShyPXRbZSsrXSk8MTI4P29bYSsrXT1yOnI+MTkxJiZyPDIyND9vW2ErK109KDMxJnIpPDw2fDYzJnRbZSsrXTpyPjIzOSYmcjwzNjU/KHI9KCg3JnIpPDwxOHwoNjMmdFtlKytdKTw8MTJ8KDYzJnRbZSsrXSk8PDZ8NjMmdFtlKytdKS02NTUzNixvW2ErK109NTUyOTYrKHI+PjEwKSxvW2ErK109NTYzMjArKDEwMjMmcikpOm9bYSsrXT0oMTUmcik8PDEyfCg2MyZ0W2UrK10pPDw2fDYzJnRbZSsrXSxhPjgxOTEmJigoaXx8KGk9W10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLG8pKSxhPTApO3JldHVybiBpPyhhJiZpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsby5zbGljZSgwLGEpKSksaS5qb2luKFwiXCIpKTpTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxvLnNsaWNlKDAsYSkpfSxuLndyaXRlPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHIsaSxvPW4sYT0wO2E8dC5sZW5ndGg7KythKShyPXQuY2hhckNvZGVBdChhKSk8MTI4P2VbbisrXT1yOnI8MjA0OD8oZVtuKytdPXI+PjZ8MTkyLGVbbisrXT02MyZyfDEyOCk6NTUyOTY9PSg2NDUxMiZyKSYmNTYzMjA9PSg2NDUxMiYoaT10LmNoYXJDb2RlQXQoYSsxKSkpPyhyPTY1NTM2KygoMTAyMyZyKTw8MTApKygxMDIzJmkpLCsrYSxlW24rK109cj4+MTh8MjQwLGVbbisrXT1yPj4xMiY2M3wxMjgsZVtuKytdPXI+PjYmNjN8MTI4LGVbbisrXT02MyZyfDEyOCk6KGVbbisrXT1yPj4xMnwyMjQsZVtuKytdPXI+PjYmNjN8MTI4LGVbbisrXT02MyZyfDEyOCk7cmV0dXJuIG4tb319LDM0NDI6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtlLl9fZXNNb2R1bGU9ITA7dmFyIG49ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe2lmKCFlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50OyBgdmFsdWVgIGhhcyBubyB2YWx1ZS5cIik7dGhpcy52YWx1ZT10LkVNUFRZLGUmJnQuaXNHdWlkKGUpJiYodGhpcy52YWx1ZT1lKX1yZXR1cm4gdC5pc0d1aWQ9ZnVuY3Rpb24oZSl7dmFyIG49ZS50b1N0cmluZygpO3JldHVybiBlJiYoZSBpbnN0YW5jZW9mIHR8fHQudmFsaWRhdG9yLnRlc3QobikpfSx0LmNyZWF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgdChbdC5nZW4oMiksdC5nZW4oMSksdC5nZW4oMSksdC5nZW4oMSksdC5nZW4oMyldLmpvaW4oXCItXCIpKX0sdC5jcmVhdGVFbXB0eT1mdW5jdGlvbigpe3JldHVybiBuZXcgdChcImVtcHR5Z3VpZFwiKX0sdC5wYXJzZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQucmF3PWZ1bmN0aW9uKCl7cmV0dXJuW3QuZ2VuKDIpLHQuZ2VuKDEpLHQuZ2VuKDEpLHQuZ2VuKDEpLHQuZ2VuKDMpXS5qb2luKFwiLVwiKX0sdC5nZW49ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVwiXCIsbj0wO248dDtuKyspZSs9KDY1NTM2KigxK01hdGgucmFuZG9tKCkpfDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7cmV0dXJuIGV9LHQucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihlKXtyZXR1cm4gdC5pc0d1aWQoZSkmJnRoaXMudmFsdWU9PT1lLnRvU3RyaW5nKCl9LHQucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZT09PXQuRU1QVFl9LHQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWV9LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnt2YWx1ZTp0aGlzLnZhbHVlfX0sdC52YWxpZGF0b3I9bmV3IFJlZ0V4cChcIl5bYS16MC05XXs4fS1bYS16MC05XXs0fS1bYS16MC05XXs0fS1bYS16MC05XXs0fS1bYS16MC05XXsxMn0kXCIsXCJpXCIpLHQuRU1QVFk9XCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIix0fSgpO2UuR3VpZD1ufSwzNzIwOnQ9Pnt0LmV4cG9ydHM9bjt2YXIgZT1udWxsO3RyeXtlPW5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDEzLDIsOTYsMCwxLDEyNyw5Niw0LDEyNywxMjcsMTI3LDEyNywxLDEyNywzLDcsNiwwLDEsMSwxLDEsMSw2LDYsMSwxMjcsMSw2NSwwLDExLDcsNTAsNiwzLDEwOSwxMTcsMTA4LDAsMSw1LDEwMCwxMDUsMTE4LDk1LDExNSwwLDIsNSwxMDAsMTA1LDExOCw5NSwxMTcsMCwzLDUsMTE0LDEwMSwxMDksOTUsMTE1LDAsNCw1LDExNCwxMDEsMTA5LDk1LDExNywwLDUsOCwxMDMsMTAxLDExNiw5NSwxMDQsMTA1LDEwMywxMDQsMCwwLDEwLDE5MSwxLDYsNCwwLDM1LDAsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTI2LDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEyNywzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMSwzNiwxLDEsMTI2LDMyLDAsMTczLDMyLDEsMTczLDY2LDMyLDEzNCwxMzIsMzIsMiwxNzMsMzIsMywxNzMsNjYsMzIsMTM0LDEzMiwxMjgsMzQsNCw2NiwzMiwxMzUsMTY3LDM2LDAsMzIsNCwxNjcsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTI5LDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEzMCwzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMV0pKSx7fSkuZXhwb3J0c31jYXRjaCh0KXt9ZnVuY3Rpb24gbih0LGUsbil7dGhpcy5sb3c9MHx0LHRoaXMuaGlnaD0wfGUsdGhpcy51bnNpZ25lZD0hIW59ZnVuY3Rpb24gcih0KXtyZXR1cm4hMD09PSh0JiZ0Ll9faXNMb25nX18pfW4ucHJvdG90eXBlLl9faXNMb25nX18sT2JqZWN0LmRlZmluZVByb3BlcnR5KG4ucHJvdG90eXBlLFwiX19pc0xvbmdfX1wiLHt2YWx1ZTohMH0pLG4uaXNMb25nPXI7dmFyIGk9e30sbz17fTtmdW5jdGlvbiBhKHQsZSl7dmFyIG4scixhO3JldHVybiBlPyhhPTA8PSh0Pj4+PTApJiZ0PDI1NikmJihyPW9bdF0pP3I6KG49dSh0LCgwfHQpPDA/LTE6MCwhMCksYSYmKG9bdF09biksbik6KGE9LTEyODw9KHR8PTApJiZ0PDEyOCkmJihyPWlbdF0pP3I6KG49dSh0LHQ8MD8tMTowLCExKSxhJiYoaVt0XT1uKSxuKX1mdW5jdGlvbiBzKHQsZSl7aWYoaXNOYU4odCkpcmV0dXJuIGU/bTpiO2lmKGUpe2lmKHQ8MClyZXR1cm4gbTtpZih0Pj1kKXJldHVybiB4fWVsc2V7aWYodDw9LWgpcmV0dXJuIFQ7aWYodCsxPj1oKXJldHVybiB3fXJldHVybiB0PDA/cygtdCxlKS5uZWcoKTp1KHQlZnwwLHQvZnwwLGUpfWZ1bmN0aW9uIHUodCxlLHIpe3JldHVybiBuZXcgbih0LGUscil9bi5mcm9tSW50PWEsbi5mcm9tTnVtYmVyPXMsbi5mcm9tQml0cz11O3ZhciBjPU1hdGgucG93O2Z1bmN0aW9uIGwodCxlLG4pe2lmKDA9PT10Lmxlbmd0aCl0aHJvdyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtpZihcIk5hTlwiPT09dHx8XCJJbmZpbml0eVwiPT09dHx8XCIrSW5maW5pdHlcIj09PXR8fFwiLUluZmluaXR5XCI9PT10KXJldHVybiBiO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlPyhuPWUsZT0hMSk6ZT0hIWUsKG49bnx8MTApPDJ8fDM2PG4pdGhyb3cgUmFuZ2VFcnJvcihcInJhZGl4XCIpO3ZhciByO2lmKChyPXQuaW5kZXhPZihcIi1cIikpPjApdGhyb3cgRXJyb3IoXCJpbnRlcmlvciBoeXBoZW5cIik7aWYoMD09PXIpcmV0dXJuIGwodC5zdWJzdHJpbmcoMSksZSxuKS5uZWcoKTtmb3IodmFyIGk9cyhjKG4sOCkpLG89YixhPTA7YTx0Lmxlbmd0aDthKz04KXt2YXIgdT1NYXRoLm1pbig4LHQubGVuZ3RoLWEpLHA9cGFyc2VJbnQodC5zdWJzdHJpbmcoYSxhK3UpLG4pO2lmKHU8OCl7dmFyIGY9cyhjKG4sdSkpO289by5tdWwoZikuYWRkKHMocCkpfWVsc2Ugbz0obz1vLm11bChpKSkuYWRkKHMocCkpfXJldHVybiBvLnVuc2lnbmVkPWUsb31mdW5jdGlvbiBwKHQsZSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/cyh0LGUpOlwic3RyaW5nXCI9PXR5cGVvZiB0P2wodCxlKTp1KHQubG93LHQuaGlnaCxcImJvb2xlYW5cIj09dHlwZW9mIGU/ZTp0LnVuc2lnbmVkKX1uLmZyb21TdHJpbmc9bCxuLmZyb21WYWx1ZT1wO3ZhciBmPTQyOTQ5NjcyOTYsZD1mKmYsaD1kLzIsZz1hKDE8PDI0KSxiPWEoMCk7bi5aRVJPPWI7dmFyIG09YSgwLCEwKTtuLlVaRVJPPW07dmFyIHk9YSgxKTtuLk9ORT15O3ZhciBfPWEoMSwhMCk7bi5VT05FPV87dmFyIHY9YSgtMSk7bi5ORUdfT05FPXY7dmFyIHc9dSgtMSwyMTQ3NDgzNjQ3LCExKTtuLk1BWF9WQUxVRT13O3ZhciB4PXUoLTEsLTEsITApO24uTUFYX1VOU0lHTkVEX1ZBTFVFPXg7dmFyIFQ9dSgwLC0yMTQ3NDgzNjQ4LCExKTtuLk1JTl9WQUxVRT1UO3ZhciBTPW4ucHJvdG90eXBlO1MudG9JbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD90aGlzLmxvdz4+PjA6dGhpcy5sb3d9LFMudG9OdW1iZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD8odGhpcy5oaWdoPj4+MCkqZisodGhpcy5sb3c+Pj4wKTp0aGlzLmhpZ2gqZisodGhpcy5sb3c+Pj4wKX0sUy50b1N0cmluZz1mdW5jdGlvbih0KXtpZigodD10fHwxMCk8Mnx8MzY8dCl0aHJvdyBSYW5nZUVycm9yKFwicmFkaXhcIik7aWYodGhpcy5pc1plcm8oKSlyZXR1cm5cIjBcIjtpZih0aGlzLmlzTmVnYXRpdmUoKSl7aWYodGhpcy5lcShUKSl7dmFyIGU9cyh0KSxuPXRoaXMuZGl2KGUpLHI9bi5tdWwoZSkuc3ViKHRoaXMpO3JldHVybiBuLnRvU3RyaW5nKHQpK3IudG9JbnQoKS50b1N0cmluZyh0KX1yZXR1cm5cIi1cIit0aGlzLm5lZygpLnRvU3RyaW5nKHQpfWZvcih2YXIgaT1zKGModCw2KSx0aGlzLnVuc2lnbmVkKSxvPXRoaXMsYT1cIlwiOzspe3ZhciB1PW8uZGl2KGkpLGw9KG8uc3ViKHUubXVsKGkpKS50b0ludCgpPj4+MCkudG9TdHJpbmcodCk7aWYoKG89dSkuaXNaZXJvKCkpcmV0dXJuIGwrYTtmb3IoO2wubGVuZ3RoPDY7KWw9XCIwXCIrbDthPVwiXCIrbCthfX0sUy5nZXRIaWdoQml0cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhpZ2h9LFMuZ2V0SGlnaEJpdHNVbnNpZ25lZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhpZ2g+Pj4wfSxTLmdldExvd0JpdHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sb3d9LFMuZ2V0TG93Qml0c1Vuc2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubG93Pj4+MH0sUy5nZXROdW1CaXRzQWJzPWZ1bmN0aW9uKCl7aWYodGhpcy5pc05lZ2F0aXZlKCkpcmV0dXJuIHRoaXMuZXEoVCk/NjQ6dGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7Zm9yKHZhciB0PTAhPXRoaXMuaGlnaD90aGlzLmhpZ2g6dGhpcy5sb3csZT0zMTtlPjAmJjA9PSh0JjE8PGUpO2UtLSk7cmV0dXJuIDAhPXRoaXMuaGlnaD9lKzMzOmUrMX0sUy5pc1plcm89ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuaGlnaCYmMD09PXRoaXMubG93fSxTLmVxej1TLmlzWmVybyxTLmlzTmVnYXRpdmU9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy51bnNpZ25lZCYmdGhpcy5oaWdoPDB9LFMuaXNQb3NpdGl2ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkfHx0aGlzLmhpZ2g+PTB9LFMuaXNPZGQ9ZnVuY3Rpb24oKXtyZXR1cm4gMT09KDEmdGhpcy5sb3cpfSxTLmlzRXZlbj1mdW5jdGlvbigpe3JldHVybiAwPT0oMSZ0aGlzLmxvdyl9LFMuZXF1YWxzPWZ1bmN0aW9uKHQpe3JldHVybiByKHQpfHwodD1wKHQpKSwodGhpcy51bnNpZ25lZD09PXQudW5zaWduZWR8fHRoaXMuaGlnaD4+PjMxIT0xfHx0LmhpZ2g+Pj4zMSE9MSkmJnRoaXMuaGlnaD09PXQuaGlnaCYmdGhpcy5sb3c9PT10Lmxvd30sUy5lcT1TLmVxdWFscyxTLm5vdEVxdWFscz1mdW5jdGlvbih0KXtyZXR1cm4hdGhpcy5lcSh0KX0sUy5uZXE9Uy5ub3RFcXVhbHMsUy5uZT1TLm5vdEVxdWFscyxTLmxlc3NUaGFuPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbXAodCk8MH0sUy5sdD1TLmxlc3NUaGFuLFMubGVzc1RoYW5PckVxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbXAodCk8PTB9LFMubHRlPVMubGVzc1RoYW5PckVxdWFsLFMubGU9Uy5sZXNzVGhhbk9yRXF1YWwsUy5ncmVhdGVyVGhhbj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb21wKHQpPjB9LFMuZ3Q9Uy5ncmVhdGVyVGhhbixTLmdyZWF0ZXJUaGFuT3JFcXVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb21wKHQpPj0wfSxTLmd0ZT1TLmdyZWF0ZXJUaGFuT3JFcXVhbCxTLmdlPVMuZ3JlYXRlclRoYW5PckVxdWFsLFMuY29tcGFyZT1mdW5jdGlvbih0KXtpZihyKHQpfHwodD1wKHQpKSx0aGlzLmVxKHQpKXJldHVybiAwO3ZhciBlPXRoaXMuaXNOZWdhdGl2ZSgpLG49dC5pc05lZ2F0aXZlKCk7cmV0dXJuIGUmJiFuPy0xOiFlJiZuPzE6dGhpcy51bnNpZ25lZD90LmhpZ2g+Pj4wPnRoaXMuaGlnaD4+PjB8fHQuaGlnaD09PXRoaXMuaGlnaCYmdC5sb3c+Pj4wPnRoaXMubG93Pj4+MD8tMToxOnRoaXMuc3ViKHQpLmlzTmVnYXRpdmUoKT8tMToxfSxTLmNvbXA9Uy5jb21wYXJlLFMubmVnYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMudW5zaWduZWQmJnRoaXMuZXEoVCk/VDp0aGlzLm5vdCgpLmFkZCh5KX0sUy5uZWc9Uy5uZWdhdGUsUy5hZGQ9ZnVuY3Rpb24odCl7cih0KXx8KHQ9cCh0KSk7dmFyIGU9dGhpcy5oaWdoPj4+MTYsbj02NTUzNSZ0aGlzLmhpZ2gsaT10aGlzLmxvdz4+PjE2LG89NjU1MzUmdGhpcy5sb3csYT10LmhpZ2g+Pj4xNixzPTY1NTM1JnQuaGlnaCxjPXQubG93Pj4+MTYsbD0wLGY9MCxkPTAsaD0wO3JldHVybiBkKz0oaCs9bysoNjU1MzUmdC5sb3cpKT4+PjE2LGYrPShkKz1pK2MpPj4+MTYsbCs9KGYrPW4rcyk+Pj4xNixsKz1lK2EsdSgoZCY9NjU1MzUpPDwxNnwoaCY9NjU1MzUpLChsJj02NTUzNSk8PDE2fChmJj02NTUzNSksdGhpcy51bnNpZ25lZCl9LFMuc3VidHJhY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHIodCl8fCh0PXAodCkpLHRoaXMuYWRkKHQubmVnKCkpfSxTLnN1Yj1TLnN1YnRyYWN0LFMubXVsdGlwbHk9ZnVuY3Rpb24odCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gYjtpZihyKHQpfHwodD1wKHQpKSxlKXJldHVybiB1KGUubXVsKHRoaXMubG93LHRoaXMuaGlnaCx0Lmxvdyx0LmhpZ2gpLGUuZ2V0X2hpZ2goKSx0aGlzLnVuc2lnbmVkKTtpZih0LmlzWmVybygpKXJldHVybiBiO2lmKHRoaXMuZXEoVCkpcmV0dXJuIHQuaXNPZGQoKT9UOmI7aWYodC5lcShUKSlyZXR1cm4gdGhpcy5pc09kZCgpP1Q6YjtpZih0aGlzLmlzTmVnYXRpdmUoKSlyZXR1cm4gdC5pc05lZ2F0aXZlKCk/dGhpcy5uZWcoKS5tdWwodC5uZWcoKSk6dGhpcy5uZWcoKS5tdWwodCkubmVnKCk7aWYodC5pc05lZ2F0aXZlKCkpcmV0dXJuIHRoaXMubXVsKHQubmVnKCkpLm5lZygpO2lmKHRoaXMubHQoZykmJnQubHQoZykpcmV0dXJuIHModGhpcy50b051bWJlcigpKnQudG9OdW1iZXIoKSx0aGlzLnVuc2lnbmVkKTt2YXIgbj10aGlzLmhpZ2g+Pj4xNixpPTY1NTM1JnRoaXMuaGlnaCxvPXRoaXMubG93Pj4+MTYsYT02NTUzNSZ0aGlzLmxvdyxjPXQuaGlnaD4+PjE2LGw9NjU1MzUmdC5oaWdoLGY9dC5sb3c+Pj4xNixkPTY1NTM1JnQubG93LGg9MCxtPTAseT0wLF89MDtyZXR1cm4geSs9KF8rPWEqZCk+Pj4xNixtKz0oeSs9bypkKT4+PjE2LHkmPTY1NTM1LG0rPSh5Kz1hKmYpPj4+MTYsaCs9KG0rPWkqZCk+Pj4xNixtJj02NTUzNSxoKz0obSs9bypmKT4+PjE2LG0mPTY1NTM1LGgrPShtKz1hKmwpPj4+MTYsaCs9bipkK2kqZitvKmwrYSpjLHUoKHkmPTY1NTM1KTw8MTZ8KF8mPTY1NTM1KSwoaCY9NjU1MzUpPDwxNnwobSY9NjU1MzUpLHRoaXMudW5zaWduZWQpfSxTLm11bD1TLm11bHRpcGx5LFMuZGl2aWRlPWZ1bmN0aW9uKHQpe2lmKHIodCl8fCh0PXAodCkpLHQuaXNaZXJvKCkpdGhyb3cgRXJyb3IoXCJkaXZpc2lvbiBieSB6ZXJvXCIpO3ZhciBuLGksbztpZihlKXJldHVybiB0aGlzLnVuc2lnbmVkfHwtMjE0NzQ4MzY0OCE9PXRoaXMuaGlnaHx8LTEhPT10Lmxvd3x8LTEhPT10LmhpZ2g/dSgodGhpcy51bnNpZ25lZD9lLmRpdl91OmUuZGl2X3MpKHRoaXMubG93LHRoaXMuaGlnaCx0Lmxvdyx0LmhpZ2gpLGUuZ2V0X2hpZ2goKSx0aGlzLnVuc2lnbmVkKTp0aGlzO2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIHRoaXMudW5zaWduZWQ/bTpiO2lmKHRoaXMudW5zaWduZWQpe2lmKHQudW5zaWduZWR8fCh0PXQudG9VbnNpZ25lZCgpKSx0Lmd0KHRoaXMpKXJldHVybiBtO2lmKHQuZ3QodGhpcy5zaHJ1KDEpKSlyZXR1cm4gXztvPW19ZWxzZXtpZih0aGlzLmVxKFQpKXJldHVybiB0LmVxKHkpfHx0LmVxKHYpP1Q6dC5lcShUKT95OihuPXRoaXMuc2hyKDEpLmRpdih0KS5zaGwoMSkpLmVxKGIpP3QuaXNOZWdhdGl2ZSgpP3k6djooaT10aGlzLnN1Yih0Lm11bChuKSksbz1uLmFkZChpLmRpdih0KSkpO2lmKHQuZXEoVCkpcmV0dXJuIHRoaXMudW5zaWduZWQ/bTpiO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiB0LmlzTmVnYXRpdmUoKT90aGlzLm5lZygpLmRpdih0Lm5lZygpKTp0aGlzLm5lZygpLmRpdih0KS5uZWcoKTtpZih0LmlzTmVnYXRpdmUoKSlyZXR1cm4gdGhpcy5kaXYodC5uZWcoKSkubmVnKCk7bz1ifWZvcihpPXRoaXM7aS5ndGUodCk7KXtuPU1hdGgubWF4KDEsTWF0aC5mbG9vcihpLnRvTnVtYmVyKCkvdC50b051bWJlcigpKSk7Zm9yKHZhciBhPU1hdGguY2VpbChNYXRoLmxvZyhuKS9NYXRoLkxOMiksbD1hPD00OD8xOmMoMixhLTQ4KSxmPXMobiksZD1mLm11bCh0KTtkLmlzTmVnYXRpdmUoKXx8ZC5ndChpKTspZD0oZj1zKG4tPWwsdGhpcy51bnNpZ25lZCkpLm11bCh0KTtmLmlzWmVybygpJiYoZj15KSxvPW8uYWRkKGYpLGk9aS5zdWIoZCl9cmV0dXJuIG99LFMuZGl2PVMuZGl2aWRlLFMubW9kdWxvPWZ1bmN0aW9uKHQpe3JldHVybiByKHQpfHwodD1wKHQpKSxlP3UoKHRoaXMudW5zaWduZWQ/ZS5yZW1fdTplLnJlbV9zKSh0aGlzLmxvdyx0aGlzLmhpZ2gsdC5sb3csdC5oaWdoKSxlLmdldF9oaWdoKCksdGhpcy51bnNpZ25lZCk6dGhpcy5zdWIodGhpcy5kaXYodCkubXVsKHQpKX0sUy5tb2Q9Uy5tb2R1bG8sUy5yZW09Uy5tb2R1bG8sUy5ub3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdSh+dGhpcy5sb3csfnRoaXMuaGlnaCx0aGlzLnVuc2lnbmVkKX0sUy5hbmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHIodCl8fCh0PXAodCkpLHUodGhpcy5sb3cmdC5sb3csdGhpcy5oaWdoJnQuaGlnaCx0aGlzLnVuc2lnbmVkKX0sUy5vcj1mdW5jdGlvbih0KXtyZXR1cm4gcih0KXx8KHQ9cCh0KSksdSh0aGlzLmxvd3x0Lmxvdyx0aGlzLmhpZ2h8dC5oaWdoLHRoaXMudW5zaWduZWQpfSxTLnhvcj1mdW5jdGlvbih0KXtyZXR1cm4gcih0KXx8KHQ9cCh0KSksdSh0aGlzLmxvd150Lmxvdyx0aGlzLmhpZ2hedC5oaWdoLHRoaXMudW5zaWduZWQpfSxTLnNoaWZ0TGVmdD1mdW5jdGlvbih0KXtyZXR1cm4gcih0KSYmKHQ9dC50b0ludCgpKSwwPT0odCY9NjMpP3RoaXM6dDwzMj91KHRoaXMubG93PDx0LHRoaXMuaGlnaDw8dHx0aGlzLmxvdz4+PjMyLXQsdGhpcy51bnNpZ25lZCk6dSgwLHRoaXMubG93PDx0LTMyLHRoaXMudW5zaWduZWQpfSxTLnNobD1TLnNoaWZ0TGVmdCxTLnNoaWZ0UmlnaHQ9ZnVuY3Rpb24odCl7cmV0dXJuIHIodCkmJih0PXQudG9JbnQoKSksMD09KHQmPTYzKT90aGlzOnQ8MzI/dSh0aGlzLmxvdz4+PnR8dGhpcy5oaWdoPDwzMi10LHRoaXMuaGlnaD4+dCx0aGlzLnVuc2lnbmVkKTp1KHRoaXMuaGlnaD4+dC0zMix0aGlzLmhpZ2g+PTA/MDotMSx0aGlzLnVuc2lnbmVkKX0sUy5zaHI9Uy5zaGlmdFJpZ2h0LFMuc2hpZnRSaWdodFVuc2lnbmVkPWZ1bmN0aW9uKHQpe2lmKHIodCkmJih0PXQudG9JbnQoKSksMD09KHQmPTYzKSlyZXR1cm4gdGhpczt2YXIgZT10aGlzLmhpZ2g7cmV0dXJuIHQ8MzI/dSh0aGlzLmxvdz4+PnR8ZTw8MzItdCxlPj4+dCx0aGlzLnVuc2lnbmVkKTp1KDMyPT09dD9lOmU+Pj50LTMyLDAsdGhpcy51bnNpZ25lZCl9LFMuc2hydT1TLnNoaWZ0UmlnaHRVbnNpZ25lZCxTLnNocl91PVMuc2hpZnRSaWdodFVuc2lnbmVkLFMudG9TaWduZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD91KHRoaXMubG93LHRoaXMuaGlnaCwhMSk6dGhpc30sUy50b1Vuc2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5zaWduZWQ/dGhpczp1KHRoaXMubG93LHRoaXMuaGlnaCwhMCl9LFMudG9CeXRlcz1mdW5jdGlvbih0KXtyZXR1cm4gdD90aGlzLnRvQnl0ZXNMRSgpOnRoaXMudG9CeXRlc0JFKCl9LFMudG9CeXRlc0xFPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5oaWdoLGU9dGhpcy5sb3c7cmV0dXJuWzI1NSZlLGU+Pj44JjI1NSxlPj4+MTYmMjU1LGU+Pj4yNCwyNTUmdCx0Pj4+OCYyNTUsdD4+PjE2JjI1NSx0Pj4+MjRdfSxTLnRvQnl0ZXNCRT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGlnaCxlPXRoaXMubG93O3JldHVyblt0Pj4+MjQsdD4+PjE2JjI1NSx0Pj4+OCYyNTUsMjU1JnQsZT4+PjI0LGU+Pj4xNiYyNTUsZT4+PjgmMjU1LDI1NSZlXX0sbi5mcm9tQnl0ZXM9ZnVuY3Rpb24odCxlLHIpe3JldHVybiByP24uZnJvbUJ5dGVzTEUodCxlKTpuLmZyb21CeXRlc0JFKHQsZSl9LG4uZnJvbUJ5dGVzTEU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IG4odFswXXx0WzFdPDw4fHRbMl08PDE2fHRbM108PDI0LHRbNF18dFs1XTw8OHx0WzZdPDwxNnx0WzddPDwyNCxlKX0sbi5mcm9tQnl0ZXNCRT1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgbih0WzRdPDwyNHx0WzVdPDwxNnx0WzZdPDw4fHRbN10sdFswXTw8MjR8dFsxXTw8MTZ8dFsyXTw8OHx0WzNdLGUpfX0sMTQ0NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHIsaSxvLGE9bigyMTAwKSxzPWEuUmVhZGVyLHU9YS5Xcml0ZXIsYz1hLnV0aWwsbD1hLnJvb3RzLmRlZmF1bHR8fChhLnJvb3RzLmRlZmF1bHQ9e30pO2wub25ueD0oKG89e30pLlZlcnNpb249KHI9e30sKGk9T2JqZWN0LmNyZWF0ZShyKSlbclswXT1cIl9TVEFSVF9WRVJTSU9OXCJdPTAsaVtyWzFdPVwiSVJfVkVSU0lPTl8yMDE3XzEwXzEwXCJdPTEsaVtyWzJdPVwiSVJfVkVSU0lPTl8yMDE3XzEwXzMwXCJdPTIsaVtyWzNdPVwiSVJfVkVSU0lPTl8yMDE3XzExXzNcIl09MyxpW3JbNF09XCJJUl9WRVJTSU9OXzIwMTlfMV8yMlwiXT00LGlbcls1XT1cIklSX1ZFUlNJT05cIl09NSxpKSxvLkF0dHJpYnV0ZVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLmZsb2F0cz1bXSx0aGlzLmludHM9W10sdGhpcy5zdHJpbmdzPVtdLHRoaXMudGVuc29ycz1bXSx0aGlzLmdyYXBocz1bXSx0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLm5hbWU9XCJcIix0LnByb3RvdHlwZS5yZWZBdHRyTmFtZT1cIlwiLHQucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLHQucHJvdG90eXBlLnR5cGU9MCx0LnByb3RvdHlwZS5mPTAsdC5wcm90b3R5cGUuaT1jLkxvbmc/Yy5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCx0LnByb3RvdHlwZS5zPWMubmV3QnVmZmVyKFtdKSx0LnByb3RvdHlwZS50PW51bGwsdC5wcm90b3R5cGUuZz1udWxsLHQucHJvdG90eXBlLmZsb2F0cz1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuaW50cz1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuc3RyaW5ncz1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUudGVuc29ycz1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZ3JhcGhzPWMuZW1wdHlBcnJheSx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7aWYoZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmZS51aW50MzIoMTApLnN0cmluZyh0Lm5hbWUpLG51bGwhPXQuZiYmdC5oYXNPd25Qcm9wZXJ0eShcImZcIikmJmUudWludDMyKDIxKS5mbG9hdCh0LmYpLG51bGwhPXQuaSYmdC5oYXNPd25Qcm9wZXJ0eShcImlcIikmJmUudWludDMyKDI0KS5pbnQ2NCh0LmkpLG51bGwhPXQucyYmdC5oYXNPd25Qcm9wZXJ0eShcInNcIikmJmUudWludDMyKDM0KS5ieXRlcyh0LnMpLG51bGwhPXQudCYmdC5oYXNPd25Qcm9wZXJ0eShcInRcIikmJmwub25ueC5UZW5zb3JQcm90by5lbmNvZGUodC50LGUudWludDMyKDQyKS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPXQuZyYmdC5oYXNPd25Qcm9wZXJ0eShcImdcIikmJmwub25ueC5HcmFwaFByb3RvLmVuY29kZSh0LmcsZS51aW50MzIoNTApLmZvcmsoKSkubGRlbGltKCksbnVsbCE9dC5mbG9hdHMmJnQuZmxvYXRzLmxlbmd0aCl7ZS51aW50MzIoNTgpLmZvcmsoKTtmb3IodmFyIG49MDtuPHQuZmxvYXRzLmxlbmd0aDsrK24pZS5mbG9hdCh0LmZsb2F0c1tuXSk7ZS5sZGVsaW0oKX1pZihudWxsIT10LmludHMmJnQuaW50cy5sZW5ndGgpe2ZvcihlLnVpbnQzMig2NikuZm9yaygpLG49MDtuPHQuaW50cy5sZW5ndGg7KytuKWUuaW50NjQodC5pbnRzW25dKTtlLmxkZWxpbSgpfWlmKG51bGwhPXQuc3RyaW5ncyYmdC5zdHJpbmdzLmxlbmd0aClmb3Iobj0wO248dC5zdHJpbmdzLmxlbmd0aDsrK24pZS51aW50MzIoNzQpLmJ5dGVzKHQuc3RyaW5nc1tuXSk7aWYobnVsbCE9dC50ZW5zb3JzJiZ0LnRlbnNvcnMubGVuZ3RoKWZvcihuPTA7bjx0LnRlbnNvcnMubGVuZ3RoOysrbilsLm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKHQudGVuc29yc1tuXSxlLnVpbnQzMig4MikuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT10LmdyYXBocyYmdC5ncmFwaHMubGVuZ3RoKWZvcihuPTA7bjx0LmdyYXBocy5sZW5ndGg7KytuKWwub25ueC5HcmFwaFByb3RvLmVuY29kZSh0LmdyYXBoc1tuXSxlLnVpbnQzMig5MCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gbnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJmUudWludDMyKDEwNikuc3RyaW5nKHQuZG9jU3RyaW5nKSxudWxsIT10LnR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpJiZlLnVpbnQzMigxNjApLmludDMyKHQudHlwZSksbnVsbCE9dC5yZWZBdHRyTmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcInJlZkF0dHJOYW1lXCIpJiZlLnVpbnQzMigxNzApLnN0cmluZyh0LnJlZkF0dHJOYW1lKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguQXR0cmlidXRlUHJvdG87dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5uYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyMTpyLnJlZkF0dHJOYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAxMzpyLmRvY1N0cmluZz10LnN0cmluZygpO2JyZWFrO2Nhc2UgMjA6ci50eXBlPXQuaW50MzIoKTticmVhaztjYXNlIDI6ci5mPXQuZmxvYXQoKTticmVhaztjYXNlIDM6ci5pPXQuaW50NjQoKTticmVhaztjYXNlIDQ6ci5zPXQuYnl0ZXMoKTticmVhaztjYXNlIDU6ci50PWwub25ueC5UZW5zb3JQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKTticmVhaztjYXNlIDY6ci5nPWwub25ueC5HcmFwaFByb3RvLmRlY29kZSh0LHQudWludDMyKCkpO2JyZWFrO2Nhc2UgNzppZihyLmZsb2F0cyYmci5mbG9hdHMubGVuZ3RofHwoci5mbG9hdHM9W10pLDI9PSg3JmkpKWZvcih2YXIgbz10LnVpbnQzMigpK3QucG9zO3QucG9zPG87KXIuZmxvYXRzLnB1c2godC5mbG9hdCgpKTtlbHNlIHIuZmxvYXRzLnB1c2godC5mbG9hdCgpKTticmVhaztjYXNlIDg6aWYoci5pbnRzJiZyLmludHMubGVuZ3RofHwoci5pbnRzPVtdKSwyPT0oNyZpKSlmb3Iobz10LnVpbnQzMigpK3QucG9zO3QucG9zPG87KXIuaW50cy5wdXNoKHQuaW50NjQoKSk7ZWxzZSByLmludHMucHVzaCh0LmludDY0KCkpO2JyZWFrO2Nhc2UgOTpyLnN0cmluZ3MmJnIuc3RyaW5ncy5sZW5ndGh8fChyLnN0cmluZ3M9W10pLHIuc3RyaW5ncy5wdXNoKHQuYnl0ZXMoKSk7YnJlYWs7Y2FzZSAxMDpyLnRlbnNvcnMmJnIudGVuc29ycy5sZW5ndGh8fChyLnRlbnNvcnM9W10pLHIudGVuc29ycy5wdXNoKGwub25ueC5UZW5zb3JQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxMTpyLmdyYXBocyYmci5ncmFwaHMubGVuZ3RofHwoci5ncmFwaHM9W10pLHIuZ3JhcGhzLnB1c2gobC5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmIWMuaXNTdHJpbmcodC5uYW1lKSlyZXR1cm5cIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQucmVmQXR0ck5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJyZWZBdHRyTmFtZVwiKSYmIWMuaXNTdHJpbmcodC5yZWZBdHRyTmFtZSkpcmV0dXJuXCJyZWZBdHRyTmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJiFjLmlzU3RyaW5nKHQuZG9jU3RyaW5nKSlyZXR1cm5cImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC50eXBlJiZ0Lmhhc093blByb3BlcnR5KFwidHlwZVwiKSlzd2l0Y2godC50eXBlKXtkZWZhdWx0OnJldHVyblwidHlwZTogZW51bSB2YWx1ZSBleHBlY3RlZFwiO2Nhc2UgMDpjYXNlIDE6Y2FzZSAyOmNhc2UgMzpjYXNlIDQ6Y2FzZSA1OmNhc2UgNjpjYXNlIDc6Y2FzZSA4OmNhc2UgOTpjYXNlIDEwOn1pZihudWxsIT10LmYmJnQuaGFzT3duUHJvcGVydHkoXCJmXCIpJiZcIm51bWJlclwiIT10eXBlb2YgdC5mKXJldHVyblwiZjogbnVtYmVyIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5pJiZ0Lmhhc093blByb3BlcnR5KFwiaVwiKSYmIShjLmlzSW50ZWdlcih0LmkpfHx0LmkmJmMuaXNJbnRlZ2VyKHQuaS5sb3cpJiZjLmlzSW50ZWdlcih0LmkuaGlnaCkpKXJldHVyblwiaTogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5zJiZ0Lmhhc093blByb3BlcnR5KFwic1wiKSYmISh0LnMmJlwibnVtYmVyXCI9PXR5cGVvZiB0LnMubGVuZ3RofHxjLmlzU3RyaW5nKHQucykpKXJldHVyblwiczogYnVmZmVyIGV4cGVjdGVkXCI7aWYobnVsbCE9dC50JiZ0Lmhhc093blByb3BlcnR5KFwidFwiKSYmKG49bC5vbm54LlRlbnNvclByb3RvLnZlcmlmeSh0LnQpKSlyZXR1cm5cInQuXCIrbjtpZihudWxsIT10LmcmJnQuaGFzT3duUHJvcGVydHkoXCJnXCIpJiYobj1sLm9ubnguR3JhcGhQcm90by52ZXJpZnkodC5nKSkpcmV0dXJuXCJnLlwiK247aWYobnVsbCE9dC5mbG9hdHMmJnQuaGFzT3duUHJvcGVydHkoXCJmbG9hdHNcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuZmxvYXRzKSlyZXR1cm5cImZsb2F0czogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIGU9MDtlPHQuZmxvYXRzLmxlbmd0aDsrK2UpaWYoXCJudW1iZXJcIiE9dHlwZW9mIHQuZmxvYXRzW2VdKXJldHVyblwiZmxvYXRzOiBudW1iZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPXQuaW50cyYmdC5oYXNPd25Qcm9wZXJ0eShcImludHNcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuaW50cykpcmV0dXJuXCJpbnRzOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmludHMubGVuZ3RoOysrZSlpZighKGMuaXNJbnRlZ2VyKHQuaW50c1tlXSl8fHQuaW50c1tlXSYmYy5pc0ludGVnZXIodC5pbnRzW2VdLmxvdykmJmMuaXNJbnRlZ2VyKHQuaW50c1tlXS5oaWdoKSkpcmV0dXJuXCJpbnRzOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPXQuc3RyaW5ncyYmdC5oYXNPd25Qcm9wZXJ0eShcInN0cmluZ3NcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuc3RyaW5ncykpcmV0dXJuXCJzdHJpbmdzOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LnN0cmluZ3MubGVuZ3RoOysrZSlpZighKHQuc3RyaW5nc1tlXSYmXCJudW1iZXJcIj09dHlwZW9mIHQuc3RyaW5nc1tlXS5sZW5ndGh8fGMuaXNTdHJpbmcodC5zdHJpbmdzW2VdKSkpcmV0dXJuXCJzdHJpbmdzOiBidWZmZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPXQudGVuc29ycyYmdC5oYXNPd25Qcm9wZXJ0eShcInRlbnNvcnNcIikpe2lmKCFBcnJheS5pc0FycmF5KHQudGVuc29ycykpcmV0dXJuXCJ0ZW5zb3JzOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LnRlbnNvcnMubGVuZ3RoOysrZSlpZihuPWwub25ueC5UZW5zb3JQcm90by52ZXJpZnkodC50ZW5zb3JzW2VdKSlyZXR1cm5cInRlbnNvcnMuXCIrbn1pZihudWxsIT10LmdyYXBocyYmdC5oYXNPd25Qcm9wZXJ0eShcImdyYXBoc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5ncmFwaHMpKXJldHVyblwiZ3JhcGhzOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmdyYXBocy5sZW5ndGg7KytlKXt2YXIgbjtpZihuPWwub25ueC5HcmFwaFByb3RvLnZlcmlmeSh0LmdyYXBoc1tlXSkpcmV0dXJuXCJncmFwaHMuXCIrbn19cmV0dXJuIG51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LkF0dHJpYnV0ZVByb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguQXR0cmlidXRlUHJvdG87c3dpdGNoKG51bGwhPXQubmFtZSYmKGUubmFtZT1TdHJpbmcodC5uYW1lKSksbnVsbCE9dC5yZWZBdHRyTmFtZSYmKGUucmVmQXR0ck5hbWU9U3RyaW5nKHQucmVmQXR0ck5hbWUpKSxudWxsIT10LmRvY1N0cmluZyYmKGUuZG9jU3RyaW5nPVN0cmluZyh0LmRvY1N0cmluZykpLHQudHlwZSl7Y2FzZVwiVU5ERUZJTkVEXCI6Y2FzZSAwOmUudHlwZT0wO2JyZWFrO2Nhc2VcIkZMT0FUXCI6Y2FzZSAxOmUudHlwZT0xO2JyZWFrO2Nhc2VcIklOVFwiOmNhc2UgMjplLnR5cGU9MjticmVhaztjYXNlXCJTVFJJTkdcIjpjYXNlIDM6ZS50eXBlPTM7YnJlYWs7Y2FzZVwiVEVOU09SXCI6Y2FzZSA0OmUudHlwZT00O2JyZWFrO2Nhc2VcIkdSQVBIXCI6Y2FzZSA1OmUudHlwZT01O2JyZWFrO2Nhc2VcIkZMT0FUU1wiOmNhc2UgNjplLnR5cGU9NjticmVhaztjYXNlXCJJTlRTXCI6Y2FzZSA3OmUudHlwZT03O2JyZWFrO2Nhc2VcIlNUUklOR1NcIjpjYXNlIDg6ZS50eXBlPTg7YnJlYWs7Y2FzZVwiVEVOU09SU1wiOmNhc2UgOTplLnR5cGU9OTticmVhaztjYXNlXCJHUkFQSFNcIjpjYXNlIDEwOmUudHlwZT0xMH1pZihudWxsIT10LmYmJihlLmY9TnVtYmVyKHQuZikpLG51bGwhPXQuaSYmKGMuTG9uZz8oZS5pPWMuTG9uZy5mcm9tVmFsdWUodC5pKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQuaT9lLmk9cGFyc2VJbnQodC5pLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5pP2UuaT10Lmk6XCJvYmplY3RcIj09dHlwZW9mIHQuaSYmKGUuaT1uZXcgYy5Mb25nQml0cyh0LmkubG93Pj4+MCx0LmkuaGlnaD4+PjApLnRvTnVtYmVyKCkpKSxudWxsIT10LnMmJihcInN0cmluZ1wiPT10eXBlb2YgdC5zP2MuYmFzZTY0LmRlY29kZSh0LnMsZS5zPWMubmV3QnVmZmVyKGMuYmFzZTY0Lmxlbmd0aCh0LnMpKSwwKTp0LnMubGVuZ3RoJiYoZS5zPXQucykpLG51bGwhPXQudCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQudCl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by50OiBvYmplY3QgZXhwZWN0ZWRcIik7ZS50PWwub25ueC5UZW5zb3JQcm90by5mcm9tT2JqZWN0KHQudCl9aWYobnVsbCE9dC5nKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5nKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmc6IG9iamVjdCBleHBlY3RlZFwiKTtlLmc9bC5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdCh0LmcpfWlmKHQuZmxvYXRzKXtpZighQXJyYXkuaXNBcnJheSh0LmZsb2F0cykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uZmxvYXRzOiBhcnJheSBleHBlY3RlZFwiKTtlLmZsb2F0cz1bXTtmb3IodmFyIG49MDtuPHQuZmxvYXRzLmxlbmd0aDsrK24pZS5mbG9hdHNbbl09TnVtYmVyKHQuZmxvYXRzW25dKX1pZih0LmludHMpe2lmKCFBcnJheS5pc0FycmF5KHQuaW50cykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uaW50czogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuaW50cz1bXSxuPTA7bjx0LmludHMubGVuZ3RoOysrbiljLkxvbmc/KGUuaW50c1tuXT1jLkxvbmcuZnJvbVZhbHVlKHQuaW50c1tuXSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiB0LmludHNbbl0/ZS5pbnRzW25dPXBhcnNlSW50KHQuaW50c1tuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQuaW50c1tuXT9lLmludHNbbl09dC5pbnRzW25dOlwib2JqZWN0XCI9PXR5cGVvZiB0LmludHNbbl0mJihlLmludHNbbl09bmV3IGMuTG9uZ0JpdHModC5pbnRzW25dLmxvdz4+PjAsdC5pbnRzW25dLmhpZ2g+Pj4wKS50b051bWJlcigpKX1pZih0LnN0cmluZ3Mpe2lmKCFBcnJheS5pc0FycmF5KHQuc3RyaW5ncykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uc3RyaW5nczogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuc3RyaW5ncz1bXSxuPTA7bjx0LnN0cmluZ3MubGVuZ3RoOysrbilcInN0cmluZ1wiPT10eXBlb2YgdC5zdHJpbmdzW25dP2MuYmFzZTY0LmRlY29kZSh0LnN0cmluZ3Nbbl0sZS5zdHJpbmdzW25dPWMubmV3QnVmZmVyKGMuYmFzZTY0Lmxlbmd0aCh0LnN0cmluZ3Nbbl0pKSwwKTp0LnN0cmluZ3Nbbl0ubGVuZ3RoJiYoZS5zdHJpbmdzW25dPXQuc3RyaW5nc1tuXSl9aWYodC50ZW5zb3JzKXtpZighQXJyYXkuaXNBcnJheSh0LnRlbnNvcnMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnRlbnNvcnM6IGFycmF5IGV4cGVjdGVkXCIpO2ZvcihlLnRlbnNvcnM9W10sbj0wO248dC50ZW5zb3JzLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LnRlbnNvcnNbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udGVuc29yczogb2JqZWN0IGV4cGVjdGVkXCIpO2UudGVuc29yc1tuXT1sLm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdCh0LnRlbnNvcnNbbl0pfX1pZih0LmdyYXBocyl7aWYoIUFycmF5LmlzQXJyYXkodC5ncmFwaHMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmdyYXBoczogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuZ3JhcGhzPVtdLG49MDtuPHQuZ3JhcGhzLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LmdyYXBoc1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5ncmFwaHM6IG9iamVjdCBleHBlY3RlZFwiKTtlLmdyYXBoc1tuXT1sLm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KHQuZ3JhcGhzW25dKX19cmV0dXJuIGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307aWYoKGUuYXJyYXlzfHxlLmRlZmF1bHRzKSYmKG4uZmxvYXRzPVtdLG4uaW50cz1bXSxuLnN0cmluZ3M9W10sbi50ZW5zb3JzPVtdLG4uZ3JhcGhzPVtdKSxlLmRlZmF1bHRzKXtpZihuLm5hbWU9XCJcIixuLmY9MCxjLkxvbmcpe3ZhciByPW5ldyBjLkxvbmcoMCwwLCExKTtuLmk9ZS5sb25ncz09PVN0cmluZz9yLnRvU3RyaW5nKCk6ZS5sb25ncz09PU51bWJlcj9yLnRvTnVtYmVyKCk6cn1lbHNlIG4uaT1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjA7ZS5ieXRlcz09PVN0cmluZz9uLnM9XCJcIjoobi5zPVtdLGUuYnl0ZXMhPT1BcnJheSYmKG4ucz1jLm5ld0J1ZmZlcihuLnMpKSksbi50PW51bGwsbi5nPW51bGwsbi5kb2NTdHJpbmc9XCJcIixuLnR5cGU9ZS5lbnVtcz09PVN0cmluZz9cIlVOREVGSU5FRFwiOjAsbi5yZWZBdHRyTmFtZT1cIlwifWlmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJihuLm5hbWU9dC5uYW1lKSxudWxsIT10LmYmJnQuaGFzT3duUHJvcGVydHkoXCJmXCIpJiYobi5mPWUuanNvbiYmIWlzRmluaXRlKHQuZik/U3RyaW5nKHQuZik6dC5mKSxudWxsIT10LmkmJnQuaGFzT3duUHJvcGVydHkoXCJpXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIHQuaT9uLmk9ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5pKTp0Lmk6bi5pPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuaSk6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LmkubG93Pj4+MCx0LmkuaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5pKSxudWxsIT10LnMmJnQuaGFzT3duUHJvcGVydHkoXCJzXCIpJiYobi5zPWUuYnl0ZXM9PT1TdHJpbmc/Yy5iYXNlNjQuZW5jb2RlKHQucywwLHQucy5sZW5ndGgpOmUuYnl0ZXM9PT1BcnJheT9BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LnMpOnQucyksbnVsbCE9dC50JiZ0Lmhhc093blByb3BlcnR5KFwidFwiKSYmKG4udD1sLm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QodC50LGUpKSxudWxsIT10LmcmJnQuaGFzT3duUHJvcGVydHkoXCJnXCIpJiYobi5nPWwub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KHQuZyxlKSksdC5mbG9hdHMmJnQuZmxvYXRzLmxlbmd0aCl7bi5mbG9hdHM9W107Zm9yKHZhciBpPTA7aTx0LmZsb2F0cy5sZW5ndGg7KytpKW4uZmxvYXRzW2ldPWUuanNvbiYmIWlzRmluaXRlKHQuZmxvYXRzW2ldKT9TdHJpbmcodC5mbG9hdHNbaV0pOnQuZmxvYXRzW2ldfWlmKHQuaW50cyYmdC5pbnRzLmxlbmd0aClmb3Iobi5pbnRzPVtdLGk9MDtpPHQuaW50cy5sZW5ndGg7KytpKVwibnVtYmVyXCI9PXR5cGVvZiB0LmludHNbaV0/bi5pbnRzW2ldPWUubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHQuaW50c1tpXSk6dC5pbnRzW2ldOm4uaW50c1tpXT1lLmxvbmdzPT09U3RyaW5nP2MuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0LmludHNbaV0pOmUubG9uZ3M9PT1OdW1iZXI/bmV3IGMuTG9uZ0JpdHModC5pbnRzW2ldLmxvdz4+PjAsdC5pbnRzW2ldLmhpZ2g+Pj4wKS50b051bWJlcigpOnQuaW50c1tpXTtpZih0LnN0cmluZ3MmJnQuc3RyaW5ncy5sZW5ndGgpZm9yKG4uc3RyaW5ncz1bXSxpPTA7aTx0LnN0cmluZ3MubGVuZ3RoOysraSluLnN0cmluZ3NbaV09ZS5ieXRlcz09PVN0cmluZz9jLmJhc2U2NC5lbmNvZGUodC5zdHJpbmdzW2ldLDAsdC5zdHJpbmdzW2ldLmxlbmd0aCk6ZS5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQuc3RyaW5nc1tpXSk6dC5zdHJpbmdzW2ldO2lmKHQudGVuc29ycyYmdC50ZW5zb3JzLmxlbmd0aClmb3Iobi50ZW5zb3JzPVtdLGk9MDtpPHQudGVuc29ycy5sZW5ndGg7KytpKW4udGVuc29yc1tpXT1sLm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QodC50ZW5zb3JzW2ldLGUpO2lmKHQuZ3JhcGhzJiZ0LmdyYXBocy5sZW5ndGgpZm9yKG4uZ3JhcGhzPVtdLGk9MDtpPHQuZ3JhcGhzLmxlbmd0aDsrK2kpbi5ncmFwaHNbaV09bC5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QodC5ncmFwaHNbaV0sZSk7cmV0dXJuIG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9dC5kb2NTdHJpbmcpLG51bGwhPXQudHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikmJihuLnR5cGU9ZS5lbnVtcz09PVN0cmluZz9sLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVt0LnR5cGVdOnQudHlwZSksbnVsbCE9dC5yZWZBdHRyTmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcInJlZkF0dHJOYW1lXCIpJiYobi5yZWZBdHRyTmFtZT10LnJlZkF0dHJOYW1lKSxufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sdC5BdHRyaWJ1dGVUeXBlPWZ1bmN0aW9uKCl7dmFyIHQ9e30sZT1PYmplY3QuY3JlYXRlKHQpO3JldHVybiBlW3RbMF09XCJVTkRFRklORURcIl09MCxlW3RbMV09XCJGTE9BVFwiXT0xLGVbdFsyXT1cIklOVFwiXT0yLGVbdFszXT1cIlNUUklOR1wiXT0zLGVbdFs0XT1cIlRFTlNPUlwiXT00LGVbdFs1XT1cIkdSQVBIXCJdPTUsZVt0WzZdPVwiRkxPQVRTXCJdPTYsZVt0WzddPVwiSU5UU1wiXT03LGVbdFs4XT1cIlNUUklOR1NcIl09OCxlW3RbOV09XCJURU5TT1JTXCJdPTksZVt0WzEwXT1cIkdSQVBIU1wiXT0xMCxlfSgpLHR9KCksby5WYWx1ZUluZm9Qcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS5uYW1lPVwiXCIsdC5wcm90b3R5cGUudHlwZT1udWxsLHQucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmZS51aW50MzIoMTApLnN0cmluZyh0Lm5hbWUpLG51bGwhPXQudHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikmJmwub25ueC5UeXBlUHJvdG8uZW5jb2RlKHQudHlwZSxlLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKSxudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmZS51aW50MzIoMjYpLnN0cmluZyh0LmRvY1N0cmluZyksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlZhbHVlSW5mb1Byb3RvO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOnIubmFtZT10LnN0cmluZygpO2JyZWFrO2Nhc2UgMjpyLnR5cGU9bC5vbm54LlR5cGVQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKTticmVhaztjYXNlIDM6ci5kb2NTdHJpbmc9dC5zdHJpbmcoKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFjLmlzU3RyaW5nKHQubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LnR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKXt2YXIgZT1sLm9ubnguVHlwZVByb3RvLnZlcmlmeSh0LnR5cGUpO2lmKGUpcmV0dXJuXCJ0eXBlLlwiK2V9cmV0dXJuIG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhYy5pc1N0cmluZyh0LmRvY1N0cmluZyk/XCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlZhbHVlSW5mb1Byb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguVmFsdWVJbmZvUHJvdG87aWYobnVsbCE9dC5uYW1lJiYoZS5uYW1lPVN0cmluZyh0Lm5hbWUpKSxudWxsIT10LnR5cGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LnR5cGUpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVmFsdWVJbmZvUHJvdG8udHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO2UudHlwZT1sLm9ubnguVHlwZVByb3RvLmZyb21PYmplY3QodC50eXBlKX1yZXR1cm4gbnVsbCE9dC5kb2NTdHJpbmcmJihlLmRvY1N0cmluZz1TdHJpbmcodC5kb2NTdHJpbmcpKSxlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O3JldHVybiBlLmRlZmF1bHRzJiYobi5uYW1lPVwiXCIsbi50eXBlPW51bGwsbi5kb2NTdHJpbmc9XCJcIiksbnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmKG4ubmFtZT10Lm5hbWUpLG51bGwhPXQudHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikmJihuLnR5cGU9bC5vbm54LlR5cGVQcm90by50b09iamVjdCh0LnR5cGUsZSkpLG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9dC5kb2NTdHJpbmcpLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLG8uTm9kZVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLmlucHV0PVtdLHRoaXMub3V0cHV0PVtdLHRoaXMuYXR0cmlidXRlPVtdLHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUuaW5wdXQ9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLm91dHB1dD1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUubmFtZT1cIlwiLHQucHJvdG90eXBlLm9wVHlwZT1cIlwiLHQucHJvdG90eXBlLmRvbWFpbj1cIlwiLHQucHJvdG90eXBlLmF0dHJpYnV0ZT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe2lmKGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuaW5wdXQmJnQuaW5wdXQubGVuZ3RoKWZvcih2YXIgbj0wO248dC5pbnB1dC5sZW5ndGg7KytuKWUudWludDMyKDEwKS5zdHJpbmcodC5pbnB1dFtuXSk7aWYobnVsbCE9dC5vdXRwdXQmJnQub3V0cHV0Lmxlbmd0aClmb3Iobj0wO248dC5vdXRwdXQubGVuZ3RoOysrbillLnVpbnQzMigxOCkuc3RyaW5nKHQub3V0cHV0W25dKTtpZihudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiZlLnVpbnQzMigyNikuc3RyaW5nKHQubmFtZSksbnVsbCE9dC5vcFR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJvcFR5cGVcIikmJmUudWludDMyKDM0KS5zdHJpbmcodC5vcFR5cGUpLG51bGwhPXQuYXR0cmlidXRlJiZ0LmF0dHJpYnV0ZS5sZW5ndGgpZm9yKG49MDtuPHQuYXR0cmlidXRlLmxlbmd0aDsrK24pbC5vbm54LkF0dHJpYnV0ZVByb3RvLmVuY29kZSh0LmF0dHJpYnV0ZVtuXSxlLnVpbnQzMig0MikuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gbnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJmUudWludDMyKDUwKS5zdHJpbmcodC5kb2NTdHJpbmcpLG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiZlLnVpbnQzMig1OCkuc3RyaW5nKHQuZG9tYWluKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguTm9kZVByb3RvO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOnIuaW5wdXQmJnIuaW5wdXQubGVuZ3RofHwoci5pbnB1dD1bXSksci5pbnB1dC5wdXNoKHQuc3RyaW5nKCkpO2JyZWFrO2Nhc2UgMjpyLm91dHB1dCYmci5vdXRwdXQubGVuZ3RofHwoci5vdXRwdXQ9W10pLHIub3V0cHV0LnB1c2godC5zdHJpbmcoKSk7YnJlYWs7Y2FzZSAzOnIubmFtZT10LnN0cmluZygpO2JyZWFrO2Nhc2UgNDpyLm9wVHlwZT10LnN0cmluZygpO2JyZWFrO2Nhc2UgNzpyLmRvbWFpbj10LnN0cmluZygpO2JyZWFrO2Nhc2UgNTpyLmF0dHJpYnV0ZSYmci5hdHRyaWJ1dGUubGVuZ3RofHwoci5hdHRyaWJ1dGU9W10pLHIuYXR0cmlidXRlLnB1c2gobC5vbm54LkF0dHJpYnV0ZVByb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDY6ci5kb2NTdHJpbmc9dC5zdHJpbmcoKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPXQuaW5wdXQmJnQuaGFzT3duUHJvcGVydHkoXCJpbnB1dFwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnB1dCkpcmV0dXJuXCJpbnB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIGU9MDtlPHQuaW5wdXQubGVuZ3RoOysrZSlpZighYy5pc1N0cmluZyh0LmlucHV0W2VdKSlyZXR1cm5cImlucHV0OiBzdHJpbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPXQub3V0cHV0JiZ0Lmhhc093blByb3BlcnR5KFwib3V0cHV0XCIpKXtpZighQXJyYXkuaXNBcnJheSh0Lm91dHB1dCkpcmV0dXJuXCJvdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQub3V0cHV0Lmxlbmd0aDsrK2UpaWYoIWMuaXNTdHJpbmcodC5vdXRwdXRbZV0pKXJldHVyblwib3V0cHV0OiBzdHJpbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFjLmlzU3RyaW5nKHQubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10Lm9wVHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm9wVHlwZVwiKSYmIWMuaXNTdHJpbmcodC5vcFR5cGUpKXJldHVyblwib3BUeXBlOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRvbWFpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmIWMuaXNTdHJpbmcodC5kb21haW4pKXJldHVyblwiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmF0dHJpYnV0ZSYmdC5oYXNPd25Qcm9wZXJ0eShcImF0dHJpYnV0ZVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5hdHRyaWJ1dGUpKXJldHVyblwiYXR0cmlidXRlOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmF0dHJpYnV0ZS5sZW5ndGg7KytlKXt2YXIgbj1sLm9ubnguQXR0cmlidXRlUHJvdG8udmVyaWZ5KHQuYXR0cmlidXRlW2VdKTtpZihuKXJldHVyblwiYXR0cmlidXRlLlwiK259fXJldHVybiBudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmIWMuaXNTdHJpbmcodC5kb2NTdHJpbmcpP1wiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGwub25ueC5Ob2RlUHJvdG8pcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5Ob2RlUHJvdG87aWYodC5pbnB1dCl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnB1dCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLmlucHV0OiBhcnJheSBleHBlY3RlZFwiKTtlLmlucHV0PVtdO2Zvcih2YXIgbj0wO248dC5pbnB1dC5sZW5ndGg7KytuKWUuaW5wdXRbbl09U3RyaW5nKHQuaW5wdXRbbl0pfWlmKHQub3V0cHV0KXtpZighQXJyYXkuaXNBcnJheSh0Lm91dHB1dCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUub3V0cHV0PVtdLG49MDtuPHQub3V0cHV0Lmxlbmd0aDsrK24pZS5vdXRwdXRbbl09U3RyaW5nKHQub3V0cHV0W25dKX1pZihudWxsIT10Lm5hbWUmJihlLm5hbWU9U3RyaW5nKHQubmFtZSkpLG51bGwhPXQub3BUeXBlJiYoZS5vcFR5cGU9U3RyaW5nKHQub3BUeXBlKSksbnVsbCE9dC5kb21haW4mJihlLmRvbWFpbj1TdHJpbmcodC5kb21haW4pKSx0LmF0dHJpYnV0ZSl7aWYoIUFycmF5LmlzQXJyYXkodC5hdHRyaWJ1dGUpKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk5vZGVQcm90by5hdHRyaWJ1dGU6IGFycmF5IGV4cGVjdGVkXCIpO2ZvcihlLmF0dHJpYnV0ZT1bXSxuPTA7bjx0LmF0dHJpYnV0ZS5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5hdHRyaWJ1dGVbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLmF0dHJpYnV0ZTogb2JqZWN0IGV4cGVjdGVkXCIpO2UuYXR0cmlidXRlW25dPWwub25ueC5BdHRyaWJ1dGVQcm90by5mcm9tT2JqZWN0KHQuYXR0cmlidXRlW25dKX19cmV0dXJuIG51bGwhPXQuZG9jU3RyaW5nJiYoZS5kb2NTdHJpbmc9U3RyaW5nKHQuZG9jU3RyaW5nKSksZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtpZigoZS5hcnJheXN8fGUuZGVmYXVsdHMpJiYobi5pbnB1dD1bXSxuLm91dHB1dD1bXSxuLmF0dHJpYnV0ZT1bXSksZS5kZWZhdWx0cyYmKG4ubmFtZT1cIlwiLG4ub3BUeXBlPVwiXCIsbi5kb2NTdHJpbmc9XCJcIixuLmRvbWFpbj1cIlwiKSx0LmlucHV0JiZ0LmlucHV0Lmxlbmd0aCl7bi5pbnB1dD1bXTtmb3IodmFyIHI9MDtyPHQuaW5wdXQubGVuZ3RoOysrciluLmlucHV0W3JdPXQuaW5wdXRbcl19aWYodC5vdXRwdXQmJnQub3V0cHV0Lmxlbmd0aClmb3Iobi5vdXRwdXQ9W10scj0wO3I8dC5vdXRwdXQubGVuZ3RoOysrciluLm91dHB1dFtyXT10Lm91dHB1dFtyXTtpZihudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYobi5uYW1lPXQubmFtZSksbnVsbCE9dC5vcFR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJvcFR5cGVcIikmJihuLm9wVHlwZT10Lm9wVHlwZSksdC5hdHRyaWJ1dGUmJnQuYXR0cmlidXRlLmxlbmd0aClmb3Iobi5hdHRyaWJ1dGU9W10scj0wO3I8dC5hdHRyaWJ1dGUubGVuZ3RoOysrciluLmF0dHJpYnV0ZVtyXT1sLm9ubnguQXR0cmlidXRlUHJvdG8udG9PYmplY3QodC5hdHRyaWJ1dGVbcl0sZSk7cmV0dXJuIG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9dC5kb2NTdHJpbmcpLG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYobi5kb21haW49dC5kb21haW4pLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLG8uTW9kZWxQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodGhpcy5vcHNldEltcG9ydD1bXSx0aGlzLm1ldGFkYXRhUHJvcHM9W10sdClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS5pclZlcnNpb249Yy5Mb25nP2MuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsdC5wcm90b3R5cGUub3BzZXRJbXBvcnQ9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLnByb2R1Y2VyTmFtZT1cIlwiLHQucHJvdG90eXBlLnByb2R1Y2VyVmVyc2lvbj1cIlwiLHQucHJvdG90eXBlLmRvbWFpbj1cIlwiLHQucHJvdG90eXBlLm1vZGVsVmVyc2lvbj1jLkxvbmc/Yy5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCx0LnByb3RvdHlwZS5kb2NTdHJpbmc9XCJcIix0LnByb3RvdHlwZS5ncmFwaD1udWxsLHQucHJvdG90eXBlLm1ldGFkYXRhUHJvcHM9Yy5lbXB0eUFycmF5LHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtpZihlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LmlyVmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcImlyVmVyc2lvblwiKSYmZS51aW50MzIoOCkuaW50NjQodC5pclZlcnNpb24pLG51bGwhPXQucHJvZHVjZXJOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwicHJvZHVjZXJOYW1lXCIpJiZlLnVpbnQzMigxOCkuc3RyaW5nKHQucHJvZHVjZXJOYW1lKSxudWxsIT10LnByb2R1Y2VyVmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyVmVyc2lvblwiKSYmZS51aW50MzIoMjYpLnN0cmluZyh0LnByb2R1Y2VyVmVyc2lvbiksbnVsbCE9dC5kb21haW4mJnQuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJmUudWludDMyKDM0KS5zdHJpbmcodC5kb21haW4pLG51bGwhPXQubW9kZWxWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwibW9kZWxWZXJzaW9uXCIpJiZlLnVpbnQzMig0MCkuaW50NjQodC5tb2RlbFZlcnNpb24pLG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiZlLnVpbnQzMig1MCkuc3RyaW5nKHQuZG9jU3RyaW5nKSxudWxsIT10LmdyYXBoJiZ0Lmhhc093blByb3BlcnR5KFwiZ3JhcGhcIikmJmwub25ueC5HcmFwaFByb3RvLmVuY29kZSh0LmdyYXBoLGUudWludDMyKDU4KS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPXQub3BzZXRJbXBvcnQmJnQub3BzZXRJbXBvcnQubGVuZ3RoKWZvcih2YXIgbj0wO248dC5vcHNldEltcG9ydC5sZW5ndGg7KytuKWwub25ueC5PcGVyYXRvclNldElkUHJvdG8uZW5jb2RlKHQub3BzZXRJbXBvcnRbbl0sZS51aW50MzIoNjYpLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9dC5tZXRhZGF0YVByb3BzJiZ0Lm1ldGFkYXRhUHJvcHMubGVuZ3RoKWZvcihuPTA7bjx0Lm1ldGFkYXRhUHJvcHMubGVuZ3RoOysrbilsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUodC5tZXRhZGF0YVByb3BzW25dLGUudWludDMyKDExNCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54Lk1vZGVsUHJvdG87dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5pclZlcnNpb249dC5pbnQ2NCgpO2JyZWFrO2Nhc2UgODpyLm9wc2V0SW1wb3J0JiZyLm9wc2V0SW1wb3J0Lmxlbmd0aHx8KHIub3BzZXRJbXBvcnQ9W10pLHIub3BzZXRJbXBvcnQucHVzaChsLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDI6ci5wcm9kdWNlck5hbWU9dC5zdHJpbmcoKTticmVhaztjYXNlIDM6ci5wcm9kdWNlclZlcnNpb249dC5zdHJpbmcoKTticmVhaztjYXNlIDQ6ci5kb21haW49dC5zdHJpbmcoKTticmVhaztjYXNlIDU6ci5tb2RlbFZlcnNpb249dC5pbnQ2NCgpO2JyZWFrO2Nhc2UgNjpyLmRvY1N0cmluZz10LnN0cmluZygpO2JyZWFrO2Nhc2UgNzpyLmdyYXBoPWwub25ueC5HcmFwaFByb3RvLmRlY29kZSh0LHQudWludDMyKCkpO2JyZWFrO2Nhc2UgMTQ6ci5tZXRhZGF0YVByb3BzJiZyLm1ldGFkYXRhUHJvcHMubGVuZ3RofHwoci5tZXRhZGF0YVByb3BzPVtdKSxyLm1ldGFkYXRhUHJvcHMucHVzaChsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT10LmlyVmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcImlyVmVyc2lvblwiKSYmIShjLmlzSW50ZWdlcih0LmlyVmVyc2lvbil8fHQuaXJWZXJzaW9uJiZjLmlzSW50ZWdlcih0LmlyVmVyc2lvbi5sb3cpJiZjLmlzSW50ZWdlcih0LmlyVmVyc2lvbi5oaWdoKSkpcmV0dXJuXCJpclZlcnNpb246IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO2lmKG51bGwhPXQub3BzZXRJbXBvcnQmJnQuaGFzT3duUHJvcGVydHkoXCJvcHNldEltcG9ydFwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5vcHNldEltcG9ydCkpcmV0dXJuXCJvcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIGU9MDtlPHQub3BzZXRJbXBvcnQubGVuZ3RoOysrZSlpZihuPWwub25ueC5PcGVyYXRvclNldElkUHJvdG8udmVyaWZ5KHQub3BzZXRJbXBvcnRbZV0pKXJldHVyblwib3BzZXRJbXBvcnQuXCIrbn1pZihudWxsIT10LnByb2R1Y2VyTmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyTmFtZVwiKSYmIWMuaXNTdHJpbmcodC5wcm9kdWNlck5hbWUpKXJldHVyblwicHJvZHVjZXJOYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LnByb2R1Y2VyVmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyVmVyc2lvblwiKSYmIWMuaXNTdHJpbmcodC5wcm9kdWNlclZlcnNpb24pKXJldHVyblwicHJvZHVjZXJWZXJzaW9uOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRvbWFpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmIWMuaXNTdHJpbmcodC5kb21haW4pKXJldHVyblwiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10Lm1vZGVsVmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcIm1vZGVsVmVyc2lvblwiKSYmIShjLmlzSW50ZWdlcih0Lm1vZGVsVmVyc2lvbil8fHQubW9kZWxWZXJzaW9uJiZjLmlzSW50ZWdlcih0Lm1vZGVsVmVyc2lvbi5sb3cpJiZjLmlzSW50ZWdlcih0Lm1vZGVsVmVyc2lvbi5oaWdoKSkpcmV0dXJuXCJtb2RlbFZlcnNpb246IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhYy5pc1N0cmluZyh0LmRvY1N0cmluZykpcmV0dXJuXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuZ3JhcGgmJnQuaGFzT3duUHJvcGVydHkoXCJncmFwaFwiKSYmKG49bC5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KHQuZ3JhcGgpKSlyZXR1cm5cImdyYXBoLlwiK247aWYobnVsbCE9dC5tZXRhZGF0YVByb3BzJiZ0Lmhhc093blByb3BlcnR5KFwibWV0YWRhdGFQcm9wc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5tZXRhZGF0YVByb3BzKSlyZXR1cm5cIm1ldGFkYXRhUHJvcHM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQubWV0YWRhdGFQcm9wcy5sZW5ndGg7KytlKXt2YXIgbjtpZihuPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeSh0Lm1ldGFkYXRhUHJvcHNbZV0pKXJldHVyblwibWV0YWRhdGFQcm9wcy5cIitufX1yZXR1cm4gbnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguTW9kZWxQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54Lk1vZGVsUHJvdG87aWYobnVsbCE9dC5pclZlcnNpb24mJihjLkxvbmc/KGUuaXJWZXJzaW9uPWMuTG9uZy5mcm9tVmFsdWUodC5pclZlcnNpb24pKS51bnNpZ25lZD0hMTpcInN0cmluZ1wiPT10eXBlb2YgdC5pclZlcnNpb24/ZS5pclZlcnNpb249cGFyc2VJbnQodC5pclZlcnNpb24sMTApOlwibnVtYmVyXCI9PXR5cGVvZiB0LmlyVmVyc2lvbj9lLmlyVmVyc2lvbj10LmlyVmVyc2lvbjpcIm9iamVjdFwiPT10eXBlb2YgdC5pclZlcnNpb24mJihlLmlyVmVyc2lvbj1uZXcgYy5Mb25nQml0cyh0LmlyVmVyc2lvbi5sb3c+Pj4wLHQuaXJWZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpKSksdC5vcHNldEltcG9ydCl7aWYoIUFycmF5LmlzQXJyYXkodC5vcHNldEltcG9ydCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIik7ZS5vcHNldEltcG9ydD1bXTtmb3IodmFyIG49MDtuPHQub3BzZXRJbXBvcnQubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQub3BzZXRJbXBvcnRbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogb2JqZWN0IGV4cGVjdGVkXCIpO2Uub3BzZXRJbXBvcnRbbl09bC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5mcm9tT2JqZWN0KHQub3BzZXRJbXBvcnRbbl0pfX1pZihudWxsIT10LnByb2R1Y2VyTmFtZSYmKGUucHJvZHVjZXJOYW1lPVN0cmluZyh0LnByb2R1Y2VyTmFtZSkpLG51bGwhPXQucHJvZHVjZXJWZXJzaW9uJiYoZS5wcm9kdWNlclZlcnNpb249U3RyaW5nKHQucHJvZHVjZXJWZXJzaW9uKSksbnVsbCE9dC5kb21haW4mJihlLmRvbWFpbj1TdHJpbmcodC5kb21haW4pKSxudWxsIT10Lm1vZGVsVmVyc2lvbiYmKGMuTG9uZz8oZS5tb2RlbFZlcnNpb249Yy5Mb25nLmZyb21WYWx1ZSh0Lm1vZGVsVmVyc2lvbikpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiB0Lm1vZGVsVmVyc2lvbj9lLm1vZGVsVmVyc2lvbj1wYXJzZUludCh0Lm1vZGVsVmVyc2lvbiwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQubW9kZWxWZXJzaW9uP2UubW9kZWxWZXJzaW9uPXQubW9kZWxWZXJzaW9uOlwib2JqZWN0XCI9PXR5cGVvZiB0Lm1vZGVsVmVyc2lvbiYmKGUubW9kZWxWZXJzaW9uPW5ldyBjLkxvbmdCaXRzKHQubW9kZWxWZXJzaW9uLmxvdz4+PjAsdC5tb2RlbFZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCkpKSxudWxsIT10LmRvY1N0cmluZyYmKGUuZG9jU3RyaW5nPVN0cmluZyh0LmRvY1N0cmluZykpLG51bGwhPXQuZ3JhcGgpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LmdyYXBoKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8uZ3JhcGg6IG9iamVjdCBleHBlY3RlZFwiKTtlLmdyYXBoPWwub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3QodC5ncmFwaCl9aWYodC5tZXRhZGF0YVByb3BzKXtpZighQXJyYXkuaXNBcnJheSh0Lm1ldGFkYXRhUHJvcHMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8ubWV0YWRhdGFQcm9wczogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUubWV0YWRhdGFQcm9wcz1bXSxuPTA7bjx0Lm1ldGFkYXRhUHJvcHMubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQubWV0YWRhdGFQcm9wc1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLm1ldGFkYXRhUHJvcHM6IG9iamVjdCBleHBlY3RlZFwiKTtlLm1ldGFkYXRhUHJvcHNbbl09bC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdCh0Lm1ldGFkYXRhUHJvcHNbbl0pfX1yZXR1cm4gZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtpZigoZS5hcnJheXN8fGUuZGVmYXVsdHMpJiYobi5vcHNldEltcG9ydD1bXSxuLm1ldGFkYXRhUHJvcHM9W10pLGUuZGVmYXVsdHMpe2lmKGMuTG9uZyl7dmFyIHI9bmV3IGMuTG9uZygwLDAsITEpO24uaXJWZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/ci50b1N0cmluZygpOmUubG9uZ3M9PT1OdW1iZXI/ci50b051bWJlcigpOnJ9ZWxzZSBuLmlyVmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjA7bi5wcm9kdWNlck5hbWU9XCJcIixuLnByb2R1Y2VyVmVyc2lvbj1cIlwiLG4uZG9tYWluPVwiXCIsYy5Mb25nPyhyPW5ldyBjLkxvbmcoMCwwLCExKSxuLm1vZGVsVmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTplLmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyKTpuLm1vZGVsVmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjAsbi5kb2NTdHJpbmc9XCJcIixuLmdyYXBoPW51bGx9aWYobnVsbCE9dC5pclZlcnNpb24mJnQuaGFzT3duUHJvcGVydHkoXCJpclZlcnNpb25cIikmJihcIm51bWJlclwiPT10eXBlb2YgdC5pclZlcnNpb24/bi5pclZlcnNpb249ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5pclZlcnNpb24pOnQuaXJWZXJzaW9uOm4uaXJWZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuaXJWZXJzaW9uKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQuaXJWZXJzaW9uLmxvdz4+PjAsdC5pclZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5pclZlcnNpb24pLG51bGwhPXQucHJvZHVjZXJOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwicHJvZHVjZXJOYW1lXCIpJiYobi5wcm9kdWNlck5hbWU9dC5wcm9kdWNlck5hbWUpLG51bGwhPXQucHJvZHVjZXJWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwicHJvZHVjZXJWZXJzaW9uXCIpJiYobi5wcm9kdWNlclZlcnNpb249dC5wcm9kdWNlclZlcnNpb24pLG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYobi5kb21haW49dC5kb21haW4pLG51bGwhPXQubW9kZWxWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwibW9kZWxWZXJzaW9uXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIHQubW9kZWxWZXJzaW9uP24ubW9kZWxWZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHQubW9kZWxWZXJzaW9uKTp0Lm1vZGVsVmVyc2lvbjpuLm1vZGVsVmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP2MuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0Lm1vZGVsVmVyc2lvbik6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0Lm1vZGVsVmVyc2lvbi5sb3c+Pj4wLHQubW9kZWxWZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpOnQubW9kZWxWZXJzaW9uKSxudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmKG4uZG9jU3RyaW5nPXQuZG9jU3RyaW5nKSxudWxsIT10LmdyYXBoJiZ0Lmhhc093blByb3BlcnR5KFwiZ3JhcGhcIikmJihuLmdyYXBoPWwub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KHQuZ3JhcGgsZSkpLHQub3BzZXRJbXBvcnQmJnQub3BzZXRJbXBvcnQubGVuZ3RoKXtuLm9wc2V0SW1wb3J0PVtdO2Zvcih2YXIgaT0wO2k8dC5vcHNldEltcG9ydC5sZW5ndGg7KytpKW4ub3BzZXRJbXBvcnRbaV09bC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by50b09iamVjdCh0Lm9wc2V0SW1wb3J0W2ldLGUpfWlmKHQubWV0YWRhdGFQcm9wcyYmdC5tZXRhZGF0YVByb3BzLmxlbmd0aClmb3Iobi5tZXRhZGF0YVByb3BzPVtdLGk9MDtpPHQubWV0YWRhdGFQcm9wcy5sZW5ndGg7KytpKW4ubWV0YWRhdGFQcm9wc1tpXT1sLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdCh0Lm1ldGFkYXRhUHJvcHNbaV0sZSk7cmV0dXJuIG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLG8uU3RyaW5nU3RyaW5nRW50cnlQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS5rZXk9XCJcIix0LnByb3RvdHlwZS52YWx1ZT1cIlwiLHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5rZXkmJnQuaGFzT3duUHJvcGVydHkoXCJrZXlcIikmJmUudWludDMyKDEwKS5zdHJpbmcodC5rZXkpLG51bGwhPXQudmFsdWUmJnQuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSYmZS51aW50MzIoMTgpLnN0cmluZyh0LnZhbHVlKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLmtleT10LnN0cmluZygpO2JyZWFrO2Nhc2UgMjpyLnZhbHVlPXQuc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtyZXR1cm5cIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQ/XCJvYmplY3QgZXhwZWN0ZWRcIjpudWxsIT10LmtleSYmdC5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSYmIWMuaXNTdHJpbmcodC5rZXkpP1wia2V5OiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsIT10LnZhbHVlJiZ0Lmhhc093blByb3BlcnR5KFwidmFsdWVcIikmJiFjLmlzU3RyaW5nKHQudmFsdWUpP1widmFsdWU6IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8pcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvO3JldHVybiBudWxsIT10LmtleSYmKGUua2V5PVN0cmluZyh0LmtleSkpLG51bGwhPXQudmFsdWUmJihlLnZhbHVlPVN0cmluZyh0LnZhbHVlKSksZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtyZXR1cm4gZS5kZWZhdWx0cyYmKG4ua2V5PVwiXCIsbi52YWx1ZT1cIlwiKSxudWxsIT10LmtleSYmdC5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSYmKG4ua2V5PXQua2V5KSxudWxsIT10LnZhbHVlJiZ0Lmhhc093blByb3BlcnR5KFwidmFsdWVcIikmJihuLnZhbHVlPXQudmFsdWUpLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLG8uVGVuc29yQW5ub3RhdGlvbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodGhpcy5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPVtdLHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUudGVuc29yTmFtZT1cIlwiLHQucHJvdG90eXBlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9Yy5lbXB0eUFycmF5LHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtpZihlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LnRlbnNvck5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JOYW1lXCIpJiZlLnVpbnQzMigxMCkuc3RyaW5nKHQudGVuc29yTmFtZSksbnVsbCE9dC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzJiZ0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoKWZvcih2YXIgbj0wO248dC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK24pbC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlKHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXSxlLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlRlbnNvckFubm90YXRpb247dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci50ZW5zb3JOYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyOnIucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmci5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aHx8KHIucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1bXSksci5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLnB1c2gobC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC50ZW5zb3JOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwidGVuc29yTmFtZVwiKSYmIWMuaXNTdHJpbmcodC50ZW5zb3JOYW1lKSlyZXR1cm5cInRlbnNvck5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmdC5oYXNPd25Qcm9wZXJ0eShcInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNcIikpe2lmKCFBcnJheS5pc0FycmF5KHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcykpcmV0dXJuXCJxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgZT0wO2U8dC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK2Upe3ZhciBuPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeSh0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbZV0pO2lmKG4pcmV0dXJuXCJxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLlwiK259fXJldHVybiBudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGwub25ueC5UZW5zb3JBbm5vdGF0aW9uKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguVGVuc29yQW5ub3RhdGlvbjtpZihudWxsIT10LnRlbnNvck5hbWUmJihlLnRlbnNvck5hbWU9U3RyaW5nKHQudGVuc29yTmFtZSkpLHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyl7aWYoIUFycmF5LmlzQXJyYXkodC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JBbm5vdGF0aW9uLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM6IGFycmF5IGV4cGVjdGVkXCIpO2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1bXTtmb3IodmFyIG49MDtuPHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvckFubm90YXRpb24ucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lczogb2JqZWN0IGV4cGVjdGVkXCIpO2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXT1sLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXSl9fXJldHVybiBlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKChlLmFycmF5c3x8ZS5kZWZhdWx0cykmJihuLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9W10pLGUuZGVmYXVsdHMmJihuLnRlbnNvck5hbWU9XCJcIiksbnVsbCE9dC50ZW5zb3JOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwidGVuc29yTmFtZVwiKSYmKG4udGVuc29yTmFtZT10LnRlbnNvck5hbWUpLHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aCl7bi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPVtdO2Zvcih2YXIgcj0wO3I8dC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK3Ipbi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW3JdPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tyXSxlKX1yZXR1cm4gbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksby5HcmFwaFByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLm5vZGU9W10sdGhpcy5pbml0aWFsaXplcj1bXSx0aGlzLmlucHV0PVtdLHRoaXMub3V0cHV0PVtdLHRoaXMudmFsdWVJbmZvPVtdLHRoaXMucXVhbnRpemF0aW9uQW5ub3RhdGlvbj1bXSx0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLm5vZGU9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLm5hbWU9XCJcIix0LnByb3RvdHlwZS5pbml0aWFsaXplcj1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsdC5wcm90b3R5cGUuaW5wdXQ9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLm91dHB1dD1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUudmFsdWVJbmZvPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uPWMuZW1wdHlBcnJheSx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7aWYoZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5ub2RlJiZ0Lm5vZGUubGVuZ3RoKWZvcih2YXIgbj0wO248dC5ub2RlLmxlbmd0aDsrK24pbC5vbm54Lk5vZGVQcm90by5lbmNvZGUodC5ub2RlW25dLGUudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJmUudWludDMyKDE4KS5zdHJpbmcodC5uYW1lKSxudWxsIT10LmluaXRpYWxpemVyJiZ0LmluaXRpYWxpemVyLmxlbmd0aClmb3Iobj0wO248dC5pbml0aWFsaXplci5sZW5ndGg7KytuKWwub25ueC5UZW5zb3JQcm90by5lbmNvZGUodC5pbml0aWFsaXplcltuXSxlLnVpbnQzMig0MikuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmZS51aW50MzIoODIpLnN0cmluZyh0LmRvY1N0cmluZyksbnVsbCE9dC5pbnB1dCYmdC5pbnB1dC5sZW5ndGgpZm9yKG49MDtuPHQuaW5wdXQubGVuZ3RoOysrbilsLm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKHQuaW5wdXRbbl0sZS51aW50MzIoOTApLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9dC5vdXRwdXQmJnQub3V0cHV0Lmxlbmd0aClmb3Iobj0wO248dC5vdXRwdXQubGVuZ3RoOysrbilsLm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKHQub3V0cHV0W25dLGUudWludDMyKDk4KS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPXQudmFsdWVJbmZvJiZ0LnZhbHVlSW5mby5sZW5ndGgpZm9yKG49MDtuPHQudmFsdWVJbmZvLmxlbmd0aDsrK24pbC5vbm54LlZhbHVlSW5mb1Byb3RvLmVuY29kZSh0LnZhbHVlSW5mb1tuXSxlLnVpbnQzMigxMDYpLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9dC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uJiZ0LnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoKWZvcihuPTA7bjx0LnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOysrbilsLm9ubnguVGVuc29yQW5ub3RhdGlvbi5lbmNvZGUodC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW25dLGUudWludDMyKDExNCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LkdyYXBoUHJvdG87dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5ub2RlJiZyLm5vZGUubGVuZ3RofHwoci5ub2RlPVtdKSxyLm5vZGUucHVzaChsLm9ubnguTm9kZVByb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDI6ci5uYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSA1OnIuaW5pdGlhbGl6ZXImJnIuaW5pdGlhbGl6ZXIubGVuZ3RofHwoci5pbml0aWFsaXplcj1bXSksci5pbml0aWFsaXplci5wdXNoKGwub25ueC5UZW5zb3JQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxMDpyLmRvY1N0cmluZz10LnN0cmluZygpO2JyZWFrO2Nhc2UgMTE6ci5pbnB1dCYmci5pbnB1dC5sZW5ndGh8fChyLmlucHV0PVtdKSxyLmlucHV0LnB1c2gobC5vbm54LlZhbHVlSW5mb1Byb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDEyOnIub3V0cHV0JiZyLm91dHB1dC5sZW5ndGh8fChyLm91dHB1dD1bXSksci5vdXRwdXQucHVzaChsLm9ubnguVmFsdWVJbmZvUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMTM6ci52YWx1ZUluZm8mJnIudmFsdWVJbmZvLmxlbmd0aHx8KHIudmFsdWVJbmZvPVtdKSxyLnZhbHVlSW5mby5wdXNoKGwub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxNDpyLnF1YW50aXphdGlvbkFubm90YXRpb24mJnIucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGh8fChyLnF1YW50aXphdGlvbkFubm90YXRpb249W10pLHIucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5wdXNoKGwub25ueC5UZW5zb3JBbm5vdGF0aW9uLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPXQubm9kZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5vZGVcIikpe2lmKCFBcnJheS5pc0FycmF5KHQubm9kZSkpcmV0dXJuXCJub2RlOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgZT0wO2U8dC5ub2RlLmxlbmd0aDsrK2UpaWYobj1sLm9ubnguTm9kZVByb3RvLnZlcmlmeSh0Lm5vZGVbZV0pKXJldHVyblwibm9kZS5cIitufWlmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFjLmlzU3RyaW5nKHQubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmluaXRpYWxpemVyJiZ0Lmhhc093blByb3BlcnR5KFwiaW5pdGlhbGl6ZXJcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuaW5pdGlhbGl6ZXIpKXJldHVyblwiaW5pdGlhbGl6ZXI6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuaW5pdGlhbGl6ZXIubGVuZ3RoOysrZSlpZihuPWwub25ueC5UZW5zb3JQcm90by52ZXJpZnkodC5pbml0aWFsaXplcltlXSkpcmV0dXJuXCJpbml0aWFsaXplci5cIitufWlmKG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhYy5pc1N0cmluZyh0LmRvY1N0cmluZykpcmV0dXJuXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuaW5wdXQmJnQuaGFzT3duUHJvcGVydHkoXCJpbnB1dFwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnB1dCkpcmV0dXJuXCJpbnB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5pbnB1dC5sZW5ndGg7KytlKWlmKG49bC5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeSh0LmlucHV0W2VdKSlyZXR1cm5cImlucHV0LlwiK259aWYobnVsbCE9dC5vdXRwdXQmJnQuaGFzT3duUHJvcGVydHkoXCJvdXRwdXRcIikpe2lmKCFBcnJheS5pc0FycmF5KHQub3V0cHV0KSlyZXR1cm5cIm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5vdXRwdXQubGVuZ3RoOysrZSlpZihuPWwub25ueC5WYWx1ZUluZm9Qcm90by52ZXJpZnkodC5vdXRwdXRbZV0pKXJldHVyblwib3V0cHV0LlwiK259aWYobnVsbCE9dC52YWx1ZUluZm8mJnQuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZUluZm9cIikpe2lmKCFBcnJheS5pc0FycmF5KHQudmFsdWVJbmZvKSlyZXR1cm5cInZhbHVlSW5mbzogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC52YWx1ZUluZm8ubGVuZ3RoOysrZSlpZihuPWwub25ueC5WYWx1ZUluZm9Qcm90by52ZXJpZnkodC52YWx1ZUluZm9bZV0pKXJldHVyblwidmFsdWVJbmZvLlwiK259aWYobnVsbCE9dC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwicXVhbnRpemF0aW9uQW5ub3RhdGlvblwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uKSlyZXR1cm5cInF1YW50aXphdGlvbkFubm90YXRpb246IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGg7KytlKXt2YXIgbjtpZihuPWwub25ueC5UZW5zb3JBbm5vdGF0aW9uLnZlcmlmeSh0LnF1YW50aXphdGlvbkFubm90YXRpb25bZV0pKXJldHVyblwicXVhbnRpemF0aW9uQW5ub3RhdGlvbi5cIitufX1yZXR1cm4gbnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguR3JhcGhQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LkdyYXBoUHJvdG87aWYodC5ub2RlKXtpZighQXJyYXkuaXNBcnJheSh0Lm5vZGUpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ubm9kZTogYXJyYXkgZXhwZWN0ZWRcIik7ZS5ub2RlPVtdO2Zvcih2YXIgbj0wO248dC5ub2RlLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0Lm5vZGVbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5ub2RlOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5ub2RlW25dPWwub25ueC5Ob2RlUHJvdG8uZnJvbU9iamVjdCh0Lm5vZGVbbl0pfX1pZihudWxsIT10Lm5hbWUmJihlLm5hbWU9U3RyaW5nKHQubmFtZSkpLHQuaW5pdGlhbGl6ZXIpe2lmKCFBcnJheS5pc0FycmF5KHQuaW5pdGlhbGl6ZXIpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5pdGlhbGl6ZXI6IGFycmF5IGV4cGVjdGVkXCIpO2ZvcihlLmluaXRpYWxpemVyPVtdLG49MDtuPHQuaW5pdGlhbGl6ZXIubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQuaW5pdGlhbGl6ZXJbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbml0aWFsaXplcjogb2JqZWN0IGV4cGVjdGVkXCIpO2UuaW5pdGlhbGl6ZXJbbl09bC5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3QodC5pbml0aWFsaXplcltuXSl9fWlmKG51bGwhPXQuZG9jU3RyaW5nJiYoZS5kb2NTdHJpbmc9U3RyaW5nKHQuZG9jU3RyaW5nKSksdC5pbnB1dCl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnB1dCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbnB1dDogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuaW5wdXQ9W10sbj0wO248dC5pbnB1dC5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5pbnB1dFtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLmlucHV0OiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5pbnB1dFtuXT1sLm9ubnguVmFsdWVJbmZvUHJvdG8uZnJvbU9iamVjdCh0LmlucHV0W25dKX19aWYodC5vdXRwdXQpe2lmKCFBcnJheS5pc0FycmF5KHQub3V0cHV0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUub3V0cHV0PVtdLG49MDtuPHQub3V0cHV0Lmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0Lm91dHB1dFtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm91dHB1dDogb2JqZWN0IGV4cGVjdGVkXCIpO2Uub3V0cHV0W25dPWwub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KHQub3V0cHV0W25dKX19aWYodC52YWx1ZUluZm8pe2lmKCFBcnJheS5pc0FycmF5KHQudmFsdWVJbmZvKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnZhbHVlSW5mbzogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUudmFsdWVJbmZvPVtdLG49MDtuPHQudmFsdWVJbmZvLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LnZhbHVlSW5mb1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnZhbHVlSW5mbzogb2JqZWN0IGV4cGVjdGVkXCIpO2UudmFsdWVJbmZvW25dPWwub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KHQudmFsdWVJbmZvW25dKX19aWYodC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uKXtpZighQXJyYXkuaXNBcnJheSh0LnF1YW50aXphdGlvbkFubm90YXRpb24pKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ucXVhbnRpemF0aW9uQW5ub3RhdGlvbjogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbj1bXSxuPTA7bjx0LnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbltuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnF1YW50aXphdGlvbkFubm90YXRpb246IG9iamVjdCBleHBlY3RlZFwiKTtlLnF1YW50aXphdGlvbkFubm90YXRpb25bbl09bC5vbm54LlRlbnNvckFubm90YXRpb24uZnJvbU9iamVjdCh0LnF1YW50aXphdGlvbkFubm90YXRpb25bbl0pfX1yZXR1cm4gZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtpZigoZS5hcnJheXN8fGUuZGVmYXVsdHMpJiYobi5ub2RlPVtdLG4uaW5pdGlhbGl6ZXI9W10sbi5pbnB1dD1bXSxuLm91dHB1dD1bXSxuLnZhbHVlSW5mbz1bXSxuLnF1YW50aXphdGlvbkFubm90YXRpb249W10pLGUuZGVmYXVsdHMmJihuLm5hbWU9XCJcIixuLmRvY1N0cmluZz1cIlwiKSx0Lm5vZGUmJnQubm9kZS5sZW5ndGgpe24ubm9kZT1bXTtmb3IodmFyIHI9MDtyPHQubm9kZS5sZW5ndGg7KytyKW4ubm9kZVtyXT1sLm9ubnguTm9kZVByb3RvLnRvT2JqZWN0KHQubm9kZVtyXSxlKX1pZihudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYobi5uYW1lPXQubmFtZSksdC5pbml0aWFsaXplciYmdC5pbml0aWFsaXplci5sZW5ndGgpZm9yKG4uaW5pdGlhbGl6ZXI9W10scj0wO3I8dC5pbml0aWFsaXplci5sZW5ndGg7KytyKW4uaW5pdGlhbGl6ZXJbcl09bC5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KHQuaW5pdGlhbGl6ZXJbcl0sZSk7aWYobnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz10LmRvY1N0cmluZyksdC5pbnB1dCYmdC5pbnB1dC5sZW5ndGgpZm9yKG4uaW5wdXQ9W10scj0wO3I8dC5pbnB1dC5sZW5ndGg7KytyKW4uaW5wdXRbcl09bC5vbm54LlZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0KHQuaW5wdXRbcl0sZSk7aWYodC5vdXRwdXQmJnQub3V0cHV0Lmxlbmd0aClmb3Iobi5vdXRwdXQ9W10scj0wO3I8dC5vdXRwdXQubGVuZ3RoOysrciluLm91dHB1dFtyXT1sLm9ubnguVmFsdWVJbmZvUHJvdG8udG9PYmplY3QodC5vdXRwdXRbcl0sZSk7aWYodC52YWx1ZUluZm8mJnQudmFsdWVJbmZvLmxlbmd0aClmb3Iobi52YWx1ZUluZm89W10scj0wO3I8dC52YWx1ZUluZm8ubGVuZ3RoOysrciluLnZhbHVlSW5mb1tyXT1sLm9ubnguVmFsdWVJbmZvUHJvdG8udG9PYmplY3QodC52YWx1ZUluZm9bcl0sZSk7aWYodC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uJiZ0LnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoKWZvcihuLnF1YW50aXphdGlvbkFubm90YXRpb249W10scj0wO3I8dC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsrK3Ipbi5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW3JdPWwub25ueC5UZW5zb3JBbm5vdGF0aW9uLnRvT2JqZWN0KHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbltyXSxlKTtyZXR1cm4gbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksby5UZW5zb3JQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodGhpcy5kaW1zPVtdLHRoaXMuZmxvYXREYXRhPVtdLHRoaXMuaW50MzJEYXRhPVtdLHRoaXMuc3RyaW5nRGF0YT1bXSx0aGlzLmludDY0RGF0YT1bXSx0aGlzLmV4dGVybmFsRGF0YT1bXSx0aGlzLmRvdWJsZURhdGE9W10sdGhpcy51aW50NjREYXRhPVtdLHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUuZGltcz1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZGF0YVR5cGU9MCx0LnByb3RvdHlwZS5zZWdtZW50PW51bGwsdC5wcm90b3R5cGUuZmxvYXREYXRhPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5pbnQzMkRhdGE9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLnN0cmluZ0RhdGE9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLmludDY0RGF0YT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUubmFtZT1cIlwiLHQucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLHQucHJvdG90eXBlLnJhd0RhdGE9Yy5uZXdCdWZmZXIoW10pLHQucHJvdG90eXBlLmV4dGVybmFsRGF0YT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZGF0YUxvY2F0aW9uPTAsdC5wcm90b3R5cGUuZG91YmxlRGF0YT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUudWludDY0RGF0YT1jLmVtcHR5QXJyYXksdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe2lmKGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuZGltcyYmdC5kaW1zLmxlbmd0aCl7ZS51aW50MzIoMTApLmZvcmsoKTtmb3IodmFyIG49MDtuPHQuZGltcy5sZW5ndGg7KytuKWUuaW50NjQodC5kaW1zW25dKTtlLmxkZWxpbSgpfWlmKG51bGwhPXQuZGF0YVR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJkYXRhVHlwZVwiKSYmZS51aW50MzIoMTYpLmludDMyKHQuZGF0YVR5cGUpLG51bGwhPXQuc2VnbWVudCYmdC5oYXNPd25Qcm9wZXJ0eShcInNlZ21lbnRcIikmJmwub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmVuY29kZSh0LnNlZ21lbnQsZS51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCksbnVsbCE9dC5mbG9hdERhdGEmJnQuZmxvYXREYXRhLmxlbmd0aCl7Zm9yKGUudWludDMyKDM0KS5mb3JrKCksbj0wO248dC5mbG9hdERhdGEubGVuZ3RoOysrbillLmZsb2F0KHQuZmxvYXREYXRhW25dKTtlLmxkZWxpbSgpfWlmKG51bGwhPXQuaW50MzJEYXRhJiZ0LmludDMyRGF0YS5sZW5ndGgpe2ZvcihlLnVpbnQzMig0MikuZm9yaygpLG49MDtuPHQuaW50MzJEYXRhLmxlbmd0aDsrK24pZS5pbnQzMih0LmludDMyRGF0YVtuXSk7ZS5sZGVsaW0oKX1pZihudWxsIT10LnN0cmluZ0RhdGEmJnQuc3RyaW5nRGF0YS5sZW5ndGgpZm9yKG49MDtuPHQuc3RyaW5nRGF0YS5sZW5ndGg7KytuKWUudWludDMyKDUwKS5ieXRlcyh0LnN0cmluZ0RhdGFbbl0pO2lmKG51bGwhPXQuaW50NjREYXRhJiZ0LmludDY0RGF0YS5sZW5ndGgpe2ZvcihlLnVpbnQzMig1OCkuZm9yaygpLG49MDtuPHQuaW50NjREYXRhLmxlbmd0aDsrK24pZS5pbnQ2NCh0LmludDY0RGF0YVtuXSk7ZS5sZGVsaW0oKX1pZihudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiZlLnVpbnQzMig2Nikuc3RyaW5nKHQubmFtZSksbnVsbCE9dC5yYXdEYXRhJiZ0Lmhhc093blByb3BlcnR5KFwicmF3RGF0YVwiKSYmZS51aW50MzIoNzQpLmJ5dGVzKHQucmF3RGF0YSksbnVsbCE9dC5kb3VibGVEYXRhJiZ0LmRvdWJsZURhdGEubGVuZ3RoKXtmb3IoZS51aW50MzIoODIpLmZvcmsoKSxuPTA7bjx0LmRvdWJsZURhdGEubGVuZ3RoOysrbillLmRvdWJsZSh0LmRvdWJsZURhdGFbbl0pO2UubGRlbGltKCl9aWYobnVsbCE9dC51aW50NjREYXRhJiZ0LnVpbnQ2NERhdGEubGVuZ3RoKXtmb3IoZS51aW50MzIoOTApLmZvcmsoKSxuPTA7bjx0LnVpbnQ2NERhdGEubGVuZ3RoOysrbillLnVpbnQ2NCh0LnVpbnQ2NERhdGFbbl0pO2UubGRlbGltKCl9aWYobnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJmUudWludDMyKDk4KS5zdHJpbmcodC5kb2NTdHJpbmcpLG51bGwhPXQuZXh0ZXJuYWxEYXRhJiZ0LmV4dGVybmFsRGF0YS5sZW5ndGgpZm9yKG49MDtuPHQuZXh0ZXJuYWxEYXRhLmxlbmd0aDsrK24pbC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlKHQuZXh0ZXJuYWxEYXRhW25dLGUudWludDMyKDEwNikuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gbnVsbCE9dC5kYXRhTG9jYXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkYXRhTG9jYXRpb25cIikmJmUudWludDMyKDExMikuaW50MzIodC5kYXRhTG9jYXRpb24pLGV9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5jb2RlKHQsZSkubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7dCBpbnN0YW5jZW9mIHN8fCh0PXMuY3JlYXRlKHQpKTtmb3IodmFyIG49dm9pZCAwPT09ZT90Lmxlbjp0LnBvcytlLHI9bmV3IGwub25ueC5UZW5zb3JQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTppZihyLmRpbXMmJnIuZGltcy5sZW5ndGh8fChyLmRpbXM9W10pLDI9PSg3JmkpKWZvcih2YXIgbz10LnVpbnQzMigpK3QucG9zO3QucG9zPG87KXIuZGltcy5wdXNoKHQuaW50NjQoKSk7ZWxzZSByLmRpbXMucHVzaCh0LmludDY0KCkpO2JyZWFrO2Nhc2UgMjpyLmRhdGFUeXBlPXQuaW50MzIoKTticmVhaztjYXNlIDM6ci5zZWdtZW50PWwub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmRlY29kZSh0LHQudWludDMyKCkpO2JyZWFrO2Nhc2UgNDppZihyLmZsb2F0RGF0YSYmci5mbG9hdERhdGEubGVuZ3RofHwoci5mbG9hdERhdGE9W10pLDI9PSg3JmkpKWZvcihvPXQudWludDMyKCkrdC5wb3M7dC5wb3M8bzspci5mbG9hdERhdGEucHVzaCh0LmZsb2F0KCkpO2Vsc2Ugci5mbG9hdERhdGEucHVzaCh0LmZsb2F0KCkpO2JyZWFrO2Nhc2UgNTppZihyLmludDMyRGF0YSYmci5pbnQzMkRhdGEubGVuZ3RofHwoci5pbnQzMkRhdGE9W10pLDI9PSg3JmkpKWZvcihvPXQudWludDMyKCkrdC5wb3M7dC5wb3M8bzspci5pbnQzMkRhdGEucHVzaCh0LmludDMyKCkpO2Vsc2Ugci5pbnQzMkRhdGEucHVzaCh0LmludDMyKCkpO2JyZWFrO2Nhc2UgNjpyLnN0cmluZ0RhdGEmJnIuc3RyaW5nRGF0YS5sZW5ndGh8fChyLnN0cmluZ0RhdGE9W10pLHIuc3RyaW5nRGF0YS5wdXNoKHQuYnl0ZXMoKSk7YnJlYWs7Y2FzZSA3OmlmKHIuaW50NjREYXRhJiZyLmludDY0RGF0YS5sZW5ndGh8fChyLmludDY0RGF0YT1bXSksMj09KDcmaSkpZm9yKG89dC51aW50MzIoKSt0LnBvczt0LnBvczxvOylyLmludDY0RGF0YS5wdXNoKHQuaW50NjQoKSk7ZWxzZSByLmludDY0RGF0YS5wdXNoKHQuaW50NjQoKSk7YnJlYWs7Y2FzZSA4OnIubmFtZT10LnN0cmluZygpO2JyZWFrO2Nhc2UgMTI6ci5kb2NTdHJpbmc9dC5zdHJpbmcoKTticmVhaztjYXNlIDk6ci5yYXdEYXRhPXQuYnl0ZXMoKTticmVhaztjYXNlIDEzOnIuZXh0ZXJuYWxEYXRhJiZyLmV4dGVybmFsRGF0YS5sZW5ndGh8fChyLmV4dGVybmFsRGF0YT1bXSksci5leHRlcm5hbERhdGEucHVzaChsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxNDpyLmRhdGFMb2NhdGlvbj10LmludDMyKCk7YnJlYWs7Y2FzZSAxMDppZihyLmRvdWJsZURhdGEmJnIuZG91YmxlRGF0YS5sZW5ndGh8fChyLmRvdWJsZURhdGE9W10pLDI9PSg3JmkpKWZvcihvPXQudWludDMyKCkrdC5wb3M7dC5wb3M8bzspci5kb3VibGVEYXRhLnB1c2godC5kb3VibGUoKSk7ZWxzZSByLmRvdWJsZURhdGEucHVzaCh0LmRvdWJsZSgpKTticmVhaztjYXNlIDExOmlmKHIudWludDY0RGF0YSYmci51aW50NjREYXRhLmxlbmd0aHx8KHIudWludDY0RGF0YT1bXSksMj09KDcmaSkpZm9yKG89dC51aW50MzIoKSt0LnBvczt0LnBvczxvOylyLnVpbnQ2NERhdGEucHVzaCh0LnVpbnQ2NCgpKTtlbHNlIHIudWludDY0RGF0YS5wdXNoKHQudWludDY0KCkpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC5kaW1zJiZ0Lmhhc093blByb3BlcnR5KFwiZGltc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5kaW1zKSlyZXR1cm5cImRpbXM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciBlPTA7ZTx0LmRpbXMubGVuZ3RoOysrZSlpZighKGMuaXNJbnRlZ2VyKHQuZGltc1tlXSl8fHQuZGltc1tlXSYmYy5pc0ludGVnZXIodC5kaW1zW2VdLmxvdykmJmMuaXNJbnRlZ2VyKHQuZGltc1tlXS5oaWdoKSkpcmV0dXJuXCJkaW1zOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPXQuZGF0YVR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJkYXRhVHlwZVwiKSYmIWMuaXNJbnRlZ2VyKHQuZGF0YVR5cGUpKXJldHVyblwiZGF0YVR5cGU6IGludGVnZXIgZXhwZWN0ZWRcIjtpZihudWxsIT10LnNlZ21lbnQmJnQuaGFzT3duUHJvcGVydHkoXCJzZWdtZW50XCIpJiYobj1sLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC52ZXJpZnkodC5zZWdtZW50KSkpcmV0dXJuXCJzZWdtZW50LlwiK247aWYobnVsbCE9dC5mbG9hdERhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJmbG9hdERhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuZmxvYXREYXRhKSlyZXR1cm5cImZsb2F0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5mbG9hdERhdGEubGVuZ3RoOysrZSlpZihcIm51bWJlclwiIT10eXBlb2YgdC5mbG9hdERhdGFbZV0pcmV0dXJuXCJmbG9hdERhdGE6IG51bWJlcltdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC5pbnQzMkRhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJpbnQzMkRhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuaW50MzJEYXRhKSlyZXR1cm5cImludDMyRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5pbnQzMkRhdGEubGVuZ3RoOysrZSlpZighYy5pc0ludGVnZXIodC5pbnQzMkRhdGFbZV0pKXJldHVyblwiaW50MzJEYXRhOiBpbnRlZ2VyW10gZXhwZWN0ZWRcIn1pZihudWxsIT10LnN0cmluZ0RhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJzdHJpbmdEYXRhXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LnN0cmluZ0RhdGEpKXJldHVyblwic3RyaW5nRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5zdHJpbmdEYXRhLmxlbmd0aDsrK2UpaWYoISh0LnN0cmluZ0RhdGFbZV0mJlwibnVtYmVyXCI9PXR5cGVvZiB0LnN0cmluZ0RhdGFbZV0ubGVuZ3RofHxjLmlzU3RyaW5nKHQuc3RyaW5nRGF0YVtlXSkpKXJldHVyblwic3RyaW5nRGF0YTogYnVmZmVyW10gZXhwZWN0ZWRcIn1pZihudWxsIT10LmludDY0RGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcImludDY0RGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnQ2NERhdGEpKXJldHVyblwiaW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmludDY0RGF0YS5sZW5ndGg7KytlKWlmKCEoYy5pc0ludGVnZXIodC5pbnQ2NERhdGFbZV0pfHx0LmludDY0RGF0YVtlXSYmYy5pc0ludGVnZXIodC5pbnQ2NERhdGFbZV0ubG93KSYmYy5pc0ludGVnZXIodC5pbnQ2NERhdGFbZV0uaGlnaCkpKXJldHVyblwiaW50NjREYXRhOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFjLmlzU3RyaW5nKHQubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmIWMuaXNTdHJpbmcodC5kb2NTdHJpbmcpKXJldHVyblwiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LnJhd0RhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJyYXdEYXRhXCIpJiYhKHQucmF3RGF0YSYmXCJudW1iZXJcIj09dHlwZW9mIHQucmF3RGF0YS5sZW5ndGh8fGMuaXNTdHJpbmcodC5yYXdEYXRhKSkpcmV0dXJuXCJyYXdEYXRhOiBidWZmZXIgZXhwZWN0ZWRcIjtpZihudWxsIT10LmV4dGVybmFsRGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcImV4dGVybmFsRGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5leHRlcm5hbERhdGEpKXJldHVyblwiZXh0ZXJuYWxEYXRhOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmV4dGVybmFsRGF0YS5sZW5ndGg7KytlKXt2YXIgbjtpZihuPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeSh0LmV4dGVybmFsRGF0YVtlXSkpcmV0dXJuXCJleHRlcm5hbERhdGEuXCIrbn19aWYobnVsbCE9dC5kYXRhTG9jYXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkYXRhTG9jYXRpb25cIikpc3dpdGNoKHQuZGF0YUxvY2F0aW9uKXtkZWZhdWx0OnJldHVyblwiZGF0YUxvY2F0aW9uOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7Y2FzZSAwOmNhc2UgMTp9aWYobnVsbCE9dC5kb3VibGVEYXRhJiZ0Lmhhc093blByb3BlcnR5KFwiZG91YmxlRGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5kb3VibGVEYXRhKSlyZXR1cm5cImRvdWJsZURhdGE6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuZG91YmxlRGF0YS5sZW5ndGg7KytlKWlmKFwibnVtYmVyXCIhPXR5cGVvZiB0LmRvdWJsZURhdGFbZV0pcmV0dXJuXCJkb3VibGVEYXRhOiBudW1iZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPXQudWludDY0RGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcInVpbnQ2NERhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KHQudWludDY0RGF0YSkpcmV0dXJuXCJ1aW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LnVpbnQ2NERhdGEubGVuZ3RoOysrZSlpZighKGMuaXNJbnRlZ2VyKHQudWludDY0RGF0YVtlXSl8fHQudWludDY0RGF0YVtlXSYmYy5pc0ludGVnZXIodC51aW50NjREYXRhW2VdLmxvdykmJmMuaXNJbnRlZ2VyKHQudWludDY0RGF0YVtlXS5oaWdoKSkpcmV0dXJuXCJ1aW50NjREYXRhOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifXJldHVybiBudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGwub25ueC5UZW5zb3JQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LlRlbnNvclByb3RvO2lmKHQuZGltcyl7aWYoIUFycmF5LmlzQXJyYXkodC5kaW1zKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5kaW1zOiBhcnJheSBleHBlY3RlZFwiKTtlLmRpbXM9W107Zm9yKHZhciBuPTA7bjx0LmRpbXMubGVuZ3RoOysrbiljLkxvbmc/KGUuZGltc1tuXT1jLkxvbmcuZnJvbVZhbHVlKHQuZGltc1tuXSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiB0LmRpbXNbbl0/ZS5kaW1zW25dPXBhcnNlSW50KHQuZGltc1tuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQuZGltc1tuXT9lLmRpbXNbbl09dC5kaW1zW25dOlwib2JqZWN0XCI9PXR5cGVvZiB0LmRpbXNbbl0mJihlLmRpbXNbbl09bmV3IGMuTG9uZ0JpdHModC5kaW1zW25dLmxvdz4+PjAsdC5kaW1zW25dLmhpZ2g+Pj4wKS50b051bWJlcigpKX1pZihudWxsIT10LmRhdGFUeXBlJiYoZS5kYXRhVHlwZT0wfHQuZGF0YVR5cGUpLG51bGwhPXQuc2VnbWVudCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQuc2VnbWVudCl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5zZWdtZW50OiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5zZWdtZW50PWwub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmZyb21PYmplY3QodC5zZWdtZW50KX1pZih0LmZsb2F0RGF0YSl7aWYoIUFycmF5LmlzQXJyYXkodC5mbG9hdERhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmZsb2F0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuZmxvYXREYXRhPVtdLG49MDtuPHQuZmxvYXREYXRhLmxlbmd0aDsrK24pZS5mbG9hdERhdGFbbl09TnVtYmVyKHQuZmxvYXREYXRhW25dKX1pZih0LmludDMyRGF0YSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnQzMkRhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmludDMyRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuaW50MzJEYXRhPVtdLG49MDtuPHQuaW50MzJEYXRhLmxlbmd0aDsrK24pZS5pbnQzMkRhdGFbbl09MHx0LmludDMyRGF0YVtuXX1pZih0LnN0cmluZ0RhdGEpe2lmKCFBcnJheS5pc0FycmF5KHQuc3RyaW5nRGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uc3RyaW5nRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuc3RyaW5nRGF0YT1bXSxuPTA7bjx0LnN0cmluZ0RhdGEubGVuZ3RoOysrbilcInN0cmluZ1wiPT10eXBlb2YgdC5zdHJpbmdEYXRhW25dP2MuYmFzZTY0LmRlY29kZSh0LnN0cmluZ0RhdGFbbl0sZS5zdHJpbmdEYXRhW25dPWMubmV3QnVmZmVyKGMuYmFzZTY0Lmxlbmd0aCh0LnN0cmluZ0RhdGFbbl0pKSwwKTp0LnN0cmluZ0RhdGFbbl0ubGVuZ3RoJiYoZS5zdHJpbmdEYXRhW25dPXQuc3RyaW5nRGF0YVtuXSl9aWYodC5pbnQ2NERhdGEpe2lmKCFBcnJheS5pc0FycmF5KHQuaW50NjREYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5pbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO2ZvcihlLmludDY0RGF0YT1bXSxuPTA7bjx0LmludDY0RGF0YS5sZW5ndGg7KytuKWMuTG9uZz8oZS5pbnQ2NERhdGFbbl09Yy5Mb25nLmZyb21WYWx1ZSh0LmludDY0RGF0YVtuXSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiB0LmludDY0RGF0YVtuXT9lLmludDY0RGF0YVtuXT1wYXJzZUludCh0LmludDY0RGF0YVtuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQuaW50NjREYXRhW25dP2UuaW50NjREYXRhW25dPXQuaW50NjREYXRhW25dOlwib2JqZWN0XCI9PXR5cGVvZiB0LmludDY0RGF0YVtuXSYmKGUuaW50NjREYXRhW25dPW5ldyBjLkxvbmdCaXRzKHQuaW50NjREYXRhW25dLmxvdz4+PjAsdC5pbnQ2NERhdGFbbl0uaGlnaD4+PjApLnRvTnVtYmVyKCkpfWlmKG51bGwhPXQubmFtZSYmKGUubmFtZT1TdHJpbmcodC5uYW1lKSksbnVsbCE9dC5kb2NTdHJpbmcmJihlLmRvY1N0cmluZz1TdHJpbmcodC5kb2NTdHJpbmcpKSxudWxsIT10LnJhd0RhdGEmJihcInN0cmluZ1wiPT10eXBlb2YgdC5yYXdEYXRhP2MuYmFzZTY0LmRlY29kZSh0LnJhd0RhdGEsZS5yYXdEYXRhPWMubmV3QnVmZmVyKGMuYmFzZTY0Lmxlbmd0aCh0LnJhd0RhdGEpKSwwKTp0LnJhd0RhdGEubGVuZ3RoJiYoZS5yYXdEYXRhPXQucmF3RGF0YSkpLHQuZXh0ZXJuYWxEYXRhKXtpZighQXJyYXkuaXNBcnJheSh0LmV4dGVybmFsRGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZXh0ZXJuYWxEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5leHRlcm5hbERhdGE9W10sbj0wO248dC5leHRlcm5hbERhdGEubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQuZXh0ZXJuYWxEYXRhW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmV4dGVybmFsRGF0YTogb2JqZWN0IGV4cGVjdGVkXCIpO2UuZXh0ZXJuYWxEYXRhW25dPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3QodC5leHRlcm5hbERhdGFbbl0pfX1zd2l0Y2godC5kYXRhTG9jYXRpb24pe2Nhc2VcIkRFRkFVTFRcIjpjYXNlIDA6ZS5kYXRhTG9jYXRpb249MDticmVhaztjYXNlXCJFWFRFUk5BTFwiOmNhc2UgMTplLmRhdGFMb2NhdGlvbj0xfWlmKHQuZG91YmxlRGF0YSl7aWYoIUFycmF5LmlzQXJyYXkodC5kb3VibGVEYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5kb3VibGVEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5kb3VibGVEYXRhPVtdLG49MDtuPHQuZG91YmxlRGF0YS5sZW5ndGg7KytuKWUuZG91YmxlRGF0YVtuXT1OdW1iZXIodC5kb3VibGVEYXRhW25dKX1pZih0LnVpbnQ2NERhdGEpe2lmKCFBcnJheS5pc0FycmF5KHQudWludDY0RGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8udWludDY0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUudWludDY0RGF0YT1bXSxuPTA7bjx0LnVpbnQ2NERhdGEubGVuZ3RoOysrbiljLkxvbmc/KGUudWludDY0RGF0YVtuXT1jLkxvbmcuZnJvbVZhbHVlKHQudWludDY0RGF0YVtuXSkpLnVuc2lnbmVkPSEwOlwic3RyaW5nXCI9PXR5cGVvZiB0LnVpbnQ2NERhdGFbbl0/ZS51aW50NjREYXRhW25dPXBhcnNlSW50KHQudWludDY0RGF0YVtuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQudWludDY0RGF0YVtuXT9lLnVpbnQ2NERhdGFbbl09dC51aW50NjREYXRhW25dOlwib2JqZWN0XCI9PXR5cGVvZiB0LnVpbnQ2NERhdGFbbl0mJihlLnVpbnQ2NERhdGFbbl09bmV3IGMuTG9uZ0JpdHModC51aW50NjREYXRhW25dLmxvdz4+PjAsdC51aW50NjREYXRhW25dLmhpZ2g+Pj4wKS50b051bWJlcighMCkpfXJldHVybiBlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKChlLmFycmF5c3x8ZS5kZWZhdWx0cykmJihuLmRpbXM9W10sbi5mbG9hdERhdGE9W10sbi5pbnQzMkRhdGE9W10sbi5zdHJpbmdEYXRhPVtdLG4uaW50NjREYXRhPVtdLG4uZG91YmxlRGF0YT1bXSxuLnVpbnQ2NERhdGE9W10sbi5leHRlcm5hbERhdGE9W10pLGUuZGVmYXVsdHMmJihuLmRhdGFUeXBlPTAsbi5zZWdtZW50PW51bGwsbi5uYW1lPVwiXCIsZS5ieXRlcz09PVN0cmluZz9uLnJhd0RhdGE9XCJcIjoobi5yYXdEYXRhPVtdLGUuYnl0ZXMhPT1BcnJheSYmKG4ucmF3RGF0YT1jLm5ld0J1ZmZlcihuLnJhd0RhdGEpKSksbi5kb2NTdHJpbmc9XCJcIixuLmRhdGFMb2NhdGlvbj1lLmVudW1zPT09U3RyaW5nP1wiREVGQVVMVFwiOjApLHQuZGltcyYmdC5kaW1zLmxlbmd0aCl7bi5kaW1zPVtdO2Zvcih2YXIgcj0wO3I8dC5kaW1zLmxlbmd0aDsrK3IpXCJudW1iZXJcIj09dHlwZW9mIHQuZGltc1tyXT9uLmRpbXNbcl09ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5kaW1zW3JdKTp0LmRpbXNbcl06bi5kaW1zW3JdPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuZGltc1tyXSk6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LmRpbXNbcl0ubG93Pj4+MCx0LmRpbXNbcl0uaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5kaW1zW3JdfWlmKG51bGwhPXQuZGF0YVR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJkYXRhVHlwZVwiKSYmKG4uZGF0YVR5cGU9dC5kYXRhVHlwZSksbnVsbCE9dC5zZWdtZW50JiZ0Lmhhc093blByb3BlcnR5KFwic2VnbWVudFwiKSYmKG4uc2VnbWVudD1sLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC50b09iamVjdCh0LnNlZ21lbnQsZSkpLHQuZmxvYXREYXRhJiZ0LmZsb2F0RGF0YS5sZW5ndGgpZm9yKG4uZmxvYXREYXRhPVtdLHI9MDtyPHQuZmxvYXREYXRhLmxlbmd0aDsrK3Ipbi5mbG9hdERhdGFbcl09ZS5qc29uJiYhaXNGaW5pdGUodC5mbG9hdERhdGFbcl0pP1N0cmluZyh0LmZsb2F0RGF0YVtyXSk6dC5mbG9hdERhdGFbcl07aWYodC5pbnQzMkRhdGEmJnQuaW50MzJEYXRhLmxlbmd0aClmb3Iobi5pbnQzMkRhdGE9W10scj0wO3I8dC5pbnQzMkRhdGEubGVuZ3RoOysrciluLmludDMyRGF0YVtyXT10LmludDMyRGF0YVtyXTtpZih0LnN0cmluZ0RhdGEmJnQuc3RyaW5nRGF0YS5sZW5ndGgpZm9yKG4uc3RyaW5nRGF0YT1bXSxyPTA7cjx0LnN0cmluZ0RhdGEubGVuZ3RoOysrciluLnN0cmluZ0RhdGFbcl09ZS5ieXRlcz09PVN0cmluZz9jLmJhc2U2NC5lbmNvZGUodC5zdHJpbmdEYXRhW3JdLDAsdC5zdHJpbmdEYXRhW3JdLmxlbmd0aCk6ZS5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQuc3RyaW5nRGF0YVtyXSk6dC5zdHJpbmdEYXRhW3JdO2lmKHQuaW50NjREYXRhJiZ0LmludDY0RGF0YS5sZW5ndGgpZm9yKG4uaW50NjREYXRhPVtdLHI9MDtyPHQuaW50NjREYXRhLmxlbmd0aDsrK3IpXCJudW1iZXJcIj09dHlwZW9mIHQuaW50NjREYXRhW3JdP24uaW50NjREYXRhW3JdPWUubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHQuaW50NjREYXRhW3JdKTp0LmludDY0RGF0YVtyXTpuLmludDY0RGF0YVtyXT1lLmxvbmdzPT09U3RyaW5nP2MuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0LmludDY0RGF0YVtyXSk6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LmludDY0RGF0YVtyXS5sb3c+Pj4wLHQuaW50NjREYXRhW3JdLmhpZ2g+Pj4wKS50b051bWJlcigpOnQuaW50NjREYXRhW3JdO2lmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJihuLm5hbWU9dC5uYW1lKSxudWxsIT10LnJhd0RhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJyYXdEYXRhXCIpJiYobi5yYXdEYXRhPWUuYnl0ZXM9PT1TdHJpbmc/Yy5iYXNlNjQuZW5jb2RlKHQucmF3RGF0YSwwLHQucmF3RGF0YS5sZW5ndGgpOmUuYnl0ZXM9PT1BcnJheT9BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LnJhd0RhdGEpOnQucmF3RGF0YSksdC5kb3VibGVEYXRhJiZ0LmRvdWJsZURhdGEubGVuZ3RoKWZvcihuLmRvdWJsZURhdGE9W10scj0wO3I8dC5kb3VibGVEYXRhLmxlbmd0aDsrK3Ipbi5kb3VibGVEYXRhW3JdPWUuanNvbiYmIWlzRmluaXRlKHQuZG91YmxlRGF0YVtyXSk/U3RyaW5nKHQuZG91YmxlRGF0YVtyXSk6dC5kb3VibGVEYXRhW3JdO2lmKHQudWludDY0RGF0YSYmdC51aW50NjREYXRhLmxlbmd0aClmb3Iobi51aW50NjREYXRhPVtdLHI9MDtyPHQudWludDY0RGF0YS5sZW5ndGg7KytyKVwibnVtYmVyXCI9PXR5cGVvZiB0LnVpbnQ2NERhdGFbcl0/bi51aW50NjREYXRhW3JdPWUubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHQudWludDY0RGF0YVtyXSk6dC51aW50NjREYXRhW3JdOm4udWludDY0RGF0YVtyXT1lLmxvbmdzPT09U3RyaW5nP2MuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0LnVpbnQ2NERhdGFbcl0pOmUubG9uZ3M9PT1OdW1iZXI/bmV3IGMuTG9uZ0JpdHModC51aW50NjREYXRhW3JdLmxvdz4+PjAsdC51aW50NjREYXRhW3JdLmhpZ2g+Pj4wKS50b051bWJlcighMCk6dC51aW50NjREYXRhW3JdO2lmKG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9dC5kb2NTdHJpbmcpLHQuZXh0ZXJuYWxEYXRhJiZ0LmV4dGVybmFsRGF0YS5sZW5ndGgpZm9yKG4uZXh0ZXJuYWxEYXRhPVtdLHI9MDtyPHQuZXh0ZXJuYWxEYXRhLmxlbmd0aDsrK3Ipbi5leHRlcm5hbERhdGFbcl09bC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QodC5leHRlcm5hbERhdGFbcl0sZSk7cmV0dXJuIG51bGwhPXQuZGF0YUxvY2F0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwiZGF0YUxvY2F0aW9uXCIpJiYobi5kYXRhTG9jYXRpb249ZS5lbnVtcz09PVN0cmluZz9sLm9ubnguVGVuc29yUHJvdG8uRGF0YUxvY2F0aW9uW3QuZGF0YUxvY2F0aW9uXTp0LmRhdGFMb2NhdGlvbiksbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHQuRGF0YVR5cGU9ZnVuY3Rpb24oKXt2YXIgdD17fSxlPU9iamVjdC5jcmVhdGUodCk7cmV0dXJuIGVbdFswXT1cIlVOREVGSU5FRFwiXT0wLGVbdFsxXT1cIkZMT0FUXCJdPTEsZVt0WzJdPVwiVUlOVDhcIl09MixlW3RbM109XCJJTlQ4XCJdPTMsZVt0WzRdPVwiVUlOVDE2XCJdPTQsZVt0WzVdPVwiSU5UMTZcIl09NSxlW3RbNl09XCJJTlQzMlwiXT02LGVbdFs3XT1cIklOVDY0XCJdPTcsZVt0WzhdPVwiU1RSSU5HXCJdPTgsZVt0WzldPVwiQk9PTFwiXT05LGVbdFsxMF09XCJGTE9BVDE2XCJdPTEwLGVbdFsxMV09XCJET1VCTEVcIl09MTEsZVt0WzEyXT1cIlVJTlQzMlwiXT0xMixlW3RbMTNdPVwiVUlOVDY0XCJdPTEzLGVbdFsxNF09XCJDT01QTEVYNjRcIl09MTQsZVt0WzE1XT1cIkNPTVBMRVgxMjhcIl09MTUsZVt0WzE2XT1cIkJGTE9BVDE2XCJdPTE2LGV9KCksdC5TZWdtZW50PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLmJlZ2luPWMuTG9uZz9jLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLHQucHJvdG90eXBlLmVuZD1jLkxvbmc/Yy5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuYmVnaW4mJnQuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSYmZS51aW50MzIoOCkuaW50NjQodC5iZWdpbiksbnVsbCE9dC5lbmQmJnQuaGFzT3duUHJvcGVydHkoXCJlbmRcIikmJmUudWludDMyKDE2KS5pbnQ2NCh0LmVuZCksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQ7dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5iZWdpbj10LmludDY0KCk7YnJlYWs7Y2FzZSAyOnIuZW5kPXQuaW50NjQoKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe3JldHVyblwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dD9cIm9iamVjdCBleHBlY3RlZFwiOm51bGwhPXQuYmVnaW4mJnQuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSYmIShjLmlzSW50ZWdlcih0LmJlZ2luKXx8dC5iZWdpbiYmYy5pc0ludGVnZXIodC5iZWdpbi5sb3cpJiZjLmlzSW50ZWdlcih0LmJlZ2luLmhpZ2gpKT9cImJlZ2luOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjpudWxsIT10LmVuZCYmdC5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSYmIShjLmlzSW50ZWdlcih0LmVuZCl8fHQuZW5kJiZjLmlzSW50ZWdlcih0LmVuZC5sb3cpJiZjLmlzSW50ZWdlcih0LmVuZC5oaWdoKSk/XCJlbmQ6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQpcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5UZW5zb3JQcm90by5TZWdtZW50O3JldHVybiBudWxsIT10LmJlZ2luJiYoYy5Mb25nPyhlLmJlZ2luPWMuTG9uZy5mcm9tVmFsdWUodC5iZWdpbikpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiB0LmJlZ2luP2UuYmVnaW49cGFyc2VJbnQodC5iZWdpbiwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQuYmVnaW4/ZS5iZWdpbj10LmJlZ2luOlwib2JqZWN0XCI9PXR5cGVvZiB0LmJlZ2luJiYoZS5iZWdpbj1uZXcgYy5Mb25nQml0cyh0LmJlZ2luLmxvdz4+PjAsdC5iZWdpbi5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLG51bGwhPXQuZW5kJiYoYy5Mb25nPyhlLmVuZD1jLkxvbmcuZnJvbVZhbHVlKHQuZW5kKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQuZW5kP2UuZW5kPXBhcnNlSW50KHQuZW5kLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5lbmQ/ZS5lbmQ9dC5lbmQ6XCJvYmplY3RcIj09dHlwZW9mIHQuZW5kJiYoZS5lbmQ9bmV3IGMuTG9uZ0JpdHModC5lbmQubG93Pj4+MCx0LmVuZC5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307aWYoZS5kZWZhdWx0cyl7aWYoYy5Mb25nKXt2YXIgcj1uZXcgYy5Mb25nKDAsMCwhMSk7bi5iZWdpbj1lLmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTplLmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyfWVsc2Ugbi5iZWdpbj1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjA7Yy5Mb25nPyhyPW5ldyBjLkxvbmcoMCwwLCExKSxuLmVuZD1lLmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTplLmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyKTpuLmVuZD1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjB9cmV0dXJuIG51bGwhPXQuYmVnaW4mJnQuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiB0LmJlZ2luP24uYmVnaW49ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5iZWdpbik6dC5iZWdpbjpuLmJlZ2luPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuYmVnaW4pOmUubG9uZ3M9PT1OdW1iZXI/bmV3IGMuTG9uZ0JpdHModC5iZWdpbi5sb3c+Pj4wLHQuYmVnaW4uaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5iZWdpbiksbnVsbCE9dC5lbmQmJnQuaGFzT3duUHJvcGVydHkoXCJlbmRcIikmJihcIm51bWJlclwiPT10eXBlb2YgdC5lbmQ/bi5lbmQ9ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5lbmQpOnQuZW5kOm4uZW5kPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuZW5kKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQuZW5kLmxvdz4+PjAsdC5lbmQuaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5lbmQpLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLHQuRGF0YUxvY2F0aW9uPWZ1bmN0aW9uKCl7dmFyIHQ9e30sZT1PYmplY3QuY3JlYXRlKHQpO3JldHVybiBlW3RbMF09XCJERUZBVUxUXCJdPTAsZVt0WzFdPVwiRVhURVJOQUxcIl09MSxlfSgpLHR9KCksby5UZW5zb3JTaGFwZVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLmRpbT1bXSx0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLmRpbT1jLmVtcHR5QXJyYXksdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe2lmKGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuZGltJiZ0LmRpbS5sZW5ndGgpZm9yKHZhciBuPTA7bjx0LmRpbS5sZW5ndGg7KytuKWwub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi5lbmNvZGUodC5kaW1bbl0sZS51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7cmV0dXJuIGV9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5jb2RlKHQsZSkubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7dCBpbnN0YW5jZW9mIHN8fCh0PXMuY3JlYXRlKHQpKTtmb3IodmFyIG49dm9pZCAwPT09ZT90Lmxlbjp0LnBvcytlLHI9bmV3IGwub25ueC5UZW5zb3JTaGFwZVByb3RvO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO2k+Pj4zPT0xPyhyLmRpbSYmci5kaW0ubGVuZ3RofHwoci5kaW09W10pLHIuZGltLnB1c2gobC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLmRlY29kZSh0LHQudWludDMyKCkpKSk6dC5za2lwVHlwZSg3JmkpfXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRpbSYmdC5oYXNPd25Qcm9wZXJ0eShcImRpbVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5kaW0pKXJldHVyblwiZGltOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgZT0wO2U8dC5kaW0ubGVuZ3RoOysrZSl7dmFyIG49bC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnZlcmlmeSh0LmRpbVtlXSk7aWYobilyZXR1cm5cImRpbS5cIitufX1yZXR1cm4gbnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguVGVuc29yU2hhcGVQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LlRlbnNvclNoYXBlUHJvdG87aWYodC5kaW0pe2lmKCFBcnJheS5pc0FycmF5KHQuZGltKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JTaGFwZVByb3RvLmRpbTogYXJyYXkgZXhwZWN0ZWRcIik7ZS5kaW09W107Zm9yKHZhciBuPTA7bjx0LmRpbS5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5kaW1bbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yU2hhcGVQcm90by5kaW06IG9iamVjdCBleHBlY3RlZFwiKTtlLmRpbVtuXT1sLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24uZnJvbU9iamVjdCh0LmRpbVtuXSl9fXJldHVybiBlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKChlLmFycmF5c3x8ZS5kZWZhdWx0cykmJihuLmRpbT1bXSksdC5kaW0mJnQuZGltLmxlbmd0aCl7bi5kaW09W107Zm9yKHZhciByPTA7cjx0LmRpbS5sZW5ndGg7KytyKW4uZGltW3JdPWwub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi50b09iamVjdCh0LmRpbVtyXSxlKX1yZXR1cm4gbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHQuRGltZW5zaW9uPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9dmFyIGU7cmV0dXJuIHQucHJvdG90eXBlLmRpbVZhbHVlPWMuTG9uZz9jLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLHQucHJvdG90eXBlLmRpbVBhcmFtPVwiXCIsdC5wcm90b3R5cGUuZGVub3RhdGlvbj1cIlwiLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInZhbHVlXCIse2dldDpjLm9uZU9mR2V0dGVyKGU9W1wiZGltVmFsdWVcIixcImRpbVBhcmFtXCJdKSxzZXQ6Yy5vbmVPZlNldHRlcihlKX0pLHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5kaW1WYWx1ZSYmdC5oYXNPd25Qcm9wZXJ0eShcImRpbVZhbHVlXCIpJiZlLnVpbnQzMig4KS5pbnQ2NCh0LmRpbVZhbHVlKSxudWxsIT10LmRpbVBhcmFtJiZ0Lmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikmJmUudWludDMyKDE4KS5zdHJpbmcodC5kaW1QYXJhbSksbnVsbCE9dC5kZW5vdGF0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmZS51aW50MzIoMjYpLnN0cmluZyh0LmRlbm90YXRpb24pLGV9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5jb2RlKHQsZSkubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7dCBpbnN0YW5jZW9mIHN8fCh0PXMuY3JlYXRlKHQpKTtmb3IodmFyIG49dm9pZCAwPT09ZT90Lmxlbjp0LnBvcytlLHI9bmV3IGwub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbjt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLmRpbVZhbHVlPXQuaW50NjQoKTticmVhaztjYXNlIDI6ci5kaW1QYXJhbT10LnN0cmluZygpO2JyZWFrO2Nhc2UgMzpyLmRlbm90YXRpb249dC5zdHJpbmcoKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO3ZhciBlPXt9O2lmKG51bGwhPXQuZGltVmFsdWUmJnQuaGFzT3duUHJvcGVydHkoXCJkaW1WYWx1ZVwiKSYmKGUudmFsdWU9MSwhKGMuaXNJbnRlZ2VyKHQuZGltVmFsdWUpfHx0LmRpbVZhbHVlJiZjLmlzSW50ZWdlcih0LmRpbVZhbHVlLmxvdykmJmMuaXNJbnRlZ2VyKHQuZGltVmFsdWUuaGlnaCkpKSlyZXR1cm5cImRpbVZhbHVlOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRpbVBhcmFtJiZ0Lmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikpe2lmKDE9PT1lLnZhbHVlKXJldHVyblwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO2lmKGUudmFsdWU9MSwhYy5pc1N0cmluZyh0LmRpbVBhcmFtKSlyZXR1cm5cImRpbVBhcmFtOiBzdHJpbmcgZXhwZWN0ZWRcIn1yZXR1cm4gbnVsbCE9dC5kZW5vdGF0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmIWMuaXNTdHJpbmcodC5kZW5vdGF0aW9uKT9cImRlbm90YXRpb246IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb247cmV0dXJuIG51bGwhPXQuZGltVmFsdWUmJihjLkxvbmc/KGUuZGltVmFsdWU9Yy5Mb25nLmZyb21WYWx1ZSh0LmRpbVZhbHVlKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQuZGltVmFsdWU/ZS5kaW1WYWx1ZT1wYXJzZUludCh0LmRpbVZhbHVlLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5kaW1WYWx1ZT9lLmRpbVZhbHVlPXQuZGltVmFsdWU6XCJvYmplY3RcIj09dHlwZW9mIHQuZGltVmFsdWUmJihlLmRpbVZhbHVlPW5ldyBjLkxvbmdCaXRzKHQuZGltVmFsdWUubG93Pj4+MCx0LmRpbVZhbHVlLmhpZ2g+Pj4wKS50b051bWJlcigpKSksbnVsbCE9dC5kaW1QYXJhbSYmKGUuZGltUGFyYW09U3RyaW5nKHQuZGltUGFyYW0pKSxudWxsIT10LmRlbm90YXRpb24mJihlLmRlbm90YXRpb249U3RyaW5nKHQuZGVub3RhdGlvbikpLGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307cmV0dXJuIGUuZGVmYXVsdHMmJihuLmRlbm90YXRpb249XCJcIiksbnVsbCE9dC5kaW1WYWx1ZSYmdC5oYXNPd25Qcm9wZXJ0eShcImRpbVZhbHVlXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIHQuZGltVmFsdWU/bi5kaW1WYWx1ZT1lLmxvbmdzPT09U3RyaW5nP1N0cmluZyh0LmRpbVZhbHVlKTp0LmRpbVZhbHVlOm4uZGltVmFsdWU9ZS5sb25ncz09PVN0cmluZz9jLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC5kaW1WYWx1ZSk6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LmRpbVZhbHVlLmxvdz4+PjAsdC5kaW1WYWx1ZS5oaWdoPj4+MCkudG9OdW1iZXIoKTp0LmRpbVZhbHVlLGUub25lb2ZzJiYobi52YWx1ZT1cImRpbVZhbHVlXCIpKSxudWxsIT10LmRpbVBhcmFtJiZ0Lmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikmJihuLmRpbVBhcmFtPXQuZGltUGFyYW0sZS5vbmVvZnMmJihuLnZhbHVlPVwiZGltUGFyYW1cIikpLG51bGwhPXQuZGVub3RhdGlvbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikmJihuLmRlbm90YXRpb249dC5kZW5vdGF0aW9uKSxufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sdH0oKSx0fSgpLG8uVHlwZVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9dmFyIGU7cmV0dXJuIHQucHJvdG90eXBlLnRlbnNvclR5cGU9bnVsbCx0LnByb3RvdHlwZS5kZW5vdGF0aW9uPVwiXCIsT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidmFsdWVcIix7Z2V0OmMub25lT2ZHZXR0ZXIoZT1bXCJ0ZW5zb3JUeXBlXCJdKSxzZXQ6Yy5vbmVPZlNldHRlcihlKX0pLHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC50ZW5zb3JUeXBlJiZ0Lmhhc093blByb3BlcnR5KFwidGVuc29yVHlwZVwiKSYmbC5vbm54LlR5cGVQcm90by5UZW5zb3IuZW5jb2RlKHQudGVuc29yVHlwZSxlLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKSxudWxsIT10LmRlbm90YXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpJiZlLnVpbnQzMig1MCkuc3RyaW5nKHQuZGVub3RhdGlvbiksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlR5cGVQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLnRlbnNvclR5cGU9bC5vbm54LlR5cGVQcm90by5UZW5zb3IuZGVjb2RlKHQsdC51aW50MzIoKSk7YnJlYWs7Y2FzZSA2OnIuZGVub3RhdGlvbj10LnN0cmluZygpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC50ZW5zb3JUeXBlJiZ0Lmhhc093blByb3BlcnR5KFwidGVuc29yVHlwZVwiKSl7dmFyIGU9bC5vbm54LlR5cGVQcm90by5UZW5zb3IudmVyaWZ5KHQudGVuc29yVHlwZSk7aWYoZSlyZXR1cm5cInRlbnNvclR5cGUuXCIrZX1yZXR1cm4gbnVsbCE9dC5kZW5vdGF0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmIWMuaXNTdHJpbmcodC5kZW5vdGF0aW9uKT9cImRlbm90YXRpb246IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlR5cGVQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LlR5cGVQcm90bztpZihudWxsIT10LnRlbnNvclR5cGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LnRlbnNvclR5cGUpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLnRlbnNvclR5cGU6IG9iamVjdCBleHBlY3RlZFwiKTtlLnRlbnNvclR5cGU9bC5vbm54LlR5cGVQcm90by5UZW5zb3IuZnJvbU9iamVjdCh0LnRlbnNvclR5cGUpfXJldHVybiBudWxsIT10LmRlbm90YXRpb24mJihlLmRlbm90YXRpb249U3RyaW5nKHQuZGVub3RhdGlvbikpLGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307cmV0dXJuIGUuZGVmYXVsdHMmJihuLmRlbm90YXRpb249XCJcIiksbnVsbCE9dC50ZW5zb3JUeXBlJiZ0Lmhhc093blByb3BlcnR5KFwidGVuc29yVHlwZVwiKSYmKG4udGVuc29yVHlwZT1sLm9ubnguVHlwZVByb3RvLlRlbnNvci50b09iamVjdCh0LnRlbnNvclR5cGUsZSksZS5vbmVvZnMmJihuLnZhbHVlPVwidGVuc29yVHlwZVwiKSksbnVsbCE9dC5kZW5vdGF0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmKG4uZGVub3RhdGlvbj10LmRlbm90YXRpb24pLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0LlRlbnNvcj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS5lbGVtVHlwZT0wLHQucHJvdG90eXBlLnNoYXBlPW51bGwsdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LmVsZW1UeXBlJiZ0Lmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikmJmUudWludDMyKDgpLmludDMyKHQuZWxlbVR5cGUpLG51bGwhPXQuc2hhcGUmJnQuaGFzT3duUHJvcGVydHkoXCJzaGFwZVwiKSYmbC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZW5jb2RlKHQuc2hhcGUsZS51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlR5cGVQcm90by5UZW5zb3I7dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5lbGVtVHlwZT10LmludDMyKCk7YnJlYWs7Y2FzZSAyOnIuc2hhcGU9bC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT10LmVsZW1UeXBlJiZ0Lmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikmJiFjLmlzSW50ZWdlcih0LmVsZW1UeXBlKSlyZXR1cm5cImVsZW1UeXBlOiBpbnRlZ2VyIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5zaGFwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInNoYXBlXCIpKXt2YXIgZT1sLm9ubnguVGVuc29yU2hhcGVQcm90by52ZXJpZnkodC5zaGFwZSk7aWYoZSlyZXR1cm5cInNoYXBlLlwiK2V9cmV0dXJuIG51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlR5cGVQcm90by5UZW5zb3IpcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5UeXBlUHJvdG8uVGVuc29yO2lmKG51bGwhPXQuZWxlbVR5cGUmJihlLmVsZW1UeXBlPTB8dC5lbGVtVHlwZSksbnVsbCE9dC5zaGFwZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQuc2hhcGUpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLlRlbnNvci5zaGFwZTogb2JqZWN0IGV4cGVjdGVkXCIpO2Uuc2hhcGU9bC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZnJvbU9iamVjdCh0LnNoYXBlKX1yZXR1cm4gZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtyZXR1cm4gZS5kZWZhdWx0cyYmKG4uZWxlbVR5cGU9MCxuLnNoYXBlPW51bGwpLG51bGwhPXQuZWxlbVR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSYmKG4uZWxlbVR5cGU9dC5lbGVtVHlwZSksbnVsbCE9dC5zaGFwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInNoYXBlXCIpJiYobi5zaGFwZT1sLm9ubnguVGVuc29yU2hhcGVQcm90by50b09iamVjdCh0LnNoYXBlLGUpKSxufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sdH0oKSx0fSgpLG8uT3BlcmF0b3JTZXRJZFByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLmRvbWFpbj1cIlwiLHQucHJvdG90eXBlLnZlcnNpb249Yy5Mb25nP2MuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LmRvbWFpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmZS51aW50MzIoMTApLnN0cmluZyh0LmRvbWFpbiksbnVsbCE9dC52ZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwidmVyc2lvblwiKSYmZS51aW50MzIoMTYpLmludDY0KHQudmVyc2lvbiksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLmRvbWFpbj10LnN0cmluZygpO2JyZWFrO2Nhc2UgMjpyLnZlcnNpb249dC5pbnQ2NCgpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7cmV0dXJuXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10P1wib2JqZWN0IGV4cGVjdGVkXCI6bnVsbCE9dC5kb21haW4mJnQuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJiFjLmlzU3RyaW5nKHQuZG9tYWluKT9cImRvbWFpbjogc3RyaW5nIGV4cGVjdGVkXCI6bnVsbCE9dC52ZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwidmVyc2lvblwiKSYmIShjLmlzSW50ZWdlcih0LnZlcnNpb24pfHx0LnZlcnNpb24mJmMuaXNJbnRlZ2VyKHQudmVyc2lvbi5sb3cpJiZjLmlzSW50ZWdlcih0LnZlcnNpb24uaGlnaCkpP1widmVyc2lvbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI6bnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvO3JldHVybiBudWxsIT10LmRvbWFpbiYmKGUuZG9tYWluPVN0cmluZyh0LmRvbWFpbikpLG51bGwhPXQudmVyc2lvbiYmKGMuTG9uZz8oZS52ZXJzaW9uPWMuTG9uZy5mcm9tVmFsdWUodC52ZXJzaW9uKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQudmVyc2lvbj9lLnZlcnNpb249cGFyc2VJbnQodC52ZXJzaW9uLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC52ZXJzaW9uP2UudmVyc2lvbj10LnZlcnNpb246XCJvYmplY3RcIj09dHlwZW9mIHQudmVyc2lvbiYmKGUudmVyc2lvbj1uZXcgYy5Mb25nQml0cyh0LnZlcnNpb24ubG93Pj4+MCx0LnZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCkpKSxlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKGUuZGVmYXVsdHMpaWYobi5kb21haW49XCJcIixjLkxvbmcpe3ZhciByPW5ldyBjLkxvbmcoMCwwLCExKTtuLnZlcnNpb249ZS5sb25ncz09PVN0cmluZz9yLnRvU3RyaW5nKCk6ZS5sb25ncz09PU51bWJlcj9yLnRvTnVtYmVyKCk6cn1lbHNlIG4udmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjA7cmV0dXJuIG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYobi5kb21haW49dC5kb21haW4pLG51bGwhPXQudmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcInZlcnNpb25cIikmJihcIm51bWJlclwiPT10eXBlb2YgdC52ZXJzaW9uP24udmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP1N0cmluZyh0LnZlcnNpb24pOnQudmVyc2lvbjpuLnZlcnNpb249ZS5sb25ncz09PVN0cmluZz9jLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC52ZXJzaW9uKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQudmVyc2lvbi5sb3c+Pj4wLHQudmVyc2lvbi5oaWdoPj4+MCkudG9OdW1iZXIoKTp0LnZlcnNpb24pLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLG8pLHQuZXhwb3J0cz1sfSwyMTAwOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9big5NDgyKX0sOTQ4MjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9ZTtmdW5jdGlvbiBpKCl7ci51dGlsLl9jb25maWd1cmUoKSxyLldyaXRlci5fY29uZmlndXJlKHIuQnVmZmVyV3JpdGVyKSxyLlJlYWRlci5fY29uZmlndXJlKHIuQnVmZmVyUmVhZGVyKX1yLmJ1aWxkPVwibWluaW1hbFwiLHIuV3JpdGVyPW4oMTE3Myksci5CdWZmZXJXcml0ZXI9bigzMTU1KSxyLlJlYWRlcj1uKDE0MDgpLHIuQnVmZmVyUmVhZGVyPW4oNTkzKSxyLnV0aWw9big5NjkzKSxyLnJwYz1uKDU5OTQpLHIucm9vdHM9big1MDU0KSxyLmNvbmZpZ3VyZT1pLGkoKX0sMTQwODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXU7dmFyIHIsaT1uKDk2OTMpLG89aS5Mb25nQml0cyxhPWkudXRmODtmdW5jdGlvbiBzKHQsZSl7cmV0dXJuIFJhbmdlRXJyb3IoXCJpbmRleCBvdXQgb2YgcmFuZ2U6IFwiK3QucG9zK1wiICsgXCIrKGV8fDEpK1wiID4gXCIrdC5sZW4pfWZ1bmN0aW9uIHUodCl7dGhpcy5idWY9dCx0aGlzLnBvcz0wLHRoaXMubGVuPXQubGVuZ3RofXZhciBjLGw9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4QXJyYXk/ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIG5ldyB1KHQpO3Rocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIil9OmZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIG5ldyB1KHQpO3Rocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIil9LHA9ZnVuY3Rpb24oKXtyZXR1cm4gaS5CdWZmZXI/ZnVuY3Rpb24odCl7cmV0dXJuKHUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBpLkJ1ZmZlci5pc0J1ZmZlcih0KT9uZXcgcih0KTpsKHQpfSkodCl9Omx9O2Z1bmN0aW9uIGYoKXt2YXIgdD1uZXcgbygwLDApLGU9MDtpZighKHRoaXMubGVuLXRoaXMucG9zPjQpKXtmb3IoO2U8MzsrK2Upe2lmKHRoaXMucG9zPj10aGlzLmxlbil0aHJvdyBzKHRoaXMpO2lmKHQubG89KHQubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KmUpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIHR9cmV0dXJuIHQubG89KHQubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvcysrXSk8PDcqZSk+Pj4wLHR9Zm9yKDtlPDQ7KytlKWlmKHQubG89KHQubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KmUpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIHQ7aWYodC5sbz0odC5sb3woMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDI4KT4+PjAsdC5oaT0odC5oaXwoMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk+PjQpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIHQ7aWYoZT0wLHRoaXMubGVuLXRoaXMucG9zPjQpe2Zvcig7ZTw1OysrZSlpZih0LmhpPSh0LmhpfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8NyplKzMpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIHR9ZWxzZSBmb3IoO2U8NTsrK2Upe2lmKHRoaXMucG9zPj10aGlzLmxlbil0aHJvdyBzKHRoaXMpO2lmKHQuaGk9KHQuaGl8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KmUrMyk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gdH10aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpfWZ1bmN0aW9uIGQodCxlKXtyZXR1cm4odFtlLTRdfHRbZS0zXTw8OHx0W2UtMl08PDE2fHRbZS0xXTw8MjQpPj4+MH1mdW5jdGlvbiBoKCl7aWYodGhpcy5wb3MrOD50aGlzLmxlbil0aHJvdyBzKHRoaXMsOCk7cmV0dXJuIG5ldyBvKGQodGhpcy5idWYsdGhpcy5wb3MrPTQpLGQodGhpcy5idWYsdGhpcy5wb3MrPTQpKX11LmNyZWF0ZT1wKCksdS5wcm90b3R5cGUuX3NsaWNlPWkuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5fHxpLkFycmF5LnByb3RvdHlwZS5zbGljZSx1LnByb3RvdHlwZS51aW50MzI9KGM9NDI5NDk2NzI5NSxmdW5jdGlvbigpe2lmKGM9KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGM7aWYoYz0oY3woMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDcpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGM7aWYoYz0oY3woMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDE0KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBjO2lmKGM9KGN8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDwyMSk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gYztpZihjPShjfCgxNSZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDwyOCk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gYztpZigodGhpcy5wb3MrPTUpPnRoaXMubGVuKXRocm93IHRoaXMucG9zPXRoaXMubGVuLHModGhpcywxMCk7cmV0dXJuIGN9KSx1LnByb3RvdHlwZS5pbnQzMj1mdW5jdGlvbigpe3JldHVybiAwfHRoaXMudWludDMyKCl9LHUucHJvdG90eXBlLnNpbnQzMj1mdW5jdGlvbigpe3ZhciB0PXRoaXMudWludDMyKCk7cmV0dXJuIHQ+Pj4xXi0oMSZ0KXwwfSx1LnByb3RvdHlwZS5ib29sPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPT10aGlzLnVpbnQzMigpfSx1LnByb3RvdHlwZS5maXhlZDMyPWZ1bmN0aW9uKCl7aWYodGhpcy5wb3MrND50aGlzLmxlbil0aHJvdyBzKHRoaXMsNCk7cmV0dXJuIGQodGhpcy5idWYsdGhpcy5wb3MrPTQpfSx1LnByb3RvdHlwZS5zZml4ZWQzMj1mdW5jdGlvbigpe2lmKHRoaXMucG9zKzQ+dGhpcy5sZW4pdGhyb3cgcyh0aGlzLDQpO3JldHVybiAwfGQodGhpcy5idWYsdGhpcy5wb3MrPTQpfSx1LnByb3RvdHlwZS5mbG9hdD1mdW5jdGlvbigpe2lmKHRoaXMucG9zKzQ+dGhpcy5sZW4pdGhyb3cgcyh0aGlzLDQpO3ZhciB0PWkuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsdGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9NCx0fSx1LnByb3RvdHlwZS5kb3VibGU9ZnVuY3Rpb24oKXtpZih0aGlzLnBvcys4PnRoaXMubGVuKXRocm93IHModGhpcyw0KTt2YXIgdD1pLmZsb2F0LnJlYWREb3VibGVMRSh0aGlzLmJ1Zix0aGlzLnBvcyk7cmV0dXJuIHRoaXMucG9zKz04LHR9LHUucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy51aW50MzIoKSxlPXRoaXMucG9zLG49dGhpcy5wb3MrdDtpZihuPnRoaXMubGVuKXRocm93IHModGhpcyx0KTtyZXR1cm4gdGhpcy5wb3MrPXQsQXJyYXkuaXNBcnJheSh0aGlzLmJ1Zik/dGhpcy5idWYuc2xpY2UoZSxuKTplPT09bj9uZXcgdGhpcy5idWYuY29uc3RydWN0b3IoMCk6dGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1ZixlLG4pfSx1LnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmJ5dGVzKCk7cmV0dXJuIGEucmVhZCh0LDAsdC5sZW5ndGgpfSx1LnByb3RvdHlwZS5za2lwPWZ1bmN0aW9uKHQpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXtpZih0aGlzLnBvcyt0PnRoaXMubGVuKXRocm93IHModGhpcyx0KTt0aGlzLnBvcys9dH1lbHNlIGRve2lmKHRoaXMucG9zPj10aGlzLmxlbil0aHJvdyBzKHRoaXMpfXdoaWxlKDEyOCZ0aGlzLmJ1Zlt0aGlzLnBvcysrXSk7cmV0dXJuIHRoaXN9LHUucHJvdG90eXBlLnNraXBUeXBlPWZ1bmN0aW9uKHQpe3N3aXRjaCh0KXtjYXNlIDA6dGhpcy5za2lwKCk7YnJlYWs7Y2FzZSAxOnRoaXMuc2tpcCg4KTticmVhaztjYXNlIDI6dGhpcy5za2lwKHRoaXMudWludDMyKCkpO2JyZWFrO2Nhc2UgMzpmb3IoOzQhPSh0PTcmdGhpcy51aW50MzIoKSk7KXRoaXMuc2tpcFR5cGUodCk7YnJlYWs7Y2FzZSA1OnRoaXMuc2tpcCg0KTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIrdCtcIiBhdCBvZmZzZXQgXCIrdGhpcy5wb3MpfXJldHVybiB0aGlzfSx1Ll9jb25maWd1cmU9ZnVuY3Rpb24odCl7cj10LHUuY3JlYXRlPXAoKSxyLl9jb25maWd1cmUoKTt2YXIgZT1pLkxvbmc/XCJ0b0xvbmdcIjpcInRvTnVtYmVyXCI7aS5tZXJnZSh1LnByb3RvdHlwZSx7aW50NjQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5jYWxsKHRoaXMpW2VdKCExKX0sdWludDY0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuY2FsbCh0aGlzKVtlXSghMCl9LHNpbnQ2NDpmdW5jdGlvbigpe3JldHVybiBmLmNhbGwodGhpcykuenpEZWNvZGUoKVtlXSghMSl9LGZpeGVkNjQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5jYWxsKHRoaXMpW2VdKCEwKX0sc2ZpeGVkNjQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5jYWxsKHRoaXMpW2VdKCExKX19KX19LDU5MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPW87dmFyIHI9bigxNDA4KTsoby5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPW87dmFyIGk9big5NjkzKTtmdW5jdGlvbiBvKHQpe3IuY2FsbCh0aGlzLHQpfW8uX2NvbmZpZ3VyZT1mdW5jdGlvbigpe2kuQnVmZmVyJiYoby5wcm90b3R5cGUuX3NsaWNlPWkuQnVmZmVyLnByb3RvdHlwZS5zbGljZSl9LG8ucHJvdG90eXBlLnN0cmluZz1mdW5jdGlvbigpe3ZhciB0PXRoaXMudWludDMyKCk7cmV0dXJuIHRoaXMuYnVmLnV0ZjhTbGljZT90aGlzLmJ1Zi51dGY4U2xpY2UodGhpcy5wb3MsdGhpcy5wb3M9TWF0aC5taW4odGhpcy5wb3MrdCx0aGlzLmxlbikpOnRoaXMuYnVmLnRvU3RyaW5nKFwidXRmLThcIix0aGlzLnBvcyx0aGlzLnBvcz1NYXRoLm1pbih0aGlzLnBvcyt0LHRoaXMubGVuKSl9LG8uX2NvbmZpZ3VyZSgpfSw1MDU0OnQ9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9e319LDU5OTQ6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO2UuU2VydmljZT1uKDc5NDgpfSw3OTQ4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9aTt2YXIgcj1uKDk2OTMpO2Z1bmN0aW9uIGkodCxlLG4pe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7ci5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSx0aGlzLnJwY0ltcGw9dCx0aGlzLnJlcXVlc3REZWxpbWl0ZWQ9Qm9vbGVhbihlKSx0aGlzLnJlc3BvbnNlRGVsaW1pdGVkPUJvb2xlYW4obil9KGkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3I9aSxpLnByb3RvdHlwZS5ycGNDYWxsPWZ1bmN0aW9uIHQoZSxuLGksbyxhKXtpZighbyl0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0IG11c3QgYmUgc3BlY2lmaWVkXCIpO3ZhciBzPXRoaXM7aWYoIWEpcmV0dXJuIHIuYXNQcm9taXNlKHQscyxlLG4saSxvKTtpZihzLnJwY0ltcGwpdHJ5e3JldHVybiBzLnJwY0ltcGwoZSxuW3MucmVxdWVzdERlbGltaXRlZD9cImVuY29kZURlbGltaXRlZFwiOlwiZW5jb2RlXCJdKG8pLmZpbmlzaCgpLChmdW5jdGlvbih0LG4pe2lmKHQpcmV0dXJuIHMuZW1pdChcImVycm9yXCIsdCxlKSxhKHQpO2lmKG51bGwhPT1uKXtpZighKG4gaW5zdGFuY2VvZiBpKSl0cnl7bj1pW3MucmVzcG9uc2VEZWxpbWl0ZWQ/XCJkZWNvZGVEZWxpbWl0ZWRcIjpcImRlY29kZVwiXShuKX1jYXRjaCh0KXtyZXR1cm4gcy5lbWl0KFwiZXJyb3JcIix0LGUpLGEodCl9cmV0dXJuIHMuZW1pdChcImRhdGFcIixuLGUpLGEobnVsbCxuKX1zLmVuZCghMCl9KSl9Y2F0Y2godCl7cmV0dXJuIHMuZW1pdChcImVycm9yXCIsdCxlKSx2b2lkIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7YSh0KX0pLDApfWVsc2Ugc2V0VGltZW91dCgoZnVuY3Rpb24oKXthKEVycm9yKFwiYWxyZWFkeSBlbmRlZFwiKSl9KSwwKX0saS5wcm90b3R5cGUuZW5kPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnJwY0ltcGwmJih0fHx0aGlzLnJwY0ltcGwobnVsbCxudWxsLG51bGwpLHRoaXMucnBjSW1wbD1udWxsLHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKSksdGhpc319LDE5NDU6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1pO3ZhciByPW4oOTY5Myk7ZnVuY3Rpb24gaSh0LGUpe3RoaXMubG89dD4+PjAsdGhpcy5oaT1lPj4+MH12YXIgbz1pLnplcm89bmV3IGkoMCwwKTtvLnRvTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuIDB9LG8uenpFbmNvZGU9by56ekRlY29kZT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxvLmxlbmd0aD1mdW5jdGlvbigpe3JldHVybiAxfTt2YXIgYT1pLnplcm9IYXNoPVwiXFwwXFwwXFwwXFwwXFwwXFwwXFwwXFwwXCI7aS5mcm9tTnVtYmVyPWZ1bmN0aW9uKHQpe2lmKDA9PT10KXJldHVybiBvO3ZhciBlPXQ8MDtlJiYodD0tdCk7dmFyIG49dD4+PjAscj0odC1uKS80Mjk0OTY3Mjk2Pj4+MDtyZXR1cm4gZSYmKHI9fnI+Pj4wLG49fm4+Pj4wLCsrbj40Mjk0OTY3Mjk1JiYobj0wLCsrcj40Mjk0OTY3Mjk1JiYocj0wKSkpLG5ldyBpKG4scil9LGkuZnJvbT1mdW5jdGlvbih0KXtpZihcIm51bWJlclwiPT10eXBlb2YgdClyZXR1cm4gaS5mcm9tTnVtYmVyKHQpO2lmKHIuaXNTdHJpbmcodCkpe2lmKCFyLkxvbmcpcmV0dXJuIGkuZnJvbU51bWJlcihwYXJzZUludCh0LDEwKSk7dD1yLkxvbmcuZnJvbVN0cmluZyh0KX1yZXR1cm4gdC5sb3d8fHQuaGlnaD9uZXcgaSh0Lmxvdz4+PjAsdC5oaWdoPj4+MCk6b30saS5wcm90b3R5cGUudG9OdW1iZXI9ZnVuY3Rpb24odCl7aWYoIXQmJnRoaXMuaGk+Pj4zMSl7dmFyIGU9MSt+dGhpcy5sbz4+PjAsbj1+dGhpcy5oaT4+PjA7cmV0dXJuIGV8fChuPW4rMT4+PjApLC0oZSs0Mjk0OTY3Mjk2Km4pfXJldHVybiB0aGlzLmxvKzQyOTQ5NjcyOTYqdGhpcy5oaX0saS5wcm90b3R5cGUudG9Mb25nPWZ1bmN0aW9uKHQpe3JldHVybiByLkxvbmc/bmV3IHIuTG9uZygwfHRoaXMubG8sMHx0aGlzLmhpLEJvb2xlYW4odCkpOntsb3c6MHx0aGlzLmxvLGhpZ2g6MHx0aGlzLmhpLHVuc2lnbmVkOkJvb2xlYW4odCl9fTt2YXIgcz1TdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQ7aS5mcm9tSGFzaD1mdW5jdGlvbih0KXtyZXR1cm4gdD09PWE/bzpuZXcgaSgocy5jYWxsKHQsMCl8cy5jYWxsKHQsMSk8PDh8cy5jYWxsKHQsMik8PDE2fHMuY2FsbCh0LDMpPDwyNCk+Pj4wLChzLmNhbGwodCw0KXxzLmNhbGwodCw1KTw8OHxzLmNhbGwodCw2KTw8MTZ8cy5jYWxsKHQsNyk8PDI0KT4+PjApfSxpLnByb3RvdHlwZS50b0hhc2g9ZnVuY3Rpb24oKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUmdGhpcy5sbyx0aGlzLmxvPj4+OCYyNTUsdGhpcy5sbz4+PjE2JjI1NSx0aGlzLmxvPj4+MjQsMjU1JnRoaXMuaGksdGhpcy5oaT4+PjgmMjU1LHRoaXMuaGk+Pj4xNiYyNTUsdGhpcy5oaT4+PjI0KX0saS5wcm90b3R5cGUuenpFbmNvZGU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhpPj4zMTtyZXR1cm4gdGhpcy5oaT0oKHRoaXMuaGk8PDF8dGhpcy5sbz4+PjMxKV50KT4+PjAsdGhpcy5sbz0odGhpcy5sbzw8MV50KT4+PjAsdGhpc30saS5wcm90b3R5cGUuenpEZWNvZGU9ZnVuY3Rpb24oKXt2YXIgdD0tKDEmdGhpcy5sbyk7cmV0dXJuIHRoaXMubG89KCh0aGlzLmxvPj4+MXx0aGlzLmhpPDwzMSledCk+Pj4wLHRoaXMuaGk9KHRoaXMuaGk+Pj4xXnQpPj4+MCx0aGlzfSxpLnByb3RvdHlwZS5sZW5ndGg9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxvLGU9KHRoaXMubG8+Pj4yOHx0aGlzLmhpPDw0KT4+PjAsbj10aGlzLmhpPj4+MjQ7cmV0dXJuIDA9PT1uPzA9PT1lP3Q8MTYzODQ/dDwxMjg/MToyOnQ8MjA5NzE1Mj8zOjQ6ZTwxNjM4ND9lPDEyOD81OjY6ZTwyMDk3MTUyPzc6ODpuPDEyOD85OjEwfX0sOTY5MzpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9ZTtmdW5jdGlvbiBpKHQsZSxuKXtmb3IodmFyIHI9T2JqZWN0LmtleXMoZSksaT0wO2k8ci5sZW5ndGg7KytpKXZvaWQgMCE9PXRbcltpXV0mJm58fCh0W3JbaV1dPWVbcltpXV0pO3JldHVybiB0fWZ1bmN0aW9uIG8odCl7ZnVuY3Rpb24gZSh0LG4pe2lmKCEodGhpcyBpbnN0YW5jZW9mIGUpKXJldHVybiBuZXcgZSh0LG4pO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwibWVzc2FnZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdH19KSxFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT9FcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLGUpOk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwic3RhY2tcIix7dmFsdWU6KG5ldyBFcnJvcikuc3RhY2t8fFwiXCJ9KSxuJiZpKHRoaXMsbil9cmV0dXJuKGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSkuY29uc3RydWN0b3I9ZSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJuYW1lXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0fX0pLGUucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZStcIjogXCIrdGhpcy5tZXNzYWdlfSxlfXIuYXNQcm9taXNlPW4oNDUzNyksci5iYXNlNjQ9big3NDE5KSxyLkV2ZW50RW1pdHRlcj1uKDkyMTEpLHIuZmxvYXQ9big5NDUpLHIuaW5xdWlyZT1uKDcxOTkpLHIudXRmOD1uKDQ5OTcpLHIucG9vbD1uKDY2NjIpLHIuTG9uZ0JpdHM9bigxOTQ1KSxyLmlzTm9kZT1Cb29sZWFuKHZvaWQgMCE9PW4uZyYmbi5nJiZuLmcucHJvY2VzcyYmbi5nLnByb2Nlc3MudmVyc2lvbnMmJm4uZy5wcm9jZXNzLnZlcnNpb25zLm5vZGUpLHIuZ2xvYmFsPXIuaXNOb2RlJiZuLmd8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvd3x8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGZ8fHRoaXMsci5lbXB0eUFycmF5PU9iamVjdC5mcmVlemU/T2JqZWN0LmZyZWV6ZShbXSk6W10sci5lbXB0eU9iamVjdD1PYmplY3QuZnJlZXplP09iamVjdC5mcmVlemUoe30pOnt9LHIuaXNJbnRlZ2VyPU51bWJlci5pc0ludGVnZXJ8fGZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiZpc0Zpbml0ZSh0KSYmTWF0aC5mbG9vcih0KT09PXR9LHIuaXNTdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR8fHQgaW5zdGFuY2VvZiBTdHJpbmd9LHIuaXNPYmplY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwib2JqZWN0XCI9PXR5cGVvZiB0fSxyLmlzc2V0PXIuaXNTZXQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10W2VdO3JldHVybiEobnVsbD09bnx8IXQuaGFzT3duUHJvcGVydHkoZSkpJiYoXCJvYmplY3RcIiE9dHlwZW9mIG58fChBcnJheS5pc0FycmF5KG4pP24ubGVuZ3RoOk9iamVjdC5rZXlzKG4pLmxlbmd0aCk+MCl9LHIuQnVmZmVyPWZ1bmN0aW9uKCl7dHJ5e3ZhciB0PXIuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7cmV0dXJuIHQucHJvdG90eXBlLnV0ZjhXcml0ZT90Om51bGx9Y2F0Y2godCl7cmV0dXJuIG51bGx9fSgpLHIuX0J1ZmZlcl9mcm9tPW51bGwsci5fQnVmZmVyX2FsbG9jVW5zYWZlPW51bGwsci5uZXdCdWZmZXI9ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/ci5CdWZmZXI/ci5fQnVmZmVyX2FsbG9jVW5zYWZlKHQpOm5ldyByLkFycmF5KHQpOnIuQnVmZmVyP3IuX0J1ZmZlcl9mcm9tKHQpOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBVaW50OEFycmF5P3Q6bmV3IFVpbnQ4QXJyYXkodCl9LHIuQXJyYXk9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4QXJyYXk/VWludDhBcnJheTpBcnJheSxyLkxvbmc9ci5nbG9iYWwuZGNvZGVJTyYmci5nbG9iYWwuZGNvZGVJTy5Mb25nfHxyLmdsb2JhbC5Mb25nfHxyLmlucXVpcmUoXCJsb25nXCIpLHIua2V5MlJlPS9edHJ1ZXxmYWxzZXwwfDEkLyxyLmtleTMyUmU9L14tPyg/OjB8WzEtOV1bMC05XSopJC8sci5rZXk2NFJlPS9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLyxyLmxvbmdUb0hhc2g9ZnVuY3Rpb24odCl7cmV0dXJuIHQ/ci5Mb25nQml0cy5mcm9tKHQpLnRvSGFzaCgpOnIuTG9uZ0JpdHMuemVyb0hhc2h9LHIubG9uZ0Zyb21IYXNoPWZ1bmN0aW9uKHQsZSl7dmFyIG49ci5Mb25nQml0cy5mcm9tSGFzaCh0KTtyZXR1cm4gci5Mb25nP3IuTG9uZy5mcm9tQml0cyhuLmxvLG4uaGksZSk6bi50b051bWJlcihCb29sZWFuKGUpKX0sci5tZXJnZT1pLHIubGNGaXJzdD1mdW5jdGlvbih0KXtyZXR1cm4gdC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSt0LnN1YnN0cmluZygxKX0sci5uZXdFcnJvcj1vLHIuUHJvdG9jb2xFcnJvcj1vKFwiUHJvdG9jb2xFcnJvclwiKSxyLm9uZU9mR2V0dGVyPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT17fSxuPTA7bjx0Lmxlbmd0aDsrK24pZVt0W25dXT0xO3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgdD1PYmplY3Qua2V5cyh0aGlzKSxuPXQubGVuZ3RoLTE7bj4tMTstLW4paWYoMT09PWVbdFtuXV0mJnZvaWQgMCE9PXRoaXNbdFtuXV0mJm51bGwhPT10aGlzW3Rbbl1dKXJldHVybiB0W25dfX0sci5vbmVPZlNldHRlcj1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDsrK24pdFtuXSE9PWUmJmRlbGV0ZSB0aGlzW3Rbbl1dfX0sci50b0pTT05PcHRpb25zPXtsb25nczpTdHJpbmcsZW51bXM6U3RyaW5nLGJ5dGVzOlN0cmluZyxqc29uOiEwfSxyLl9jb25maWd1cmU9ZnVuY3Rpb24oKXt2YXIgdD1yLkJ1ZmZlcjt0PyhyLl9CdWZmZXJfZnJvbT10LmZyb20hPT1VaW50OEFycmF5LmZyb20mJnQuZnJvbXx8ZnVuY3Rpb24oZSxuKXtyZXR1cm4gbmV3IHQoZSxuKX0sci5fQnVmZmVyX2FsbG9jVW5zYWZlPXQuYWxsb2NVbnNhZmV8fGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0pOnIuX0J1ZmZlcl9mcm9tPXIuX0J1ZmZlcl9hbGxvY1Vuc2FmZT1udWxsfX0sMTE3MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXA7dmFyIHIsaT1uKDk2OTMpLG89aS5Mb25nQml0cyxhPWkuYmFzZTY0LHM9aS51dGY4O2Z1bmN0aW9uIHUodCxlLG4pe3RoaXMuZm49dCx0aGlzLmxlbj1lLHRoaXMubmV4dD12b2lkIDAsdGhpcy52YWw9bn1mdW5jdGlvbiBjKCl7fWZ1bmN0aW9uIGwodCl7dGhpcy5oZWFkPXQuaGVhZCx0aGlzLnRhaWw9dC50YWlsLHRoaXMubGVuPXQubGVuLHRoaXMubmV4dD10LnN0YXRlc31mdW5jdGlvbiBwKCl7dGhpcy5sZW49MCx0aGlzLmhlYWQ9bmV3IHUoYywwLDApLHRoaXMudGFpbD10aGlzLmhlYWQsdGhpcy5zdGF0ZXM9bnVsbH12YXIgZj1mdW5jdGlvbigpe3JldHVybiBpLkJ1ZmZlcj9mdW5jdGlvbigpe3JldHVybihwLmNyZWF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgcn0pKCl9OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBwfX07ZnVuY3Rpb24gZCh0LGUsbil7ZVtuXT0yNTUmdH1mdW5jdGlvbiBoKHQsZSl7dGhpcy5sZW49dCx0aGlzLm5leHQ9dm9pZCAwLHRoaXMudmFsPWV9ZnVuY3Rpb24gZyh0LGUsbil7Zm9yKDt0LmhpOyllW24rK109MTI3JnQubG98MTI4LHQubG89KHQubG8+Pj43fHQuaGk8PDI1KT4+PjAsdC5oaT4+Pj03O2Zvcig7dC5sbz4xMjc7KWVbbisrXT0xMjcmdC5sb3wxMjgsdC5sbz10LmxvPj4+NztlW24rK109dC5sb31mdW5jdGlvbiBiKHQsZSxuKXtlW25dPTI1NSZ0LGVbbisxXT10Pj4+OCYyNTUsZVtuKzJdPXQ+Pj4xNiYyNTUsZVtuKzNdPXQ+Pj4yNH1wLmNyZWF0ZT1mKCkscC5hbGxvYz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGkuQXJyYXkodCl9LGkuQXJyYXkhPT1BcnJheSYmKHAuYWxsb2M9aS5wb29sKHAuYWxsb2MsaS5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpKSxwLnByb3RvdHlwZS5fcHVzaD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMudGFpbD10aGlzLnRhaWwubmV4dD1uZXcgdSh0LGUsbiksdGhpcy5sZW4rPWUsdGhpc30saC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh1LnByb3RvdHlwZSksaC5wcm90b3R5cGUuZm49ZnVuY3Rpb24odCxlLG4pe2Zvcig7dD4xMjc7KWVbbisrXT0xMjcmdHwxMjgsdD4+Pj03O2Vbbl09dH0scC5wcm90b3R5cGUudWludDMyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxlbis9KHRoaXMudGFpbD10aGlzLnRhaWwubmV4dD1uZXcgaCgodD4+Pj0wKTwxMjg/MTp0PDE2Mzg0PzI6dDwyMDk3MTUyPzM6dDwyNjg0MzU0NTY/NDo1LHQpKS5sZW4sdGhpc30scC5wcm90b3R5cGUuaW50MzI9ZnVuY3Rpb24odCl7cmV0dXJuIHQ8MD90aGlzLl9wdXNoKGcsMTAsby5mcm9tTnVtYmVyKHQpKTp0aGlzLnVpbnQzMih0KX0scC5wcm90b3R5cGUuc2ludDMyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnVpbnQzMigodDw8MV50Pj4zMSk+Pj4wKX0scC5wcm90b3R5cGUudWludDY0PWZ1bmN0aW9uKHQpe3ZhciBlPW8uZnJvbSh0KTtyZXR1cm4gdGhpcy5fcHVzaChnLGUubGVuZ3RoKCksZSl9LHAucHJvdG90eXBlLmludDY0PXAucHJvdG90eXBlLnVpbnQ2NCxwLnByb3RvdHlwZS5zaW50NjQ9ZnVuY3Rpb24odCl7dmFyIGU9by5mcm9tKHQpLnp6RW5jb2RlKCk7cmV0dXJuIHRoaXMuX3B1c2goZyxlLmxlbmd0aCgpLGUpfSxwLnByb3RvdHlwZS5ib29sPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wdXNoKGQsMSx0PzE6MCl9LHAucHJvdG90eXBlLmZpeGVkMzI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3B1c2goYiw0LHQ+Pj4wKX0scC5wcm90b3R5cGUuc2ZpeGVkMzI9cC5wcm90b3R5cGUuZml4ZWQzMixwLnByb3RvdHlwZS5maXhlZDY0PWZ1bmN0aW9uKHQpe3ZhciBlPW8uZnJvbSh0KTtyZXR1cm4gdGhpcy5fcHVzaChiLDQsZS5sbykuX3B1c2goYiw0LGUuaGkpfSxwLnByb3RvdHlwZS5zZml4ZWQ2ND1wLnByb3RvdHlwZS5maXhlZDY0LHAucHJvdG90eXBlLmZsb2F0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wdXNoKGkuZmxvYXQud3JpdGVGbG9hdExFLDQsdCl9LHAucHJvdG90eXBlLmRvdWJsZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcHVzaChpLmZsb2F0LndyaXRlRG91YmxlTEUsOCx0KX07dmFyIG09aS5BcnJheS5wcm90b3R5cGUuc2V0P2Z1bmN0aW9uKHQsZSxuKXtlLnNldCh0LG4pfTpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDsrK3IpZVtuK3JdPXRbcl19O3AucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKHQpe3ZhciBlPXQubGVuZ3RoPj4+MDtpZighZSlyZXR1cm4gdGhpcy5fcHVzaChkLDEsMCk7aWYoaS5pc1N0cmluZyh0KSl7dmFyIG49cC5hbGxvYyhlPWEubGVuZ3RoKHQpKTthLmRlY29kZSh0LG4sMCksdD1ufXJldHVybiB0aGlzLnVpbnQzMihlKS5fcHVzaChtLGUsdCl9LHAucHJvdG90eXBlLnN0cmluZz1mdW5jdGlvbih0KXt2YXIgZT1zLmxlbmd0aCh0KTtyZXR1cm4gZT90aGlzLnVpbnQzMihlKS5fcHVzaChzLndyaXRlLGUsdCk6dGhpcy5fcHVzaChkLDEsMCl9LHAucHJvdG90eXBlLmZvcms9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZXM9bmV3IGwodGhpcyksdGhpcy5oZWFkPXRoaXMudGFpbD1uZXcgdShjLDAsMCksdGhpcy5sZW49MCx0aGlzfSxwLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlcz8odGhpcy5oZWFkPXRoaXMuc3RhdGVzLmhlYWQsdGhpcy50YWlsPXRoaXMuc3RhdGVzLnRhaWwsdGhpcy5sZW49dGhpcy5zdGF0ZXMubGVuLHRoaXMuc3RhdGVzPXRoaXMuc3RhdGVzLm5leHQpOih0aGlzLmhlYWQ9dGhpcy50YWlsPW5ldyB1KGMsMCwwKSx0aGlzLmxlbj0wKSx0aGlzfSxwLnByb3RvdHlwZS5sZGVsaW09ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhlYWQsZT10aGlzLnRhaWwsbj10aGlzLmxlbjtyZXR1cm4gdGhpcy5yZXNldCgpLnVpbnQzMihuKSxuJiYodGhpcy50YWlsLm5leHQ9dC5uZXh0LHRoaXMudGFpbD1lLHRoaXMubGVuKz1uKSx0aGlzfSxwLnByb3RvdHlwZS5maW5pc2g9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5oZWFkLm5leHQsZT10aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSxuPTA7dDspdC5mbih0LnZhbCxlLG4pLG4rPXQubGVuLHQ9dC5uZXh0O3JldHVybiBlfSxwLl9jb25maWd1cmU9ZnVuY3Rpb24odCl7cj10LHAuY3JlYXRlPWYoKSxyLl9jb25maWd1cmUoKX19LDMxNTU6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1vO3ZhciByPW4oMTE3Myk7KG8ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1vO3ZhciBpPW4oOTY5Myk7ZnVuY3Rpb24gbygpe3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBhKHQsZSxuKXt0Lmxlbmd0aDw0MD9pLnV0Zjgud3JpdGUodCxlLG4pOmUudXRmOFdyaXRlP2UudXRmOFdyaXRlKHQsbik6ZS53cml0ZSh0LG4pfW8uX2NvbmZpZ3VyZT1mdW5jdGlvbigpe28uYWxsb2M9aS5fQnVmZmVyX2FsbG9jVW5zYWZlLG8ud3JpdGVCeXRlc0J1ZmZlcj1pLkJ1ZmZlciYmaS5CdWZmZXIucHJvdG90eXBlIGluc3RhbmNlb2YgVWludDhBcnJheSYmXCJzZXRcIj09PWkuQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZT9mdW5jdGlvbih0LGUsbil7ZS5zZXQodCxuKX06ZnVuY3Rpb24odCxlLG4pe2lmKHQuY29weSl0LmNvcHkoZSxuLDAsdC5sZW5ndGgpO2Vsc2UgZm9yKHZhciByPTA7cjx0Lmxlbmd0aDspZVtuKytdPXRbcisrXX19LG8ucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKHQpe2kuaXNTdHJpbmcodCkmJih0PWkuX0J1ZmZlcl9mcm9tKHQsXCJiYXNlNjRcIikpO3ZhciBlPXQubGVuZ3RoPj4+MDtyZXR1cm4gdGhpcy51aW50MzIoZSksZSYmdGhpcy5fcHVzaChvLndyaXRlQnl0ZXNCdWZmZXIsZSx0KSx0aGlzfSxvLnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24odCl7dmFyIGU9aS5CdWZmZXIuYnl0ZUxlbmd0aCh0KTtyZXR1cm4gdGhpcy51aW50MzIoZSksZSYmdGhpcy5fcHVzaChhLGUsdCksdGhpc30sby5fY29uZmlndXJlKCl9LDc3MTQ6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO2UuUj12b2lkIDA7Y29uc3Qgcj1uKDY5MTkpLGk9big3NDQ4KTtlLlI9bmV3IGNsYXNze2FzeW5jIGluaXQoKXt9YXN5bmMgY3JlYXRlU2Vzc2lvbkhhbmRsZXIodCxlKXtjb25zdCBuPW5ldyByLlNlc3Npb24oZSk7cmV0dXJuIGF3YWl0IG4ubG9hZE1vZGVsKHQpLG5ldyBpLk9ubnhqc1Nlc3Npb25IYW5kbGVyKG4pfX19LDQyMDA6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO2UuYzg9ZS5yWD12b2lkIDA7Y29uc3Qgcj1uKDE2NzApLGk9big1MzgxKSxvPW4oMjE1NyksYT1uKDIzMDYpO2Uuclg9KCk9PntpZigoXCJudW1iZXJcIiE9dHlwZW9mIHIuZW52Lndhc20uaW5pdFRpbWVvdXR8fHIuZW52Lndhc20uaW5pdFRpbWVvdXQ8MCkmJihyLmVudi53YXNtLmluaXRUaW1lb3V0PTApLFwiYm9vbGVhblwiIT10eXBlb2Ygci5lbnYud2FzbS5zaW1kJiYoci5lbnYud2FzbS5zaW1kPSEwKSxcImJvb2xlYW5cIiE9dHlwZW9mIHIuZW52Lndhc20ucHJveHkmJihyLmVudi53YXNtLnByb3h5PSExKSxcIm51bWJlclwiIT10eXBlb2Ygci5lbnYud2FzbS5udW1UaHJlYWRzfHwhTnVtYmVyLmlzSW50ZWdlcihyLmVudi53YXNtLm51bVRocmVhZHMpfHxyLmVudi53YXNtLm51bVRocmVhZHM8PTApe2NvbnN0IHQ9XCJ1bmRlZmluZWRcIj09dHlwZW9mIG5hdmlnYXRvcj8oMCxpLmNwdXMpKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O3IuZW52Lndhc20ubnVtVGhyZWFkcz1NYXRoLm1pbig0LE1hdGguY2VpbCgodHx8MSkvMikpfX0sZS5jOD1uZXcgY2xhc3N7YXN5bmMgaW5pdCgpeygwLGUuclgpKCksYXdhaXQoMCxvLmluaXRXYXNtKSgpfWFzeW5jIGNyZWF0ZVNlc3Npb25IYW5kbGVyKHQsZSl7Y29uc3Qgbj1uZXcgYS5Pbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXI7cmV0dXJuIGF3YWl0IG4ubG9hZE1vZGVsKHQsZSksUHJvbWlzZS5yZXNvbHZlKG4pfX19LDYwMTg6ZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1uKTt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsbik7aSYmIShcImdldFwiaW4gaT8hZS5fX2VzTW9kdWxlOmkud3JpdGFibGV8fGkuY29uZmlndXJhYmxlKXx8KGk9e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVbbl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQscixpKX06ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9biksdFtyXT1lW25dfSksaT10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gdClcImRlZmF1bHRcIj09PW58fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pfHxyKGUsdCxuKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksaShuKDE2NzApLGUpO2NvbnN0IG89bigxNjcwKTt7Y29uc3QgdD1uKDc3MTQpLlI7KDAsby5yZWdpc3RlckJhY2tlbmQpKFwid2ViZ2xcIix0LC0xMCl9e2NvbnN0IHQ9big0MjAwKS5jODsoMCxvLnJlZ2lzdGVyQmFja2VuZCkoXCJjcHVcIix0LDEwKSwoMCxvLnJlZ2lzdGVyQmFja2VuZCkoXCJ3YXNtXCIsdCwxMCksKDAsby5yZWdpc3RlckJhY2tlbmQpKFwieG5ucGFja1wiLHQsOSl9fSwyNDY6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleT12b2lkIDA7Y2xhc3Mgbntjb25zdHJ1Y3Rvcih0KXtPYmplY3QuYXNzaWduKHRoaXMsdCl9Z2V0IGNhY2hlS2V5KCl7cmV0dXJuIHRoaXMuX2NhY2hlS2V5fHwodGhpcy5fY2FjaGVLZXk9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuc29ydCgpLm1hcCgodD0+YCR7dGhpc1t0XX1gKSkuam9pbihcIjtcIikpLHRoaXMuX2NhY2hlS2V5fX1lLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleT10PT5uZXcgbih0KX0sNzc3ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5BdHRyaWJ1dGU9dm9pZCAwO2NvbnN0IHI9bigxNDQ2KSxpPW4oOTM5NSksbz1uKDkxNjIpLGE9bigyNTE3KTt2YXIgcz1pLm9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnM7Y2xhc3MgdXtjb25zdHJ1Y3Rvcih0KXtpZih0aGlzLl9hdHRyaWJ1dGVzPW5ldyBNYXAsbnVsbCE9dCl7Zm9yKGNvbnN0IGUgb2YgdCllIGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP3RoaXMuX2F0dHJpYnV0ZXMuc2V0KGUubmFtZSxbdS5nZXRWYWx1ZShlKSx1LmdldFR5cGUoZSldKTplIGluc3RhbmNlb2Ygcy5BdHRyaWJ1dGUmJnRoaXMuX2F0dHJpYnV0ZXMuc2V0KGUubmFtZSgpLFt1LmdldFZhbHVlKGUpLHUuZ2V0VHlwZShlKV0pO2lmKHRoaXMuX2F0dHJpYnV0ZXMuc2l6ZTx0Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJkdXBsaWNhdGVkIGF0dHJpYnV0ZSBuYW1lc1wiKX19c2V0KHQsZSxuKXt0aGlzLl9hdHRyaWJ1dGVzLnNldCh0LFtuLGVdKX1kZWxldGUodCl7dGhpcy5fYXR0cmlidXRlcy5kZWxldGUodCl9Z2V0RmxvYXQodCxlKXtyZXR1cm4gdGhpcy5nZXQodCxcImZsb2F0XCIsZSl9Z2V0SW50KHQsZSl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJpbnRcIixlKX1nZXRTdHJpbmcodCxlKXtyZXR1cm4gdGhpcy5nZXQodCxcInN0cmluZ1wiLGUpfWdldFRlbnNvcih0LGUpe3JldHVybiB0aGlzLmdldCh0LFwidGVuc29yXCIsZSl9Z2V0RmxvYXRzKHQsZSl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJmbG9hdHNcIixlKX1nZXRJbnRzKHQsZSl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJpbnRzXCIsZSl9Z2V0U3RyaW5ncyh0LGUpe3JldHVybiB0aGlzLmdldCh0LFwic3RyaW5nc1wiLGUpfWdldFRlbnNvcnModCxlKXtyZXR1cm4gdGhpcy5nZXQodCxcInRlbnNvcnNcIixlKX1nZXQodCxlLG4pe2NvbnN0IHI9dGhpcy5fYXR0cmlidXRlcy5nZXQodCk7aWYodm9pZCAwPT09cil7aWYodm9pZCAwIT09bilyZXR1cm4gbjt0aHJvdyBuZXcgRXJyb3IoYHJlcXVpcmVkIGF0dHJpYnV0ZSBub3QgZm91bmQ6ICR7dH1gKX1pZihyWzFdIT09ZSl0aHJvdyBuZXcgRXJyb3IoYHR5cGUgbWlzbWF0Y2g6IGV4cGVjdGVkICR7ZX0gYnV0IGdvdCAke3JbMV19YCk7cmV0dXJuIHJbMF19c3RhdGljIGdldFR5cGUodCl7Y29uc3QgZT10IGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP3QudHlwZTp0LnR5cGUoKTtzd2l0Y2goZSl7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVDpyZXR1cm5cImZsb2F0XCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlQ6cmV0dXJuXCJpbnRcIjtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORzpyZXR1cm5cInN0cmluZ1wiO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SOnJldHVyblwidGVuc29yXCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVFM6cmV0dXJuXCJmbG9hdHNcIjtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFM6cmV0dXJuXCJpbnRzXCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTOnJldHVyblwic3RyaW5nc1wiO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzpyZXR1cm5cInRlbnNvcnNcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgYXR0cmlidXRlIHR5cGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQ6ICR7ci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGVbZV19YCl9fXN0YXRpYyBnZXRWYWx1ZSh0KXtjb25zdCBlPXQgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8/dC50eXBlOnQudHlwZSgpO2lmKGU9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSHx8ZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUyl0aHJvdyBuZXcgRXJyb3IoXCJncmFwaCBhdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7Y29uc3Qgbj10aGlzLmdldFZhbHVlTm9DaGVjayh0KTtpZihlPT09ci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UJiZhLkxvbmdVdGlsLmlzTG9uZyhuKSlyZXR1cm4gYS5Mb25nVXRpbC5sb25nVG9OdW1iZXIobik7aWYoZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFMpe2NvbnN0IHQ9bixlPW5ldyBBcnJheSh0Lmxlbmd0aCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspe2NvbnN0IHI9dFtuXTtlW25dPWEuTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHIpfXJldHVybiBlfWlmKGU9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1IpcmV0dXJuIHQgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8/by5UZW5zb3IuZnJvbVByb3RvKG4pOm8uVGVuc29yLmZyb21PcnRUZW5zb3Iobik7aWYoZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlMpe2lmKHQgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8pcmV0dXJuIG4ubWFwKCh0PT5vLlRlbnNvci5mcm9tUHJvdG8odCkpKTtpZih0IGluc3RhbmNlb2Ygcy5BdHRyaWJ1dGUpcmV0dXJuIG4ubWFwKCh0PT5vLlRlbnNvci5mcm9tT3J0VGVuc29yKHQpKSl9aWYoZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORyYmdCBpbnN0YW5jZW9mIHIub25ueC5BdHRyaWJ1dGVQcm90byl7Y29uc3QgdD1uO3JldHVybigwLGEuZGVjb2RlVXRmOFN0cmluZykodCl9cmV0dXJuIGU9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTJiZ0IGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP24ubWFwKGEuZGVjb2RlVXRmOFN0cmluZyk6bn1zdGF0aWMgZ2V0VmFsdWVOb0NoZWNrKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP3RoaXMuZ2V0VmFsdWVOb0NoZWNrRnJvbU9ubnhGb3JtYXQodCk6dGhpcy5nZXRWYWx1ZU5vQ2hlY2tGcm9tT3J0Rm9ybWF0KHQpfXN0YXRpYyBnZXRWYWx1ZU5vQ2hlY2tGcm9tT25ueEZvcm1hdCh0KXtzd2l0Y2godC50eXBlKXtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkZMT0FUOnJldHVybiB0LmY7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlQ6cmV0dXJuIHQuaTtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORzpyZXR1cm4gdC5zO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SOnJldHVybiB0LnQ7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSDpyZXR1cm4gdC5nO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOnJldHVybiB0LmZsb2F0cztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFM6cmV0dXJuIHQuaW50cztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6cmV0dXJuIHQuc3RyaW5ncztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6cmV0dXJuIHQudGVuc29ycztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUzpyZXR1cm4gdC5ncmFwaHM7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGF0dHJpYnV0ZSB0eXBlOiAke3Iub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW3QudHlwZV19YCl9fXN0YXRpYyBnZXRWYWx1ZU5vQ2hlY2tGcm9tT3J0Rm9ybWF0KHQpe3N3aXRjaCh0LnR5cGUoKSl7Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuRkxPQVQ6cmV0dXJuIHQuZigpO2Nhc2Ugcy5BdHRyaWJ1dGVUeXBlLklOVDpyZXR1cm4gdC5pKCk7Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuU1RSSU5HOnJldHVybiB0LnMoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5URU5TT1I6cmV0dXJuIHQudCgpO2Nhc2Ugcy5BdHRyaWJ1dGVUeXBlLkdSQVBIOnJldHVybiB0LmcoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5GTE9BVFM6cmV0dXJuIHQuZmxvYXRzQXJyYXkoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5JTlRTOntjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5pbnRzTGVuZ3RoKCk7bisrKWUucHVzaCh0LmludHMobikpO3JldHVybiBlfWNhc2Ugcy5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6e2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0LnN0cmluZ3NMZW5ndGgoKTtuKyspZS5wdXNoKHQuc3RyaW5ncyhuKSk7cmV0dXJuIGV9Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzp7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQudGVuc29yc0xlbmd0aCgpO24rKyllLnB1c2godC50ZW5zb3JzKG4pKTtyZXR1cm4gZX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgYXR0cmlidXRlIHR5cGU6ICR7cy5BdHRyaWJ1dGVUeXBlW3QudHlwZSgpXX1gKX19fWUuQXR0cmlidXRlPXV9LDcwOTE6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucmVzb2x2ZUJhY2tlbmQ9ZS5iYWNrZW5kPXZvaWQgMDtjb25zdCByPW4oNTAzOCksaT1uZXcgTWFwO2FzeW5jIGZ1bmN0aW9uIG8odCl7Y29uc3Qgbj1lLmJhY2tlbmQ7aWYodm9pZCAwIT09blt0XSYmZnVuY3Rpb24odCl7Y29uc3QgZT10O3JldHVyblwiaW5pdGlhbGl6ZVwiaW4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5pbml0aWFsaXplJiZcImNyZWF0ZVNlc3Npb25IYW5kbGVyXCJpbiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmNyZWF0ZVNlc3Npb25IYW5kbGVyJiZcImRpc3Bvc2VcImluIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZGlzcG9zZX0oblt0XSkpe2NvbnN0IGU9blt0XTtsZXQgcj1lLmluaXRpYWxpemUoKTtpZihcIm9iamVjdFwiPT10eXBlb2YgciYmXCJ0aGVuXCJpbiByJiYocj1hd2FpdCByKSxyKXJldHVybiBpLnNldCh0LGUpLGV9fWUuYmFja2VuZD17d2ViZ2w6bmV3IHIuV2ViR0xCYWNrZW5kfSxlLnJlc29sdmVCYWNrZW5kPWFzeW5jIGZ1bmN0aW9uIHQoZSl7aWYoIWUpcmV0dXJuIHQoW1wid2ViZ2xcIl0pO3tjb25zdCB0PVwic3RyaW5nXCI9PXR5cGVvZiBlP1tlXTplO2Zvcihjb25zdCBlIG9mIHQpe2NvbnN0IHQ9aS5nZXQoZSk7aWYodClyZXR1cm4gdDtjb25zdCBuPWF3YWl0IG8oZSk7aWYobilyZXR1cm4gbn19dGhyb3cgbmV3IEVycm9yKFwibm8gYXZhaWxhYmxlIGJhY2tlbmQgdG8gdXNlXCIpfX0sNTAzODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5XZWJHTEJhY2tlbmQ9dm9pZCAwO2NvbnN0IHI9bigxNjcwKSxpPW4oNjIzMSksbz1uKDY0MTYpLGE9big3MzA1KTtlLldlYkdMQmFja2VuZD1jbGFzc3tnZXQgY29udGV4dElkKCl7cmV0dXJuIHIuZW52LndlYmdsLmNvbnRleHRJZH1zZXQgY29udGV4dElkKHQpe3IuZW52LndlYmdsLmNvbnRleHRJZD10fWdldCBtYXRtdWxNYXhCYXRjaFNpemUoKXtyZXR1cm4gci5lbnYud2ViZ2wubWF0bXVsTWF4QmF0Y2hTaXplfXNldCBtYXRtdWxNYXhCYXRjaFNpemUodCl7ci5lbnYud2ViZ2wubWF0bXVsTWF4QmF0Y2hTaXplPXR9Z2V0IHRleHR1cmVDYWNoZU1vZGUoKXtyZXR1cm4gci5lbnYud2ViZ2wudGV4dHVyZUNhY2hlTW9kZX1zZXQgdGV4dHVyZUNhY2hlTW9kZSh0KXtyLmVudi53ZWJnbC50ZXh0dXJlQ2FjaGVNb2RlPXR9Z2V0IHBhY2soKXtyZXR1cm4gci5lbnYud2ViZ2wucGFja31zZXQgcGFjayh0KXtyLmVudi53ZWJnbC5wYWNrPXR9Z2V0IGFzeW5jKCl7cmV0dXJuIHIuZW52LndlYmdsLmFzeW5jfXNldCBhc3luYyh0KXtyLmVudi53ZWJnbC5hc3luYz10fWluaXRpYWxpemUoKXt0cnl7cmV0dXJuIHRoaXMuZ2xDb250ZXh0PSgwLGEuY3JlYXRlV2ViR0xDb250ZXh0KSh0aGlzLmNvbnRleHRJZCksXCJudW1iZXJcIiE9dHlwZW9mIHRoaXMubWF0bXVsTWF4QmF0Y2hTaXplJiYodGhpcy5tYXRtdWxNYXhCYXRjaFNpemU9MTYpLFwic3RyaW5nXCIhPXR5cGVvZiB0aGlzLnRleHR1cmVDYWNoZU1vZGUmJih0aGlzLnRleHR1cmVDYWNoZU1vZGU9XCJmdWxsXCIpLFwiYm9vbGVhblwiIT10eXBlb2YgdGhpcy5wYWNrJiYodGhpcy5wYWNrPSExKSxcImJvb2xlYW5cIiE9dHlwZW9mIHRoaXMuYXN5bmMmJih0aGlzLmFzeW5jPSExKSxpLkxvZ2dlci5zZXRXaXRoRW52KHIuZW52KSxpLkxvZ2dlci52ZXJib3NlKFwiV2ViR0xCYWNrZW5kXCIsYENyZWF0ZWQgV2ViR0xDb250ZXh0OiAke3R5cGVvZiB0aGlzLmdsQ29udGV4dH0gd2l0aCBtYXRtdWxNYXhCYXRjaFNpemU6ICR7dGhpcy5tYXRtdWxNYXhCYXRjaFNpemV9OyB0ZXh0dXJlQ2FjaGVNb2RlOiAke3RoaXMudGV4dHVyZUNhY2hlTW9kZX07IHBhY2s6ICR7dGhpcy5wYWNrfTsgYXN5bmM6ICR7dGhpcy5hc3luY30uYCksITB9Y2F0Y2godCl7cmV0dXJuIGkuTG9nZ2VyLndhcm5pbmcoXCJXZWJHTEJhY2tlbmRcIixgVW5hYmxlIHRvIGluaXRpYWxpemUgV2ViR0xCYWNrZW5kLiAke3R9YCksITF9fWNyZWF0ZVNlc3Npb25IYW5kbGVyKHQpe3JldHVybiBuZXcgby5XZWJHTFNlc3Npb25IYW5kbGVyKHRoaXMsdCl9ZGlzcG9zZSgpe3RoaXMuZ2xDb250ZXh0LmRpc3Bvc2UoKX19fSw1MTA3Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLkNvb3Jkc0dsc2xMaWI9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oODUyMCksbz1uKDUwNjApLGE9big3ODU5KSxzPW4oOTM5MCk7Y2xhc3MgdSBleHRlbmRzIGkuR2xzbExpYntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXRGdW5jdGlvbnMoKXtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLm9mZnNldFRvQ29vcmRzKCkpLHRoaXMuY29vcmRzVG9PZmZzZXQoKSksdGhpcy50b1ZlYygpKSx0aGlzLnZhbHVlRnJvbSgpKSx0aGlzLmdldENvbW1vblV0aWxGdW5jcygpKSx0aGlzLmdldElucHV0c1NhbXBsaW5nU25pcHBldHMoKSksdGhpcy5nZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1vZmZzZXRUb0Nvb3Jkcygpe3JldHVybntvZmZzZXRUb0Nvb3JkczpuZXcgaS5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIHZlYzIgb2Zmc2V0VG9Db29yZHMoaW50IG9mZnNldCwgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XFxuICAgICAgICBpbnQgdCA9IG9mZnNldCAvIHdpZHRoO1xcbiAgICAgICAgaW50IHMgPSBvZmZzZXQgLSB0KndpZHRoO1xcbiAgICAgICAgdmVjMiBjb29yZHMgPSAodmVjMihzLHQpICsgdmVjMigwLjUsMC41KSkgLyB2ZWMyKHdpZHRoLCBoZWlnaHQpO1xcbiAgICAgICAgcmV0dXJuIGNvb3JkcztcXG4gICAgICB9XFxuICAgICAgXCIpfX1jb29yZHNUb09mZnNldCgpe3JldHVybntjb29yZHNUb09mZnNldDpuZXcgaS5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIGludCBjb29yZHNUb09mZnNldCh2ZWMyIGNvb3JkcywgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XFxuICAgICAgICBmbG9hdCBzID0gY29vcmRzLnMgKiBmbG9hdCh3aWR0aCk7XFxuICAgICAgICBmbG9hdCB0ID0gY29vcmRzLnQgKiBmbG9hdChoZWlnaHQpO1xcbiAgICAgICAgaW50IG9mZnNldCA9IGludCh0KSAqIHdpZHRoICsgaW50KHMpO1xcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcXG4gICAgICB9XFxuICAgICAgXCIpfX1nZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoKXtjb25zdCB0PXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O3JldHVybiB0LmlzUGFja2VkP3RoaXMuZ2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KHQpOnRoaXMuZ2V0VW5wYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQodCl9Z2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KHQpe2NvbnN0IGU9dC51bnBhY2tlZFNoYXBlLG49W3Qud2lkdGgsdC5oZWlnaHRdLHI9e30sYT1cImdldE91dHB1dENvb3Jkc1wiO3N3aXRjaChlLmxlbmd0aCl7Y2FzZSAwOnJbYV09dGhpcy5nZXRPdXRwdXRTY2FsYXJDb29yZHMoKTticmVhaztjYXNlIDE6clthXT10aGlzLmdldE91dHB1dFBhY2tlZDFEQ29vcmRzKGUsbik7YnJlYWs7Y2FzZSAyOnJbYV09dGhpcy5nZXRPdXRwdXRQYWNrZWQyRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgMzpyW2FdPXRoaXMuZ2V0T3V0cHV0UGFja2VkM0RDb29yZHMoZSxuKTticmVhaztkZWZhdWx0OnJbYV09dGhpcy5nZXRPdXRwdXRQYWNrZWRORENvb3JkcyhlLG4pfWNvbnN0IHM9YFxcbiAgICAgIHZvaWQgc2V0T3V0cHV0KHZlYzQgdmFsKSB7XFxuICAgICAgICAkeygwLG8uZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKS5vdXRwdXR9ID0gdmFsO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gci5mbG9hdFRleHR1cmVTZXRSR0JBPW5ldyBpLkdsc2xMaWJSb3V0aW5lKHMpLHJ9Z2V0VW5wYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQodCl7Y29uc3QgZT10LnVucGFja2VkU2hhcGUsbj1bdC53aWR0aCx0LmhlaWdodF0scj17fSxhPVwiZ2V0T3V0cHV0Q29vcmRzXCI7c3dpdGNoKGUubGVuZ3RoKXtjYXNlIDA6clthXT10aGlzLmdldE91dHB1dFNjYWxhckNvb3JkcygpO2JyZWFrO2Nhc2UgMTpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQxRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgMjpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQyRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgMzpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQzRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgNDpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ0RENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgNTpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ1RENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgNjpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ2RENvb3JkcyhlLG4pO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvdXRwdXQgZGltZW5zaW9uYWxpdHk6ICR7ZS5sZW5ndGh9YCl9Y29uc3Qgcz1gXFxuICAgICAgICB2b2lkIHNldE91dHB1dChmbG9hdCB2YWwpIHtcXG4gICAgICAgICAgJHsoMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikub3V0cHV0fSA9IHZlYzQodmFsLCAwLCAwLCAwKTtcXG4gICAgICAgIH1cXG4gICAgYDtyZXR1cm4gci5mbG9hdFRleHR1cmVTZXRSPW5ldyBpLkdsc2xMaWJSb3V0aW5lKHMpLHJ9Z2V0T3V0cHV0U2NhbGFyQ29vcmRzKCl7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiAwO1xcbiAgICAgIH1cXG4gICAgXCIpfWdldE91dHB1dFBhY2tlZDFEQ29vcmRzKHQsZSl7Y29uc3Qgbj1lO2xldCByPVwiXCI7cmV0dXJuIDE9PT1uWzBdPyhyPWBcXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgICByZXR1cm4gMiAqIGludChUZXhDb29yZHMueSAqICR7blsxXX0uMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGAsbmV3IGkuR2xzbExpYlJvdXRpbmUocikpOjE9PT1uWzFdPyhyPWBcXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgICByZXR1cm4gMiAqIGludChUZXhDb29yZHMueCAqICR7blswXX0uMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGAsbmV3IGkuR2xzbExpYlJvdXRpbmUocikpOihyPWBcXG4gICAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7blswXX0sICR7blsxXX0pKTtcXG4gICAgICAgICAgcmV0dXJuIDIgKiAocmVzVGV4UkMueSAqICR7blswXX0gKyByZXNUZXhSQy54KTtcXG4gICAgICAgIH1cXG4gICAgICBgLG5ldyBpLkdsc2xMaWJSb3V0aW5lKHIpKX1nZXRPdXRwdXRQYWNrZWQyRENvb3Jkcyh0LGUpe2xldCBuPVwiXCI7aWYoci5BcnJheVV0aWwuYXJyYXlzRXF1YWwodCxlKSlyZXR1cm4gbj1gXFxuICAgICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIHJldHVybiAyICogaXZlYzIoVGV4Q29vcmRzLnh5ICogdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKTtjb25zdCBvPWUsYT1NYXRoLmNlaWwodFsxXS8yKTtyZXR1cm4gbj1gXFxuICAgICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtvWzBdfSwgJHtvWzFdfSkpO1xcblxcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtvWzBdfSArIHJlc1RleFJDLng7XFxuXFxuICAgICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcXG4gICAgICAgICAgaW50IHIgPSBpbW9kKGluZGV4LCAke2F9KSAqIDI7XFxuICAgICAgICAgIGludCBjID0gMiAqIChpbmRleCAvICR7YX0pO1xcblxcbiAgICAgICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRQYWNrZWQzRENvb3Jkcyh0LGUpe2NvbnN0IG49W2VbMF0sZVsxXV0scj1NYXRoLmNlaWwodFsyXS8yKSxvPXIqTWF0aC5jZWlsKHRbMV0vMiksYT1gXFxuICAgICAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtuWzBdfSwgJHtuWzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtuWzBdfSArIHJlc1RleFJDLng7XFxuXFxuICAgICAgICAgIGludCBiID0gaW5kZXggLyAke299O1xcbiAgICAgICAgICBpbmRleCAtPSBiICogJHtvfTtcXG5cXG4gICAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxcbiAgICAgICAgICBpbnQgciA9IGltb2QoaW5kZXgsICR7cn0pICogMjtcXG4gICAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHtyfSk7XFxuXFxuICAgICAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShhKX1nZXRPdXRwdXRQYWNrZWRORENvb3Jkcyh0LGUpe2NvbnN0IG49W2VbMF0sZVsxXV0scj1NYXRoLmNlaWwodFt0Lmxlbmd0aC0xXS8yKSxvPXIqTWF0aC5jZWlsKHRbdC5sZW5ndGgtMl0vMik7bGV0IGE9byxzPVwiXCIsdT1cImIsIHIsIGNcIjtmb3IobGV0IGU9MjtlPHQubGVuZ3RoLTE7ZSsrKWEqPXRbdC5sZW5ndGgtZS0xXSxzPWBcXG4gICAgICBpbnQgYiR7ZX0gPSBpbmRleCAvICR7YX07XFxuICAgICAgaW5kZXggLT0gYiR7ZX0gKiAke2F9O1xcbiAgICBgK3MsdT1gYiR7ZX0sIGArdTtjb25zdCBjPWBcXG4gICAgICBpdmVjJHt0Lmxlbmd0aH0gZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtuWzBdfSwgJHtuWzFdfSkpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7blswXX0gKyByZXNUZXhSQy54O1xcblxcbiAgICAgICAgJHtzfVxcblxcbiAgICAgICAgaW50IGIgPSBpbmRleCAvICR7b307XFxuICAgICAgICBpbmRleCAtPSBiICogJHtvfTtcXG5cXG4gICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcXG4gICAgICAgIGludCByID0gaW1vZChpbmRleCwgJHtyfSkgKiAyO1xcbiAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHtyfSk7XFxuXFxuICAgICAgICByZXR1cm4gaXZlYyR7dC5sZW5ndGh9KCR7dX0pO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoYyl9Z2V0T3V0cHV0VW5wYWNrZWQxRENvb3Jkcyh0LGUpe2NvbnN0IG49YFxcbiAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICAgIHJldHVybiByZXNUZXhSQy55ICogJHtlWzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobil9Z2V0T3V0cHV0VW5wYWNrZWQyRENvb3Jkcyh0LGUpe2NvbnN0IG49YFxcbiAgICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7ZVswXX0sICR7ZVsxXX0pKTtcXG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7ZVswXX0gKyByZXNUZXhSQy54O1xcbiAgICAgICAgICBpbnQgciA9IGluZGV4IC8gJHt0WzFdfTtcXG4gICAgICAgICAgaW50IGMgPSBpbmRleCAtIHIgKiAke3RbMV19O1xcbiAgICAgICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobil9Z2V0T3V0cHV0VW5wYWNrZWQzRENvb3Jkcyh0LGUpe2xldCBuPVwiXCI7Y29uc3Qgcj10Lmxlbmd0aDtsZXQgbz1udWxsO3I8MiYmKG89W10pLG89bmV3IEFycmF5KHItMSksb1tyLTJdPXRbci0xXTtmb3IobGV0IGU9ci0zO2U+PTA7LS1lKW9bZV09b1tlKzFdKnRbZSsxXTtjb25zdCBhPVtcInJcIixcImNcIixcImRcIl0scz1vLm1hcCgoKHQsZSk9PmBpbnQgJHthW2VdfSA9IGluZGV4IC8gJHt0fTsgJHtlPT09by5sZW5ndGgtMT9gaW50ICR7YVtlKzFdfSA9IGluZGV4IC0gJHthW2VdfSAqICR7dH1gOmBpbmRleCAtPSAke2FbZV19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke2VbMF19ICsgcmVzVGV4UkMueDtcXG4gICAgICAgICAgJHtzfVxcbiAgICAgICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRVbnBhY2tlZDREQ29vcmRzKHQsZSl7bGV0IG49XCJcIjtjb25zdCByPXQubGVuZ3RoO2xldCBvPW51bGw7cjwyJiYobz1bXSksbz1uZXcgQXJyYXkoci0xKSxvW3ItMl09dFtyLTFdO2ZvcihsZXQgZT1yLTM7ZT49MDstLWUpb1tlXT1vW2UrMV0qdFtlKzFdO2NvbnN0IGE9W1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIl0scz1vLm1hcCgoKHQsZSk9PmBpbnQgJHthW2VdfSA9IGluZGV4IC8gJHt0fTsgJHtlPT09by5sZW5ndGgtMT9gaW50ICR7YVtlKzFdfSA9IGluZGV4IC0gJHthW2VdfSAqICR7dH1gOmBpbmRleCAtPSAke2FbZV19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICBpdmVjNCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtlWzBdfSwgJHtlWzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtlWzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICAgICR7c31cXG4gICAgICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcXG4gICAgICAgIH1cXG4gICAgICBgLG5ldyBpLkdsc2xMaWJSb3V0aW5lKG4pfWdldE91dHB1dFVucGFja2VkNURDb29yZHModCxlKXtsZXQgbj1cIlwiO2NvbnN0IHI9dC5sZW5ndGg7bGV0IG89bnVsbDtyPDImJihvPVtdKSxvPW5ldyBBcnJheShyLTEpLG9bci0yXT10W3ItMV07Zm9yKGxldCBlPXItMztlPj0wOy0tZSlvW2VdPW9bZSsxXSp0W2UrMV07Y29uc3QgYT1bXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiLFwiZDNcIl0scz1vLm1hcCgoKHQsZSk9PmBpbnQgJHthW2VdfSA9IGluZGV4IC8gJHt0fTsgJHtlPT09by5sZW5ndGgtMT9gaW50ICR7YVtlKzFdfSA9IGluZGV4IC0gJHthW2VdfSAqICR7dH1gOmBpbmRleCAtPSAke2FbZV19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICBpdmVjNSBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtlWzBdfSwgJHtlWzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtlWzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICAgICR7c31cXG4gICAgICAgICAgcmV0dXJuIGl2ZWM1KHIsIGMsIGQsIGQyLCBkMyk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRVbnBhY2tlZDZEQ29vcmRzKHQsZSl7bGV0IG49XCJcIjtjb25zdCByPXQubGVuZ3RoO2xldCBvPW51bGw7cjwyJiYobz1bXSksbz1uZXcgQXJyYXkoci0xKSxvW3ItMl09dFtyLTFdO2ZvcihsZXQgZT1yLTM7ZT49MDstLWUpb1tlXT1vW2UrMV0qdFtlKzFdO2NvbnN0IGE9W1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIixcImQzXCIsXCJkNFwiXSxzPW8ubWFwKCgodCxlKT0+YGludCAke2FbZV19ID0gaW5kZXggLyAke3R9OyAke2U9PT1vLmxlbmd0aC0xP2BpbnQgJHthW2UrMV19ID0gaW5kZXggLSAke2FbZV19ICogJHt0fWA6YGluZGV4IC09ICR7YVtlXX0gKiAke3R9YH07YCkpLmpvaW4oXCJcIik7cmV0dXJuIG49YFxcbiAgICAgaXZlYzYgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7ZVswXX0gKyByZXNUZXhSQy54O1xcbiAgICAgICAgICR7c31cXG4gICAgICAgICByZXR1cm4gaXZlYzYociwgYywgZCwgZDIsIGQzLCBkNCk7XFxuICAgICAgIH1cXG4gICAgIGAsbmV3IGkuR2xzbExpYlJvdXRpbmUobil9Z2V0Q29tbW9uVXRpbEZ1bmNzKCl7Y29uc3QgdD17fTtsZXQgZT1cInV2RnJvbUZsYXRcIjt0W2VdPW5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgIHZlYzIgdXZGcm9tRmxhdChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLyB0ZXhOdW1SO1xcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLSB0ZXhDICogdGV4TnVtUjtcXG4gICAgICAvLyBUT0RPOiBzd2FwIHRleFIsIHRleEMgb3JkZXIgaW4gZm9sbG93aW5nIGZ1bmN0aW9uIHNvIHJvdyBpcyBjb3JyZXNwb25kaW5nIHRvIHUgYW5kIGNvbHVtbiBpcyBjb3JyZXNwb25kaW5nIHRvXFxuICAgICAgLy8gICAgICAgdi5cXG4gICAgICByZXR1cm4gKHZlYzIodGV4UiwgdGV4QykgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1SLCB0ZXhOdW1DKTtcXG4gICAgfVxcbiAgICBcIiksZT1cInBhY2tlZFVWZnJvbTFEXCIsdFtlXT1uZXcgaS5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIHZlYzIgcGFja2VkVVZmcm9tMUQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcXG4gICAgICAgIGludCB0ZXhlbEluZGV4ID0gaW5kZXggLyAyO1xcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxuICAgICAgfVxcbiAgICAgIFwiKSxlPVwicGFja2VkVVZmcm9tMkRcIix0W2VdPW5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20yRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIGludCB0ZXhlbEluZGV4ID0gKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxuICAgICAgfVxcbiAgICAgIFwiKSxlPVwicGFja2VkVVZmcm9tM0RcIix0W2VdPW5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20zRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsXFxuICAgICAgICAgIGludCB0ZXhlbHNJbkJhdGNoLCBpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgYixcXG4gICAgICAgICAgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgaW50IGluZGV4ID0gYiAqIHRleGVsc0luQmF0Y2ggKyAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XFxuICAgICAgICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gICAgICAgIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbiAgICAgIH1cXG4gICAgICBcIiksZT1cInNhbXBsZVRleHR1cmVcIjtjb25zdCBuPSgwLG8uZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtyZXR1cm4gdFtlXT1uZXcgaS5HbHNsTGliUm91dGluZShgXFxuICAgICAgICBmbG9hdCBzYW1wbGVUZXh0dXJlKHNhbXBsZXIyRCB0ZXh0dXJlU2FtcGxlciwgdmVjMiB1dikge1xcbiAgICAgICAgICAgIHJldHVybiAke24udGV4dHVyZTJEfSh0ZXh0dXJlU2FtcGxlciwgdXYpLnI7XFxuICAgICAgICB9YCksdH1nZXRJbnB1dHNTYW1wbGluZ1NuaXBwZXRzKCl7Y29uc3QgdD17fSxlPXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgobixyKT0+e2NvbnN0IGk9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbcl0sbz0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSkobik7aS5pc1BhY2tlZD90W29dPXRoaXMuZ2V0UGFja2VkU2FtcGxlckZyb21JbnB1dChvLG4saSk6dFtvXT10aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChvLG4saSk7Y29uc3QgYT0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZUF0T3V0Q29vcmRzKShuKTtpLnVucGFja2VkU2hhcGUubGVuZ3RoPD1lLnVucGFja2VkU2hhcGUubGVuZ3RoJiYoaS5pc1BhY2tlZD90W2FdPXRoaXMuZ2V0UGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKGEsaSxlLG4pOnRbYV09dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhhLGksZSxuKSl9KSksdH1nZXRQYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHModCxlLG4sbyl7Y29uc3QgYT1lLnVucGFja2VkU2hhcGUsdT1uLnVucGFja2VkU2hhcGUsYz1vLGw9KDAscy5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWUpKGMpLHA9YS5sZW5ndGgsZj11Lmxlbmd0aCxkPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGEsdSksaD0oMCxzLmdldENvb3Jkc0RhdGFUeXBlKShmKSxnPWYtcDtsZXQgYjtjb25zdCBtPSgwLHMuZ2V0R2xDaGFubmVscykoKTtiPTA9PT1wP1wiXCI6ZjwyJiZkLmxlbmd0aD49MT9cImNvb3JkcyA9IDA7XCI6ZC5tYXAoKHQ9PmBjb29yZHMuJHttW3QrZ119ID0gMDtgKSkuam9pbihcIlxcblwiKTtsZXQgeT1cIlwiO3k9ZjwyJiZwPjA/XCJjb29yZHNcIjphLm1hcCgoKHQsZSk9PmBjb29yZHMuJHttW2UrZ119YCkpLmpvaW4oXCIsIFwiKTtsZXQgXz1cInJldHVybiBvdXRwdXRWYWx1ZTtcIjtjb25zdCB2PTE9PT1yLlNoYXBlVXRpbC5zaXplKGEpLHc9MT09PXIuU2hhcGVVdGlsLnNpemUodSk7aWYoMSE9PXB8fHZ8fHcpe2lmKHYmJiF3KV89MT09PWY/XCJcXG4gICAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueCwgMC4sIDAuKTtcXG4gICAgICAgIFwiOlwiXFxuICAgICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1xcbiAgICAgICAgXCI7ZWxzZSBpZihkLmxlbmd0aCl7Y29uc3QgdD1wLTIsZT1wLTE7ZC5pbmRleE9mKHQpPi0xJiZkLmluZGV4T2YoZSk+LTE/Xz1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1wiOmQuaW5kZXhPZih0KT4tMT9fPVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSwgb3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSk7XCI6ZC5pbmRleE9mKGUpPi0xJiYoXz1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh4LCBvdXRwdXRWYWx1ZS56eik7XCIpfX1lbHNlIF89XCJcXG4gICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh5LCBvdXRwdXRWYWx1ZS54eSk7XFxuICAgICAgXCI7Y29uc3QgeD1gXFxuICAgICAgdmVjNCAke3R9KCkge1xcbiAgICAgICAgJHtofSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIFxcbiAgICAgICAgaW50IGxhc3REaW0gPSBjb29yZHMuJHttW2YtMV19O1xcbiAgICAgICAgY29vcmRzLiR7bVtmLTFdfSA9IGNvb3Jkcy4ke21bZi0yXX07XFxuICAgICAgICBjb29yZHMuJHttW2YtMl19ID0gbGFzdERpbTtcXG4gICAgICBcXG4gICAgICAgICR7Yn1cXG4gICAgICAgIHZlYzQgb3V0cHV0VmFsdWUgPSAke2x9KCR7eX0pO1xcbiAgICAgICAgJHtffVxcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoeCxbXCJjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHNcIl0pfWdldFVucGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKHQsZSxuLG8pe2NvbnN0IGE9W24ud2lkdGgsbi5oZWlnaHRdLHU9W2Uud2lkdGgsZS5oZWlnaHRdLGM9ZS51bnBhY2tlZFNoYXBlLmxlbmd0aCxsPW4udW5wYWNrZWRTaGFwZS5sZW5ndGgscD1lLnVucGFja2VkU2hhcGUsZj1uLnVucGFja2VkU2hhcGUsZD0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSkobyk7aWYoYz09PWwmJnIuQXJyYXlVdGlsLmFycmF5c0VxdWFsKHUsYSkpe2NvbnN0IGU9YFxcbiAgICAgICAgICBmbG9hdCAke3R9KCkge1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7b30sIFRleENvb3Jkcyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGUsW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Y29uc3QgaD0oMCxzLmdldENvb3Jkc0RhdGFUeXBlKShsKSxnPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKHAsZiksYj1sLWM7bGV0IG07Y29uc3QgeT0oMCxzLmdldEdsQ2hhbm5lbHMpKCk7bT0wPT09Yz9cIlwiOmw8MiYmZy5sZW5ndGg+PTE/XCJjb29yZHMgPSAwO1wiOmcubWFwKCh0PT5gY29vcmRzLiR7eVt0K2JdfSA9IDA7YCkpLmpvaW4oXCJcXG5cIik7bGV0IF89XCJcIjtfPWw8MiYmYz4wP1wiY29vcmRzXCI6ZS51bnBhY2tlZFNoYXBlLm1hcCgoKHQsZSk9PmBjb29yZHMuJHt5W2UrYl19YCkpLmpvaW4oXCIsIFwiKTtjb25zdCB2PWBcXG4gICAgICAgIGZsb2F0ICR7dH0oKSB7XFxuICAgICAgICAgICR7aH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgICR7bX1cXG4gICAgICAgICAgcmV0dXJuICR7ZH0oJHtffSk7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUodixbXCJjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHNcIl0pfWdldFBhY2tlZFNhbXBsZXJGcm9tSW5wdXQodCxlLG4pe3N3aXRjaChuLnVucGFja2VkU2hhcGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlclNjYWxhcih0LGUpO2Nhc2UgMTpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyMUQodCxlLG4pO2Nhc2UgMjpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyMkQodCxlLG4pO2Nhc2UgMzpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyM0QodCxlLG4pO2RlZmF1bHQ6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlck5EKHQsZSxuKX19Z2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZTtzd2l0Y2goci5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIodCxlLG4pO2Nhc2UgMTpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIxRCh0LGUsbik7Y2FzZSAyOnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjJEKHQsZSxuKTtjYXNlIDM6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyM0QodCxlLG4pO2Nhc2UgNDpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI0RCh0LGUsbik7Y2FzZSA1OnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjVEKHQsZSxuKTtjYXNlIDY6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyNkQodCxlLG4pO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkaW1lbnNpb24gJHtyLmxlbmd0aH0tRGApfX1nZXRQYWNrZWRTYW1wbGVyU2NhbGFyKHQsZSl7Y29uc3Qgbj1gXFxuICAgICAgICAgIHZlYzQgJHt0fSgpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHsoMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfSgke2V9LCBoYWxmQ1IpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRQYWNrZWRTYW1wbGVyMUQodCxlLG4pe2NvbnN0IHI9W24ud2lkdGgsbi5oZWlnaHRdLGE9W3JbMV0sclswXV0scz0oMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbiksdT1gdmVjNCAke3R9KGludCBpbmRleCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20xRChcXG4gICAgICAke2FbMF19LCAke2FbMV19LCBpbmRleCk7XFxuICAgICAgcmV0dXJuICR7cy50ZXh0dXJlMkR9KCR7ZX0sIHV2KTtcXG4gICAgfWA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKHUsW1wiY29vcmRpbmF0ZXMucGFja2VkVVZmcm9tMURcIl0pfWdldFBhY2tlZFNhbXBsZXIyRCh0LGUsbil7Y29uc3QgYT1uLnVucGFja2VkU2hhcGUscz1bbi53aWR0aCxuLmhlaWdodF0sdT0oMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbiksYz1zWzBdLGw9c1sxXTtpZihudWxsIT1zJiZyLkFycmF5VXRpbC5hcnJheXNFcXVhbChhLHMpKXtjb25zdCBuPWB2ZWM0ICR7dH0oaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKCR7bH0uMCwgJHtjfS4wKTtcXG4gICAgICAgIHJldHVybiAke3UudGV4dHVyZTJEfSgke2V9LCB1dik7XFxuICAgICAgfWA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKG4pfWNvbnN0IHA9cyxmPU1hdGguY2VpbChhWzFdLzIpLGQ9YHZlYzQgJHt0fShpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTJEKCR7cFsxXX0sICR7cFswXX0sICR7Zn0sIHJvdywgY29sKTtcXG4gICAgICByZXR1cm4gJHt1LnRleHR1cmUyRH0oJHtlfSwgdXYpO1xcbiAgICB9YDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoZCxbXCJjb29yZGluYXRlcy5wYWNrZWRVVmZyb20yRFwiXSl9Z2V0UGFja2VkU2FtcGxlcjNEKHQsZSxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZSxhPVtuLndpZHRoLG4uaGVpZ2h0XSx1PVthWzBdLGFbMV1dLGM9KDAsby5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO2lmKDE9PT1yWzBdKXtjb25zdCBvPXIuc2xpY2UoMSksYT1bMSwyXSx1PSgwLHMuc3F1ZWV6ZUlucHV0U2hhcGUpKHIsbyksYz1bXCJiXCIsXCJyb3dcIixcImNvbFwiXSxsPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO2wudW5wYWNrZWRTaGFwZT11O2NvbnN0IHA9dGhpcy5nZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSxsKSxmPWAke3Aucm91dGluZUJvZHl9XFxuICAgICAgdmVjNCAke3R9KGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICByZXR1cm4gJHt0fSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKGMsYSl9KTtcXG4gICAgICB9IGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGYscC5kZXBlbmRlbmNpZXMpfWNvbnN0IGw9dVswXSxwPXVbMV0sZj1NYXRoLmNlaWwoclsyXS8yKSxkPWB2ZWM0ICR7dH0oaW50IGIsIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tM0QoXFxuICAgICAgICAke3B9LCAke2x9LCAke2YqTWF0aC5jZWlsKHJbMV0vMil9LCAke2Z9LCBiLCByb3csIGNvbCk7XFxuICAgICAgcmV0dXJuICR7Yy50ZXh0dXJlMkR9KCR7ZX0sIHV2KTt9YDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoZCxbXCJjb29yZGluYXRlcy5wYWNrZWRVVmZyb20zRFwiXSl9Z2V0UGFja2VkU2FtcGxlck5EKHQsZSxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZSxhPXIubGVuZ3RoLHM9W24ud2lkdGgsbi5oZWlnaHRdLHU9KDAsby5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pLGM9W3NbMF0sc1sxXV0sbD1jWzFdLHA9Y1swXSxmPU1hdGguY2VpbChyW2EtMV0vMik7bGV0IGQ9ZipNYXRoLmNlaWwoclthLTJdLzIpLGg9XCJpbnQgYiwgaW50IHJvdywgaW50IGNvbFwiLGc9YGIgKiAke2R9ICsgKHJvdyAvIDIpICogJHtmfSArIChjb2wgLyAyKWA7Zm9yKGxldCB0PTI7dDxhLTE7dCsrKWg9YGludCBiJHt0fSwgYCtoLGQqPXJbYS10LTFdLGc9YGIke3R9ICogJHtkfSArIGArZztjb25zdCBiPWB2ZWM0ICR7dH0oJHtofSkge1xcbiAgICAgIGludCBpbmRleCA9ICR7Z307XFxuICAgICAgaW50IHRleFIgPSBpbmRleCAvICR7cH07XFxuICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiAke3B9O1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKCR7cH0sICR7bH0pO1xcbiAgICAgIHJldHVybiAke3UudGV4dHVyZTJEfSgke2V9LCB1dik7XFxuICAgIH1gO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShiKX1nZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIodCxlLG4pe2NvbnN0W3Isb109W24ud2lkdGgsbi5oZWlnaHRdO2lmKDE9PT1yJiYxPT09byl7Y29uc3Qgbj1gXFxuICAgICAgICAgIGZsb2F0ICR7dH0oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgaGFsZkNSKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBhPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oKSB7XFxuICAgICAgICAgIGludCBvZmZzZXRfJHtlfSA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtyfSwgJHtvfSk7XFxuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7cn0sICR7b30sIG9mZnNldF8ke2V9KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGEsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXRcIl0pfWdldFVucGFja2VkU2FtcGxlcjFEKHQsZSxuKXtjb25zdCByPW4ud2lkdGgsbz1uLmhlaWdodDtpZigxPT09byYmMT09PXIpe2NvbnN0IG49YFxcbiAgICAgICAgZmxvYXQgJHt0fShpbnQgaW5kZXgpIHtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgaGFsZkNSKTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShuLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWlmKDE9PT1vKXtjb25zdCBuPWBcXG4gICAgICAgICAgZmxvYXQgJHt0fShpbnQgaW5kZXgpIHtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXgpICsgMC41KSAvICR7cn0uMCwgMC41KTtcXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKG4sW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9aWYoMT09PXIpe2NvbnN0IG49YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCBpbmRleCkge1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4KSArIDAuNSkgLyAke299LjApO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBhPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oaW50IGluZGV4KSB7XFxuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7cn0sICR7b30sIGluZGV4KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGEsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyMkQodCxlLG4pe2NvbnN0IG89bi51bnBhY2tlZFNoYXBlLHU9W24uaGVpZ2h0LG4ud2lkdGhdO2lmKG51bGwhPXUmJnIuQXJyYXlVdGlsLmFycmF5c0VxdWFsKG8sdSkpe2NvbnN0IG49YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIocm93LCBjb2wpICsgaGFsZkNSKSAvIHZlYzIoJHt1WzFdfS4wLCAke3VbMF19LjApO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdHtuZXdTaGFwZTpjLGtlcHREaW1zOmx9PSgwLGEuc3F1ZWV6ZVNoYXBlKShvKSxwPWM7aWYocC5sZW5ndGg8by5sZW5ndGgpe2NvbnN0IHI9KDAscy5zcXVlZXplSW5wdXRTaGFwZSkobyxwKSxhPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO2EudW5wYWNrZWRTaGFwZT1yO2NvbnN0IHU9W1wiY29sXCIsXCJyb3dcIl0sYz1gXFxuICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQodCxlLGEpLnJvdXRpbmVCb2R5fVxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHt0fSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKHUsbCl9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoYyxbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBmPXVbMV0sZD11WzBdO2lmKDE9PT1kKXtjb25zdCBuPWBcXG4gICAgICAgICAgZmxvYXQgJHt0fShpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgICAgaW50IG9mZnNldF8ke2V9ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke2Z9LCAke2R9KTtcXG4gICAgICAgICAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMzKHJvdywgY29sLCBvZmZzZXRfJHtlfSksIHZlYzMoJHtvWzFdfSwgMSwgMSkpO1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGluZGV4ICsgMC41KSAvICR7Zn0uMCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShuLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX1pZigxPT09Zil7Y29uc3Qgbj1gXFxuICAgICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICAgIGludCBvZmZzZXRfJHtlfSA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtmfSwgJHtkfSk7XFxuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7ZX0pLCB2ZWMzKCR7b1sxXX0sIDEsIDEpKTtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoaW5kZXggKyAwLjUpIC8gJHtkfS4wLCAwLjUpO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Y29uc3QgaD1gXFxuICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgaW50IGluZGV4ID0gY29sICogJHtvWzFdfSArIHJvdztcXG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtmfSwgJHtkfSwgaW5kZXgpO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoaCxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyM0QodCxlLG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLG89clsxXSpyWzJdLHU9clsyXSx7bmV3U2hhcGU6YyxrZXB0RGltczpsfT0oMCxhLnNxdWVlemVTaGFwZSkocikscD1jO2lmKHAubGVuZ3RoPHIubGVuZ3RoKXtjb25zdCBvPSgwLHMuc3F1ZWV6ZUlucHV0U2hhcGUpKHIscCksYT1bXCJiYXRjaFwiLFwiY29sXCIsXCJyb3dcIl0sdT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG4pKTt1LnVucGFja2VkU2hhcGU9bztjb25zdCBjPXRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSx1KSxmPWwucmV2ZXJzZSgpLGQ9YFxcbiAgICAgICAgICAke2Mucm91dGluZUJvZHl9XFxuICAgICAgICAgIGZsb2F0ICR7dH0oaW50IGJhdGNoLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgICAgcmV0dXJuICR7dH0oJHsoMCxzLmdldFNxdWVlemVkUGFyYW1zKShhLGYpfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGQsYy5kZXBlbmRlbmNpZXMpfWNvbnN0IGY9YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCBkZXB0aCwgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgICAgICAgICBpbnQgaW5kZXggPSBkZXB0aCAqICR7b30gKyBjb2wgKiAke3V9ICsgcm93O1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7bi53aWR0aH0sICR7bi5oZWlnaHR9LCBpbmRleCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoZixbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyNEQodCxlLG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLG89clszXSxhPXJbMl0qbyxzPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7clsxXSphfSArIGNvbCAqICR7YX0gK1xcbiAgICAgICAgICAgICAgZGVwdGgyICogJHtvfSArIGRlcHRoO1xcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke24ud2lkdGh9LCAke24uaGVpZ2h0fSwgaW5kZXgpO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUocyxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1nZXRVbnBhY2tlZFNhbXBsZXI1RCh0LGUsbil7Y29uc3Qgcj1uLnVucGFja2VkU2hhcGUsbz1yWzRdLHU9clszXSpvLGM9clsyXSp1LGw9clsxXSpjLHtuZXdTaGFwZTpwLGtlcHREaW1zOmZ9PSgwLGEuc3F1ZWV6ZVNoYXBlKShyKTtpZihwLmxlbmd0aDxyLmxlbmd0aCl7Y29uc3Qgbz0oMCxzLnNxdWVlemVJbnB1dFNoYXBlKShyLHApLGE9W1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIixcImRlcHRoM1wiXSx1PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO3UudW5wYWNrZWRTaGFwZT1vO2NvbnN0IGM9YFxcbiAgICAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSx1KS5yb3V0aW5lQm9keX1cXG4gICAgICAgICAgZmxvYXQgJHt0fShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHt0fSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKGEsZil9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoYyxbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCJdKX1jb25zdCBkPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7bH0gKyBjb2wgKiAke2N9ICsgZGVwdGggKiAke3V9ICtcXG4gICAgICAgICAgZGVwdGgzICogJHtvfSArIGRlcHRoMjtcXG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtuLndpZHRofSwgJHtuLmhlaWdodH0sIGluZGV4KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGQsW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyNkQodCxlLG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLG89cls1XSx1PXJbNF0qbyxjPXJbM10qdSxsPXJbMl0qYyxwPXJbMV0qbCx7bmV3U2hhcGU6ZixrZXB0RGltczpkfT0oMCxhLnNxdWVlemVTaGFwZSkocik7aWYoZi5sZW5ndGg8ci5sZW5ndGgpe2NvbnN0IG89KDAscy5zcXVlZXplSW5wdXRTaGFwZSkocixmKSxhPVtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCIsXCJkZXB0aDNcIixcImRlcHRoNFwiXSx1PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO3UudW5wYWNrZWRTaGFwZT1vO2NvbnN0IGM9YFxcbiAgICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQodCxlLHUpLnJvdXRpbmVCb2R5fVxcbiAgICAgICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuICR7dH0oJHsoMCxzLmdldFNxdWVlemVkUGFyYW1zKShhLGQpfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShjLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIl0pfWNvbnN0IGg9YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICAgICAgaW50IGluZGV4ID0gcm93ICogJHtwfSArIGNvbCAqICR7bH0gKyBkZXB0aCAqICR7Y30gK1xcbiAgICAgICAgICAgIGRlcHRoMiAqICR7dX0gKyBkZXB0aDMgKiAke299ICsgZGVwdGg0O1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7bi53aWR0aH0sICR7bi5oZWlnaHR9LCBpbmRleCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShoLFtcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIixcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX10b1ZlYygpe2NvbnN0IHQ9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQsZT10LnNoYXBlLmxlbmd0aCxuPXQuc3RyaWRlcyxyPXQud2lkdGgsbz10LmhlaWdodCxhPVtdO2ZvcihsZXQgdD0wO3Q8ZS0xOysrdClhLnB1c2goYFxcbiAgICAgICAgY1ske3R9XSA9IG9mZnNldCAvICR7blt0XX07YCksYS5wdXNoKGBcXG4gICAgICAgIG9mZnNldCAtPSBjWyR7dH1dICogJHtuW3RdfTtgKTthLnB1c2goYFxcbiAgICAgICAgY1ske2UtMX1dID0gb2Zmc2V0O2ApO2NvbnN0IHM9YFxcbiAgICAgIHZvaWQgdG9WZWModmVjMiB0ZXhDb29yZHMsIG91dCBpbnQgY1ske2V9XSkge1xcbiAgICAgICAgaW50IG9mZnNldCA9IGNvb3Jkc1RvT2Zmc2V0KHRleENvb3JkcywgJHtyfSwgJHtvfSk7XFxuICAgICAgICAke2Euam9pbihcIlwiKX1cXG4gICAgICB9XFxuICAgICAgdm9pZCB0b1ZlYyhpbnQgb2Zmc2V0LCBvdXQgaW50IGNbJHtlfV0pIHtcXG4gICAgICAgICR7YS5qb2luKFwiXCIpfVxcbiAgICAgIH1cXG4gICAgYDtyZXR1cm57dG9WZWM6bmV3IGkuR2xzbExpYlJvdXRpbmUocyxbXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9fXZhbHVlRnJvbSgpe2NvbnN0IHQ9e307cmV0dXJuIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKChlLG4pPT57Y29uc3Qgcj10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tuXSxvPShyLnVucGFja2VkU2hhcGUubGVuZ3RoPjA/ci51bnBhY2tlZFNoYXBlOnIuc2hhcGUpLmxlbmd0aDtsZXQgYT1gXyR7ZX1gO3RbYV09bmV3IGkuR2xzbExpYlJvdXRpbmUodGhpcy5nZXRWYWx1ZUZyb21TaW5nbGUoZSxvLHIud2lkdGgsci5oZWlnaHQsITEpLFtgc2hhcGVVdGlscy5pbmRpY2VzVG9PZmZzZXQke2F9YCxcImNvb3JkaW5hdGVzLm9mZnNldFRvQ29vcmRzXCIsXCJmcmFnY29sb3IuZ2V0Q29sb3JBc0Zsb2F0XCJdKSxhKz1cIl9UXCIsdFthXT1uZXcgaS5HbHNsTGliUm91dGluZSh0aGlzLmdldFZhbHVlRnJvbVNpbmdsZShlLG8sci53aWR0aCxyLmhlaWdodCwhMCksW2BzaGFwZVV0aWxzLmluZGljZXNUb09mZnNldCR7YX1gLFwiY29vcmRpbmF0ZXMub2Zmc2V0VG9Db29yZHNcIixcImZyYWdjb2xvci5nZXRDb2xvckFzRmxvYXRcIl0pfSkpLHR9Z2V0VmFsdWVGcm9tU2luZ2xlKHQsZSxuLHIsaSl7bGV0IGE9YF8ke3R9YDtyZXR1cm4gaSYmKGErPVwiX1RcIiksYFxcbiAgICAgICAgZmxvYXQgJHthfShpbnQgbVske2V9XSkge1xcbiAgICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0JHthfShtKTtcXG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7bn0sICR7cn0pO1xcbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgkeygwLG8uZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKS50ZXh0dXJlMkR9KCR7dH0sIGNvb3JkcykpO1xcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBgfWdldFBhY2tlZFZhbHVlRnJvbSh0LGUsbixyLGkpe2xldCBhPWBfJHt0fV9QYWNrYDtyZXR1cm4gaSYmKGErPVwiX1RcIiksYFxcbiAgICAgICAgdmVjNCAke2F9KGludCBtWyR7ZX1dKSB7XFxuICAgICAgICAgIGludCBvZmZzZXQgPSBpbmRpY2VzVG9PZmZzZXRfJHt0fShtKTtcXG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7bn0sICR7cn0pO1xcbiAgICAgICAgICByZXR1cm4gJHsoMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfSgke3R9LCBjb29yZHMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgYH19ZS5Db29yZHNHbHNsTGliPXV9LDg1MjA6KHQsZSk9PntcInVzZSBzdHJpY3RcIjt2YXIgbjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlRvcG9sb2dpY2FsU29ydEdsc2xSb3V0aW5lcz1lLkdsc2xMaWJSb3V0aW5lTm9kZT1lLkdsc2xMaWJSb3V0aW5lPWUuR2xzbExpYj1lLkdsc2xDb250ZXh0PWUuRnVuY3Rpb25UeXBlPXZvaWQgMCwobj1lLkZ1bmN0aW9uVHlwZXx8KGUuRnVuY3Rpb25UeXBlPXt9KSlbbi5WYWx1ZUJhc2VkPTBdPVwiVmFsdWVCYXNlZFwiLG5bbi5Qb3NpdGlvbmFsPTFdPVwiUG9zaXRpb25hbFwiLGUuR2xzbENvbnRleHQ9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4scil7dGhpcy5nbENvbnRleHQ9dCx0aGlzLnByb2dyYW1JbmZvPWUsdGhpcy5pbnB1dFRleHR1cmVMYXlvdXRzPW4sdGhpcy5vdXRwdXRUZXh0dXJlTGF5b3V0PXJ9fSxlLkdsc2xMaWI9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5jb250ZXh0PXR9fSxlLkdsc2xMaWJSb3V0aW5lPWNsYXNze2NvbnN0cnVjdG9yKHQsZSl7dGhpcy5yb3V0aW5lQm9keT10LHRoaXMuZGVwZW5kZW5jaWVzPWV9fSxlLkdsc2xMaWJSb3V0aW5lTm9kZT1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUsbil7dGhpcy5uYW1lPXQsdGhpcy5kZXBlbmRlbmNpZXM9bnx8W10sZSYmKHRoaXMucm91dGluZUJvZHk9ZSl9YWRkRGVwZW5kZW5jeSh0KXt0JiZ0aGlzLmRlcGVuZGVuY2llcy5wdXNoKHQpfX0sZS5Ub3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXM9Y2xhc3N7c3RhdGljIHJldHVybk9yZGVyZWROb2Rlcyh0KXtpZighdHx8MD09PXQubGVuZ3RoKXJldHVybltdO2lmKDE9PT10Lmxlbmd0aClyZXR1cm4gdDtjb25zdCBlPW5ldyBTZXQsbj1uZXcgU2V0LHI9bmV3IEFycmF5O3JldHVybiB0aGlzLmNyZWF0ZU9yZGVyZWROb2Rlcyh0LGUsbixyKSxyfXN0YXRpYyBjcmVhdGVPcmRlcmVkTm9kZXModCxlLG4scil7Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDsrK2kpdGhpcy5kZnNUcmF2ZXJzZSh0W2ldLGUsbixyKX1zdGF0aWMgZGZzVHJhdmVyc2UodCxlLG4scil7aWYoIXR8fG4uaGFzKHQubmFtZSkpcmV0dXJuO2lmKGUuaGFzKHQubmFtZSkpdGhyb3cgbmV3IEVycm9yKFwiQ3ljbGljIGRlcGVuZGVuY3kgZGV0ZWN0ZWQuIENhbid0IHRvcG9sb2dpY2FsbHkgc29ydCByb3V0aW5lcyBuZWVkZWQgZm9yIHNoYWRlci5cIik7ZS5hZGQodC5uYW1lKTtjb25zdCBpPXQuZGVwZW5kZW5jaWVzO2lmKGkmJmkubGVuZ3RoPjApZm9yKGxldCB0PTA7dDxpLmxlbmd0aDsrK3QpdGhpcy5kZnNUcmF2ZXJzZShpW3RdLGUsbixyKTtyLnB1c2godCksbi5hZGQodC5uYW1lKSxlLmRlbGV0ZSh0Lm5hbWUpfX19LDczNDE6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuRW5jb2RpbmdHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oODUyMCk7Y2xhc3MgaSBleHRlbmRzIHIuR2xzbExpYntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXRGdW5jdGlvbnMoKXtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHRoaXMuZW5jb2RlRmxvYXQzMigpKSx0aGlzLmRlY29kZUZsb2F0MzIoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1lbmNvZGVGbG9hdDMyKCl7cmV0dXJue2VuY29kZTpuZXcgci5HbHNsTGliUm91dGluZShcImhpZ2hwIHZlYzQgZW5jb2RlKGhpZ2hwIGZsb2F0IGYpIHtcXG4gICAgICAgIHJldHVybiB2ZWM0KGYsIDAuMCwgMC4wLCAwLjApO1xcbiAgICAgIH1cXG4gICAgICAgIFwiKX19ZGVjb2RlRmxvYXQzMigpe3JldHVybntkZWNvZGU6bmV3IHIuR2xzbExpYlJvdXRpbmUoXCJoaWdocCBmbG9hdCBkZWNvZGUoaGlnaHAgdmVjNCByZ2JhKSB7XFxuICAgICAgICByZXR1cm4gcmdiYS5yO1xcbiAgICAgIH1cXG4gICAgICAgIFwiKX19ZW5jb2RlVWludDgoKXtjb25zdCB0PWkuaXNMaXR0bGVFbmRpYW4oKT9cInJnYmEucmdiYT1yZ2JhLmFiZ3I7XCI6XCJcIjtyZXR1cm57ZW5jb2RlOm5ldyByLkdsc2xMaWJSb3V0aW5lKGBcXG4gICAgICBoaWdocCB2ZWM0IGVuY29kZShoaWdocCBmbG9hdCBmKSB7XFxuICAgICAgICBoaWdocCBmbG9hdCBGID0gYWJzKGYpO1xcbiAgICAgICAgaGlnaHAgZmxvYXQgU2lnbiA9IHN0ZXAoMC4wLC1mKTtcXG4gICAgICAgIGhpZ2hwIGZsb2F0IEV4cG9uZW50ID0gZmxvb3IobG9nMihGKSk7XFxuICAgICAgICBoaWdocCBmbG9hdCBNYW50aXNzYSA9IChleHAyKC0gRXhwb25lbnQpICogRik7XFxuICAgICAgICBFeHBvbmVudCA9IGZsb29yKGxvZzIoRikgKyAxMjcuMCkgKyBmbG9vcihsb2cyKE1hbnRpc3NhKSk7XFxuICAgICAgICBoaWdocCB2ZWM0IHJnYmE7XFxuICAgICAgICByZ2JhWzBdID0gMTI4LjAgKiBTaWduICArIGZsb29yKEV4cG9uZW50KmV4cDIoLTEuMCkpO1xcbiAgICAgICAgcmdiYVsxXSA9IDEyOC4wICogbW9kKEV4cG9uZW50LDIuMCkgKyBtb2QoZmxvb3IoTWFudGlzc2EqMTI4LjApLDEyOC4wKTtcXG4gICAgICAgIHJnYmFbMl0gPSBmbG9vcihtb2QoZmxvb3IoTWFudGlzc2EqZXhwMigyMy4wIC04LjApKSxleHAyKDguMCkpKTtcXG4gICAgICAgIHJnYmFbM10gPSBmbG9vcihleHAyKDIzLjApKm1vZChNYW50aXNzYSxleHAyKC0xNS4wKSkpO1xcbiAgICAgICAgJHt0fVxcbiAgICAgICAgcmdiYSA9IHJnYmEgLyAyNTUuMDsgLy8gdmFsdWVzIG5lZWQgdG8gYmUgbm9ybWFsaXplZCB0byBbMCwxXVxcbiAgICAgICAgcmV0dXJuIHJnYmE7XFxuICAgIH1cXG4gICAgICAgIGApfX1kZWNvZGVVaW50OCgpe2NvbnN0IHQ9aS5pc0xpdHRsZUVuZGlhbigpP1wicmdiYS5yZ2JhPXJnYmEuYWJncjtcIjpcIlwiO3JldHVybntkZWNvZGU6bmV3IHIuR2xzbExpYlJvdXRpbmUoYFxcbiAgICAgICAgaGlnaHAgZmxvYXQgZGVjb2RlKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgICAgICAgICByZ2JhID0gcmdiYSAqIDI1NS4wOyAvLyB2YWx1ZXMgbmVlZCB0byBiZSBkZS1ub3JtYWxpemVkIGZyb20gWzAsMV0gdG8gWzAsMjU1XVxcbiAgICAgICAgICAke3R9XFxuICAgICAgICAgIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyOC4wLHJnYmFbMF0pKjIuMDtcXG4gICAgICAgICAgaGlnaHAgZmxvYXQgRXhwb25lbnQgPSAyLjAgKiBtb2QocmdiYVswXSwxMjguMCkgKyBzdGVwKDEyOC4wLHJnYmFbMV0pIC0gMTI3LjA7XFxuICAgICAgICAgIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMV0sMTI4LjApKjY1NTM2LjAgKyByZ2JhWzJdKjI1Ni4wICtyZ2JhWzNdICsgZmxvYXQoMHg4MDAwMDApO1xcbiAgICAgICAgICBoaWdocCBmbG9hdCBSZXN1bHQgPSAgU2lnbiAqIGV4cDIoRXhwb25lbnQpICogKE1hbnRpc3NhICogZXhwMigtMjMuMCApKTtcXG4gICAgICAgICAgcmV0dXJuIFJlc3VsdDtcXG4gICAgICB9XFxuICAgICAgICBgKX19c3RhdGljIGlzTGl0dGxlRW5kaWFuKCl7Y29uc3QgdD1uZXcgQXJyYXlCdWZmZXIoNCksZT1uZXcgVWludDMyQXJyYXkodCksbj1uZXcgVWludDhBcnJheSh0KTtpZihlWzBdPTM3MzU5Mjg1NTksMjM5PT09blswXSlyZXR1cm4hMDtpZigyMjI9PT1uWzBdKXJldHVybiExO3Rocm93IG5ldyBFcnJvcihcInVua25vd24gZW5kaWFubmVzc1wiKX19ZS5FbmNvZGluZ0dsc2xMaWI9aX0sOTg5NDoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5GcmFnQ29sb3JHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oODUyMCksaT1uKDUwNjApO2NsYXNzIG8gZXh0ZW5kcyByLkdsc2xMaWJ7Y29uc3RydWN0b3IodCl7c3VwZXIodCl9Z2V0RnVuY3Rpb25zKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLnNldEZyYWdDb2xvcigpKSx0aGlzLmdldENvbG9yQXNGbG9hdCgpKX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fXNldEZyYWdDb2xvcigpe2NvbnN0IHQ9KDAsaS5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO3JldHVybntzZXRGcmFnQ29sb3I6bmV3IHIuR2xzbExpYlJvdXRpbmUoYFxcbiAgICAgICAgdm9pZCBzZXRGcmFnQ29sb3IoZmxvYXQgdmFsdWUpIHtcXG4gICAgICAgICAgICAke3Qub3V0cHV0fSA9IGVuY29kZSh2YWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICBgLFtcImVuY29kaW5nLmVuY29kZVwiXSl9fWdldENvbG9yQXNGbG9hdCgpe3JldHVybntnZXRDb2xvckFzRmxvYXQ6bmV3IHIuR2xzbExpYlJvdXRpbmUoXCJcXG4gICAgICAgIGZsb2F0IGdldENvbG9yQXNGbG9hdCh2ZWM0IGNvbG9yKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZShjb2xvcik7XFxuICAgICAgICB9XFxuICAgICAgICBcIixbXCJlbmNvZGluZy5kZWNvZGVcIl0pfX19ZS5GcmFnQ29sb3JHbHNsTGliPW99LDI4NDg6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnJlcGxhY2VJbmxpbmVzPXZvaWQgMDtjb25zdCBuPS9AaW5saW5lW1xcc1xcblxccl0rKFxcdyspW1xcc1xcblxccl0rKFswLTlhLXpBLVpfXSspXFxzKlxcKChbXildKilcXClcXHMqeygoW159XXxbXFxuXFxyXSkqKX0vZ207ZS5yZXBsYWNlSW5saW5lcz1mdW5jdGlvbih0KXtjb25zdCBlPXt9O2xldCByO2Zvcig7bnVsbCE9PShyPW4uZXhlYyh0KSk7KXtjb25zdCB0PXJbM10uc3BsaXQoXCIsXCIpLm1hcCgodD0+e2NvbnN0IGU9dC50cmltKCkuc3BsaXQoXCIgXCIpO3JldHVybiBlJiYyPT09ZS5sZW5ndGg/e3R5cGU6ZVswXSxuYW1lOmVbMV19Om51bGx9KSkuZmlsdGVyKCh0PT5udWxsIT09dCkpO2VbclsyXV09e3BhcmFtczp0LGJvZHk6cls0XX19Zm9yKGNvbnN0IG4gaW4gZSl7Y29uc3QgaT1cIihcXFxcdyspP1xcXFxzKyhbXzAtOWEtekEtWl0rKVxcXFxzKz1cXFxccytfX0ZVTkNfX1xcXFwoKC4qKVxcXFwpXFxcXHMqO1wiLnJlcGxhY2UoXCJfX0ZVTkNfX1wiLG4pLG89bmV3IFJlZ0V4cChpLFwiZ21cIik7Zm9yKDtudWxsIT09KHI9by5leGVjKHQpKTspe2NvbnN0IGk9clsxXSxvPXJbMl0sYT1yWzNdLnNwbGl0KFwiLFwiKSxzPWk/YCR7aX0gJHtvfTtgOlwiXCI7bGV0IHU9ZVtuXS5ib2R5LGM9XCJcIjtlW25dLnBhcmFtcy5mb3JFYWNoKCgodCxlKT0+e3QmJihjKz1gJHt0LnR5cGV9ICR7dC5uYW1lfSA9ICR7YVtlXX07XFxuYCl9KSksdT1gJHtjfVxcbiAke3V9YCx1PXUucmVwbGFjZShcInJldHVyblwiLGAke299ID0gYCk7Y29uc3QgbD1gXFxuICAgICAgJHtzfVxcbiAgICAgIHtcXG4gICAgICAgICR7dX1cXG4gICAgICB9XFxuICAgICAgYDt0PXQucmVwbGFjZShyWzBdLGwpfX1yZXR1cm4gdC5yZXBsYWNlKG4sXCJcIil9fSw4ODc5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLkdsc2xQcmVwcm9jZXNzb3I9dm9pZCAwO2NvbnN0IHI9big4NTIwKSxpPW4oMjg0OCksbz1uKDU0ODMpLGE9big1MDYwKTtlLkdsc2xQcmVwcm9jZXNzb3I9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4saSl7dGhpcy5saWJzPXt9LHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGg9e30sdGhpcy5jb250ZXh0PW5ldyByLkdsc2xDb250ZXh0KHQsZSxuLGkpLE9iamVjdC5rZXlzKG8uZ2xzbFJlZ2lzdHJ5KS5mb3JFYWNoKCh0PT57Y29uc3QgZT1uZXcgby5nbHNsUmVnaXN0cnlbdF0odGhpcy5jb250ZXh0KTt0aGlzLmxpYnNbdF09ZX0pKTtjb25zdCBhPXRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGg7Zm9yKGNvbnN0IHQgaW4gdGhpcy5saWJzKXtjb25zdCBlPXRoaXMubGlic1t0XS5nZXRGdW5jdGlvbnMoKTtmb3IoY29uc3QgbiBpbiBlKXtjb25zdCBpPXQrXCIuXCIrbjtsZXQgbzthW2ldPyhvPWFbaV0sby5yb3V0aW5lQm9keT1lW25dLnJvdXRpbmVCb2R5KToobz1uZXcgci5HbHNsTGliUm91dGluZU5vZGUoaSxlW25dLnJvdXRpbmVCb2R5KSxhW2ldPW8pO2NvbnN0IHM9ZVtuXS5kZXBlbmRlbmNpZXM7aWYocylmb3IobGV0IHQ9MDt0PHMubGVuZ3RoOysrdClpZihhW3NbdF1dKW8uYWRkRGVwZW5kZW5jeShhW3NbdF1dKTtlbHNle2NvbnN0IGU9bmV3IHIuR2xzbExpYlJvdXRpbmVOb2RlKHNbdF0pO2Fbc1t0XV09ZSxvLmFkZERlcGVuZGVuY3koZSl9fX19cHJlcHJvY2Vzcygpe2NvbnN0IHQ9dGhpcy5jb250ZXh0LnByb2dyYW1JbmZvO2xldCBlPXQuc2hhZGVyU291cmNlO3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaGFzTWFpbnx8KGU9YCR7ZX1cXG4gICAgICAkeygwLGEuZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24sdGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoKX1gKSxlPSgwLGkucmVwbGFjZUlubGluZXMpKGUpLGAkeygwLGEuZ2V0RnJhZ1NoYWRlclByZWFtYmxlKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pfVxcbiAgICAke3RoaXMuZ2V0VW5pZm9ybXModC5pbnB1dE5hbWVzLHQudmFyaWFibGVzKX1cXG4gICAgJHt0aGlzLmdldEltcG9ydHMoZSl9XFxuICAgICR7ZX1gfWdldEltcG9ydHModCl7Y29uc3QgZT10aGlzLnNlbGVjdEdsc2xMaWJSb3V0aW5lc1RvQmVJbmNsdWRlZCh0KTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuXCJcIjtsZXQgbj1cIlwiO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7Kyt0KXtpZighZVt0XS5yb3V0aW5lQm9keSl0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgYm9keSBmb3IgdGhlIEdsc2wgTGlicmFyeSByb3V0aW5lOiAke2VbdF0ubmFtZX1gKTtuKz1lW3RdLnJvdXRpbmVCb2R5K1wiXFxuXCJ9cmV0dXJuIG59c2VsZWN0R2xzbExpYlJvdXRpbmVzVG9CZUluY2x1ZGVkKHQpe2NvbnN0IGU9W107cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGgpLmZvckVhY2goKG49Pntjb25zdCByPW4uc3BsaXQoXCIuXCIpWzFdOy0xIT09dC5pbmRleE9mKHIpJiZlLnB1c2godGhpcy5nbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaFtuXSl9KSksci5Ub3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXMucmV0dXJuT3JkZXJlZE5vZGVzKGUpfWdldFVuaWZvcm1zKHQsZSl7Y29uc3Qgbj1bXTtpZih0KWZvcihjb25zdCBlIG9mIHQpbi5wdXNoKGB1bmlmb3JtIHNhbXBsZXIyRCAke2V9O2ApO2lmKGUpZm9yKGNvbnN0IHQgb2YgZSluLnB1c2goYHVuaWZvcm0gJHt0LnR5cGV9ICR7dC5uYW1lfSR7dC5hcnJheUxlbmd0aD9gWyR7dC5hcnJheUxlbmd0aH1dYDpcIlwifTtgKTtyZXR1cm4gbi5qb2luKFwiXFxuXCIpfX19LDU0ODM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZ2xzbFJlZ2lzdHJ5PXZvaWQgMDtjb25zdCByPW4oNTEwNyksaT1uKDczNDEpLG89big5ODk0KSxhPW4oMjY1NSkscz1uKDM4OTEpO2UuZ2xzbFJlZ2lzdHJ5PXtlbmNvZGluZzppLkVuY29kaW5nR2xzbExpYixmcmFnY29sb3I6by5GcmFnQ29sb3JHbHNsTGliLHZlYzpzLlZlY0dsc2xMaWIsc2hhcGVVdGlsczphLlNoYXBlVXRpbHNHbHNsTGliLGNvb3JkaW5hdGVzOnIuQ29vcmRzR2xzbExpYn19LDI2NTU6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuU2hhcGVVdGlsc0dsc2xMaWI9dm9pZCAwO2NvbnN0IHI9big4NTIwKTtjbGFzcyBpIGV4dGVuZHMgci5HbHNsTGlie2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpfWdldEZ1bmN0aW9ucygpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdGhpcy5iY2FzdEluZGV4KCkpLHRoaXMuYmNhc3RNYXRtdWxJbmRleCgpKSx0aGlzLm9mZnNldFRvSW5kaWNlcygpKSx0aGlzLmluZGljZXNUb09mZnNldCgpKSx0aGlzLmluY3JlbWVudEluZGljZXMoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1iY2FzdEluZGV4KCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGgsZT17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKG4saSk9Pntjb25zdCBvPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW2ldLnVucGFja2VkU2hhcGU7aWYoby5sZW5ndGg8PXQpe2NvbnN0IGk9by5sZW5ndGgsYT10LWkscz1gYmNhc3RJbmRpY2VzXyR7bn1gO2xldCB1PVwiXCI7Zm9yKGxldCB0PTA7dDxpOysrdCl1Kz1gXFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7dH1dID0gaW50KCBtb2QoZmxvYXQoYmNhc3RlZEluZGljZXNbJHthK3R9XSksICR7b1t0XX0uMCkgKTtcXG4gICAgICAgICAgYDtjb25zdCBjPWBcXG4gICAgICAgIHZvaWQgJHtzfSAoaW50IGJjYXN0ZWRJbmRpY2VzWyR7dH1dLCBvdXQgaW50IHJlYWxJbmRpY2VzWyR7aX1dKSB7XFxuICAgICAgICAgICR7dX1cXG4gICAgICAgIH1cXG4gICAgICAgIGA7ZVtzXT1uZXcgci5HbHNsTGliUm91dGluZShjKX19KSksZX1iY2FzdE1hdG11bEluZGV4KCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGgsZT17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKG4saSk9Pntjb25zdCBvPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW2ldLnNoYXBlO2lmKCEoby5sZW5ndGg8Mnx8by5sZW5ndGg+dCkpe2NvbnN0IGk9by5sZW5ndGgsYT10LWkscz1gYmNhc3RNYXRtdWxJbmRpY2VzXyR7bn1gO2xldCB1PVwiXCI7Zm9yKGxldCB0PTA7dDxpLTI7Kyt0KXUrPWBcXG4gICAgICAgICAgcmVhbEluZGljZXNbJHt0fV0gPSBpbnQoIG1vZChmbG9hdChiY2FzdGVkSW5kaWNlc1ske2ErdH1dKSwgJHtvW3RdfS4wKSApO1xcbiAgICAgICAgICBgO2NvbnN0IGM9YFxcbiAgICAgICAgdm9pZCAke3N9KGludCBiY2FzdGVkSW5kaWNlc1ske3R9XSwgb3V0IGludCByZWFsSW5kaWNlc1ske2l9XSkge1xcbiAgICAgICAgICAke3V9XFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7aS0xfV0gPSBiY2FzdGVkSW5kaWNlc1ske3QtMX1dO1xcbiAgICAgICAgICByZWFsSW5kaWNlc1ske2ktMn1dID0gYmNhc3RlZEluZGljZXNbJHt0LTJ9XTtcXG4gICAgICAgIH1cXG4gICAgICAgIGA7ZVtzXT1uZXcgci5HbHNsTGliUm91dGluZShjKX19KSksZX1pbmRpY2VzVG9PZmZzZXQoKXtjb25zdCB0PXt9O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgoZSxuKT0+e2NvbnN0IG89dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc2hhcGUsYT10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tuXS5zdHJpZGVzLHM9by5sZW5ndGg7bGV0IHU9YGluZGljZXNUb09mZnNldF8ke2V9YDt0W3VdPW5ldyByLkdsc2xMaWJSb3V0aW5lKGkuaW5kZXhUb09mZnNldFNpbmdsZSh1LHMsYSkpLHU9YGluZGljZXNUb09mZnNldF8ke2V9X1RgLHRbdV09bmV3IHIuR2xzbExpYlJvdXRpbmUoaS5pbmRleFRvT2Zmc2V0U2luZ2xlKHUscyxhLnNsaWNlKCkucmV2ZXJzZSgpKSl9KSksdH1zdGF0aWMgaW5kZXhUb09mZnNldFNpbmdsZSh0LGUsbil7bGV0IHI9XCJcIjtmb3IobGV0IHQ9ZS0xO3Q+PTA7LS10KXIrPWBcXG4gICAgICAgIG9mZnNldCArPSBpbmRpY2VzWyR7dH1dICogJHtuW3RdfTtcXG4gICAgICAgIGA7cmV0dXJuYFxcbiAgICAgIGludCAke3R9KGludCBpbmRpY2VzWyR7ZX1dKSB7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcXG4gICAgICAgICR7cn1cXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XFxuICAgICAgfVxcbiAgICAgIGB9b2Zmc2V0VG9JbmRpY2VzKCl7Y29uc3QgdD17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKGUsbik9Pntjb25zdCBvPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW25dLnNoYXBlLGE9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc3RyaWRlcyxzPW8ubGVuZ3RoO2xldCB1PWBvZmZzZXRUb0luZGljZXNfJHtlfWA7dFt1XT1uZXcgci5HbHNsTGliUm91dGluZShpLm9mZnNldFRvSW5kaWNlc1NpbmdsZSh1LHMsYSkpLHU9YG9mZnNldFRvSW5kaWNlc18ke2V9X1RgLHRbdV09bmV3IHIuR2xzbExpYlJvdXRpbmUoaS5vZmZzZXRUb0luZGljZXNTaW5nbGUodSxzLGEuc2xpY2UoKS5yZXZlcnNlKCkpKX0pKSx0fXN0YXRpYyBvZmZzZXRUb0luZGljZXNTaW5nbGUodCxlLG4pe2NvbnN0IHI9W107Zm9yKGxldCB0PTA7dDxlLTE7Kyt0KXIucHVzaChgXFxuICAgICAgaW5kaWNlc1ske3R9XSA9IG9mZnNldCAvICR7blt0XX07YCksci5wdXNoKGBcXG4gICAgICAgIG9mZnNldCAtPSBpbmRpY2VzWyR7dH1dICogJHtuW3RdfTtgKTtyZXR1cm4gci5wdXNoKGBcXG4gICAgICBpbmRpY2VzWyR7ZS0xfV0gPSBvZmZzZXQ7YCksYFxcbiAgICAgIHZvaWQgJHt0fShpbnQgb2Zmc2V0LCBvdXQgaW50IGluZGljZXNbJHtlfV0pIHtcXG4gICAgICAgICR7ci5qb2luKFwiXCIpfVxcbiAgICAgIH1cXG4gICAgICBgfWluY3JlbWVudEluZGljZXMoKXtjb25zdCB0PXt9O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgoZSxuKT0+e2NvbnN0IGk9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc2hhcGUsbz1pLmxlbmd0aCxhPWBpbmNyZW1lbnRJbmRpY2VzXyR7ZX1gO2xldCBzPVwiXCI7Zm9yKGxldCB0PTA7dDxvOysrdClzKz1gXFxuICAgICAgICBzaGFwZVske3R9XSA9ICR7aVt0XX07YDtjb25zdCB1PWBcXG4gICAgICAgIHZvaWQgJHthfShpbnQgYXhpcywgb3V0IGludCBpbmRpY2VzWyR7b31dKSB7XFxuICAgICAgICAgIGludCBzaGFwZVske299XTtcXG4gICAgICAgICAgJHtzfTtcXG4gICAgICAgICAgZm9yKGludCBpID0gJHtvfSAtMSA7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICAgICAgaWYoaSA+IGF4aXMpIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIGluZGljZXNbaV0gKz0gMTtcXG4gICAgICAgICAgICBpZihpbmRpY2VzW2ldIDwgc2hhcGVbaV0pIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbmRpY2VzW2ldID0gMDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgYDt0W2FdPW5ldyByLkdsc2xMaWJSb3V0aW5lKHUpfSkpLHR9fWUuU2hhcGVVdGlsc0dsc2xMaWI9aX0sNTA2MDoodCxlKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluPWUuZ2V0RnJhZ1NoYWRlclByZWFtYmxlPWUuZ2V0VmVydGV4U2hhZGVyU291cmNlPWUuZ2V0R2xzbD12b2lkIDA7Y29uc3Qgbj17dmVyc2lvbjpcIlwiLGF0dHJpYnV0ZTpcImF0dHJpYnV0ZVwiLHZhcnlpbmdWZXJ0ZXg6XCJ2YXJ5aW5nXCIsdmFyeWluZ0ZyYWc6XCJ2YXJ5aW5nXCIsdGV4dHVyZTJEOlwidGV4dHVyZTJEXCIsb3V0cHV0OlwiZ2xfRnJhZ0NvbG9yXCIsb3V0cHV0RGVjbGFyYXRpb246XCJcIn0scj17dmVyc2lvbjpcIiN2ZXJzaW9uIDMwMCBlc1wiLGF0dHJpYnV0ZTpcImluXCIsdmFyeWluZ1ZlcnRleDpcIm91dFwiLHZhcnlpbmdGcmFnOlwiaW5cIix0ZXh0dXJlMkQ6XCJ0ZXh0dXJlXCIsb3V0cHV0Olwib3V0cHV0Q29sb3JcIixvdXRwdXREZWNsYXJhdGlvbjpcIm91dCB2ZWM0IG91dHB1dENvbG9yO1wifTtmdW5jdGlvbiBpKHQpe3JldHVybiAxPT09dD9uOnJ9ZS5nZXRHbHNsPWksZS5nZXRWZXJ0ZXhTaGFkZXJTb3VyY2U9ZnVuY3Rpb24odCl7Y29uc3QgZT1pKHQpO3JldHVybmAke2UudmVyc2lvbn1cXG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgICAgJHtlLmF0dHJpYnV0ZX0gdmVjMyBwb3NpdGlvbjtcXG4gICAgICAke2UuYXR0cmlidXRlfSB2ZWMyIHRleHR1cmVDb29yZDtcXG5cXG4gICAgICAke2UudmFyeWluZ1ZlcnRleH0gdmVjMiBUZXhDb29yZHM7XFxuXFxuICAgICAgdm9pZCBtYWluKClcXG4gICAgICB7XFxuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMS4wKTtcXG4gICAgICAgICAgVGV4Q29vcmRzID0gdGV4dHVyZUNvb3JkO1xcbiAgICAgIH1gfSxlLmdldEZyYWdTaGFkZXJQcmVhbWJsZT1mdW5jdGlvbih0KXtjb25zdCBlPWkodCk7cmV0dXJuYCR7ZS52ZXJzaW9ufVxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBpbnQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XFxuICAgICR7ZS52YXJ5aW5nRnJhZ30gdmVjMiBUZXhDb29yZHM7XFxuICAgICR7ZS5vdXRwdXREZWNsYXJhdGlvbn1cXG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcXG5cXG4gICAgLy8gQ3VzdG9tIHZlY3RvciB0eXBlcyB0byBoYW5kbGUgaGlnaGVyIGRpbWVuYWxpdGllcy5cXG4gICAgc3RydWN0IGl2ZWM1XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgfTtcXG5cXG4gICAgc3RydWN0IGl2ZWM2XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgICBpbnQgdjtcXG4gICAgfTtcXG5cXG4gICAgaW50IGltb2QoaW50IHgsIGludCB5KSB7XFxuICAgICAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcXG4gICAgfVxcblxcbiAgICBgfSxlLmdldERlZmF1bHRGcmFnU2hhZGVyTWFpbj1mdW5jdGlvbih0LGUpe3JldHVybmBcXG4gIHZvaWQgbWFpbigpIHtcXG4gICAgaW50IGluZGljZXNbJHtlfV07XFxuICAgIHRvVmVjKFRleENvb3JkcywgaW5kaWNlcyk7XFxuICAgIHZlYzQgcmVzdWx0ID0gdmVjNChwcm9jZXNzKGluZGljZXMpKTtcXG4gICAgJHtpKHQpLm91dHB1dH0gPSByZXN1bHQ7XFxuICB9XFxuICBgfX0sMzg5MToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5WZWNHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oODUyMCk7Y2xhc3MgaSBleHRlbmRzIHIuR2xzbExpYntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fWdldEZ1bmN0aW9ucygpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHRoaXMuYmluYXJ5VmVjRnVuY3Rpb25zKCkpLHRoaXMuY29weVZlYygpKSx0aGlzLnNldFZlY0l0ZW0oKSksdGhpcy5nZXRWZWNJdGVtKCkpfWJpbmFyeVZlY0Z1bmN0aW9ucygpe2NvbnN0IHQ9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoLGU9e2FkZDpcIis9XCIsc3ViOlwiLT1cIixtdWw6XCIqPVwiLGRpdjpcIi89XCJ9LG49e307Zm9yKGNvbnN0IGkgaW4gZSl7Y29uc3Qgbz1gJHtpfVZlY2A7bGV0IGE9XCJcIjtmb3IobGV0IG49MDtuPHQ7KytuKWErPWBcXG4gICAgICAgICAgZGVzdFske259XSAke2VbaV19IHNyY1ske259XTtcXG4gICAgICAgICAgYDtjb25zdCBzPWBcXG4gICAgICAgIHZvaWQgJHtvfShpbnQgc3JjWyR7dH1dLCBvdXQgaW50IGRlc3RbJHt0fV0pIHtcXG4gICAgICAgICAgJHthfVxcbiAgICAgICAgfVxcbiAgICAgICAgYDtuW29dPW5ldyByLkdsc2xMaWJSb3V0aW5lKHMpfXJldHVybiBufWNvcHlWZWMoKXtjb25zdCB0PXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aDtsZXQgZT1cIlwiO2ZvcihsZXQgbj0wO248dDsrK24pZSs9YFxcbiAgICAgICAgZGVzdFske259XSA9IHNyY1ske259XTtcXG4gICAgICAgIGA7Y29uc3Qgbj1gXFxuICAgICAgdm9pZCBjb3B5VmVjKGludCBzcmNbJHt0fV0sIG91dCBpbnQgZGVzdFske3R9XSkge1xcbiAgICAgICAgJHtlfVxcbiAgICAgIH1cXG4gICAgICBgO3JldHVybntjb3B5VmVjOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX1zZXRWZWNJdGVtKCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGg7bGV0IGU9YFxcbiAgICAgICAgaWYoaW5kZXggPCAwKVxcbiAgICAgICAgICAgIGluZGV4ID0ke3R9ICsgaW5kZXg7XFxuICAgICAgICBpZiAoaW5kZXggPT0gMClcXG4gICAgICAgICAgICBtWzBdID0gdmFsdWU7XFxuICAgICAgICBgO2ZvcihsZXQgbj0xO248dC0xOysrbillKz1gXFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAke259KVxcbiAgICAgICAgICAgIG1bJHtufV0gPSB2YWx1ZTtcXG4gICAgICAgICAgICBgO2UrPWBcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgICBtWyR7dC0xfV0gPSB2YWx1ZTtcXG4gICAgICAgIGA7Y29uc3Qgbj1gXFxuICAgICAgdm9pZCBzZXRWZWNJdGVtKG91dCBpbnQgbVske3R9XSwgaW50IGluZGV4LCBpbnQgdmFsdWUpIHtcXG4gICAgICAgICR7ZX1cXG4gICAgICB9XFxuICAgICAgICBgO3JldHVybntzZXRWZWNJdGVtOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX1nZXRWZWNJdGVtKCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGg7bGV0IGU9YFxcbiAgICAgICAgaWYoaW5kZXggPCAwKVxcbiAgICAgICAgICAgIGluZGV4ID0gJHt0fSArIGluZGV4O1xcbiAgICAgICAgaWYgKGluZGV4ID09IDApXFxuICAgICAgICAgICAgcmV0dXJuIG1bMF07XFxuICAgICAgYDtmb3IobGV0IG49MTtuPHQtMTsrK24pZSs9YFxcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gJHtufSlcXG4gICAgICAgICAgICByZXR1cm4gbVske259XTtcXG4gICAgICBgO2UrPWBcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgICByZXR1cm4gbVske3QtMX1dO1xcbiAgICAgICAgYDtjb25zdCBuPWBcXG4gICAgICBpbnQgZ2V0VmVjSXRlbShpbnQgbVske3R9XSwgaW50IGluZGV4KSB7XFxuICAgICAgICAke2V9XFxuICAgICAgfVxcbiAgICBgO3JldHVybntnZXRWZWNJdGVtOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX19ZS5WZWNHbHNsTGliPWl9LDgzMTY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuV2ViR0xJbmZlcmVuY2VIYW5kbGVyPXZvaWQgMDtjb25zdCByPW4oNjIzMSksaT1uKDkxNjIpLG89bigyNTE3KSxhPW4oMjQwMykscz1uKDcwMTkpLHU9big4NzEwKSxjPW4oNTYxMSksbD1uKDQwNTcpLHA9bigyMDM5KTtlLldlYkdMSW5mZXJlbmNlSGFuZGxlcj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnNlc3Npb249dCx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfWNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh0LGUpe3JldHVybigwLGwuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksdCxlKX1leGVjdXRlUHJvZ3JhbSh0LGUpe2lmKGUubGVuZ3RoPHQuaW5wdXROYW1lcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBzaXplIG11c3RuJ3QgYmUgbGVzcyB0aGFuICR7dC5pbnB1dE5hbWVzLmxlbmd0aH0uYCk7aWYodC5pbnB1dE5hbWVzLmxlbmd0aCE9PXQuaW5wdXRUeXBlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgbmFtZXMgc2l6ZSBkb2VzIG5vdCBtYXRjaCBpbnB1dCB0eXBlc1wiKTtjb25zdCBuPVtdO2ZvcihsZXQgcj0wO3I8dC5pbnB1dE5hbWVzLmxlbmd0aDsrK3IpbltyXT10aGlzLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoZVtyXSx0LmlucHV0VHlwZXNbcl0pO2NvbnN0IHI9KCh0LGUpPT57Y29uc3Qgbj1lLm1hcCgodD0+YCR7dC51bnBhY2tlZFNoYXBlLmpvaW4oXCIsXCIpfTske3Qud2lkdGh9eCR7dC5oZWlnaHR9YCkpLmpvaW4oXCJfXCIpO2xldCByPXQubmFtZTtyZXR1cm4gdC5jYWNoZUhpbnQmJihyKz1cIltcIit0LmNhY2hlSGludCtcIl1cIikscis9XCI6XCIrbixyfSkodCxuKTtsZXQgaT10aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3Qocik7Y29uc3Qgbz1pP2kucHJvZ3JhbUluZm86XCJmdW5jdGlvblwiPT10eXBlb2YgdC5nZXQ/dC5nZXQoKTp0LGE9KDAsbC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksby5vdXRwdXQuZGltcyxvLm91dHB1dC50ZXh0dXJlVHlwZSkscz10aGlzLmNyZWF0ZVRleHR1cmVEYXRhKGEsby5vdXRwdXQudHlwZSk7cmV0dXJuIGl8fChpPXRoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5idWlsZChvLG4scyksdGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KHIsaSkpLHRoaXMucnVuUHJvZ3JhbShpLG4scyksc31ydW4odCxlKXtyZXR1cm4gdGhpcy5leGVjdXRlUHJvZ3JhbSh0LGUpLnRlbnNvcn1ydW5Qcm9ncmFtKHQsZSxuKXtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbilpZighIWVbbl0uaXNQYWNrZWQhPSh0LnByb2dyYW1JbmZvLmlucHV0VHlwZXNbbl09PT1wLlRleHR1cmVUeXBlLnBhY2tlZCkpdGhyb3cgbmV3IEVycm9yKGBpbnB1dFske259XSBwcm9wZXJ0eSBwYWNrZWQgaW5jb25zaXN0ZW50YCk7aWYoISFuLmlzUGFja2VkIT0odC5wcm9ncmFtSW5mby5vdXRwdXQudGV4dHVyZVR5cGU9PT1wLlRleHR1cmVUeXBlLnBhY2tlZCkpdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0IHByb3BlcnR5IHBhY2tlZCBpbmNvbnNpc3RlbnRcIik7dGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnJ1bih0LGUsbil9Z2V0T3JDcmVhdGVUZXh0dXJlRGF0YSh0LGUpe2xldCBuPXRoaXMuZ2V0VGV4dHVyZURhdGEodC5kYXRhSWQsZT09PXAuVGV4dHVyZVR5cGUucGFja2VkKTtpZighbiYmKG49dGhpcy5nZXRUZXh0dXJlRGF0YSh0LmRhdGFJZCxlIT09cC5UZXh0dXJlVHlwZS5wYWNrZWQpLG4pKXJldHVybiBlPT09cC5UZXh0dXJlVHlwZS5wYWNrZWQ/dGhpcy5wYWNrKG4pOnRoaXMudW5wYWNrKG4pO2lmKCFuKXtjb25zdCByPSgwLGwuY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZSkodGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LHQuZGltcyxlKTtpZihlPT09cC5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKXtjb25zdCBuPTEscj00LGk9dC5kaW1zO2lmKDQ9PT1pLmxlbmd0aCl7Y29uc3Qgbz1baVswXSxNYXRoLmNlaWwoaVsxXSppWzJdKmlbM10vcildLGE9KDAsbC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksbyxlKTtsZXQgcz10Lm51bWJlckRhdGE7aWYoaVsxXSppWzJdKmlbM10lciE9MCl7Y29uc3QgZT1pWzBdLG89aVsxXSppWzJdKmlbM10sYT1NYXRoLmNlaWwobypuL3IpKnI7cz1uZXcgRmxvYXQzMkFycmF5KGUqYSk7Zm9yKGxldCByPTA7cjxlOysrcil7Y29uc3QgZT1yKm8saT1yKmErciVuKm87cy5zZXQodC5udW1iZXJEYXRhLnN1YmFycmF5KGUsZStvKSxpKX19cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGEoYSx0LnR5cGUscyx0LDEpfX1pZihlPT09cC5UZXh0dXJlVHlwZS5wYWNrZWQpe2NvbnN0IGU9KDAsbC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksdC5kaW1zLDEsW10se3JldmVyc2VXSDohMH0pLHI9dGhpcy5jcmVhdGVUZXh0dXJlRGF0YShlLHQudHlwZSx0Lm51bWJlckRhdGEsdCwxKTtuPXRoaXMucGFjayhyKX1lbHNlIG49dGhpcy5jcmVhdGVUZXh0dXJlRGF0YShyLHQudHlwZSx0Lm51bWJlckRhdGEsdCwxKX1yZXR1cm4gbn1jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXRCaW5kVGVuc29yKHQsZSxuLHIpe3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhKHQsZSxuLHIsMSl9Y3JlYXRlVGV4dHVyZURhdGEodCxlLG4saSxvKXtyLkxvZ2dlci52ZXJib3NlKFwiSW5mZXJlbmNlSGFuZGxlclwiLGBDcmVhdGluZyBUZXh0dXJlRGF0YTogbGF5b3V0Olske0pTT04uc3RyaW5naWZ5KHQpfV1gKTtjb25zdCBhPXRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5jcmVhdGVUZXh0dXJlRnJvbUxheW91dChlLHQsbixvKTtyZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKHQsZSxhLGkpfXJlc2hhcGVVbnBhY2tlZCh0LGUpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQscC5UZXh0dXJlVHlwZS51bnBhY2tlZCkscj17Y2hhbm5lbHM6bi5jaGFubmVscyxoZWlnaHQ6bi5oZWlnaHQsd2lkdGg6bi53aWR0aCxzaGFwZTowIT09ZS5sZW5ndGg/ZTpbMV0sc3RyaWRlczpvLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhlKSx1bnBhY2tlZFNoYXBlOmV9O3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUocix0LnR5cGUsbi50ZXh0dXJlKS50ZW5zb3J9cmVzaGFwZVBhY2tlZCh0LGUpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQscC5UZXh0dXJlVHlwZS5wYWNrZWQpO2lmKCgwLHMuaXNSZXNoYXBlQ2hlYXApKHQuZGltcyxlKSl7Y29uc3Qgcj17Y2hhbm5lbHM6bi5jaGFubmVscyxoZWlnaHQ6bi5oZWlnaHQsd2lkdGg6bi53aWR0aCxzaGFwZTowIT09ZS5sZW5ndGg/ZTpbMV0sc3RyaWRlczpvLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhlKSx1bnBhY2tlZFNoYXBlOmUsaXNQYWNrZWQ6ITB9O3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUocix0LnR5cGUsbi50ZXh0dXJlKS50ZW5zb3J9Y29uc3Qgcj0oMCxzLnByb2Nlc3NEaW1zM0QpKHQuZGltcyksaT0oMCxzLnByb2Nlc3NEaW1zM0QpKGUpLGE9dGhpcy5yZXNoYXBlUGFja2VkKHQsciksdT10aGlzLnJ1bigoMCxzLmNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvTG9hZGVyKSh0aGlzLGEsaSksW2FdKTtyZXR1cm4gdGhpcy5yZXNoYXBlUGFja2VkKHUsZSl9Y2FzdCh0LGUpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQscC5UZXh0dXJlVHlwZS51bnBhY2tlZCk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZShuLGUsbi50ZXh0dXJlKS50ZW5zb3J9Y3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZSh0LGUsbixyLG8pe2NvbnN0IGE9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHt0ZW5zb3I6cnx8bmV3IGkuVGVuc29yKHQudW5wYWNrZWRTaGFwZSxlLCh0PT50aGlzLnJlYWRUZXh0dXJlKGEpKSwoYXN5bmMgdD0+dGhpcy5yZWFkVGV4dHVyZUFzeW5jKGEpKSx2b2lkIDAsbyksdGV4dHVyZTpufSk7cmV0dXJuIHRoaXMuc2V0VGV4dHVyZURhdGEoYS50ZW5zb3IuZGF0YUlkLGEsdC5pc1BhY2tlZCksYX1nZXRUZXh0dXJlRGF0YSh0LGU9ITEpe3JldHVybiB0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0KT90aGlzLnNlc3Npb24uZ2V0VGV4dHVyZURhdGEodCxlKTplP3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQodCk6dGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHQpfXNldFRleHR1cmVEYXRhKHQsZSxuPSExKXt0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0KT90aGlzLnNlc3Npb24uc2V0VGV4dHVyZURhdGEodCxlLG4pOihuP3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZTp0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSkuc2V0KHQsZSl9aXNUZXh0dXJlTGF5b3V0Q2FjaGVkKHQsZT0hMSl7cmV0dXJuISF0aGlzLmdldFRleHR1cmVEYXRhKHQuZGF0YUlkLGUpfWRpc3Bvc2UoKXt0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIuY2xlYXJBY3RpdmVUZXh0dXJlcygpLHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKCh0PT50aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodCkpKSx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKCh0PT50aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodCkpKSx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfXJlYWRUZXh0dXJlKHQpe3JldHVybiB0LmlzUGFja2VkP3RoaXMucmVhZFRleHR1cmUodGhpcy51bnBhY2sodCkpOnRoaXMuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZD90aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmUodCx0LnRlbnNvci50eXBlLHQuY2hhbm5lbHMpOnRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCgoMCx1LmVuY29kZUFzVWludDgpKHRoaXMsdCkpfWFzeW5jIHJlYWRUZXh0dXJlQXN5bmModCl7cmV0dXJuIHQuaXNQYWNrZWQ/dGhpcy5yZWFkVGV4dHVyZUFzeW5jKHRoaXMudW5wYWNrKHQpKTp0aGlzLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQuaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQ/dGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlYWRUZXh0dXJlQXN5bmModCx0LnRlbnNvci50eXBlLHQuY2hhbm5lbHMpOnRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCgoMCx1LmVuY29kZUFzVWludDgpKHRoaXMsdCkpfXBhY2sodCl7cmV0dXJuIHRoaXMuZXhlY3V0ZVByb2dyYW0oKDAsYS5jcmVhdGVQYWNrUHJvZ3JhbUluZm9Mb2FkZXIpKHRoaXMsdC50ZW5zb3IpLFt0LnRlbnNvcl0pfXVucGFjayh0KXtyZXR1cm4gdGhpcy5leGVjdXRlUHJvZ3JhbSgoMCxjLmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyKSh0aGlzLHQudGVuc29yKSxbdC50ZW5zb3JdKX19fSwxNjQwOmZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2kmJiEoXCJnZXRcImluIGk/IWUuX19lc01vZHVsZTppLndyaXRhYmxlfHxpLmNvbmZpZ3VyYWJsZSl8fChpPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlW25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsaSl9OmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pLHRbcl09ZVtuXX0pLGk9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pfTpmdW5jdGlvbih0LGUpe3QuZGVmYXVsdD1lfSksbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmcihlLHQsbik7cmV0dXJuIGkoZSx0KSxlfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLldFQkdMX09QX1JFU09MVkVfUlVMRVM9dm9pZCAwO2NvbnN0IGE9bigyODk4KSxzPW8obig3ODM5KSksdT1uKDQxOTYpLGM9bigyMDY5KSxsPW4oODEzOCkscD1uKDk2NjMpLGY9big1MTkzKSxkPW4oNzk5MiksaD1uKDEyNTMpLGc9big0Nzc2KSxiPW4oNjU3MiksbT1uKDMzNDYpLHk9big1NjIzKSxfPW4oMjg3MCksdj1uKDIxNDMpLHc9big0OTM5KSx4PW4oNzE4KSxUPW4oMjI2OCksUz1uKDgxMTcpLE89bigyMjc4KSxBPW4oNTUyNCksRT1uKDU5NzUpLEk9bigzOTMzKSxQPW4oNjU1OCksRD1uKDU3MjMpLCQ9bigzNzM4KSxrPW8obig0OTA5KSksQz1uKDg0MjgpLEY9big5NzkzKTtlLldFQkdMX09QX1JFU09MVkVfUlVMRVM9W1tcIkFic1wiLFwiXCIsXCI2K1wiLGsuYWJzXSxbXCJBY29zXCIsXCJcIixcIjcrXCIsay5hY29zXSxbXCJBZGRcIixcIlwiLFwiNytcIixzLmFkZF0sW1wiQW5kXCIsXCJcIixcIjcrXCIscy5hbmRdLFtcIkFzaW5cIixcIlwiLFwiNytcIixrLmFzaW5dLFtcIkF0YW5cIixcIlwiLFwiNytcIixrLmF0YW5dLFtcIkF2ZXJhZ2VQb29sXCIsXCJcIixcIjcrXCIsdi5hdmVyYWdlUG9vbCx2LnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXSxbXCJCYXRjaE5vcm1hbGl6YXRpb25cIixcIlwiLFwiNytcIixhLmJhdGNoTm9ybWFsaXphdGlvbixhLnBhcnNlQmF0Y2hOb3JtYWxpemF0aW9uQXR0cmlidXRlc10sW1wiQ2FzdFwiLFwiXCIsXCI2K1wiLHUuY2FzdCx1LnBhcnNlQ2FzdEF0dHJpYnV0ZXNdLFtcIkNlaWxcIixcIlwiLFwiNitcIixrLmNlaWxdLFtcIkNsaXBcIixcIlwiLFwiNi0xMFwiLGsuY2xpcCxrLnBhcnNlQ2xpcEF0dHJpYnV0ZXNdLFtcIkNsaXBcIixcIlwiLFwiMTErXCIsay5jbGlwVjExXSxbXCJDb25jYXRcIixcIlwiLFwiNCtcIixjLmNvbmNhdCxjLnBhcnNlQ29uY2F0QXR0cmlidXRlc10sW1wiQ29udlwiLFwiXCIsXCIxK1wiLGwuY29udixsLnBhcnNlQ29udkF0dHJpYnV0ZXNdLFtcIkNvbnZUcmFuc3Bvc2VcIixcIlwiLFwiMStcIixwLmNvbnZUcmFuc3Bvc2UscC5wYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzXSxbXCJDb3NcIixcIlwiLFwiNytcIixrLmNvc10sW1wiRGl2XCIsXCJcIixcIjcrXCIscy5kaXZdLFtcIkRyb3BvdXRcIixcIlwiLFwiNytcIixrLmlkZW50aXR5XSxbXCJEZXB0aFRvU3BhY2VcIixcIlwiLFwiMStcIixmLmRlcHRoVG9TcGFjZSxmLnBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlc10sW1wiRXF1YWxcIixcIlwiLFwiNytcIixzLmVxdWFsXSxbXCJFbHVcIixcIlwiLFwiNitcIixrLmVsdSxrLnBhcnNlRWx1QXR0cmlidXRlc10sW1wiRXhwXCIsXCJcIixcIjYrXCIsay5leHBdLFtcIkZsYXR0ZW5cIixcIlwiLFwiMStcIixkLmZsYXR0ZW4sZC5wYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzXSxbXCJGbG9vclwiLFwiXCIsXCI2K1wiLGsuZmxvb3JdLFtcIkZ1c2VkQ29udlwiLFwiY29tLm1pY3Jvc29mdFwiLFwiMStcIixsLmNvbnYsbC5wYXJzZUNvbnZBdHRyaWJ1dGVzXSxbXCJHYXRoZXJcIixcIlwiLFwiMStcIixoLmdhdGhlcixoLnBhcnNlR2F0aGVyQXR0cmlidXRlc10sW1wiR2VtbVwiLFwiXCIsXCI3LTEwXCIsZy5nZW1tLGcucGFyc2VHZW1tQXR0cmlidXRlc1Y3XSxbXCJHZW1tXCIsXCJcIixcIjExK1wiLGcuZ2VtbSxnLnBhcnNlR2VtbUF0dHJpYnV0ZXNWMTFdLFtcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsXCJcIixcIjErXCIsdi5nbG9iYWxBdmVyYWdlUG9vbCx2LnBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXSxbXCJHbG9iYWxNYXhQb29sXCIsXCJcIixcIjErXCIsdi5nbG9iYWxNYXhQb29sXSxbXCJHcmVhdGVyXCIsXCJcIixcIjcrXCIscy5ncmVhdGVyXSxbXCJJZGVudGl0eVwiLFwiXCIsXCIxK1wiLGsuaWRlbnRpdHldLFtcIkltYWdlU2NhbGVyXCIsXCJcIixcIjErXCIsYi5pbWFnZVNjYWxlcixiLnBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzXSxbXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixcIlwiLFwiNitcIixtLmluc3RhbmNlTm9ybWFsaXphdGlvbixtLnBhcnNlSW5zdGFuY2VOb3JtYWxpemF0aW9uQXR0cmlidXRlc10sW1wiTGVha3lSZWx1XCIsXCJcIixcIjYrXCIsay5sZWFreVJlbHUsay5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXNdLFtcIkxlc3NcIixcIlwiLFwiNytcIixzLmxlc3NdLFtcIkxvZ1wiLFwiXCIsXCI2K1wiLGsubG9nXSxbXCJNYXRNdWxcIixcIlwiLFwiMStcIix5Lm1hdE11bCx5LnBhcnNlTWF0TXVsQXR0cmlidXRlc10sW1wiTWF4UG9vbFwiLFwiXCIsXCIxK1wiLHYubWF4UG9vbCx2LnBhcnNlTWF4UG9vbEF0dHJpYnV0ZXNdLFtcIk11bFwiLFwiXCIsXCI3K1wiLHMubXVsXSxbXCJOZWdcIixcIlwiLFwiNitcIixrLm5lZ10sW1wiTm90XCIsXCJcIixcIjErXCIsay5ub3RdLFtcIk9yXCIsXCJcIixcIjcrXCIscy5vcl0sW1wiUGFkXCIsXCJcIixcIjItMTBcIixfLnBhZFYyLF8ucGFyc2VQYWRBdHRyaWJ1dGVzVjJdLFtcIlBhZFwiLFwiXCIsXCIxMStcIixfLnBhZFYxMSxfLnBhcnNlUGFkQXR0cmlidXRlc1YxMV0sW1wiUG93XCIsXCJcIixcIjcrXCIscy5wb3ddLFtcIlBSZWx1XCIsXCJcIixcIjcrXCIscy5wUmVsdV0sW1wiUmVkdWNlTG9nU3VtXCIsXCJcIixcIjErXCIsdy5yZWR1Y2VMb2dTdW0sdy5wYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFtcIlJlZHVjZU1heFwiLFwiXCIsXCIxK1wiLHcucmVkdWNlTWF4LHcucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxbXCJSZWR1Y2VNZWFuXCIsXCJcIixcIjErXCIsdy5yZWR1Y2VNZWFuLHcucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxbXCJSZWR1Y2VNaW5cIixcIlwiLFwiMStcIix3LnJlZHVjZU1pbix3LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlUHJvZFwiLFwiXCIsXCIxK1wiLHcucmVkdWNlUHJvZCx3LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlU3VtXCIsXCJcIixcIjEtMTJcIix3LnJlZHVjZVN1bSx3LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlU3VtU3F1YXJlXCIsXCJcIixcIjErXCIsdy5yZWR1Y2VMb2dTdW1TcXVhcmUsdy5wYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFtcIlJlbHVcIixcIlwiLFwiNitcIixrLnJlbHVdLFtcIlJlc2hhcGVcIixcIlwiLFwiNStcIix4LnJlc2hhcGVdLFtcIlJlc2l6ZVwiLFwiXCIsXCIxMFwiLFQucmVzaXplLFQucGFyc2VSZXNpemVBdHRyaWJ1dGVzVjEwXSxbXCJSZXNpemVcIixcIlwiLFwiMTErXCIsVC5yZXNpemUsVC5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTFdLFtcIlNoYXBlXCIsXCJcIixcIjErXCIsUy5zaGFwZV0sW1wiU2lnbW9pZFwiLFwiXCIsXCI2K1wiLGsuc2lnbW9pZF0sW1wiU2luXCIsXCJcIixcIjcrXCIsay5zaW5dLFtcIlNsaWNlXCIsXCJcIixcIjEwK1wiLE8uc2xpY2VWMTBdLFtcIlNsaWNlXCIsXCJcIixcIjEtOVwiLE8uc2xpY2UsTy5wYXJzZVNsaWNlQXR0cmlidXRlc10sW1wiU29mdG1heFwiLFwiXCIsXCIxLTEyXCIsQS5zb2Z0bWF4LEEucGFyc2VTb2Z0bWF4QXR0cmlidXRlc10sW1wiU29mdG1heFwiLFwiXCIsXCIxMytcIixBLnNvZnRtYXhWMTMsQS5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzXSxbXCJTcGxpdFwiLFwiXCIsXCIyLTEyXCIsRS5zcGxpdCxFLnBhcnNlU3BsaXRBdHRyaWJ1dGVzXSxbXCJTcXJ0XCIsXCJcIixcIjYrXCIsay5zcXJ0XSxbXCJTcXVlZXplXCIsXCJcIixcIjEtMTJcIixJLnNxdWVlemUsSS5wYXJzZVNxdWVlemVBdHRyaWJ1dGVzXSxbXCJTcXVlZXplXCIsXCJcIixcIjEzK1wiLEkuc3F1ZWV6ZVYxM10sW1wiU3ViXCIsXCJcIixcIjcrXCIscy5zdWJdLFtcIlN1bVwiLFwiXCIsXCI2K1wiLFAuc3VtXSxbXCJUYW5cIixcIlwiLFwiNytcIixrLnRhbl0sW1wiVGFuaFwiLFwiXCIsXCI2K1wiLGsudGFuaF0sW1wiVGlsZVwiLFwiXCIsXCI2K1wiLEQudGlsZV0sW1wiVHJhbnNwb3NlXCIsXCJcIixcIjErXCIsJC50cmFuc3Bvc2UsJC5wYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXNdLFtcIlVwc2FtcGxlXCIsXCJcIixcIjctOFwiLEYudXBzYW1wbGUsRi5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3XSxbXCJVcHNhbXBsZVwiLFwiXCIsXCI5XCIsRi51cHNhbXBsZSxGLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzVjldLFtcIlVuc3F1ZWV6ZVwiLFwiXCIsXCIxLTEyXCIsQy51bnNxdWVlemUsQy5wYXJzZVVuc3F1ZWV6ZUF0dHJpYnV0ZXNdLFtcIlVuc3F1ZWV6ZVwiLFwiXCIsXCIxMytcIixDLnVuc3F1ZWV6ZVYxM10sW1wiWG9yXCIsXCJcIixcIjcrXCIscy54b3JdXX0sMjg5ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM9ZS5iYXRjaE5vcm1hbGl6YXRpb249dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9big1MDYwKSxvPW4oMjAzOSksYT17bmFtZTpcIkJhdGNoTm9ybWFsaXphdGlvblwiLGlucHV0TmFtZXM6W1wiQVwiLFwiU2NhbGVcIixcIkJcIixcIk1lYW5cIixcIlZhcmlhbmNlXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UuYmF0Y2hOb3JtYWxpemF0aW9uPSh0LGUsbik9Pih1KGUpLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+cyh0LGUsbil9KSxlKV0pLGUucGFyc2VCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcImVwc2lsb25cIiwxZS01KSxuPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcIm1vbWVudHVtXCIsLjkpLGk9dC5hdHRyaWJ1dGVzLmdldEludChcInNwYXRpYWxcIiwxKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2Vwc2lsb246ZSxtb21lbnR1bTpuLHNwYXRpYWw6aX0pfTtjb25zdCBzPSh0LGUsbik9Pntjb25zdCByPSgwLGkuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLHM9ZVswXS5kaW1zLmxlbmd0aCxbdSxjXT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlWzFdLmRpbXMsby5UZXh0dXJlVHlwZS51bnBhY2tlZCksbD1gXFxuICBmbG9hdCBwcm9jZXNzKGludFske3N9XSBpbmRpY2VzKSB7XFxuICAgIHZlYzIgcG9zaXRpb24gPSBvZmZzZXRUb0Nvb3JkcyhpbmRpY2VzWzFdLCAke3V9LCAke2N9KTtcXG4gICAgZmxvYXQgc2NhbGUgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oU2NhbGUsIHBvc2l0aW9uKSk7XFxuICAgIGZsb2F0IG1lYW4gPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oTWVhbiwgcG9zaXRpb24pKTtcXG4gICAgZmxvYXQgdmFyaWFuY2UgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oVmFyaWFuY2UsIHBvc2l0aW9uKSk7XFxuICAgIGZsb2F0IGIgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oQiwgcG9zaXRpb24pKTtcXG5cXG4gICAgcmV0dXJuIHNjYWxlICogKCAoX0EoaW5kaWNlcykgLSBtZWFuKSAvIHNxcnQodmFyaWFuY2UgKyBmbG9hdCgke24uZXBzaWxvbn0pKSApICsgYjtcXG4gIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse291dHB1dDp7ZGltczplWzBdLmRpbXMsdHlwZTplWzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmx9KX0sdT10PT57aWYoIXR8fDUhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaE5vcm1hbGl6YXRpb24gcmVxdWlyZXMgNSBpbnB1dHMuXCIpO2NvbnN0IGU9dFswXSxuPXRbMV0scj10WzJdLGk9dFszXSxvPXRbNF07aWYoZS5kaW1zLmxlbmd0aDwzfHwxIT09bi5kaW1zLmxlbmd0aHx8MSE9PXIuZGltcy5sZW5ndGh8fDEhPT1pLmRpbXMubGVuZ3RofHwxIT09by5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHNoYXBlLlwiKTtpZihuLmRpbXNbMF0hPT1lLmRpbXNbMV18fHIuZGltc1swXSE9PWUuZGltc1sxXXx8aS5kaW1zWzBdIT09ZS5kaW1zWzFdfHxvLmRpbXNbMF0hPT1lLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYoXCJmbG9hdDMyXCIhPT1lLnR5cGUmJlwiZmxvYXQ2NFwiIT09ZS50eXBlfHxcImZsb2F0MzJcIiE9PW4udHlwZSYmXCJmbG9hdDY0XCIhPT1uLnR5cGV8fFwiZmxvYXQzMlwiIT09ci50eXBlJiZcImZsb2F0NjRcIiE9PXIudHlwZXx8XCJmbG9hdDMyXCIhPT1pLnR5cGUmJlwiZmxvYXQ2NFwiIT09aS50eXBlfHxcImZsb2F0MzJcIiE9PW8udHlwZSYmXCJmbG9hdDY0XCIhPT1vLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfX0sNzgzOToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS54b3I9ZS5zdWI9ZS5wUmVsdT1lLnBvdz1lLm9yPWUubXVsPWUubGVzcz1lLmdyZWF0ZXI9ZS5lcXVhbD1lLmRpdj1lLmFuZD1lLmFkZD1lLmdsc2xQUmVsdT1lLmdsc2xQb3c9ZS5nbHNsWG9yPWUuZ2xzbE9yPWUuZ2xzbEFuZD1lLmdsc2xMZXNzPWUuZ2xzbEdyZWF0ZXI9ZS5nbHNsRXF1YWw9ZS5nbHNsU3ViPWUuZ2xzbE11bD1lLmdsc2xEaXY9ZS5nbHNsQWRkPXZvaWQgMDtjb25zdCByPW4oMjUxNyksaT1uKDg1MjApLG89big1MDYwKSxhPW4oMjAzOSk7ZnVuY3Rpb24gcygpe2NvbnN0IHQ9XCJhZGRfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBhICsgYjtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2MSArIHYyO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiB1KCl7Y29uc3QgdD1cImRpdl9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke3R9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGEgLyBiO1xcbiAgfVxcbiAgdmVjNCAke3R9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgcmV0dXJuIHYxIC8gdjI7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGMoKXtjb25zdCB0PVwibXVsX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gYSAqIGI7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdjEgKiB2MjtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gbCgpe2NvbnN0IHQ9XCJzdWJfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBhIC0gYjtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2MSAtIHYyO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBwKCl7Y29uc3QgdD1cImVxdWFsX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gZmxvYXQoYSA9PSBiKTtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KGVxdWFsKHYxLCB2MikpO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBmKCl7Y29uc3QgdD1cImdyZWF0ZXJfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdChhID4gYik7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdmVjNCggdjEuciA+IHYyLnIgLFxcbiAgICAgIHYxLmcgPiB2Mi5nLFxcbiAgICAgIHYxLmIgPiB2Mi5iLFxcbiAgICAgIHYxLmEgPiB2Mi5hICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGQoKXtjb25zdCB0PVwibGVzc19cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke3R9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGZsb2F0KGEgPCBiKTtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KCB2MS5yIDwgdjIuciAsXFxuICAgICAgICAgICAgICAgIHYxLmcgPCB2Mi5nLFxcbiAgICAgICAgICAgICAgICB2MS5iIDwgdjIuYixcXG4gICAgICAgICAgICAgICAgdjEuYSA8IHYyLmEgKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gaCgpe2NvbnN0IHQ9XCJhbmRfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSAmJiBib29sKGIpICk7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcXG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XFxuICAgIHJldHVybiB2ZWM0KCBiMS5yICYmIGIyLnIgLFxcbiAgICAgICAgICAgICAgICBiMS5nICYmIGIyLmcsXFxuICAgICAgICAgICAgICAgIGIxLmIgJiYgYjIuYixcXG4gICAgICAgICAgICAgICAgYjEuYSAmJiBiMi5hICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGcoKXtjb25zdCB0PVwib3JfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSB8fCBib29sKGIpICk7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcXG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XFxuICAgIHJldHVybiB2ZWM0KCBiMS5yIHx8IGIyLnIgLFxcbiAgICAgICAgICAgICAgICBiMS5nIHx8IGIyLmcsXFxuICAgICAgICAgICAgICAgIGIxLmIgfHwgYjIuYixcXG4gICAgICAgICAgICAgICAgYjEuYSB8fCBiMi5hICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGIoKXtjb25zdCB0PVwieG9yX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gZmxvYXQoIGJvb2woYSkgXl4gYm9vbChiKSApO1xcbiAgfVxcbiAgdmVjNCAke3R9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgYnZlYzQgYjEgPSBidmVjNCh2MSk7XFxuICAgIGJ2ZWM0IGIyID0gYnZlYzQodjIpO1xcbiAgICByZXR1cm4gdmVjNCggYjEuciBeXiBiMi5yICxcXG4gICAgICAgICAgICAgICAgYjEuZyBeXiBiMi5nLFxcbiAgICAgICAgICAgICAgICBiMS5iIF5eIGIyLmIsXFxuICAgICAgICAgICAgICAgIGIxLmEgXl4gYjIuYSApO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBtKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe2NvbnN0IGU9YCR7dH1fYDtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuICR7dH0oYSwgYik7XFxuICB9XFxuICB2ZWM0ICR7ZX0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gJHt0fSh2MSwgdjIpO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX0oXCJwb3dcIil9ZnVuY3Rpb24geSgpe2NvbnN0IHQ9XCJwcmVsdV9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke3R9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGEgPCAwLjAgPyBhICogYjogYTtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KFxcbiAgICAgIHYxLnIgPCAwLjAgPyB2MS5yICogdjIucjogdjEucixcXG4gICAgICB2MS5nIDwgMC4wID8gdjEuZyAqIHYyLmc6IHYxLmcsXFxuICAgICAgdjEuYiA8IDAuMCA/IHYxLmIgKiB2Mi5iOiB2MS5iLFxcbiAgICAgIHYxLmEgPCAwLjAgPyB2MS5hICogdjIuYTogdjEuYVxcbiAgICAgICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWUuZ2xzbEFkZD1zLGUuZ2xzbERpdj11LGUuZ2xzbE11bD1jLGUuZ2xzbFN1Yj1sLGUuZ2xzbEVxdWFsPXAsZS5nbHNsR3JlYXRlcj1mLGUuZ2xzbExlc3M9ZCxlLmdsc2xBbmQ9aCxlLmdsc2xPcj1nLGUuZ2xzbFhvcj1iLGUuZ2xzbFBvdz1tLGUuZ2xzbFBSZWx1PXk7Y29uc3QgXz0odCxlLG4scj1lWzBdLnR5cGUsaSk9Pntjb25zdCBvPXQuc2Vzc2lvbi5wYWNrP2EuVGV4dHVyZVR5cGUucGFja2VkOmEuVGV4dHVyZVR5cGUudW5wYWNrZWQ7cmV0dXJue25hbWU6bi5uYW1lLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOltvLG9dLGNhY2hlSGludDppLGdldDooKT0+dih0LGUsbixyKX19LHY9KHQsZSxuLGk9ZVswXS50eXBlKT0+e2NvbnN0IHM9dC5zZXNzaW9uLnBhY2s/YS5UZXh0dXJlVHlwZS5wYWNrZWQ6YS5UZXh0dXJlVHlwZS51bnBhY2tlZCx1PSFyLlNoYXBlVXRpbC5hcmVFcXVhbChlWzBdLmRpbXMsZVsxXS5kaW1zKTtsZXQgYz1lWzBdLmRpbXM7Y29uc3QgbD10LnNlc3Npb24ucGFjaztpZih1KXtjb25zdCBhPXIuQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoZVswXS5kaW1zLGVbMV0uZGltcywhMSk7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7Yz1hO2NvbnN0IHU9Yy5sZW5ndGgscD0wIT09ZVswXS5kaW1zLmxlbmd0aD9lWzBdLmRpbXMubGVuZ3RoOjEsZj0wIT09ZVsxXS5kaW1zLmxlbmd0aD9lWzFdLmRpbXMubGVuZ3RoOjEsZD0wIT09ZVswXS5kaW1zLmxlbmd0aD9cImJjYXN0SW5kaWNlc19BKGluZGljZXMsIGFpbmRpY2VzKTtcIjpcImFpbmRpY2VzWzBdID0gMDtcIixoPTAhPT1lWzFdLmRpbXMubGVuZ3RoP1wiYmNhc3RJbmRpY2VzX0IoaW5kaWNlcywgYmluZGljZXMpO1wiOlwiYmluZGljZXNbMF0gPSAwO1wiLGc9KDAsby5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksYj1sP2BcXG4gICAgICAke24uYm9keX1cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgYiA9IGdldEJBdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke24ubmFtZX0oYSwgYik7XFxuICAgICAgICAke2cub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9YDpgXFxuICAgICAgJHtuLmJvZHl9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3V9XSkge1xcbiAgICAgICAgaW50IGFpbmRpY2VzWyR7cH1dO1xcbiAgICAgICAgaW50IGJpbmRpY2VzWyR7Zn1dO1xcbiAgICAgICAgJHtkfVxcbiAgICAgICAgJHtofVxcbiAgICAgICAgcmV0dXJuICR7bi5uYW1lfShfQShhaW5kaWNlcyksIF9CKGJpbmRpY2VzKSk7XFxuICAgICAgfWA7cmV0dXJue25hbWU6bi5uYW1lLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOltzLHNdLG91dHB1dDp7ZGltczpjLHR5cGU6aSx0ZXh0dXJlVHlwZTpzfSxzaGFkZXJTb3VyY2U6YixoYXNNYWluOmx9fWNvbnN0IHA9KDAsby5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksZj1gXFxuICAgICR7bi5ib2R5fVxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgdmVjNCB2MSA9ICR7cC50ZXh0dXJlMkR9KEEsIFRleENvb3Jkcyk7XFxuICAgICAgdmVjNCB2MiA9ICR7cC50ZXh0dXJlMkR9KEIsIFRleENvb3Jkcyk7XFxuICAgICAgdmVjNCByZXN1bHQgPSAke24ubmFtZX0odjEsIHYyKTtcXG4gICAgICAke3Aub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgfVxcbiAgICBgO3JldHVybntuYW1lOm4ubmFtZSxpbnB1dE5hbWVzOltcIkFcIixcIkJcIl0saW5wdXRUeXBlczpbcyxzXSxvdXRwdXQ6e2RpbXM6ZVswXS5kaW1zLHR5cGU6aSx0ZXh0dXJlVHlwZTpzfSxzaGFkZXJTb3VyY2U6ZixoYXNNYWluOiEwfX07ZS5hZGQ9KHQsZSk9Plt0LnJ1bihfKHQsZSxzKCkpLGUpXSxlLmFuZD0odCxlKT0+W3QucnVuKF8odCxlLGgoKSxcImJvb2xcIiksZSldLGUuZGl2PSh0LGUpPT5bdC5ydW4oXyh0LGUsdSgpKSxlKV0sZS5lcXVhbD0odCxlKT0+W3QucnVuKF8odCxlLHAoKSxcImJvb2xcIiksZSldLGUuZ3JlYXRlcj0odCxlKT0+W3QucnVuKF8odCxlLGYoKSxcImJvb2xcIiksZSldLGUubGVzcz0odCxlKT0+W3QucnVuKF8odCxlLGQoKSxcImJvb2xcIiksZSldLGUubXVsPSh0LGUpPT5bdC5ydW4oXyh0LGUsYygpKSxlKV0sZS5vcj0odCxlKT0+W3QucnVuKF8odCxlLGcoKSxcImJvb2xcIiksZSldLGUucG93PSh0LGUpPT5bdC5ydW4oXyh0LGUsbSgpKSxlKV0sZS5wUmVsdT0odCxlKT0+W3QucnVuKF8odCxlLHkoKSksZSldLGUuc3ViPSh0LGUpPT5bdC5ydW4oXyh0LGUsbCgpKSxlKV0sZS54b3I9KHQsZSk9Plt0LnJ1bihfKHQsZSxiKCksXCJib29sXCIpLGUpXX0sNDE5NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUNhc3RBdHRyaWJ1dGVzPWUuY2FzdD12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpO2UuY2FzdD0odCxlLG4pPT4oaShlKSxbdC5jYXN0KGVbMF0sbildKSxlLnBhcnNlQ2FzdEF0dHJpYnV0ZXM9dD0+ci5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odC5hdHRyaWJ1dGVzLmdldEludChcInRvXCIpKTtjb25zdCBpPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNhc3QgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoXCJzdHJpbmdcIj09PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0sMTE2MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KSxvPW4oOTM5MCksYT1uKDI4MjcpO2UuY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXI9KHQsZSxuKT0+e2NvbnN0IHU9KGM9ZS5sZW5ndGgsbD1uLmNhY2hlS2V5LHtuYW1lOlwiQ29uY2F0IChwYWNrZWQpXCIsaW5wdXROYW1lczpBcnJheS5mcm9tKHtsZW5ndGg6Y30sKCh0LGUpPT5gWCR7ZX1gKSksaW5wdXRUeXBlczpBcnJheShjKS5maWxsKGkuVGV4dHVyZVR5cGUucGFja2VkKSxjYWNoZUhpbnQ6bH0pO3ZhciBjLGw7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Z2V0OigpPT4oKHQsZSxuLHUpPT57Y29uc3QgYz1uWzBdLmRpbXMuc2xpY2UoKTtpZih1Pj1jLmxlbmd0aHx8dTwtMSpjLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGlzIHNwZWNpZmllZCBmb3IgY29uY2F0IGRvZXNuJ3QgbWF0Y2ggaW5wdXQgZGltZW5zaW9uYWxpdHlcIik7dTwwJiYodT1jLmxlbmd0aCt1KTtjb25zdCBsPWMuc2xpY2UoMCk7Zm9yKGxldCB0PTE7dDxuLmxlbmd0aDt0Kyspe2NvbnN0IGU9blt0XS5kaW1zLnNsaWNlKCk7Zm9yKGxldCB0PTA7dDxjLmxlbmd0aDt0KyspaWYodD09PXUpbFt1XSs9ZVt0XTtlbHNlIGlmKGNbdF0hPT1lW3RdKXRocm93IG5ldyBFcnJvcihcIm5vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoXCIpfWNvbnN0IHA9bC5sZW5ndGgsZj0oMCxhLmdldENoYW5uZWxzKShcImNvb3Jkc1wiLHApLGQ9KDAsby5nZXRDb29yZHNEYXRhVHlwZSkocCksaD0oMCxhLnVucGFja0Zyb21DaGFubmVsKSgpLGc9bi5tYXAoKHQ9PnQuZGltcykpLGI9KDAsby5nZXRHbENoYW5uZWxzKShwKSxtPW5ldyBBcnJheShnLmxlbmd0aC0xKTttWzBdPWdbMF1bdV07Zm9yKGxldCB0PTE7dDxtLmxlbmd0aDt0KyspbVt0XT1tW3QtMV0rZ1t0XVt1XTtjb25zdCB5PWJbdV0sXz1iLnNsaWNlKC0yKSx2PWIuam9pbigpO2xldCB3PWBpZiAoJHt5fSA8ICR7bVswXX0pIHtcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgIGdldFgwKCR7dn0pLCB2ZWMyKCR7Xy5qb2luKCl9KSk7XFxuICAgICAgICB9YDtmb3IobGV0IHQ9MTt0PG0ubGVuZ3RoO3QrKyl7Y29uc3QgZT1tW3QtMV07dys9YFxcbiAgICAgICAgICAgIGlmICgke3l9IDwgJHttW3RdfSAgJiYgJHt5fSA+PSAke21bdC0xXX0pIHtcXG4gICAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgICAgICBnZXRYJHt0fSgke3MoYix5LGUpfSksXFxuICAgICAgICAgICAgICAgIHZlYzIoJHtzKF8seSxlKX0pKTtcXG4gICAgICAgICAgICB9YH1jb25zdCB4PW0ubGVuZ3RoLFQ9bVttLmxlbmd0aC0xXTt3Kz1gXFxuICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXFxuICAgICAgICAgICAgICBnZXRYJHt4fSgke3MoYix5LFQpfSksXFxuICAgICAgICAgICAgICB2ZWMyKCR7cyhfLHksVCl9KSk7YDtjb25zdCBTPSgwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLE89YFxcbiAgICAgICAgICAke2h9XFxuICAgICAgICAgIGZsb2F0IGdldFZhbHVlKCR7Yi5tYXAoKHQ9PlwiaW50IFwiK3QpKX0pIHtcXG4gICAgICAgICAgICAke3d9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICR7ZH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgICAgaW50IGxhc3REaW0gPSBjb29yZHMuJHtiW3AtMV19O1xcbiAgICAgICAgICAgIGNvb3Jkcy4ke2JbcC0xXX0gPSBjb29yZHMuJHtiW3AtMl19O1xcbiAgICAgICAgICAgIGNvb3Jkcy4ke2JbcC0yXX0gPSBsYXN0RGltO1xcblxcbiAgICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNChnZXRWYWx1ZSgke2Z9KSwgMC4sIDAuLCAwLik7XFxuXFxuICAgICAgICAgICAgJHtmW3AtMV19ID0gJHtmW3AtMV19ICsgMTtcXG4gICAgICAgICAgICBpZiAoJHtmW3AtMV19IDwgJHtsW3AtMV19KSB7XFxuICAgICAgICAgICAgICByZXN1bHQuZyA9IGdldFZhbHVlKCR7Zn0pO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAke2ZbcC0yXX0gPSAke2ZbcC0yXX0gKyAxO1xcbiAgICAgICAgICAgIGlmICgke2ZbcC0yXX0gPCAke2xbcC0yXX0pIHtcXG4gICAgICAgICAgICAgIHJlc3VsdC5hID0gZ2V0VmFsdWUoJHtmfSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICR7ZltwLTFdfSA9ICR7ZltwLTFdfSAtIDE7XFxuICAgICAgICAgICAgaWYgKCR7ZltwLTJdfSA8ICR7bFtwLTJdfSAmJlxcbiAgICAgICAgICAgICAgICAke2ZbcC0xXX0gPCAke2xbcC0xXX0pIHtcXG4gICAgICAgICAgICAgIHJlc3VsdC5iID0gZ2V0VmFsdWUoJHtmfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICR7Uy5vdXRwdXR9ID0gcmVzdWx0O1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpsLHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUucGFja2VkfSxzaGFkZXJTb3VyY2U6TyxoYXNNYWluOiEwfSl9KSh0LHUsZSxuLmF4aXMpfSl9O2NvbnN0IHM9KHQsZSxuKT0+e2NvbnN0IHI9dC5pbmRleE9mKGUpO3JldHVybiB0Lm1hcCgoKHQsZSk9PmU9PT1yP2Ake3R9IC0gJHtufWA6dCkpLmpvaW4oKX19LDIwNjk6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VDb25jYXRBdHRyaWJ1dGVzPWUuY29uY2F0PXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjAzOSksbz1uKDExNjMpO2UuY29uY2F0PSh0LGUsbik9PihwKGUpLHQuc2Vzc2lvbi5wYWNrJiZlWzBdLmRpbXMubGVuZ3RoPjE/W3QucnVuKCgwLG8uY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXIpKHQsZSxuKSxlKV06W3QucnVuKGEodCxlLG4pLGUpXSk7Y29uc3QgYT0odCxlLG4pPT57Y29uc3Qgcj0obz1lLmxlbmd0aCxhPW4uY2FjaGVLZXkse25hbWU6XCJDb25jYXRcIixpbnB1dE5hbWVzOkFycmF5LmZyb20oe2xlbmd0aDpvfSwoKHQsZSk9PmBYJHtlfWApKSxpbnB1dFR5cGVzOkFycmF5KG8pLmZpbGwoaS5UZXh0dXJlVHlwZS51bnBhY2tlZCksY2FjaGVIaW50OmF9KTt2YXIgbyxhO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+KCh0LGUsbixyKT0+e2NvbnN0IG89blswXS5kaW1zLnNsaWNlKCk7aWYocj49by5sZW5ndGh8fHI8LTEqby5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhpcyBzcGVjaWZpZWQgZm9yIGNvbmNhdCBkb2Vzbid0IG1hdGNoIGlucHV0IGRpbWVuc2lvbmFsaXR5XCIpO3I8MCYmKHI9by5sZW5ndGgrcik7Y29uc3QgYT1vLnNsaWNlKDApO2ZvcihsZXQgdD0xO3Q8bi5sZW5ndGg7dCsrKXtjb25zdCBlPW5bdF0uZGltcy5zbGljZSgpO2ZvcihsZXQgdD0wO3Q8by5sZW5ndGg7dCsrKWlmKHQ9PT1yKWFbcl0rPWVbdF07ZWxzZSBpZihvW3RdIT09ZVt0XSl0aHJvdyBuZXcgRXJyb3IoXCJub24gY29uY2F0IGRpbWVuc2lvbnMgbXVzdCBtYXRjaFwiKX1jb25zdCBwPWEubGVuZ3RoLGY9bmV3IEFycmF5KG4ubGVuZ3RoKTtsZXQgZD0wO2ZvcihsZXQgdD0wO3Q8Zi5sZW5ndGg7Kyt0KWQrPW5bdF0uZGltc1tyXSxmW3RdPWQ7bGV0IGg9XCJcIjtoPW4ubGVuZ3RoPDU/cyhmKTp1KGYpO2NvbnN0IGc9YFxcbiAgICAgICAgJHtjKG4ubGVuZ3RoLHApfVxcbiAgICAgICAgJHtsKGYpfVxcbiAgICAgICAgJHtofVxcbiAgICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3B9XSkge1xcbiAgICAgICAgICBpbnQgdGV4dHVyZUluZGV4ID0gZ2V0VGV4dHVyZVdoZXJlRGF0YVJlc2lkZXMgKGluZGljZXNbJHtyfV0pO1xcblxcbiAgICAgICAgICBpZih0ZXh0dXJlSW5kZXggIT0gMCkge1xcbiAgICAgICAgICAgIGluZGljZXNbJHtyfV0gPSBpbmRpY2VzWyR7cn1dIC0gaW50KGdldFNpemVJbkNvbmNhdEF4aXNWYWx1ZUZyb21JbmRleCh0ZXh0dXJlSW5kZXgtaW50KDEpKSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIGZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZSh0ZXh0dXJlSW5kZXgsIGluZGljZXMpO1xcbiAgICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOmEsdHlwZTpuWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmd9KX0pKDAscixlLG4uYXhpcyl9KX0scz10PT5gaW50IGdldFRleHR1cmVXaGVyZURhdGFSZXNpZGVzKGludCBpbmRleCkge1xcbiAgICAgICR7dC5tYXAoKCh0LGUpPT5gaWYoaW5kZXg8JHt0fSkge3JldHVybiAke2V9O31cXG5gKSkuam9pbihcIlwiKX1cXG4gICAgfWAsdT10PT5zKHQpLGM9KHQsZSk9Pntjb25zdCBuPVtgZmxvYXQgZmV0Y2hEYXRhRnJvbUNvcnJlY3RUZXh0dXJlKGludCB0ZXh0dXJlSW5kZXgsIGludCBpbmRpY2VzWyR7ZX1dKSB7YF07Zm9yKGxldCBlPTA7ZTx0OysrZSkwPT09ZT9uLnB1c2goYFxcdGlmICh0ZXh0dXJlSW5kZXggPT0gJHtlfSkgeyByZXR1cm4gX1gke2V9KGluZGljZXMpOyB9YCk6ZT09PXQtMT9uLnB1c2goYFxcdGVsc2UgeyByZXR1cm4gX1gke2V9KGluZGljZXMpOyB9YCk6bi5wdXNoKGBcXHRlbHNlIGlmICh0ZXh0dXJlSW5kZXggPT0gJHtlfSkgeyByZXR1cm4gX1gke2V9KGluZGljZXMpOyB9YCk7cmV0dXJuIG4ucHVzaChcIlxcdH1cIiksbi5qb2luKFwiXFxuXCIpfSxsPXQ9Pntjb25zdCBlPVtcImludCBnZXRTaXplSW5Db25jYXRBeGlzVmFsdWVGcm9tSW5kZXgoaW50IGluZGV4KSB7XCJdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKTA9PT1uP2UucHVzaChgXFx0aWYgKGluZGV4ID09ICR7bn0pIHsgcmV0dXJuICR7dFtuXX07IH1gKTpuPT09dC5sZW5ndGgtMT9lLnB1c2goYFxcdGVsc2UgeyByZXR1cm4gJHt0W25dfTsgfWApOmUucHVzaChgXFx0ZWxzZSBpZiAoaW5kZXggPT0gJHtufSkgeyByZXR1cm4gJHt0W25dfTsgfWApO3JldHVybiBlLnB1c2goXCJcXHR9XCIpLGUuam9pbihcIlxcblwiKX07ZS5wYXJzZUNvbmNhdEF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtheGlzOnQuYXR0cmlidXRlcy5nZXRJbnQoXCJheGlzXCIpfSk7Y29uc3QgcD10PT57aWYoIXR8fHQubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7Y29uc3QgZT10WzBdLnR5cGUsbj10WzBdLmRpbXMubGVuZ3RoO2lmKFwic3RyaW5nXCI9PT1lKXRocm93IG5ldyBFcnJvcihcInN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7Zm9yKGNvbnN0IHIgb2YgdCl7aWYoci50eXBlIT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBiZSBvbmUgdHlwZVwiKTtpZihyLmRpbXMubGVuZ3RoIT09bil0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpfX19LDQ3NzA6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNjIzMSksaT1uKDUwNjApLG89bigyMDM5KSxhPW4oODEzOCkscz1uKDI4MjMpO2UuY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyPSh0LGUsbik9Pntjb25zdCB1PShjPWUubGVuZ3RoPjIsbD1uLmNhY2hlS2V5LHtuYW1lOlwiR3JvdXBlZENvbnZcIixpbnB1dE5hbWVzOmM/W1wiWFwiLFwiV1wiLFwiQmlhc1wiXTpbXCJYXCIsXCJXXCJdLGlucHV0VHlwZXM6Yz9bby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdOltvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDpsfSk7dmFyIGMsbDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtnZXQ6KCk9PigodCxlLG4sdSk9Pntjb25zdCBjPWUubGVuZ3RoPjI/XCJ2YWx1ZSArPSBnZXRCaWFzKG91dHB1dF9jaGFubmVsKTtcIjpcIlwiLGw9ZVswXS5kaW1zLnNsaWNlKCkscD1lWzFdLmRpbXMuc2xpY2UoKSxmPXBbMF0vdS5ncm91cDtyLkxvZ2dlci52ZXJib3NlKFwiR3JvdXBlZENvbnZcIixgYXV0cFBhZDoke3UuYXV0b1BhZH0sIGRpbGF0aW9uczoke3UuZGlsYXRpb25zfSwgZ3JvdXA6JHt1Lmdyb3VwfSwga2VybmVsU2hhcGU6JHt1Lmtlcm5lbFNoYXBlfSwgcGFkczoke3UucGFkc30sIHN0cmlkZXM6JHt1LnN0cmlkZXN9YCk7Y29uc3QgZD0oMCxhLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShsLHAsdS5kaWxhdGlvbnMsdS5wYWRzLHUuc3RyaWRlcyksaD0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx7YWN0aXZhdGlvbkZ1bmN0aW9uOmcsYXBwbHlBY3RpdmF0aW9uOmJ9PSgwLHMuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKHUpLG09YFxcbiAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKCR7dS5zdHJpZGVzWzBdfSwgJHt1LnN0cmlkZXNbMV19KTtcXG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3UucGFkc1swXX0sICR7dS5wYWRzWzFdfSk7XFxuICAke2d9XFxuICB2b2lkIG1haW4oKSB7XFxuICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgaW50IG91dHB1dF9jaGFubmVsID0gY29vcmRzLnk7XFxuICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy56dyAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICBpbnQgZ3JvdXBfaWQgPSBvdXRwdXRfY2hhbm5lbCAvICR7Zn07XFxuXFxuICAgIGZsb2F0IHZhbHVlID0gMC4wO1xcbiAgICBmb3IgKGludCB3SW5DaGFubmVsID0gMDsgd0luQ2hhbm5lbCA8ICR7cFsxXX07IHdJbkNoYW5uZWwrKykge1xcbiAgICAgIGludCBpbnB1dF9jaGFubmVsID0gZ3JvdXBfaWQgKiAke3BbMV19ICsgd0luQ2hhbm5lbDtcXG4gICAgICBmb3IgKGludCB3SGVpZ2h0ID0gMDsgd0hlaWdodCA8ICR7cFsyXX07IHdIZWlnaHQrKykge1xcbiAgICAgICAgaW50IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiAke3UuZGlsYXRpb25zWzBdfTtcXG5cXG4gICAgICAgIGlmICh4SGVpZ2h0IDwgMCB8fCB4SGVpZ2h0ID49ICR7bFsyXX0pIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKGludCB3V2lkdGggPSAwOyB3V2lkdGggPCAke3BbM119OyB3V2lkdGgrKykge1xcbiAgICAgICAgICBpbnQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiAke3UuZGlsYXRpb25zWzFdfTtcXG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDAgfHwgeFdpZHRoID49ICR7bFszXX0pIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgaW5wdXRfY2hhbm5lbCwgeFdpZHRoLCB4SGVpZ2h0KTtcXG4gICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcob3V0cHV0X2NoYW5uZWwsIHdJbkNoYW5uZWwsIHdXaWR0aCwgd0hlaWdodCk7XFxuICAgICAgICAgIHZhbHVlICs9IHhWYWwqd1ZhbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgJHtjfVxcbiAgICAke2J9XFxuICAgICR7aC5vdXRwdXR9ID0gdmVjNCh2YWx1ZSwgLjAsIC4wLCAuMCk7XFxuICB9XFxuYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtvdXRwdXQ6e2RpbXM6ZCx0eXBlOmVbMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6bSxoYXNNYWluOiEwfSl9KSh0LGUsdSxuKX0pfX0sMTM4NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jb252MkRQYWNrZWQ9ZS5jb252MkRQYWNrZWRQb2ludHdpc2U9dm9pZCAwO2NvbnN0IHI9big4MTM4KSxpPW4oODU1NSksbz1uKDcwOCk7ZS5jb252MkRQYWNrZWRQb2ludHdpc2U9KHQsZSxuKT0+e2NvbnN0IGk9ZVswXS5kaW1zLGE9ZVsxXS5kaW1zLHM9KDAsci5jYWxjdWxhdGVPdXRwdXRTaGFwZSkoaSxhLG4uZGlsYXRpb25zLG4ucGFkcyxuLnN0cmlkZXMpLHU9dC5yZXNoYXBlUGFja2VkKGVbMF0sW2lbMV0saVsyXSppWzNdXSksYz10LnJlc2hhcGVQYWNrZWQoZVsxXSxbYVswXSxhWzFdXSksbD1lLmxlbmd0aD4yP1tjLHUsZVsyXV06W2MsdV0scD10LnJ1bigoMCxvLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKSh0LGwsbiksbCk7cmV0dXJuIHQucmVzaGFwZVBhY2tlZChwLHMpfSxlLmNvbnYyRFBhY2tlZD0odCxlLG4pPT57Y29uc3QgYT1lWzBdLmRpbXMscz1lWzFdLmRpbXMsdT0oMCxyLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShhLHMsbi5kaWxhdGlvbnMsbi5wYWRzLG4uc3RyaWRlcyksYz10LnJ1bigoMCxpLmNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvTG9hZGVyKSh0LGVbMF0sZVsxXSx1LG4pLFtlWzBdXSksbD10LnJlc2hhcGVQYWNrZWQoZVsxXSxbc1swXSxzWzFdKnNbMl0qc1szXV0pLHA9Mz09PWUubGVuZ3RoP1tsLGMsZVsyXV06W2wsY10sZj10LnJ1bigoMCxvLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKSh0LHAsbikscCk7cmV0dXJuIHQucmVzaGFwZVBhY2tlZChmLHUpfX0sOTY2MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPWUuY29udlRyYW5zcG9zZT12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDUwNjApLG89bigyMDM5KSxhPW4oMjgyMykscz0odCxlLG4scixpLG8pPT4odC0xKSplK24rKHItMSkqaSsxLW8sdT0odCxlLG4scixpKT0+e2NvbnN0IG89TWF0aC5mbG9vcih0LzIpO1wiU0FNRV9VUFBFUlwiPT09ZT8obltyXT1vLG5baV09dC1vKTpcIlNBTUVfTE9XRVJcIj09PWUmJihuW3JdPXQtbyxuW2ldPW8pfTtlLmNvbnZUcmFuc3Bvc2U9KHQsZSxuKT0+KGYoZSxuKSxjKHQsZSxuKSk7Y29uc3QgYz0odCxlLG4pPT57Y29uc3Qgcj1wKG4sZSk7cmV0dXJuW2wodCxlLHIpXX0sbD0odCxlLG4pPT50LnJ1bigoKHQsZSxuKT0+e2NvbnN0IHI9KHM9ZS5sZW5ndGg+Mix1PW4uY2FjaGVLZXkse25hbWU6XCJDb252VHJhbnNwb3NlXCIsaW5wdXROYW1lczpzP1tcIlhcIixcIldcIixcIkJcIl06W1wiWFwiLFwiV1wiXSxpbnB1dFR5cGVzOnM/W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkXTpbby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6dX0pO3ZhciBzLHU7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7Z2V0OigpPT4oKHQsZSxuLHIpPT57Y29uc3Qgcz1lLmxlbmd0aD4yP1wiZ2V0QihvdXRwdXRfY2hhbm5lbClcIjpcIjAuMFwiLHU9ZVswXS5kaW1zLGM9ZVsxXS5kaW1zLGw9Y1sxXSxwPWNbMF0vci5ncm91cCxmPVtlWzBdLmRpbXNbMF0sZVsxXS5kaW1zWzFdKnIuZ3JvdXAsLi4uci5vdXRwdXRTaGFwZV0sZD0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx7YWN0aXZhdGlvbkZ1bmN0aW9uOmgsYXBwbHlBY3RpdmF0aW9uOmd9PSgwLGEuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKHIpLGI9YFxcbiAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKCR7ci5zdHJpZGVzWzBdfSwgJHtyLnN0cmlkZXNbMV19KTtcXG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3IucGFkc1swXX0sICR7ci5wYWRzWzFdfSk7XFxuICAke2h9XFxuICB2b2lkIG1haW4oKSB7XFxuICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgaW50IG91dHB1dF9jaGFubmVsID0gY29vcmRzLnk7XFxuXFxuICAgIGl2ZWMyIGxvYyA9IGNvb3Jkcy56dyArIHBhZHM7XFxuXFxuICAgIGludCBncm91cF9pZCA9IG91dHB1dF9jaGFubmVsIC8gJHtsfTtcXG4gICAgaW50IHdPdXRDaGFubmVsID0gb3V0cHV0X2NoYW5uZWwgLSBncm91cF9pZCAqICR7bH07XFxuXFxuICAgIGZsb2F0IHZhbHVlID0gJHtzfTtcXG4gICAgZm9yIChpbnQgaW5DaGFubmVsT2Zmc2V0ID0gMDsgaW5DaGFubmVsT2Zmc2V0IDwgJHtwfTsgaW5DaGFubmVsT2Zmc2V0KyspIHtcXG4gICAgICBpbnQgaW5wdXRfY2hhbm5lbCA9IGdyb3VwX2lkICogJHtwfSArIGluQ2hhbm5lbE9mZnNldDtcXG4gICAgICBmb3IgKGludCB3V09mZiA9IDA7IHdXT2ZmIDwgJHtjWzJdfTsgd1dPZmYrKykge1xcbiAgICAgICAgZm9yIChpbnQgd0hPZmYgPSAwOyB3SE9mZiA8ICR7Y1szXX07IHdIT2ZmKyspIHtcXG4gICAgICAgICAgaXZlYzIgd09mZiA9IGl2ZWMyKHdXT2ZmICogJHtyLmRpbGF0aW9uc1swXX0sIHdIT2ZmICogJHtyLmRpbGF0aW9uc1sxXX0pO1xcbiAgICAgICAgICBpdmVjMiB3TG9jID0gbG9jIC0gd09mZjtcXG4gICAgICAgICAgaXZlYzIgd0xvY0luID0gd0xvYyAvIHN0cmlkZXM7XFxuICAgICAgICAgIGlmIChcXG4gICAgICAgICAgICB3TG9jSW4gKiBzdHJpZGVzID09IHdMb2MgJiZcXG4gICAgICAgICAgICB3TG9jSW4ueCA+PSAwICYmIHdMb2NJbi54IDwgJHt1WzJdfSAmJlxcbiAgICAgICAgICAgIHdMb2NJbi55ID49IDAgJiYgd0xvY0luLnkgPCAke3VbM119XFxuICAgICAgICAgICkge1xcbiAgICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCBpbnB1dF9jaGFubmVsLCB3TG9jSW4ueSwgd0xvY0luLngpO1xcbiAgICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKGlucHV0X2NoYW5uZWwsIHdPdXRDaGFubmVsLCB3SE9mZiwgd1dPZmYpO1xcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgICR7Z31cXG4gICAgJHtkLm91dHB1dH0gPSB2ZWM0KHZhbHVlLCAuMCwgLjAsIC4wKTtcXG4gIH1cXG5gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpmLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpiLGhhc01haW46ITB9KX0pKHQsZSxyLG4pfSl9KSh0LGUsbiksZSkscD0odCxlKT0+e2NvbnN0IG49dC5rZXJuZWxTaGFwZS5zbGljZSgpO2lmKDA9PT10Lmtlcm5lbFNoYXBlLmxlbmd0aClmb3IobGV0IHQ9Mjt0PGVbMV0uZGltcy5sZW5ndGg7Kyt0KW4ucHVzaChlWzFdLmRpbXNbdF0pO2NvbnN0IHI9dC5wYWRzLnNsaWNlKCksaT10Lm91dHB1dFNoYXBlLnNsaWNlKCk7KCh0LGUsbixyLGksbyxhLGMpPT57Y29uc3QgbD10Lmxlbmd0aC0yLHA9MD09PWMubGVuZ3RoO2ZvcihsZXQgZj0wO2Y8bDsrK2Ype2NvbnN0IGQ9cD90W2YrMl0qb1tmXTpjW2ZdLGg9cyh0W2YrMl0sb1tmXSxpW2ZdLGVbZl0sbltmXSxkKTt1KGgscixpLGYsZitsKSxwJiZjLnB1c2gob1tmXSoodFtmKzJdLTEpK2FbZl0rKGVbZl0tMSkqbltmXSsxLWlbZl0taVtmK2xdKX19KShlWzBdLmRpbXMsbix0LmRpbGF0aW9ucyx0LmF1dG9QYWQscix0LnN0cmlkZXMsdC5vdXRwdXRQYWRkaW5nLGkpO2NvbnN0IG89T2JqZWN0LmFzc2lnbih7fSx0KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihvLHtrZXJuZWxTaGFwZTpuLHBhZHM6cixvdXRwdXRTaGFwZTppLGNhY2hlS2V5OnQuY2FjaGVLZXl9KSxvfTtlLnBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXM9dD0+e2NvbnN0IGU9dC5hdHRyaWJ1dGVzLG49KDAsYS5wYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpKGUpLGk9ZS5nZXRTdHJpbmcoXCJhdXRvX3BhZFwiLFwiTk9UU0VUXCIpLG89ZS5nZXRJbnRzKFwiZGlsYXRpb25zXCIsWzEsMV0pLHM9ZS5nZXRJbnQoXCJncm91cFwiLDEpLHU9ZS5nZXRJbnRzKFwia2VybmVsX3NoYXBlXCIsW10pLGM9ZS5nZXRJbnRzKFwib3V0cHV0X3BhZGRpbmdcIixbMCwwXSksbD1lLmdldEludHMoXCJvdXRwdXRfc2hhcGVcIixbXSkscD1lLmdldEludHMoXCJwYWRzXCIsWzAsMCwwLDBdKSxmPWUuZ2V0SW50cyhcInN0cmlkZXNcIixbMSwxXSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKE9iamVjdC5hc3NpZ24oe2F1dG9QYWQ6aSxkaWxhdGlvbnM6byxncm91cDpzLGtlcm5lbFNoYXBlOnUsb3V0cHV0UGFkZGluZzpjLG91dHB1dFNoYXBlOmwscGFkczpwLHN0cmlkZXM6Zn0sbikpfTtjb25zdCBmPSh0LGUpPT57aWYoIXR8fDIhPT10Lmxlbmd0aCYmMyE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZig0IT09dFswXS5kaW1zLmxlbmd0aHx8NCE9PXRbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG9ubHkgc3VwcG9ydCAyLWRpbWVuc2lvbmFsIGNvbnZcIik7aWYodFswXS5kaW1zWzFdIT09dFsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcIkZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcIik7Y29uc3Qgbj10WzFdLmRpbXNbMV0qZS5ncm91cDtpZigzPT09dC5sZW5ndGgmJigxIT09dFsyXS5kaW1zLmxlbmd0aHx8dFsyXS5kaW1zWzBdIT09bikpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2NvbnN0IHI9dFswXS5kaW1zLmxlbmd0aC0yO2lmKGUuZGlsYXRpb25zLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7cn1EYCk7aWYoZS5zdHJpZGVzLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3J9RGApO2lmKGUucGFkcy5sZW5ndGghPT0yKnIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAkezIqcn1EYCk7aWYoZS5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBvdXRwdXRfcGFkZGluZyBzaG91bGQgYmUgJHtyfURgKTtpZigwIT09ZS5rZXJuZWxTaGFwZS5sZW5ndGgmJmUua2VybmVsU2hhcGUubGVuZ3RoIT09dFsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKDAhPT1lLm91dHB1dFNoYXBlLmxlbmd0aCYmZS5vdXRwdXRTaGFwZS5sZW5ndGghPT10WzBdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvdXRwdXQgc2hhcGVcIik7aWYoXCJmbG9hdDMyXCIhPT10WzBdLnR5cGV8fFwiZmxvYXQzMlwiIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkNvbnZUcmFuc3Bvc2UgaW5wdXQoWCxXKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpO2lmKDM9PT10Lmxlbmd0aCYmXCJmbG9hdDMyXCIhPT10WzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ29udlRyYW5zcG9zZSBpbnB1dChiaWFzKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfX0sODEzODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUNvbnZBdHRyaWJ1dGVzPWUuY29udj1lLmNhbGN1bGF0ZU91dHB1dFNoYXBlPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDQ3NzApLGE9bigxMzg2KSxzPW4oOTgyOCksdT1uKDI4MjMpLGM9bigzMjQ4KSxsPW4oNTYyMyk7ZS5jYWxjdWxhdGVPdXRwdXRTaGFwZT0odCxlLG4scixpKT0+e2NvbnN0IG89dFswXSxhPXQuc2xpY2UoMikscz1hLmxlbmd0aCx1PWVbMF0sYz1lLnNsaWNlKDIpLm1hcCgoKHQsZSk9PnQrKHQtMSkqKG5bZV0tMSkpKSxsPWEubWFwKCgodCxlKT0+dCtyW2VdK3JbZStzXSkpLm1hcCgoKHQsZSk9Pk1hdGguZmxvb3IoKHQtY1tlXStpW2VdKS9pW2VdKSkpO3JldHVybltvLHVdLmNvbmNhdCguLi5sKX0sZS5jb252PSh0LGUsbik9PihnKGUsbikscCh0LGUsbikpO2NvbnN0IHA9KHQsZSxuKT0+e2NvbnN0IHI9aChuLGUpLGk9dC5zZXNzaW9uLnBhY2sscz0xPT09ci5rZXJuZWxTaGFwZVswXSYmMT09PXIua2VybmVsU2hhcGVbMV07cmV0dXJuIHIuZ3JvdXA+MT9bdC5ydW4oKDAsby5jcmVhdGVVbnBhY2tlZEdyb3VwZWRDb252UHJvZ3JhbUluZm9Mb2FkZXIpKHQsZSxyKSxlKV06cyYmaT9bZih0LGUscildOmkmJjQ9PT1lWzBdLmRpbXMubGVuZ3RoJiYxPT09ZVswXS5kaW1zWzBdJiYhcz9bKDAsYS5jb252MkRQYWNrZWQpKHQsZSxyKV06W2QodCxlLHIpXX0sZj0odCxuLHIpPT57Y29uc3QgaT1uWzBdLmRpbXMsbz1uWzFdLmRpbXMsYT0oMCxlLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShpLG8sci5kaWxhdGlvbnMsci5wYWRzLHIuc3RyaWRlcykscz10LnJlc2hhcGVVbnBhY2tlZChuWzBdLFtpWzFdLGlbMl0qaVszXV0pLHU9dC5yZXNoYXBlVW5wYWNrZWQoblsxXSxbb1swXSxvWzFdXSksYz1uLmxlbmd0aD4yP1t1LHMsblsyXV06W3Usc10scD10LnJ1bigoMCxsLmNyZWF0ZU1hdG11bFByb2dyYW1JbmZvTG9hZGVyKShjLHIpLGMpO3JldHVybiB0LnJlc2hhcGVVbnBhY2tlZChwLGEpfSxkPSh0LG4scik9Pntjb25zdCBpPW5bMF0uZGltcyxvPW5bMV0uZGltcyxhPSgwLGUuY2FsY3VsYXRlT3V0cHV0U2hhcGUpKGksbyxyLmRpbGF0aW9ucyxyLnBhZHMsci5zdHJpZGVzKSx1PXQucnVuKCgwLGMuY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXIpKHQsblswXSxuWzFdLGEsciksW25bMF1dKSxsPTM9PT1uLmxlbmd0aD9bdSxuWzFdLG5bMl1dOlt1LG5bMV1dO3JldHVybiB0LnJ1bigoMCxzLmNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlcikodCxuLGEsciksbCl9LGg9KHQsZSk9Pntjb25zdCBuPXQua2VybmVsU2hhcGUuc2xpY2UoKTtpZigwPT09dC5rZXJuZWxTaGFwZS5sZW5ndGgpZm9yKGxldCB0PTI7dDxlWzFdLmRpbXMubGVuZ3RoOysrdCluLnB1c2goZVsxXS5kaW1zW3RdKTtjb25zdCByPXQucGFkcy5zbGljZSgpO2kuUG9vbENvbnZVdGlsLmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChlWzBdLmRpbXMsdC5zdHJpZGVzLHQuZGlsYXRpb25zLG4scix0LmF1dG9QYWQpO2NvbnN0IG89T2JqZWN0LmFzc2lnbih7fSx0KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihvLHtrZXJuZWxTaGFwZTpuLHBhZHM6cixjYWNoZUtleTp0LmNhY2hlS2V5fSksb307ZS5wYXJzZUNvbnZBdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcyxuPSgwLHUucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKShlKSxpPWUuZ2V0U3RyaW5nKFwiYXV0b19wYWRcIixcIk5PVFNFVFwiKSxvPWUuZ2V0SW50cyhcImRpbGF0aW9uc1wiLFsxLDFdKSxhPWUuZ2V0SW50KFwiZ3JvdXBcIiwxKSxzPWUuZ2V0SW50cyhcImtlcm5lbF9zaGFwZVwiLFtdKSxjPWUuZ2V0SW50cyhcInBhZHNcIixbMCwwLDAsMF0pLGw9ZS5nZXRJbnRzKFwic3RyaWRlc1wiLFsxLDFdKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoT2JqZWN0LmFzc2lnbih7YXV0b1BhZDppLGRpbGF0aW9uczpvLGdyb3VwOmEsa2VybmVsU2hhcGU6cyxwYWRzOmMsc3RyaWRlczpsfSxuKSl9O2NvbnN0IGc9KHQsZSk9PntpZighdHx8MiE9PXQubGVuZ3RoJiYzIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKDQhPT10WzBdLmRpbXMubGVuZ3RofHw0IT09dFsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udlwiKTtpZih0WzBdLmRpbXNbMV0hPT10WzFdLmRpbXNbMV0qZS5ncm91cCl0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2lmKDM9PT10Lmxlbmd0aCYmKDEhPT10WzJdLmRpbXMubGVuZ3RofHx0WzFdLmRpbXNbMF0hPT10WzJdLmRpbXNbMF0pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmlhc1wiKTtjb25zdCBuPXRbMF0uZGltcy5sZW5ndGgtMjtpZihlLmRpbGF0aW9ucy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke259RGApO2lmKGUuc3RyaWRlcy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtufURgKTtpZihlLnBhZHMubGVuZ3RoIT09MipuKXRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHsyKm59RGApO2lmKDAhPT1lLmtlcm5lbFNoYXBlLmxlbmd0aCYmZS5rZXJuZWxTaGFwZS5sZW5ndGghPT10WzFdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXJuZWwgc2hhcGVcIik7aWYoXCJmbG9hdDMyXCIhPT10WzBdLnR5cGV8fFwiZmxvYXQzMlwiIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkNvbnYgaW5wdXQoWCxXKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpO2lmKDM9PT10Lmxlbmd0aCYmXCJmbG9hdDMyXCIhPT10WzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ29udiBpbnB1dChiaWFzKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfX0sNTE5MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXM9ZS5kZXB0aFRvU3BhY2U9dm9pZCAwO2NvbnN0IHI9bigzNzM4KTtlLmRlcHRoVG9TcGFjZT0odCxlLG4pPT57aShlKTtjb25zdCBvPW4uYmxvY2tzaXplLGE9bypvLHM9XCJEQ1JcIj09PW4ubW9kZT9bMCwzLDQsMSw1LDJdOlswLDEsNCwyLDUsM10sdT1cIkRDUlwiPT09bi5tb2RlP1tlWzBdLmRpbXNbMF0sbyxvLGVbMF0uZGltc1sxXS9hLGVbMF0uZGltc1syXSxlWzBdLmRpbXNbM11dOltlWzBdLmRpbXNbMF0sZVswXS5kaW1zWzFdL2EsbyxvLGVbMF0uZGltc1syXSxlWzBdLmRpbXNbM11dLGM9dC5yZXNoYXBlVW5wYWNrZWQoZVswXSx1KSxsPXtwZXJtOnMsY2FjaGVLZXk6YCR7c31gfSxbcF09KDAsci50cmFuc3Bvc2UpKHQsW2NdLGwpLGY9W2VbMF0uZGltc1swXSxlWzBdLmRpbXNbMV0vYSxlWzBdLmRpbXNbMl0qbyxlWzBdLmRpbXNbM10qb107cmV0dXJuW3QucmVzaGFwZVVucGFja2VkKHAsZildfSxlLnBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlcz10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwiYmxvY2tzaXplXCIpO2lmKGU8MSl0aHJvdyBuZXcgRXJyb3IoYGJsb2Nrc2l6ZSBtdXN0IGJlID49IDEsIGJ1dCBnb3QgOiAke2V9IGZvciBEZXB0aFRvU3BhY2VgKTtjb25zdCBuPXQuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJtb2RlXCIsXCJEQ1JcIik7aWYoXCJEQ1JcIiE9PW4mJlwiQ1JEXCIhPT1uKXRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIG1vZGU6ICR7bn0gZm9yIERlcHRoVG9TcGFjZWApO3JldHVybnttb2RlOm4sYmxvY2tzaXplOmV9fTtjb25zdCBpPXQ9PntpZigxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBEZXB0aFRvU3BhY2UgZXhwZWN0IDEgaW5wdXRzLCBidXQgZ290ICR7dC5sZW5ndGh9YCk7aWYoXCJzdHJpbmdcIj09PXRbMF0udHlwZXx8NCE9PXRbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcHRoVG9TcGFjZSBpbnB1dCBzaG91bGQgYmUgYSA0LUQgbnVtZXJpYyB0ZW5zb3JcIil9fSw5ODI4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpLGk9big1MDYwKSxvPW4oMjAzOSksYT1uKDI4MjMpLHM9bigzMjQ4KTtlLmNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlcj0odCxlLG4sdSk9Pntjb25zdCBjPSgodCxlKT0+KHtuYW1lOlwiQ29udkRvdFByb2R1Y3RcIixpbnB1dE5hbWVzOnQ/W1wiSW0yQ29sXCIsXCJLXCIsXCJCXCJdOltcIkltMkNvbFwiLFwiS1wiXSxpbnB1dFR5cGVzOnQ/W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdOltvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbl0sY2FjaGVLZXk6ZS5hY3RpdmF0aW9uQ2FjaGVLZXl9KSkoZS5sZW5ndGg+Mix1KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGMpLHtnZXQ6KCk9PigodCxlLG4sdSxjKT0+e2NvbnN0IGw9blswXS5kaW1zLHA9blsxXS5kaW1zLGY9W3BbMF0sTWF0aC5jZWlsKGxbMV0qcFsyXSpwWzNdLzQpXSxkPSgwLHMuY2FsY3VsYXRlSW0yQ29sRGltcykobCxwLHUpLFtoLGddPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGYsby5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKSxiPXIuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGQpLFttLHldPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGQsby5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKSxfPXUubGVuZ3RoLHY9bi5sZW5ndGg8Mz9cIjAuMFwiOlwiX0IoYilcIix3PU1hdGguY2VpbChsWzFdKnBbMl0qcFszXS80KSx7YWN0aXZhdGlvbkZ1bmN0aW9uOngsYXBwbHlBY3RpdmF0aW9uOlR9PSgwLGEuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKGMpLFM9KDAsaS5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksTz1gXFxuJHt4fVxcbmZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtffV0pIHtcXG4gIGludCBiWzFdO1xcbiAgYlswXSA9IGluZGljZXNbMV07XFxuICBpbnQgaW0yY29sWzRdO1xcbiAgaW0yY29sWzBdID0gaW5kaWNlc1swXTtcXG4gIGltMmNvbFsxXSA9IGluZGljZXNbMl07XFxuICBpbTJjb2xbMl0gPSBpbmRpY2VzWzNdO1xcbiAgaW50IGltMmNvbE9mZnNldCA9IGltMmNvbFswXSAqICR7YlswXX0gKyBpbTJjb2xbMV0gKiAke2JbMV19ICsgaW0yY29sWzJdICogJHtiWzJdfTtcXG4gIGludCBrZXJuZWxPZmZzZXQgPSBpbmRpY2VzWzFdICogJHtmWzFdfTtcXG4gIGZsb2F0IHZhbHVlID0gJHt2fTtcXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgJHt3fTsgKytpKSB7XFxuICAgIHZlYzIgaW0yY29sQ29vcmRzID0gb2Zmc2V0VG9Db29yZHMoaW0yY29sT2Zmc2V0LCAke219LCAke3l9KTtcXG4gICAgdmVjMiBrZXJuZWxDb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhrZXJuZWxPZmZzZXQsICR7aH0sICR7Z30pO1xcbiAgICB2YWx1ZSArPSBkb3QoJHtTLnRleHR1cmUyRH0oSW0yQ29sLCBpbTJjb2xDb29yZHMpLCAke1MudGV4dHVyZTJEfShLLCBrZXJuZWxDb29yZHMpKTtcXG4gICAgKytpbTJjb2xPZmZzZXQ7XFxuICAgICsra2VybmVsT2Zmc2V0O1xcbiAgfVxcbiAgJHtUfVxcbiAgcmV0dXJuIHZhbHVlO1xcbn1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczp1LHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpPfSl9KSh0LGMsZSxuLHUpfSl9fSw3OTkyOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlRmxhdHRlbkF0dHJpYnV0ZXM9ZS5mbGF0dGVuPXZvaWQgMDtjb25zdCByPW4oMjUxNyk7ZS5mbGF0dGVuPSh0LGUsbik9PntpKGUsbik7Y29uc3Qgbz1yLlNoYXBlVXRpbC5mbGF0dGVuU2hhcGUoZVswXS5kaW1zLG4pO3JldHVyblt0LnJlc2hhcGVVbnBhY2tlZChlWzBdLG8pXX0sZS5wYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzPXQ9PnQuYXR0cmlidXRlcy5nZXRJbnQoXCJheGlzXCIsMSk7Y29uc3QgaT0odCxlKT0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRmxhdHRlbiByZXF1aXJlcyAxIGlucHV0LlwiKTtjb25zdCBuPXRbMF0uZGltcy5sZW5ndGg7aWYoMD09PW4pdGhyb3cgbmV3IEVycm9yKFwic2NhbGFyIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkLlwiKTtpZihlPC1ufHxlPm4pdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBheGlzXCIpO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkLlwiKX19LDI4MjM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzPWUuZ2V0QWN0aXZhdGlvblNuaXBwZXQ9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oNDkwOSk7ZS5nZXRBY3RpdmF0aW9uU25pcHBldD1mdW5jdGlvbih0KXtsZXQgZTtzd2l0Y2godC5hY3RpdmF0aW9uKXtjYXNlXCJSZWx1XCI6ZT0oMCxpLmdsc2xSZWx1KSgpO2JyZWFrO2Nhc2VcIlNpZ21vaWRcIjplPSgwLGkuZ2xzbFNpZ21vaWQpKCk7YnJlYWs7Y2FzZVwiQ2xpcFwiOmU9KDAsaS5nbHNsQ2xpcCkodC5jbGlwTWluLHQuY2xpcE1heCk7YnJlYWs7ZGVmYXVsdDpyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOlwiXCIsYXBwbHlBY3RpdmF0aW9uOlwiXCJ9fWNvbnN0IG49ZS5uYW1lO3JldHVybnthY3RpdmF0aW9uRnVuY3Rpb246ZS5ib2R5LGFwcGx5QWN0aXZhdGlvbjpgdmFsdWUgPSAke259Xyh2YWx1ZSk7YH19LGUucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuZ2V0U3RyaW5nKFwiYWN0aXZhdGlvblwiLFwiXCIpO2lmKFwiQ2xpcFwiPT09ZSl7Y29uc3RbbixpXT10LmdldEZsb2F0cyhcImFjdGl2YXRpb25fcGFyYW1zXCIsW3IuTUlOX0NMSVAsci5NQVhfQ0xJUF0pO3JldHVybnthY3RpdmF0aW9uOmUsY2xpcE1heDppLGNsaXBNaW46bixhY3RpdmF0aW9uQ2FjaGVLZXk6YCR7ZX06JHtufSwke2l9YH19cmV0dXJue2FjdGl2YXRpb246ZSxhY3RpdmF0aW9uQ2FjaGVLZXk6ZX19fSwxMjUzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlR2F0aGVyQXR0cmlidXRlcz1lLmdhdGhlcj12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDc4Miksbz1uKDI1MTcpLGE9bigyMDM5KTtlLmdhdGhlcj0odCxlLG4pPT4oYyhlLG4uYXhpcyksW3QucnVuKHUodCxlLG4pLGUpXSksZS5wYXJzZUdhdGhlckF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtheGlzOnQuYXR0cmlidXRlcy5nZXRJbnQoXCJheGlzXCIsMCl9KTtjb25zdCBzPXtuYW1lOlwiR2F0aGVyXCIsaW5wdXROYW1lczpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6W2EuVGV4dHVyZVR5cGUudW5wYWNrZWQsYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19LHU9KHQsZSxuKT0+e2NvbnN0IHI9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleX0pO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+KCh0LGUsbixyKT0+e2NvbnN0IGk9blswXS5kaW1zLnNsaWNlKCkscz1uWzFdLmRpbXMuc2xpY2UoKSx1PW5ldyBBcnJheShpLmxlbmd0aCtzLmxlbmd0aC0xKTtyPW8uU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMocixpLmxlbmd0aCk7Y29uc3QgYz1bXTtmb3IobGV0IHQ9MDt0PHUubGVuZ3RoO3QrKyl0PHI/KHVbdF09aVt0XSxjLnB1c2goYGlucHV0SWR4WyR7dH1dID0gb3V0cHV0SWR4WyR7dH1dO2ApKTp0PHIrcy5sZW5ndGg/KHVbdF09c1t0LXJdLGMucHVzaChgaW5kZXhEYXRhSWR4WyR7dC1yfV0gPSBvdXRwdXRJZHhbJHt0fV07YCkpOih1W3RdPWlbdC1zLmxlbmd0aCsxXSxjLnB1c2goYGlucHV0SWR4WyR7dC1zLmxlbmd0aCsxfV0gPSBvdXRwdXRJZHhbJHt0fV07YCkpO2NvbnN0IGw9YFxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IG91dHB1dElkeFske3UubGVuZ3RofHwxfV0pIHtcXG4gICAgICAgIGludCBpbnB1dElkeFske2kubGVuZ3RofV07XFxuICAgICAgICBpbnQgaW5kZXhEYXRhSWR4WyR7cy5sZW5ndGh8fDF9XTtcXG4gICAgICAgIGluZGV4RGF0YUlkeFswXSA9IDA7XFxuICAgICAgICAke2Muam9pbihcIlxcbiAgICAgICAgXCIpfVxcbiAgICAgICAgaW50IGlkeCA9IGludChfQihpbmRleERhdGFJZHgpKTtcXG4gICAgICAgIGlucHV0SWR4WyR7cn1dID0gaWR4IDwgMCA/IGlkeCArICR7aVtyXX0gOiBpZHg7XFxuICAgICAgICByZXR1cm4gX0EoaW5wdXRJZHgpO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczp1LHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOmEuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpsfSl9KSgwLHIsZSxuLmF4aXMpfSl9LGM9KHQsZSk9PntpZighdHx8MiE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkdhdGhlciByZXF1aXJlcyAyIGlucHV0cy5cIik7Y29uc3Qgbj10WzBdLmRpbXMubGVuZ3RoO2lmKG48MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHNoYXBlLlwiKTtpZihlPC1ufHxlPm4tMSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGF4aXMuXCIpO2lmKC0xPT09aS5OVU1CRVJfVFlQRVMuaW5kZXhPZih0WzBdLnR5cGUpKXRocm93IG5ldyBFcnJvcihcIkludmFpZCBpbnB1dCB0eXBlLlwiKTtpZihcImludDMyXCIhPT10WzFdLnR5cGUmJlwiaW50MTZcIiE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhaWQgaW5wdXQgdHlwZS5cIil9fSw0Nzc2Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlR2VtbUF0dHJpYnV0ZXNWMTE9ZS5wYXJzZUdlbW1BdHRyaWJ1dGVzVjc9ZS5nZW1tPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDIwMzkpO2UuZ2VtbT0odCxlLG4pPT4oYyhlLG4pLFt0LnJ1bihzKGUsbiksZSldKTtjb25zdCBhPSh0LGUpPT57Y29uc3Qgbj0wIT09dC5hdHRyaWJ1dGVzLmdldEludChcInRyYW5zQVwiLDApLGk9MCE9PXQuYXR0cmlidXRlcy5nZXRJbnQoXCJ0cmFuc0JcIiwwKSxvPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcImFscGhhXCIsMSksYT10LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJiZXRhXCIsMSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHt0cmFuc0E6bix0cmFuc0I6aSxhbHBoYTpvLGJldGE6YSxpc09wdGlvbmFsQzplfSl9O2UucGFyc2VHZW1tQXR0cmlidXRlc1Y3PXQ9PmEodCwhMSksZS5wYXJzZUdlbW1BdHRyaWJ1dGVzVjExPXQ9PmEodCwhMCk7Y29uc3Qgcz0odCxlKT0+e2NvbnN0IG49e25hbWU6XCJHZW1tXCIsaW5wdXROYW1lczozPT09dC5sZW5ndGg/W1wiQVwiLFwiQlwiLFwiQ1wiXTpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6Mz09PXQubGVuZ3RoP1tvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZF06W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZF0sa2V5OmUuY2FjaGVLZXl9O3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+dShuLHQsZSl9KX0sdT0odCxlLG4pPT57Y29uc3Qgcj1lWzBdLmRpbXMuc2xpY2UoKSxhPWVbMV0uZGltcy5zbGljZSgpLFtzLHVdPWkuR2VtbVV0aWwuZ2V0U2hhcGVPZkdlbW1SZXN1bHQocixuLnRyYW5zQSxhLG4udHJhbnNCLDM9PT1lLmxlbmd0aD9lWzJdLmRpbXM6dm9pZCAwKSxjPVtzLHVdO2lmKCFjKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCBsPXJbci5sZW5ndGgtMV0scD1cIlwiO24udHJhbnNBJiYobD1yWzBdKSxuLnRyYW5zQSYmbi50cmFuc0I/cD1cInZhbHVlICs9IF9BX1QoYSkgKiBfQl9UKGIpO1wiOm4udHJhbnNBJiYhbi50cmFuc0I/cD1cInZhbHVlICs9IF9BX1QoYSkgKiBfQihiKTtcIjohbi50cmFuc0EmJm4udHJhbnNCP3A9XCJ2YWx1ZSArPSBfQShhKSAqIF9CX1QoYik7XCI6bi50cmFuc0F8fG4udHJhbnNCfHwocD1cInZhbHVlICs9IF9BKGEpICogX0IoYik7XCIpO2NvbnN0IGY9Yy5sZW5ndGgsZD1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2Z9XSkge1xcbiAgICAgICAgICBpbnQgYVske2Z9XTtcXG4gICAgICAgICAgaW50IGJbJHtmfV07XFxuICAgICAgICAgICR7Mz09PWUubGVuZ3RoP2BpbnQgY1ske2VbMl0uZGltcy5sZW5ndGh9XTtgOlwiXCJ9XFxuXFxuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgYSk7XFxuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgYik7XFxuICAgICAgICAgICR7Mz09PWUubGVuZ3RoP1wiYmNhc3RJbmRpY2VzX0MoaW5kaWNlcywgYyk7XCI6XCJcIn1cXG5cXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSAwLjA7XFxuICAgICAgICAgIGZvciAoaW50IGs9MDsgazwke2x9OyArK2spIHtcXG4gICAgICAgICAgICAgIGFbJHtmLTF9XSA9IGs7XFxuICAgICAgICAgICAgICBiWyR7Zi0yfV0gPSBrO1xcbiAgICAgICAgICAgICAgJHtwfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiBhbHBoYTtcXG4gICAgICAgICAgJHszPT09ZS5sZW5ndGg/XCJ2YWx1ZSArPSBiZXRhICogX0MoYyk7XCI6XCJcIn1cXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dDp7ZGltczpjLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHZhcmlhYmxlczpbe25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmbG9hdFwiLGRhdGE6bi5hbHBoYX0se25hbWU6XCJiZXRhXCIsdHlwZTpcImZsb2F0XCIsZGF0YTpuLmJldGF9XSxzaGFkZXJTb3VyY2U6ZH0pfSxjPSh0LGUpPT57aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbWlzc2luZ1wiKTtpZihlLmlzT3B0aW9uYWxDJiYodC5sZW5ndGg8Mnx8dC5sZW5ndGg+MykpdGhyb3cgbmV3IEVycm9yKFwiSW52YWlkIGlucHV0IHNoYXBlLlwiKTtpZighZS5pc09wdGlvbmFsQyYmMyE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkdlbW0gcmVxdWlyZXMgMyBpbnB1dHNcIik7aWYoMz09PXQubGVuZ3RoJiYxIT09dFsyXS5kaW1zLmxlbmd0aCYmMiE9PXRbMl0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZSBvZiBDXCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZXx8XCJmbG9hdDMyXCIhPT10WzFdLnR5cGUmJlwiZmxvYXQ2NFwiIT09dFsxXS50eXBlfHwzPT09dC5sZW5ndGgmJlwiZmxvYXQzMlwiIT09dFsyXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMl0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKHRbMF0udHlwZSE9PXRbMV0udHlwZXx8Mz09PXQubGVuZ3RoJiZ0WzBdLnR5cGUhPT10WzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZXMgYXJlIG1pc21hdGNoZWRcIil9fSw4NTU1Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNTA2MCksaT1uKDIwMzkpLG89bigyODI3KTtlLmNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvTG9hZGVyPSh0LGUsbixhLHMpPT57Y29uc3QgdT0oYz1zLmNhY2hlS2V5LHtuYW1lOlwiSW0yQ29sIChwYWNrZWQpXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUucGFja2VkXSxjYWNoZUhpbnQ6Y30pO3ZhciBjO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse2dldDooKT0+KCh0LGUsbixhLHMsdSk9Pntjb25zdCBjPW4uZGltcyxsPWEuZGltcyxwPXMubGVuZ3RoLGY9W2xbMV0qbFsyXSpsWzNdLHNbMl0qc1szXV0sZD1sWzJdKmxbM10saD0oMCxvLnVucGFja0Zyb21DaGFubmVsKSgpLGc9KDAsci5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7bGV0IGI9XCJcIjtmb3IobGV0IHQ9MDt0PD0xO3QrKylmb3IobGV0IGU9MDtlPD0xO2UrKyliKz1gXFxuICAgICAgICAgICAgYmxvY2tJbmRleCA9IHJjLnggKyAke2V9O1xcbiAgICAgICAgICAgIHBvcyA9IHJjLnkgKyAke3R9O1xcblxcbiAgICAgICAgICAgIGlmKGJsb2NrSW5kZXggPCAke2ZbMV19ICYmIHBvcyA8ICR7ZlswXX0pIHtcXG4gICAgICAgICAgICAgIG9mZnNldFkgPSBpbnQoYmxvY2tJbmRleCAvICgke3NbcC0xXX0pKSAqICR7dS5zdHJpZGVzWzBdfSAtXFxuICAgICAgICAgICAgICAgICR7dS5wYWRzWzBdfTtcXG4gICAgICAgICAgICAgIGQwID0gb2Zmc2V0WSArICR7dS5kaWxhdGlvbnNbMF19ICogKGltb2QocG9zLCAke2R9KSAvICR7bFsyXX0pO1xcblxcbiAgICAgICAgICAgICAgaWYoZDAgPCAke2NbMl19ICYmIGQwID49IDApIHtcXG4gICAgICAgICAgICAgICAgb2Zmc2V0WCA9IGltb2QoYmxvY2tJbmRleCwgJHtzW3AtMV19KSAqICR7dS5zdHJpZGVzWzFdfSAtXFxuICAgICAgICAgICAgICAgICAgJHt1LnBhZHNbMV19O1xcbiAgICAgICAgICAgICAgICBkMSA9IG9mZnNldFggKyAke3UuZGlsYXRpb25zWzFdfSAqIGltb2QoaW1vZChwb3MsICR7ZH0pLCAke2xbMl19KTtcXG5cXG4gICAgICAgICAgICAgICAgaWYoZDEgPCAke2NbM119ICYmIGQxID49IDApIHtcXG5cXG4gICAgICAgICAgICAgICAgICBjaCA9IGludChmbG9hdChwb3MpLyAke2R9Lik7XFxuICAgICAgICAgICAgICAgICAgICBpbm5lckRpbXMgPSB2ZWMyKGQwLCBkMSk7XFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbJHsyKnQrZX1dID0gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0QSgwLCBjaCwgaW50KGlubmVyRGltcy54KSxcXG4gICAgICAgICAgICAgICAgICAgICAgaW50KGlubmVyRGltcy55KSksIGlubmVyRGltcyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGA7Y29uc3QgbT1gXFxuICAgICAgJHtofVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLjApO1xcbiAgICAgICAgICBpbnQgYmxvY2tJbmRleCwgcG9zLCBvZmZzZXRZLCBkMCwgb2Zmc2V0WCwgZDEsIGNoO1xcbiAgICAgICAgICB2ZWMyIGlubmVyRGltcztcXG4gICAgICAgICAgJHtifVxcbiAgICAgICAgICAke2cub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgICAgICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6Zix0eXBlOm4udHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnBhY2tlZH0sc2hhZGVyU291cmNlOm0saGFzTWFpbjohMH0pfSkodCx1LGUsbixhLHMpfSl9fSwzMjQ4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNhbGN1bGF0ZUltMkNvbERpbXM9ZS5jcmVhdGVJbTJDb2xQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDIwMzkpO2UuY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXI9KHQsbixpLG8sYSk9Pntjb25zdCBzPSh1PWEuY2FjaGVLZXkse25hbWU6XCJJbTJDb2xcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbci5UZXh0dXJlVHlwZS51bnBhY2tlZF0sY2FjaGVIaW50OnV9KTt2YXIgdTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtnZXQ6KCk9PigodCxuLGksbyxhLHMpPT57Y29uc3QgdT1pLmRpbXMsYz1vLmRpbXMsbD1hLmxlbmd0aCxwPSgwLGUuY2FsY3VsYXRlSW0yQ29sRGltcykodSxjLGEsNCksZj1gXFxuICAgICAgICBjb25zdCBpbnQgWEMgPSAke3VbMV19O1xcbiAgICAgICAgY29uc3QgaW50IFhIID0gJHt1WzJdfTtcXG4gICAgICAgIGNvbnN0IGludCBYVyA9ICR7dVszXX07XFxuICAgICAgICBjb25zdCBpbnQgS0ggPSAke3Mua2VybmVsU2hhcGVbMF19O1xcbiAgICAgICAgY29uc3QgaW50IEtXID0gJHtzLmtlcm5lbFNoYXBlWzFdfTtcXG4gICAgICAgIGNvbnN0IGludCBkaWxhdGlvbkggPSAke3MuZGlsYXRpb25zWzBdfTtcXG4gICAgICAgIGNvbnN0IGludCBkaWxhdGlvblcgPSAke3MuZGlsYXRpb25zWzFdfTtcXG4gICAgICAgIGNvbnN0IGludCBzdHJpZGVIID0gJHtzLnN0cmlkZXNbMF19O1xcbiAgICAgICAgY29uc3QgaW50IHN0cmlkZVcgPSAke3Muc3RyaWRlc1sxXX07XFxuICAgICAgICBjb25zdCBpbnQgcGFkSCA9ICR7cy5wYWRzWzBdfTtcXG4gICAgICAgIGNvbnN0IGludCBwYWRXID0gJHtzLnBhZHNbMV19O1xcbiAgICAgICAgY29uc3QgaW50IEtIS1cgPSBLSCpLVztcXG4gICAgICAgIGNvbnN0IGludCBYQ0tIS1cgPSBYQyAqIEtIS1c7XFxuICAgICAgICBjb25zdCBpbnQgb3V0cHV0Q2hhbm5lbHMgPSA0O1xcbiAgICAgICAgdmVjNCBwcm9jZXNzKGludCBpbmRpY2VzWyR7bH1dKSB7XFxuICAgICAgICAgIGludCBiICA9IGluZGljZXNbMF07IC8vIGJhdGNoIHNpemVcXG4gICAgICAgICAgaW50IG9oID0gaW5kaWNlc1sxXSAqIHN0cmlkZUggLSBwYWRIOyAvL291dHB1dCBoZWlnaHRcXG4gICAgICAgICAgaW50IG93ID0gaW5kaWNlc1syXSAqIHN0cmlkZVcgLSBwYWRXOyAvL291dHB1dCB3aWR0aFxcbiAgICAgICAgICBpbnQgcCA9IGluZGljZXNbM10gKiBvdXRwdXRDaGFubmVsczsgLy9wYXRjaFxcbiAgICAgICAgICB2ZWM0IHZhbHVlID0gdmVjNCgwLjApO1xcbiAgICAgICAgICBmb3IoaW50IGk9MDsgaSA8IG91dHB1dENoYW5uZWxzOyArK2kpIHtcXG4gICAgICAgICAgICBpZihwIDwgWENLSEtXKSB7XFxuICAgICAgICAgICAgICBpbnQgcGF0Y2hDID0gcCAvIEtIS1c7XFxuICAgICAgICAgICAgICBpbnQgcGF0Y2hIID0gKHAgLSBwYXRjaEMqS0hLVykgLyBLVztcXG4gICAgICAgICAgICAgIGludCBwYXRjaFcgPSAocCAtIHBhdGNoQypLSEtXKSAtIHBhdGNoSCAqIEtXO1xcbiAgICAgICAgICAgICAgaW50IHhoMiA9IG9oICsgcGF0Y2hIICogZGlsYXRpb25IO1xcbiAgICAgICAgICAgICAgaW50IHh3MiA9IG93ICsgcGF0Y2hXICogZGlsYXRpb25XO1xcbiAgICAgICAgICAgICAgaW50IHhbJHt1Lmxlbmd0aH1dO1xcbiAgICAgICAgICAgICAgeFswXSA9IGI7XFxuICAgICAgICAgICAgICB4WzFdID0gcGF0Y2hDO1xcbiAgICAgICAgICAgICAgeFsyXSA9IHhoMjtcXG4gICAgICAgICAgICAgIHhbM10gPSB4dzI7XFxuICAgICAgICAgICAgICBpZih4aDIgPj0gMCAmJlxcbiAgICAgICAgICAgICAgICAgIHhoMiA8IFhIICYmXFxuICAgICAgICAgICAgICAgICAgeHcyID49IDAgJiZcXG4gICAgICAgICAgICAgICAgICB4dzIgPCBYVykge1xcbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IF9YKHgpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICArK3A7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtvdXRwdXQ6e2RpbXM6cCx0eXBlOmkudHlwZSx0ZXh0dXJlVHlwZTpyLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb259LHNoYWRlclNvdXJjZTpmfSl9KSgwLHMsbixpLG8sYSl9KX0sZS5jYWxjdWxhdGVJbTJDb2xEaW1zPSh0LGUsbixyPTQpPT5bblswXSxuWzJdLG5bM10sTWF0aC5jZWlsKHRbMV0qZVsyXSplWzNdL3IpXX0sNjU3MjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUltYWdlU2NhbGVyQXR0cmlidXRlcz1lLmltYWdlU2NhbGVyPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjAzOSk7ZS5pbWFnZVNjYWxlcj0odCxlLG4pPT4odShlKSxbdC5ydW4oYSh0LGUsbiksZSldKSxlLnBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcInNjYWxlXCIpLG49dC5hdHRyaWJ1dGVzLmdldEZsb2F0cyhcImJpYXNcIik7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtzY2FsZTplLGJpYXM6bn0pfTtjb25zdCBvPXtuYW1lOlwiSW1hZ2VTY2FsZXJcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19LGE9KHQsZSxuKT0+e2NvbnN0IHI9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG8pLHtjYWNoZUhpbnQ6bi5jYWNoZUtleX0pO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+KCh0LGUsbixyKT0+e2NvbnN0IG89blswXS5kaW1zLnNsaWNlKCksYT1vLmxlbmd0aCx1PWBcXG4gICAgICAke3Moci5iaWFzLmxlbmd0aCl9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2F9XSkge1xcbiAgICAgICAgcmV0dXJuIF9YKGluZGljZXMpICogc2NhbGUgKyBnZXRCaWFzKGJpYXMsIGluZGljZXNbMV0pO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpvLHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHZhcmlhYmxlczpbe25hbWU6XCJiaWFzXCIsdHlwZTpcImZsb2F0XCIsYXJyYXlMZW5ndGg6ci5iaWFzLmxlbmd0aCxkYXRhOnIuYmlhc30se25hbWU6XCJzY2FsZVwiLHR5cGU6XCJmbG9hdFwiLGRhdGE6ci5zY2FsZX1dLHNoYWRlclNvdXJjZTp1fSl9KSgwLHIsZSxuKX0pfSxzPXQ9Pntjb25zdCBlPVtgZmxvYXQgZ2V0QmlhcyhmbG9hdCBiaWFzWyR7dH1dLCBpbnQgY2hhbm5lbCkge2BdO2ZvcihsZXQgbj0wO248dDsrK24pMD09PW4/ZS5wdXNoKGBcXHRpZiAoY2hhbm5lbCA9PSAke259KSB7IHJldHVybiBiaWFzWyR7bn1dOyB9YCk6bj09PXQtMT9lLnB1c2goYFxcdGVsc2UgeyByZXR1cm4gYmlhc1ske259XTsgfWApOmUucHVzaChgXFx0ZWxzZSBpZiAoY2hhbm5lbCA9PSAke259KSB7IHJldHVybiBiaWFzWyR7bn1dOyB9YCk7cmV0dXJuIGUucHVzaChcIlxcdH1cIiksZS5qb2luKFwiXFxuXCIpfSx1PXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkltYWdlU2NhbGVyIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKDQhPT10WzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0sMzM0NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUluc3RhbmNlTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM9ZS5pbnN0YW5jZU5vcm1hbGl6YXRpb249dm9pZCAwO2NvbnN0IHI9big1MDYwKSxpPW4oMjAzOSk7ZS5pbnN0YW5jZU5vcm1hbGl6YXRpb249KHQsZSxuKT0+e2MoZSk7Y29uc3Qgcj10LnJ1bihhKGVbMF0pLGUpO3JldHVyblt0LnJ1bih1KHQsZVswXSxuLHIuZGltcyksW2VbMF0scixlWzFdLGVbMl1dKV19LGUucGFyc2VJbnN0YW5jZU5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzPXQ9PnQuYXR0cmlidXRlcy5nZXRGbG9hdChcImVwc2lsb25cIiwxZS01KTtjb25zdCBvPXtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uX01lYW5BbmRWYXJpYW5jZVwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkXX0sYT10PT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbykse2dldDooKT0+KCh0LGUpPT57Y29uc3Qgbj1lLmRpbXMuc2xpY2UoKSxyPW5bMV0sbz1uWzJdKm5bM10sYT1bblswXSxyXSxzPWBcXG4gICAgICB2ZWM0IHByb2Nlc3MoaW50WzJdIGluZGljZXMpIHtcXG4gICAgICAgIHZlYzQgdiA9IHZlYzQoMC4wKTtcXG4gICAgICAgIGludCBhWzRdO1xcbiAgICAgICAgYVswXSA9IGluZGljZXNbMF07XFxuICAgICAgICBhWzFdID0gaW5kaWNlc1sxXTtcXG4gICAgICAgIGZsb2F0IHRlbXAgPSAwLjA7XFxuICAgICAgICBmb3IoaW50IGEyPTA7IGEyPCR7blsyXX07IGEyKyspIHtcXG4gICAgICAgICAgYVsyXSA9IGEyO1xcbiAgICAgICAgICBmb3IoaW50IGEzPTA7IGEzPCR7blszXX07IGEzKyspIHtcXG4gICAgICAgICAgICBhWzNdID0gYTM7XFxuICAgICAgICAgICAgZmxvYXQgeCA9IF9YKGEpO1xcbiAgICAgICAgICAgIHRlbXAgKz0geDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZmxvYXQgbWVhbiA9IHRlbXAgLyBmbG9hdCgke299KTtcXG4gICAgICAgIHRlbXAgPSAwLjA7XFxuICAgICAgICBmb3IoaW50IGEyPTA7IGEyPCR7blsyXX07IGEyKyspIHtcXG4gICAgICAgICAgYVsyXSA9IGEyO1xcbiAgICAgICAgICBmb3IoaW50IGEzPTA7IGEzPCR7blszXX07IGEzKyspIHtcXG4gICAgICAgICAgICBhWzNdID0gYTM7XFxuICAgICAgICAgICAgZmxvYXQgeCA9IF9YKGEpO1xcbiAgICAgICAgICAgIHRlbXAgKz0gKHggLSBtZWFuKSAqICh4IC0gbWVhbik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHYuciA9IG1lYW47XFxuICAgICAgICB2LmcgPSB0ZW1wIC8gZmxvYXQoJHtvfSk7XFxuXFxuICAgICAgICByZXR1cm4gdjtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXQ6e2RpbXM6YSx0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb259LHNoYWRlclNvdXJjZTpzfSl9KShvLHQpfSkscz17bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvbl9Db21wdXRlT3V0cHV0XCIsaW5wdXROYW1lczpbXCJYXCIsXCJNZWFuQW5kVmFyaWFuY2VcIixcIlNjYWxlXCIsXCJCXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uLGkuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19LHU9KHQsZSxuLG8pPT57Y29uc3QgYT1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2NhY2hlSGludDpgJHtufWB9KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtnZXQ6KCk9PigodCxlLG4sbyxhKT0+e2NvbnN0IHM9KDAsci5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksW3UsY109dC5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoYSxpLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24pLFtsLHBdPVt1LzQsY10sZj1gXFxuICAgICAgdmVjNCBnZXRfTWVhbkFuZFZhcmlhbmNlKGludFsyXSBtdikge1xcbiAgICAgICAgaW50IG9mZnNldCA9IGluZGljZXNUb09mZnNldF9NZWFuQW5kVmFyaWFuY2UobXYpO1xcbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7bH0sICR7cH0pO1xcbiAgICAgICAgcmV0dXJuICR7cy50ZXh0dXJlMkR9KE1lYW5BbmRWYXJpYW5jZSwgY29vcmRzKTtcXG4gICAgICB9XFxuXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbNF0gaW5kaWNlcykge1xcbiAgICAgICAgaW50IG12WzJdO1xcbiAgICAgICAgbXZbMF0gPSBpbmRpY2VzWzBdO1xcbiAgICAgICAgbXZbMV0gPSBpbmRpY2VzWzFdO1xcbiAgICAgICAgdmVjNCBtZWFuX2FuZF92YXJpYW5jZSA9IGdldF9NZWFuQW5kVmFyaWFuY2UobXYpO1xcbiAgICAgICAgZmxvYXQgbWVhbiA9IG1lYW5fYW5kX3ZhcmlhbmNlLnI7XFxuICAgICAgICBmbG9hdCB2YXJpYW5jZSA9IG1lYW5fYW5kX3ZhcmlhbmNlLmc7XFxuXFxuICAgICAgICBpbnQgc2JbMV07XFxuICAgICAgICBzYlswXSA9IGluZGljZXNbMV07XFxuICAgICAgICBmbG9hdCBzY2FsZSA9IF9TY2FsZShzYik7XFxuICAgICAgICBmbG9hdCBiID0gX0Ioc2IpO1xcblxcbiAgICAgICAgcmV0dXJuIHNjYWxlICogKF9YKGluZGljZXMpIC0gbWVhbikgLyBzcXJ0KHZhcmlhbmNlICsgZXBzaWxvbikgKyBiO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpuLmRpbXMsdHlwZTpuLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sdmFyaWFibGVzOlt7bmFtZTpcImVwc2lsb25cIix0eXBlOlwiZmxvYXRcIixkYXRhOm99XSxzaGFkZXJTb3VyY2U6Zn0pfSkodCxhLGUsbixvKX0pfSxjPXQ9PntpZighdHx8MyE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkluc3RhbmNlTm9ybWFsaXphdGlvbiByZXF1aXJlcyAzIGlucHV0cy5cIik7Y29uc3QgZT10WzBdLG49dFsxXSxyPXRbMl07aWYoZS5kaW1zLmxlbmd0aDwzfHwxIT09bi5kaW1zLmxlbmd0aHx8MSE9PXIuZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYobi5kaW1zWzBdIT09ZS5kaW1zWzFdfHxyLmRpbXNbMF0hPT1lLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc2hhcGVzIGFyZSBtaXNtYXRjaGVkLlwiKTtpZihcImZsb2F0MzJcIiE9PWUudHlwZSYmXCJmbG9hdDY0XCIhPT1lLnR5cGV8fFwiZmxvYXQzMlwiIT09bi50eXBlJiZcImZsb2F0NjRcIiE9PW4udHlwZXx8XCJmbG9hdDMyXCIhPT1yLnR5cGUmJlwiZmxvYXQ2NFwiIT09ci50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoNCE9PXRbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiT25seSBzdXBwb3J0IDQtRCBpbnB1dCBzaGFwZS5cIil9fSw3MDg6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oNTA2MCksbz1uKDIwMzkpLGE9big5MzkwKSxzPW4oMjgyMyksdT1uKDU2MjMpO2UuY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXI9KHQsZSxuKT0+e2NvbnN0IGM9KGw9ZS5sZW5ndGg+MixwPW4uYWN0aXZhdGlvbkNhY2hlS2V5LHtuYW1lOlwiTWF0TXVsIChwYWNrZWQpXCIsaW5wdXROYW1lczpsP1tcIkFcIixcIkJcIixcIkJpYXNcIl06W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOmw/W28uVGV4dHVyZVR5cGUucGFja2VkLG8uVGV4dHVyZVR5cGUucGFja2VkLG8uVGV4dHVyZVR5cGUucGFja2VkXTpbby5UZXh0dXJlVHlwZS5wYWNrZWQsby5UZXh0dXJlVHlwZS5wYWNrZWRdLGNhY2hlSGludDpwfSk7dmFyIGwscDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGMpLHtnZXQ6KCk9PigodCxlLG4sYyk9Pntjb25zdCBsPW4ubGVuZ3RoPjIscD1sP1widmFsdWUgKz0gZ2V0Qmlhc0Zvck1hdG11bCgpO1wiOlwiXCIsZj1uWzBdLmRpbXMsZD1uWzFdLmRpbXMsaD1yLkJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGYsZCwhMCksZz0hci5TaGFwZVV0aWwuYXJlRXF1YWwoblswXS5kaW1zLG5bMV0uZGltcyk7aWYoIWgpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtjb25zdCBiPWZbZi5sZW5ndGgtMV0sbT1NYXRoLmNlaWwoYi8yKSx5PWYubGVuZ3RoLF89ZC5sZW5ndGgsdj0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx3PSgwLGEuZ2V0Q29vcmRzRGF0YVR5cGUpKGgubGVuZ3RoKSx4PWgubGVuZ3RoLFQ9KDAsYS5nZXRHbENoYW5uZWxzKSgpLHthY3RpdmF0aW9uRnVuY3Rpb246UyxhcHBseUFjdGl2YXRpb246T309KDAscy5nZXRBY3RpdmF0aW9uU25pcHBldCkoYyksQT1sP2AkeygwLHUuZ2V0Qmlhc0Zvck1hdG11bCkodyxULG5bMl0uZGltcyxoLCEwKX1gOlwiXCIsRT1nP2Ake2Z1bmN0aW9uKHQsZSxuLGkpe2xldCBvPVtdLGE9W107Y29uc3Qgcz1uWzBdLmRpbXMsdT1uWzFdLmRpbXMsYz1zLmxlbmd0aCxsPXUubGVuZ3RoLHA9aS5sZW5ndGgsZj1wLWMsZD1wLWw7bz1zLm1hcCgoKHQsbik9PmBjb29yZHMuJHtlW24rZl19YCkpLG9bYy0xXT1cImkqMlwiLG8uam9pbihcIiwgXCIpLGE9dS5tYXAoKCh0LG4pPT5gY29vcmRzLiR7ZVtuK2RdfWApKSxhW2wtMl09XCJpKjJcIixhLmpvaW4oXCIsIFwiKTtjb25zdCBoPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKHMsaSksZz1yLkJyb2FkY2FzdFV0aWwuZ2V0QnJvYWRjYXN0RGltcyh1LGkpLGI9aC5tYXAoKHQ9PmBjb29yZHMuJHtlW3QrZl19ID0gMDtgKSkuam9pbihcIlxcblwiKSxtPWcubWFwKCh0PT5gY29vcmRzLiR7ZVt0K2RdfSA9IDA7YCkpLmpvaW4oXCJcXG5cIikseT1gaW50IGxhc3REaW0gPSBjb29yZHMuJHtlW3AtMV19O1xcbiAgY29vcmRzLiR7ZVtwLTFdfSA9IGNvb3Jkcy4ke2VbcC0yXX07XFxuICBjb29yZHMuJHtlW3AtMl19ID0gbGFzdERpbTtgO3JldHVybmBcXG52ZWM0IGdldEFBdE91dENvb3Jkc01hdG11bChpbnQgaSkge1xcbiAgJHt0fSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICR7eX1cXG4gICR7Yn1cXG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRBKCR7b30pO1xcbiAgcmV0dXJuIG91dHB1dFZhbHVlO1xcbn1cXG5cXG52ZWM0IGdldEJBdE91dENvb3Jkc01hdG11bChpbnQgaSkge1xcbiAgJHt0fSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICR7eX1cXG4gICR7bX1cXG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRCKCR7YX0pO1xcbiAgcmV0dXJuIG91dHB1dFZhbHVlO1xcbn1gfSh3LFQsbixoKX1gOlwiXCIsST1nP1wiZ2V0QUF0T3V0Q29vcmRzTWF0bXVsKGkpXCI6YGdldEEoJHtmdW5jdGlvbih0LGUpe2xldCBuPVwiXCI7Zm9yKGxldCByPTA7cjxlLTI7cisrKW4rPWByYy4ke3Rbcl19LCBgO3JldHVybiBuKz1gcmMuJHt0W2UtMl19LCBpKjJgLG59KFQseSl9KWAsUD1nP1wiZ2V0QkF0T3V0Q29vcmRzTWF0bXVsKGkpXCI6YGdldEIoJHtmdW5jdGlvbih0LGUpe2xldCBuPVwiXCI7Zm9yKGxldCByPTA7cjxlLTI7cisrKW4rPWByYy4ke3Rbcl19LCBgO3JldHVybiBuKz1gaSoyLCByYy4ke3RbZS0xXX1gLG59KFQsXyl9KWAsRD1gXFxuICAgICAgICAgICAgJHtFfVxcbiAgICAgICAgICAgICR7QX1cXG4gICAgICAgICAgICAke1N9XFxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICAgJHtnP1wiXCI6YCR7d30gcmMgPVxcbiAgICAgICAgICBnZXRPdXRwdXRDb29yZHMoKTsgaW50IGxhc3REaW0gPSByYy4ke1RbeC0xXX07IHJjLiR7VFt4LTFdfSA9XFxuICAgICAgICAgIHJjLiR7VFt4LTJdfTsgcmMuJHtUW3gtMl19ID0gbGFzdERpbTtcXG4gICAgICBgfVxcblxcbiAgICAgICAgICAgICAgdmVjNCB2YWx1ZSA9IHZlYzQoMCk7XFxuICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7bX07IGkrKykge1xcbiAgICAgICAgICAgICAgICB2ZWM0IGEgPSAke0l9O1xcbiAgICAgICAgICAgICAgICB2ZWM0IGIgPSAke1B9O1xcblxcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAoYS5ycmJiICogYi5yZ3JnKTtcXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gKGEuZ2dhYSAqIGIuYmFiYSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAke3B9XFxuICAgICAgICAgICAgICAke099XFxuICAgICAgICAgICAgICAke3Yub3V0cHV0fSA9IHZhbHVlO1xcbiAgICAgICAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpoLHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUucGFja2VkfSxzaGFkZXJTb3VyY2U6RCxoYXNNYWluOiEwfSl9KSh0LGMsZSxuKX0pfX0sNTYyMzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5nZXRCaWFzRm9yTWF0bXVsPWUuY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXI9ZS5wYXJzZU1hdE11bEF0dHJpYnV0ZXM9ZS5tYXRNdWw9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oMjAzOSksbz1uKDkzOTApLGE9bigyODIzKSxzPW4oNzA4KTtmdW5jdGlvbiB1KHQsZSl7Y29uc3Qgbj0ocz10Lmxlbmd0aD4yLHU9ZS5hY3RpdmF0aW9uQ2FjaGVLZXkse25hbWU6XCJNYXRNdWxcIixpbnB1dE5hbWVzOnM/W1wiQVwiLFwiQlwiLFwiQmlhc1wiXTpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6cz9baS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWRdOltpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDp1fSk7dmFyIHMsdTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtnZXQ6KCk9PmZ1bmN0aW9uKHQsZSxuKXtjb25zdCBzPWVbMF0uZGltcyx1PWVbMV0uZGltcyxjPXIuQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUocyx1LCEwKTtpZighYyl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2NvbnN0IHA9KDAsby5nZXRDb29yZHNEYXRhVHlwZSkoYy5sZW5ndGgpLGY9KDAsby5nZXRHbENoYW5uZWxzKSgpLHthY3RpdmF0aW9uRnVuY3Rpb246ZCxhcHBseUFjdGl2YXRpb246aH09KDAsYS5nZXRBY3RpdmF0aW9uU25pcHBldCkobiksZz1lLmxlbmd0aD4yLGI9Zz9cInZhbHVlICs9IGdldEJpYXNGb3JNYXRtdWwoKTtcIjpcIlwiLG09Zz9gJHtsKHAsZixlWzJdLmRpbXMsYywhMSl9YDpcIlwiLHk9Yy5sZW5ndGgsXz1zLmxlbmd0aCx2PXUubGVuZ3RoLHc9YFxcbiAgICAke2R9XFxuICAgICR7bX1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3l9XSkge1xcbiAgICAgICAgaW50IGFbJHtffV07XFxuICAgICAgICBpbnQgYlske3Z9XTtcXG4gICAgICAgIGJjYXN0TWF0bXVsSW5kaWNlc19BKGluZGljZXMsIGEpO1xcbiAgICAgICAgYmNhc3RNYXRtdWxJbmRpY2VzX0IoaW5kaWNlcywgYik7XFxuXFxuICAgICAgICBmbG9hdCB2YWx1ZTtcXG4gICAgICAgIGZvciAoaW50IGs9MDsgazwke3Nbcy5sZW5ndGgtMV19OyArK2spIHtcXG4gICAgICAgICAgICBhWyR7Xy0xfV0gPSBrO1xcbiAgICAgICAgICAgIGJbJHt2LTJ9XSA9IGs7XFxuICAgICAgICAgICAgdmFsdWUgKz0gX0EoYSkgKiBfQihiKTtcXG4gICAgICAgIH1cXG4gICAgICAgICR7Yn1cXG4gICAgICAgICR7aH1cXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7b3V0cHV0OntkaW1zOmMsdHlwZTplWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnd9KX0obix0LGUpfSl9ZS5tYXRNdWw9KHQsZSxuKT0+KGMoZSksdC5zZXNzaW9uLnBhY2s/W3QucnVuKCgwLHMuY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIpKHQsZSxuKSxlKV06W3QucnVuKHUoZSxuKSxlKV0pLGUucGFyc2VNYXRNdWxBdHRyaWJ1dGVzPXQ9PigwLGEucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKSh0LmF0dHJpYnV0ZXMpLGUuY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXI9dTtjb25zdCBjPXQ9PntpZighdHx8MiE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk1hdE11bCByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYodFswXS5kaW1zW3RbMF0uZGltcy5sZW5ndGgtMV0hPT10WzFdLmRpbXNbdFsxXS5kaW1zLmxlbmd0aC0yXSl0aHJvdyBuZXcgRXJyb3IoXCJzaGFyZWQgZGltZW5zaW9uIGRvZXMgbm90IG1hdGNoLlwiKTtpZihcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGV8fFwiZmxvYXQzMlwiIT09dFsxXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dHMgc2hvdWxkIGJlIGZsb2F0IHR5cGVcIik7aWYodFswXS50eXBlIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcImlucHV0cyB0eXBlcyBzaG91bGQgbWF0Y2hcIil9O2Z1bmN0aW9uIGwodCxlLG4saSxvKXtsZXQgYT1cIlwiO2NvbnN0IHM9bi5sZW5ndGgsdT1pLmxlbmd0aCxjPXUtczthPXU8MiYmcz4wP1wiY29vcmRzXCI6bi5tYXAoKCh0LG4pPT5gY29vcmRzLiR7ZVtuK2NdfWApKS5qb2luKFwiLCBcIik7Y29uc3QgbD1yLkJyb2FkY2FzdFV0aWwuZ2V0QnJvYWRjYXN0RGltcyhuLGkpLm1hcCgodD0+YGNvb3Jkcy4ke2VbdCtjXX0gPSAwO2ApKS5qb2luKFwiXFxuXCIpO2xldCBwPVwidmVjNChvdXRwdXRWYWx1ZS54eCwgb3V0cHV0VmFsdWUueXkpXCI7cmV0dXJuIDE9PT1yLlNoYXBlVXRpbC5zaXplKG4pJiYocD1cInZlYzQob3V0cHV0VmFsdWUueClcIiksbz9gXFxudmVjNCBnZXRCaWFzRm9yTWF0bXVsKCkge1xcbiAgJHt0fSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICR7bH1cXG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRCaWFzKCR7YX0pO1xcbiAgcmV0dXJuICR7cH07XFxufWA6YFxcbmZsb2F0IGdldEJpYXNGb3JNYXRtdWwoKSB7XFxuICAke3R9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgJHtsfVxcbiAgcmV0dXJuIGdldEJpYXMoY29vcmRzLngpO1xcbn1gfWUuZ2V0Qmlhc0Zvck1hdG11bD1sfSwyNDAzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNyZWF0ZVBhY2tQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KSxvPW4oOTM5MCksYT1uKDI4MjcpLHM9e25hbWU6XCJwYWNrXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUudW5wYWNrZWRSZXZlcnNlZF19O2UuY3JlYXRlUGFja1Byb2dyYW1JbmZvTG9hZGVyPSh0LGUpPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2dldDooKT0+KCh0LGUpPT57Y29uc3Qgbj0oMCxyLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx1PWUuZGltcyxjPXUubGVuZ3RoLGw9ZS5kaW1zLmxlbmd0aCxwPSgwLG8uZ2V0Q29vcmRzRGF0YVR5cGUpKGwpLGY9KDAsYS5nZXRDaGFubmVscykoXCJyY1wiLGwpLGQ9KGg9bCxnPWYsYj11W3UubGVuZ3RoLTJdLG09dVt1Lmxlbmd0aC0xXSwwPT09aHx8MT09PWg/XCJcIjpgXFxuICAgIGludCByID0gJHtnW2gtMl19O1xcbiAgICBpbnQgYyA9ICR7Z1toLTFdfTtcXG4gICAgaW50IHJwMSA9ICR7Z1toLTJdfSArIDE7XFxuICAgIGludCBjcDEgPSAke2dbaC0xXX0gKyAxO1xcbiAgICBib29sIHJFZGdlID0gcnAxID49ICR7bX07XFxuICAgIGJvb2wgY0VkZ2UgPSBjcDEgPj0gJHtifTtcXG4gICAgYCk7dmFyIGgsZyxiLG07bGV0IHk7eT0wPT09Yz9bMSwxXToxPT09Yz9bdVswXSwxXTpbdVtsLTFdLHVbbC0yXV07Y29uc3QgXz1mdW5jdGlvbih0LGUsbil7aWYoMD09PXQpcmV0dXJuXCJmYWxzZVwiO2lmKDE9PT10KXJldHVybmByYyA+ICR7ZVswXX1gO2xldCByPVwiXCI7Zm9yKGxldCBpPXQtMjtpPHQ7aSsrKXIrPWAke25baV19ID49ICR7ZVtpLXQrMl19YCxpPHQtMSYmKHIrPVwifHxcIik7cmV0dXJuIHJ9KGwseSxmKSx2PWZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10Lmxlbmd0aDtpZigwPT09bilyZXR1cm5cImdldEEoKSwgMCwgMCwgMFwiO2lmKDE9PT1uKXJldHVybmBnZXRBKHJjKSxcXG4gICAgICAgICAgICByYyArIDEgPj0gJHt0WzBdfSA/IDAuIDogZ2V0QShyYyArIDEpLFxcbiAgICAgICAgICAgIDAsIDBgO2xldCByPVwiXCI7aWYobj4yKWZvcihsZXQgdD0wO3Q8bi0yOysrdClyKz1gJHtlW3RdfSxgO3JldHVybmBnZXRBKCR7cn1yLCBjKSxcXG4gICAgICAgICAgckVkZ2UgPyAwLiA6IGdldEEoJHtyfXJwMSwgYyksXFxuICAgICAgICAgIGNFZGdlID8gMC4gOiBnZXRBKCR7cn1yLCBjcDEpLFxcbiAgICAgICAgICByRWRnZSB8fCBjRWRnZSA/IDAuIDogZ2V0QSgke3J9cnAxLCBjcDEpYH0odSxmKSx3PWBcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgJHtwfSByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgICBpZigke199KSB7XFxuICAgICAgICAgICAgJHtuLm91dHB1dH0gPSB2ZWM0KDApO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICR7ZH1cXG5cXG4gICAgICAgICAgICAke24ub3V0cHV0fSA9IHZlYzQoJHt2fSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2hhc01haW46ITAsb3V0cHV0OntkaW1zOmUuZGltcyx0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnBhY2tlZH0sc2hhZGVyU291cmNlOnd9KX0pKHQsZSl9KX0sMjgyNzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS51bnBhY2tGcm9tQ2hhbm5lbD1lLmdldENoYW5uZWxzPWUuZ2V0VmVjQ2hhbm5lbHM9dm9pZCAwO2NvbnN0IHI9big5MzkwKTtmdW5jdGlvbiBpKHQsZSl7cmV0dXJuKDAsci5nZXRHbENoYW5uZWxzKShlKS5tYXAoKGU9PmAke3R9LiR7ZX1gKSl9ZS5nZXRWZWNDaGFubmVscz1pLGUuZ2V0Q2hhbm5lbHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gMT09PWU/W3RdOmkodCxlKX0sZS51bnBhY2tGcm9tQ2hhbm5lbD1mdW5jdGlvbigpe3JldHVyblwiXFxuICAgIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCBpbnQgZGltKSB7XFxuICAgICAgaW50IG1vZENvb3JkID0gaW1vZChkaW0sIDIpO1xcbiAgICAgIHJldHVybiBtb2RDb29yZCA9PSAwID8gZnJhZy5yIDogZnJhZy5nO1xcbiAgICB9XFxuXFxuICAgIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCB2ZWMyIGlubmVyRGltcykge1xcbiAgICAgIHZlYzIgbW9kQ29vcmQgPSBtb2QoaW5uZXJEaW1zLCAyLik7XFxuICAgICAgcmV0dXJuIG1vZENvb3JkLnggPT0gMC4gP1xcbiAgICAgICAgKG1vZENvb3JkLnkgPT0gMC4gPyBmcmFnLnIgOiBmcmFnLmcpIDpcXG4gICAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5iIDogZnJhZy5hKTtcXG4gICAgfVxcbiAgXCJ9fSwyODcwOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlUGFkQXR0cmlidXRlc1YxMT1lLnBhZFYxMT1lLnBhcnNlUGFkQXR0cmlidXRlc1YyPWUucGFkVjI9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9bigyNTE3KSxvPW4oNTA2MCksYT1uKDIwMzkpLHM9e25hbWU6XCJQYWRcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UucGFkVjI9KHQsZSxuKT0+KGwoZSksW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT5jKHQsZVswXSxuKX0pLGUpXSksZS5wYXJzZVBhZEF0dHJpYnV0ZXNWMj10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwibW9kZVwiLFwiY29uc3RhbnRcIiksbj10LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJ2YWx1ZVwiLDApLGk9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJwYWRzXCIpO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7bW9kZTplLHZhbHVlOm4scGFkczppfSl9LGUucGFkVjExPSh0LG4scik9PntwKG4pO2NvbnN0IGk9dSh0LG4scik7cmV0dXJuKDAsZS5wYWRWMikodCxbblswXV0saSl9LGUucGFyc2VQYWRBdHRyaWJ1dGVzVjExPXQ9PnQuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJtb2RlXCIsXCJjb25zdGFudFwiKTtjb25zdCB1PSh0LGUsbik9PntpZighdC5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoZVsxXS5kYXRhSWQpfHxlLmxlbmd0aD49MyYmIXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMl0uZGF0YUlkKSl0aHJvdyBuZXcgRXJyb3IoXCJkeW5hbWljIHBhZCBhdHRyaWJ1dGVzIGFyZSBub3QgYWxsb3dlZFwiKTtjb25zdCBpPUFycmF5LmZyb20oZVsxXS5pbnRlZ2VyRGF0YSksbz1lLmxlbmd0aD49Mz9lWzJdLmZsb2F0RGF0YVswXTowO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7bW9kZTpuLHBhZHM6aSx2YWx1ZTpvfSl9LGM9KHQsZSxuKT0+e2NvbnN0IHI9aS5TaGFwZVV0aWwucGFkU2hhcGUoZS5kaW1zLnNsaWNlKCksbi5wYWRzKSxvPXIubGVuZ3RoLHM9YFxcbiAgICAgICR7Zih0LGUsbil9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtvfV0gaW5kaWNlcykge1xcbiAgICAgICAgICByZXR1cm4gcGFkQShpbmRpY2VzKTtcXG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlBhZFwiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkXSxvdXRwdXQ6e2RpbXM6cix0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTphLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6c319LGw9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUGFkIHJlcXVpcmVzIDEgaW5wdXRcIik7aWYoXCJmbG9hdDMyXCIhPT10WzBdLnR5cGUmJlwiZmxvYXQ2NFwiIT09dFswXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9LHA9dD0+e2lmKCF0fHwyIT09dC5sZW5ndGgmJjMhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJQYWQgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZihcImludDMyXCIhPT10WzFdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZih0Lmxlbmd0aD49MyYmXCJzdHJpbmdcIj09PXRbMl0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfSxmPSh0LGUsbik9Pntjb25zdCByPSgwLG8uZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLFtzLHVdPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGUuZGltcyxhLlRleHR1cmVUeXBlLnVucGFja2VkKSxjPWkuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGUuZGltcyk7c3dpdGNoKG4ubW9kZSl7Y2FzZVwiY29uc3RhbnRcIjpyZXR1cm4gZChyLGUuZGltcyxjLHMsdSxuLnBhZHMsbi52YWx1ZSk7Y2FzZVwicmVmbGVjdFwiOnJldHVybiBoKHIsZS5kaW1zLGMscyx1LG4ucGFkcyk7Y2FzZVwiZWRnZVwiOnJldHVybiBnKHIsZS5kaW1zLGMscyx1LG4ucGFkcyk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1vZGVcIil9fSxkPSh0LGUsbixyLGksbyxhKT0+e2NvbnN0IHM9ZS5sZW5ndGg7bGV0IHU9XCJcIjtmb3IobGV0IHQ9cy0xO3Q+PTA7LS10KXUrPWBcXG4gICAgICAgIGsgPSBtWyR7dH1dIC0gJHtvW3RdfTtcXG4gICAgICAgIGlmIChrIDwgMCkgIHJldHVybiBjb25zdGFudDtcXG4gICAgICAgIGlmIChrID49ICR7ZVt0XX0pIHJldHVybiBjb25zdGFudDtcXG4gICAgICAgIG9mZnNldCArPSBrICogJHtuW3RdfTtcXG4gICAgICAgIGA7cmV0dXJuYFxcbiAgICAgIGZsb2F0IHBhZEEoaW50IG1bJHtzfV0pIHtcXG4gICAgICAgIGNvbnN0IGZsb2F0IGNvbnN0YW50ID0gZmxvYXQoJHthfSk7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcXG4gICAgICAgIGludCBrID0gMDtcXG4gICAgICAgICR7dX1cXG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke3J9LCAke2l9KTtcXG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7dC50ZXh0dXJlMkR9KEEsIGNvb3JkcykpO1xcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH1cXG4gICAgICBgfSxoPSh0LGUsbixyLGksbyk9Pntjb25zdCBhPWUubGVuZ3RoO2xldCBzPVwiXCI7Zm9yKGxldCB0PWEtMTt0Pj0wOy0tdClzKz1gXFxuICAgICAgICBrID0gbVske3R9XSAtICR7b1t0XX07XFxuICAgICAgICBpZiAoayA8IDApIHsgayA9IC1rOyB9XFxuICAgICAgICB7XFxuICAgICAgICAgIGNvbnN0IGludCBfMm5fMSA9ICR7MiooZVt0XS0xKX07XFxuICAgICAgICAgIGsgPSBpbnQoIG1vZCggZmxvYXQoayksIGZsb2F0KF8ybl8xKSApICkgO1xcbiAgICAgICAgICBpZihrID49ICR7ZVt0XX0pIHsgayA9IF8ybl8xIC0gazsgfVxcbiAgICAgICAgfVxcbiAgICAgICAgb2Zmc2V0ICs9IGsgKiAke25bdF19O1xcbiAgICAgICAgYDtyZXR1cm5gXFxuICAgICAgZmxvYXQgcGFkQShpbnQgbVske2F9XSkge1xcbiAgICAgICAgaW50IG9mZnNldCA9IDA7XFxuICAgICAgICBpbnQgayA9IDA7XFxuICAgICAgICAke3N9XFxuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHtyfSwgJHtpfSk7XFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke3QudGV4dHVyZTJEfShBLCBjb29yZHMpKTtcXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9XFxuICAgICAgYH0sZz0odCxlLG4scixpLG8pPT57Y29uc3QgYT1lLmxlbmd0aDtsZXQgcz1cIlwiO2ZvcihsZXQgdD1hLTE7dD49MDstLXQpcys9YFxcbiAgICAgICAgayA9IG1bJHt0fV0gLSAke29bdF19O1xcbiAgICAgICAgaWYgKGsgPCAwKSAgayA9IDA7XFxuICAgICAgICBpZiAoayA+PSAke2VbdF19KSBrID0gJHtlW3RdLTF9O1xcbiAgICAgICAgb2Zmc2V0ICs9IGsgKiAke25bdF19O1xcbiAgICAgIGA7cmV0dXJuYFxcbiAgICAgIGZsb2F0IHBhZEEoaW50IG1bJHthfV0pIHtcXG4gICAgICAgIGludCBvZmZzZXQgPSAwO1xcbiAgICAgICAgaW50IGsgPSAwO1xcbiAgICAgICAgJHtzfVxcbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7cn0sICR7aX0pO1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHt0LnRleHR1cmUyRH0oQSwgY29vcmRzKSk7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGB9fSwyMTQzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmdsb2JhbE1heFBvb2w9ZS5wYXJzZU1heFBvb2xBdHRyaWJ1dGVzPWUubWF4UG9vbD1lLnBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzPWUuZ2xvYmFsQXZlcmFnZVBvb2w9ZS5wYXJzZUF2ZXJhZ2VQb29sQXR0cmlidXRlcz1lLmF2ZXJhZ2VQb29sPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDIwMzkpO2UuYXZlcmFnZVBvb2w9KHQsZSxuKT0+e3AoZSk7Y29uc3Qgcj17bmFtZTpcIkF2ZXJhZ2VQb29sXCIsaW5wdXROYW1lczpbXCJYXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDpuLmNhY2hlS2V5fTtyZXR1cm5bdC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHtnZXQ6KCk9PmEoZSxyLCExLG4pfSksZSldfSxlLnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJhdXRvX3BhZFwiLFwiTk9UU0VUXCIpLG49dC5hdHRyaWJ1dGVzLmdldEludChcImNlaWxfbW9kZVwiLDApLGk9MCE9PXQuYXR0cmlidXRlcy5nZXRJbnQoXCJjb3VudF9pbmNsdWRlX3BhZFwiLDApLG89dC5hdHRyaWJ1dGVzLmdldEludHMoXCJrZXJuZWxfc2hhcGVcIiksYT10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcInN0cmlkZXNcIixbXSkscz10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcInBhZHNcIixbXSk7aWYoMCE9PW4pdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBBdmVyYWdlUG9vbFwiKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F1dG9QYWQ6ZSxjZWlsTW9kZTpuLGNvdW50SW5jbHVkZVBhZDppLGtlcm5lbFNoYXBlOm8sc3RyaWRlczphLHBhZHM6c30pfTtjb25zdCBhPSh0LGUsbixyKT0+e2NvbnN0W2Esc109dSh0LHIsbiksYz1pLlNoYXBlVXRpbC5zaXplKGEua2VybmVsU2hhcGUpO2xldCBsPVwiXCI7YS5jb3VudEluY2x1ZGVQYWQ/bCs9YHZhbHVlIC89IGZsb2F0KCR7Y30pO2A6bCs9YHZhbHVlIC89IGZsb2F0KCR7Y30gLSBwYWQpO2A7Y29uc3QgcD1gXFxuICAgICAgICAke2YodFswXS5kaW1zLGEsXCJ2YWx1ZSArPSBfWCh4KTtcIixsLFwiMC4wXCIpfVxcbiAgICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOnMsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnB9KX07ZS5nbG9iYWxBdmVyYWdlUG9vbD0odCxlLG4pPT57cChlKTtjb25zdCByPXtuYW1lOlwiR2xvYmFsQXZlcmFnZVBvb2xcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF0sY2FjaGVIaW50OmAke24uY291bnRJbmNsdWRlUGFkfWB9O3JldHVyblt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+YShlLHIsITAsbil9KSxlKV19LGUucGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXM9dD0+e2NvbnN0IGU9MCE9PXQuYXR0cmlidXRlcy5nZXRJbnQoXCJjb3VudF9pbmNsdWRlX3BhZFwiLDApO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXV0b1BhZDpcIlwiLGNlaWxNb2RlOjAsY291bnRJbmNsdWRlUGFkOmUsa2VybmVsU2hhcGU6W10sc3RyaWRlczpbXSxwYWRzOltdfSl9LGUubWF4UG9vbD0odCxlLG4pPT57cChlKTtjb25zdCByPXtuYW1lOlwiTWF4UG9vbFwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6bi5jYWNoZUtleX07cmV0dXJuW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7Z2V0OigpPT5zKGUsciwhMSxuKX0pLGUpXX0sZS5wYXJzZU1heFBvb2xBdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJhdXRvX3BhZFwiLFwiTk9UU0VUXCIpLG49dC5hdHRyaWJ1dGVzLmdldEludChcImNlaWxfbW9kZVwiLDApLGk9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJrZXJuZWxfc2hhcGVcIiksbz10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcInN0cmlkZXNcIixbXSksYT10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcInBhZHNcIixbXSkscz10LmF0dHJpYnV0ZXMuZ2V0SW50KFwic3RvcmFnZV9vcmRlclwiLDApLHU9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJkaWxhdGlvbnNcIixbXSk7aWYoMCE9PXMpdGhyb3cgbmV3IEVycm9yKFwiY29sdW1uIG1ham9yIHN0b3JhZ2Ugb3JkZXIgaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7aWYoMCE9PW4pdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXV0b1BhZDplLGNlaWxNb2RlOm4sY291bnRJbmNsdWRlUGFkOiExLGtlcm5lbFNoYXBlOmksc3RyaWRlczpvLHBhZHM6YSxzdG9yYWdlT3JkZXI6cyxkaWxhdGlvbnM6dX0pfTtjb25zdCBzPSh0LGUsbixyKT0+e2NvbnN0W2ksYV09dSh0LHIsbikscz1gXFxuICAgICAgJHtmKHRbMF0uZGltcyxpLFwiXFxuICAgICAgdmFsdWUgPSBtYXgoX1goeCksIHZhbHVlKTtcXG4gICAgXCIsXCJcIixcIi0xZTVcIil9XFxuICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOmEsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnN9KX0sdT0odCxlLG4pPT57Y29uc3Qgcj10WzBdLmRpbXMuc2xpY2UoKSxvPU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJkaWxhdGlvbnNcIiksYT1lLmtlcm5lbFNoYXBlLnNsaWNlKCkscz1lLnN0cmlkZXMuc2xpY2UoKSx1PW8/ZS5kaWxhdGlvbnMuc2xpY2UoKTpbXSxjPWUucGFkcy5zbGljZSgpO2kuUG9vbENvbnZVdGlsLmFkanVzdFBvb2xBdHRyaWJ1dGVzKG4scixhLHMsdSxjKTtjb25zdCBsPWkuUG9vbENvbnZVdGlsLmNvbXB1dGVQb29sT3V0cHV0U2hhcGUobixyLHMsdSxhLGMsZS5hdXRvUGFkKSxwPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIG8/T2JqZWN0LmFzc2lnbihwLHtrZXJuZWxTaGFwZTphLHN0cmlkZXM6cyxwYWRzOmMsZGlsYXRpb25zOnUsY2FjaGVLZXk6ZS5jYWNoZUtleX0pOk9iamVjdC5hc3NpZ24ocCx7a2VybmVsU2hhcGU6YSxzdHJpZGVzOnMscGFkczpjLGNhY2hlS2V5OmUuY2FjaGVLZXl9KSxbcCxsXX0sYz17YXV0b1BhZDpcIlwiLGNlaWxNb2RlOjAsY291bnRJbmNsdWRlUGFkOiExLGtlcm5lbFNoYXBlOltdLHN0cmlkZXM6W10scGFkczpbXSxzdG9yYWdlT3JkZXI6MCxkaWxhdGlvbnM6W10sY2FjaGVLZXk6XCJcIn0sbD17bmFtZTpcIkdsb2JhbE1heFBvb2xcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UuZ2xvYmFsTWF4UG9vbD0odCxlKT0+KHAoZSksW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxsKSx7Z2V0OigpPT5zKGUsbCwhMCxjKX0pLGUpXSk7Y29uc3QgcD10PT57aWYoIXR8fDEhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJQb29sIG9wcyByZXF1aXJlcyAxIGlucHV0LlwiKTtpZihcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0sZj0odCxlLG4scixvKT0+e2NvbnN0IGE9dC5sZW5ndGg7aWYoZS5rZXJuZWxTaGFwZS5sZW5ndGg8PTIpe2NvbnN0IGk9ZS5rZXJuZWxTaGFwZVtlLmtlcm5lbFNoYXBlLmxlbmd0aC0xXSxzPWUuc3RyaWRlc1tlLnN0cmlkZXMubGVuZ3RoLTFdLHU9ZS5wYWRzW2UucGFkcy5sZW5ndGgvMi0xXSxjPWUucGFkc1tlLnBhZHMubGVuZ3RoLTFdLGw9dFthLTFdO2xldCBwPVwiXCIsZj1cIlwiLGQ9XCJcIjtpZihwPXUrYyE9PTA/YFxcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7aX07IGkrKykge1xcbiAgICAgICAgICAgIHhbJHthfSAtIDFdID0gaW5kaWNlc1ske2F9IC0gMV0gKiAke3N9IC0gJHt1fSArIGk7XFxuICAgICAgICAgICAgaWYgKHhbJHthfSAtIDFdIDwgMCB8fCB4WyR7YX0gLSAxXSA+PSAke2x9KSB7XFxuICAgICAgICAgICAgICBwYWQrKztcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAke259XFxuICAgICAgICAgIH1gOmBcXG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2l9OyBpKyspIHtcXG4gICAgICAgICAgICB4WyR7YX0gLSAxXSA9IGluZGljZXNbJHthfSAtIDFdICogJHtzfSAtICR7dX0gKyBpO1xcbiAgICAgICAgICAgICR7bn1cXG4gICAgICAgICAgfWAsMj09PWUua2VybmVsU2hhcGUubGVuZ3RoKXtjb25zdCBuPWUua2VybmVsU2hhcGVbZS5rZXJuZWxTaGFwZS5sZW5ndGgtMl0scj1lLnN0cmlkZXNbZS5zdHJpZGVzLmxlbmd0aC0yXSxvPWUucGFkc1tlLnBhZHMubGVuZ3RoLzItMl0scz1lLnBhZHNbZS5wYWRzLmxlbmd0aC0yXSx1PXRbYS0yXTtmPW8rcyE9PTA/YFxcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgJHtufTsgaisrKSB7XFxuICAgICAgICAgICAgICB4WyR7YX0gLSAyXSA9IGluZGljZXNbJHthfSAtIDJdICogJHtyfSAtICR7b30gKyBqO1xcbiAgICAgICAgICAgICAgaWYgKHhbJHthfSAtIDJdIDwgMCB8fCB4WyR7YX0gLSAyXSA+PSAke3V9KSB7XFxuICAgICAgICAgICAgICAgIHBhZCs9ICR7aX07XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICBgOmBcXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8ICR7bn07IGorKykge1xcbiAgICAgICAgICAgICAgeFske2F9IC0gMl0gPSBpbmRpY2VzWyR7YX0gLSAyXSAqICR7cn0gLSAke299ICsgajtcXG4gICAgICAgICAgICBgLGQ9XCJcXG4gICAgICAgICAgfVxcbiAgICAgICAgXCJ9cmV0dXJuYFxcbiAgICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2F9XSkge1xcbiAgICAgICAgICBpbnQgeFske2F9XTtcXG4gICAgICAgICAgY29weVZlYyhpbmRpY2VzLCB4KTtcXG5cXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSAke299O1xcbiAgICAgICAgICBpbnQgcGFkID0gMDtcXG4gICAgICAgICAgJHtmfVxcbiAgICAgICAgICAke3B9XFxuICAgICAgICAgICR7ZH1cXG4gICAgICAgICAgJHtyfVxcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgYH17Y29uc3Qgcz1pLlNoYXBlVXRpbC5zaXplKGUua2VybmVsU2hhcGUpLHU9aS5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZS5rZXJuZWxTaGFwZSksYz11Lmxlbmd0aCxsPWUucGFkcy5sZW5ndGgscD1oKGMpLGY9ZCh0LFwiaW5wdXREaW1zXCIpLGc9ZChlLnBhZHMsXCJwYWRzXCIpLGI9ZCh1LFwia2VybmVsU3RyaWRlc1wiKSxtPWQoZS5zdHJpZGVzLFwic3RyaWRlc1wiKTtsZXQgeT1cIlwiO3JldHVybiB5PWUucGFkcy5yZWR1Y2UoKCh0LGUpPT50K2UpKT9gXFxuICAgICAgICAgICAgaWYgKHhbal0gPj0gaW5wdXREaW1zW2pdIHx8IHhbal0gPCAwKSB7XFxuICAgICAgICAgICAgICBwYWQrKztcXG4gICAgICAgICAgICAgIGlzUGFkID0gdHJ1ZTtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoIWlzUGFkKSB7XFxuICAgICAgICAgICAgJHtufVxcbiAgICAgICAgICB9YDpgXFxuICAgICAgICAgIH1cXG4gICAgICAgICAgJHtufVxcbiAgICAgICAgYCxgXFxuICAgICAgICAke3B9XFxuICAgICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7YX1dKSB7XFxuICAgICAgICAgIGludCB4WyR7YX1dO1xcbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIHgpO1xcbiAgICAgICAgICBpbnQgb2Zmc2V0WyR7Y31dO1xcbiAgICAgICAgICBpbnQgcGFkc1ske2x9XTtcXG4gICAgICAgICAgaW50IGlucHV0RGltc1ske2F9XTtcXG4gICAgICAgICAgaW50IGtlcm5lbFN0cmlkZXNbJHtjfV07XFxuICAgICAgICAgIGludCBzdHJpZGVzWyR7Y31dO1xcbiAgICAgICAgICAke2d9XFxuICAgICAgICAgICR7Zn1cXG4gICAgICAgICAgJHttfVxcbiAgICAgICAgICAke2J9XFxuXFxuICAgICAgICAgIGZsb2F0IHZhbHVlID0gJHtvfTtcXG4gICAgICAgICAgaW50IHBhZCA9IDA7XFxuICAgICAgICAgIGJvb2wgaXNQYWQgPSBmYWxzZTtcXG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke3N9OyBpKyspIHtcXG4gICAgICAgICAgICBvZmZzZXRUb0luZGljZXMoaSwga2VybmVsU3RyaWRlcywgb2Zmc2V0KTtcXG4gICAgICAgICAgICBpc1BhZCA9IGZhbHNlO1xcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAke2F9IC0gJHtjfTsgaiA8ICR7YX07IGorKykge1xcbiAgICAgICAgICAgICAgeFtqXSA9IGluZGljZXNbal0gKiBzdHJpZGVzW2ogLSAke2F9ICsgJHtjfV1cXG4gICAgICAgICAgICAgICAgKyBvZmZzZXRbaiAtICR7YX0gKyAke2N9XSAtIHBhZHNbaiAtIDJdO1xcbiAgICAgICAgICAgICAgJHt5fVxcbiAgICAgICAgICB9XFxuICAgICAgICAgICR7cn1cXG5cXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIGB9fSxkPSh0LGUpPT57bGV0IG49XCJcIjtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyluKz1gXFxuICAgICAgJHtlfVske3J9XSA9ICR7dFtyXX07XFxuICAgIGA7cmV0dXJuIG59LGg9dD0+YFxcbiAgdm9pZCBvZmZzZXRUb0luZGljZXMoaW50IG9mZnNldCwgaW50WyR7dH1dIHN0cmlkZXMsIG91dCBpbnRbJHt0fV0gaW5kaWNlcykge1xcbiAgICBpZiAoJHt0fSA9PSAwKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHt0fSAtIDE7ICsraSkge1xcbiAgICAgIGluZGljZXNbaV0gPSBvZmZzZXQgLyBzdHJpZGVzW2ldO1xcbiAgICAgIG9mZnNldCAtPSBpbmRpY2VzW2ldICogc3RyaWRlc1tpXTtcXG4gICAgfVxcbiAgICBpbmRpY2VzWyR7dH0gLSAxXSA9IG9mZnNldDtcXG4gIH1gfSw0OTM5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnJlZHVjZUxvZ1N1bVNxdWFyZT1lLnJlZHVjZUxvZ1N1bT1lLnJlZHVjZVByb2Q9ZS5yZWR1Y2VNaW49ZS5yZWR1Y2VNYXg9ZS5yZWR1Y2VNZWFuPWUucmVkdWNlU3VtPWUucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oNzgyKSxvPW4oMjUxNyksYT1uKDIwMzkpLHM9KHQsZSxuLHIsaSk9PntjKGUpO2NvbnN0IG89e25hbWU6cixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O3JldHVyblt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbykse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+dSh0LGUsbixyLGksbyl9KSxlKV19O2UucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcy5nZXRJbnRzKFwiYXhlc1wiLFtdKSxuPTE9PT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwia2VlcGRpbXNcIiwxKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F4ZXM6ZSxrZWVwRGltczpufSl9O2NvbnN0IHU9KHQsZSxuLHIsaSxzKT0+e2NvbnN0IHU9W10sYz1lWzBdLmRpbXMubGVuZ3RofHwxLGw9W10scD1vLlNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKG4uYXhlcyxlWzBdLmRpbXMubGVuZ3RoKSxmPWkoZSxwKTtsZXQgZD1mWzFdO2ZvcihsZXQgdD0wO3Q8ZVswXS5kaW1zLmxlbmd0aDt0KyspcC5pbmRleE9mKHQpPj0wfHwwPT09cC5sZW5ndGg/KG4ua2VlcERpbXMmJnUucHVzaCgxKSxkPWBcXG4gICAgICAgICAgZm9yKGludCBqJHt0fSA9IDA7IGoke3R9IDwgJHtlWzBdLmRpbXNbdF19OyBqJHt0fSsrKSB7XFxuICAgICAgICAgICAgaW5wdXRJZHhbJHt0fV0gPSBqJHt0fTtcXG4gICAgICAgICAgICAke2R9XFxuICAgICAgICAgIH1gKToobC5wdXNoKGBpbnB1dElkeFske3R9XSA9IG91dHB1dElkeFske3UubGVuZ3RofV07YCksdS5wdXNoKGVbMF0uZGltc1t0XSkpO2NvbnN0IGg9YFxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IG91dHB1dElkeFske3UubGVuZ3RofHwxfV0pIHtcXG4gICAgICAgIGZsb2F0IHZhbHVlOyAgICAgICAgICAgICAgICAgLy8gZmluYWwgcmVzdWx0XFxuICAgICAgICBpbnQgaW5wdXRJZHhbJHtjfV07ICAgICAgLy8gYWRkcmVzc2luZyBpbnB1dCBkYXRhXFxuICAgICAgICAke2wuam9pbihcIlxcblwiKX1cXG4gICAgICAgICR7ZlswXX0gICAgICAgLy8gaW5pdCBvcHMgZm9yIHJlZHVjZSBtYXgvbWluXFxuICAgICAgICAke2R9XFxuICAgICAgICAke2ZbMl19ICAgICAgIC8vIGZpbmFsIGNvbXB1dGF0aW9uIGZvciByZWR1Y2UgbWVhblxcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse291dHB1dDp7ZGltczp1LHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOmEuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpofSl9LGM9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUmVkdWNlIG9wIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKC0xPT09aS5OVU1CRVJfVFlQRVMuaW5kZXhPZih0WzBdLnR5cGUpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9O2UucmVkdWNlU3VtPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VTdW1cIiwoKCk9PltcInZhbHVlID0gMC4wO1wiLFwidmFsdWUgKz0gX0EoaW5wdXRJZHgpO1wiLFwiXCJdKSksZS5yZWR1Y2VNZWFuPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VNZWFuXCIsKCh0LGUpPT57bGV0IG49MTtmb3IobGV0IHI9MDtyPHRbMF0uZGltcy5sZW5ndGg7cisrKShlLmluZGV4T2Yocik+PTB8fDA9PT1lLmxlbmd0aCkmJihuKj10WzBdLmRpbXNbcl0pO3JldHVybltcInZhbHVlID0gMC4wO1wiLFwidmFsdWUgKz0gX0EoaW5wdXRJZHgpO1wiLGB2YWx1ZSAvPSAke259LjtgXX0pKSxlLnJlZHVjZU1heD0odCxlLG4pPT5zKHQsZSxuLFwiUmVkdWNlTWF4XCIsKCh0LGUpPT57Y29uc3Qgbj1bXTtmb3IobGV0IHI9MDtyPHRbMF0uZGltcy5sZW5ndGg7cisrKShlLmluZGV4T2Yocik+PTB8fDA9PT1lLmxlbmd0aCkmJm4ucHVzaChgaW5wdXRJZHhbJHtyfV0gPSAwO2ApO3JldHVybltgJHtuLmpvaW4oXCJcXG5cIil9XFxudmFsdWUgPSBfQShpbnB1dElkeCk7YCxcInZhbHVlID0gbWF4KHZhbHVlLCBfQShpbnB1dElkeCkpO1wiLFwiXCJdfSkpLGUucmVkdWNlTWluPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VNaW5cIiwoKHQsZSk9Pntjb25zdCBuPVtdO2ZvcihsZXQgcj0wO3I8dFswXS5kaW1zLmxlbmd0aDtyKyspKGUuaW5kZXhPZihyKT49MHx8MD09PWUubGVuZ3RoKSYmbi5wdXNoKGBpbnB1dElkeFske3J9XSA9IDA7YCk7cmV0dXJuW2Ake24uam9pbihcIlxcblwiKX1cXG52YWx1ZSA9IF9BKGlucHV0SWR4KTtgLFwidmFsdWUgPSBtaW4odmFsdWUsIF9BKGlucHV0SWR4KSk7XCIsXCJcIl19KSksZS5yZWR1Y2VQcm9kPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VQcm9kXCIsKCgpPT5bXCJ2YWx1ZSA9IDEuMDtcIixcInZhbHVlICo9IF9BKGlucHV0SWR4KTtcIixcIlwiXSkpLGUucmVkdWNlTG9nU3VtPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VMb2dTdW1cIiwoKCk9PltcInZhbHVlID0gMC4wO1wiLFwidmFsdWUgKz0gX0EoaW5wdXRJZHgpO1wiLFwidmFsdWUgPSBsb2codmFsdWUpO1wiXSkpLGUucmVkdWNlTG9nU3VtU3F1YXJlPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VMb2dTdW1TcXVhcmVcIiwoKCk9PltcImZsb2F0IHQ7IHZhbHVlID0gMC4wO1wiLFwidCA9IF9BKGlucHV0SWR4KTsgdmFsdWUgKz0gdCAqIHQ7XCIsXCJcIl0pKX0sNzAxOToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5pc1Jlc2hhcGVDaGVhcD1lLnByb2Nlc3NEaW1zM0Q9ZS5jcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpLGk9big1MDYwKSxvPW4oMjAzOSksYT1uKDI4MjcpO2UuY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbUluZm9Mb2FkZXI9KHQsZSxuKT0+e2NvbnN0IHM9KHQ9Pih7bmFtZTpcIlJlc2hhcGUgKHBhY2tlZClcIixpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnBhY2tlZF0saW5wdXROYW1lczpbXCJBXCJdLGNhY2hlSGludDpgJHt0fWB9KSkobik7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Z2V0OigpPT4oKHQsZSxuLHMpPT57Y29uc3QgdT1lLmRpbXMsYz1zO2xldCBsPVwiXCI7Zm9yKGxldCB0PTA7dDw0O3QrKyl7bGV0IGU9XCJcIjtzd2l0Y2godCl7Y2FzZSAwOmU9XCJvdXRwdXRDb29yZHMgPSByYztcIjticmVhaztjYXNlIDE6ZT1cIm91dHB1dENvb3JkcyA9IGl2ZWMzKHJjLngsIHJjLnkrMSwgcmMueik7XCI7YnJlYWs7Y2FzZSAyOmU9XCJvdXRwdXRDb29yZHMgPSBpdmVjMyhyYy54LCByYy55LCByYy56KzEpO1wiO2JyZWFrO2Nhc2UgMzplPVwib3V0cHV0Q29vcmRzID0gaXZlYzMocmMueCwgcmMueSsxLCByYy56KzEpO1wiO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yfWwrPWBcXG4gICAgICAgICR7ZX1cXG4gICAgICAgICR7dD4wP1wiaWYob3V0cHV0Q29vcmRzLnkgPCByb3dzICYmIG91dHB1dENvb3Jkcy56IDwgY29scyl7XCI6XCJcIn1cXG4gICAgICAgICAgaW50IGZsYXR0ZW5lZEluZGV4ID0gZ2V0RmxhdHRlbmVkSW5kZXgob3V0cHV0Q29vcmRzKTtcXG5cXG4gICAgICAgICAgaXZlYzMgaW5wdXRSQyA9IGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGZsYXR0ZW5lZEluZGV4KTtcXG4gICAgICAgICAgdmVjMiBpbm5lckRpbXMgPSB2ZWMyKGZsb2F0KGlucHV0UkMueSksZmxvYXQoaW5wdXRSQy56KSk7XFxuXFxuICAgICAgICAgIHJlc3VsdFske3R9XSA9IGdldENoYW5uZWwoZ2V0QShpbnB1dFJDLngsIGlucHV0UkMueSwgaW5wdXRSQy56KSwgaW5uZXJEaW1zKTtcXG5cXG4gICAgICAgICR7dD4wP1wifVwiOlwiXCJ9XFxuICAgICAgYH1jb25zdCBwPSgwLGkuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLGY9YFxcbiAgICAgICR7ZnVuY3Rpb24odCl7Y29uc3QgZT1yLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyh0KSxuPVtcImJcIixcInJcIixcImNcIl0saT1cImluZGV4XCI7cmV0dXJuYFxcbiAgICBpdmVjMyBpbnB1dENvb3Jkc0Zyb21SZXNoYXBlZE91dENvb3JkcyhpbnQgaW5kZXgpIHtcXG4gICAgICAke2UubWFwKCgodCxyKT0+YGludCAke25bcl19ID0gJHtpfSAvICR7dH07ICR7cj09PWUubGVuZ3RoLTE/YGludCAke25bcisxXX0gPSAke2l9IC0gJHtuW3JdfSAqICR7dH1gOmBpbmRleCAtPSAke25bcl19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpfVxcbiAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcXG4gICAgfVxcbiAgYH0odSl9XFxuICAgICAgJHtmdW5jdGlvbih0KXtjb25zdCBlPXIuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHQpO3JldHVybmBcXG4gIGludCBnZXRGbGF0dGVuZWRJbmRleChpdmVjMyBjb29yZHMpIHtcXG4gICAgLy8gcmV2ZXJzZSB5LCB6IG9yZGVyXFxuICAgIHJldHVybiBjb29yZHMueCAqICR7ZVswXX0gKyBjb29yZHMueiAqICR7ZVsxXX0gKyBjb29yZHMueTtcXG4gIH1cXG5gfShjKX1cXG4gICAgICAkeygwLGEudW5wYWNrRnJvbUNoYW5uZWwpKCl9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLjApO1xcblxcbiAgICAgICAgaXZlYzMgb3V0cHV0Q29vcmRzO1xcbiAgICAgICAgaW50IHJvd3MgPSAke2NbMl19O1xcbiAgICAgICAgaW50IGNvbHMgPSAke2NbMV19O1xcblxcbiAgICAgICAgJHtsfVxcbiAgICAgICAgJHtwLm91dHB1dH0gPSByZXN1bHQ7XFxuICAgICAgfVxcbiAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpjLHR5cGU6ZS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUucGFja2VkfSxzaGFkZXJTb3VyY2U6ZixoYXNNYWluOiEwfSl9KSh0LGUscyxuKX0pfSxlLnByb2Nlc3NEaW1zM0Q9ZnVuY3Rpb24odCl7aWYoMD09PXQubGVuZ3RoKXJldHVyblsxLDEsMV07bGV0IGU9MTtmb3IobGV0IG49MDtuPHQubGVuZ3RoLTI7KytuKWUqPXRbbl07cmV0dXJuW2UsdC5sZW5ndGg+MT90W3QubGVuZ3RoLTJdOjEsdFt0Lmxlbmd0aC0xXV19LGUuaXNSZXNoYXBlQ2hlYXA9ZnVuY3Rpb24odCxlKXtsZXQgbj0hMTtyZXR1cm4gbj0wPT09dC5sZW5ndGh8fDA9PT1lLmxlbmd0aHx8KHQubGVuZ3RoPDJ8fGUubGVuZ3RoPDI/dFt0Lmxlbmd0aC0xXT09PWVbZS5sZW5ndGgtMV06dFt0Lmxlbmd0aC0xXT09PWVbZS5sZW5ndGgtMV0mJnRbdC5sZW5ndGgtMl09PT1lW2UubGVuZ3RoLTJdKSxufX0sNzE4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnJlc2hhcGU9dm9pZCAwO2NvbnN0IHI9bigyNTE3KTtlLnJlc2hhcGU9KHQsZSk9Pntjb25zdCBuPXIuU2hhcGVVdGlsLmNhbGN1bGF0ZVJlc2hhcGVkRGltcyhlWzBdLmRpbXMsZVsxXS5pbnRlZ2VyRGF0YSk7cmV0dXJuIHQuc2Vzc2lvbi5wYWNrP1t0LnJlc2hhcGVQYWNrZWQoZVswXSxuKV06W3QucmVzaGFwZVVucGFja2VkKGVbMF0sbildfX0sMjI2ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTE9ZS5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTA9ZS5yZXNpemU9dm9pZCAwO2NvbnN0IHI9big1MDYwKSxpPW4oMjAzOSksbz1uKDkzOTApLGE9bigyODI3KSxzPW4oOTc5MyksdT17bmFtZTpcIlJlc2l6ZVwiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnBhY2tlZF19O2UucmVzaXplPSh0LGUsbik9PigoMCxzLnZhbGlkYXRlSW5wdXRzKShlLG4pLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+Yyh0LGUsbil9KSxlKV0pLGUucGFyc2VSZXNpemVBdHRyaWJ1dGVzVjEwPXQ9PigwLHMucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKHQsMTApLGUucGFyc2VSZXNpemVBdHRyaWJ1dGVzVjExPXQ9PigwLHMucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKHQsMTEpO2NvbnN0IGM9KHQsZSxuKT0+e2NvbnN0IHM9KDAsci5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksW2MscF09bChlLG4pO2lmKGMuZXZlcnkoKHQ9PjE9PT10KSkmJlwidGZfY3JvcF9hbmRfcmVzaXplXCIhPT1uLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlKXJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse291dHB1dDp7ZGltczpwLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUucGFja2VkfSxoYXNNYWluOiEwLHNoYWRlclNvdXJjZTpgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICAgICAgICAgdmVjNCB2ID0gJHtzLnRleHR1cmUyRH0oWCwgVGV4Q29vcmRzKTtcXG4gICAgICAgICAgICAgICAgICAgICR7cy5vdXRwdXR9ID0gdjtcXG4gICAgICAgICAgICAgICAgfWB9KTtjb25zdCBmPXAubGVuZ3RoO2lmKGY8Mil0aHJvdyBuZXcgRXJyb3IoYG91dHB1dCBkaW1lbnNpb24gc2hvdWxkIGJlIGF0IGxlYXN0IDIsIGJ1dCBnb3QgJHtmfWApO2NvbnN0IGQ9cFtmLTJdLGg9cFtmLTFdLGc9ZVswXS5kaW1zO2lmKGYhPT1nLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYG91dHB1dCBkaW1lbnNpb24gc2hvdWxkIG1hdGNoIGlucHV0ICR7Zy5sZW5ndGh9LCBidXQgZ290ICR7Zn1gKTtjb25zdCBiPWdbZi0yXSxtPWdbZi0xXSx5PWNbZi0yXSxfPWNbZi0xXTtsZXQgdj1cIlwiO2lmKFwibGluZWFyXCIhPT1uLm1vZGUpdGhyb3cgbmV3IEVycm9yKGByZXNpemUgKHBhY2tlZCkgZG9lcyBub3Qgc3VwcG9ydCBtb2RlOiAnJHtuLm1vZGV9J2ApO3N3aXRjaChuLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlKXtjYXNlXCJhc3ltbWV0cmljXCI6dj1cIlxcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlYzQoY29vcmRzKSAvIHNjYWxlV0hXSDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgXCI7YnJlYWs7Y2FzZVwiaGFsZl9waXhlbFwiOnY9XCJcXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgZ2V0U291cmNlRnJhY0luZGV4KGl2ZWM0IGNvb3Jkcykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodmVjNChjb29yZHMpICsgMC41KSAvIHNjYWxlV0hXSCAtIDAuNTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgXCI7YnJlYWs7Y2FzZVwicHl0b3JjaF9oYWxmX3BpeGVsXCI6dj1gXFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IGZjb29yZHMgPSB2ZWM0KGNvb3Jkcyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7aH0uMCA+IDEuMCA/IChmY29vcmRzLnggKyAwLjUpIC8gc2NhbGVXSFdILnggLSAwLjUgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7ZH0uMCA+IDEuMCA/IChmY29vcmRzLnkgKyAwLjUpIC8gc2NhbGVXSFdILnkgLSAwLjUgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7aH0uMCA+IDEuMCA/IChmY29vcmRzLnogKyAwLjUpIC8gc2NhbGVXSFdILnogLSAwLjUgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7ZH0uMCA+IDEuMCA/IChmY29vcmRzLncgKyAwLjUpIC8gc2NhbGVXSFdILncgLSAwLjUgOiAwLjBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGA7YnJlYWs7Y2FzZVwiYWxpZ25fY29ybmVyc1wiOnY9YFxcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCByZXNpemVkID0gdmVjNCgke2h9LjAgLSAxLjAsICR7ZH0uMCAtIDEuMCwgJHtofS4wIC0gMS4wLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2R9LjAgLSAxLjApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgb3JpZ2luYWwgPSB2ZWM0KCR7bX0uMCAtIDEuMCwgJHtifS4wIC0gMS4wLCAke219LjAgLSAxLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7Yn0uMCAtIDEuMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBuZXdfc2NhbGUgPSBvcmlnaW5hbCAvIHJlc2l6ZWQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlYzQoY29vcmRzKSAqIG5ld19zY2FsZTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgYDticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgcmVzaXplIChwYWNrZWQpIGRvZXMgbm90IHN1cHBvcnQgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyR7bi5jb29yZGluYXRlVHJhbnNmb3JtTW9kZX0nYCl9Y29uc3Qgdz0oMCxvLmdldENvb3Jkc0RhdGFUeXBlKShmKSx4PWBcXG4gICAgICAgICAgICBjb25zdCB2ZWMyIGlucHV0V0ggPSB2ZWMyKCR7Yn0uMCwgJHttfS4wKTtcXG4gICAgICAgICAgICBjb25zdCB2ZWM0IHNjYWxlV0hXSCA9IHZlYzQoZmxvYXQoJHt5fSksIGZsb2F0KCR7X30pLCBmbG9hdCgke3l9KSwgZmxvYXQoJHtffSkpO1xcbiAgICAgICAgICAgICR7KDAsYS51bnBhY2tGcm9tQ2hhbm5lbCkoKX1cXG4gICAgICAgICAgICAke3Z9XFxuICAgICAgICAgICAgZmxvYXQgZ2V0QVZhbHVlKGludCB4MTAsIGludCByLCBpbnQgYywgaW50IGQpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0QSh4MTAsIHIsIGMsIGQpLCB2ZWMyKGMsIGQpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICAgICAke3d9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICAgICAgICAgIGludCBiYXRjaCA9IHJjWzBdO1xcbiAgICAgICAgICAgICAgICBpbnQgZGVwdGggPSByY1sxXTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gcmV0cmlldmUgdGhlIDQgY29vcmRpbmF0ZXMgdGhhdCBpcyB1c2VkIGluIHRoZSA0IHBhY2tlZCBvdXRwdXQgdmFsdWVzLlxcbiAgICAgICAgICAgICAgICBpdmVjNCBjb29yZHMgPSBpdmVjNChyYy53eiwgcmMudyArIDEsIHJjLnogKyAxKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBzb3VyY2UgaW5kZXggaW4gZnJhY3Rpb25cXG4gICAgICAgICAgICAgICAgdmVjNCBzb3VyY2VGcmFjID0gZ2V0U291cmNlRnJhY0luZGV4KGNvb3Jkcyk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgbG93ZXIgYW5kIHVwcGVyIGJvdW5kIG9mIHRoZSA0IHZhbHVlcyB0aGF0IHdpbGwgYmUgcGFja2VkIGludG8gb25lIHRleGVsLlxcbiAgICAgICAgICAgICAgICBpdmVjNCB4MDAgPSBpdmVjNChtYXgoc291cmNlRnJhYy54eSwgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy54eSkpKTtcXG4gICAgICAgICAgICAgICAgaXZlYzQgeDAxID0gaXZlYzQobWF4KHNvdXJjZUZyYWMueHcsIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMueHcpKSk7XFxuICAgICAgICAgICAgICAgIGl2ZWM0IHgxMCA9IGl2ZWM0KG1heChzb3VyY2VGcmFjLnp5LCB2ZWMyKDAuMCkpLCBtaW4oaW5wdXRXSCAtIDEuMCwgY2VpbChzb3VyY2VGcmFjLnp5KSkpO1xcbiAgICAgICAgICAgICAgICBpdmVjNCB4MTEgPSBpdmVjNChtYXgoc291cmNlRnJhYy56dywgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy56dykpKTtcXG5cXG4gICAgICAgICAgICAgICAgYm9vbCBoYXNOZXh0Um93ID0gcmMudyA8ICR7ZC0xfTtcXG4gICAgICAgICAgICAgICAgYm9vbCBoYXNOZXh0Q29sID0gcmMueiA8ICR7aC0xfTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gcGFjayB4MDAsIHgwMSwgeDEwLCB4MTEncyB0b3AtbGVmdCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcXG4gICAgICAgICAgICAgICAgdmVjNCB0b3BMZWZ0ID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgIGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMC54LCB4MDAueSksXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLngsIHgwMS55KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTAueCwgeDEwLnkpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTEueCwgeDExLnkpIDogMC4wKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gcGFjayB4MDAsIHgwMSwgeDEwLCB4MTEncyB0b3AtcmlnaHQgY29ybmVyIGludG8gb25lIHZlYzQgc3RydWN0dXJlXFxuICAgICAgICAgICAgICAgIHZlYzQgdG9wUmlnaHQgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLngsIHgwMC53KSxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueCwgeDAxLncpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC54LCB4MTAudykgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS54LCB4MTEudykgOiAwLjApO1xcblxcbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIGJvdHRvbS1sZWZ0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbUxlZnQgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLnosIHgwMC55KSxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueiwgeDAxLnkpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC56LCB4MTAueSkgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS56LCB4MTEueSkgOiAwLjApO1xcblxcbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIGJvdHRvbS1yaWdodCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcXG4gICAgICAgICAgICAgICAgdmVjNCBib3R0b21SaWdodCA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueiwgeDAwLncpLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS56LCB4MDEudykgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLnosIHgxMC53KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLnosIHgxMS53KSA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgaW50ZXJwb2xhdGlvbiBmcmFjdGlvbiBvbiB1IGFuZCB2IGRpcmVjdGlvblxcbiAgICAgICAgICAgICAgICB2ZWM0IGZyYWMgPSB2ZWM0KHNvdXJjZUZyYWMpIC0gZmxvb3Ioc291cmNlRnJhYyk7XFxuICAgICAgICAgICAgICAgIHZlYzQgY2xhbXBGcmFjID0gY2xhbXAoZnJhYywgdmVjNCgwLjApLCB2ZWM0KDEuMCkpO1xcblxcbiAgICAgICAgICAgICAgICB2ZWM0IHRvcCA9IG1peCh0b3BMZWZ0LCB0b3BSaWdodCwgY2xhbXBGcmFjLnl3eXcpO1xcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbSA9IG1peChib3R0b21MZWZ0LCBib3R0b21SaWdodCwgY2xhbXBGcmFjLnl3eXcpO1xcbiAgICAgICAgICAgICAgICB2ZWM0IG5ld1ZhbHVlID0gbWl4KHRvcCwgYm90dG9tLCBjbGFtcEZyYWMueHh6eik7XFxuXFxuICAgICAgICAgICAgICAgICR7cy5vdXRwdXR9ID0gdmVjNChuZXdWYWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtvdXRwdXQ6e2RpbXM6cCx0eXBlOmVbMF0udHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnBhY2tlZH0saGFzTWFpbjohMCxzaGFkZXJTb3VyY2U6eH0pfSxsPSh0LGUpPT57Y29uc3Qgbj10WzBdLmRpbXM7bGV0IHIsaT1lLnNjYWxlcztpZigwPT09aS5sZW5ndGgpe2NvbnN0IG89dFtlLnNjYWxlc0lucHV0SWR4XTtpZihvJiYwIT09by5zaXplKXtpZih0W2Uuc2l6ZXNJbnB1dElkeF0pdGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgb2Ygc2NhbGVzIG9yIHNpemVzIG11c3QgYmUgcHJvdmlkZWQgYXMgaW5wdXQuXCIpO2k9cChvLGUubW9kZSxlLmlzUmVzaXplKX1lbHNle2NvbnN0IG89dFtlLnNpemVzSW5wdXRJZHhdO2lmKCFvfHwwPT09by5zaXplKXRocm93IG5ldyBFcnJvcihcIkVpdGhlciBzY2FsZXMgb3Igc2l6ZXMgTVVTVCBiZSBwcm92aWRlZCBhcyBpbnB1dC5cIik7cj1BcnJheS5mcm9tKG8uaW50ZWdlckRhdGEpLGk9ZihyLG4sZS5tb2RlLGUuaXNSZXNpemUpfX1lbHNlIGlmKHRbZS5zaXplc0lucHV0SWR4XSl0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBvZiBzY2FsZXMgb3Igc2l6ZXMgbXVzdCBiZSBwcm92aWRlZCBhcyBpbnB1dC5cIik7Y29uc3Qgbz1yfHxuLm1hcCgoKHQsZSk9Pk1hdGguZmxvb3IodCppW2VdKSkpO3JldHVybltpLG9dfSxwPSh0LGUsbik9Pntjb25zdCByPUFycmF5LmZyb20odC5mbG9hdERhdGEpO3JldHVybigwLHMuc2NhbGVzVmFsaWRhdGlvbikocixlLG4pLHJ9LGY9KHQsZSxuLHIpPT57Y29uc3QgaT1lLmxlbmd0aCxvPW5ldyBBcnJheShpKTtmb3IobGV0IG49MCxyPWk7bjxyO24rKylpZigwPT09ZVtuXSl7aWYoMCE9PXRbbl0pdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZGltIGlzIHplcm8gYnV0IHJlcXVpcmVkIG91dHB1dCBkaW0gaXMgbm9uLXplcm8uXCIpO29bbl09MX1lbHNlIG9bbl09dFtuXS9lW25dO3JldHVybigwLHMuc2NhbGVzVmFsaWRhdGlvbikobyxuLHIpLG99fSw4MTE3Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNoYXBlPXZvaWQgMDtjb25zdCByPW4oOTE2Mik7ZS5zaGFwZT0odCxlKT0+KGkoZSksW25ldyByLlRlbnNvcihbZVswXS5kaW1zLmxlbmd0aF0sXCJpbnQzMlwiLHZvaWQgMCx2b2lkIDAsbmV3IEludDMyQXJyYXkoZVswXS5kaW1zKSldKTtjb25zdCBpPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIHJlcXVpcmVzIDEgaW5wdXQuXCIpfX0sMjI3ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5zbGljZVYxMD1lLnBhcnNlU2xpY2VBdHRyaWJ1dGVzPWUuc2xpY2U9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9big3ODIpLG89bigyNTE3KSxhPW4oMjAzOSkscz17bmFtZTpcIlNsaWNlXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2EuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTtlLnNsaWNlPSh0LGUsbik9PihjKGUpLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+dSh0LGVbMF0sbil9KSxlKV0pLGUucGFyc2VTbGljZUF0dHJpYnV0ZXM9dD0+e2NvbnN0IGU9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJzdGFydHNcIiksbj10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcImVuZHNcIiksaT10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcImF4ZXNcIixbXSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtzdGFydHM6ZSxlbmRzOm4sYXhlczppfSl9O2NvbnN0IHU9KHQsZSxuKT0+e2NvbnN0IHI9MD09PW4uYXhlcy5sZW5ndGg/ZS5kaW1zLnNsaWNlKDApLm1hcCgoKHQsZSk9PmUpKTpuLmF4ZXMsaT1vLlNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKHIsZS5kaW1zLmxlbmd0aCksdT1uLnN0YXJ0cy5tYXAoKCh0LG4pPT50PmUuZGltc1tpW25dXS0xP2UuZGltc1tpW25dXTpvLlNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKHQsZS5kaW1zW2lbbl1dKSkpLGM9bi5lbmRzLm1hcCgoKHQsbik9PnQ+ZS5kaW1zW2lbbl1dLTE/ZS5kaW1zW2lbbl1dOm8uU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXModCxlLmRpbXNbaVtuXV0pKSksbD1lLmRpbXMuc2xpY2UoKSxwPVtdO2ZvcihsZXQgdD0wO3Q8aS5sZW5ndGg7dCsrKWxbaVt0XV09Y1t0XS11W3RdLHVbdF0+MCYmcC5wdXNoKGBvdXRwdXRJZHhbJHtpW3RdfV0gKz0gJHt1W3RdfTtgKTtjb25zdCBmPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHtsLmxlbmd0aH1dKSB7XFxuICAgICAgICAke3Auam9pbihcIlxcbiAgICAgIFwiKX1cXG4gICAgICAgIHJldHVybiBfQShvdXRwdXRJZHgpO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse291dHB1dDp7ZGltczpsLHR5cGU6ZS50eXBlLHRleHR1cmVUeXBlOmEuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpmfSl9LGM9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiU2xpY2UgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoLTE9PT1pLk5VTUJFUl9UWVBFUy5pbmRleE9mKHRbMF0udHlwZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX07ZS5zbGljZVYxMD0odCxlKT0+e3AoZSk7Y29uc3Qgbj1sKHQsZSk7cmV0dXJuW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT51KHQsZVswXSxuKX0pLFtlWzBdXSldfTtjb25zdCBsPSh0LGUpPT57aWYoIXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMV0uZGF0YUlkKXx8IXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMl0uZGF0YUlkKXx8ZS5sZW5ndGg+PTQmJiF0LnNlc3Npb24uaXNJbml0aWFsaXplcihlWzNdLmRhdGFJZCl8fGUubGVuZ3RoPj01JiYhdC5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoZVs0XS5kYXRhSWQpKXRocm93IG5ldyBFcnJvcihcImR5bmFtaWMgc2xpY2UgYXR0cmlidXRlcyBhcmUgbm90IGFsbG93ZWRcIik7aWYoZS5sZW5ndGg+PTUmJmVbNF0uaW50ZWdlckRhdGEuc29tZSgodD0+MSE9PXQpKSl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgbm9uLTEgc3RlcHMgaXMgbm90IHN1cHBvcnRlZCBmb3IgU2xpY2VcIik7Y29uc3Qgbj1BcnJheS5mcm9tKGVbMV0uaW50ZWdlckRhdGEpLHI9QXJyYXkuZnJvbShlWzJdLmludGVnZXJEYXRhKSxpPWUubGVuZ3RoPj00P0FycmF5LmZyb20oZVszXS5pbnRlZ2VyRGF0YSk6W107cmV0dXJue3N0YXJ0czpuLGVuZHM6cixheGVzOmksY2FjaGVLZXk6YCR7aX07JHtufTske3J9YH19LHA9dD0+e2lmKCF0fHx0Lmxlbmd0aDwzfHx0Lmxlbmd0aD41KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgbnVtYmVyLlwiKTtpZihcImludDMyXCIhPT10WzFdLnR5cGV8fDEhPT10WzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoXCJpbnQzMlwiIT09dFsyXS50eXBlfHwxIT09dFsyXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKHQubGVuZ3RoPj00JiYoXCJpbnQzMlwiIT09dFszXS50eXBlfHwxIT09dFszXS5kaW1zLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZih0Lmxlbmd0aD49NSYmKFwiaW50MzJcIiE9PXRbNF0udHlwZXx8MSE9PXRbNF0uZGltcy5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSw1NTI0Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNvZnRtYXhWMTM9ZS5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzPWUucGFyc2VTb2Z0bWF4QXR0cmlidXRlcz1lLnNvZnRtYXg9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9bigyNTE3KSxvPW4oNTA2MCksYT1uKDIwMzkpLHM9bigzNzM4KSx1PXtuYW1lOlwiU29mdG1heENvbXB1dGVNYXhcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19LGM9e25hbWU6XCJTb2Z0bWF4Q29tcHV0ZVNjYWxlXCIsaW5wdXROYW1lczpbXCJBXCIsXCJNYXhcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZCxhLlRleHR1cmVUeXBlLnVucGFja2VkXX0sbD17bmFtZTpcIlNvZnRNYXhcIixpbnB1dE5hbWVzOltcIkFcIixcIk1heFwiLFwiTm9ybVwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkLGEuVGV4dHVyZVR5cGUudW5wYWNrZWQsYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2Uuc29mdG1heD0odCxlLG4pPT57ZyhlKTtjb25zdCByPWVbMF0uZGltcy5zbGljZSgpLG89aS5TaGFwZVV0aWwubm9ybWFsaXplQXhpcyhuLmF4aXMsci5sZW5ndGgpLGE9aS5TaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKHIsbykscz1pLlNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihyLG8pO3JldHVybiBwKHQsZSxuLGEscyl9LGUucGFyc2VTb2Z0bWF4QXR0cmlidXRlcz10PT4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F4aXM6dC5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwxKX0pLGUucGFyc2VTb2Z0bWF4QXR0cmlidXRlc1YxMz10PT4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F4aXM6dC5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwtMSl9KSxlLnNvZnRtYXhWMTM9KHQsZSxuKT0+e2coZSk7Y29uc3Qgbz1lWzBdLmRpbXMuc2xpY2UoKSxhPWkuU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMobi5heGlzLG8ubGVuZ3RoKSx1PW8ubGVuZ3RoLGM9YSE9PXUtMSxsPVtdO2xldCBmLGQ9W10saD1bXTtjJiYoZD1BcnJheS5mcm9tKHtsZW5ndGg6dX0pLm1hcCgoKHQsZSk9PmUpKSxkW2FdPXUtMSxkW3UtMV09YSxkLm1hcCgodD0+bC5wdXNoKG9bdF0pKSksZj0oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe3Blcm06ZH0pLGg9KDAscy50cmFuc3Bvc2UpKHQsZSxmKSk7Y29uc3QgYj1jP2kuU2hhcGVVdGlsLnNpemVUb0RpbWVuc2lvbihsLHUtMSk6aS5TaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKG8sdS0xKSxtPWM/aS5TaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24obCx1LTEpOmkuU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKG8sdS0xKSx5PXAodCxjP2g6ZSxuLGIsbSk7cmV0dXJuIGM/KDAscy50cmFuc3Bvc2UpKHQseSxmKTp5fTtjb25zdCBwPSh0LGUsbixyLGkpPT57Y29uc3Qgbz1mKHQsZVswXSxyLGksW3JdKSxhPXQucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT5vfSksZSkscz1kKHQsZVswXSxyLGksby5vdXRwdXQuZGltcyxbcl0pLHA9dC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGMpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9PnN9KSxbZVswXSxhXSksZz1oKHQsZVswXSxyLGksby5vdXRwdXQuZGltcyxzLm91dHB1dC5kaW1zKTtyZXR1cm5bdC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGwpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9Pmd9KSxbZVswXSxhLHBdKV19LGY9KHQsZSxuLHIsaSk9Pntjb25zdFtzLGNdPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGUuZGltcyxhLlRleHR1cmVUeXBlLnVucGFja2VkKSxsPWkubGVuZ3RoO2lmKG48MXx8cjwxKXRocm93IG5ldyBFcnJvcihcIkxvZ2ljYWwgcm93IGNvdW50IE4gYW5kIGZlYXR1cmUgY291bnQgRCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpO2lmKDEhPT1pLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgb3V0cHV0IHNob3VsZCBiZSAxXCIpO2lmKGlbMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50XCIpO2NvbnN0IHA9KDAsby5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksZj1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtsfV0gaW5kaWNlcykge1xcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke3J9O1xcblxcbiAgICAgICAgZmxvYXQgbWF4ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7cC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCwgJHtzfSxcXG4gICAgICAgICR7Y30gKSkpO1xcbiAgICAgICAgZm9yKGludCBpPTE7IGk8JHtyfTsgKytpKVxcbiAgICAgICAge1xcbiAgICAgICAgICBmbG9hdCBjdXJyZW50ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7cC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCArIGksXFxuICAgICAgICAgICAgJHtzfSwgJHtjfSkpKTtcXG4gICAgICAgICAgaWYoY3VycmVudCA+IG1heClcXG4gICAgICAgICAgbWF4ID0gY3VycmVudDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBtYXg7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7b3V0cHV0OntkaW1zOmksdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmZ9KX0sZD0odCxlLG4scixpLHMpPT57Y29uc3RbdSxsXT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlLmRpbXMsYS5UZXh0dXJlVHlwZS51bnBhY2tlZCkscD1zLmxlbmd0aDtpZihuPDF8fHI8MSl0aHJvdyBuZXcgRXJyb3IoXCJMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKTtpZigxIT09cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uYWxpdHkgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgMVwiKTtpZihzWzBdIT09bil0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZSBvZiB0aGUgb3V0cHV0IHNob3VsZCBiZSBlcXVhbCB0byBsb2dpY2FsIHJvdyBjb3VudFwiKTtpZigxIT09aS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uYWxpdHkgb2YgdGhlIGludGVybWVkaWF0ZSByZXN1bHRzIHNob3VsZCBiZSAxXCIpO2lmKGlbMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnRcIik7Y29uc3QgZj1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtwfV0gaW5kaWNlcykge1xcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke3J9O1xcblxcbiAgICAgICAgZmxvYXQgbm9ybV9mYWN0b3IgPSAwLjA7XFxuICAgICAgICBmbG9hdCBtYXggPSBfTWF4KGluZGljZXMpO1xcbiAgICAgICAgZm9yKGludCBpPTA7IGk8JHtyfTsgKytpKVxcbiAgICAgICAge1xcbiAgICAgICAgICBub3JtX2ZhY3RvciArPSBleHAoZ2V0Q29sb3JBc0Zsb2F0KCR7KDAsby5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfShBLCBvZmZzZXRUb0Nvb3Jkcyhsb2dpY2FsX3Jvd19zdGFydF9vZmZzZXQgKyBpLFxcbiAgICAgICAgICAgICR7dX0sICR7bH0pKSkgLSBtYXgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIG5vcm1fZmFjdG9yO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYykse291dHB1dDp7ZGltczpzLHR5cGU6ZS50eXBlLHRleHR1cmVUeXBlOmEuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpmfSl9LGg9KHQsZSxuLHIsaSxvKT0+e2NvbnN0W3MsdV09dC5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoZS5kaW1zLGEuVGV4dHVyZVR5cGUudW5wYWNrZWQpLGM9ZS5kaW1zLmxlbmd0aDtpZihuPDF8fHI8MSl0aHJvdyBuZXcgRXJyb3IoXCJMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKTtpZigxIT09aS5sZW5ndGh8fDEhPT1vLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDFcIik7aWYoaVswXSE9PW58fG9bMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnRcIik7Y29uc3QgcD1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtjfV0gaW5kaWNlcykge1xcblxcbiAgICAgIC8vIGdldCBvZmZzZXQgb2YgY3VycmVudCBsb2dpY2FsIHRlbnNvciBpbmRleCBmcm9tIHRoZSAyLUQgdGV4dHVyZSBjb29yZGluYXRlcyAoVGV4Q29vcmRzKVxcbiAgICAgIGludCBvZmZzZXQgPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7c30sICR7dX0pO1xcblxcbiAgICAgIC8vZGV0ZXJtaW5lIHRoZSBsb2dpY2FsIHJvdyBmb3IgdGhpcyBpbmRleFxcbiAgICAgIGludCBsb2dpY2FsX3Jvd19pbmRleFsxXTtcXG4gICAgICBsb2dpY2FsX3Jvd19pbmRleFswXSA9IG9mZnNldCAvICR7cn07XFxuXFxuICAgICAgZmxvYXQgbm9ybV9mYWN0b3IgPSBfTm9ybShsb2dpY2FsX3Jvd19pbmRleCk7XFxuXFxuICAgICAgLy8gYXZvaWQgcG9zc2libGUgZGl2aXNpb24gYnkgMFxcbiAgICAgIC8vIGlmIG5vcm1fZmFjb3IgaXMgMCwgYWxsIGVsZW1lbnRzIGFyZSB6ZXJvXFxuICAgICAgLy8gaWYgc28sIHJldHVybiAwXFxuICAgICAgaWYobm9ybV9mYWN0b3IgPT0gMC4wKVxcbiAgICAgICAgcmV0dXJuIDAuMDtcXG5cXG4gICAgICByZXR1cm4gZXhwKF9BKGluZGljZXMpIC0gX01heChsb2dpY2FsX3Jvd19pbmRleCkpIC8gbm9ybV9mYWN0b3I7XFxuICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbCkse291dHB1dDp7ZGltczplLmRpbXMsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnB9KX0sZz10PT57aWYoIXR8fDEhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTb2Z0bWF4IHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGVcIil9fSw1OTc1Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlU3BsaXRBdHRyaWJ1dGVzPWUuc3BsaXQ9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9bigyNTE3KSxvPW4oMjAzOSksYT17bmFtZTpcIlNwbGl0XCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWRdfTtlLnNwbGl0PSh0LGUsbik9PntjKGUpO2NvbnN0IHI9aS5TaGFwZVV0aWwubm9ybWFsaXplQXhpcyhuLmF4aXMsZVswXS5kaW1zLmxlbmd0aCksbz1zKHQsZSxyLG4pLGw9W107Zm9yKGxldCBpPTA7aTxvOysraSlsLnB1c2godC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtjYWNoZUhpbnQ6YCR7bi5jYWNoZUtleX07JHtpfWAsZ2V0OigpPT51KHQsZVswXSxuLHIsaSl9KSxlKSk7cmV0dXJuIGx9LGUucGFyc2VTcGxpdEF0dHJpYnV0ZXM9dD0+e2NvbnN0IGU9dC5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwwKSxuPXQuYXR0cmlidXRlcy5nZXRJbnRzKFwic3BsaXRcIixbXSksaT10Lm91dHB1dHMubGVuZ3RoO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXhpczplLHNwbGl0Om4sbnVtT3V0cHV0czppfSl9O2NvbnN0IHM9KHQsZSxuLHIpPT57Y29uc3RbLG9dPWkuU3BsaXRVdGlsLnNwbGl0U2hhcGUoZVswXS5kaW1zLG4sci5zcGxpdCxyLm51bU91dHB1dHMpO3JldHVybiBvLmxlbmd0aH0sdT0odCxlLG4scixzKT0+e2NvbnN0W3UsY109aS5TcGxpdFV0aWwuc3BsaXRTaGFwZShlLmRpbXMscixuLnNwbGl0LG4ubnVtT3V0cHV0cyksbD1jW3NdLHA9dVtzXSxmPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cC5sZW5ndGh9XSkge1xcbiAgICAgICAgaW5kaWNlc1ske3J9XSArPSAke2x9O1xcbiAgICAgICAgcmV0dXJuIF9BKGluZGljZXMpO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtjYWNoZUhpbnQ6YCR7bi5jYWNoZUtleX06JHtzfWAsb3V0cHV0OntkaW1zOnAsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmZ9KX0sYz10PT57aWYoIXR8fDEhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTcGxpdCByZXF1aXJlcyBvbmUgaW5wdXQuXCIpO2lmKFwiaW50OFwiIT09dFswXS50eXBlJiZcInVpbnQ4XCIhPT10WzBdLnR5cGUmJlwiaW50MTZcIiE9PXRbMF0udHlwZSYmXCJ1aW50MTZcIiE9PXRbMF0udHlwZSYmXCJpbnQzMlwiIT09dFswXS50eXBlJiZcInVpbnQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGUmJlwiYm9vbFwiIT09dFswXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSwzOTMzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlU3F1ZWV6ZUF0dHJpYnV0ZXM9ZS5zcXVlZXplVjEzPWUuc3F1ZWV6ZT12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpO2Uuc3F1ZWV6ZT0odCxlLG4pPT57aShlKTtjb25zdCBvPXIuU2hhcGVVdGlsLnNxdWVlemVTaGFwZShlWzBdLmRpbXMsbik7cmV0dXJuW3QucmVzaGFwZVVucGFja2VkKGVbMF0sbyldfSxlLnNxdWVlemVWMTM9KHQsbik9PihvKG4pLCgwLGUuc3F1ZWV6ZSkodCxbblswXV0sQXJyYXkuZnJvbShuWzFdLmludGVnZXJEYXRhKSkpLGUucGFyc2VTcXVlZXplQXR0cmlidXRlcz10PT50LmF0dHJpYnV0ZXMuZ2V0SW50cyhcImF4ZXNcIik7Y29uc3QgaT10PT57aWYoIXR8fDEhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTcXVlZXplIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSxvPXQ9PntpZighdHx8MiE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNxdWVlemUgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKFwiaW50MzJcIiE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0sNjU1ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5zdW09dm9pZCAwO2NvbnN0IHI9big1MDYwKSxpPW4oMjAzOSk7ZS5zdW09KHQsZSk9PnthKGUpO2NvbnN0IG49e25hbWU6XCJTdW1cIixpbnB1dE5hbWVzOmUubWFwKCgodCxlKT0+YFgke2V9YCkpLGlucHV0VHlwZXM6bmV3IEFycmF5KGUubGVuZ3RoKS5maWxsKGkuVGV4dHVyZVR5cGUudW5wYWNrZWQpfTtyZXR1cm5bdC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtnZXQ6KCk9Pm8odCxlLG4pfSksZSldfTtjb25zdCBvPSh0LGUsbik9Pntjb25zdCBvPSgwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLGE9ZVswXS5kaW1zLnNsaWNlKCkscz1gXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke2UubWFwKCgodCxlKT0+YCR7by50ZXh0dXJlMkR9KFgke2V9LFRleENvb3JkcylgKSkuam9pbihcIiArIFwiKX07XFxuICAgICAgICAke28ub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7b3V0cHV0OntkaW1zOmEsdHlwZTplWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0saGFzTWFpbjohMCxzaGFkZXJTb3VyY2U6c30pfSxhPXQ9PntpZighdHx8MD09PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlN1bSByZXF1aXJlcyBpbnB1dHMuXCIpO2NvbnN0IGU9dFswXS5kaW1zLmxlbmd0aDtmb3IobGV0IG49MTtuPHQubGVuZ3RoO24rKyl7aWYoZSE9PXRbbl0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc2hhcGVzIGFyZSBtaXNtYXRjaGVkLlwiKTtmb3IobGV0IHI9MDtyPGU7cisrKWlmKHRbMF0uZGltc1tyXSE9PXRbbl0uZGltc1tyXSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBzaGFwZXMgYXJlIG5vdCBtYXRjaGVkLlwiKX1pZihcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtmb3IobGV0IGU9MTtlPHQubGVuZ3RoO2UrKylpZih0WzBdLnR5cGUhPT10W2VdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZXMgYXJlIG5vdCBtYXRjaGVkLlwiKX19LDU3MjM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUudGlsZT12b2lkIDA7Y29uc3Qgcj1uKDc4MiksaT1uKDIwMzkpO2UudGlsZT0odCxlKT0+e2EoZSk7Y29uc3Qgbj17bmFtZTpcIlRpbGVcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O3JldHVyblt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+byh0LGUsbil9KSxlKV19O2NvbnN0IG89KHQsZSxuKT0+e2NvbnN0IHI9ZVswXS5kaW1zLnNsaWNlKCksbz1uZXcgQXJyYXkoci5sZW5ndGgpLGE9W107Zm9yKGxldCB0PTA7dDxyLmxlbmd0aDt0Kyspb1t0XT1yW3RdKmVbMV0ubnVtYmVyRGF0YVt0XSxhLnB1c2goYGlucHV0SWR4WyR7dH1dID0gaW50KG1vZChmbG9hdChvdXRwdXRJZHhbJHt0fV0pLCAke3JbdF19LikpO2ApO2NvbnN0IHM9by5sZW5ndGgsdT1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7c31dKSB7XFxuICAgICAgICBpbnQgaW5wdXRJZHhbJHtzfV07XFxuICAgICAgICAke2Euam9pbihcIlxcblwiKX1cXG4gICAgICAgIHJldHVybiBfQShpbnB1dElkeCk7XFxuICAgICAgfVxcbiAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpvLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTp1fSl9LGE9dD0+e2lmKCF0fHwyIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSByZXF1aXJlcyAyIGlucHV0LlwiKTtpZigxIT09dFsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2Vjb25kIGlucHV0IHNoYXBlIG11c3QgMSBkaW1lbnNpb24uXCIpO2lmKHRbMV0uZGltc1swXSE9PXRbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYoLTE9PT1yLk5VTUJFUl9UWVBFUy5pbmRleE9mKHRbMF0udHlwZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZihcImludDMyXCIhPT10WzFdLnR5cGUmJlwiaW50MTZcIiE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlcGVhdCB0eXBlLlwiKX19LDM3Mzg6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzPWUudHJhbnNwb3NlPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDIwMzkpLGE9e25hbWU6XCJUcmFuc3Bvc2VcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UudHJhbnNwb3NlPSh0LGUsbik9PihwKGUpLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+cyh0LGVbMF0sbi5wZXJtKX0pLGUpXSksZS5wYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtwZXJtOnQuYXR0cmlidXRlcy5nZXRJbnRzKFwicGVybVwiLFtdKX0pO2NvbnN0IHM9KHQsZSxuKT0+e2NvbnN0IHI9ZS5kaW1zO249dShyLG4pO2NvbnN0IGk9YyhyLG4pLHM9ci5sZW5ndGgscD1gXFxuICAgICAgJHtsKFwicGVybVwiLG4scyl9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3N9XSkge1xcbiAgICAgICAgaW50IGFbJHtzfV07XFxuICAgICAgICBwZXJtKGEsIGluZGljZXMpO1xcbiAgICAgICAgcmV0dXJuIF9BKGEpO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse291dHB1dDp7ZGltczppLHR5cGU6ZS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpwfSl9LHU9KHQsZSk9PihlJiZlLmxlbmd0aCE9PXQubGVuZ3RoJiYoZT1bLi4udC5rZXlzKCldLnJldmVyc2UoKSksZSksYz0odCxlKT0+KGU9dSh0LGUpLGkuU2hhcGVVdGlsLnNvcnRCYXNlZE9uUGVybSh0LGUpKSxsPSh0LGUsbik9Pntjb25zdCByPVtdO3IucHVzaChgdm9pZCAke3R9KG91dCBpbnQgYVske259XSwgaW50IHNyY1ske259XSkge2ApO2ZvcihsZXQgdD0wO3Q8bjsrK3Qpci5wdXNoKGBcXHRhWyR7ZVt0XX1dPXNyY1ske3R9XTtgKTtyZXR1cm4gci5wdXNoKFwiXFx0fVwiKSxyLmpvaW4oXCJcXG5cIil9LHA9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfX0sODcxMDoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5lbmNvZGVBc1VpbnQ4PXZvaWQgMDtjb25zdCByPW4oNTA2MCksaT1uKDIwMzkpO2UuZW5jb2RlQXNVaW50OD0odCxlKT0+e2NvbnN0IG49ZS5zaGFwZSxvPSgwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLGE9YFxcbiAgICBjb25zdCBmbG9hdCBGTE9BVF9NQVggPSAxLjcwMTQxMTg0ZTM4O1xcbiAgICBjb25zdCBmbG9hdCBGTE9BVF9NSU4gPSAxLjE3NTQ5NDM1ZS0zODtcXG5cXG4gICAgYm9vbCBpc05hTihmbG9hdCB2YWwpIHtcXG4gICAgICByZXR1cm4gKHZhbCA8IDEuMCB8fCAwLjAgPCB2YWwgfHwgdmFsID09IDAuMCkgPyBmYWxzZSA6IHRydWU7XFxuICAgIH1cXG5cXG4gICAgaGlnaHAgdmVjNCBlbmNvZGVBc1VpbnQ4KGhpZ2hwIGZsb2F0IHYpIHtcXG4gICAgICBpZiAoaXNOYU4odikpIHtcXG4gICAgICAgIHJldHVybiB2ZWM0KDI1NSwgMjU1LCAyNTUsIDI1NSk7XFxuICAgICAgfVxcblxcbiAgICAgIGhpZ2hwIGZsb2F0IGF2ID0gYWJzKHYpO1xcblxcbiAgICAgIGlmKGF2IDwgRkxPQVRfTUlOKSB7XFxuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcbiAgICAgIH0gZWxzZSBpZih2ID4gRkxPQVRfTUFYKSB7XFxuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMTI4LjAsIDEyNy4wKSAvIDI1NS4wO1xcbiAgICAgIH0gZWxzZSBpZih2IDwgLUZMT0FUX01BWCkge1xcbiAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsICAxMjguMCwgMjU1LjApIC8gMjU1LjA7XFxuICAgICAgfVxcblxcbiAgICAgIGhpZ2hwIHZlYzQgYyA9IHZlYzQoMCwwLDAsMCk7XFxuXFxuICAgICAgaGlnaHAgZmxvYXQgZSA9IGZsb29yKGxvZzIoYXYpKTtcXG4gICAgICBoaWdocCBmbG9hdCBtID0gZXhwMihmcmFjdChsb2cyKGF2KSkpIC0gMS4wO1xcblxcbiAgICAgIGNbMl0gPSBmbG9vcigxMjguMCAqIG0pO1xcbiAgICAgIG0gLT0gY1syXSAvIDEyOC4wO1xcbiAgICAgIGNbMV0gPSBmbG9vcigzMjc2OC4wICogbSk7XFxuICAgICAgbSAtPSBjWzFdIC8gMzI3NjguMDtcXG4gICAgICBjWzBdID0gZmxvb3IoODM4ODYwOC4wICogbSk7XFxuXFxuICAgICAgaGlnaHAgZmxvYXQgZWJpYXMgPSBlICsgMTI3LjA7XFxuICAgICAgY1szXSA9IGZsb29yKGViaWFzIC8gMi4wKTtcXG4gICAgICBlYmlhcyAtPSBjWzNdICogMi4wO1xcbiAgICAgIGNbMl0gKz0gZmxvb3IoZWJpYXMpICogMTI4LjA7XFxuXFxuICAgICAgY1szXSArPSAxMjguMCAqIHN0ZXAoMC4wLCAtdik7XFxuXFxuICAgICAgcmV0dXJuIGMgLyAyNTUuMDtcXG4gICAgfVxcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgZmxvYXQgdmFsdWUgPSAke28udGV4dHVyZTJEfShYLFRleENvb3JkcykucjtcXG4gICAgICAke28ub3V0cHV0fSA9IGVuY29kZUFzVWludDgodmFsdWUpO1xcbiAgICB9YCxzPXtuYW1lOlwiVWludDhFbmNvZGVcIixpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkXSxpbnB1dE5hbWVzOltcIlhcIl0sb3V0cHV0OntkaW1zOm4sdHlwZTplLnRlbnNvci50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUuZG93bmxvYWRVaW50OEFzRmxvYXR9LHNoYWRlclNvdXJjZTphLGhhc01haW46ITB9O3JldHVybiB0LmV4ZWN1dGVQcm9ncmFtKHMsW2UudGVuc29yXSl9fSw0OTA5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnRhbmg9ZS50YW49ZS5zcXJ0PWUuc2luPWUuc2lnbW9pZD1lLnJlbHU9ZS5ub3Q9ZS5uZWc9ZS5sb2c9ZS5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXM9ZS5sZWFreVJlbHU9ZS5pZGVudGl0eT1lLmZsb29yPWUuZXhwPWUucGFyc2VFbHVBdHRyaWJ1dGVzPWUuZWx1PWUuY29zPWUuY2VpbD1lLmNsaXBWMTE9ZS5wYXJzZUNsaXBBdHRyaWJ1dGVzPWUuY2xpcD1lLmF0YW49ZS5hc2luPWUuYWNvcz1lLmFicz1lLmdsc2xUYW5oPWUuZ2xzbFRhbj1lLmdsc2xTcXJ0PWUuZ2xzbFNpZ21vaWQ9ZS5nbHNsUmVsdT1lLmdsc2xTaW49ZS5nbHNsTm90PWUuZ2xzbE5lZz1lLmdsc2xMb2c9ZS5nbHNsTGVha3lSZWx1PWUuZ2xzbElkZW50aXR5PWUuZ2xzbENsaXA9ZS5nbHNsRmxvb3I9ZS5nbHNsRXhwPWUuZ2xzbEVsdT1lLmdsc2xDb3M9ZS5nbHNsQ2VpbD1lLmdsc2xBdGFuPWUuZ2xzbEFzaW49ZS5nbHNsQWNvcz1lLmdsc2xBYnM9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9bigyNTE3KSxvPW4oODUyMCksYT1uKDUwNjApLHM9bigyMDM5KTtmdW5jdGlvbiB1KCl7cmV0dXJuIFAoXCJhYnNcIil9ZnVuY3Rpb24gYygpe3JldHVybiBQKFwiYWNvc1wiKX1mdW5jdGlvbiBsKCl7cmV0dXJuIFAoXCJhc2luXCIpfWZ1bmN0aW9uIHAoKXtyZXR1cm4gUChcImF0YW5cIil9ZnVuY3Rpb24gZigpe3JldHVybiBQKFwiY2VpbFwiKX1mdW5jdGlvbiBkKCl7cmV0dXJuIFAoXCJjb3NcIil9ZnVuY3Rpb24gaCh0KXtjb25zdCBlPVwiZWx1XCI7cmV0dXJue2JvZHk6YFxcbiAgY29uc3QgZmxvYXQgYWxwaGEgPSBmbG9hdCgke3R9KTtcXG5cXG4gIGZsb2F0ICR7ZX1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIGEgPj0gMC4wID8gYTogKGV4cChhKSAtIDEuMCkgKiBhbHBoYTtcXG4gIH1cXG4gIHZlYzQgJHtlfV8odmVjNCB2KSB7XFxuICAgIHJldHVybiB2ZWM0KCR7ZX1fKHYueCksICR7ZX1fKHYueSksICR7ZX1fKHYueiksICR7ZX1fKHYudykpO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBnKCl7cmV0dXJuIFAoXCJleHBcIil9ZnVuY3Rpb24gYigpe3JldHVybiBQKFwiZmxvb3JcIil9ZnVuY3Rpb24gbSh0LGUpe2NvbnN0IG49XCJjbGlwXCI7cmV0dXJue2JvZHk6YFxcbiAgY29uc3QgZmxvYXQgbWluID0gZmxvYXQoJHt0fSk7XFxuICBjb25zdCBmbG9hdCBtYXggPSBmbG9hdCgke2V9KTtcXG5cXG4gIGZsb2F0ICR7bn1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIGNsYW1wKGEsIG1pbiwgbWF4KTtcXG4gIH1cXG4gIHZlYzQgJHtufV8odmVjNCB2KSB7XFxuICAgIHJldHVybiBjbGFtcCh2LCBtaW4sIG1heCk7XFxuICB9XFxuICBgLG5hbWU6bix0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIHkoKXtjb25zdCB0PVwiaW5kZW50aXR5XCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gYTtcXG4gIH1cXG4gIHZlYzQgJHt0fV8odmVjNCB2KSB7XFxuICAgIHJldHVybiB2O1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBfKHQpe2NvbnN0IGU9XCJsZWFreVJlbHVcIjtyZXR1cm57Ym9keTpgXFxuICBjb25zdCBmbG9hdCBhbHBoYSA9IGZsb2F0KCR7dH0pO1xcblxcbiAgZmxvYXQgJHtlfV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gYSA8IDAuMCA/IGEgKiBhbHBoYSA6IGE7XFxuICB9XFxuICB2ZWM0ICR7ZX1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gdmVjNCgke2V9Xyh2LngpLCAke2V9Xyh2LnkpLCAke2V9Xyh2LnopLCAke2V9Xyh2LncpKTtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gdigpe3JldHVybiBQKFwibG9nXCIpfWZ1bmN0aW9uIHcoKXtjb25zdCB0PVwibmVnXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gLWE7XFxuICB9XFxuICB2ZWM0ICR7dH1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gLXY7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIHgoKXtjb25zdCB0PVwibm90XCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gZmxvYXQoICEgYm9vbChhKSApO1xcbiAgfVxcbiAgYm9vbCAke3R9Xyhib29sIGEpIHtcXG4gICAgcmV0dXJuICFhO1xcbiAgfVxcbiAgdmVjNCAke3R9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIHZlYzQoIWJvb2wodi54KSwgIWJvb2wodi55KSwgIWJvb2wodi56KSwgIWJvb2wodi53KSk7XFxuICB9XFxuICBidmVjNCAke3R9XyhidmVjNCB2KSB7XFxuICAgIHJldHVybiBidmVjNCghdi54LCAhdi55LCAhdi56LCAhdi53KTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gVCgpe3JldHVybiBQKFwic2luXCIpfWZ1bmN0aW9uIFMoKXtjb25zdCB0PVwicmVsdVwiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIG1heCggYSwgMC4wICk7XFxuICB9XFxuICB2ZWM0ICR7dH1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gbWF4KCB2LCAwLjAgKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gTygpe2NvbnN0IHQ9XCJzaWdtb2lkXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtYSkpO1xcbiAgfVxcbiAgdmVjNCAke3R9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIDEuMCAvICgxLjAgKyBleHAoLXYpKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gQSgpe3JldHVybiBQKFwic3FydFwiKX1mdW5jdGlvbiBFKCl7cmV0dXJuIFAoXCJ0YW5cIil9ZnVuY3Rpb24gSSgpe2NvbnN0IHQ9XCJ0YW5oXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICBhID0gY2xhbXAoYSwgLTEwLiwgMTAuKTtcXG4gICAgYSA9IGV4cCgyLiphKTtcXG4gICAgcmV0dXJuIChhIC0gMS4pIC8gKGEgKyAxLik7XFxuICB9XFxuICB2ZWM0ICR7dH1fKHZlYzQgdikge1xcbiAgICB2ID0gY2xhbXAodiwgLTEwLiwgMTAuKTtcXG4gICAgdiA9IGV4cCgyLip2KTtcXG4gICAgcmV0dXJuICh2IC0gMS4pIC8gKHYgKyAxLik7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIFAodCl7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gJHt0fShhKTtcXG4gIH1cXG4gIHZlYzQgJHt0fV8odmVjNCB2KSB7XFxuICAgIHJldHVybiAke3R9KHYpO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1lLmdsc2xBYnM9dSxlLmdsc2xBY29zPWMsZS5nbHNsQXNpbj1sLGUuZ2xzbEF0YW49cCxlLmdsc2xDZWlsPWYsZS5nbHNsQ29zPWQsZS5nbHNsRWx1PWgsZS5nbHNsRXhwPWcsZS5nbHNsRmxvb3I9YixlLmdsc2xDbGlwPW0sZS5nbHNsSWRlbnRpdHk9eSxlLmdsc2xMZWFreVJlbHU9XyxlLmdsc2xMb2c9dixlLmdsc2xOZWc9dyxlLmdsc2xOb3Q9eCxlLmdsc2xTaW49VCxlLmdsc2xSZWx1PVMsZS5nbHNsU2lnbW9pZD1PLGUuZ2xzbFNxcnQ9QSxlLmdsc2xUYW49RSxlLmdsc2xUYW5oPUk7Y29uc3QgRD0odCxlLG4scik9Pntjb25zdCBpPXQuc2Vzc2lvbi5wYWNrP3MuVGV4dHVyZVR5cGUucGFja2VkOnMuVGV4dHVyZVR5cGUudW5wYWNrZWQsbz17bmFtZTpuLm5hbWUsaW5wdXRUeXBlczpbaV0saW5wdXROYW1lczpbXCJBXCJdLGNhY2hlSGludDpyfTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG8pLHtnZXQ6KCk9PigodCxlLG4scik9Pntjb25zdCBpPXQuc2Vzc2lvbi5wYWNrP3MuVGV4dHVyZVR5cGUucGFja2VkOnMuVGV4dHVyZVR5cGUudW5wYWNrZWQsbz0oMCxhLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6bi5kaW1zLHR5cGU6bi50eXBlLHRleHR1cmVUeXBlOml9LHNoYWRlclNvdXJjZTpgXFxuICAgICAke3IuYm9keX1cXG4gICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgdmVjNCB2ID0gJHtvLnRleHR1cmUyRH0oQSwgVGV4Q29vcmRzKTtcXG4gICAgICAgdiA9ICR7ci5uYW1lfV8odik7XFxuICAgICAgICR7by5vdXRwdXR9ID0gdjtcXG4gICAgIH1cXG4gICAgIGAsaGFzTWFpbjohMH0pfSkodCxvLGUsbil9KX07ZS5hYnM9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSx1KCkpLGUpXSxlLmFjb3M9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxjKCkpLGUpXSxlLmFzaW49KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxsKCkpLGUpXSxlLmF0YW49KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxwKCkpLGUpXSxlLmNsaXA9KHQsZSxuKT0+W3QucnVuKEQodCxlWzBdLG0obi5taW4sbi5tYXgpLG4uY2FjaGVLZXkpLGUpXSxlLnBhcnNlQ2xpcEF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHttaW46dC5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibWluXCIsaS5NSU5fQ0xJUCksbWF4OnQuYXR0cmlidXRlcy5nZXRGbG9hdChcIm1heFwiLGkuTUFYX0NMSVApfSksZS5jbGlwVjExPSh0LG4pPT57Y29uc3Qgcj0kKHQsbik7cmV0dXJuKDAsZS5jbGlwKSh0LFtuWzBdXSxyKX07Y29uc3QgJD0odCxlKT0+e2lmKGUubGVuZ3RoPj0zJiYoIXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMV0uZGF0YUlkKXx8IXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMl0uZGF0YUlkKSkpdGhyb3cgbmV3IEVycm9yKFwiZHluYW1pYyBjbGlwIGF0dHJpYnV0ZXMgYXJlIG5vdCBhbGxvd2VkXCIpO2NvbnN0IG49ZS5sZW5ndGg+PTM/ZVsxXS5udW1iZXJEYXRhWzBdOmkuTUlOX0NMSVAsbz1lLmxlbmd0aD49Mz9lWzJdLm51bWJlckRhdGFbMF06aS5NQVhfQ0xJUDtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe21pbjpuLG1heDpvfSl9O2UuY2VpbD0odCxlKT0+W3QucnVuKEQodCxlWzBdLGYoKSksZSldLGUuY29zPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sZCgpKSxlKV0sZS5lbHU9KHQsZSxuKT0+W3QucnVuKEQodCxlWzBdLGgobi5hbHBoYSksbi5jYWNoZUtleSksZSldLGUucGFyc2VFbHVBdHRyaWJ1dGVzPXQ9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YWxwaGE6dC5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiYWxwaGFcIiwxKX0pLGUuZXhwPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sZygpKSxlKV0sZS5mbG9vcj0odCxlKT0+W3QucnVuKEQodCxlWzBdLGIoKSksZSldLGUuaWRlbnRpdHk9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSx5KCkpLGUpXSxlLmxlYWt5UmVsdT0odCxlLG4pPT5bdC5ydW4oRCh0LGVbMF0sXyhuLmFscGhhKSxuLmNhY2hlS2V5KSxlKV0sZS5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHthbHBoYTp0LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJhbHBoYVwiLC4wMSl9KSxlLmxvZz0odCxlKT0+W3QucnVuKEQodCxlWzBdLHYoKSksZSldLGUubmVnPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sdygpKSxlKV0sZS5ub3Q9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSx4KCkpLGUpXSxlLnJlbHU9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxTKCkpLGUpXSxlLnNpZ21vaWQ9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxPKCkpLGUpXSxlLnNpbj0odCxlKT0+W3QucnVuKEQodCxlWzBdLFQoKSksZSldLGUuc3FydD0odCxlKT0+W3QucnVuKEQodCxlWzBdLEEoKSksZSldLGUudGFuPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sRSgpKSxlKV0sZS50YW5oPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sSSgpKSxlKV19LDU2MTE6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm9Mb2FkZXI9ZS5jcmVhdGVVbnBhY2tQcm9ncmFtSW5mbz12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KSxvPW4oOTM5MCksYT1uKDI4MjcpLHM9e25hbWU6XCJ1bnBhY2tcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS5wYWNrZWRdfTtlLmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvPSh0LGUpPT57Y29uc3Qgbj1lLmRpbXMubGVuZ3RoLHU9KDAsYS5nZXRDaGFubmVscykoXCJyY1wiLG4pLGM9dS5zbGljZSgtMiksbD0oMCxvLmdldENvb3Jkc0RhdGFUeXBlKShuKSxwPSgwLGEudW5wYWNrRnJvbUNoYW5uZWwpKCksZj0wPT09ZS5kaW1zLmxlbmd0aD9cIlwiOmZ1bmN0aW9uKHQsZSl7aWYoMT09PXQpcmV0dXJuXCJyY1wiO2xldCBuPVwiXCI7Zm9yKGxldCByPTA7cjx0O3IrKyluKz1lW3JdLHI8dC0xJiYobis9XCIsXCIpO3JldHVybiBufShuLHUpLGQ9bjw9MT9cInJjXCI6YHZlYzIoJHtjLmpvaW4oXCIsXCIpfSlgLGg9YFxcbiAgICAke3B9XFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAke2x9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgIC8vIFNhbXBsZSB0aGUgdGV4dHVyZSB3aXRoIHRoZSBjb29yZHMgdG8gZ2V0IHRoZSByZ2JhIGNoYW5uZWwgdmFsdWUuXFxuICAgICAgIHZlYzQgcGFja2VkSW5wdXQgPSBnZXRBKCR7Zn0pO1xcblxcbiAgICAgICAkeygwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLm91dHB1dH0gPSB2ZWM0KGdldENoYW5uZWwocGFja2VkSW5wdXQsICR7ZH0pLCAwLCAwLCAwKTtcXG4gICAgIH1cXG4gICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2hhc01haW46ITAsb3V0cHV0OntkaW1zOmUuZGltcyx0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6aH0pfSxlLmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyPSh0LG4pPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2dldDooKT0+KDAsZS5jcmVhdGVVbnBhY2tQcm9ncmFtSW5mbykodCxuKX0pfSw4NDI4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlVW5zcXVlZXplQXR0cmlidXRlcz1lLnVuc3F1ZWV6ZVYxMz1lLnVuc3F1ZWV6ZT12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpO2UudW5zcXVlZXplPSh0LGUsbik9PntpKGUpO2NvbnN0IG89ci5TaGFwZVV0aWwudW5zcXVlZXplU2hhcGUoZVswXS5kaW1zLG4pO3JldHVyblt0LnJlc2hhcGVVbnBhY2tlZChlWzBdLG8pXX0sZS51bnNxdWVlemVWMTM9KHQsbik9PihvKG4pLCgwLGUudW5zcXVlZXplKSh0LFtuWzBdXSxBcnJheS5mcm9tKG5bMV0uaW50ZWdlckRhdGEpKSksZS5wYXJzZVVuc3F1ZWV6ZUF0dHJpYnV0ZXM9dD0+dC5hdHRyaWJ1dGVzLmdldEludHMoXCJheGVzXCIpO2NvbnN0IGk9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVW5zcXVlZXplIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSxvPXQ9PntpZighdHx8MiE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlVuc3F1ZWV6ZSByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoXCJpbnQzMlwiIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSw5NzkzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNjYWxlc1ZhbGlkYXRpb249ZS52YWxpZGF0ZUlucHV0cz1lLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzPWUucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWOT1lLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzVjc9ZS51cHNhbXBsZT12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDUwNjApLG89bigyMDM5KSxhPXtuYW1lOlwiVXBzYW1wbGVcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UudXBzYW1wbGU9KHQsbixyKT0+KCgwLGUudmFsaWRhdGVJbnB1dHMpKG4sciksW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx7Y2FjaGVIaW50OnIuY2FjaGVLZXksZ2V0OigpPT5zKHQsbixyKX0pLG4pXSksZS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3PXQ9PigwLGUucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKHQsNyksZS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y5PXQ9PigwLGUucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKHQsOSksZS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlcz0odCxuKT0+e2NvbnN0IGk9bj49MTAsbz10LmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwibW9kZVwiLFwibmVhcmVzdFwiKTtpZihcIm5lYXJlc3RcIiE9PW8mJlwibGluZWFyXCIhPT1vJiYobjwxMXx8XCJjdWJpY1wiIT09bykpdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgbW9kZTogJHtvfWApO2xldCBhPVtdO248OSYmKGE9dC5hdHRyaWJ1dGVzLmdldEZsb2F0cyhcInNjYWxlc1wiKSwoMCxlLnNjYWxlc1ZhbGlkYXRpb24pKGEsbyxpKSk7Y29uc3Qgcz10LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJleHRyYXBvbGF0aW9uX3ZhbHVlXCIsMCksdT1uPjEwP3QuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJjb29yZGluYXRlX3RyYW5zZm9ybWF0aW9uX21vZGVcIixcImhhbGZfcGl4ZWxcIik6XCJhc3ltbWV0cmljXCI7aWYoLTE9PT1bXCJhc3ltbWV0cmljXCIsXCJweXRvcmNoX2hhbGZfcGl4ZWxcIixcInRmX2hhbGZfcGl4ZWxfZm9yX25uXCIsXCJhbGlnbl9jb3JuZXJzXCIsXCJ0Zl9jcm9wX2FuZF9yZXNpemVcIixcImhhbGZfcGl4ZWxcIl0uaW5kZXhPZih1KSl0aHJvdyBuZXcgRXJyb3IoYGNvb3JkaW5hdGVfdHJhbnNmb3JtX21vZGUgJyR7dX0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtjb25zdCBjPVwidGZfY3JvcF9hbmRfcmVzaXplXCI9PT11LGw9YyxwPVwibmVhcmVzdFwiPT09byYmbj49MTE/dC5hdHRyaWJ1dGVzLmdldFN0cmluZyhcIm5lYXJlc3RfbW9kZVwiLFwicm91bmRfcHJlZmVyX2Zsb29yXCIpOlwiXCI7aWYoLTE9PT1bXCJyb3VuZF9wcmVmZXJfZmxvb3JcIixcInJvdW5kX3ByZWZlcl9jZWlsXCIsXCJmbG9vclwiLFwiY2VpbFwiLFwiXCJdLmluZGV4T2YocCkpdGhyb3cgbmV3IEVycm9yKGBuZWFyZXN0X21vZGUgJyR7cH0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtjb25zdCBmPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcImN1YmljX2NvZWZmX2FcIiwtLjc1KSxkPTAhPT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwiZXhjbHVkZV9vdXRzaWRlXCIsMCk7aWYoZCYmXCJjdWJpY1wiIT09byl0aHJvdyBuZXcgRXJyb3IoXCJleGNsdWRlX291dHNpZGUgY2FuIGJlIHNldCB0byAxIG9ubHkgd2hlbiBtb2RlIGlzIENVQklDLlwiKTtjb25zdCBoPW48MTF8fFwibmVhcmVzdFwiPT09byYmXCJhc3ltbWV0cmljXCI9PT11JiZcImZsb29yXCI9PT1wO2xldCBnPTAsYj0wLG09MDtyZXR1cm4gbj4xMD90LmlucHV0cy5sZW5ndGg+Mj8oZz0xLGI9MixtPTMpOihiPTEsbT0yKTo5PT09biYmKGI9MSksKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtvcHNldDpuLGlzUmVzaXplOmksbW9kZTpvLHNjYWxlczphLGV4dHJhcG9sYXRpb25WYWx1ZTpzLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOnUsdXNlRXh0cmFwb2xhdGlvbjpsLG5lZWRSb2lJbnB1dDpjLG5lYXJlc3RNb2RlOnAsY3ViaWNDb2VmZmljaWVudEE6ZixleGNsdWRlT3V0c2lkZTpkLHVzZU5lYXJlc3QyeE9wdGltaXphdGlvbjpoLHJvaUlucHV0SWR4Omcsc2NhbGVzSW5wdXRJZHg6YixzaXplc0lucHV0SWR4Om19KX07Y29uc3Qgcz0odCxlLG4pPT57Y29uc3Qgcj0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxbcyx1XT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlWzBdLmRpbXMsby5UZXh0dXJlVHlwZS51bnBhY2tlZCksYz1lWzBdLmRpbXMubWFwKCgodCxlKT0+TWF0aC5mbG9vcih0Km4uc2NhbGVzW2VdKSkpLFtsLHBdPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGMsby5UZXh0dXJlVHlwZS51bnBhY2tlZCksZj1jLmxlbmd0aCxkPW5ldyBBcnJheShmKSxoPW5ldyBBcnJheShmKTtsZXQgZz1gXFxuICAgICAgaW50IG91dHB1dF9waXRjaGVzWyR7Zn1dO1xcbiAgICAgIGludCBpbnB1dF9waXRjaGVzWyR7Zn1dO1xcbiAgICAgIGA7Zm9yKGxldCB0PWYtMTt0Pj0wO3QtLSlkW3RdPXQ9PT1mLTE/MTpkW3QrMV0qY1t0KzFdLGhbdF09dD09PWYtMT8xOmhbdCsxXSplWzBdLmRpbXNbdCsxXSxnKz1gXFxuICAgICAgICBvdXRwdXRfcGl0Y2hlc1ske3R9XSA9ICR7ZFt0XX07XFxuICAgICAgICBpbnB1dF9waXRjaGVzWyR7dH1dID0gJHtoW3RdfTtcXG4gICAgICAgIGA7Y29uc3QgYj1gXFxuICAgICAgZmxvYXQgZ2V0SW5wdXRGbG9hdChpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMoaW5kZXgsICR7c30sICR7dX0pO1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oWCwgY29vcmRzKSk7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGAsbT1cIm5lYXJlc3RcIj09PW4ubW9kZT9gXFxuICAgICR7Yn1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2Z9XSkge1xcbiAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XFxuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtsfSwgJHtwfSk7XFxuXFxuICAgICAgJHtnfVxcblxcbiAgICAgIGludCBkLCBtO1xcbiAgICAgIGZvciAoaW50IGRpbSA9IDA7IGRpbSA8ICR7Zn07ICsrZGltKSB7XFxuICAgICAgICBkID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbZGltXTtcXG4gICAgICAgIG0gPSBvdXRwdXRfaW5kZXggLSBkICogb3V0cHV0X3BpdGNoZXNbZGltXTtcXG4gICAgICAgIG91dHB1dF9pbmRleCA9IG07XFxuXFxuICAgICAgICBpZiAoc2NhbGVzW2RpbV0gIT0gMSAmJiBkID4gMCkge1xcbiAgICAgICAgICBpbnQgZDIgPSBkIC8gc2NhbGVzW2RpbV07XFxuICAgICAgICAgIG0gPSBkIC0gZDIgKiBzY2FsZXNbZGltXTtcXG4gICAgICAgICAgZCA9IGQyO1xcbiAgICAgICAgfVxcbiAgICAgICAgaW5wdXRfaW5kZXggKz0gaW5wdXRfcGl0Y2hlc1tkaW1dICogZDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXgpO1xcbiAgICB9YDo0PT09Zj9gXFxuICAgICR7Yn1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1s0XSkge1xcbiAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XFxuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtsfSwgJHtwfSk7XFxuXFxuICAgICAgJHtnfVxcblxcbiAgICAgIGludCBtO1xcbiAgICAgIGludCBpbmRleF9vZl9kaW0wLCBpbmRleF9vZl9kaW0xLCBpbmRleF9vZl9kaW0yLCBpbmRleF9vZl9kaW0zO1xcbiAgICAgIGluZGV4X29mX2RpbTAgPSBvdXRwdXRfaW5kZXggLyBvdXRwdXRfcGl0Y2hlc1swXTtcXG4gICAgICBtID0gb3V0cHV0X2luZGV4IC0gaW5kZXhfb2ZfZGltMCAqIG91dHB1dF9waXRjaGVzWzBdO1xcbiAgICAgIGluZGV4X29mX2RpbTEgPSBtIC8gb3V0cHV0X3BpdGNoZXNbMV07XFxuICAgICAgbSA9IG0gLSBpbmRleF9vZl9kaW0xICogb3V0cHV0X3BpdGNoZXNbMV07XFxuICAgICAgaW5kZXhfb2ZfZGltMiA9IG0gLyBvdXRwdXRfcGl0Y2hlc1syXTtcXG4gICAgICBtID0gbSAtIGluZGV4X29mX2RpbTIgKiBvdXRwdXRfcGl0Y2hlc1syXTtcXG4gICAgICBpbmRleF9vZl9kaW0zID0gbTtcXG5cXG4gICAgICBpbnQgaW5kZXhfb2ZfaW5wdXRfZGltMiwgaW5kZXhfb2ZfaW5wdXRfZGltMywgeF9vZmZzZXQsIHlfb2Zmc2V0O1xcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTIgPSBpbmRleF9vZl9kaW0yIC8gc2NhbGVzWzJdO1xcbiAgICAgIHlfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMiAtIGluZGV4X29mX2lucHV0X2RpbTIgKiBzY2FsZXNbMl07XFxuICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMyA9IGluZGV4X29mX2RpbTMgLyBzY2FsZXNbM107XFxuICAgICAgeF9vZmZzZXQgPSBpbmRleF9vZl9kaW0zIC0gaW5kZXhfb2ZfaW5wdXRfZGltMyAqIHNjYWxlc1szXTtcXG5cXG4gICAgICBpbnB1dF9pbmRleCA9IGluZGV4X29mX2RpbTAgKiBpbnB1dF9waXRjaGVzWzBdICtcXG4gICAgICAgICAgICBpbmRleF9vZl9kaW0xICogaW5wdXRfcGl0Y2hlc1sxXSArXFxuICAgICAgICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMiAqIGlucHV0X3BpdGNoZXNbMl0gK1xcbiAgICAgICAgICAgIGluZGV4X29mX2lucHV0X2RpbTM7XFxuXFxuICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XFxuICAgICAgZmxvYXQgeDEwLCB4MDEsIHgxMTtcXG5cXG4gICAgICBib29sIGVuZF9vZl9kaW0yID0gZmFsc2U7XFxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTIgPT0gKCR7ZVswXS5kaW1zWzJdfSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDJcXG4gICAgICAgIHgwMSA9IHgwMDtcXG4gICAgICAgIGVuZF9vZl9kaW0yID0gdHJ1ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgeDAxID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMl0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMyA9PSAoaW5wdXRfcGl0Y2hlc1syXSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDNcXG4gICAgICAgIHgxMCA9IHgwMDtcXG4gICAgICAgIHgxMSA9IHgwMTtcXG4gICAgICB9XFxuICAgICAgZWxzZSB7XFxuICAgICAgICB4MTAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgMSk7XFxuICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMiA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzJdICsgMSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xcbiAgICAgIGZsb2F0IHkxID0geDEwICsgZmxvYXQoeV9vZmZzZXQpICogKHgxMSAtIHgxMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xcbiAgICAgIHJldHVybiB5MCArIGZsb2F0KHhfb2Zmc2V0KSAqICh5MSAtIHkwKSAvIGZsb2F0KHNjYWxlc1szXSk7XFxuICAgIH1gOmBcXG4gICAgJHtifVxcbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWzJdKSB7XFxuICAgICAgaW50IGlucHV0X2luZGV4ID0gMDtcXG4gICAgICBpbnQgb3V0cHV0X2luZGV4ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke2x9LCAke3B9KTtcXG5cXG4gICAgICAke2d9XFxuXFxuICAgICAgaW50IG07XFxuICAgICAgaW50IGluZGV4X29mX2RpbTAsIGluZGV4X29mX2RpbTE7XFxuICAgICAgaW5kZXhfb2ZfZGltMCA9IG91dHB1dF9pbmRleCAvIG91dHB1dF9waXRjaGVzWzBdO1xcbiAgICAgIG0gPSBvdXRwdXRfaW5kZXggLSBpbmRleF9vZl9kaW0wICogb3V0cHV0X3BpdGNoZXNbMF07XFxuICAgICAgaW5kZXhfb2ZfZGltMSA9IG07XFxuXFxuICAgICAgaW50IGluZGV4X29mX2lucHV0X2RpbTAsIGluZGV4X29mX2lucHV0X2RpbTEsIHhfb2Zmc2V0LCB5X29mZnNldDtcXG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0wID0gaW5kZXhfb2ZfZGltMCAvIHNjYWxlc1swXTtcXG4gICAgICB5X29mZnNldCA9IGluZGV4X29mX2RpbTAgLSBpbmRleF9vZl9pbnB1dF9kaW0wICogc2NhbGVzWzBdO1xcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTEgPSBpbmRleF9vZl9kaW0xIC8gc2NhbGVzWzFdO1xcbiAgICAgIHhfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMSAtIGluZGV4X29mX2lucHV0X2RpbTEgKiBzY2FsZXNbMV07XFxuXFxuICAgICAgaW5wdXRfaW5kZXggPSBpbmRleF9vZl9pbnB1dF9kaW0wICogaW5wdXRfcGl0Y2hlc1swXSArIGluZGV4X29mX2lucHV0X2RpbTE7XFxuXFxuICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XFxuICAgICAgZmxvYXQgeDEwLCB4MDEsIHgxMTtcXG5cXG4gICAgICBib29sIGVuZF9vZl9kaW0wID0gZmFsc2U7XFxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTAgPT0gKCR7ZVswXS5kaW1zWzBdfSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDBcXG4gICAgICAgIHgwMSA9IHgwMDtcXG4gICAgICAgIGVuZF9vZl9kaW0wID0gdHJ1ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgeDAxID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMF0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMSA9PSAoaW5wdXRfcGl0Y2hlc1swXSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDFcXG4gICAgICAgIHgxMCA9IHgwMDtcXG4gICAgICAgIHgxMSA9IHgwMTtcXG4gICAgICB9XFxuICAgICAgZWxzZSB7XFxuICAgICAgICB4MTAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgMSk7XFxuICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMCA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzBdICsgMSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xcbiAgICAgIGZsb2F0IHkxID0geDEwICsgZmxvYXQoeV9vZmZzZXQpICogKHgxMSAtIHgxMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xcbiAgICAgIHJldHVybiB5MCArIGZsb2F0KHhfb2Zmc2V0KSAqICh5MSAtIHkwKSAvIGZsb2F0KHNjYWxlc1sxXSk7XFxuICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse291dHB1dDp7ZGltczpjLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTptLHZhcmlhYmxlczpbe25hbWU6XCJzY2FsZXNcIix0eXBlOlwiaW50XCIsYXJyYXlMZW5ndGg6bi5zY2FsZXMubGVuZ3RoLGRhdGE6bi5zY2FsZXMubWFwKCh0PT5NYXRoLmNlaWwodCkpKX1dfSl9O2UudmFsaWRhdGVJbnB1dHM9KHQsZSk9PntpZighdHx8ZS5vcHNldDw5JiYxIT09dC5sZW5ndGh8fGUub3BzZXQ+PTkmJmUub3BzZXQ8MTEmJjIhPT10Lmxlbmd0aHx8ZS5vcHNldD49MTEmJnQubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dHMuXCIpO2lmKGUuc2NhbGVzLmxlbmd0aD4wJiZ0WzBdLmRpbXMubGVuZ3RoIT09ZS5zY2FsZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSxlLnNjYWxlc1ZhbGlkYXRpb249KHQsZSxuKT0+e2lmKG4pe2Zvcihjb25zdCBlIG9mIHQpaWYoZTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJTY2FsZSB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDAuXCIpfWVsc2UgZm9yKGNvbnN0IGUgb2YgdClpZihlPDEpdGhyb3cgbmV3IEVycm9yKFwiU2NhbGUgdmFsdWUgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLlwiKTtpZighKFwibGluZWFyXCIhPT1lJiZcImN1YmljXCIhPT1lfHwyPT09dC5sZW5ndGh8fDQ9PT10Lmxlbmd0aCYmMT09PXRbMF0mJjE9PT10WzFdKSl0aHJvdyBuZXcgRXJyb3IoYCdMaW5lYXInIG1vZGUgYW5kICdDdWJpYycgbW9kZSBvbmx5IHN1cHBvcnQgMi1EIGlucHV0cyAoJ0JpbGluZWFyJywgJ0JpY3ViaWMnKSAgICAgICAgIG9yIDQtRCBpbnB1dHMgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBvdXRlcm1vc3QgMiBzY2FsZSB2YWx1ZXMgYmVpbmcgMSAgICAgICAgIGluIHRoZSAke24/XCJSZXNpemVcIjpcIlVwc2FtcGxlXCJ9IG9wZWFydG9yLmApfX0sMTk1ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5Qcm9ncmFtTWFuYWdlcj12b2lkIDA7Y29uc3Qgcj1uKDE2NzApLGk9big2MjMxKSxvPW4oODg3OSksYT1uKDUwNjApO2UuUHJvZ3JhbU1hbmFnZXI9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4pe3RoaXMucHJvZmlsZXI9dCx0aGlzLmdsQ29udGV4dD1lLHRoaXMudGV4dHVyZUxheW91dFN0cmF0ZWd5PW4sdGhpcy5yZXBvPW5ldyBNYXAsdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITF9Z2V0QXJ0aWZhY3QodCl7cmV0dXJuIHRoaXMucmVwby5nZXQodCl9c2V0QXJ0aWZhY3QodCxlKXt0aGlzLnJlcG8uc2V0KHQsZSl9cnVuKHQsZSxuKXt2YXIgcjt0aGlzLnByb2ZpbGVyLmV2ZW50KFwib3BcIixgUHJvZ3JhbU1hbmFnZXIucnVuICR7bnVsbCE9PShyPXQucHJvZ3JhbUluZm8ubmFtZSkmJnZvaWQgMCE9PXI/cjpcInVua25vd24ga2VybmVsXCJ9YCwoKCk9Pnt2YXIgcjtjb25zdCBvPXRoaXMuZ2xDb250ZXh0LmdsLGE9dC5wcm9ncmFtO28udXNlUHJvZ3JhbShhKTt0cnl7dGhpcy5iaW5kT3V0cHV0KG4pLHRoaXMuYXR0cmlidXRlc0JvdW5kfHx0aGlzLmJpbmRBdHRyaWJ1dGVzKHQuYXR0cmliTG9jYXRpb25zKSx0aGlzLmJpbmRVbmlmb3Jtcyh0LnVuaWZvcm1Mb2NhdGlvbnMsbnVsbCE9PShyPXQucHJvZ3JhbUluZm8udmFyaWFibGVzKSYmdm9pZCAwIT09cj9yOltdLGUpfWNhdGNoKGUpe3Rocm93IGkuTG9nZ2VyLmVycm9yKFwiUHJvZ3JhbU1hbmFnZXJcIix0LnByb2dyYW1JbmZvLnNoYWRlclNvdXJjZSksZX10aGlzLnByb2ZpbGVyLmV2ZW50KFwiYmFja2VuZFwiLFwiR2xDb250ZXh0LmRyYXcoKVwiLCgoKT0+e3RoaXMuZ2xDb250ZXh0LmRyYXcoKX0pKX0pLHRoaXMuZ2xDb250ZXh0KX1kaXNwb3NlKCl7dGhpcy52ZXJ0ZXhTaGFkZXImJnRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRleFNoYWRlciksdGhpcy5yZXBvLmZvckVhY2goKHQ9PnRoaXMuZ2xDb250ZXh0LmRlbGV0ZVByb2dyYW0odC5wcm9ncmFtKSkpfWJ1aWxkKHQsZSxuKXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlByb2dyYW1NYW5hZ2VyLmJ1aWxkXCIsKCgpPT57Y29uc3Qgcj1uZXcgby5HbHNsUHJlcHJvY2Vzc29yKHRoaXMuZ2xDb250ZXh0LHQsZSxuKSxpPXIucHJlcHJvY2VzcygpLGE9dGhpcy5jb21waWxlKGkpO3JldHVybntwcm9ncmFtSW5mbzp0LHByb2dyYW06YSx1bmlmb3JtTG9jYXRpb25zOnRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9ucyhhLHIuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLHIuY29udGV4dC5wcm9ncmFtSW5mby52YXJpYWJsZXMpLGF0dHJpYkxvY2F0aW9uczp0aGlzLmdldEF0dHJpYkxvY2F0aW9ucyhhKX19KSl9Y29tcGlsZSh0KXtpZighdGhpcy52ZXJ0ZXhTaGFkZXIpe2kuTG9nZ2VyLnZlcmJvc2UoXCJQcm9yZ3JhbU1hbmFnZXJcIixcIkNvbXBpbGluZyBhbmQgY2FjaGluZyBWZXJ0ZXggc2hhZGVyIGZvciB0aGUgZmlyc3QgdGltZVwiKTtjb25zdCB0PSgwLGEuZ2V0VmVydGV4U2hhZGVyU291cmNlKSh0aGlzLmdsQ29udGV4dC52ZXJzaW9uKTt0aGlzLnZlcnRleFNoYWRlcj10aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKHQsdGhpcy5nbENvbnRleHQuZ2wuVkVSVEVYX1NIQURFUil9ci5lbnYuZGVidWcmJmkuTG9nZ2VyLnZlcmJvc2UoXCJQcm9yZ3JhbU1hbmFnZXJcIixgRnJhZ1NoYWRlcjpcXG4ke3R9XFxuYCk7Y29uc3QgZT10aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKHQsdGhpcy5nbENvbnRleHQuZ2wuRlJBR01FTlRfU0hBREVSKSxuPXRoaXMuZ2xDb250ZXh0LmNyZWF0ZVByb2dyYW0odGhpcy52ZXJ0ZXhTaGFkZXIsZSk7cmV0dXJuIHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcihlKSxufWJpbmRPdXRwdXQodCl7Y29uc3QgZT10LndpZHRoLG49dC5oZWlnaHQ7aS5Mb2dnZXIudmVyYm9zZShcIlByb3JncmFtTWFuYWdlclwiLGBCaW5kaW5nIG91dHB1dCB0ZXh0dXJlIHRvIEZyYW1lYnVmZmVyOiB3L2g9JHtlfS8ke259LCBzaGFwZT0ke3Quc2hhcGV9LCB0eXBlPSR7dC50ZW5zb3IudHlwZX1gKSx0aGlzLmdsQ29udGV4dC5hdHRhY2hGcmFtZWJ1ZmZlcih0LnRleHR1cmUsZSxuKX1iaW5kQXR0cmlidXRlcyh0KXtjb25zdCBlPXQucG9zaXRpb24sbj10LnRleHR1cmVDb29yZDt0aGlzLmdsQ29udGV4dC5zZXRWZXJ0ZXhBdHRyaWJ1dGVzKGUsbiksdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITB9YmluZFVuaWZvcm1zKHQsZSxuKXt2YXIgcjtjb25zdCBpPXRoaXMuZ2xDb250ZXh0LmdsO2xldCBvPTA7Zm9yKGNvbnN0e25hbWU6YSx0eXBlOnMsbG9jYXRpb246dSxhcnJheUxlbmd0aDpjfW9mIHQpe2NvbnN0IHQ9bnVsbD09PShyPWUuZmluZCgodD0+dC5uYW1lPT09YSkpKXx8dm9pZCAwPT09cj92b2lkIDA6ci5kYXRhO2lmKFwic2FtcGxlcjJEXCIhPT1zJiYhdCl0aHJvdyBuZXcgRXJyb3IoYHZhcmlhYmxlICcke2F9JyBkb2VzIG5vdCBoYXZlIGRhdGEgZGVmaW5lZCBpbiBwcm9ncmFtIGluZm9gKTtzd2l0Y2gocyl7Y2FzZVwic2FtcGxlcjJEXCI6dGhpcy5iaW5kVGV4dHVyZShuW29dLHUsbyksbysrO2JyZWFrO2Nhc2VcImZsb2F0XCI6Yz9pLnVuaWZvcm0xZnYodSx0KTppLnVuaWZvcm0xZih1LHQpO2JyZWFrO2Nhc2VcImludFwiOmM/aS51bmlmb3JtMWl2KHUsdCk6aS51bmlmb3JtMWkodSx0KTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5pZm9ybSBub3QgaW1wbGVtZW50ZWQ6ICR7c31gKX19fWJpbmRUZXh0dXJlKHQsZSxuKXt0aGlzLmdsQ29udGV4dC5iaW5kVGV4dHVyZVRvVW5pZm9ybSh0LnRleHR1cmUsbixlKX1nZXRBdHRyaWJMb2NhdGlvbnModCl7cmV0dXJue3Bvc2l0aW9uOnRoaXMuZ2V0QXR0cmliTG9jYXRpb24odCxcInBvc2l0aW9uXCIpLHRleHR1cmVDb29yZDp0aGlzLmdldEF0dHJpYkxvY2F0aW9uKHQsXCJ0ZXh0dXJlQ29vcmRcIil9fWdldFVuaWZvcm1Mb2NhdGlvbnModCxlLG4pe2NvbnN0IHI9W107aWYoZSlmb3IoY29uc3QgbiBvZiBlKXIucHVzaCh7bmFtZTpuLHR5cGU6XCJzYW1wbGVyMkRcIixsb2NhdGlvbjp0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbih0LG4pfSk7aWYobilmb3IoY29uc3QgZSBvZiBuKXIucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse2xvY2F0aW9uOnRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHQsZS5uYW1lKX0pKTtyZXR1cm4gcn1nZXRVbmlmb3JtTG9jYXRpb24odCxlKXtjb25zdCBuPXRoaXMuZ2xDb250ZXh0LmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0LGUpO2lmKG51bGw9PT1uKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSAke2V9IG5vdCBmb3VuZC5gKTtyZXR1cm4gbn1nZXRBdHRyaWJMb2NhdGlvbih0LGUpe3JldHVybiB0aGlzLmdsQ29udGV4dC5nbC5nZXRBdHRyaWJMb2NhdGlvbih0LGUpfX19LDY0MTY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuV2ViR0xTZXNzaW9uSGFuZGxlcj12b2lkIDA7Y29uc3Qgcj1uKDYyMzEpLGk9bigxMDQ3KSxvPW4oODMxNiksYT1uKDE2NDApLHM9bigxOTU4KSx1PW4oNzg1OSksYz1uKDU3MDIpO2UuV2ViR0xTZXNzaW9uSGFuZGxlcj1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuYmFja2VuZD10LHRoaXMuY29udGV4dD1lLHRoaXMubGF5b3V0U3RyYXRlZ3k9bmV3IHUuUHJlZmVyTG9naWNhbFN0cmF0ZWd5KHQuZ2xDb250ZXh0Lm1heFRleHR1cmVTaXplKSx0aGlzLnByb2dyYW1NYW5hZ2VyPW5ldyBzLlByb2dyYW1NYW5hZ2VyKHRoaXMuY29udGV4dC5wcm9maWxlcix0LmdsQ29udGV4dCx0aGlzLmxheW91dFN0cmF0ZWd5KSx0aGlzLnRleHR1cmVNYW5hZ2VyPW5ldyBjLlRleHR1cmVNYW5hZ2VyKHQuZ2xDb250ZXh0LHRoaXMubGF5b3V0U3RyYXRlZ3ksdGhpcy5jb250ZXh0LnByb2ZpbGVyLHtyZXVzZVRleHR1cmVzOlwiZnVsbFwiPT09dC50ZXh0dXJlQ2FjaGVNb2RlfSksdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXAsdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnBhY2s9dC5wYWNrLHRoaXMucGFjazJ1bnBhY2tNYXA9bmV3IE1hcCx0aGlzLnVucGFjazJwYWNrTWFwPW5ldyBNYXB9Y3JlYXRlSW5mZXJlbmNlSGFuZGxlcigpe3JldHVybiBuZXcgby5XZWJHTEluZmVyZW5jZUhhbmRsZXIodGhpcyl9b25HcmFwaEluaXRpYWxpemVkKHQpe2NvbnN0IGU9dC5nZXRWYWx1ZXMoKS5maWx0ZXIoKHQ9Pi0xPT09dC5mcm9tJiZ0LnRlbnNvcikpLm1hcCgodD0+dC50ZW5zb3IuZGF0YUlkKSk7dGhpcy5pbml0aWFsaXplcnM9bmV3IFNldChlKX1pc0luaXRpYWxpemVyKHQpe3JldHVybiEhdGhpcy5pbml0aWFsaXplcnMmJnRoaXMuaW5pdGlhbGl6ZXJzLmhhcyh0KX1hZGRJbml0aWFsaXplcih0KXt0aGlzLmluaXRpYWxpemVycy5hZGQodCl9Z2V0VGV4dHVyZURhdGEodCxlKXtyZXR1cm4gZT90aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHQpOnRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldCh0KX1zZXRUZXh0dXJlRGF0YSh0LGUsbj0hMSl7ci5Mb2dnZXIudmVyYm9zZShcIldlYkdMU2Vzc2lvbkhhbmRsZXJcIixcIlN0b3JpbmcgVGV4dHVyZSBkYXRhIGluIGNhY2hlXCIpLG4/dGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLnNldCh0LGUpOnRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLnNldCh0LGUpfWRpc3Bvc2UoKXt0aGlzLnByb2dyYW1NYW5hZ2VyLmRpc3Bvc2UoKSx0aGlzLnRleHR1cmVNYW5hZ2VyLmNsZWFyQWN0aXZlVGV4dHVyZXMoKSx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCgodD0+dGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZSh0LCEwKSkpLHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwLHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2goKHQ9PnRoaXMudGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodCwhMCkpKSx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfXJlc29sdmUodCxlLG4pe2NvbnN0IHI9KDAsaS5yZXNvbHZlT3BlcmF0b3IpKHQsZSxhLldFQkdMX09QX1JFU09MVkVfUlVMRVMpO3JldHVybntpbXBsOnIub3BJbXBsLGNvbnRleHQ6ci5vcEluaXQ/ci5vcEluaXQodCxuKTp0fX19fSw3NzY5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlVpbnQ4RGF0YUVuY29kZXI9ZS5SR0JBRmxvYXREYXRhRW5jb2Rlcj1lLlJlZEZsb2F0MzJEYXRhRW5jb2Rlcj12b2lkIDA7Y29uc3Qgcj1uKDYyMzEpO2UuUmVkRmxvYXQzMkRhdGFFbmNvZGVyPWNsYXNze2NvbnN0cnVjdG9yKHQsZT0xKXtpZigxPT09ZSl0aGlzLmludGVybmFsRm9ybWF0PXQuUjMyRix0aGlzLmZvcm1hdD10LlJFRCx0aGlzLnRleHR1cmVUeXBlPXQuRkxPQVQsdGhpcy5jaGFubmVsU2l6ZT1lO2Vsc2V7aWYoNCE9PWUpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHtlfWApO3RoaXMuaW50ZXJuYWxGb3JtYXQ9dC5SR0JBMzJGLHRoaXMuZm9ybWF0PXQuUkdCQSx0aGlzLnRleHR1cmVUeXBlPXQuRkxPQVQsdGhpcy5jaGFubmVsU2l6ZT1lfX1lbmNvZGUodCxlKXtsZXQgbixpO3JldHVybiB0LmNvbnN0cnVjdG9yIT09RmxvYXQzMkFycmF5JiYoci5Mb2dnZXIud2FybmluZyhcIkVuY29kZXJcIixcImRhdGEgd2FzIG5vdCBvZiB0eXBlIEZsb2F0MzI7IGNyZWF0aW5nIG5ldyBGbG9hdDMyQXJyYXlcIiksaT1uZXcgRmxvYXQzMkFycmF5KHQpKSxlKnRoaXMuY2hhbm5lbFNpemU+dC5sZW5ndGg/KHIuTG9nZ2VyLndhcm5pbmcoXCJFbmNvZGVyXCIsXCJTb3VyY2UgZGF0YSB0b28gc21hbGwuIEFsbG9jYXRpbmcgbGFyZ2VyIGFycmF5XCIpLGk9dCxuPXRoaXMuYWxsb2NhdGUoZSp0aGlzLmNoYW5uZWxTaXplKSxpLmZvckVhY2goKCh0LGUpPT5uW2VdPXQpKSk6KGk9dCxuPWkpLG59YWxsb2NhdGUodCl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoNCp0KX1kZWNvZGUodCxlKXtyZXR1cm4gMT09PXRoaXMuY2hhbm5lbFNpemU/dC5maWx0ZXIoKCh0LGUpPT5lJTQ9PTApKS5zdWJhcnJheSgwLGUpOnQuc3ViYXJyYXkoMCxlKX19LGUuUkdCQUZsb2F0RGF0YUVuY29kZXI9Y2xhc3N7Y29uc3RydWN0b3IodCxlPTEsbil7aWYoMSE9PWUmJjQhPT1lKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7ZX1gKTt0aGlzLmludGVybmFsRm9ybWF0PXQuUkdCQSx0aGlzLmZvcm1hdD10LlJHQkEsdGhpcy5jaGFubmVsU2l6ZT1lLHRoaXMudGV4dHVyZVR5cGU9bnx8dC5GTE9BVH1lbmNvZGUodCxlKXtsZXQgbj10O3JldHVybiAxPT09dGhpcy5jaGFubmVsU2l6ZSYmKHIuTG9nZ2VyLnZlcmJvc2UoXCJFbmNvZGVyXCIsXCJFeHBsb2RpbmcgaW50byBhIGxhcmdlciBhcnJheVwiKSxuPXRoaXMuYWxsb2NhdGUoZSksdC5mb3JFYWNoKCgodCxlKT0+bls0KmVdPXQpKSksbn1hbGxvY2F0ZSh0KXtyZXR1cm4gbmV3IEZsb2F0MzJBcnJheSg0KnQpfWRlY29kZSh0LGUpe3JldHVybiAxPT09dGhpcy5jaGFubmVsU2l6ZT90LmZpbHRlcigoKHQsZSk9PmUlND09MCkpLnN1YmFycmF5KDAsZSk6dC5zdWJhcnJheSgwLGUpfX0sZS5VaW50OERhdGFFbmNvZGVyPWNsYXNze2NvbnN0cnVjdG9yKHQsZT0xKXtpZih0aGlzLmNoYW5uZWxTaXplPTQsMT09PWUpdGhpcy5pbnRlcm5hbEZvcm1hdD10LkFMUEhBLHRoaXMuZm9ybWF0PXQuQUxQSEEsdGhpcy50ZXh0dXJlVHlwZT10LlVOU0lHTkVEX0JZVEUsdGhpcy5jaGFubmVsU2l6ZT1lO2Vsc2V7aWYoNCE9PWUpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHtlfWApO3RoaXMuaW50ZXJuYWxGb3JtYXQ9dC5SR0JBLHRoaXMuZm9ybWF0PXQuUkdCQSx0aGlzLnRleHR1cmVUeXBlPXQuVU5TSUdORURfQllURSx0aGlzLmNoYW5uZWxTaXplPWV9fWVuY29kZSh0LGUpe3JldHVybiBuZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlTGVuZ3RoKX1hbGxvY2F0ZSh0KXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodCp0aGlzLmNoYW5uZWxTaXplKX1kZWNvZGUodCxlKXtpZih0IGluc3RhbmNlb2YgVWludDhBcnJheSlyZXR1cm4gdC5zdWJhcnJheSgwLGUpO3Rocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcnJheSB0eXBlOiAke3QuY29uc3RydWN0b3J9YCl9fX0sNzg1OToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5nZXRCYXRjaERpbT1lLnNpemVUb1NxdWFyaXNoU2hhcGU9ZS5nZXRSb3dzQ29scz1lLnNpemVGcm9tU2hhcGU9ZS5pc0ludD1lLnBhcnNlQXhpc1BhcmFtPWUuc3F1ZWV6ZVNoYXBlPWUuUHJlZmVyTG9naWNhbFN0cmF0ZWd5PWUuQWx3YXlzS2VlcE9yaWdpbmFsU2l6ZVN0cmF0ZWd5PXZvaWQgMDtjb25zdCByPW4oNjIzMSksaT1uKDI1MTcpO2Z1bmN0aW9uIG8odCxlKXtjb25zdCBuPVtdLHI9W10saT1udWxsIT1lJiZBcnJheS5pc0FycmF5KGUpJiYwPT09ZS5sZW5ndGgsbz1udWxsPT1lfHxpP251bGw6YShlLHQpLnNvcnQoKTtsZXQgcz0wO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7KytlKXtpZihudWxsIT1vKXtpZihvW3NdPT09ZSYmMSE9PXRbZV0pdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzcXVlZXplIGF4aXMgJHtlfSBzaW5jZSBpdHMgZGltICcke3RbZV19JyBpcyBub3QgMWApOyhudWxsPT1vW3NdfHxvW3NdPmUpJiYxPT09dFtlXSYmKG4ucHVzaCh0W2VdKSxyLnB1c2goZSkpLG9bc108PWUmJnMrK30xIT09dFtlXSYmKG4ucHVzaCh0W2VdKSxyLnB1c2goZSkpfXJldHVybntuZXdTaGFwZTpuLGtlcHREaW1zOnJ9fWZ1bmN0aW9uIGEodCxlKXtjb25zdCBuPWUubGVuZ3RoO3JldHVybiB0PW51bGw9PXQ/ZS5tYXAoKCh0LGUpPT5lKSk6W10uY29uY2F0KHQpLCgwLGkuYXNzZXJ0KSh0LmV2ZXJ5KCh0PT50Pj0tbiYmdDxuKSksKCgpPT5gQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW4gcmFuZ2UgWy0ke259LCAke259KSBidXQgZ290IGF4aXMgJHt0fWApKSwoMCxpLmFzc2VydCkodC5ldmVyeShzKSwoKCk9PmBBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbnRlZ2VycyBidXQgZ290IGF4aXMgJHt0fWApKSx0Lm1hcCgodD0+dDwwP24rdDp0KSl9ZnVuY3Rpb24gcyh0KXtyZXR1cm4gdCUxPT0wfWZ1bmN0aW9uIHUodCl7aWYoMD09PXQubGVuZ3RoKXJldHVybiAxO2xldCBlPXRbMF07Zm9yKGxldCBuPTE7bjx0Lmxlbmd0aDtuKyspZSo9dFtuXTtyZXR1cm4gZX1mdW5jdGlvbiBjKHQpe2NvbnN0IGU9TWF0aC5jZWlsKE1hdGguc3FydCh0KSk7cmV0dXJuW2UsTWF0aC5jZWlsKHQvZSldfWUuQWx3YXlzS2VlcE9yaWdpbmFsU2l6ZVN0cmF0ZWd5PWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMubWF4VGV4dHVyZVNpemU9dH1jb21wdXRlVGV4dHVyZVdIKHQsZSl7aWYoMD09PXQubGVuZ3RoKXJldHVyblsxLDFdO2NvbnN0IG49dGhpcy5tYXhUZXh0dXJlU2l6ZTtpZihlJiZ2b2lkIDAhPT1lLmJyZWFrQXhpcyl7Y29uc3QgaT1lLmJyZWFrQXhpcz49dC5sZW5ndGg/MTp0LnNsaWNlKGUuYnJlYWtBeGlzKS5yZWR1Y2UoKCh0LGUpPT50KmUpKSxvPWUuYnJlYWtBeGlzPD0wPzE6dC5zbGljZSgwLGUuYnJlYWtBeGlzKS5yZWR1Y2UoKCh0LGUpPT50KmUpKTtpZighKGk+bnx8bz5uKSlyZXR1cm5baSxvXTtyLkxvZ2dlci52ZXJib3NlKFwiVGV4dHVyZUxheW91dFwiLGBHaXZlbiB3aWR0aC9oZWlnaHQgcHJlZmVyZW5jZXMgd2VyZSB1bmF0dGFpbmFibGU6IHNoYXBlOiR7dH0sIGJyZWFrQXhpczoke2UuYnJlYWtBeGlzfWApfWNvbnN0IGk9dC5yZWR1Y2UoKCh0LGUpPT50KmUpKTtsZXQgbz1NYXRoLmZsb29yKE1hdGguc3FydChpKSk7Zm9yKDtvPG4mJm88aSYmaSVvIT0wO28rKyk7aWYobz49bnx8aSVvIT0wKXRocm93IG5ldyBFcnJvcihgVGhlIGdpdmVuIGRpbWVuc2lvbnMgYXJlIG91dHNpZGUgdGhpcyBHUFUncyBib3VuZGFyaWVzOiAke3R9YCk7cmV0dXJuW28saS9vXX19LGUuUHJlZmVyTG9naWNhbFN0cmF0ZWd5PWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMubWF4VGV4dHVyZVNpemU9dH1jb21wdXRlVGV4dHVyZVdIKHQsZSl7Y29uc3Qgbj10aGlzLmNvbXB1dGVUZXh0dXJlKHQsZSk7cmV0dXJuIGUmJmUuaXNQYWNrZWQmJihuWzBdLz0yLG5bMV0vPTIpLGUmJmUucmV2ZXJzZVdIP1tuWzFdLG5bMF1dOm59Y29tcHV0ZVRleHR1cmUodCxlKXtjb25zdCBuPWUmJmUuaXNQYWNrZWQ7aWYoMD09PXQubGVuZ3RoKXJldHVybiBuP1syLDJdOlsxLDFdO2xldCBpPXRoaXMubWF4VGV4dHVyZVNpemU7aWYoZSYmdm9pZCAwIT09ZS5icmVha0F4aXMpe2NvbnN0IG49ZS5icmVha0F4aXM+PXQubGVuZ3RoPzE6dC5zbGljZShlLmJyZWFrQXhpcykucmVkdWNlKCgodCxlKT0+dCplKSksbz1lLmJyZWFrQXhpczw9MD8xOnQuc2xpY2UoMCxlLmJyZWFrQXhpcykucmVkdWNlKCgodCxlKT0+dCplKSk7aWYoIShuPml8fG8+aSkpcmV0dXJuW24sb107ci5Mb2dnZXIudmVyYm9zZShcIlRleHR1cmVMYXlvdXRcIixgR2l2ZW4gd2lkdGgvaGVpZ2h0IHByZWZlcmVuY2VzIHdlcmUgdW5hdHRhaW5hYmxlOiBzaGFwZToke3R9LCBicmVha0F4aXM6JHtlLmJyZWFrQXhpc31gKX1sZXQgYT10LnNsaWNlKDApO2lmKG4mJihpKj0yLGE9YS5tYXAoKCh0LGUpPT5lPj1hLmxlbmd0aC0yP2FbZV0lMj09MD9hW2VdOmFbZV0rMTphW2VdKSksMT09PWEubGVuZ3RoJiYoYT1bMixhWzBdXSkpLDIhPT1hLmxlbmd0aCl7Y29uc3QgdD1vKGEpO2E9dC5uZXdTaGFwZX1jb25zdCBzPXUoYSk7cmV0dXJuIGEubGVuZ3RoPD0xJiZzPD1pP1sxLHNdOjI9PT1hLmxlbmd0aCYmYVswXTw9aSYmYVsxXTw9aT9hOjM9PT1hLmxlbmd0aCYmYVswXSphWzFdPD1pJiZhWzJdPD1pP1thWzBdKmFbMV0sYVsyXV06Mz09PWEubGVuZ3RoJiZhWzBdPD1pJiZhWzFdKmFbMl08PWk/W2FbMF0sYVsxXSphWzJdXTo0PT09YS5sZW5ndGgmJmFbMF0qYVsxXSphWzJdPD1pJiZhWzNdPD1pP1thWzBdKmFbMV0qYVsyXSxhWzNdXTo0PT09YS5sZW5ndGgmJmFbMF08PWkmJmFbMV0qYVsyXSphWzNdPD1pP1thWzBdLGFbMV0qYVsyXSphWzNdXTpuP2Mocy80KS5tYXAoKHQ9PjIqdCkpOmMocyl9fSxlLnNxdWVlemVTaGFwZT1vLGUucGFyc2VBeGlzUGFyYW09YSxlLmlzSW50PXMsZS5zaXplRnJvbVNoYXBlPXUsZS5nZXRSb3dzQ29scz1mdW5jdGlvbih0KXtpZigwPT09dC5sZW5ndGgpdGhyb3cgRXJyb3IoXCJDYW5ub3QgZ2V0IHJvd3MgYW5kIGNvbHVtbnMgb2YgYW4gZW1wdHkgc2hhcGUgYXJyYXkuXCIpO3JldHVyblt0Lmxlbmd0aD4xP3RbdC5sZW5ndGgtMl06MSx0W3QubGVuZ3RoLTFdXX0sZS5zaXplVG9TcXVhcmlzaFNoYXBlPWMsZS5nZXRCYXRjaERpbT1mdW5jdGlvbih0LGU9Mil7cmV0dXJuIHUodC5zbGljZSgwLHQubGVuZ3RoLWUpKX19LDQwNTc6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZT1lLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodD1lLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tVGV4dHVyZVR5cGU9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oMjAzOSk7ZS5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlPSh0LG4scik9Pntjb25zdCBvPXI9PT1pLlRleHR1cmVUeXBlLnVucGFja2VkfHxyPT09aS5UZXh0dXJlVHlwZS51bnBhY2tlZFJldmVyc2VkPzE6NCxhPXI9PT1pLlRleHR1cmVUeXBlLnBhY2tlZCxzPXI9PT1pLlRleHR1cmVUeXBlLnVucGFja2VkUmV2ZXJzZWR8fHI9PT1pLlRleHR1cmVUeXBlLnBhY2tlZCx1PXI9PT1pLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24/bi5sZW5ndGgtMTp2b2lkIDAsYz1yPT09aS5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uP24ubWFwKCgodCxlKT0+ZT09PW4ubGVuZ3RoLTE/NCp0OnQpKTp2b2lkIDA7cmV0dXJuKDAsZS5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKSh0LG4sbyxjLHtpc1BhY2tlZDphLHJldmVyc2VXSDpzLGJyZWFrQXhpczp1fSl9LGUuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0PSh0LG4scik9Pntjb25zdCBpPSgwLGUuY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZSkodCxuLHIpO3JldHVybltpLndpZHRoLGkuaGVpZ2h0XX0sZS5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlPSh0LGUsbj0xLGksbyk9Pntjb25zdCBhPSEoIW98fCFvLmlzUGFja2VkKSxbcyx1XT10LmNvbXB1dGVUZXh0dXJlV0goYSYmaXx8ZSxvKSxjPWUubGVuZ3RoO2xldCBsPWUuc2xpY2UoMCk7aWYoMD09PWMmJihsPVsxXSksMT09PW4paT1lO2Vsc2UgaWYoYSl7aWYoNCE9PW4pdGhyb3cgbmV3IEVycm9yKFwiYSBwYWNrZWQgdGV4dHVyZSBtdXN0IGJlIDQtY2hhbm5lbFwiKTtpPWUsYz4wJiYobFtjLTFdPU1hdGguY2VpbChsW2MtMV0vMikpLGM+MSYmKGxbYy0yXT1NYXRoLmNlaWwobFtjLTJdLzIpKX1lbHNlIGlmKCFpKXRocm93IG5ldyBFcnJvcihcIlVucGFja2VkIHNoYXBlIGlzIG5lZWRlZCB3aGVuIHVzaW5nIGNoYW5uZWxzID4gMVwiKTtyZXR1cm57d2lkdGg6cyxoZWlnaHQ6dSxjaGFubmVsczpuLGlzUGFja2VkOmEsc2hhcGU6bCxzdHJpZGVzOnIuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGwpLHVucGFja2VkU2hhcGU6aSxyZXZlcnNlZFdIOm8mJm8ucmV2ZXJzZVdIfX19LDU3MDI6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuVGV4dHVyZU1hbmFnZXI9dm9pZCAwO2NvbnN0IHI9big2MjMxKTtlLlRleHR1cmVNYW5hZ2VyPWNsYXNze2NvbnN0cnVjdG9yKHQsZSxuLHIpe3RoaXMuZ2xDb250ZXh0PXQsdGhpcy5sYXlvdXRTdHJhdGVneT1lLHRoaXMucHJvZmlsZXI9bix0aGlzLmNvbmZpZz1yLHRoaXMucGVuZGluZ1JlYWQ9bmV3IE1hcCxyLnJldXNlVGV4dHVyZXMmJih0aGlzLmluVXNlVGV4dHVyZXM9bmV3IE1hcCx0aGlzLmlkbGVUZXh0dXJlcz1uZXcgTWFwLHRoaXMudGV4dHVyZUxvb2t1cD1uZXcgTWFwKX1jcmVhdGVUZXh0dXJlRnJvbUxheW91dCh0LGUsbixpKXtjb25zdCBvPXRoaXMudG9FbmNvZGVyVHlwZSh0KSxhPXRoaXMuZ2xDb250ZXh0LmdldEVuY29kZXIobyxlLmNoYW5uZWxzfHwxLGkpO2lmKGUuaXNQYWNrZWQmJjE9PT1pKXRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtjb25zdCBzPWUud2lkdGgsdT1lLmhlaWdodDtsZXQgYyxsO2lmKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMpe2M9YCR7c314JHt1fV8ke2EuZm9ybWF0fV8ke2EuaW50ZXJuYWxGb3JtYXR9XyR7YS50ZXh0dXJlVHlwZX1gLGw9dGhpcy5pblVzZVRleHR1cmVzLmdldChjKSxsfHwobD1bXSx0aGlzLmluVXNlVGV4dHVyZXMuc2V0KGMsbCkpO2NvbnN0IGU9dGhpcy5pZGxlVGV4dHVyZXMuZ2V0KGMpO2lmKGUmJmUubGVuZ3RoPjApe2NvbnN0IHI9ZS5wb3AoKTtyZXR1cm4gbC5wdXNoKHIpLDE9PT1pJiZ0aGlzLmdsQ29udGV4dC51cGRhdGVUZXh0dXJlKHIscyx1LGEsdGhpcy50b1RleHR1cmVEYXRhKHQsbikpLHJ9fXIuTG9nZ2VyLnZlcmJvc2UoXCJUZXh0dXJlTWFuYWdlclwiLGBDcmVhdGluZyBuZXcgdGV4dHVyZSBvZiBzaXplICR7ZS53aWR0aH14JHtlLmhlaWdodH1gKTtjb25zdCBwPXRoaXMuZ2xDb250ZXh0LmFsbG9jYXRlVGV4dHVyZShzLHUsYSx0aGlzLnRvVGV4dHVyZURhdGEodCxuKSk7cmV0dXJuIHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMmJihsLnB1c2gocCksdGhpcy50ZXh0dXJlTG9va3VwLnNldChwLGMpKSxwfXJlYWRUZXh0dXJlKHQsZSxuKXtyZXR1cm4gbnx8KG49MSksdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlRleHR1cmVNYW5hZ2VyLnJlYWRUZXh0dXJlXCIsKCgpPT57Y29uc3Qgcj10LnNoYXBlLnJlZHVjZSgoKHQsZSk9PnQqZSkpKm4saT10aGlzLmdsQ29udGV4dC5yZWFkVGV4dHVyZSh0LnRleHR1cmUsdC53aWR0aCx0LmhlaWdodCxyLHRoaXMudG9FbmNvZGVyVHlwZShlKSxuKTtyZXR1cm4gdGhpcy50b1RlbnNvckRhdGEoZSxpKX0pKX1hc3luYyByZWFkVGV4dHVyZUFzeW5jKHQsZSxuKXtjb25zdCByPXQudGVuc29yLmRhdGFJZDtpZihufHwobj0xKSx0aGlzLnBlbmRpbmdSZWFkLmhhcyhyKSl7Y29uc3QgdD10aGlzLnBlbmRpbmdSZWFkLmdldChyKTtyZXR1cm4gbmV3IFByb21pc2UoKGU9Pm51bGw9PXQ/dm9pZCAwOnQucHVzaChlKSkpfXJldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KFwiYmFja2VuZFwiLFwiVGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmVBc3luY1wiLChhc3luYygpPT57dGhpcy5wZW5kaW5nUmVhZC5zZXQocixbXSk7Y29uc3QgaT10LnNoYXBlLnJlZHVjZSgoKHQsZSk9PnQqZSkpKm47YXdhaXQgdGhpcy5nbENvbnRleHQuY3JlYXRlQW5kV2FpdEZvckZlbmNlKCk7Y29uc3Qgbz10aGlzLmdsQ29udGV4dC5yZWFkVGV4dHVyZSh0LnRleHR1cmUsdC53aWR0aCx0LmhlaWdodCxpLHRoaXMudG9FbmNvZGVyVHlwZShlKSxuKSxhPXRoaXMudG9UZW5zb3JEYXRhKGUsbykscz10aGlzLnBlbmRpbmdSZWFkLmdldChyKTtyZXR1cm4gdGhpcy5wZW5kaW5nUmVhZC5kZWxldGUociksbnVsbD09c3x8cy5mb3JFYWNoKCh0PT50KGEpKSksYX0pKX1yZWFkVWludDhUZXh0dXJlQXNGbG9hdCh0KXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlRleHR1cmVNYW5hZ2VyLnJlYWRVaW50OFRleHR1cmVBc0Zsb2F0XCIsKCgpPT57Y29uc3QgZT10LnNoYXBlLnJlZHVjZSgoKHQsZSk9PnQqZSkpLG49dGhpcy5nbENvbnRleHQucmVhZFRleHR1cmUodC50ZXh0dXJlLHQud2lkdGgsdC5oZWlnaHQsNCplLFwiYnl0ZVwiLDQpO3JldHVybiBuZXcgRmxvYXQzMkFycmF5KG4uYnVmZmVyLG4uYnl0ZU9mZnNldCxlKX0pKX1yZWxlYXNlVGV4dHVyZSh0LGUpe2xldCBuO2lmKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMmJihuPXRoaXMudGV4dHVyZUxvb2t1cC5nZXQodC50ZXh0dXJlKSxuKSl7ZSYmdGhpcy50ZXh0dXJlTG9va3VwLmRlbGV0ZShuKTtjb25zdCByPXRoaXMuaW5Vc2VUZXh0dXJlcy5nZXQobik7aWYocil7Y29uc3QgZT1yLmluZGV4T2YodC50ZXh0dXJlKTtpZigtMSE9PWUpe3Iuc3BsaWNlKGUsMSk7bGV0IGk9dGhpcy5pZGxlVGV4dHVyZXMuZ2V0KG4pO2l8fChpPVtdLHRoaXMuaWRsZVRleHR1cmVzLnNldChuLGkpKSxpLnB1c2godC50ZXh0dXJlKX19fW4mJiFlfHwoci5Mb2dnZXIudmVyYm9zZShcIlRleHR1cmVNYW5hZ2VyXCIsYERlbGV0aW5nIHRleHR1cmUgb2Ygc2l6ZSAke3Qud2lkdGh9eCR7dC5oZWlnaHR9YCksdGhpcy5nbENvbnRleHQuZGVsZXRlVGV4dHVyZSh0LnRleHR1cmUpKX10b1RlbnNvckRhdGEodCxlKXtzd2l0Y2godCl7Y2FzZVwiaW50MTZcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEludDE2QXJyYXk/ZTpJbnQxNkFycmF5LmZyb20oZSk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEludDMyQXJyYXk/ZTpJbnQzMkFycmF5LmZyb20oZSk7Y2FzZVwiaW50OFwiOnJldHVybiBlIGluc3RhbmNlb2YgSW50OEFycmF5P2U6SW50OEFycmF5LmZyb20oZSk7Y2FzZVwidWludDE2XCI6cmV0dXJuIGUgaW5zdGFuY2VvZiBVaW50MTZBcnJheT9lOlVpbnQxNkFycmF5LmZyb20oZSk7Y2FzZVwidWludDMyXCI6cmV0dXJuIGUgaW5zdGFuY2VvZiBVaW50MzJBcnJheT9lOlVpbnQzMkFycmF5LmZyb20oZSk7Y2FzZVwidWludDhcIjpjYXNlXCJib29sXCI6cmV0dXJuIGUgaW5zdGFuY2VvZiBVaW50OEFycmF5P2U6VWludDhBcnJheS5mcm9tKGUpO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheT9lOkZsb2F0MzJBcnJheS5mcm9tKGUpO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheT9lOkZsb2F0NjRBcnJheS5mcm9tKGUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBUZW5zb3JEYXRhIHR5cGUgJHt0fSBpcyBub3Qgc3VwcG9ydGVkYCl9fXRvVGV4dHVyZURhdGEodCxlKXtpZihlKXJldHVybiBlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5P2U6bmV3IEZsb2F0MzJBcnJheShlKX10b0VuY29kZXJUeXBlKHQpe3JldHVyblwiZmxvYXRcIn1jbGVhckFjdGl2ZVRleHR1cmVzKCl7dGhpcy5nbENvbnRleHQuY2xlYXJBY3RpdmVUZXh0dXJlcygpfX19LDIwMzk6KHQsZSk9PntcInVzZSBzdHJpY3RcIjt2YXIgbjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlRleHR1cmVUeXBlPXZvaWQgMCwobj1lLlRleHR1cmVUeXBlfHwoZS5UZXh0dXJlVHlwZT17fSkpW24udW5wYWNrZWQ9MF09XCJ1bnBhY2tlZFwiLG5bbi51bnBhY2tlZFJldmVyc2VkPTFdPVwidW5wYWNrZWRSZXZlcnNlZFwiLG5bbi5wYWNrZWQ9Ml09XCJwYWNrZWRcIixuW24uZG93bmxvYWRVaW50OEFzRmxvYXQ9M109XCJkb3dubG9hZFVpbnQ4QXNGbG9hdFwiLG5bbi5wYWNrZWRMYXN0RGltZW5zaW9uPTRdPVwicGFja2VkTGFzdERpbWVuc2lvblwifSw5MzkwOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmdldEdsQ2hhbm5lbHM9ZS5nZXRDb29yZHNEYXRhVHlwZT1lLmdldFNxdWVlemVkUGFyYW1zPWUuc3F1ZWV6ZUlucHV0U2hhcGU9ZS5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWVBdE91dENvb3Jkcz1lLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZT1lLnJlcGVhdGVkVHJ5PWUuZ2V0UGFja2VkU2hhcGU9dm9pZCAwO2NvbnN0IHI9bigyNTE3KTtlLmdldFBhY2tlZFNoYXBlPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dC5sZW5ndGg7cmV0dXJuIHQuc2xpY2UoMCxlLTEpLmNvbmNhdCh0W2UtMV0vNCl9LGUucmVwZWF0ZWRUcnk9YXN5bmMgZnVuY3Rpb24odCxlPSh0PT4wKSxuKXtyZXR1cm4gbmV3IFByb21pc2UoKChyLGkpPT57bGV0IG89MDtjb25zdCBhPSgpPT57aWYodCgpKXJldHVybiB2b2lkIHIoKTtvKys7Y29uc3Qgcz1lKG8pO251bGwhPW4mJm8+PW4/aSgpOnNldFRpbWVvdXQoYSxzKX07YSgpfSkpfSxlLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZT1mdW5jdGlvbih0KXtyZXR1cm4oMCxyLmFzc2VydCkodm9pZCAwIT09dCYmMCE9PXQubGVuZ3RoLCgoKT0+XCJlbXB0eSBzdHJpbmcgZm91bmQgZm9yIHNhbXBsZXIgbmFtZVwiKSksXCJnZXRcIit0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSl9LGUuZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHM9ZnVuY3Rpb24odCl7cmV0dXJuKDAsci5hc3NlcnQpKHZvaWQgMCE9PXQmJjAhPT10Lmxlbmd0aCwoKCk9PlwiZW1wdHkgc3RyaW5nIGZvdW5kIGZvciBzYW1wbGVyIG5hbWVcIikpLFwiZ2V0XCIrdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSt0LnNsaWNlKDEpK1wiQXRPdXRDb29yZHNcIn0sZS5zcXVlZXplSW5wdXRTaGFwZT1mdW5jdGlvbih0LGUpe2xldCBuPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodCkpO3JldHVybiBuPWUsbn0sZS5nZXRTcXVlZXplZFBhcmFtcz1mdW5jdGlvbih0LGUpe3JldHVybiBlLm1hcCgoZT0+dFtlXSkpLmpvaW4oXCIsIFwiKX0sZS5nZXRDb29yZHNEYXRhVHlwZT1mdW5jdGlvbih0KXtpZih0PD0xKXJldHVyblwiaW50XCI7aWYoMj09PXQpcmV0dXJuXCJpdmVjMlwiO2lmKDM9PT10KXJldHVyblwiaXZlYzNcIjtpZig0PT09dClyZXR1cm5cIml2ZWM0XCI7aWYoNT09PXQpcmV0dXJuXCJpdmVjNVwiO2lmKDY9PT10KXJldHVyblwiaXZlYzZcIjt0aHJvdyBFcnJvcihgR1BVIGZvciByYW5rICR7dH0gaXMgbm90IHlldCBzdXBwb3J0ZWRgKX0sZS5nZXRHbENoYW5uZWxzPWZ1bmN0aW9uKHQ9Nil7cmV0dXJuW1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXS5zbGljZSgwLHQpfX0sNzMwNToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jcmVhdGVOZXdXZWJHTENvbnRleHQ9ZS5jcmVhdGVXZWJHTENvbnRleHQ9dm9pZCAwO2NvbnN0IHI9big2MjMxKSxpPW4oMTcxMyksbz17fTtmdW5jdGlvbiBhKHQpe2NvbnN0IGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZG9jdW1lbnQpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBPZmZzY3JlZW5DYW52YXMpdGhyb3cgbmV3IFR5cGVFcnJvcihcImZhaWxlZCB0byBjcmVhdGUgY2FudmFzOiBPZmZzY3JlZW5DYW52YXMgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpfWNvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtyZXR1cm4gdC53aWR0aD0xLHQuaGVpZ2h0PTEsdH0oKTtsZXQgbjtjb25zdCBvPXthbHBoYTohMSxkZXB0aDohMSxhbnRpYWxpYXM6ITEsc3RlbmNpbDohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEscHJlbXVsdGlwbGllZEFscGhhOiExLGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6ITF9O2lmKCghdHx8XCJ3ZWJnbDJcIj09PXQpJiYobj1lLmdldENvbnRleHQoXCJ3ZWJnbDJcIixvKSxuKSl0cnl7cmV0dXJuIG5ldyBpLldlYkdMQ29udGV4dChuLDIpfWNhdGNoKHQpe3IuTG9nZ2VyLndhcm5pbmcoXCJHbENvbnRleHRGYWN0b3J5XCIsYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wyJy4gRXJyb3I6ICR7dH1gKX1pZigoIXR8fFwid2ViZ2xcIj09PXQpJiYobj1lLmdldENvbnRleHQoXCJ3ZWJnbFwiLG8pfHxlLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIixvKSxuKSl0cnl7cmV0dXJuIG5ldyBpLldlYkdMQ29udGV4dChuLDEpfWNhdGNoKHQpe3IuTG9nZ2VyLndhcm5pbmcoXCJHbENvbnRleHRGYWN0b3J5XCIsYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wnIG9yICdleHBlcmltZW50YWwtd2ViZ2wnLiBFcnJvcjogJHt0fWApfXRocm93IG5ldyBFcnJvcihcIldlYkdMIGlzIG5vdCBzdXBwb3J0ZWRcIil9ZS5jcmVhdGVXZWJHTENvbnRleHQ9ZnVuY3Rpb24gdChlKXtsZXQgbjtlJiZcIndlYmdsMlwiIT09ZXx8IShcIndlYmdsMlwiaW4gbyk/ZSYmXCJ3ZWJnbFwiIT09ZXx8IShcIndlYmdsXCJpbiBvKXx8KG49by53ZWJnbCk6bj1vLndlYmdsMixuPW58fGEoZSksZT1lfHwxPT09bi52ZXJzaW9uP1wid2ViZ2xcIjpcIndlYmdsMlwiO2NvbnN0IHI9bi5nbDtyZXR1cm4gb1tlXT1uLHIuaXNDb250ZXh0TG9zdCgpPyhkZWxldGUgb1tlXSx0KGUpKTooci5kaXNhYmxlKHIuREVQVEhfVEVTVCksci5kaXNhYmxlKHIuU1RFTkNJTF9URVNUKSxyLmRpc2FibGUoci5CTEVORCksci5kaXNhYmxlKHIuRElUSEVSKSxyLmRpc2FibGUoci5QT0xZR09OX09GRlNFVF9GSUxMKSxyLmRpc2FibGUoci5TQU1QTEVfQ09WRVJBR0UpLHIuZW5hYmxlKHIuU0NJU1NPUl9URVNUKSxyLmVuYWJsZShyLkNVTExfRkFDRSksci5jdWxsRmFjZShyLkJBQ0spLG4pfSxlLmNyZWF0ZU5ld1dlYkdMQ29udGV4dD1hfSwxNzEzOmZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2kmJiEoXCJnZXRcImluIGk/IWUuX19lc01vZHVsZTppLndyaXRhYmxlfHxpLmNvbmZpZ3VyYWJsZSl8fChpPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlW25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsaSl9OmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pLHRbcl09ZVtuXX0pLGk9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pfTpmdW5jdGlvbih0LGUpe3QuZGVmYXVsdD1lfSksbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmcihlLHQsbik7cmV0dXJuIGkoZSx0KSxlfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLldlYkdMQ29udGV4dD1lLmxpbmVhclNlYXJjaExhc3RUcnVlPXZvaWQgMDtjb25zdCBhPW4oMTY3MCkscz1vKG4oNzc2OSkpLHU9big5MzkwKTtmdW5jdGlvbiBjKHQpe2xldCBlPTA7Zm9yKDtlPHQubGVuZ3RoJiZ0W2VdKCk7KytlKTtyZXR1cm4gZS0xfWUubGluZWFyU2VhcmNoTGFzdFRydWU9YyxlLldlYkdMQ29udGV4dD1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuZnJhbWVCdWZmZXJCb3VuZD0hMSx0aGlzLml0ZW1zVG9Qb2xsPVtdLHRoaXMuZ2w9dCx0aGlzLnZlcnNpb249ZSx0aGlzLmdldEV4dGVuc2lvbnMoKSx0aGlzLnZlcnRleGJ1ZmZlcj10aGlzLmNyZWF0ZVZlcnRleGJ1ZmZlcigpLHRoaXMuZnJhbWVidWZmZXI9dGhpcy5jcmVhdGVGcmFtZWJ1ZmZlcigpLHRoaXMucXVlcnlWaXRhbFBhcmFtZXRlcnMoKX1hbGxvY2F0ZVRleHR1cmUodCxlLG4scil7Y29uc3QgaT10aGlzLmdsLG89aS5jcmVhdGVUZXh0dXJlKCk7aS5iaW5kVGV4dHVyZShpLlRFWFRVUkVfMkQsbyksaS50ZXhQYXJhbWV0ZXJpKGkuVEVYVFVSRV8yRCxpLlRFWFRVUkVfTUlOX0ZJTFRFUixpLk5FQVJFU1QpLGkudGV4UGFyYW1ldGVyaShpLlRFWFRVUkVfMkQsaS5URVhUVVJFX01BR19GSUxURVIsaS5ORUFSRVNUKSxpLnRleFBhcmFtZXRlcmkoaS5URVhUVVJFXzJELGkuVEVYVFVSRV9XUkFQX1MsaS5DTEFNUF9UT19FREdFKSxpLnRleFBhcmFtZXRlcmkoaS5URVhUVVJFXzJELGkuVEVYVFVSRV9XUkFQX1QsaS5DTEFNUF9UT19FREdFKTtjb25zdCBhPXI/bi5lbmNvZGUocix0KmUpOm51bGw7cmV0dXJuIGkudGV4SW1hZ2UyRChpLlRFWFRVUkVfMkQsMCxuLmludGVybmFsRm9ybWF0LHQsZSwwLG4uZm9ybWF0LG4udGV4dHVyZVR5cGUsYSksdGhpcy5jaGVja0Vycm9yKCksb311cGRhdGVUZXh0dXJlKHQsZSxuLHIsaSl7Y29uc3Qgbz10aGlzLmdsO28uYmluZFRleHR1cmUoby5URVhUVVJFXzJELHQpO2NvbnN0IGE9ci5lbmNvZGUoaSxlKm4pO28udGV4U3ViSW1hZ2UyRChvLlRFWFRVUkVfMkQsMCwwLDAsZSxuLHIuZm9ybWF0LHIudGV4dHVyZVR5cGUsYSksdGhpcy5jaGVja0Vycm9yKCl9YXR0YWNoRnJhbWVidWZmZXIodCxlLG4pe2NvbnN0IHI9dGhpcy5nbDtyLmJpbmRUZXh0dXJlKHIuVEVYVFVSRV8yRCx0KSxyLmJpbmRGcmFtZWJ1ZmZlcihyLkZSQU1FQlVGRkVSLHRoaXMuZnJhbWVidWZmZXIpLHIuZnJhbWVidWZmZXJUZXh0dXJlMkQoci5GUkFNRUJVRkZFUixyLkNPTE9SX0FUVEFDSE1FTlQwLHIuVEVYVFVSRV8yRCx0LDApLHRoaXMuY2hlY2tFcnJvcigpLHIudmlld3BvcnQoMCwwLGUsbiksci5zY2lzc29yKDAsMCxlLG4pfXJlYWRUZXh0dXJlKHQsZSxuLHIsaSxvKXtjb25zdCBhPXRoaXMuZ2w7b3x8KG89MSksdGhpcy5mcmFtZUJ1ZmZlckJvdW5kfHx0aGlzLmF0dGFjaEZyYW1lYnVmZmVyKHQsZSxuKTtjb25zdCBzPXRoaXMuZ2V0RW5jb2RlcihpLG8pLHU9cy5hbGxvY2F0ZShlKm4pO3JldHVybiBhLmJpbmRUZXh0dXJlKGEuVEVYVFVSRV8yRCx0KSxhLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGEuRlJBTUVCVUZGRVIsYS5DT0xPUl9BVFRBQ0hNRU5UMCxhLlRFWFRVUkVfMkQsdCwwKSxhLnJlYWRQaXhlbHMoMCwwLGUsbixhLlJHQkEscy50ZXh0dXJlVHlwZSx1KSx0aGlzLmNoZWNrRXJyb3IoKSxzLmRlY29kZSh1LHIpfWlzRnJhbWVidWZmZXJSZWFkeSgpe3JldHVybiEwfWdldEFjdGl2ZVRleHR1cmUoKXtjb25zdCB0PXRoaXMuZ2w7cmV0dXJuXCJURVhUVVJFXCIrKHQuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuQUNUSVZFX1RFWFRVUkUpLXQuVEVYVFVSRTApfWdldFRleHR1cmVCaW5kaW5nKCl7cmV0dXJuIHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuVEVYVFVSRV9CSU5ESU5HXzJEKX1nZXRGcmFtZWJ1ZmZlckJpbmRpbmcoKXtyZXR1cm4gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5GUkFNRUJVRkZFUl9CSU5ESU5HKX1zZXRWZXJ0ZXhBdHRyaWJ1dGVzKHQsZSl7Y29uc3Qgbj10aGlzLmdsO24udmVydGV4QXR0cmliUG9pbnRlcih0LDMsbi5GTE9BVCwhMSwyMCwwKSxuLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHQpLC0xIT09ZSYmKG4udmVydGV4QXR0cmliUG9pbnRlcihlLDIsbi5GTE9BVCwhMSwyMCwxMiksbi5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShlKSksdGhpcy5jaGVja0Vycm9yKCl9Y3JlYXRlUHJvZ3JhbSh0LGUpe2NvbnN0IG49dGhpcy5nbCxyPW4uY3JlYXRlUHJvZ3JhbSgpO3JldHVybiBuLmF0dGFjaFNoYWRlcihyLHQpLG4uYXR0YWNoU2hhZGVyKHIsZSksbi5saW5rUHJvZ3JhbShyKSxyfWNvbXBpbGVTaGFkZXIodCxlKXtjb25zdCBuPXRoaXMuZ2wscj1uLmNyZWF0ZVNoYWRlcihlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoYGNyZWF0ZVNoYWRlcigpIHJldHVybmVkIG51bGwgd2l0aCB0eXBlICR7ZX1gKTtpZihuLnNoYWRlclNvdXJjZShyLHQpLG4uY29tcGlsZVNoYWRlcihyKSwhMT09PW4uZ2V0U2hhZGVyUGFyYW1ldGVyKHIsbi5DT01QSUxFX1NUQVRVUykpdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6ICR7bi5nZXRTaGFkZXJJbmZvTG9nKHIpfVxcblNoYWRlciBzb3VyY2U6XFxuJHt0fWApO3JldHVybiByfWRlbGV0ZVNoYWRlcih0KXt0aGlzLmdsLmRlbGV0ZVNoYWRlcih0KX1iaW5kVGV4dHVyZVRvVW5pZm9ybSh0LGUsbil7Y29uc3Qgcj10aGlzLmdsO3IuYWN0aXZlVGV4dHVyZShyLlRFWFRVUkUwK2UpLHRoaXMuY2hlY2tFcnJvcigpLHIuYmluZFRleHR1cmUoci5URVhUVVJFXzJELHQpLHRoaXMuY2hlY2tFcnJvcigpLHIudW5pZm9ybTFpKG4sZSksdGhpcy5jaGVja0Vycm9yKCl9ZHJhdygpe3RoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLlRSSUFOR0xFX1NUUklQLDAsNCksdGhpcy5jaGVja0Vycm9yKCl9Y2hlY2tFcnJvcigpe2lmKGEuZW52LmRlYnVnKXtjb25zdCB0PXRoaXMuZ2wsZT10LmdldEVycm9yKCk7bGV0IG49XCJcIjtzd2l0Y2goZSl7Y2FzZSB0Lk5PX0VSUk9SOnJldHVybjtjYXNlIHQuSU5WQUxJRF9FTlVNOm49XCJJTlZBTElEX0VOVU1cIjticmVhaztjYXNlIHQuSU5WQUxJRF9WQUxVRTpuPVwiSU5WQUxJRF9WQUxVRVwiO2JyZWFrO2Nhc2UgdC5JTlZBTElEX09QRVJBVElPTjpuPVwiSU5WQUxJRF9PUEVSQVRJT05cIjticmVhaztjYXNlIHQuSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046bj1cIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OXCI7YnJlYWs7Y2FzZSB0Lk9VVF9PRl9NRU1PUlk6bj1cIk9VVF9PRl9NRU1PUllcIjticmVhaztjYXNlIHQuQ09OVEVYVF9MT1NUX1dFQkdMOm49XCJDT05URVhUX0xPU1RfV0VCR0xcIjticmVhaztkZWZhdWx0Om49YFVua25vd24gV2ViR0wgRXJyb3I6ICR7ZS50b1N0cmluZygxNil9YH10aHJvdyBuZXcgRXJyb3Iobil9fWRlbGV0ZVRleHR1cmUodCl7dGhpcy5nbC5kZWxldGVUZXh0dXJlKHQpfWRlbGV0ZVByb2dyYW0odCl7dGhpcy5nbC5kZWxldGVQcm9ncmFtKHQpfWdldEVuY29kZXIodCxlLG49MCl7aWYoMj09PXRoaXMudmVyc2lvbilyZXR1cm4gbmV3IHMuUmVkRmxvYXQzMkRhdGFFbmNvZGVyKHRoaXMuZ2wsZSk7c3dpdGNoKHQpe2Nhc2VcImZsb2F0XCI6cmV0dXJuIDE9PT1ufHx0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZD9uZXcgcy5SR0JBRmxvYXREYXRhRW5jb2Rlcih0aGlzLmdsLGUpOm5ldyBzLlJHQkFGbG9hdERhdGFFbmNvZGVyKHRoaXMuZ2wsZSx0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24uSEFMRl9GTE9BVF9PRVMpO2Nhc2VcImludFwiOnRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtjYXNlXCJieXRlXCI6cmV0dXJuIG5ldyBzLlVpbnQ4RGF0YUVuY29kZXIodGhpcy5nbCxlKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhVHlwZTogJHt0fWApfX1jbGVhckFjdGl2ZVRleHR1cmVzKCl7Y29uc3QgdD10aGlzLmdsO2ZvcihsZXQgZT0wO2U8dGhpcy5tYXhUZXh0dXJlSW1hZ2VVbml0czsrK2UpdC5hY3RpdmVUZXh0dXJlKHQuVEVYVFVSRTArZSksdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCl9ZGlzcG9zZSgpe2lmKHRoaXMuZGlzcG9zZWQpcmV0dXJuO2NvbnN0IHQ9dGhpcy5nbDt0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlciksdC5iaW5kQnVmZmVyKHQuQVJSQVlfQlVGRkVSLG51bGwpLHQuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4YnVmZmVyKSx0LmJpbmRCdWZmZXIodC5FTEVNRU5UX0FSUkFZX0JVRkZFUixudWxsKSx0LmZpbmlzaCgpLHRoaXMuZGlzcG9zZWQ9ITB9Y3JlYXRlRGVmYXVsdEdlb21ldHJ5KCl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWy0xLDEsMCwwLDEsLTEsLTEsMCwwLDAsMSwxLDAsMSwxLDEsLTEsMCwxLDBdKX1jcmVhdGVWZXJ0ZXhidWZmZXIoKXtjb25zdCB0PXRoaXMuZ2wsZT10LmNyZWF0ZUJ1ZmZlcigpO2lmKCFlKXRocm93IG5ldyBFcnJvcihcImNyZWF0ZUJ1ZmZlcigpIHJldHVybmVkIG51bGxcIik7Y29uc3Qgbj10aGlzLmNyZWF0ZURlZmF1bHRHZW9tZXRyeSgpO3JldHVybiB0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIsZSksdC5idWZmZXJEYXRhKHQuQVJSQVlfQlVGRkVSLG4sdC5TVEFUSUNfRFJBVyksdGhpcy5jaGVja0Vycm9yKCksZX1jcmVhdGVGcmFtZWJ1ZmZlcigpe2NvbnN0IHQ9dGhpcy5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO2lmKCF0KXRocm93IG5ldyBFcnJvcihcImNyZWF0ZUZyYW1lYnVmZmVyIHJldHVybmVkIG51bGxcIik7cmV0dXJuIHR9cXVlcnlWaXRhbFBhcmFtZXRlcnMoKXtjb25zdCB0PXRoaXMuZ2w7aWYodGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyPXRoaXMuY2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpLHRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkPXRoaXMuY2hlY2tSZW5kZXJGbG9hdDMyKCksdGhpcy5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZD10aGlzLmNoZWNrRmxvYXQzMkRvd25sb2FkKCksMT09PXRoaXMudmVyc2lvbiYmIXRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiYmIXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkKXRocm93IG5ldyBFcnJvcihcImJvdGggZmxvYXQzMiBhbmQgZmxvYXQxNiBUZXh0dXJlVHlwZSBhcmUgbm90IHN1cHBvcnRlZFwiKTt0aGlzLmlzQmxlbmRTdXBwb3J0ZWQ9IXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkfHx0aGlzLmNoZWNrRmxvYXQzMkJsZW5kKCksdGhpcy5tYXhUZXh0dXJlU2l6ZT10LmdldFBhcmFtZXRlcih0Lk1BWF9URVhUVVJFX1NJWkUpLHRoaXMubWF4VGV4dHVyZUltYWdlVW5pdHM9dC5nZXRQYXJhbWV0ZXIodC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksdGhpcy52ZXJzaW9ufWdldEV4dGVuc2lvbnMoKXsyPT09dGhpcy52ZXJzaW9uPyh0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpLHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKSk6KHRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIiksdGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKSl9Y2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpe2NvbnN0IHQ9dGhpcy5nbCxlPXQuY3JlYXRlVGV4dHVyZSgpO3QuYmluZFRleHR1cmUodC5URVhUVVJFXzJELGUpO2NvbnN0IG49Mj09PXRoaXMudmVyc2lvbj90LlJHQkEzMkY6dC5SR0JBO3QudGV4SW1hZ2UyRCh0LlRFWFRVUkVfMkQsMCxuLDEsMSwwLHQuUkdCQSx0LkZMT0FULG51bGwpO2NvbnN0IHI9dC5jcmVhdGVGcmFtZWJ1ZmZlcigpO3QuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsciksdC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0LkZSQU1FQlVGRkVSLHQuQ09MT1JfQVRUQUNITUVOVDAsdC5URVhUVVJFXzJELGUsMCk7Y29uc3QgaT10LmNoZWNrRnJhbWVidWZmZXJTdGF0dXModC5GUkFNRUJVRkZFUik9PT10LkZSQU1FQlVGRkVSX0NPTVBMRVRFO3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlVGV4dHVyZShlKSx0LmRlbGV0ZUZyYW1lYnVmZmVyKHIpLGl9Y2hlY2tSZW5kZXJGbG9hdDMyKCl7aWYoMj09PXRoaXMudmVyc2lvbil7aWYoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbilyZXR1cm4hMX1lbHNlIGlmKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbilyZXR1cm4hMTtyZXR1cm4gdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyfWNoZWNrRmxvYXQzMkRvd25sb2FkKCl7aWYoMj09PXRoaXMudmVyc2lvbil7aWYoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbilyZXR1cm4hMX1lbHNle2lmKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbilyZXR1cm4hMTtpZighdGhpcy5nbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXRcIikpcmV0dXJuITF9cmV0dXJuIHRoaXMuaXNGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcn1jaGVja0Zsb2F0MzJCbGVuZCgpe2NvbnN0IHQ9dGhpcy5nbDtsZXQgZSxuLHIsaSxvO3RyeXtlPXQuY3JlYXRlVGV4dHVyZSgpLG49dC5jcmVhdGVGcmFtZWJ1ZmZlcigpLHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELGUpO2NvbnN0IGE9Mj09PXRoaXMudmVyc2lvbj90LlJHQkEzMkY6dC5SR0JBO3JldHVybiB0LnRleEltYWdlMkQodC5URVhUVVJFXzJELDAsYSwxLDEsMCx0LlJHQkEsdC5GTE9BVCxudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG4pLHQuZnJhbWVidWZmZXJUZXh0dXJlMkQodC5GUkFNRUJVRkZFUix0LkNPTE9SX0FUVEFDSE1FTlQwLHQuVEVYVFVSRV8yRCxlLDApLHQuZW5hYmxlKHQuQkxFTkQpLHI9dC5jcmVhdGVTaGFkZXIodC5WRVJURVhfU0hBREVSKSwhIXImJih0LnNoYWRlclNvdXJjZShyLFwidm9pZCBtYWluKCl7fVwiKSx0LmNvbXBpbGVTaGFkZXIociksaT10LmNyZWF0ZVNoYWRlcih0LkZSQUdNRU5UX1NIQURFUiksISFpJiYodC5zaGFkZXJTb3VyY2UoaSxcInByZWNpc2lvbiBoaWdocCBmbG9hdDt2b2lkIG1haW4oKXtnbF9GcmFnQ29sb3I9dmVjNCgwLjUpO31cIiksdC5jb21waWxlU2hhZGVyKGkpLG89dC5jcmVhdGVQcm9ncmFtKCksISFvJiYodC5hdHRhY2hTaGFkZXIobyxyKSx0LmF0dGFjaFNoYWRlcihvLGkpLHQubGlua1Byb2dyYW0obyksdC51c2VQcm9ncmFtKG8pLHQuZHJhd0FycmF5cyh0LlBPSU5UUywwLDEpLHQuZ2V0RXJyb3IoKT09PXQuTk9fRVJST1IpKSl9ZmluYWxseXt0LmRpc2FibGUodC5CTEVORCksbyYmdC5kZWxldGVQcm9ncmFtKG8pLHImJnQuZGVsZXRlU2hhZGVyKHIpLGkmJnQuZGVsZXRlU2hhZGVyKGkpLG4mJih0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlRnJhbWVidWZmZXIobikpLGUmJih0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKSx0LmRlbGV0ZVRleHR1cmUoZSkpfX1iZWdpblRpbWVyKCl7aWYoMj09PXRoaXMudmVyc2lvbiYmdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pe2NvbnN0IHQ9dGhpcy5nbCxlPXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uLG49dC5jcmVhdGVRdWVyeSgpO3JldHVybiB0LmJlZ2luUXVlcnkoZS5USU1FX0VMQVBTRURfRVhULG4pLG59dGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5cIil9ZW5kVGltZXIoKXtpZigyIT09dGhpcy52ZXJzaW9ufHwhdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiKTt7Y29uc3QgdD10aGlzLmdsLGU9dGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb247dC5lbmRRdWVyeShlLlRJTUVfRUxBUFNFRF9FWFQpfX1pc1RpbWVyUmVzdWx0QXZhaWxhYmxlKHQpe2xldCBlPSExLG49ITE7aWYoMiE9PXRoaXMudmVyc2lvbnx8IXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKXRocm93IG5ldyBFcnJvcihcIldlYkdMMSBwcm9maWxpbmcgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIik7e2NvbnN0IHI9dGhpcy5nbCxpPXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uO2U9ci5nZXRRdWVyeVBhcmFtZXRlcih0LHIuUVVFUllfUkVTVUxUX0FWQUlMQUJMRSksbj1yLmdldFBhcmFtZXRlcihpLkdQVV9ESVNKT0lOVF9FWFQpfXJldHVybiBlJiYhbn1nZXRUaW1lclJlc3VsdCh0KXtsZXQgZT0wO2lmKDIhPT10aGlzLnZlcnNpb24pdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiKTt7Y29uc3Qgbj10aGlzLmdsO2U9bi5nZXRRdWVyeVBhcmFtZXRlcih0LG4uUVVFUllfUkVTVUxUKSxuLmRlbGV0ZVF1ZXJ5KHQpfXJldHVybiBlLzFlNn1hc3luYyB3YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKHQpe3JldHVybiBhd2FpdCgwLHUucmVwZWF0ZWRUcnkpKCgoKT0+dGhpcy5pc1RpbWVyUmVzdWx0QXZhaWxhYmxlKHQpKSksdGhpcy5nZXRUaW1lclJlc3VsdCh0KX1hc3luYyBjcmVhdGVBbmRXYWl0Rm9yRmVuY2UoKXtjb25zdCB0PXRoaXMuY3JlYXRlRmVuY2UodGhpcy5nbCk7cmV0dXJuIHRoaXMucG9sbEZlbmNlKHQpfWNyZWF0ZUZlbmNlKHQpe2xldCBlO2NvbnN0IG49dCxyPW4uZmVuY2VTeW5jKG4uU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsMCk7cmV0dXJuIHQuZmx1c2goKSxlPW51bGw9PT1yPygpPT4hMDooKT0+e2NvbnN0IHQ9bi5jbGllbnRXYWl0U3luYyhyLDAsMCk7cmV0dXJuIHQ9PT1uLkFMUkVBRFlfU0lHTkFMRUR8fHQ9PT1uLkNPTkRJVElPTl9TQVRJU0ZJRUR9LHtxdWVyeTpyLGlzRmVuY2VQYXNzZWQ6ZX19YXN5bmMgcG9sbEZlbmNlKHQpe3JldHVybiBuZXcgUHJvbWlzZSgoZT0+e3RoaXMuYWRkSXRlbVRvUG9sbCgoKCk9PnQuaXNGZW5jZVBhc3NlZCgpKSwoKCk9PmUoKSkpfSkpfXBvbGxJdGVtcygpe2NvbnN0IHQ9Yyh0aGlzLml0ZW1zVG9Qb2xsLm1hcCgodD0+dC5pc0RvbmVGbikpKTtmb3IobGV0IGU9MDtlPD10OysrZSl7Y29uc3R7cmVzb2x2ZUZuOnR9PXRoaXMuaXRlbXNUb1BvbGxbZV07dCgpfXRoaXMuaXRlbXNUb1BvbGw9dGhpcy5pdGVtc1RvUG9sbC5zbGljZSh0KzEpfWFzeW5jIGFkZEl0ZW1Ub1BvbGwodCxlKXt0aGlzLml0ZW1zVG9Qb2xsLnB1c2goe2lzRG9uZUZuOnQscmVzb2x2ZUZuOmV9KSx0aGlzLml0ZW1zVG9Qb2xsLmxlbmd0aD4xfHxhd2FpdCgwLHUucmVwZWF0ZWRUcnkpKCgoKT0+KHRoaXMucG9sbEl0ZW1zKCksMD09PXRoaXMuaXRlbXNUb1BvbGwubGVuZ3RoKSkpfX19LDEwMzY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuRXhlY3V0aW9uUGxhbj12b2lkIDA7Y29uc3Qgcj1uKDYyMzEpO2NsYXNzIGl7Y29uc3RydWN0b3IodCxlKXt0aGlzLm9wPXQsdGhpcy5ub2RlPWV9fWUuRXhlY3V0aW9uUGxhbj1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUsbil7dGhpcy5ncmFwaD10LHRoaXMucHJvZmlsZXI9bix0aGlzLmluaXRpYWxpemUoZSl9aW5pdGlhbGl6ZSh0KXt0aGlzLnByb2ZpbGVyLmV2ZW50KFwic2Vzc2lvblwiLFwiRXhlY3V0aW9uUGxhbi5pbml0aWFsaXplXCIsKCgpPT57Y29uc3QgZT10aGlzLmdyYXBoLmdldE5vZGVzKCk7aWYoZS5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2l6ZSBvZiBub2RlcyBhbmQgT1BzIGRvIG5vdCBtYXRjaC5cIik7dGhpcy5fb3BzPXQubWFwKCgodCxuKT0+bmV3IGkodCxlW25dKSkpLHRoaXMucmVzZXQoKSx0aGlzLl9zdGFydGVyPVtdLHRoaXMuX29wcy5mb3JFYWNoKCgodCxlKT0+e2xldCBuPSEwO2Zvcihjb25zdCBlIG9mIHQubm9kZS5pbnB1dHMpaWYoIXRoaXMuX3ZhbHVlc1tlXSYmLTE9PT10aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpLmluZGV4T2YoZSkpe249ITE7YnJlYWt9biYmdGhpcy5fc3RhcnRlci5wdXNoKGUpfSkpfSkpfXJlc2V0KCl7dGhpcy5fdmFsdWVzPXRoaXMuZ3JhcGguZ2V0VmFsdWVzKCkubWFwKCh0PT50LnRlbnNvcikpfWFzeW5jIGV4ZWN1dGUodCxlKXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIkV4ZWN1dGlvblBsYW4uZXhlY3V0ZVwiLChhc3luYygpPT57dGhpcy5yZXNldCgpO2NvbnN0IG49dC5jcmVhdGVJbmZlcmVuY2VIYW5kbGVyKCksaT10aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpO2lmKGUubGVuZ3RoIT09aS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBudW1iZXIgb2YgaW5wdXQgdGVuc29ycyBkb24ndCBtYXRjaCB0aGUgbnVtYmVyIG9mIGlucHV0cyB0byB0aGUgbW9kZWw6IGFjdHVhbDogJHtlLmxlbmd0aH0gZXhwZWN0ZWQ6ICR7aS5sZW5ndGh9YCk7ZS5mb3JFYWNoKCgodCxlKT0+e2NvbnN0IG49aVtlXTt0aGlzLl92YWx1ZXNbbl09dH0pKTtjb25zdCBvPXRoaXMuX3N0YXJ0ZXIuc2xpY2UoMCksYT10aGlzLmdyYXBoLmdldFZhbHVlcygpLHM9dGhpcy5ncmFwaC5nZXROb2RlcygpO2xldCB1PTA7Zm9yKDt1PG8ubGVuZ3RoOyl7Y29uc3QgdD1vW3UrK10sZT10aGlzLl9vcHNbdF0saT1lLm5vZGUuaW5wdXRzLm1hcCgodD0+dGhpcy5fdmFsdWVzW3RdKSk7aWYoLTEhPT1pLmluZGV4T2Yodm9pZCAwKSl0aHJvdyBuZXcgRXJyb3IoYHVucmVzb2x2ZWQgaW5wdXQgZGV0ZWN0ZWQ6IG9wOiAke2Uubm9kZX1gKTtjb25zdCBjPWk7ci5Mb2dnZXIudmVyYm9zZShcIkV4ZWNQbGFuXCIsYFJ1bmluZyBvcDoke2Uubm9kZS5uYW1lfSAoJHtjLm1hcCgoKHQsbik9PmAnJHtlLm5vZGUuaW5wdXRzW25dfSc6ICR7dC50eXBlfVske3QuZGltcy5qb2luKFwiLFwiKX1dYCkpLmpvaW4oXCIsIFwiKX0pYCk7Y29uc3QgbD1hd2FpdCB0aGlzLnByb2ZpbGVyLmV2ZW50KFwibm9kZVwiLGUubm9kZS5uYW1lLChhc3luYygpPT5lLm9wLmltcGwobixjLGUub3AuY29udGV4dCkpKTtpZihsLmxlbmd0aCE9PWUubm9kZS5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgc2l6ZSBvZiBvdXRwdXQgZG9lcyBub3QgbWF0Y2ggbW9kZWwgZGVmaW5pdGlvbi5cIik7bC5mb3JFYWNoKCgodCxuKT0+e2NvbnN0IHI9ZS5ub2RlLm91dHB1dHNbbl07aWYodGhpcy5fdmFsdWVzW3JdKXRocm93IG5ldyBFcnJvcihgb3V0cHV0IFske3J9XSBhbHJlYWR5IGhhcyB2YWx1ZTogb3A6JHtlLm5vZGUubmFtZX1gKTt0aGlzLl92YWx1ZXNbcl09dH0pKTtjb25zdCBwPW5ldyBTZXQ7bC5mb3JFYWNoKCgodCxuKT0+e2NvbnN0IHI9ZS5ub2RlLm91dHB1dHNbbl07Zm9yKGNvbnN0IHQgb2YgYVtyXS50byl7Y29uc3QgZT1zW3RdO2xldCBuPSEwO2Zvcihjb25zdCB0IG9mIGUuaW5wdXRzKWlmKCF0aGlzLl92YWx1ZXNbdF0pe249ITE7YnJlYWt9biYmcC5hZGQodCl9fSkpLG8ucHVzaCguLi5wKX1jb25zdCBjPVtdO2ZvcihsZXQgdD0wO3Q8dGhpcy5ncmFwaC5nZXRPdXRwdXRJbmRpY2VzKCkubGVuZ3RoO3QrKyl7Y29uc3QgZT10aGlzLmdyYXBoLmdldE91dHB1dEluZGljZXMoKVt0XSxuPXRoaXMuX3ZhbHVlc1tlXTtpZih2b2lkIDA9PT1uKXRocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgb3V0cHV0IFske2V9XSBkb2VzIG5vdCBoYXZlIHZhbHVlYCk7MD09PWU/YXdhaXQgbi5nZXREYXRhKCk6bi5kYXRhLGMucHVzaChuKX1yZXR1cm4gci5Mb2dnZXIudmVyYm9zZShcIkV4ZWNQbGFuXCIsXCJkaXNwb3Npbmcgb2YgaW5mZXJlbmNlSGFuZGxlclwiKSxuLmRpc3Bvc2UoKSxjfSkpfX19LDcwNzA6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuR3JhcGg9dm9pZCAwO2NvbnN0IHI9bigxNDQ2KSxpPW4oNzc3OCksbz1uKDkzOTUpLGE9big5MTYyKSxzPW4oMjUxNyk7dmFyIHU9by5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO2UuR3JhcGg9e2Zyb206KHQsZSk9Pm5ldyBwKHQsZSl9O2NsYXNzIGN7Y29uc3RydWN0b3IodCl7dGhpcy5fZnJvbT12b2lkIDAsdGhpcy5fdG89W10sdGhpcy50ZW5zb3I9dm9pZCAwLHRoaXMudHlwZT12b2lkIDAsdCYmKHRoaXMudHlwZT1zLlByb3RvVXRpbC50ZW5zb3JWYWx1ZVR5cGVGcm9tUHJvdG8odC50eXBlLnRlbnNvclR5cGUpKX1nZXQgZnJvbSgpe3JldHVybiB0aGlzLl9mcm9tfWdldCB0bygpe3JldHVybiB0aGlzLl90b319Y2xhc3MgbHtjb25zdHJ1Y3Rvcih0LGUpe3QgaW5zdGFuY2VvZiByLm9ubnguTm9kZVByb3RvPyh0aGlzLm5hbWU9dC5uYW1lLHRoaXMub3BUeXBlPXQub3BUeXBlLHRoaXMuYXR0cmlidXRlcz1uZXcgaS5BdHRyaWJ1dGUodC5hdHRyaWJ1dGUpKTp0IGluc3RhbmNlb2YgdS5Ob2RlJiYodGhpcy5uYW1lPW51bGwhPWU/ZTp0Lm5hbWUoKSx0aGlzLm9wVHlwZT10Lm9wVHlwZSgpLHRoaXMuYXR0cmlidXRlcz1uZXcgaS5BdHRyaWJ1dGUocy5Qcm90b1V0aWwudGVuc29yQXR0cmlidXRlc0Zyb21PUlRGb3JtYXQodCkpKSx0aGlzLmlucHV0cz1bXSx0aGlzLm91dHB1dHM9W10sdGhpcy5leGVjdXRlTm9kZT0hMH19Y2xhc3MgcHtjb25zdHJ1Y3Rvcih0LGUpe2lmKCF0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJncmFwaCBpcyBlbXB0eVwiKTt0aGlzLmJ1aWxkR3JhcGgodCksdGhpcy50cmFuc2Zvcm1HcmFwaChlKSx0aGlzLmNoZWNrSXNBY3ljbGljKCl9Z2V0SW5wdXRJbmRpY2VzKCl7cmV0dXJuIHRoaXMuX2FsbElucHV0SW5kaWNlc31nZXRJbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX2FsbElucHV0TmFtZXN9Z2V0T3V0cHV0SW5kaWNlcygpe3JldHVybiB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzfWdldE91dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX2FsbE91dHB1dE5hbWVzfWdldFZhbHVlcygpe3JldHVybiB0aGlzLl9hbGxEYXRhfWdldE5vZGVzKCl7cmV0dXJuIHRoaXMuX25vZGVzfWJ1aWxkR3JhcGgodCl7aWYodCBpbnN0YW5jZW9mIHIub25ueC5HcmFwaFByb3RvKXRoaXMuYnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgdS5HcmFwaCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdyYXBoIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cIik7dGhpcy5idWlsZEdyYXBoRnJvbU9ydEZvcm1hdCh0KX19YnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KHQpe2NvbnN0IGU9bmV3IE1hcDt0aGlzLl9hbGxEYXRhPVtdLHRoaXMuX2FsbElucHV0SW5kaWNlcz1bXSx0aGlzLl9hbGxJbnB1dE5hbWVzPVtdLHRoaXMuX2FsbE91dHB1dEluZGljZXM9W10sdGhpcy5fYWxsT3V0cHV0TmFtZXM9W10sdGhpcy5fbm9kZXM9W107Y29uc3Qgbj1uZXcgTWFwO2lmKCF0LmlucHV0KXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGlucHV0XCIpO2NvbnN0IHI9W107Zm9yKGNvbnN0IG4gb2YgdC5pbnB1dCl7aWYoZS5oYXMobi5uYW1lKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgaW5wdXQgbmFtZTogJHtuLm5hbWV9YCk7Y29uc3QgdD10aGlzLl9hbGxEYXRhLnB1c2gobmV3IGMobikpLTE7ZS5zZXQobi5uYW1lLHQpLHIucHVzaChuLm5hbWUpfWlmKCF0LmluaXRpYWxpemVyKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGluaXRpYWxpemVyXCIpO2Zvcihjb25zdCBuIG9mIHQuaW5pdGlhbGl6ZXIpe2xldCB0PWUuZ2V0KG4ubmFtZSk7aWYodm9pZCAwPT09dCl7Y29uc3Qgcj1uZXcgYztyLnR5cGU9e3NoYXBlOntkaW1zOnMuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tUHJvdG8obi5kaW1zKX0sdGVuc29yVHlwZTpzLlByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhuLmRhdGFUeXBlKX0sdD10aGlzLl9hbGxEYXRhLnB1c2gociktMSxlLnNldChuLm5hbWUsdCl9dGhpcy5fYWxsRGF0YVt0XS5fZnJvbT0tMSx0aGlzLl9hbGxEYXRhW3RdLnRlbnNvcj1hLlRlbnNvci5mcm9tUHJvdG8obil9Zm9yKGxldCB0PTA7dDx0aGlzLl9hbGxEYXRhLmxlbmd0aDt0KyspdGhpcy5fYWxsRGF0YVt0XS50ZW5zb3J8fCh0aGlzLl9hbGxJbnB1dEluZGljZXMucHVzaCh0KSx0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2goclt0XSkpO2lmKCF0Lm91dHB1dCl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBvdXRwdXRcIik7Zm9yKGNvbnN0IG4gb2YgdC5vdXRwdXQpe2lmKGUuaGFzKG4ubmFtZSkpdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG91dHB1dCBuYW1lOiAke24ubmFtZX1gKTtjb25zdCB0PXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyhuKSktMTtlLnNldChuLm5hbWUsdCksdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5wdXNoKHQpLHRoaXMuX2FsbE91dHB1dE5hbWVzLnB1c2gobi5uYW1lKX1pZighdC5ub2RlKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGVcIik7Zm9yKGNvbnN0IGUgb2YgdC5ub2RlKXtpZighZS5uYW1lKWZvcihsZXQgdD0wOzt0Kyspe2NvbnN0IHI9YHVubmFtZWRfJHtlLm9wVHlwZX1fJHt0fWA7aWYoIW4uaGFzKHIpKXtlLm5hbWU9cjticmVha319aWYobi5oYXMoZS5uYW1lKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgbm9kZSBuYW1lOiAke2UubmFtZX1gKTtjb25zdCB0PXRoaXMuX25vZGVzLnB1c2gobmV3IGwoZSkpLTE7bi5zZXQoZS5uYW1lLHQpfWZvcihsZXQgbj0wO248dGhpcy5fbm9kZXMubGVuZ3RoO24rKyl7Y29uc3Qgcj10aGlzLl9ub2Rlc1tuXSxpPXQubm9kZVtuXTtpZighaS5vdXRwdXQpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIG91dHB1dCBmb3Igbm9kZTogJHtpLm5hbWV9YCk7Zm9yKGNvbnN0IHQgb2YgaS5vdXRwdXQpe2xldCBvPWUuZ2V0KHQpO2lmKHZvaWQgMD09PW8mJihvPXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyktMSxlLnNldCh0LG8pKSxyLm91dHB1dHMucHVzaChvKSx2b2lkIDAhPT10aGlzLl9hbGxEYXRhW29dLl9mcm9tKXRocm93IG5ldyBFcnJvcihgbXVsdGlwbGUgbm9kZXMgb3V0cHV0IHRvIG9uZSBkYXRhIHZhbHVlOiAke299YCk7aWYodGhpcy5fYWxsRGF0YVtvXS5fZnJvbT1uLFwiQ29uc3RhbnRcIj09PWkub3BUeXBlKXtpZighaS5hdHRyaWJ1dGV8fDEhPT1pLmF0dHJpYnV0ZS5sZW5ndGh8fCFpLmF0dHJpYnV0ZVswXS50KXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgYXR0cmlidXRlcyBvciBtaXNzaW5nIHRlbnNvciB2YWx1ZSBpbiBhdHRyaWJ1dGVzIGZvciB0aGlzIENvbnN0YW50IG9wZXJhdG9yXCIpO2lmKCFpLm91dHB1dHx8MSE9PWkub3V0cHV0Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIG91dHB1dCBvciBpbmNvcnJlY3QgbnVtYmVyIG9mIG91dHB1dHMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3JcIik7ci5vdXRwdXRzLnBvcCgpLHIuZXhlY3V0ZU5vZGU9ITEsdGhpcy5fYWxsRGF0YVtvXS5fZnJvbT0tMSx0aGlzLl9hbGxEYXRhW29dLnRlbnNvcj1hLlRlbnNvci5mcm9tUHJvdG8oaS5hdHRyaWJ1dGVbMF0udCl9fX1mb3IobGV0IG49MDtuPHRoaXMuX25vZGVzLmxlbmd0aDtuKyspe2NvbnN0IHI9dGhpcy5fbm9kZXNbbl0saT10Lm5vZGVbbl07aWYoIWkuaW5wdXQpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGlucHV0IGZvciBub2RlOiAke2kubmFtZX1gKTtmb3IoY29uc3QgdCBvZiBpLmlucHV0KXtjb25zdCBvPWUuZ2V0KHQpO2lmKHZvaWQgMD09PW8pe2lmKFwiXCI9PT10JiYzPT09aS5pbnB1dC5sZW5ndGgmJlwiUmVzaXplXCI9PT1pLm9wVHlwZSljb250aW51ZTt0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBpbnB1dCAnJHt0fScgZm9yIG5vZGU6ICR7aS5uYW1lfWApfXIuaW5wdXRzLnB1c2gobyksdGhpcy5fYWxsRGF0YVtvXS5fdG8ucHVzaChuKX19cmV0dXJuITB9YnVpbGRHcmFwaEZyb21PcnRGb3JtYXQodCl7dmFyIGUsbixyO2NvbnN0IGk9bmV3IE1hcDt0aGlzLl9hbGxEYXRhPVtdLHRoaXMuX2FsbElucHV0SW5kaWNlcz1bXSx0aGlzLl9hbGxJbnB1dE5hbWVzPVtdLHRoaXMuX2FsbE91dHB1dEluZGljZXM9W10sdGhpcy5fYWxsT3V0cHV0TmFtZXM9W10sdGhpcy5fbm9kZXM9W107Y29uc3Qgbz1uZXcgTWFwLHA9W107Zm9yKGxldCBvPTA7bzx0LmlucHV0c0xlbmd0aCgpO28rKyl7Y29uc3QgYT10LmlucHV0cyhvKTtpZihpLmhhcyhhKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgaW5wdXQgbmFtZTogJHthfWApO2ZvcihsZXQgbz0wO288dC5ub2RlQXJnc0xlbmd0aCgpO28rKylpZigobnVsbD09PShlPXQubm9kZUFyZ3MobykpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLm5hbWUoKSk9PT1hKXtjb25zdCBlPW5ldyBjO2lmKChudWxsPT09KHI9bnVsbD09PShuPXQubm9kZUFyZ3MobykpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLnR5cGUoKSl8fHZvaWQgMD09PXI/dm9pZCAwOnIudmFsdWVUeXBlKCkpIT09dS5UeXBlSW5mb1ZhbHVlLnRlbnNvcl90eXBlKXRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgdHlwZSBmb3IgdGhlIG5vZGVBcmcuXCIpO2NvbnN0IGw9dC5ub2RlQXJncyhvKS50eXBlKCkudmFsdWUobmV3IHUuVGVuc29yVHlwZUFuZFNoYXBlKSxmPXMuUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGwuZWxlbVR5cGUoKSksZD1sLnNoYXBlKCksaD1bXTtmb3IobGV0IHQ9MDt0PGQuZGltTGVuZ3RoKCk7dCsrKWgucHVzaChzLkxvbmdVdGlsLmxvbmdUb051bWJlcihkLmRpbSh0KS52YWx1ZSgpLmRpbVZhbHVlKCkpKTtlLnR5cGU9e3NoYXBlOntkaW1zOmh9LHRlbnNvclR5cGU6Zn07Y29uc3QgZz10aGlzLl9hbGxEYXRhLnB1c2goZSktMTtpLnNldChhLGcpLHAucHVzaChhKX19Zm9yKGxldCBlPTA7ZTx0LmluaXRpYWxpemVyc0xlbmd0aCgpO2UrKyl7Y29uc3Qgbj10LmluaXRpYWxpemVycyhlKTtsZXQgcj1pLmdldChuLm5hbWUoKSk7aWYodm9pZCAwPT09cil7Y29uc3QgdD1uZXcgYyxlPXMuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tT1JURm9ybWF0KG4pLG89cy5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8obi5kYXRhVHlwZSgpKTt0LnR5cGU9e3NoYXBlOntkaW1zOmV9LHRlbnNvclR5cGU6b30scj10aGlzLl9hbGxEYXRhLnB1c2godCktMSxpLnNldChuLm5hbWUoKSxyKX10aGlzLl9hbGxEYXRhW3JdLl9mcm9tPS0xLHRoaXMuX2FsbERhdGFbcl0udGVuc29yPWEuVGVuc29yLmZyb21PcnRUZW5zb3Iobil9Zm9yKGxldCB0PTA7dDx0aGlzLl9hbGxEYXRhLmxlbmd0aDt0KyspdGhpcy5fYWxsRGF0YVt0XS50ZW5zb3J8fCh0aGlzLl9hbGxJbnB1dEluZGljZXMucHVzaCh0KSx0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2gocFt0XSkpO2ZvcihsZXQgZT0wO2U8dC5vdXRwdXRzTGVuZ3RoKCk7ZSsrKXtjb25zdCBuPXQub3V0cHV0cyhlKTtpZihpLmhhcyhuKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgb3V0cHV0IG5hbWU6ICR7bn1gKTtjb25zdCByPXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyktMTtpLnNldChuLHIpLHRoaXMuX2FsbE91dHB1dEluZGljZXMucHVzaChyKSx0aGlzLl9hbGxPdXRwdXROYW1lcy5wdXNoKG4pfWlmKCF0Lm5vZGVzKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGVcIik7Zm9yKGxldCBlPTA7ZTx0Lm5vZGVzTGVuZ3RoKCk7ZSsrKXtjb25zdCBuPXQubm9kZXMoZSk7bGV0IHI9bi5uYW1lKCk7aWYoIXIpZm9yKGxldCB0PTA7cj1gdW5uYW1lZF8ke24ub3BUeXBlKCl9XyR7dH1gLG8uaGFzKHIpO3QrKyk7aWYoby5oYXMocikpdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG5vZGUgbmFtZTogJHtyfWApO2NvbnN0IGk9dGhpcy5fbm9kZXMucHVzaChuZXcgbChuLHIpKS0xO28uc2V0KHIsaSl9Zm9yKGxldCBlPTA7ZTx0aGlzLl9ub2Rlcy5sZW5ndGg7ZSsrKXtjb25zdCBuPXRoaXMuX25vZGVzW2VdLHI9dC5ub2RlcyhlKTtpZihudWxsPT1yKXRocm93IG5ldyBFcnJvcihgTm8gbm9kZSBleGlzdHMgYXQgaW5kZXggJHtlfWApO2lmKDA9PT0obnVsbD09cj92b2lkIDA6ci5vdXRwdXRzTGVuZ3RoKCkpKXRocm93IG5ldyBFcnJvcihgbWlzc2luZyBvdXRwdXQgZm9yIG5vZGU6ICR7ci5uYW1lfWApO2ZvcihsZXQgdD0wO3Q8KG51bGw9PXI/dm9pZCAwOnIub3V0cHV0c0xlbmd0aCgpKTt0Kyspe2NvbnN0IG89bnVsbD09cj92b2lkIDA6ci5vdXRwdXRzKHQpO2xldCBzPWkuZ2V0KG8pO2lmKHZvaWQgMD09PXMmJihzPXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyktMSxpLnNldChvLHMpKSxuLm91dHB1dHMucHVzaChzKSx2b2lkIDAhPT10aGlzLl9hbGxEYXRhW3NdLl9mcm9tKXRocm93IG5ldyBFcnJvcihgbXVsdGlwbGUgbm9kZXMgb3V0cHV0IHRvIG9uZSBkYXRhIHZhbHVlOiAke3N9YCk7aWYodGhpcy5fYWxsRGF0YVtzXS5fZnJvbT1lLFwiQ29uc3RhbnRcIj09PXIub3BUeXBlKCkpe2lmKDEhPT1yLmF0dHJpYnV0ZXNMZW5ndGgoKXx8IXIuYXR0cmlidXRlcygwKS50KCkpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBhdHRyaWJ1dGVzIG9yIG1pc3NpbmcgdGVuc29yIHZhbHVlIGluIGF0dHJpYnV0ZXMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3JcIik7aWYoMSE9PXIub3V0cHV0c0xlbmd0aCgpKXRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgb3V0cHV0IG9yIGluY29ycmVjdCBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvclwiKTtuLm91dHB1dHMucG9wKCksbi5leGVjdXRlTm9kZT0hMSx0aGlzLl9hbGxEYXRhW3NdLl9mcm9tPS0xLHRoaXMuX2FsbERhdGFbc10udGVuc29yPWEuVGVuc29yLmZyb21PcnRUZW5zb3Ioci5hdHRyaWJ1dGVzKDApLnQoKSl9fX1mb3IobGV0IGU9MDtlPHRoaXMuX25vZGVzLmxlbmd0aDtlKyspe2NvbnN0IG49dGhpcy5fbm9kZXNbZV0scj10Lm5vZGVzKGUpO2lmKDA9PT1yLmlucHV0c0xlbmd0aCgpKXRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCBmb3Igbm9kZTogJHtyLm5hbWV9YCk7Zm9yKGxldCB0PTA7dDxyLmlucHV0c0xlbmd0aCgpO3QrKyl7Y29uc3Qgbz1yLmlucHV0cyh0KSxhPWkuZ2V0KG8pO2lmKHZvaWQgMD09PWEpdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgaW5wdXQgJyR7b30nIGZvciBub2RlOiAke3IubmFtZSgpfWApO24uaW5wdXRzLnB1c2goYSksdGhpcy5fYWxsRGF0YVthXS5fdG8ucHVzaChlKX19fWNoZWNrSXNBY3ljbGljKCl7Y29uc3QgdD1uZXcgU2V0O3RoaXMuX2FsbElucHV0SW5kaWNlcy5mb3JFYWNoKChlPT57dGhpcy5fYWxsRGF0YVtlXS5fdG8uZm9yRWFjaCgoZT0+e3QuYWRkKGUpfSkpfSkpO2NvbnN0IGU9QXJyYXkuZnJvbSh0KSxuPW5ldyBBcnJheSh0aGlzLl9ub2Rlcy5sZW5ndGgpLmZpbGwoXCJ3aGl0ZVwiKTtmb3IoO2UubGVuZ3RoPjA7KXtjb25zdCB0PWUucG9wKCk7XCJncmF5XCI9PT1uW3RdP25bdF09XCJibGFja1wiOihlLnB1c2godCksblt0XT1cImdyYXlcIix0aGlzLl9ub2Rlc1t0XS5vdXRwdXRzLmZvckVhY2goKHI9Pntjb25zdCBpPXRoaXMuX2FsbERhdGFbcl07aWYodm9pZCAwIT09aS50ZW5zb3IpdGhyb3cgbmV3IEVycm9yKFwibm9kZSBvdXRwdXRzIHNob3VsZCBub3QgYmUgaW5pdGlhbGl6ZWRcIik7aWYoaS5fZnJvbSE9PXQpdGhyb3cgbmV3IEVycm9yKFwiZnJvbSBwcm9wZXJ0eSBvZiB0aGUgVmFsdWUgb2JqZWN0IGRvZXNuJ3QgbWF0Y2ggaW5kZXggb2YgTm9kZSBiZWluZyBwcm9jZXNzZWRcIik7aS5fdG8uZm9yRWFjaCgodD0+e2lmKFwiZ3JheVwiPT09blt0XSl0aHJvdyBuZXcgRXJyb3IoXCJtb2RlbCBncmFwaCBpcyBjeWNsaWNcIik7XCJ3aGl0ZVwiPT09blt0XSYmZS5wdXNoKHQpfSkpfSkpKX19dHJhbnNmb3JtR3JhcGgodCl7dGhpcy5yZW1vdmVBbGxJZGVudGl0eU5vZGVzKCksdGhpcy5yZW1vdmVBbGxEcm9wb3V0Tm9kZXMoKSx0aGlzLmZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCksdCYmdC50cmFuc2Zvcm1HcmFwaCh0aGlzKSx0aGlzLmZpbmFsaXplR3JhcGgoKX1maW5hbGl6ZUdyYXBoKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPHRoaXMuX25vZGVzLmxlbmd0aDtlKyspdGhpcy5fbm9kZXNbZV0uZXhlY3V0ZU5vZGU/dD4wJiYodGhpcy5fbm9kZXNbZV0uaW5wdXRzLmZvckVhY2goKG49Pntjb25zdCByPXRoaXMuX2FsbERhdGFbbl0uX3RvLmluZGV4T2YoZSt0KTstMSE9PXImJih0aGlzLl9hbGxEYXRhW25dLl90b1tyXT1lKX0pKSx0aGlzLl9ub2Rlc1tlXS5vdXRwdXRzLmZvckVhY2goKG49Pnt0aGlzLl9hbGxEYXRhW25dLl9mcm9tJiZ0aGlzLl9hbGxEYXRhW25dLl9mcm9tPT09ZSt0JiYodGhpcy5fYWxsRGF0YVtuXS5fZnJvbT1lKX0pKSk6KHQrKyx0aGlzLl9ub2Rlc1tlXS5vdXRwdXRzLmZvckVhY2goKHQ9Pnt0aGlzLl9hbGxEYXRhW3RdLl9mcm9tPS0yfSkpLHRoaXMuX25vZGVzLnNwbGljZShlLDEpLGUtLSk7dD0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fYWxsRGF0YS5sZW5ndGg7ZSsrKWlmKC0yIT09dGhpcy5fYWxsRGF0YVtlXS5mcm9tfHwtMSE9PXRoaXMuX2FsbE91dHB1dEluZGljZXMuaW5kZXhPZihlK3QpKXtpZih0PjApe2xldCBuPS0xO3ZvaWQgMCE9PXRoaXMuX2FsbERhdGFbZV0uZnJvbSYmLTEhPT10aGlzLl9hbGxEYXRhW2VdLmZyb20/KG49dGhpcy5fbm9kZXNbdGhpcy5fYWxsRGF0YVtlXS5mcm9tXS5vdXRwdXRzLmluZGV4T2YoZSt0KSwtMSE9PW4mJih0aGlzLl9ub2Rlc1t0aGlzLl9hbGxEYXRhW2VdLmZyb21dLm91dHB1dHNbbl09ZSkpOihuPXRoaXMuX2FsbElucHV0SW5kaWNlcy5pbmRleE9mKGUrdCksLTEhPT1uJiYodGhpcy5fYWxsSW5wdXRJbmRpY2VzW25dPWUpKSx0aGlzLl9hbGxEYXRhW2VdLnRvLmZvckVhY2goKHI9PntuPXRoaXMuX25vZGVzW3JdLmlucHV0cy5pbmRleE9mKGUrdCksLTEhPT1uJiYodGhpcy5fbm9kZXNbcl0uaW5wdXRzW25dPWUpfSkpLDA9PT10aGlzLl9hbGxEYXRhW2VdLnRvLmxlbmd0aCYmKG49dGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5pbmRleE9mKGUrdCksLTEhPT1uJiYodGhpcy5fYWxsT3V0cHV0SW5kaWNlc1tuXT1lKSl9fWVsc2UgdCsrLHRoaXMuX2FsbERhdGEuc3BsaWNlKGUsMSksZS0tfWRlbGV0ZU5vZGUodCl7Y29uc3QgZT10aGlzLl9ub2Rlc1t0XTtpZihlLm91dHB1dHMubGVuZ3RoPjEpZm9yKGxldCB0PTE7dDxlLm91dHB1dHMubGVuZ3RoO3QrKylpZih0aGlzLl9hbGxEYXRhW2Uub3V0cHV0c1t0XV0udG8ubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBkZWxldGlvbiB3aXRoIG1vcmUgdGhhbiBvbmUgb3V0cHV0IGNvbm5lY3RlZCB0byBvdGhlciBub2RlcyBpcyBub3Qgc3VwcG9ydGVkLiBcIik7ZS5leGVjdXRlTm9kZT0hMTtjb25zdCBuPWUuaW5wdXRzWzBdLHI9ZS5vdXRwdXRzWzBdLGk9dGhpcy5fYWxsRGF0YVtyXS50byxvPXRoaXMuX2FsbERhdGFbbl0udG8uaW5kZXhPZih0KTtpZigtMT09PW8pdGhyb3cgbmV3IEVycm9yKFwiVGhlIFZhbHVlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIGN1cnJlbnQgTm9kZSBpbiBpdCdzICd0bycgcHJvcGVydHkgXCIpO3RoaXMuX2FsbERhdGFbbl0udG8uc3BsaWNlKG8sMSksdGhpcy5fYWxsRGF0YVtyXS5fdG89W107Y29uc3QgYT10aGlzLl9hbGxPdXRwdXRJbmRpY2VzLmluZGV4T2Yocik7aWYoLTEhPT1hJiYodGhpcy5fYWxsT3V0cHV0SW5kaWNlc1thXT1uKSxpJiZpLmxlbmd0aD4wKWZvcihjb25zdCB0IG9mIGkpe2NvbnN0IGU9dGhpcy5fbm9kZXNbdF0uaW5wdXRzLmluZGV4T2Yocik7aWYoLTE9PT1lKXRocm93IG5ldyBFcnJvcihcIlRoZSBOb2RlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIG91dHB1dCBWYWx1ZSBpbiBpdCdzICdpbnB1dHMnIHByb3BlcnR5IFwiKTt0aGlzLl9ub2Rlc1t0XS5pbnB1dHNbZV09bix0aGlzLl9hbGxEYXRhW25dLnRvLnB1c2godCl9fXJlbW92ZUFsbERyb3BvdXROb2Rlcygpe2xldCB0PTA7Zm9yKGNvbnN0IGUgb2YgdGhpcy5fbm9kZXMpe2lmKFwiRHJvcG91dFwiPT09ZS5vcFR5cGUpe2lmKDEhPT1lLmlucHV0cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRHJvcG91dCBub2RlcyBzaG91bGQgb25seSBjb250YWluIG9uZSBpbnB1dC4gXCIpO2lmKDEhPT1lLm91dHB1dHMubGVuZ3RoJiYyIT09ZS5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEcm9wb3V0IG5vZGVzIHNob3VsZCBjb250YWluIGVpdGhlciAxIG9yIDIgb3V0cHV0KHMpXCIpO2lmKDI9PT1lLm91dHB1dHMubGVuZ3RoJiYwIT09dGhpcy5fYWxsRGF0YVtlLm91dHB1dHNbMV1dLl90by5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRHJvcG91dCBub2RlcydzIHNlY29uZCBvdXRwdXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2VkIGJ5IG90aGVyIG5vZGVzXCIpO3RoaXMuZGVsZXRlTm9kZSh0KX10Kyt9fXJlbW92ZUFsbElkZW50aXR5Tm9kZXMoKXtsZXQgdD0wO2Zvcihjb25zdCBlIG9mIHRoaXMuX25vZGVzKVwiSWRlbnRpdHlcIj09PWUub3BUeXBlJiZ0aGlzLmRlbGV0ZU5vZGUodCksdCsrfWlzQWN0aXZhdGlvbih0KXtzd2l0Y2godC5vcFR5cGUpe2Nhc2VcIlJlbHVcIjpjYXNlXCJTaWdtb2lkXCI6Y2FzZVwiQ2xpcFwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCl7Zm9yKGNvbnN0IHQgb2YgdGhpcy5fbm9kZXMpaWYoXCJDb252XCI9PT10Lm9wVHlwZSl7Y29uc3QgZT10aGlzLl9hbGxEYXRhW3Qub3V0cHV0c1swXV0uX3RvO2lmKDE9PT1lLmxlbmd0aCYmdGhpcy5pc0FjdGl2YXRpb24odGhpcy5fbm9kZXNbZVswXV0pKXtjb25zdCBuPXRoaXMuX25vZGVzW2VbMF1dO2lmKFwiQ2xpcFwiPT09bi5vcFR5cGUpaWYoMT09PW4uaW5wdXRzLmxlbmd0aCl0cnl7dC5hdHRyaWJ1dGVzLnNldChcImFjdGl2YXRpb25fcGFyYW1zXCIsXCJmbG9hdHNcIixbbi5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibWluXCIpLG4uYXR0cmlidXRlcy5nZXRGbG9hdChcIm1heFwiKV0pfWNhdGNoKGUpe3QuYXR0cmlidXRlcy5zZXQoXCJhY3RpdmF0aW9uX3BhcmFtc1wiLFwiZmxvYXRzXCIsW3MuTUlOX0NMSVAscy5NQVhfQ0xJUF0pfWVsc2V7aWYoIShuLmlucHV0cy5sZW5ndGg+PTMmJnZvaWQgMCE9PXRoaXMuX2FsbERhdGFbbi5pbnB1dHNbMV1dLnRlbnNvciYmdm9pZCAwIT09dGhpcy5fYWxsRGF0YVtuLmlucHV0c1syXV0udGVuc29yKSljb250aW51ZTt0LmF0dHJpYnV0ZXMuc2V0KFwiYWN0aXZhdGlvbl9wYXJhbXNcIixcImZsb2F0c1wiLFt0aGlzLl9hbGxEYXRhW24uaW5wdXRzWzFdXS50ZW5zb3IuZmxvYXREYXRhWzBdLHRoaXMuX2FsbERhdGFbbi5pbnB1dHNbMl1dLnRlbnNvci5mbG9hdERhdGFbMF1dKX10LmF0dHJpYnV0ZXMuc2V0KFwiYWN0aXZhdGlvblwiLFwic3RyaW5nXCIsbi5vcFR5cGUpLHRoaXMuZGVsZXRlTm9kZShlWzBdKX19fX19LDYyMzE6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLm5vdz1lLlByb2ZpbGVyPWUuTG9nZ2VyPXZvaWQgMDtjb25zdCBuPXt2ZXJib3NlOjFlMyxpbmZvOjJlMyx3YXJuaW5nOjRlMyxlcnJvcjo1ZTMsZmF0YWw6NmUzfSxyPXtub25lOm5ldyBjbGFzc3tsb2codCxlLG4pe319LGNvbnNvbGU6bmV3IGNsYXNze2xvZyh0LGUsbil7Y29uc29sZS5sb2coYCR7dGhpcy5jb2xvcih0KX0gJHtuP1wiXHUwMDFiWzM1bVwiK24rXCJcdTAwMWJbMG0gXCI6XCJcIn0ke2V9YCl9Y29sb3IodCl7c3dpdGNoKHQpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm5cIlx1MDAxYlszNDs0MG12XHUwMDFiWzBtXCI7Y2FzZVwiaW5mb1wiOnJldHVyblwiXHUwMDFiWzMybWlcdTAwMWJbMG1cIjtjYXNlXCJ3YXJuaW5nXCI6cmV0dXJuXCJcdTAwMWJbMzA7NDNtd1x1MDAxYlswbVwiO2Nhc2VcImVycm9yXCI6cmV0dXJuXCJcdTAwMWJbMzE7NDBtZVx1MDAxYlswbVwiO2Nhc2VcImZhdGFsXCI6cmV0dXJuXCJcdTAwMWJbMTAxbWZcdTAwMWJbMG1cIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgc2V2ZXJpdHk6ICR7dH1gKX19fX0saT17cHJvdmlkZXI6XCJjb25zb2xlXCIsbWluaW1hbFNldmVyaXR5Olwid2FybmluZ1wiLGxvZ0RhdGVUaW1lOiEwLGxvZ1NvdXJjZUxvY2F0aW9uOiExfTtsZXQgbz17XCJcIjppfTtmdW5jdGlvbiBhKHQsZSxuLHIpe2lmKHZvaWQgMD09PWUpcmV0dXJuIGk9dCx7dmVyYm9zZTphLnZlcmJvc2UuYmluZChudWxsLGkpLGluZm86YS5pbmZvLmJpbmQobnVsbCxpKSx3YXJuaW5nOmEud2FybmluZy5iaW5kKG51bGwsaSksZXJyb3I6YS5lcnJvci5iaW5kKG51bGwsaSksZmF0YWw6YS5mYXRhbC5iaW5kKG51bGwsaSl9O2lmKHZvaWQgMD09PW4pcyh0LGUpO2Vsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIG4mJnZvaWQgMD09PXIpcyh0LGUpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIG4mJnZvaWQgMD09PXIpcyh0LG4sMCxlKTtlbHNle2lmKFwic3RyaW5nXCIhPXR5cGVvZiBufHxcIm51bWJlclwiIT10eXBlb2Ygcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW5wdXQgaXMgdmFsaWRcIik7cyh0LG4sMCxlKX12YXIgaX1mdW5jdGlvbiBzKHQsZSxpLGEpe2NvbnN0IHM9b1thfHxcIlwiXXx8b1tcIlwiXTtuW3RdPG5bcy5taW5pbWFsU2V2ZXJpdHldfHwocy5sb2dEYXRlVGltZSYmKGU9YCR7KG5ldyBEYXRlKS50b0lTT1N0cmluZygpfXwke2V9YCkscy5sb2dTb3VyY2VMb2NhdGlvbixyW3MucHJvdmlkZXJdLmxvZyh0LGUsYSkpfSFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe289e30sbihcIlwiLHR8fHt9KX1mdW5jdGlvbiBuKHQsbil7aWYoXCIqXCI9PT10KWUobik7ZWxzZXtjb25zdCBlPW9bdF18fGk7b1t0XT17cHJvdmlkZXI6bi5wcm92aWRlcnx8ZS5wcm92aWRlcixtaW5pbWFsU2V2ZXJpdHk6bi5taW5pbWFsU2V2ZXJpdHl8fGUubWluaW1hbFNldmVyaXR5LGxvZ0RhdGVUaW1lOnZvaWQgMD09PW4ubG9nRGF0ZVRpbWU/ZS5sb2dEYXRlVGltZTpuLmxvZ0RhdGVUaW1lLGxvZ1NvdXJjZUxvY2F0aW9uOnZvaWQgMD09PW4ubG9nU291cmNlTG9jYXRpb24/ZS5sb2dTb3VyY2VMb2NhdGlvbjpuLmxvZ1NvdXJjZUxvY2F0aW9ufX19dC52ZXJib3NlPWZ1bmN0aW9uKGUsbil7dChcInZlcmJvc2VcIixlLG4pfSx0LmluZm89ZnVuY3Rpb24oZSxuKXt0KFwiaW5mb1wiLGUsbil9LHQud2FybmluZz1mdW5jdGlvbihlLG4pe3QoXCJ3YXJuaW5nXCIsZSxuKX0sdC5lcnJvcj1mdW5jdGlvbihlLG4pe3QoXCJlcnJvclwiLGUsbil9LHQuZmF0YWw9ZnVuY3Rpb24oZSxuKXt0KFwiZmF0YWxcIixlLG4pfSx0LnJlc2V0PWUsdC5zZXQ9bix0LnNldFdpdGhFbnY9ZnVuY3Rpb24odCl7Y29uc3QgZT17fTt0LmxvZ0xldmVsJiYoZS5taW5pbWFsU2V2ZXJpdHk9dC5sb2dMZXZlbCksbihcIlwiLGUpfX0oYXx8KGE9e30pKSxlLkxvZ2dlcj1hO2NsYXNzIHV7Y29uc3RydWN0b3IodCxlLG4scixpLG8pe3RoaXMuY2F0ZWdvcnk9dCx0aGlzLm5hbWU9ZSx0aGlzLnN0YXJ0VGltZT1uLHRoaXMuZW5kQ2FsbGJhY2s9cix0aGlzLnRpbWVyPWksdGhpcy5jdHg9b31lbmQoKXtyZXR1cm4gdGhpcy5lbmRDYWxsYmFjayh0aGlzKX1hc3luYyBjaGVja1RpbWVyKCl7aWYodm9pZCAwPT09dGhpcy5jdHh8fHZvaWQgMD09PXRoaXMudGltZXIpdGhyb3cgbmV3IEVycm9yKFwiTm8gd2ViZ2wgdGltZXIgZm91bmRcIik7cmV0dXJuIHRoaXMuY3R4LmVuZFRpbWVyKCksdGhpcy5jdHgud2FpdEZvclF1ZXJ5QW5kR2V0VGltZSh0aGlzLnRpbWVyKX19Y2xhc3MgY3tjb25zdHJ1Y3Rvcih0LGUsbixyKXt0aGlzLmNhdGVnb3J5PXQsdGhpcy5uYW1lPWUsdGhpcy5zdGFydFRpbWU9bix0aGlzLmVuZFRpbWU9cn19ZS5Qcm9maWxlcj1jbGFzc3tzdGF0aWMgY3JlYXRlKHQpe3JldHVybiB2b2lkIDA9PT10P25ldyB0aGlzOm5ldyB0aGlzKHQubWF4TnVtYmVyRXZlbnRzLHQuZmx1c2hCYXRjaFNpemUsdC5mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHMpfWNvbnN0cnVjdG9yKHQsZSxuKXt0aGlzLl9zdGFydGVkPSExLHRoaXMuX2ZsdXNoUG9pbnRlcj0wLHRoaXMuX3N0YXJ0ZWQ9ITEsdGhpcy5fbWF4TnVtYmVyRXZlbnRzPXZvaWQgMD09PXQ/MWU0OnQsdGhpcy5fZmx1c2hCYXRjaFNpemU9dm9pZCAwPT09ZT8xMDplLHRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcz12b2lkIDA9PT1uPzVlMzpufXN0YXJ0KCl7dGhpcy5fc3RhcnRlZD0hMCx0aGlzLl90aW1pbmdFdmVudHM9W10sdGhpcy5fZmx1c2hUaW1lPSgwLGUubm93KSgpLHRoaXMuX2ZsdXNoUG9pbnRlcj0wfXN0b3AoKXtmb3IodGhpcy5fc3RhcnRlZD0hMTt0aGlzLl9mbHVzaFBvaW50ZXI8dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDt0aGlzLl9mbHVzaFBvaW50ZXIrKyl0aGlzLmxvZ09uZUV2ZW50KHRoaXMuX3RpbWluZ0V2ZW50c1t0aGlzLl9mbHVzaFBvaW50ZXJdKX1ldmVudCh0LGUsbixyKXtjb25zdCBpPXRoaXMuX3N0YXJ0ZWQ/dGhpcy5iZWdpbih0LGUscik6dm9pZCAwO2xldCBvPSExO2NvbnN0IGE9bigpO2lmKGEmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGEudGhlbilyZXR1cm4gbz0hMCxuZXcgUHJvbWlzZSgoKHQsZSk9PnthLnRoZW4oKGFzeW5jIGU9PntpJiZhd2FpdCBpLmVuZCgpLHQoZSl9KSwoYXN5bmMgdD0+e2kmJmF3YWl0IGkuZW5kKCksZSh0KX0pKX0pKTtpZighbyYmaSl7Y29uc3QgdD1pLmVuZCgpO2lmKHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQudGhlbilyZXR1cm4gbmV3IFByb21pc2UoKChlLG4pPT57dC50aGVuKCgoKT0+e2UoYSl9KSwodD0+e24odCl9KSl9KSl9cmV0dXJuIGF9YmVnaW4odCxuLHIpe2lmKCF0aGlzLl9zdGFydGVkKXRocm93IG5ldyBFcnJvcihcInByb2ZpbGVyIGlzIG5vdCBzdGFydGVkIHlldFwiKTtpZih2b2lkIDA9PT1yKXtjb25zdCByPSgwLGUubm93KSgpO3JldHVybiB0aGlzLmZsdXNoKHIpLG5ldyB1KHQsbixyLCh0PT50aGlzLmVuZFN5bmModCkpKX17Y29uc3QgZT1yLmJlZ2luVGltZXIoKTtyZXR1cm4gbmV3IHUodCxuLDAsKGFzeW5jIHQ9PnRoaXMuZW5kKHQpKSxlLHIpfX1hc3luYyBlbmQodCl7Y29uc3QgZT1hd2FpdCB0LmNoZWNrVGltZXIoKTt0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoPHRoaXMuX21heE51bWJlckV2ZW50cyYmKHRoaXMuX3RpbWluZ0V2ZW50cy5wdXNoKG5ldyBjKHQuY2F0ZWdvcnksdC5uYW1lLHQuc3RhcnRUaW1lLGUpKSx0aGlzLmZsdXNoKGUpKX1lbmRTeW5jKHQpe2NvbnN0IG49KDAsZS5ub3cpKCk7dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDx0aGlzLl9tYXhOdW1iZXJFdmVudHMmJih0aGlzLl90aW1pbmdFdmVudHMucHVzaChuZXcgYyh0LmNhdGVnb3J5LHQubmFtZSx0LnN0YXJ0VGltZSxuKSksdGhpcy5mbHVzaChuKSl9bG9nT25lRXZlbnQodCl7ZS5Mb2dnZXIudmVyYm9zZShgUHJvZmlsZXIuJHt0LmNhdGVnb3J5fWAsYCR7KHQuZW5kVGltZS10LnN0YXJ0VGltZSkudG9GaXhlZCgyKX1tcyBvbiBldmVudCAnJHt0Lm5hbWV9JyBhdCAke3QuZW5kVGltZS50b0ZpeGVkKDIpfWApfWZsdXNoKHQpe2lmKHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGgtdGhpcy5fZmx1c2hQb2ludGVyPj10aGlzLl9mbHVzaEJhdGNoU2l6ZXx8dC10aGlzLl9mbHVzaFRpbWU+PXRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyl7Zm9yKGNvbnN0IHQ9dGhpcy5fZmx1c2hQb2ludGVyO3RoaXMuX2ZsdXNoUG9pbnRlcjx0K3RoaXMuX2ZsdXNoQmF0Y2hTaXplJiZ0aGlzLl9mbHVzaFBvaW50ZXI8dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDt0aGlzLl9mbHVzaFBvaW50ZXIrKyl0aGlzLmxvZ09uZUV2ZW50KHRoaXMuX3RpbWluZ0V2ZW50c1t0aGlzLl9mbHVzaFBvaW50ZXJdKTt0aGlzLl9mbHVzaFRpbWU9KDAsZS5ub3cpKCl9fWdldCBzdGFydGVkKCl7cmV0dXJuIHRoaXMuX3N0YXJ0ZWR9fSxlLm5vdz1cInVuZGVmaW5lZFwiIT10eXBlb2YgcGVyZm9ybWFuY2UmJnBlcmZvcm1hbmNlLm5vdz8oKT0+cGVyZm9ybWFuY2Uubm93KCk6RGF0ZS5ub3d9LDI2NDQ6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuTW9kZWw9dm9pZCAwO2NvbnN0IHI9big1Njg2KSxpPW4oMTQ0Niksbz1uKDcwNzApLGE9big5Mzk1KSxzPW4oMjUxNyk7dmFyIHU9YS5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO2UuTW9kZWw9Y2xhc3N7Y29uc3RydWN0b3IoKXt9bG9hZCh0LGUsbil7aWYoIW4pdHJ5e3JldHVybiB2b2lkIHRoaXMubG9hZEZyb21Pbm54Rm9ybWF0KHQsZSl9Y2F0Y2godCl7aWYodm9pZCAwIT09bil0aHJvdyB0fXRoaXMubG9hZEZyb21PcnRGb3JtYXQodCxlKX1sb2FkRnJvbU9ubnhGb3JtYXQodCxlKXtjb25zdCBuPWkub25ueC5Nb2RlbFByb3RvLmRlY29kZSh0KTtpZihzLkxvbmdVdGlsLmxvbmdUb051bWJlcihuLmlyVmVyc2lvbik8Myl0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IHN1cHBvcnQgT05OWCBtb2RlbCB3aXRoIElSX1ZFUlNJT04+PTNcIik7dGhpcy5fb3BzZXRzPW4ub3BzZXRJbXBvcnQubWFwKCh0PT4oe2RvbWFpbjp0LmRvbWFpbix2ZXJzaW9uOnMuTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHQudmVyc2lvbil9KSkpLHRoaXMuX2dyYXBoPW8uR3JhcGguZnJvbShuLmdyYXBoLGUpfWxvYWRGcm9tT3J0Rm9ybWF0KHQsZSl7Y29uc3Qgbj1uZXcgci5mbGF0YnVmZmVycy5CeXRlQnVmZmVyKHQpLGk9dS5JbmZlcmVuY2VTZXNzaW9uLmdldFJvb3RBc0luZmVyZW5jZVNlc3Npb24obikubW9kZWwoKTtpZihzLkxvbmdVdGlsLmxvbmdUb051bWJlcihpLmlyVmVyc2lvbigpKTwzKXRocm93IG5ldyBFcnJvcihcIm9ubHkgc3VwcG9ydCBPTk5YIG1vZGVsIHdpdGggSVJfVkVSU0lPTj49M1wiKTt0aGlzLl9vcHNldHM9W107Zm9yKGxldCB0PTA7dDxpLm9wc2V0SW1wb3J0TGVuZ3RoKCk7dCsrKXtjb25zdCBlPWkub3BzZXRJbXBvcnQodCk7dGhpcy5fb3BzZXRzLnB1c2goe2RvbWFpbjpudWxsPT1lP3ZvaWQgMDplLmRvbWFpbigpLHZlcnNpb246cy5Mb25nVXRpbC5sb25nVG9OdW1iZXIoZS52ZXJzaW9uKCkpfSl9dGhpcy5fZ3JhcGg9by5HcmFwaC5mcm9tKGkuZ3JhcGgoKSxlKX1nZXQgZ3JhcGgoKXtyZXR1cm4gdGhpcy5fZ3JhcGh9Z2V0IG9wc2V0cygpe3JldHVybiB0aGlzLl9vcHNldHN9fX0sNzgyOih0LGUpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5GTE9BVF9UWVBFUz1lLklOVF9UWVBFUz1lLk5VTUJFUl9UWVBFUz12b2lkIDAsZS5OVU1CRVJfVFlQRVM9W1wiZmxvYXQzMlwiLFwiZmxvYXQ2NFwiLFwiaW50MzJcIixcImludDE2XCIsXCJpbnQ4XCIsXCJ1aW50MTZcIixcInVpbnQzMlwiLFwidWludDhcIl0sZS5JTlRfVFlQRVM9W1wiaW50MzJcIixcImludDE2XCIsXCJpbnQ4XCIsXCJ1aW50MTZcIixcInVpbnQzMlwiLFwidWludDhcIl0sZS5GTE9BVF9UWVBFUz1bXCJmbG9hdDMyXCIsXCJmbG9hdDY0XCJdfSwxMDQ3Oih0LGUpPT57XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbih0LGUpe2lmKGUuZW5kc1dpdGgoXCIrXCIpKXtjb25zdCBuPU51bWJlci5wYXJzZUludChlLnN1YnN0cmluZygwLGUubGVuZ3RoLTEpLDEwKTtyZXR1cm4haXNOYU4obikmJm48PXR9aWYoMj09PWUuc3BsaXQoXCItXCIpLmxlbmd0aCl7Y29uc3Qgbj1lLnNwbGl0KFwiLVwiKSxyPU51bWJlci5wYXJzZUludChuWzBdLDEwKSxpPU51bWJlci5wYXJzZUludChuWzFdLDEwKTtyZXR1cm4haXNOYU4ocikmJiFpc05hTihpKSYmcjw9dCYmdDw9aX1yZXR1cm4gTnVtYmVyLnBhcnNlSW50KGUsMTApPT09dH1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnJlc29sdmVPcGVyYXRvcj12b2lkIDAsZS5yZXNvbHZlT3BlcmF0b3I9ZnVuY3Rpb24odCxlLHIpe2Zvcihjb25zdCBpIG9mIHIpe2NvbnN0IHI9aVswXSxvPWlbMV0sYT1pWzJdLHM9aVszXSx1PWlbNF07aWYodC5vcFR5cGU9PT1yKWZvcihjb25zdCB0IG9mIGUpaWYoKHQuZG9tYWluPT09b3x8XCJhaS5vbm54XCI9PT10LmRvbWFpbiYmXCJcIj09PW8pJiZuKHQudmVyc2lvbixhKSlyZXR1cm57b3BJbXBsOnMsb3BJbml0OnV9fXRocm93IG5ldyBUeXBlRXJyb3IoYGNhbm5vdCByZXNvbHZlIG9wZXJhdG9yICcke3Qub3BUeXBlfScgd2l0aCBvcHNldHM6ICR7ZS5tYXAoKHQ9PmAke3QuZG9tYWlufHxcImFpLm9ubnhcIn0gdiR7dC52ZXJzaW9ufWApKS5qb2luKFwiLCBcIil9YCl9fSw5Mzk1Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLm9ubnhydW50aW1lPXZvaWQgMDtjb25zdCByPW4oNTY4Nik7dmFyIGksbztpPWUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSxmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0LlVOREVGSU5FRD0wXT1cIlVOREVGSU5FRFwiLHRbdC5GTE9BVD0xXT1cIkZMT0FUXCIsdFt0LklOVD0yXT1cIklOVFwiLHRbdC5TVFJJTkc9M109XCJTVFJJTkdcIix0W3QuVEVOU09SPTRdPVwiVEVOU09SXCIsdFt0LkdSQVBIPTVdPVwiR1JBUEhcIix0W3QuRkxPQVRTPTZdPVwiRkxPQVRTXCIsdFt0LklOVFM9N109XCJJTlRTXCIsdFt0LlNUUklOR1M9OF09XCJTVFJJTkdTXCIsdFt0LlRFTlNPUlM9OV09XCJURU5TT1JTXCIsdFt0LkdSQVBIUz0xMF09XCJHUkFQSFNcIix0W3QuU1BBUlNFX1RFTlNPUj0xMV09XCJTUEFSU0VfVEVOU09SXCIsdFt0LlNQQVJTRV9URU5TT1JTPTEyXT1cIlNQQVJTRV9URU5TT1JTXCJ9KGU9dC5BdHRyaWJ1dGVUeXBlfHwodC5BdHRyaWJ1dGVUeXBlPXt9KSl9KChvPWkuZXhwZXJpbWVudGFsfHwoaS5leHBlcmltZW50YWw9e30pKS5mYnN8fChvLmZicz17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7bGV0IGU7IWZ1bmN0aW9uKHQpe3RbdC5VTktOT1dOPTBdPVwiVU5LTk9XTlwiLHRbdC5WQUxVRT0xXT1cIlZBTFVFXCIsdFt0LlBBUkFNPTJdPVwiUEFSQU1cIn0oZT10LkRpbWVuc2lvblZhbHVlVHlwZXx8KHQuRGltZW5zaW9uVmFsdWVUeXBlPXt9KSl9KHQuZmJzfHwodC5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7bGV0IGU7IWZ1bmN0aW9uKHQpe3RbdC5VTkRFRklORUQ9MF09XCJVTkRFRklORURcIix0W3QuRkxPQVQ9MV09XCJGTE9BVFwiLHRbdC5VSU5UOD0yXT1cIlVJTlQ4XCIsdFt0LklOVDg9M109XCJJTlQ4XCIsdFt0LlVJTlQxNj00XT1cIlVJTlQxNlwiLHRbdC5JTlQxNj01XT1cIklOVDE2XCIsdFt0LklOVDMyPTZdPVwiSU5UMzJcIix0W3QuSU5UNjQ9N109XCJJTlQ2NFwiLHRbdC5TVFJJTkc9OF09XCJTVFJJTkdcIix0W3QuQk9PTD05XT1cIkJPT0xcIix0W3QuRkxPQVQxNj0xMF09XCJGTE9BVDE2XCIsdFt0LkRPVUJMRT0xMV09XCJET1VCTEVcIix0W3QuVUlOVDMyPTEyXT1cIlVJTlQzMlwiLHRbdC5VSU5UNjQ9MTNdPVwiVUlOVDY0XCIsdFt0LkNPTVBMRVg2ND0xNF09XCJDT01QTEVYNjRcIix0W3QuQ09NUExFWDEyOD0xNV09XCJDT01QTEVYMTI4XCIsdFt0LkJGTE9BVDE2PTE2XT1cIkJGTE9BVDE2XCJ9KGU9dC5UZW5zb3JEYXRhVHlwZXx8KHQuVGVuc29yRGF0YVR5cGU9e30pKX0odC5mYnN8fCh0LmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0LlByaW1pdGl2ZT0wXT1cIlByaW1pdGl2ZVwiLHRbdC5GdXNlZD0xXT1cIkZ1c2VkXCJ9KGU9dC5Ob2RlVHlwZXx8KHQuTm9kZVR5cGU9e30pKX0odC5mYnN8fCh0LmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0Lk5PTkU9MF09XCJOT05FXCIsdFt0LnRlbnNvcl90eXBlPTFdPVwidGVuc29yX3R5cGVcIix0W3Quc2VxdWVuY2VfdHlwZT0yXT1cInNlcXVlbmNlX3R5cGVcIix0W3QubWFwX3R5cGU9M109XCJtYXBfdHlwZVwifShlPXQuVHlwZUluZm9WYWx1ZXx8KHQuVHlwZUluZm9WYWx1ZT17fSkpfSh0LmZic3x8KHQuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzU2hhcGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2hhcGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWRpbShlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfWRpbUxlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRTaGFwZSh0KXt0LnN0YXJ0T2JqZWN0KDEpfXN0YXRpYyBhZGREaW0odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgY3JlYXRlRGltVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydERpbVZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRTaGFwZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlU2hhcGUodCxlKXtyZXR1cm4gbi5zdGFydFNoYXBlKHQpLG4uYWRkRGltKHQsZSksbi5lbmRTaGFwZSh0KX19ZS5TaGFwZT1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzRGltZW5zaW9uKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0RpbWVuc2lvbih0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9dmFsdWUoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZSkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfWRlbm90YXRpb24odCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1zdGF0aWMgc3RhcnREaW1lbnNpb24odCl7dC5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkVmFsdWUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkRGVub3RhdGlvbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBlbmREaW1lbnNpb24odCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZURpbWVuc2lvbih0LGUscil7cmV0dXJuIG4uc3RhcnREaW1lbnNpb24odCksbi5hZGRWYWx1ZSh0LGUpLG4uYWRkRGVub3RhdGlvbih0LHIpLG4uZW5kRGltZW5zaW9uKHQpfX1lLkRpbWVuc2lvbj1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzRGltZW5zaW9uVmFsdWUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzRGltZW5zaW9uVmFsdWUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWRpbVR5cGUoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDgodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZS5VTktOT1dOfWRpbVZhbHVlKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3Bvcyt0KTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kaW1QYXJhbSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXN0YXRpYyBzdGFydERpbWVuc2lvblZhbHVlKHQpe3Quc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZERpbVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50OCgwLG4sdC5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZS5VTktOT1dOKX1zdGF0aWMgYWRkRGltVmFsdWUodCxlKXt0LmFkZEZpZWxkSW50NjQoMSxlLHQuY3JlYXRlTG9uZygwLDApKX1zdGF0aWMgYWRkRGltUGFyYW0odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDIsZSwwKX1zdGF0aWMgZW5kRGltZW5zaW9uVmFsdWUodCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZURpbWVuc2lvblZhbHVlKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0RGltZW5zaW9uVmFsdWUodCksbi5hZGREaW1UeXBlKHQsZSksbi5hZGREaW1WYWx1ZSh0LHIpLG4uYWRkRGltUGFyYW0odCxpKSxuLmVuZERpbWVuc2lvblZhbHVlKHQpfX1lLkRpbWVuc2lvblZhbHVlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNUZW5zb3JUeXBlQW5kU2hhcGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVGVuc29yVHlwZUFuZFNoYXBlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1lbGVtVHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRH1zaGFwZShlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBuPyhlfHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlNoYXBlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKHQpe3Quc3RhcnRPYmplY3QoMil9c3RhdGljIGFkZEVsZW1UeXBlKGUsbil7ZS5hZGRGaWVsZEludDMyKDAsbix0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEKX1zdGF0aWMgYWRkU2hhcGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgZW5kVGVuc29yVHlwZUFuZFNoYXBlKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUZW5zb3JUeXBlQW5kU2hhcGUodCxlLHIpe3JldHVybiBuLnN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKHQpLG4uYWRkRWxlbVR5cGUodCxlKSxuLmFkZFNoYXBlKHQsciksbi5lbmRUZW5zb3JUeXBlQW5kU2hhcGUodCl9fWUuVGVuc29yVHlwZUFuZFNoYXBlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNNYXBUeXBlKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc01hcFR5cGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWtleVR5cGUoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK2UpOnQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUR9dmFsdWVUeXBlKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRNYXBUeXBlKHQpe3Quc3RhcnRPYmplY3QoMil9c3RhdGljIGFkZEtleVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50MzIoMCxuLHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpfXN0YXRpYyBhZGRWYWx1ZVR5cGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgZW5kTWFwVHlwZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTWFwVHlwZSh0LGUscil7cmV0dXJuIG4uc3RhcnRNYXBUeXBlKHQpLG4uYWRkS2V5VHlwZSh0LGUpLG4uYWRkVmFsdWVUeXBlKHQsciksbi5lbmRNYXBUeXBlKHQpfX1lLk1hcFR5cGU9bn0oZS5mYnN8fChlLmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc1NlcXVlbmNlVHlwZSh0LGUpe3JldHVybihlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTZXF1ZW5jZVR5cGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWVsZW1UeXBlKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRTZXF1ZW5jZVR5cGUodCl7dC5zdGFydE9iamVjdCgxKX1zdGF0aWMgYWRkRWxlbVR5cGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgZW5kU2VxdWVuY2VUeXBlKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVTZXF1ZW5jZVR5cGUodCxlKXtyZXR1cm4gbi5zdGFydFNlcXVlbmNlVHlwZSh0KSxuLmFkZEVsZW1UeXBlKHQsZSksbi5lbmRTZXF1ZW5jZVR5cGUodCl9fWUuU2VxdWVuY2VUeXBlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXsodC5mYnN8fCh0LmZicz17fSkpLkVkZ2VFbmQ9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31ub2RlSW5kZXgoKXtyZXR1cm4gdGhpcy5iYi5yZWFkVWludDMyKHRoaXMuYmJfcG9zKX1zcmNBcmdJbmRleCgpe3JldHVybiB0aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcys0KX1kc3RBcmdJbmRleCgpe3JldHVybiB0aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcys4KX1zdGF0aWMgY3JlYXRlRWRnZUVuZCh0LGUsbixyKXtyZXR1cm4gdC5wcmVwKDQsMTIpLHQud3JpdGVJbnQzMihyKSx0LndyaXRlSW50MzIobiksdC53cml0ZUludDMyKGUpLHQub2Zmc2V0KCl9fX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNOb2RlRWRnZSh0LGUpe3JldHVybihlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNOb2RlRWRnZSh0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bm9kZUluZGV4KCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRVaW50MzIodGhpcy5iYl9wb3MrdCk6MH1pbnB1dEVkZ2VzKGUsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kKS5fX2luaXQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSsxMiplLHRoaXMuYmIpOm51bGx9aW5wdXRFZGdlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1vdXRwdXRFZGdlcyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCkuX19pbml0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrMTIqZSx0aGlzLmJiKTpudWxsfW91dHB1dEVkZ2VzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydE5vZGVFZGdlKHQpe3Quc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZE5vZGVJbmRleCh0LGUpe3QuYWRkRmllbGRJbnQzMigwLGUsMCl9c3RhdGljIGFkZElucHV0RWRnZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgc3RhcnRJbnB1dEVkZ2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3RvcigxMixlLDQpfXN0YXRpYyBhZGRPdXRwdXRFZGdlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMixlLDApfXN0YXRpYyBzdGFydE91dHB1dEVkZ2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3RvcigxMixlLDQpfXN0YXRpYyBlbmROb2RlRWRnZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTm9kZUVkZ2UodCxlLHIsaSl7cmV0dXJuIG4uc3RhcnROb2RlRWRnZSh0KSxuLmFkZE5vZGVJbmRleCh0LGUpLG4uYWRkSW5wdXRFZGdlcyh0LHIpLG4uYWRkT3V0cHV0RWRnZXModCxpKSxuLmVuZE5vZGVFZGdlKHQpfX1lLk5vZGVFZGdlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNOb2RlKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc05vZGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfW5hbWUodCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1kb2NTdHJpbmcodCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1kb21haW4odCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1zaW5jZVZlcnNpb24oKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEwKTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcyt0KTowfWluZGV4KCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkVWludDMyKHRoaXMuYmJfcG9zK3QpOjB9b3BUeXBlKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXR5cGUoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE2KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3BvcytlKTp0LmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUuUHJpbWl0aXZlfWV4ZWN1dGlvblByb3ZpZGVyVHlwZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE4KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1pbnB1dHModCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9aW5wdXRzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1vdXRwdXRzKHQsZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMik7cmV0dXJuIG4/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK24pKzQqdCxlKTpudWxsfW91dHB1dHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIyKTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfWF0dHJpYnV0ZXMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI0KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KmUpLHRoaXMuYmIpOm51bGx9YXR0cmlidXRlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9aW5wdXRBcmdDb3VudHModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs0KnQpOjB9aW5wdXRBcmdDb3VudHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI2KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfWlucHV0QXJnQ291bnRzQXJyYXkoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI2KTtyZXR1cm4gdD9uZXcgSW50MzJBcnJheSh0aGlzLmJiLmJ5dGVzKCkuYnVmZmVyLHRoaXMuYmIuYnl0ZXMoKS5ieXRlT2Zmc2V0K3RoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrdCksdGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCkpOm51bGx9aW1wbGljaXRJbnB1dHModCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9aW1wbGljaXRJbnB1dHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydE5vZGUodCl7dC5zdGFydE9iamVjdCgxMyl9c3RhdGljIGFkZE5hbWUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkRG9jU3RyaW5nKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgxLGUsMCl9c3RhdGljIGFkZERvbWFpbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMixlLDApfXN0YXRpYyBhZGRTaW5jZVZlcnNpb24odCxlKXt0LmFkZEZpZWxkSW50MzIoMyxlLDApfXN0YXRpYyBhZGRJbmRleCh0LGUpe3QuYWRkRmllbGRJbnQzMig0LGUsMCl9c3RhdGljIGFkZE9wVHlwZSh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNSxlLDApfXN0YXRpYyBhZGRUeXBlKGUsbil7ZS5hZGRGaWVsZEludDMyKDYsbix0LmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUuUHJpbWl0aXZlKX1zdGF0aWMgYWRkRXhlY3V0aW9uUHJvdmlkZXJUeXBlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg3LGUsMCl9c3RhdGljIGFkZElucHV0cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoOCxlLDApfXN0YXRpYyBjcmVhdGVJbnB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW5wdXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZE91dHB1dHModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDksZSwwKX1zdGF0aWMgY3JlYXRlT3V0cHV0c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRPdXRwdXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZEF0dHJpYnV0ZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEwLGUsMCl9c3RhdGljIGNyZWF0ZUF0dHJpYnV0ZXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0QXR0cmlidXRlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRJbnB1dEFyZ0NvdW50cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTEsZSwwKX1zdGF0aWMgY3JlYXRlSW5wdXRBcmdDb3VudHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQzMihlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRJbnB1dEFyZ0NvdW50c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRJbXBsaWNpdElucHV0cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTIsZSwwKX1zdGF0aWMgY3JlYXRlSW1wbGljaXRJbnB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW1wbGljaXRJbnB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgZW5kTm9kZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTm9kZSh0LGUscixpLG8sYSxzLHUsYyxsLHAsZixkLGgpe3JldHVybiBuLnN0YXJ0Tm9kZSh0KSxuLmFkZE5hbWUodCxlKSxuLmFkZERvY1N0cmluZyh0LHIpLG4uYWRkRG9tYWluKHQsaSksbi5hZGRTaW5jZVZlcnNpb24odCxvKSxuLmFkZEluZGV4KHQsYSksbi5hZGRPcFR5cGUodCxzKSxuLmFkZFR5cGUodCx1KSxuLmFkZEV4ZWN1dGlvblByb3ZpZGVyVHlwZSh0LGMpLG4uYWRkSW5wdXRzKHQsbCksbi5hZGRPdXRwdXRzKHQscCksbi5hZGRBdHRyaWJ1dGVzKHQsZiksbi5hZGRJbnB1dEFyZ0NvdW50cyh0LGQpLG4uYWRkSW1wbGljaXRJbnB1dHModCxoKSxuLmVuZE5vZGUodCl9fWUuTm9kZT1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzVmFsdWVJbmZvKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1ZhbHVlSW5mbyh0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bmFtZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRvY1N0cmluZyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXR5cGUoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbykuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfXN0YXRpYyBzdGFydFZhbHVlSW5mbyh0KXt0LnN0YXJ0T2JqZWN0KDMpfXN0YXRpYyBhZGROYW1lKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgwLGUsMCl9c3RhdGljIGFkZERvY1N0cmluZyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBhZGRUeXBlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGVuZFZhbHVlSW5mbyh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlVmFsdWVJbmZvKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0VmFsdWVJbmZvKHQpLG4uYWRkTmFtZSh0LGUpLG4uYWRkRG9jU3RyaW5nKHQsciksbi5hZGRUeXBlKHQsaSksbi5lbmRWYWx1ZUluZm8odCl9fWUuVmFsdWVJbmZvPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNUeXBlSW5mbyh0LGUpe3JldHVybihlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNUeXBlSW5mbyh0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9ZGVub3RhdGlvbih0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXZhbHVlVHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkVWludDgodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORX12YWx1ZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIuX191bmlvbih0LHRoaXMuYmJfcG9zK2UpOm51bGx9c3RhdGljIHN0YXJ0VHlwZUluZm8odCl7dC5zdGFydE9iamVjdCgzKX1zdGF0aWMgYWRkRGVub3RhdGlvbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGRWYWx1ZVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50OCgxLG4sdC5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORSl9c3RhdGljIGFkZFZhbHVlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGVuZFR5cGVJbmZvKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUeXBlSW5mbyh0LGUscixpKXtyZXR1cm4gbi5zdGFydFR5cGVJbmZvKHQpLG4uYWRkRGVub3RhdGlvbih0LGUpLG4uYWRkVmFsdWVUeXBlKHQsciksbi5hZGRWYWx1ZSh0LGkpLG4uZW5kVHlwZUluZm8odCl9fWUuVHlwZUluZm89bn0oZS5mYnN8fChlLmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBle2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc09wZXJhdG9yU2V0SWQodCxuKXtyZXR1cm4obnx8bmV3IGUpLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzT3BlcmF0b3JTZXRJZCh0LG4pe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKG58fG5ldyBlKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9ZG9tYWluKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9dmVyc2lvbigpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MrdCk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9c3RhdGljIHN0YXJ0T3BlcmF0b3JTZXRJZCh0KXt0LnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGREb21haW4odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkVmVyc2lvbih0LGUpe3QuYWRkRmllbGRJbnQ2NCgxLGUsdC5jcmVhdGVMb25nKDAsMCkpfXN0YXRpYyBlbmRPcGVyYXRvclNldElkKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVPcGVyYXRvclNldElkKHQsbixyKXtyZXR1cm4gZS5zdGFydE9wZXJhdG9yU2V0SWQodCksZS5hZGREb21haW4odCxuKSxlLmFkZFZlcnNpb24odCxyKSxlLmVuZE9wZXJhdG9yU2V0SWQodCl9fXQuT3BlcmF0b3JTZXRJZD1lfSh0LmZic3x8KHQuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzVGVuc29yKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1RlbnNvcih0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bmFtZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRvY1N0cmluZyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRpbXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2UpKzgqdCk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9ZGltc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1kYXRhVHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiBlP3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK2UpOnQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUR9cmF3RGF0YSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50OCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2UpK3QpOjB9cmF3RGF0YUxlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9cmF3RGF0YUFycmF5KCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIHQ/bmV3IFVpbnQ4QXJyYXkodGhpcy5iYi5ieXRlcygpLmJ1ZmZlcix0aGlzLmJiLmJ5dGVzKCkuYnl0ZU9mZnNldCt0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpLHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpKTpudWxsfXN0cmluZ0RhdGEodCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9c3RyaW5nRGF0YUxlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9c3RhdGljIHN0YXJ0VGVuc29yKHQpe3Quc3RhcnRPYmplY3QoNil9c3RhdGljIGFkZE5hbWUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkRG9jU3RyaW5nKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgxLGUsMCl9c3RhdGljIGFkZERpbXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDIsZSwwKX1zdGF0aWMgY3JlYXRlRGltc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoOCxlLmxlbmd0aCw4KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZEludDY0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydERpbXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZSw4KX1zdGF0aWMgYWRkRGF0YVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50MzIoMyxuLHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpfXN0YXRpYyBhZGRSYXdEYXRhKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg0LGUsMCl9c3RhdGljIGNyZWF0ZVJhd0RhdGFWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDEsZS5sZW5ndGgsMSk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQ4KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFJhd0RhdGFWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDEsZSwxKX1zdGF0aWMgYWRkU3RyaW5nRGF0YSh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNSxlLDApfXN0YXRpYyBjcmVhdGVTdHJpbmdEYXRhVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN0cmluZ0RhdGFWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgZW5kVGVuc29yKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUZW5zb3IodCxlLHIsaSxvLGEscyl7cmV0dXJuIG4uc3RhcnRUZW5zb3IodCksbi5hZGROYW1lKHQsZSksbi5hZGREb2NTdHJpbmcodCxyKSxuLmFkZERpbXModCxpKSxuLmFkZERhdGFUeXBlKHQsbyksbi5hZGRSYXdEYXRhKHQsYSksbi5hZGRTdHJpbmdEYXRhKHQscyksbi5lbmRUZW5zb3IodCl9fWUuVGVuc29yPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNTcGFyc2VUZW5zb3IodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU3BhcnNlVGVuc29yKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX12YWx1ZXMoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1pbmRpY2VzKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9ZGltcyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrZSkrOCp0KTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kaW1zTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydFNwYXJzZVRlbnNvcih0KXt0LnN0YXJ0T2JqZWN0KDMpfXN0YXRpYyBhZGRWYWx1ZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkSW5kaWNlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBhZGREaW1zKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGNyZWF0ZURpbXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZS5sZW5ndGgsOCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQ2NChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnREaW1zVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig4LGUsOCl9c3RhdGljIGVuZFNwYXJzZVRlbnNvcih0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlU3BhcnNlVGVuc29yKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0U3BhcnNlVGVuc29yKHQpLG4uYWRkVmFsdWVzKHQsZSksbi5hZGRJbmRpY2VzKHQsciksbi5hZGREaW1zKHQsaSksbi5lbmRTcGFyc2VUZW5zb3IodCl9fWUuU3BhcnNlVGVuc29yPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNBdHRyaWJ1dGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzQXR0cmlidXRlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1uYW1lKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9ZG9jU3RyaW5nKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9dHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEfWYoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEwKTtyZXR1cm4gdD90aGlzLmJiLnJlYWRGbG9hdDMyKHRoaXMuYmJfcG9zK3QpOjB9aSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiB0P3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmJfcG9zK3QpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9dChlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE2KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1nKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTgpO3JldHVybiBuPyhlfHxuZXcgdC5leHBlcmltZW50YWwuZmJzLkdyYXBoKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9ZmxvYXRzKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjApO3JldHVybiBlP3RoaXMuYmIucmVhZEZsb2F0MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs0KnQpOjB9ZmxvYXRzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1mbG9hdHNBcnJheSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjApO3JldHVybiB0P25ldyBGbG9hdDMyQXJyYXkodGhpcy5iYi5ieXRlcygpLmJ1ZmZlcix0aGlzLmJiLmJ5dGVzKCkuYnl0ZU9mZnNldCt0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpLHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpKTpudWxsfWludHModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs4KnQpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWludHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIyKTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0cmluZ3ModCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI0KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9c3RyaW5nc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9dGVuc29ycyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjYpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlRlbnNvcikuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqZSksdGhpcy5iYik6bnVsbH10ZW5zb3JzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1ncmFwaHMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5HcmFwaCkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqZSksdGhpcy5iYik6bnVsbH1ncmFwaHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydEF0dHJpYnV0ZSh0KXt0LnN0YXJ0T2JqZWN0KDEzKX1zdGF0aWMgYWRkTmFtZSh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGREb2NTdHJpbmcodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgYWRkVHlwZShlLG4pe2UuYWRkRmllbGRJbnQzMigyLG4sdC5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEKX1zdGF0aWMgYWRkRih0LGUpe3QuYWRkRmllbGRGbG9hdDMyKDMsZSwwKX1zdGF0aWMgYWRkSSh0LGUpe3QuYWRkRmllbGRJbnQ2NCg0LGUsdC5jcmVhdGVMb25nKDAsMCkpfXN0YXRpYyBhZGRTKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg1LGUsMCl9c3RhdGljIGFkZFQodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDYsZSwwKX1zdGF0aWMgYWRkRyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNyxlLDApfXN0YXRpYyBhZGRGbG9hdHModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDgsZSwwKX1zdGF0aWMgY3JlYXRlRmxvYXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkRmxvYXQzMihlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRGbG9hdHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgYWRkSW50cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoOSxlLDApfXN0YXRpYyBjcmVhdGVJbnRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig4LGUubGVuZ3RoLDgpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkSW50NjQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW50c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoOCxlLDgpfXN0YXRpYyBhZGRTdHJpbmdzKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgxMCxlLDApfXN0YXRpYyBjcmVhdGVTdHJpbmdzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN0cmluZ3NWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgYWRkVGVuc29ycyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTEsZSwwKX1zdGF0aWMgY3JlYXRlVGVuc29yc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRUZW5zb3JzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZEdyYXBocyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTIsZSwwKX1zdGF0aWMgY3JlYXRlR3JhcGhzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEdyYXBoc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRBdHRyaWJ1dGUodCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZUF0dHJpYnV0ZSh0LGUscixpLG8sYSxzLHUsYyxsLHAsZixkLGgpe3JldHVybiBuLnN0YXJ0QXR0cmlidXRlKHQpLG4uYWRkTmFtZSh0LGUpLG4uYWRkRG9jU3RyaW5nKHQsciksbi5hZGRUeXBlKHQsaSksbi5hZGRGKHQsbyksbi5hZGRJKHQsYSksbi5hZGRTKHQscyksbi5hZGRUKHQsdSksbi5hZGRHKHQsYyksbi5hZGRGbG9hdHModCxsKSxuLmFkZEludHModCxwKSxuLmFkZFN0cmluZ3ModCxmKSxuLmFkZFRlbnNvcnModCxkKSxuLmFkZEdyYXBocyh0LGgpLG4uZW5kQXR0cmlidXRlKHQpfX1lLkF0dHJpYnV0ZT1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzR3JhcGgodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzR3JhcGgodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWluaXRpYWxpemVycyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfWluaXRpYWxpemVyc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1ub2RlQXJncyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfW5vZGVBcmdzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfW5vZGVzKGUsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5Ob2RlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfW5vZGVzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfW1heE5vZGVJbmRleCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiB0P3RoaXMuYmIucmVhZFVpbnQzMih0aGlzLmJiX3Bvcyt0KTowfW5vZGVFZGdlcyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLk5vZGVFZGdlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfW5vZGVFZGdlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9aW5wdXRzKHQsZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIG4/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK24pKzQqdCxlKTpudWxsfWlucHV0c0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9b3V0cHV0cyh0LGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTYpO3JldHVybiBuP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytuKSs0KnQsZSk6bnVsbH1vdXRwdXRzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zcGFyc2VJbml0aWFsaXplcnMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE4KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KmUpLHRoaXMuYmIpOm51bGx9c3BhcnNlSW5pdGlhbGl6ZXJzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRHcmFwaCh0KXt0LnN0YXJ0T2JqZWN0KDgpfXN0YXRpYyBhZGRJbml0aWFsaXplcnModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgY3JlYXRlSW5pdGlhbGl6ZXJzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEluaXRpYWxpemVyc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGROb2RlQXJncyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBjcmVhdGVOb2RlQXJnc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnROb2RlQXJnc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGROb2Rlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMixlLDApfXN0YXRpYyBjcmVhdGVOb2Rlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnROb2Rlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRNYXhOb2RlSW5kZXgodCxlKXt0LmFkZEZpZWxkSW50MzIoMyxlLDApfXN0YXRpYyBhZGROb2RlRWRnZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDQsZSwwKX1zdGF0aWMgY3JlYXRlTm9kZUVkZ2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE5vZGVFZGdlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRJbnB1dHModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDUsZSwwKX1zdGF0aWMgY3JlYXRlSW5wdXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydElucHV0c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRPdXRwdXRzKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg2LGUsMCl9c3RhdGljIGNyZWF0ZU91dHB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0T3V0cHV0c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRTcGFyc2VJbml0aWFsaXplcnModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDcsZSwwKX1zdGF0aWMgY3JlYXRlU3BhcnNlSW5pdGlhbGl6ZXJzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFNwYXJzZUluaXRpYWxpemVyc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRHcmFwaCh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlR3JhcGgodCxlLHIsaSxvLGEscyx1LGMpe3JldHVybiBuLnN0YXJ0R3JhcGgodCksbi5hZGRJbml0aWFsaXplcnModCxlKSxuLmFkZE5vZGVBcmdzKHQsciksbi5hZGROb2Rlcyh0LGkpLG4uYWRkTWF4Tm9kZUluZGV4KHQsbyksbi5hZGROb2RlRWRnZXModCxhKSxuLmFkZElucHV0cyh0LHMpLG4uYWRkT3V0cHV0cyh0LHUpLG4uYWRkU3BhcnNlSW5pdGlhbGl6ZXJzKHQsYyksbi5lbmRHcmFwaCh0KX19ZS5HcmFwaD1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzTW9kZWwodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTW9kZWwodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWlyVmVyc2lvbigpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MrdCk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9b3BzZXRJbXBvcnQoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLk9wZXJhdG9yU2V0SWQpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KmUpLHRoaXMuYmIpOm51bGx9b3BzZXRJbXBvcnRMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9cHJvZHVjZXJOYW1lKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9cHJvZHVjZXJWZXJzaW9uKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRvbWFpbih0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1tb2RlbFZlcnNpb24oKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3Bvcyt0KTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kb2NTdHJpbmcodCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9Z3JhcGgoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1ncmFwaERvY1N0cmluZyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1zdGF0aWMgc3RhcnRNb2RlbCh0KXt0LnN0YXJ0T2JqZWN0KDkpfXN0YXRpYyBhZGRJclZlcnNpb24odCxlKXt0LmFkZEZpZWxkSW50NjQoMCxlLHQuY3JlYXRlTG9uZygwLDApKX1zdGF0aWMgYWRkT3BzZXRJbXBvcnQodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgY3JlYXRlT3BzZXRJbXBvcnRWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0T3BzZXRJbXBvcnRWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgYWRkUHJvZHVjZXJOYW1lKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGFkZFByb2R1Y2VyVmVyc2lvbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMyxlLDApfXN0YXRpYyBhZGREb21haW4odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDQsZSwwKX1zdGF0aWMgYWRkTW9kZWxWZXJzaW9uKHQsZSl7dC5hZGRGaWVsZEludDY0KDUsZSx0LmNyZWF0ZUxvbmcoMCwwKSl9c3RhdGljIGFkZERvY1N0cmluZyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNixlLDApfXN0YXRpYyBhZGRHcmFwaCh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNyxlLDApfXN0YXRpYyBhZGRHcmFwaERvY1N0cmluZyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoOCxlLDApfXN0YXRpYyBlbmRNb2RlbCh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTW9kZWwodCxlLHIsaSxvLGEscyx1LGMsbCl7cmV0dXJuIG4uc3RhcnRNb2RlbCh0KSxuLmFkZElyVmVyc2lvbih0LGUpLG4uYWRkT3BzZXRJbXBvcnQodCxyKSxuLmFkZFByb2R1Y2VyTmFtZSh0LGkpLG4uYWRkUHJvZHVjZXJWZXJzaW9uKHQsbyksbi5hZGREb21haW4odCxhKSxuLmFkZE1vZGVsVmVyc2lvbih0LHMpLG4uYWRkRG9jU3RyaW5nKHQsdSksbi5hZGRHcmFwaCh0LGMpLG4uYWRkR3JhcGhEb2NTdHJpbmcodCxsKSxuLmVuZE1vZGVsKHQpfX1lLk1vZGVsPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3MgZXtjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyh0LG4pe3JldHVybihufHxuZXcgZSkuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyh0LG4pe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKG58fG5ldyBlKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bm9kZUluZGljZXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs0KnQpOjB9bm9kZUluZGljZXNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9bm9kZUluZGljZXNBcnJheSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/bmV3IFVpbnQzMkFycmF5KHRoaXMuYmIuYnl0ZXMoKS5idWZmZXIsdGhpcy5iYi5ieXRlcygpLmJ5dGVPZmZzZXQrdGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3Bvcyt0KSx0aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KSk6bnVsbH1rZXJuZWxEZWZIYXNoZXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50NjQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs4KnQpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWtlcm5lbERlZkhhc2hlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRLZXJuZWxDcmVhdGVJbmZvcyh0KXt0LnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGROb2RlSW5kaWNlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBjcmVhdGVOb2RlSW5kaWNlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZEludDMyKGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE5vZGVJbmRpY2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZEtlcm5lbERlZkhhc2hlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBjcmVhdGVLZXJuZWxEZWZIYXNoZXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZS5sZW5ndGgsOCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQ2NChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRLZXJuZWxEZWZIYXNoZXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZSw4KX1zdGF0aWMgZW5kS2VybmVsQ3JlYXRlSW5mb3ModCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZUtlcm5lbENyZWF0ZUluZm9zKHQsbixyKXtyZXR1cm4gZS5zdGFydEtlcm5lbENyZWF0ZUluZm9zKHQpLGUuYWRkTm9kZUluZGljZXModCxuKSxlLmFkZEtlcm5lbERlZkhhc2hlcyh0LHIpLGUuZW5kS2VybmVsQ3JlYXRlSW5mb3ModCl9fXQuS2VybmVsQ3JlYXRlSW5mb3M9ZX0odC5mYnN8fCh0LmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1ncmFwaElkKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9c2Vzc2lvblN0YXRlKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUodCl7dC5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkR3JhcGhJZCh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGRTZXNzaW9uU3RhdGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgZW5kU3ViR3JhcGhTZXNzaW9uU3RhdGUodCl7bGV0IGU9dC5lbmRPYmplY3QoKTtyZXR1cm4gdC5yZXF1aXJlZEZpZWxkKGUsNCksZX1zdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGUodCxlLHIpe3JldHVybiBuLnN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUodCksbi5hZGRHcmFwaElkKHQsZSksbi5hZGRTZXNzaW9uU3RhdGUodCxyKSxuLmVuZFN1YkdyYXBoU2Vzc2lvblN0YXRlKHQpfX1lLlN1YkdyYXBoU2Vzc2lvblN0YXRlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNTZXNzaW9uU3RhdGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2Vzc2lvblN0YXRlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1rZXJuZWxzKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuS2VybmVsQ3JlYXRlSW5mb3MpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdWJHcmFwaFNlc3Npb25TdGF0ZXMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfXN1YkdyYXBoU2Vzc2lvblN0YXRlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRTZXNzaW9uU3RhdGUodCl7dC5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkS2VybmVscyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGRTdWJHcmFwaFNlc3Npb25TdGF0ZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGVzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN1YkdyYXBoU2Vzc2lvblN0YXRlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRTZXNzaW9uU3RhdGUodCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZVNlc3Npb25TdGF0ZSh0LGUscil7cmV0dXJuIG4uc3RhcnRTZXNzaW9uU3RhdGUodCksbi5hZGRLZXJuZWxzKHQsZSksbi5hZGRTdWJHcmFwaFNlc3Npb25TdGF0ZXModCxyKSxuLmVuZFNlc3Npb25TdGF0ZSh0KX19ZS5TZXNzaW9uU3RhdGU9bn0oZS5mYnN8fChlLmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc0luZmVyZW5jZVNlc3Npb24odCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzSW5mZXJlbmNlU2Vzc2lvbih0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGJ1ZmZlckhhc0lkZW50aWZpZXIodCl7cmV0dXJuIHQuX19oYXNfaWRlbnRpZmllcihcIk9SVE1cIil9b3J0VmVyc2lvbih0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfW1vZGVsKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuTW9kZWwpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zZXNzaW9uU3RhdGUoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRJbmZlcmVuY2VTZXNzaW9uKHQpe3Quc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZE9ydFZlcnNpb24odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkTW9kZWwodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgYWRkU2Vzc2lvblN0YXRlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGVuZEluZmVyZW5jZVNlc3Npb24odCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGZpbmlzaEluZmVyZW5jZVNlc3Npb25CdWZmZXIodCxlKXt0LmZpbmlzaChlLFwiT1JUTVwiKX1zdGF0aWMgZmluaXNoU2l6ZVByZWZpeGVkSW5mZXJlbmNlU2Vzc2lvbkJ1ZmZlcih0LGUpe3QuZmluaXNoKGUsXCJPUlRNXCIsITApfXN0YXRpYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0SW5mZXJlbmNlU2Vzc2lvbih0KSxuLmFkZE9ydFZlcnNpb24odCxlKSxuLmFkZE1vZGVsKHQsciksbi5hZGRTZXNzaW9uU3RhdGUodCxpKSxuLmVuZEluZmVyZW5jZVNlc3Npb24odCl9fWUuSW5mZXJlbmNlU2Vzc2lvbj1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKX0sNzQ0ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5Pbm54anNTZXNzaW9uSGFuZGxlcj12b2lkIDA7Y29uc3Qgcj1uKDE2NzApLGk9big5MTYyKTtlLk9ubnhqc1Nlc3Npb25IYW5kbGVyPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuc2Vzc2lvbj10LHRoaXMuaW5wdXROYW1lcz10aGlzLnNlc3Npb24uaW5wdXROYW1lcyx0aGlzLm91dHB1dE5hbWVzPXRoaXMuc2Vzc2lvbi5vdXRwdXROYW1lc31hc3luYyBkaXNwb3NlKCl7fWFzeW5jIHJ1bih0LGUsbil7Y29uc3Qgbz1uZXcgTWFwO2Zvcihjb25zdCBlIGluIHQpaWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxlKSl7Y29uc3Qgbj10W2VdO28uc2V0KGUsbmV3IGkuVGVuc29yKG4uZGltcyxuLnR5cGUsdm9pZCAwLHZvaWQgMCxuLmRhdGEpKX1jb25zdCBhPWF3YWl0IHRoaXMuc2Vzc2lvbi5ydW4obykscz17fTtyZXR1cm4gYS5mb3JFYWNoKCgodCxlKT0+e3NbZV09bmV3IHIuVGVuc29yKHQudHlwZSx0LmRhdGEsdC5kaW1zKX0pKSxzfXN0YXJ0UHJvZmlsaW5nKCl7dGhpcy5zZXNzaW9uLnN0YXJ0UHJvZmlsaW5nKCl9ZW5kUHJvZmlsaW5nKCl7dGhpcy5zZXNzaW9uLmVuZFByb2ZpbGluZygpfX19LDY5MTk6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuU2Vzc2lvbj12b2lkIDA7Y29uc3Qgcj1uKDcwNjcpLGk9bigxMjk2KSxvPW4oNzA5MSksYT1uKDEwMzYpLHM9big2MjMxKSx1PW4oMjY0NCk7ZS5TZXNzaW9uPWNsYXNze2NvbnN0cnVjdG9yKHQ9e30pe3RoaXMuX2luaXRpYWxpemVkPSExLHRoaXMuYmFja2VuZEhpbnQ9dC5iYWNrZW5kSGludCx0aGlzLnByb2ZpbGVyPXMuUHJvZmlsZXIuY3JlYXRlKHQucHJvZmlsZXIpLHRoaXMuY29udGV4dD17cHJvZmlsZXI6dGhpcy5wcm9maWxlcixncmFwaElucHV0VHlwZXM6W10sZ3JhcGhJbnB1dERpbXM6W119fWdldCBpbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX21vZGVsLmdyYXBoLmdldElucHV0TmFtZXMoKX1nZXQgb3V0cHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0T3V0cHV0TmFtZXMoKX1zdGFydFByb2ZpbGluZygpe3RoaXMucHJvZmlsZXIuc3RhcnQoKX1lbmRQcm9maWxpbmcoKXt0aGlzLnByb2ZpbGVyLnN0b3AoKX1hc3luYyBsb2FkTW9kZWwodCxlLG4pe2F3YWl0IHRoaXMucHJvZmlsZXIuZXZlbnQoXCJzZXNzaW9uXCIsXCJTZXNzaW9uLmxvYWRNb2RlbFwiLChhc3luYygpPT57Y29uc3QgYT1hd2FpdCgwLG8ucmVzb2x2ZUJhY2tlbmQpKHRoaXMuYmFja2VuZEhpbnQpO2lmKHRoaXMuc2Vzc2lvbkhhbmRsZXI9YS5jcmVhdGVTZXNzaW9uSGFuZGxlcih0aGlzLmNvbnRleHQpLHRoaXMuX21vZGVsPW5ldyB1Lk1vZGVsLFwic3RyaW5nXCI9PXR5cGVvZiB0KXtjb25zdCBlPXQuZW5kc1dpdGgoXCIub3J0XCIpO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBmZXRjaCl7Y29uc3Qgbj1hd2FpdCgwLGkucHJvbWlzaWZ5KShyLnJlYWRGaWxlKSh0KTt0aGlzLmluaXRpYWxpemUobixlKX1lbHNle2NvbnN0IG49YXdhaXQgZmV0Y2godCkscj1hd2FpdCBuLmFycmF5QnVmZmVyKCk7dGhpcy5pbml0aWFsaXplKG5ldyBVaW50OEFycmF5KHIpLGUpfX1lbHNlIGlmKEFycmF5QnVmZmVyLmlzVmlldyh0KSl0aGlzLmluaXRpYWxpemUodCk7ZWxzZXtjb25zdCByPW5ldyBVaW50OEFycmF5KHQsZXx8MCxufHx0LmJ5dGVMZW5ndGgpO3RoaXMuaW5pdGlhbGl6ZShyKX19KSl9aW5pdGlhbGl6ZSh0LGUpe2lmKHRoaXMuX2luaXRpYWxpemVkKXRocm93IG5ldyBFcnJvcihcImFscmVhZHkgaW5pdGlhbGl6ZWRcIik7dGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIlNlc3Npb24uaW5pdGlhbGl6ZVwiLCgoKT0+e2NvbnN0IG49dGhpcy5zZXNzaW9uSGFuZGxlci50cmFuc2Zvcm1HcmFwaD90aGlzLnNlc3Npb25IYW5kbGVyOnZvaWQgMDt0aGlzLl9tb2RlbC5sb2FkKHQsbixlKSx0aGlzLnNlc3Npb25IYW5kbGVyLm9uR3JhcGhJbml0aWFsaXplZCYmdGhpcy5zZXNzaW9uSGFuZGxlci5vbkdyYXBoSW5pdGlhbGl6ZWQodGhpcy5fbW9kZWwuZ3JhcGgpLHRoaXMuaW5pdGlhbGl6ZU9wcyh0aGlzLl9tb2RlbC5ncmFwaCksdGhpcy5fZXhlY3V0aW9uUGxhbj1uZXcgYS5FeGVjdXRpb25QbGFuKHRoaXMuX21vZGVsLmdyYXBoLHRoaXMuX29wcyx0aGlzLnByb2ZpbGVyKX0pKSx0aGlzLl9pbml0aWFsaXplZD0hMH1hc3luYyBydW4odCl7aWYoIXRoaXMuX2luaXRpYWxpemVkKXRocm93IG5ldyBFcnJvcihcInNlc3Npb24gbm90IGluaXRpYWxpemVkIHlldFwiKTtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIlNlc3Npb24ucnVuXCIsKGFzeW5jKCk9Pntjb25zdCBlPXRoaXMubm9ybWFsaXplQW5kVmFsaWRhdGVJbnB1dHModCksbj1hd2FpdCB0aGlzLl9leGVjdXRpb25QbGFuLmV4ZWN1dGUodGhpcy5zZXNzaW9uSGFuZGxlcixlKTtyZXR1cm4gdGhpcy5jcmVhdGVPdXRwdXQobil9KSl9bm9ybWFsaXplQW5kVmFsaWRhdGVJbnB1dHModCl7Y29uc3QgZT10aGlzLl9tb2RlbC5ncmFwaC5nZXRJbnB1dE5hbWVzKCk7aWYoQXJyYXkuaXNBcnJheSh0KSl7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGluY29ycmVjdCBpbnB1dCBhcnJheSBsZW5ndGg6IGV4cGVjdGVkICR7ZS5sZW5ndGh9IGJ1dCBnb3QgJHt0Lmxlbmd0aH1gKX1lbHNle2lmKHQuc2l6ZSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW5jb3JyZWN0IGlucHV0IG1hcCBzaXplOiBleHBlY3RlZCAke2UubGVuZ3RofSBidXQgZ290ICR7dC5zaXplfWApO2NvbnN0IG49bmV3IEFycmF5KHQuc2l6ZSk7bGV0IHI9MDtmb3IobGV0IGk9MDtpPGUubGVuZ3RoOysraSl7Y29uc3Qgbz10LmdldChlW2ldKTtpZighbyl0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgaW5wdXQgdGVuc29yIGZvcjogJyR7bmFtZX0nYCk7bltyKytdPW99dD1ufWlmKHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMmJjAhPT10aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzLmxlbmd0aCYmdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zJiYwIT09dGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zLmxlbmd0aCl0aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcyx0LCExKTtlbHNle2NvbnN0IGU9dGhpcy5fbW9kZWwuZ3JhcGguZ2V0SW5wdXRJbmRpY2VzKCksbj10aGlzLl9tb2RlbC5ncmFwaC5nZXRWYWx1ZXMoKSxyPW5ldyBBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBpPTA7aTxlLmxlbmd0aDsrK2kpe2NvbnN0IG89bltlW2ldXTtyW2ldPW8udHlwZS5zaGFwZS5kaW1zLHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMucHVzaChvLnR5cGUudGVuc29yVHlwZSksdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zLnB1c2godFtpXS5kaW1zKX10aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHIsdCwhMCl9cmV0dXJuIHRoaXMudmFsaWRhdGVJbnB1dFRlbnNvclR5cGVzKHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMsdCksdH12YWxpZGF0ZUlucHV0VGVuc29yVHlwZXModCxlKXtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl7Y29uc3Qgcj10W25dLGk9ZVtuXS50eXBlO2lmKHIhPT1pKXRocm93IG5ldyBFcnJvcihgaW5wdXQgdGVuc29yWyR7bn1dIGNoZWNrIGZhaWxlZDogZXhwZWN0ZWQgdHlwZSAnJHtyfScgYnV0IGdvdCAke2l9YCl9fXZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHQsZSxuKXtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7Y29uc3QgaT10W3JdLG89ZVtyXS5kaW1zO2lmKCF0aGlzLmNvbXBhcmVUZW5zb3JEaW1zKGksbyxuKSl0aHJvdyBuZXcgRXJyb3IoYGlucHV0IHRlbnNvclske3J9XSBjaGVjayBmYWlsZWQ6IGV4cGVjdGVkIHNoYXBlICdbJHtpLmpvaW4oXCIsXCIpfV0nIGJ1dCBnb3QgWyR7by5qb2luKFwiLFwiKX1dYCl9fWNvbXBhcmVUZW5zb3JEaW1zKHQsZSxuKXtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7KytyKWlmKHRbcl0hPT1lW3JdJiYoIW58fDAhPT10W3JdKSlyZXR1cm4hMTtyZXR1cm4hMH1jcmVhdGVPdXRwdXQodCl7Y29uc3QgZT10aGlzLl9tb2RlbC5ncmFwaC5nZXRPdXRwdXROYW1lcygpO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgbnVtYmVyIG9mIG91dHB1dHMgZG8gbm90IG1hdGNoIG51bWJlciBvZiBnZW5lcmF0ZWQgb3V0cHV0c1wiKTtjb25zdCBuPW5ldyBNYXA7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3Ipbi5zZXQoZVtyXSx0W3JdKTtyZXR1cm4gbn1pbml0aWFsaXplT3BzKHQpe2NvbnN0IGU9dC5nZXROb2RlcygpO3RoaXMuX29wcz1uZXcgQXJyYXkoZS5sZW5ndGgpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXRoaXMuX29wc1tuXT10aGlzLnNlc3Npb25IYW5kbGVyLnJlc29sdmUoZVtuXSx0aGlzLl9tb2RlbC5vcHNldHMsdCl9fX0sOTE2MjpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5UZW5zb3I9dm9pZCAwO2NvbnN0IGk9bigzNDQyKSxvPXIobigzNzIwKSksYT1uKDE0NDYpLHM9big5Mzk1KSx1PW4oMjUxNyk7dmFyIGM9cy5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO2NsYXNzIGx7Z2V0IGRhdGEoKXtpZih2b2lkIDA9PT10aGlzLmNhY2hlKXtjb25zdCB0PXRoaXMuZGF0YVByb3ZpZGVyKHRoaXMuZGF0YUlkKTtpZih0Lmxlbmd0aCE9PXRoaXMuc2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgZGF0YSBwcm92aWRlZCBieSB0aGUgRGF0YSBQcm92aWRlciBpcyBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgZGltcyBvZiB0aGlzIFRlbnNvci5cIik7dGhpcy5jYWNoZT10fXJldHVybiB0aGlzLmNhY2hlfWdldCBzdHJpbmdEYXRhKCl7aWYoXCJzdHJpbmdcIiE9PXRoaXMudHlwZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSB0eXBlIGlzIG5vdCBzdHJpbmdcIik7cmV0dXJuIHRoaXMuZGF0YX1nZXQgaW50ZWdlckRhdGEoKXtzd2l0Y2godGhpcy50eXBlKXtjYXNlXCJ1aW50OFwiOmNhc2VcImludDhcIjpjYXNlXCJ1aW50MTZcIjpjYXNlXCJpbnQxNlwiOmNhc2VcImludDMyXCI6Y2FzZVwidWludDMyXCI6Y2FzZVwiYm9vbFwiOnJldHVybiB0aGlzLmRhdGE7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSB0eXBlIGlzIG5vdCBpbnRlZ2VyICh1aW50OCwgaW50OCwgdWludDE2LCBpbnQxNiwgaW50MzIsIHVpbnQzMiwgYm9vbClcIil9fWdldCBmbG9hdERhdGEoKXtzd2l0Y2godGhpcy50eXBlKXtjYXNlXCJmbG9hdDMyXCI6Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiB0aGlzLmRhdGE7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSB0eXBlIGlzIG5vdCBmbG9hdCAoZmxvYXQzMiwgZmxvYXQ2NClcIil9fWdldCBudW1iZXJEYXRhKCl7aWYoXCJzdHJpbmdcIiE9PXRoaXMudHlwZSlyZXR1cm4gdGhpcy5kYXRhO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJ0eXBlIGNhbm5vdCBiZSBub24tbnVtYmVyIChzdHJpbmcpXCIpfWdldCh0KXtyZXR1cm4gdGhpcy5kYXRhW3UuU2hhcGVVdGlsLmluZGljZXNUb09mZnNldCh0LHRoaXMuc3RyaWRlcyldfXNldCh0LGUpe3RoaXMuZGF0YVt1LlNoYXBlVXRpbC5pbmRpY2VzVG9PZmZzZXQodCx0aGlzLnN0cmlkZXMpXT1lfWFzeW5jIGdldERhdGEoKXtyZXR1cm4gdm9pZCAwPT09dGhpcy5jYWNoZSYmKHRoaXMuY2FjaGU9YXdhaXQgdGhpcy5hc3luY0RhdGFQcm92aWRlcih0aGlzLmRhdGFJZCkpLHRoaXMuY2FjaGV9Z2V0IHN0cmlkZXMoKXtyZXR1cm4gdGhpcy5fc3RyaWRlc3x8KHRoaXMuX3N0cmlkZXM9dS5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXModGhpcy5kaW1zKSksdGhpcy5fc3RyaWRlc31jb25zdHJ1Y3Rvcih0LGUsbixyLG8sYT1pLkd1aWQuY3JlYXRlKCkpe3RoaXMuZGltcz10LHRoaXMudHlwZT1lLHRoaXMuZGF0YVByb3ZpZGVyPW4sdGhpcy5hc3luY0RhdGFQcm92aWRlcj1yLHRoaXMuY2FjaGU9byx0aGlzLmRhdGFJZD1hLHRoaXMuc2l6ZT11LlNoYXBlVXRpbC52YWxpZGF0ZURpbXNBbmRDYWxjU2l6ZSh0KTtjb25zdCBzPXRoaXMuc2l6ZSxjPXZvaWQgMD09PW4mJnZvaWQgMD09PXImJnZvaWQgMD09PW87aWYodm9pZCAwIT09byYmby5sZW5ndGghPT1zKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5wdXQgZGltcyBkb2Vzbid0IG1hdGNoIGRhdGEgbGVuZ3RoLlwiKTtpZihcInN0cmluZ1wiPT09ZSl7aWYoISh2b2lkIDA9PT1vfHxBcnJheS5pc0FycmF5KG8pJiZvLmV2ZXJ5KCh0PT5cInN0cmluZ1wiPT10eXBlb2YgdCkpKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FjaGUgc2hvdWxkIGJlIGEgc3RyaW5nIGFycmF5XCIpO2MmJih0aGlzLmNhY2hlPW5ldyBBcnJheShzKSl9ZWxzZXtpZih2b2lkIDAhPT1vKXtjb25zdCB0PWYoZSk7aWYoIShvIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihgY2FjaGUgc2hvdWxkIGJlIHR5cGUgJHt0Lm5hbWV9YCl9aWYoYyl7Y29uc3QgdD1uZXcgQXJyYXlCdWZmZXIocypmdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZVwiYm9vbFwiOmNhc2VcImludDhcIjpjYXNlXCJ1aW50OFwiOnJldHVybiAxO2Nhc2VcImludDE2XCI6Y2FzZVwidWludDE2XCI6cmV0dXJuIDI7Y2FzZVwiaW50MzJcIjpjYXNlXCJ1aW50MzJcIjpjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDQ7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiA4O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgY2FsY3VsYXRlIHNpemVvZigpIG9uIHR5cGUgJHt0fWApfX0oZSkpO3RoaXMuY2FjaGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3KGYoZSkpKHQpfSh0LGUpfX19c3RhdGljIGZyb21Qcm90byh0KXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgY29uc3RydWN0IFZhbHVlIGZyb20gYW4gZW1wdHkgdGVuc29yXCIpO2NvbnN0IGU9dS5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odC5kYXRhVHlwZSksbj11LlByb3RvVXRpbC50ZW5zb3JEaW1zRnJvbVByb3RvKHQuZGltcykscj1uZXcgbChuLGUpO2lmKFwic3RyaW5nXCI9PT1lKXQuc3RyaW5nRGF0YS5mb3JFYWNoKCgodCxlKT0+e3IuZGF0YVtlXT0oMCx1LmRlY29kZVV0ZjhTdHJpbmcpKHQpfSkpO2Vsc2UgaWYodC5yYXdEYXRhJiZcIm51bWJlclwiPT10eXBlb2YgdC5yYXdEYXRhLmJ5dGVMZW5ndGgmJnQucmF3RGF0YS5ieXRlTGVuZ3RoPjApe2NvbnN0IGU9ci5kYXRhLG49bmV3IERhdGFWaWV3KHQucmF3RGF0YS5idWZmZXIsdC5yYXdEYXRhLmJ5dGVPZmZzZXQsdC5yYXdEYXRhLmJ5dGVMZW5ndGgpLGk9cCh0LmRhdGFUeXBlKSxvPXQucmF3RGF0YS5ieXRlTGVuZ3RoL2k7aWYodC5yYXdEYXRhLmJ5dGVMZW5ndGglaSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ1ZmZlciBsZW5ndGhcIik7aWYoZS5sZW5ndGghPT1vKXRocm93IG5ldyBFcnJvcihcImJ1ZmZlciBsZW5ndGggbWlzbWF0Y2hcIik7Zm9yKGxldCByPTA7cjxvO3IrKyl7Y29uc3Qgbz1oKG4sdC5kYXRhVHlwZSxyKmkpO2Vbcl09b319ZWxzZXtsZXQgZTtzd2l0Y2godC5kYXRhVHlwZSl7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6ZT10LmZsb2F0RGF0YTticmVhaztjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOmU9dC5pbnQzMkRhdGE7YnJlYWs7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6ZT10LmludDY0RGF0YTticmVhaztjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6ZT10LmRvdWJsZURhdGE7YnJlYWs7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDplPXQudWludDY0RGF0YTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVuc3BlY2lmaWMgZXJyb3JcIil9aWYobnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJmYWlsZWQgdG8gcG9wdWxhdGUgZGF0YSBmcm9tIGEgdGVuc29ycHJvdG8gdmFsdWVcIik7Y29uc3Qgbj1yLmRhdGE7aWYobi5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBsZW5ndGggbWlzbWF0Y2hcIik7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2NvbnN0IGk9ZVtyXTtvLmRlZmF1bHQuaXNMb25nKGkpP25bcl09ZChpLHQuZGF0YVR5cGUpOm5bcl09aX19cmV0dXJuIHJ9c3RhdGljIGZyb21EYXRhKHQsZSxuKXtyZXR1cm4gbmV3IGwoZSxuLHZvaWQgMCx2b2lkIDAsdCl9c3RhdGljIGZyb21PcnRUZW5zb3IodCl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNvbnN0cnVjdCBWYWx1ZSBmcm9tIGFuIGVtcHR5IHRlbnNvclwiKTtjb25zdCBlPXUuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tT1JURm9ybWF0KHQpLG49dS5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odC5kYXRhVHlwZSgpKSxyPW5ldyBsKGUsbik7aWYoXCJzdHJpbmdcIj09PW4pZm9yKGxldCBlPTA7ZTx0LnN0cmluZ0RhdGFMZW5ndGgoKTtlKyspci5kYXRhW2VdPXQuc3RyaW5nRGF0YShlKTtlbHNlIGlmKHQucmF3RGF0YUFycmF5KCkmJlwibnVtYmVyXCI9PXR5cGVvZiB0LnJhd0RhdGFMZW5ndGgoKSYmdC5yYXdEYXRhTGVuZ3RoKCk+MCl7Y29uc3QgZT1yLmRhdGEsbj1uZXcgRGF0YVZpZXcodC5yYXdEYXRhQXJyYXkoKS5idWZmZXIsdC5yYXdEYXRhQXJyYXkoKS5ieXRlT2Zmc2V0LHQucmF3RGF0YUxlbmd0aCgpKSxpPXAodC5kYXRhVHlwZSgpKSxvPXQucmF3RGF0YUxlbmd0aCgpL2k7aWYodC5yYXdEYXRhTGVuZ3RoKCklaSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ1ZmZlciBsZW5ndGhcIik7aWYoZS5sZW5ndGghPT1vKXRocm93IG5ldyBFcnJvcihcImJ1ZmZlciBsZW5ndGggbWlzbWF0Y2hcIik7Zm9yKGxldCByPTA7cjxvO3IrKyl7Y29uc3Qgbz1oKG4sdC5kYXRhVHlwZSgpLHIqaSk7ZVtyXT1vfX1yZXR1cm4gcn19ZnVuY3Rpb24gcCh0KXtzd2l0Y2godCl7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOnJldHVybiAxO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpyZXR1cm4gMjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6cmV0dXJuIDQ7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm4gODtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGNhbGN1bGF0ZSBzaXplb2YoKSBvbiB0eXBlICR7YS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3RdfWApfX1mdW5jdGlvbiBmKHQpe3N3aXRjaCh0KXtjYXNlXCJib29sXCI6Y2FzZVwidWludDhcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJpbnQ4XCI6cmV0dXJuIEludDhBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQzMlwiOnJldHVybiBJbnQzMkFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIEZsb2F0NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVuc3BlY2lmaWVkIGVycm9yXCIpfX1mdW5jdGlvbiBkKHQsZSl7aWYoZT09PWEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NHx8ZT09PWMuVGVuc29yRGF0YVR5cGUuSU5UNjQpe2lmKHQuZ3JlYXRlclRoYW5PckVxdWFsKDIxNDc0ODM2NDgpfHx0Lmxlc3NUaGFuKC0yMTQ3NDgzNjQ4KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW50NjQgaXMgbm90IHN1cHBvcnRlZFwiKX1lbHNle2lmKGUhPT1hLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyJiZlIT09Yy5UZW5zb3JEYXRhVHlwZS5VSU5UMzImJmUhPT1hLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0JiZlIT09Yy5UZW5zb3JEYXRhVHlwZS5VSU5UNjQpdGhyb3cgbmV3IFR5cGVFcnJvcihgbm90IGEgTE9ORyB0eXBlOiAke2Eub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVtlXX1gKTtpZih0LmdyZWF0ZXJUaGFuT3JFcXVhbCg0Mjk0OTY3Mjk2KXx8dC5sZXNzVGhhbigwKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwidWludDY0IGlzIG5vdCBzdXBwb3J0ZWRcIil9cmV0dXJuIHQudG9OdW1iZXIoKX1mdW5jdGlvbiBoKHQsZSxuKXtzd2l0Y2goZSl7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpyZXR1cm4gdC5nZXRVaW50OChuKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OnJldHVybiB0LmdldEludDgobik7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OnJldHVybiB0LmdldFVpbnQxNihuLCEwKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpyZXR1cm4gdC5nZXRJbnQxNihuLCEwKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpyZXR1cm4gdC5nZXRGbG9hdDMyKG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOnJldHVybiB0LmdldEludDMyKG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjpyZXR1cm4gdC5nZXRVaW50MzIobiwhMCk7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6cmV0dXJuIGQoby5kZWZhdWx0LmZyb21CaXRzKHQuZ2V0VWludDMyKG4sITApLHQuZ2V0VWludDMyKG4rNCwhMCksITEpLGUpO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpyZXR1cm4gdC5nZXRGbG9hdDY0KG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm4gZChvLmRlZmF1bHQuZnJvbUJpdHModC5nZXRVaW50MzIobiwhMCksdC5nZXRVaW50MzIobis0LCEwKSwhMCksZSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWFkIGZyb20gRGF0YVZpZXcgZm9yIHR5cGUgJHthLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVbZV19YCl9fWUuVGVuc29yPWx9LDI1MTc6ZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZGVjb2RlVXRmOFN0cmluZz1lLk1BWF9DTElQPWUuTUlOX0NMSVA9ZS5Qb29sQ29udlV0aWw9ZS5SZWR1Y2VVdGlsPWUuU3BsaXRVdGlsPWUuTWF0aFV0aWw9ZS5TaGFwZVV0aWw9ZS5Mb25nVXRpbD1lLlByb3RvVXRpbD1lLkdlbW1VdGlsPWUuYXJyYXlDb3B5SGVscGVyPWUuQnJvYWRjYXN0VXRpbD1lLk1hdE11bFV0aWw9ZS5BcnJheVV0aWw9ZS5hc3NlcnQ9ZS5jaGVja0lucHV0c1NoYXBlPXZvaWQgMDtjb25zdCBpPW4oNTY4Niksbz1yKG4oMzcyMCkpLGE9bigxNDQ2KSxzPW4oOTE2Mik7ZS5jaGVja0lucHV0c1NoYXBlPWZ1bmN0aW9uKHQsLi4uZSl7aWYoIXR8fHQubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoIXRbbl0uZGltc3x8dFtuXS5kaW1zLmxlbmd0aCE9PWVbbl0pcmV0dXJuITE7cmV0dXJuITB9LGUuYXNzZXJ0PWZ1bmN0aW9uKHQsZSl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZSgpKX0sZS5BcnJheVV0aWw9Y2xhc3N7c3RhdGljIGFycmF5c0VxdWFsKHQsZSl7aWYodC5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKylpZih0W25dIT09ZVtuXSlyZXR1cm4hMTtyZXR1cm4hMH19O2NsYXNzIHV7c3RhdGljIHByZXByb2Nlc3NJbnB1dFNoYXBlcyh0LGUpe3JldHVyblsxPT09dC5sZW5ndGg/WzEsdFswXV06dCwxPT09ZS5sZW5ndGg/W2VbMF0sMV06ZV19c3RhdGljIHBvc3Rwcm9jZXNzT3V0cHV0U2hhcGUodCxlLG4pezE9PT1lJiZ0LnNwbGljZSh0Lmxlbmd0aC0yLDEpLDE9PT1uJiZ0LnBvcCgpfXN0YXRpYyBjYWxjTWF0TXVsU2hhcGUodCxlKXtyZXR1cm4gdFsxXSE9PWVbMF0/dm9pZCAwOlt0WzBdLGVbMV1dfX1lLk1hdE11bFV0aWw9dTtjbGFzcyBje3N0YXRpYyBjYWxjU2hhcGUodCxlLG49ITEpe2NvbnN0IHI9dC5sZW5ndGgsaT1lLmxlbmd0aDtpZigwPT09cilyZXR1cm4gZTtpZigwPT09aSlyZXR1cm4gdDtjb25zdCBvPU1hdGgubWF4KHQubGVuZ3RoLGUubGVuZ3RoKSxhPW5ldyBBcnJheShvKTtpZihuKXtpZihyPDJ8fGk8MilyZXR1cm47Y29uc3Qgbj11LmNhbGNNYXRNdWxTaGFwZShbdFtyLTJdLHRbci0xXV0sW2VbaS0yXSxlW2ktMV1dKTtpZih2b2lkIDA9PT1uKXJldHVybjtbYVtvLTJdLGFbby0xXV09bn1mb3IobGV0IHM9bj8zOjE7czw9bztzKyspe2NvbnN0IG49ci1zPDA/MTp0W3Itc10sdT1pLXM8MD8xOmVbaS1zXTtpZihuIT09dSYmbj4xJiZ1PjEpcmV0dXJuO2Fbby1zXT1NYXRoLm1heChuLHUpfXJldHVybiBhfXN0YXRpYyBpbmRleCh0LGUpe2NvbnN0IG49bmV3IEFycmF5KGUubGVuZ3RoKTtyZXR1cm4gYy5maWxsSW5kZXgodCxlLG4pLG59c3RhdGljIGZpbGxJbmRleCh0LGUsbil7Y29uc3Qgcj10Lmxlbmd0aC1lLmxlbmd0aDtmb3IobGV0IGk9MDtpPGUubGVuZ3RoO2krKyluW2ldPXRbcitpXSVlW2ldfXN0YXRpYyBjYWxjKHQsZSxuLHIsaSl7Y29uc3Qgbz1jLmNhbGNTaGFwZSh0LmRpbXMsZS5kaW1zKTtpZihvKXtpZihyJiYhZi5hcmVFcXVhbChvLHQuZGltcykpcmV0dXJuO2NvbnN0IGE9Zi5zaXplKG8pLHU9cj90Om5ldyBzLlRlbnNvcihvLGl8fHQudHlwZSk7aWYoMD09PW8ubGVuZ3RoKXUuc2V0KFtdLG4odC5nZXQoW10pLGUuZ2V0KFtdKSkpO2Vsc2V7Y29uc3Qgcj1uZXcgQXJyYXkoby5sZW5ndGgpLGk9bmV3IEFycmF5KHQuZGltcy5sZW5ndGgpLHM9bmV3IEFycmF5KGUuZGltcy5sZW5ndGgpO2xldCBsLHA9MCxmPTAsZD0hMSxoPSExOzA9PT10LmRpbXMubGVuZ3RoJiYocD10LmdldChbXSksZD0hMCksMD09PWUuZGltcy5sZW5ndGgmJihmPWUuZ2V0KFtdKSxoPSEwKTtmb3IobGV0IGc9MDtnPGE7ZysrKXtsPWc7Zm9yKGxldCB0PW8ubGVuZ3RoLTE7dD49MDt0LS0pclt0XT1sJW9bdF0sbD1NYXRoLmZsb29yKGwvb1t0XSk7ZHx8KGMuZmlsbEluZGV4KHIsdC5kaW1zLGkpLHA9dC5nZXQoaSkpLGh8fChjLmZpbGxJbmRleChyLGUuZGltcyxzKSxmPWUuZ2V0KHMpKSx1LnNldChyLG4ocCxmKSl9fXJldHVybiB1fX1zdGF0aWMgaXNWYWxpZEJyb2FkY2FzdCh0LGUpe2NvbnN0IG49dC5sZW5ndGgscj1lLmxlbmd0aDtpZihuPnIpcmV0dXJuITE7Zm9yKGxldCBpPTE7aTw9bjtpKyspaWYoMSE9PXRbbi1pXSYmdFtuLWldIT09ZVtyLWldKXJldHVybiExO3JldHVybiEwfXN0YXRpYyBnZXRCcm9hZGNhc3REaW1zKHQsZSl7Y29uc3Qgbj10Lmxlbmd0aCxyPVtdO2ZvcihsZXQgaT0wO2k8bjtpKyspe2NvbnN0IG89bi0xLWksYT10W29dfHwxOyhlW2UubGVuZ3RoLTEtaV18fDEpPjEmJjE9PT1hJiZyLnVuc2hpZnQobyl9cmV0dXJuIHJ9fWUuQnJvYWRjYXN0VXRpbD1jLGUuYXJyYXlDb3B5SGVscGVyPWZ1bmN0aW9uKHQsZSxuLHIsaSl7aWYocjwwfHxyPj1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MHx8bj49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihyK2k+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kc1wiKTtpZihuK2k+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdFwiKTtmb3IobGV0IG89MDtvPGk7bysrKXRbbitvXT1lW3Irb119LGUuR2VtbVV0aWw9Y2xhc3N7c3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KHQsZSxuLHIsaSl7aWYoMiE9PXQubGVuZ3RofHwyIT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDJcIik7bGV0IG8sYSxzO2U/KG89dFsxXSxhPXRbMF0pOihvPXRbMF0sYT10WzFdKTtsZXQgdT0tMTtpZihyPyhzPW5bMF0sdT0xKToocz1uWzFdLHU9MCksblt1XSE9PWEpdGhyb3cgbmV3IEVycm9yKFwiZGltZW5zaW9uIG1pc21hdGNoXCIpO2lmKG88PTB8fHM8PTB8fGE8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaGFwZSBzcGVjaWZpZWRcIik7aWYoaSYmIWMuaXNWYWxpZEJyb2FkY2FzdChpLFtvLHNdKSl0aHJvdyBuZXcgRXJyb3IoXCJnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdFwiKTtyZXR1cm5bbyxzLGFdfX07Y2xhc3MgbHtzdGF0aWMgdGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odCl7c3dpdGNoKHQpe2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6cmV0dXJuXCJpbnQ4XCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6cmV0dXJuXCJ1aW50OFwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6cmV0dXJuXCJib29sXCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpyZXR1cm5cInVpbnQxNlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOnJldHVyblwiaW50MzJcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuU1RSSU5HOnJldHVyblwic3RyaW5nXCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm5cInVpbnQzMlwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7YS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3RdfWApfX1zdGF0aWMgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0odCl7c3dpdGNoKHQpe2Nhc2VcImludDhcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg7Y2FzZVwidWludDhcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4O2Nhc2VcImJvb2xcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w7Y2FzZVwiaW50MTZcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2O2Nhc2VcInVpbnQxNlwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2O2Nhc2VcImludDMyXCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5TVFJJTkc7Y2FzZVwiaW50NjRcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH1gKX19c3RhdGljIHRlbnNvckRpbXNGcm9tUHJvdG8odCl7cmV0dXJuIHQubWFwKCh0PT5vLmRlZmF1bHQuaXNMb25nKHQpP3QudG9OdW1iZXIoKTp0KSl9c3RhdGljIHRlbnNvclZhbHVlVHlwZUZyb21Qcm90byh0KXtyZXR1cm57dGVuc29yVHlwZTpsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKHQuZWxlbVR5cGUpLHNoYXBlOntkaW1zOmwudGVuc29yRGltc0Zyb21Qcm90byh0LnNoYXBlLmRpbS5tYXAoKHQ9PnQuZGltVmFsdWUpKSl9fX1zdGF0aWMgdGVuc29yRGltc0Zyb21PUlRGb3JtYXQodCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuZGltc0xlbmd0aCgpO24rKyllLnB1c2gocC5sb25nVG9OdW1iZXIodC5kaW1zKG4pKSk7cmV0dXJuIGV9c3RhdGljIHRlbnNvckF0dHJpYnV0ZXNGcm9tT1JURm9ybWF0KHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0LmF0dHJpYnV0ZXNMZW5ndGgoKTtuKyspZS5wdXNoKHQuYXR0cmlidXRlcyhuKSk7cmV0dXJuIGV9fWUuUHJvdG9VdGlsPWw7Y2xhc3MgcHtzdGF0aWMgbG9uZ1RvTnVtYmVyKHQsZSl7cmV0dXJuIG8uZGVmYXVsdC5pc0xvbmcodCk/dC50b051bWJlcigpOnQgaW5zdGFuY2VvZiBpLmZsYXRidWZmZXJzLkxvbmc/by5kZWZhdWx0LmZyb21WYWx1ZSh7bG93OnQubG93LGhpZ2g6dC5oaWdoLHVuc2lnbmVkOm51bGwhPWUmJmV9KS50b051bWJlcigpOnR9c3RhdGljIGlzTG9uZyh0KXtyZXR1cm4gby5kZWZhdWx0LmlzTG9uZyh0KXx8dCBpbnN0YW5jZW9mIGkuZmxhdGJ1ZmZlcnMuTG9uZ319ZS5Mb25nVXRpbD1wO2NsYXNzIGZ7c3RhdGljIHNpemUodCl7cmV0dXJuIGYuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsdC5sZW5ndGgpfXN0YXRpYyBzaXplRnJvbURpbWVuc2lvbih0LGUpe2lmKGU8MHx8ZT50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7ZX0gZm9yIHNpemVGcm9tRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHt0Lmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZi5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsZSx0Lmxlbmd0aCl9c3RhdGljIHNpemVUb0RpbWVuc2lvbih0LGUpe2lmKGU8MHx8ZT50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7ZX0gZm9yIHNpemVUb0RpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGYuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsZSl9c3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCxlLG4pe2xldCByPTE7Zm9yKGxldCBpPWU7aTxuO2krKyl7aWYodFtpXTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgMCBvciBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS5cIik7cio9dFtpXX1yZXR1cm4gcn1zdGF0aWMgY29tcHV0ZVN0cmlkZXModCl7Y29uc3QgZT10Lmxlbmd0aDtpZigwPT09ZSlyZXR1cm5bXTtpZigxPT09ZSlyZXR1cm5bMV07Y29uc3Qgbj1uZXcgQXJyYXkoZSk7bltlLTFdPTEsbltlLTJdPXRbZS0xXTtmb3IobGV0IHI9ZS0zO3I+PTA7LS1yKW5bcl09bltyKzFdKnRbcisxXTtyZXR1cm4gbn1zdGF0aWMgdHJhbnNwb3NlKHQpe3JldHVybiB0LnNsaWNlKCkucmV2ZXJzZSgpfXN0YXRpYyBpbmRpY2VzVG9PZmZzZXQodCxlLG4pe3ZvaWQgMD09PW4mJihuPXQubGVuZ3RoKTtsZXQgcj0wO2ZvcihsZXQgaT0wO2k8bjsrK2kpcis9ZVtpXSp0W2ldO3JldHVybiByfXN0YXRpYyBvZmZzZXRUb0luZGljZXModCxlKXtjb25zdCBuPWUubGVuZ3RoO2lmKDA9PT1uKXJldHVybltdO2lmKDE9PT1uKXJldHVyblt0KmVbMF1dO2NvbnN0IHI9bmV3IEFycmF5KGUubGVuZ3RoKTtmb3IobGV0IG49MDtuPHIubGVuZ3RoLTE7KytuKXJbbl09TWF0aC5mbG9vcih0L2Vbbl0pLHQtPXJbbl0qZVtuXTtyZXR1cm4gcltyLmxlbmd0aC0xXT10LHJ9c3RhdGljIG5vcm1hbGl6ZUF4aXModCxlKXtpZih0PC1lJiZ0Pj1lKXRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGF4aXMgZm9yIHRoaXMgb3BlcmF0aW9uLlwiKTtyZXR1cm4gdDwwP3QrZTp0fXN0YXRpYyBub3JtYWxpemVBeGVzKHQsZSl7cmV0dXJuIHQubWFwKCh0PT50aGlzLm5vcm1hbGl6ZUF4aXModCxlKSkpfXN0YXRpYyBpbmNyZW1lbnRJbmRleCh0LGUsbil7aWYoMD09PWUubGVuZ3RofHwwPT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggaW5jcmVtZW50aW5nIHVuc3VwcG9ydGVkIGZvciBzY2FsYXIgVGVuc29yXCIpO2lmKHZvaWQgMD09PW4pbj1lLmxlbmd0aDtlbHNlIGlmKG48PTB8fG4+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IGF4aXMgdG8gaW5jcmVtZW50IG9uXCIpO2ZvcihsZXQgcj1uLTE7cj49MCYmKHRbcl0rKywhKHRbcl08ZVtyXSkpOy0tcil0W3JdPTB9c3RhdGljIGNhbGN1bGF0ZVJlc2hhcGVkRGltcyh0LGUpe2lmKDA9PT1lLmxlbmd0aCl7aWYoMD09PXQubGVuZ3RofHwxPT09Zi5zaXplKHQpKXJldHVybltdO3Rocm93IG5ldyBFcnJvcihcImNhbm5vdCByZXNoYXBlIHRvIGEgc2NhbGFyIFRlbnNvclwiKX1jb25zdCBuPWUubGVuZ3RoLHI9bmV3IEFycmF5KG4pO2xldCBpPS0xLG89MTtmb3IobGV0IGE9MDthPG47YSsrKXtpZihlW2FdPC0xKXRocm93IG5ldyBFcnJvcihcImEgZGltZW5zaW9uIGluIHNoYXBlIGhpbnRzIGNhbm5vdCBiZSBsZXNzIHRoYW4gLTFcIik7aWYoLTE9PT1lW2FdKXtpZigtMSE9PWkpdGhyb3cgbmV3IEVycm9yKFwiYXQgbW9zdCBvbmUgZGltZW5zaW9uIGluIHNoYXBlIGhpbnRzIGNhbiBiZSAtMVwiKTtpPWF9ZWxzZXtpZigwPT09ZVthXSl7aWYoYT49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGhlIGRpbWVuc2lvbiB3aXRoIHZhbHVlIHplcm8gZXhjZWVkcyB0aGUgZGltZW5zaW9uIHNpemUgb2YgdGhlIGlucHV0IHRlbnNvclwiKTtyW2FdPXRbYV19ZWxzZSByW2FdPWVbYV07byo9clthXX19Y29uc3QgYT1mLnNpemUodCk7aWYoLTEhPT1pKXtpZihhJW8hPTApdGhyb3cgbmV3IEVycm9yKGB0aGUgaW5wdXQgdGVuc29yIGNhbm5vdCBiZSByZXNoYXBlZCB0byB0aGUgcmVxdWVzdGVkIHNoYXBlLiBJbnB1dCBzaGFwZTogWyR7dH1dIE91dHB1dCBzaGFwZTogWyR7ZX1dYCk7cltpXT1hL299ZWxzZSBpZihvIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJyZXNoYXBlZERpbXMgYW5kIG9yaWdpbmFsRGltcyBkb24ndCBoYXZlIG1hdGNoaW5nIHNpemVzXCIpO3JldHVybiByfXN0YXRpYyBzb3J0QmFzZWRPblBlcm0odCxlKXtyZXR1cm4gZT9lLm1hcCgoZT0+dFtlXSkpOnQuc2xpY2UoKS5yZXZlcnNlKCl9c3RhdGljIHBhZFNoYXBlKHQsZSl7Y29uc3Qgbj10Lmxlbmd0aDtyZXR1cm4gdC5tYXAoKCh0LHIpPT50K2Vbcl0rZVtyK25dKSl9c3RhdGljIGFyZUVxdWFsKHQsZSl7cmV0dXJuIHQubGVuZ3RoPT09ZS5sZW5ndGgmJnQuZXZlcnkoKCh0LG4pPT50PT09ZVtuXSkpfXN0YXRpYyB2YWxpZGF0ZURpbXNBbmRDYWxjU2l6ZSh0KXtpZih0Lmxlbmd0aD42KXRocm93IG5ldyBUeXBlRXJyb3IoXCJPbmx5IHJhbmsgMCB0byA2IGlzIHN1cHBvcnRlZCBmb3IgdGVuc29yIHNoYXBlLlwiKTtsZXQgZT0xO2Zvcihjb25zdCBuIG9mIHQpe2lmKCFOdW1iZXIuaXNJbnRlZ2VyKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2hhcGU6ICR7bn0gaXMgbm90IGFuIGludGVnZXJgKTtpZihuPDB8fG4+MjE0NzQ4MzY0Nyl0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNoYXBlOiBsZW5ndGggJHtufSBpcyBub3QgYWxsb3dlZGApO2UqPW59cmV0dXJuIGV9c3RhdGljIGZsYXR0ZW5TaGFwZSh0LGUpe2U8MCYmKGUrPXQubGVuZ3RoKTtjb25zdCBuPXQucmVkdWNlKCgodCxlKT0+dCplKSwxKSxyPXQuc2xpY2UoZSkucmVkdWNlKCgodCxlKT0+dCplKSwxKTtyZXR1cm5bbi9yLHJdfXN0YXRpYyBzcXVlZXplU2hhcGUodCxlKXtjb25zdCBuPW5ldyBBcnJheTtlPWYubm9ybWFsaXplQXhlcyhlLHQubGVuZ3RoKTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl7Y29uc3QgaT1lLmluZGV4T2Yocik+PTA7aWYoaSYmMSE9PXRbcl0pdGhyb3cgbmV3IEVycm9yKFwic3F1ZWV6ZSBhbiBheGlzIG9mIHNpemUgZGlmZmVyZW50IHRoYW4gMVwiKTsoMD09PWUubGVuZ3RoJiZ0W3JdPjF8fGUubGVuZ3RoPjAmJiFpKSYmbi5wdXNoKHRbcl0pfXJldHVybiBufXN0YXRpYyB1bnNxdWVlemVTaGFwZSh0LGUpe2NvbnN0IG49bmV3IEFycmF5KHQubGVuZ3RoK2UubGVuZ3RoKTtuLmZpbGwoMCk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IHI9Zi5ub3JtYWxpemVBeGlzKGVbdF0sbi5sZW5ndGgpO2lmKHI+PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIidheGVzJyBoYXMgYW4gb3V0IG9mIHJhbmdlIGF4aXNcIik7aWYoMCE9PW5bcl0pdGhyb3cgbmV3IEVycm9yKFwiJ2F4ZXMnIGhhcyBhIGR1cGxpY2F0ZSBheGlzXCIpO25bcl09MX1sZXQgcj0wO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGg7ZSsrKTA9PT1uW2VdJiYobltlXT10W3IrK10pO2lmKHIhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgdW5zcXVlZXplZCBkaW1lbnNpb24gY291bGQgbm90IGJlIGVzdGFibGlzaGVkXCIpO3JldHVybiBufX1lLlNoYXBlVXRpbD1mLGUuTWF0aFV0aWw9Y2xhc3N7c3RhdGljIHNxcih0LGUsbixyLGkpe2lmKHI8MHx8cj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IG91dCBvZiBib3VuZHNcIik7aWYocitpPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHNcIik7aWYobitpPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHRcIik7Zm9yKGxldCBvPTA7bzxpO28rKyl0W24rb10rPU1hdGgucG93KGVbcitvXSwyKX1zdGF0aWMgYXhweSh0LGUsbixyLGksbyl7aWYocjwwfHxyPj1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MHx8bj49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihyK2k+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kc1wiKTtpZihuK2k+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdFwiKTtmb3IobGV0IGE9MDthPGk7YSsrKXRbbithXSs9byplW3IrYV19c3RhdGljIHBvd3godCxlLG4scixpLG8pe2lmKHI8MHx8cj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IG91dCBvZiBib3VuZHNcIik7aWYocitpPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHNcIik7aWYobitpPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHRcIik7Zm9yKGxldCBhPTA7YTxpO2ErKyl0W24rYV09TWF0aC5wb3coZVtyK2FdLG8pfXN0YXRpYyBtdWwodCxlLG4scixpKXtpZihyPDB8fHI+PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZUluZGV4IG91dCBvZiBib3VuZHNcIik7aWYobjwwfHxuPj10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKHIraT5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzXCIpO2lmKG4raT50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0XCIpO2ZvcihsZXQgbz0wO288aTtvKyspdFtuK29dPWVbcitvXSp0W24rb119fTtjbGFzcyBke3N0YXRpYyBzcGxpdFNoYXBlKHQsZSxuLHIpe2lmKDA9PT1uLmxlbmd0aCl7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwibmVlZCB0byBrbm93IG51bWJlciBvZiBvdXRwdXRzIHdoZW4gdGhlICdzcGxpdCcgYXR0cmlidXRlIGlzIG5vdCBzcGVjaWZpZWRcIik7ZC5kZXRlcm1pbmVTcGxpdCh0W2VdLHIsbil9Y29uc3QgaT1bXSxvPVswXTtmb3IobGV0IHI9MDtyPG4ubGVuZ3RoOysrcil7MCE9PXImJm8ucHVzaChvW3ItMV0rbltyLTFdKTtjb25zdCBhPXQuc2xpY2UoKTthW2VdPW5bcl0saS5wdXNoKGEpfXJldHVybltpLG9dfXN0YXRpYyBkZXRlcm1pbmVTcGxpdCh0LGUsbil7aWYodCVlIT0wKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBzcGxpdCB0ZW5zb3IgdG8gZXF1YWwgc2l6ZWQgcGFydHNcIik7Zm9yKGxldCByPTA7cjxlOysrciluLnB1c2godC9lKX19ZS5TcGxpdFV0aWw9ZDtjbGFzcyBoe3N0YXRpYyBjYWxjUmVkdWNlKHQsZSxuLHIsaSl7Y29uc3Qgbz10LmRpbXMuc2xpY2UoMCk7MD09PWUubGVuZ3RoJiZvLmZvckVhY2goKCh0LG4pPT5lLnB1c2gobikpKTtjb25zdCBhPWguY2FsY1JlZHVjZVNoYXBlKG8sZSwhMCksdT1mLnNpemUoYSksbD1uZXcgcy5UZW5zb3IoYSx0LnR5cGUpLHA9Zi5jb21wdXRlU3RyaWRlcyhhKSxkPWYuY29tcHV0ZVN0cmlkZXMobyksZz1uZXcgQXJyYXkoby5sZW5ndGgpO2ZvcihsZXQgbj0wO248dTtuKyspe2NvbnN0IGE9Zi5vZmZzZXRUb0luZGljZXMobixwKTtjLmZpbGxJbmRleChhLG8sZyksbC5zZXQoYSxoLmNhbGNSZWR1Y2VCeUF4aXModC5udW1iZXJEYXRhLGUsbywwLGYuaW5kaWNlc1RvT2Zmc2V0KGcsZCkscixpKSl9cmV0dXJuIG4/bDpuZXcgcy5UZW5zb3IoaC5jYWxjUmVkdWNlU2hhcGUobyxlLG4pLGwudHlwZSx2b2lkIDAsdm9pZCAwLGwuZGF0YSxsLmRhdGFJZCl9c3RhdGljIGNhbGNSZWR1Y2VCeUF4aXModCxlLG4scixpLG8sYSl7bGV0IHM9MDtpZihyPj1lLmxlbmd0aClyZXR1cm4gbyh0W2ldKTtjb25zdCB1PWVbcl0sYz11Pj1uLmxlbmd0aD8xOmYuc2l6ZShuLnNsaWNlKHUrMSkpO2ZvcihsZXQgbD0wO2w8blt1XTtsKyspcz0wPT09bD9oLmNhbGNSZWR1Y2VCeUF4aXModCxlLG4scisxLGksbyxhKTphKHMsaC5jYWxjUmVkdWNlQnlBeGlzKHQsZSxuLHIrMSxpLG8sYSkpLGkrPWM7cmV0dXJuIHN9c3RhdGljIGNhbGNSZWR1Y2VTaGFwZSh0LGUsbil7Y29uc3Qgcj10LnNsaWNlKCk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0KyspcltlW3RdXT1uPzE6MDtyZXR1cm4gci5maWx0ZXIoKHQ9PjAhPT10KSl9fWUuUmVkdWNlVXRpbD1oO2NsYXNzIGd7c3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKHQsZSxuLHIsaSxvKXtpZighdCYmbi5sZW5ndGghPT1lLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzcGVjaWZpZWQga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgMiBsZXNzIHRoYW4gbGVuZ3RoIG9mIGlucHV0IGRpbWVuc2lvbnNcIik7aWYodClmb3IobGV0IHQ9MDt0PGUubGVuZ3RoLTI7dCsrKXQ+PW4ubGVuZ3RoP24ucHVzaChlW3QrMl0pOm5bdF09ZVt0KzJdO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWlmKHQ8ci5sZW5ndGgpe2lmKHJbdF08MCl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIHIucHVzaCgxKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKylpZih0PGkubGVuZ3RoKXtpZihpW3RdPDApdGhyb3cgbmV3IEVycm9yKFwiZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIGkucHVzaCgxKTtmb3IobGV0IHQ9MDt0PDIqbi5sZW5ndGg7dCsrKWlmKHQ8by5sZW5ndGgpe2lmKG9bdF08MCl0aHJvdyBuZXcgRXJyb3IoXCJwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugby5wdXNoKDApO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKXtpZihuW3RdPD0wKXRocm93IG5ldyBFcnJvcihcImtlcm5lbCBzaGFwZXMgbmVlZCB0byBiZSBncmVhdGVyIHRoYW4gMFwiKTtpZihvW3RdPj1uW3RdfHxvW3Qrbi5sZW5ndGhdPj1uW3RdKXRocm93IG5ldyBFcnJvcihcInBhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWxcIil9fXN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodCxlLG4scixpLG8pe2lmKG8pe2lmKGkubGVuZ3RoIT09MioodC5sZW5ndGgtMikpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHBhZHMgc2hvdWxkIGJlIHR3aWNlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKGUubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYoci5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtmb3IobGV0IGE9MDthPHQubGVuZ3RoLTI7YSsrKWcuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodFthKzJdLGVbYV0sblthXSxyW2FdLGksYSxhK3QubGVuZ3RoLTIsbyl9fXN0YXRpYyBjb21wdXRlUG9vbE91dHB1dFNoYXBlKHQsZSxuLHIsaSxvLGEpe2lmKGUubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMFwiKTtjb25zdCBzPVtlWzBdLGVbMV1dO3JldHVybiBnLmNvbXB1dGVTaGFwZUhlbHBlcih0LGUscyxuLHIsaSxvLGEpLHN9c3RhdGljIGNvbXB1dGVDb252T3V0cHV0U2hhcGUodCxlLG4scixpLG8sYSl7aWYodC5sZW5ndGg8PTB8fGUubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXNcIik7Y29uc3Qgcz1bdFswXSxlWzBdXTtyZXR1cm4gZy5jb21wdXRlU2hhcGVIZWxwZXIoITEsdCxzLG4scixpLG8sYSksc31zdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKHQsZSxuLHIsaSxvLGEscyl7aWYodClmb3IobGV0IHQ9MDt0PGUubGVuZ3RoLTI7dCsrKW4ucHVzaCgxKTtlbHNlIGZvcihsZXQgdD0wO3Q8ZS5sZW5ndGgtMjt0Kyspbi5wdXNoKGcuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoZVt0KzJdLHJbdF0saVt0XSxvW3RdLGEsdCx0K2UubGVuZ3RoLTIscykpfXN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0LGUsbixyLGksbyxhLHMpe2NvbnN0IHU9biooci0xKSsxO2lmKCFzfHxcIk5PVFNFVFwiPT09cylyZXR1cm4gTWF0aC5mbG9vcigodCtpW29dK2lbYV0tdSkvZSsxKTtzd2l0Y2gocyl7Y2FzZVwiVkFMSURcIjpyZXR1cm4gaVtvXT0wLGlbYV09MCxNYXRoLmZsb29yKCh0LXUpL2UrMSk7Y2FzZVwiU0FNRV9MT1dFUlwiOmNhc2VcIlNBTUVfVVBQRVJcIjppZigxIT09bil0aHJvdyBuZXcgRXJyb3IoXCJEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVJcIik7e2NvbnN0IG49KCh0K2UtMSkvZS0xKSplK3ItdDtyZXR1cm4gaVtvXT1cIlNBTUVfTE9XRVJcIj09PXM/TWF0aC5mbG9vcigobisxKS8yKTpNYXRoLmZsb29yKG4vMiksaVthXT1uLWlbb10sTWF0aC5mbG9vcigodCtuLXIpL2UrMSl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBBdXRvUGFkIHR5cGVcIil9fX1lLlBvb2xDb252VXRpbD1nLGUuTUlOX0NMSVA9LTM0MDI4MjM0NjYzODUyODg2ZTIyLGUuTUFYX0NMSVA9MzQwMjgyMzQ2NjM4NTI4ODZlMjIsZS5kZWNvZGVVdGY4U3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybihuZXcgVGV4dERlY29kZXIpLmRlY29kZSh0KX19LDc5Njc6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLml0ZXJhdGVFeHRyYU9wdGlvbnM9dm9pZCAwLGUuaXRlcmF0ZUV4dHJhT3B0aW9ucz0odCxuLHIsaSk9PntpZihcIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXQpe2lmKHIuaGFzKHQpKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zXCIpO3IuYWRkKHQpfU9iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goKChbdCxvXSk9Pntjb25zdCBhPW4/bit0OnQ7aWYoXCJvYmplY3RcIj09dHlwZW9mIG8pKDAsZS5pdGVyYXRlRXh0cmFPcHRpb25zKShvLGErXCIuXCIscixpKTtlbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBvfHxcIm51bWJlclwiPT10eXBlb2YgbylpKGEsby50b1N0cmluZygpKTtlbHNle2lmKFwiYm9vbGVhblwiIT10eXBlb2Ygbyl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6IFwiK3R5cGVvZiBvKTtpKGEsbz9cIjFcIjpcIjBcIil9fSkpfX0sMjE1NzpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHIsaT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2kmJiEoXCJnZXRcImluIGk/IWUuX19lc01vZHVsZTppLndyaXRhYmxlfHxpLmNvbmZpZ3VyYWJsZSl8fChpPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlW25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsaSl9OmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pLHRbcl09ZVtuXX0pLG89dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pfTpmdW5jdGlvbih0LGUpe3QuZGVmYXVsdD1lfSksYT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmaShlLHQsbik7cmV0dXJuIG8oZSx0KSxlfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmVuZFByb2ZpbGluZz1lLnJ1bj1lLnJlbGVhc2VTZXNzaW9uPWUuY3JlYXRlU2Vzc2lvbj1lLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT1lLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZT1lLmluaXRPcnQ9ZS5pbml0V2FzbT12b2lkIDA7Y29uc3Qgcz1uKDE2NzApLHU9YShuKDM0OSkpLGM9big2MzYxKSxsPSgpPT4hIXMuZW52Lndhc20ucHJveHkmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudDtsZXQgcCxmLGQsaD0hMSxnPSExLGI9ITE7Y29uc3QgbT1bXSx5PVtdLF89W10sdj1bXSx3PVtdLHg9W10sVD0oKT0+e2lmKGh8fCFnfHxifHwhcCl0aHJvdyBuZXcgRXJyb3IoXCJ3b3JrZXIgbm90IHJlYWR5XCIpfSxTPXQ9Pntzd2l0Y2godC5kYXRhLnR5cGUpe2Nhc2VcImluaXQtd2FzbVwiOmg9ITEsdC5kYXRhLmVycj8oYj0hMCxmWzFdKHQuZGF0YS5lcnIpKTooZz0hMCxmWzBdKCkpO2JyZWFrO2Nhc2VcImluaXQtb3J0XCI6dC5kYXRhLmVycj9kWzFdKHQuZGF0YS5lcnIpOmRbMF0oKTticmVhaztjYXNlXCJjcmVhdGVfYWxsb2NhdGVcIjp0LmRhdGEuZXJyP20uc2hpZnQoKVsxXSh0LmRhdGEuZXJyKTptLnNoaWZ0KClbMF0odC5kYXRhLm91dCk7YnJlYWs7Y2FzZVwiY3JlYXRlX2ZpbmFsaXplXCI6dC5kYXRhLmVycj95LnNoaWZ0KClbMV0odC5kYXRhLmVycik6eS5zaGlmdCgpWzBdKHQuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcImNyZWF0ZVwiOnQuZGF0YS5lcnI/Xy5zaGlmdCgpWzFdKHQuZGF0YS5lcnIpOl8uc2hpZnQoKVswXSh0LmRhdGEub3V0KTticmVhaztjYXNlXCJyZWxlYXNlXCI6dC5kYXRhLmVycj92LnNoaWZ0KClbMV0odC5kYXRhLmVycik6di5zaGlmdCgpWzBdKCk7YnJlYWs7Y2FzZVwicnVuXCI6dC5kYXRhLmVycj93LnNoaWZ0KClbMV0odC5kYXRhLmVycik6dy5zaGlmdCgpWzBdKHQuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcImVuZC1wcm9maWxpbmdcIjp0LmRhdGEuZXJyP3guc2hpZnQoKVsxXSh0LmRhdGEuZXJyKTp4LnNoaWZ0KClbMF0oKX19LE89XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50P251bGw9PT0ocj1udWxsPT09ZG9jdW1lbnR8fHZvaWQgMD09PWRvY3VtZW50P3ZvaWQgMDpkb2N1bWVudC5jdXJyZW50U2NyaXB0KXx8dm9pZCAwPT09cj92b2lkIDA6ci5zcmM6dm9pZCAwO2UuaW5pdFdhc209YXN5bmMoKT0+e2lmKGwoKSl7aWYoZylyZXR1cm47aWYoaCl0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdFdhc20oKScgZGV0ZWN0ZWQuXCIpO2lmKGIpdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdFdhc20oKScgZmFpbGVkLlwiKTtyZXR1cm4gaD0hMCx2b2lkIDA9PT1zLmVudi53YXNtLndhc21QYXRocyYmTyYmMCE9PU8uaW5kZXhPZihcImJsb2I6XCIpJiYocy5lbnYud2FzbS53YXNtUGF0aHM9Ty5zdWJzdHIoMCwrTy5sYXN0SW5kZXhPZihcIi9cIikrMSkpLG5ldyBQcm9taXNlKCgodCxlKT0+e251bGw9PXB8fHAudGVybWluYXRlKCkscD1uKDk3MTApLlooKSxwLm9ubWVzc2FnZT1TLGY9W3QsZV07Y29uc3Qgcj17dHlwZTpcImluaXQtd2FzbVwiLGluOnMuZW52Lndhc219O3AucG9zdE1lc3NhZ2Uocil9KSl9cmV0dXJuKDAsYy5pbml0aWFsaXplV2ViQXNzZW1ibHkpKHMuZW52Lndhc20pfSxlLmluaXRPcnQ9YXN5bmModCxlKT0+e2lmKGwoKSlyZXR1cm4gVCgpLG5ldyBQcm9taXNlKCgobixyKT0+e2Q9W24scl07Y29uc3QgaT17dHlwZTpcImluaXQtb3J0XCIsaW46e251bVRocmVhZHM6dCxsb2dnaW5nTGV2ZWw6ZX19O3AucG9zdE1lc3NhZ2UoaSl9KSk7dS5pbml0T3J0KHQsZSl9LGUuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPWFzeW5jIHQ9PmwoKT8oVCgpLG5ldyBQcm9taXNlKCgoZSxuKT0+e20ucHVzaChbZSxuXSk7Y29uc3Qgcj17dHlwZTpcImNyZWF0ZV9hbGxvY2F0ZVwiLGluOnttb2RlbDp0fX07cC5wb3N0TWVzc2FnZShyLFt0LmJ1ZmZlcl0pfSkpKTp1LmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSh0KSxlLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT1hc3luYyh0LGUpPT5sKCk/KFQoKSxuZXcgUHJvbWlzZSgoKG4scik9Pnt5LnB1c2goW24scl0pO2NvbnN0IGk9e3R5cGU6XCJjcmVhdGVfZmluYWxpemVcIixpbjp7bW9kZWxkYXRhOnQsb3B0aW9uczplfX07cC5wb3N0TWVzc2FnZShpKX0pKSk6dS5jcmVhdGVTZXNzaW9uRmluYWxpemUodCxlKSxlLmNyZWF0ZVNlc3Npb249YXN5bmModCxlKT0+bCgpPyhUKCksbmV3IFByb21pc2UoKChuLHIpPT57Xy5wdXNoKFtuLHJdKTtjb25zdCBpPXt0eXBlOlwiY3JlYXRlXCIsaW46e21vZGVsOnQsb3B0aW9uczplfX07cC5wb3N0TWVzc2FnZShpLFt0LmJ1ZmZlcl0pfSkpKTp1LmNyZWF0ZVNlc3Npb24odCxlKSxlLnJlbGVhc2VTZXNzaW9uPWFzeW5jIHQ9PntpZihsKCkpcmV0dXJuIFQoKSxuZXcgUHJvbWlzZSgoKGUsbik9Pnt2LnB1c2goW2Usbl0pO2NvbnN0IHI9e3R5cGU6XCJyZWxlYXNlXCIsaW46dH07cC5wb3N0TWVzc2FnZShyKX0pKTt1LnJlbGVhc2VTZXNzaW9uKHQpfSxlLnJ1bj1hc3luYyh0LGUsbixyLGkpPT5sKCk/KFQoKSxuZXcgUHJvbWlzZSgoKG8sYSk9Pnt3LnB1c2goW28sYV0pO2NvbnN0IHM9e3R5cGU6XCJydW5cIixpbjp7c2Vzc2lvbklkOnQsaW5wdXRJbmRpY2VzOmUsaW5wdXRzOm4sb3V0cHV0SW5kaWNlczpyLG9wdGlvbnM6aX19O3AucG9zdE1lc3NhZ2Uocyx1LmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzKG4pKX0pKSk6dS5ydW4odCxlLG4scixpKSxlLmVuZFByb2ZpbGluZz1hc3luYyB0PT57aWYobCgpKXJldHVybiBUKCksbmV3IFByb21pc2UoKChlLG4pPT57eC5wdXNoKFtlLG5dKTtjb25zdCByPXt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGluOnR9O3AucG9zdE1lc3NhZ2Uocil9KSk7dS5lbmRQcm9maWxpbmcodCl9fSw1ODY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuc2V0UnVuT3B0aW9ucz12b2lkIDA7Y29uc3Qgcj1uKDc5NjcpLGk9big0OTgzKSxvPW4oNjM2MSk7ZS5zZXRSdW5PcHRpb25zPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCk7bGV0IG49MDtjb25zdCBhPVtdLHM9dHx8e307dHJ5e2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1NldmVyaXR5TGV2ZWwpKXMubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYoXCJudW1iZXJcIiE9dHlwZW9mIHQubG9nU2V2ZXJpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dTZXZlcml0eUxldmVsKXx8dC5sb2dTZXZlcml0eUxldmVsPDB8fHQubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7dC5sb2dTZXZlcml0eUxldmVsfWApO2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1ZlcmJvc2l0eUxldmVsKSlzLmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dWZXJib3NpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1ZlcmJvc2l0eUxldmVsfWApO3ZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LnRlcm1pbmF0ZSkmJihzLnRlcm1pbmF0ZT0hMSk7bGV0IG89MDtpZih2b2lkIDAhPT0obnVsbD09dD92b2lkIDA6dC50YWcpJiYobz0oMCxpLmFsbG9jV2FzbVN0cmluZykodC50YWcsYSkpLG49ZS5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhzLmxvZ1NldmVyaXR5TGV2ZWwscy5sb2dWZXJib3NpdHlMZXZlbCwhIXMudGVybWluYXRlLG8pLDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9uc1wiKTtyZXR1cm4gdm9pZCAwIT09KG51bGw9PXQ/dm9pZCAwOnQuZXh0cmEpJiYoMCxyLml0ZXJhdGVFeHRyYU9wdGlvbnMpKHQuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoKHQscik9Pntjb25zdCBvPSgwLGkuYWxsb2NXYXNtU3RyaW5nKSh0LGEpLHM9KDAsaS5hbGxvY1dhc21TdHJpbmcpKHIsYSk7aWYoMCE9PWUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KG4sbyxzKSl0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7dH0gLSAke3J9YCl9KSksW24sYV19Y2F0Y2godCl7dGhyb3cgMCE9PW4mJmUuX09ydFJlbGVhc2VSdW5PcHRpb25zKG4pLGEuZm9yRWFjaChlLl9mcmVlKSx0fX19LDIzMDY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyPXZvaWQgMDtjb25zdCByPW4oMjgwNiksaT1uKDE2NzApLG89bigyODUwKSxhPW4oMjE1Nyk7bGV0IHM7ZS5Pbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXI9Y2xhc3N7YXN5bmMgY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKHQpe2NvbnN0IGU9YXdhaXQgZmV0Y2godCksbj1hd2FpdCBlLmFycmF5QnVmZmVyKCk7cmV0dXJuKDAsYS5jcmVhdGVTZXNzaW9uQWxsb2NhdGUpKG5ldyBVaW50OEFycmF5KG4pKX1hc3luYyBsb2FkTW9kZWwodCxlKXtpZihzfHwoYXdhaXQoMCxhLmluaXRPcnQpKGkuZW52Lndhc20ubnVtVGhyZWFkcywodD0+e3N3aXRjaCh0KXtjYXNlXCJ2ZXJib3NlXCI6cmV0dXJuIDA7Y2FzZVwiaW5mb1wiOnJldHVybiAxO2Nhc2VcIndhcm5pbmdcIjpyZXR1cm4gMjtjYXNlXCJlcnJvclwiOnJldHVybiAzO2Nhc2VcImZhdGFsXCI6cmV0dXJuIDQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7dH1gKX19KShpLmVudi5sb2dMZXZlbCkpLHM9ITApLFwic3RyaW5nXCI9PXR5cGVvZiB0KWlmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBmZXRjaCl7Y29uc3Qgbj1hd2FpdCgwLG8ucHJvbWlzaWZ5KShyLnJlYWRGaWxlKSh0KTtbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0KDAsYS5jcmVhdGVTZXNzaW9uKShuLGUpfWVsc2V7Y29uc3Qgbj1hd2FpdCB0aGlzLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSh0KTtbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0KDAsYS5jcmVhdGVTZXNzaW9uRmluYWxpemUpKG4sZSl9ZWxzZVt0aGlzLnNlc3Npb25JZCx0aGlzLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lc109YXdhaXQoMCxhLmNyZWF0ZVNlc3Npb24pKHQsZSl9YXN5bmMgZGlzcG9zZSgpe3JldHVybigwLGEucmVsZWFzZVNlc3Npb24pKHRoaXMuc2Vzc2lvbklkKX1hc3luYyBydW4odCxlLG4pe2NvbnN0IHI9W10sbz1bXTtPYmplY3QuZW50cmllcyh0KS5mb3JFYWNoKCh0PT57Y29uc3QgZT10WzBdLG49dFsxXSxpPXRoaXMuaW5wdXROYW1lcy5pbmRleE9mKGUpO2lmKC0xPT09aSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5wdXQgJyR7ZX0nYCk7ci5wdXNoKG4pLG8ucHVzaChpKX0pKTtjb25zdCBzPVtdO09iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKHQ9Pntjb25zdCBlPXRbMF0sbj10aGlzLm91dHB1dE5hbWVzLmluZGV4T2YoZSk7aWYoLTE9PT1uKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvdXRwdXQgJyR7ZX0nYCk7cy5wdXNoKG4pfSkpO2NvbnN0IHU9YXdhaXQoMCxhLnJ1bikodGhpcy5zZXNzaW9uSWQsbyxyLm1hcCgodD0+W3QudHlwZSx0LmRpbXMsdC5kYXRhXSkpLHMsbiksYz17fTtmb3IobGV0IHQ9MDt0PHUubGVuZ3RoO3QrKyljW3RoaXMub3V0cHV0TmFtZXNbc1t0XV1dPW5ldyBpLlRlbnNvcih1W3RdWzBdLHVbdF1bMl0sdVt0XVsxXSk7cmV0dXJuIGN9c3RhcnRQcm9maWxpbmcoKXt9ZW5kUHJvZmlsaW5nKCl7KDAsYS5lbmRQcm9maWxpbmcpKHRoaXMuc2Vzc2lvbklkKX19fSw0OTE5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNldFNlc3Npb25PcHRpb25zPXZvaWQgMDtjb25zdCByPW4oNzk2NyksaT1uKDQ5ODMpLG89big2MzYxKTtlLnNldFNlc3Npb25PcHRpb25zPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCk7bGV0IG49MDtjb25zdCBhPVtdLHM9dHx8e307KHQ9Pnt0LmV4dHJhfHwodC5leHRyYT17fSksdC5leHRyYS5zZXNzaW9ufHwodC5leHRyYS5zZXNzaW9uPXt9KTtjb25zdCBlPXQuZXh0cmEuc2Vzc2lvbjtlLnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fChlLnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpfSkocyk7dHJ5e3ZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwpJiYocy5ncmFwaE9wdGltaXphdGlvbkxldmVsPVwiYWxsXCIpO2NvbnN0IHU9KHQ9Pntzd2l0Y2godCl7Y2FzZVwiZGlzYWJsZWRcIjpyZXR1cm4gMDtjYXNlXCJiYXNpY1wiOnJldHVybiAxO2Nhc2VcImV4dGVuZGVkXCI6cmV0dXJuIDI7Y2FzZVwiYWxsXCI6cmV0dXJuIDk5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBncmFwaCBvcHRpbWl6YXRpb24gbGV2ZWw6ICR7dH1gKX19KShzLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwpO3ZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmVuYWJsZUNwdU1lbUFyZW5hKSYmKHMuZW5hYmxlQ3B1TWVtQXJlbmE9ITApLHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmVuYWJsZU1lbVBhdHRlcm4pJiYocy5lbmFibGVNZW1QYXR0ZXJuPSEwKSx2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5leGVjdXRpb25Nb2RlKSYmKHMuZXhlY3V0aW9uTW9kZT1cInNlcXVlbnRpYWxcIik7Y29uc3QgYz0odD0+e3N3aXRjaCh0KXtjYXNlXCJzZXF1ZW50aWFsXCI6cmV0dXJuIDA7Y2FzZVwicGFyYWxsZWxcIjpyZXR1cm4gMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7dH1gKX19KShzLmV4ZWN1dGlvbk1vZGUpO2xldCBsPTA7aWYodm9pZCAwIT09KG51bGw9PXQ/dm9pZCAwOnQubG9nSWQpJiYobD0oMCxpLmFsbG9jV2FzbVN0cmluZykodC5sb2dJZCxhKSksdm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nU2V2ZXJpdHlMZXZlbCkpcy5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dTZXZlcml0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1NldmVyaXR5TGV2ZWwpfHx0LmxvZ1NldmVyaXR5TGV2ZWw8MHx8dC5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nVmVyYm9zaXR5TGV2ZWwpKXMubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKFwibnVtYmVyXCIhPXR5cGVvZiB0LmxvZ1ZlcmJvc2l0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke3QubG9nVmVyYm9zaXR5TGV2ZWx9YCk7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQuZW5hYmxlUHJvZmlsaW5nKSYmKHMuZW5hYmxlUHJvZmlsaW5nPSExKSxuPWUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKHUsISFzLmVuYWJsZUNwdU1lbUFyZW5hLCEhcy5lbmFibGVNZW1QYXR0ZXJuLGMsISFzLmVuYWJsZVByb2ZpbGluZywwLGwscy5sb2dTZXZlcml0eUxldmVsLHMubG9nVmVyYm9zaXR5TGV2ZWwpLDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnNcIik7cmV0dXJuKG51bGw9PXQ/dm9pZCAwOnQuZXhlY3V0aW9uUHJvdmlkZXJzKSYmKCh0LGUsbik9Pntmb3IoY29uc3QgciBvZiBlKXtsZXQgZT1cInN0cmluZ1wiPT10eXBlb2Ygcj9yOnIubmFtZTtzd2l0Y2goZSl7Y2FzZVwieG5ucGFja1wiOmU9XCJYTk5QQUNLXCI7YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIEVQOiAke2V9YCl9Y29uc3QgYT0oMCxpLmFsbG9jV2FzbVN0cmluZykoZSxuKTtpZigwIT09KDAsby5nZXRJbnN0YW5jZSkoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIodCxhKSl0aHJvdyBuZXcgRXJyb3IoYENhbid0IGFwcGVuZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7ZX1gKX19KShuLHQuZXhlY3V0aW9uUHJvdmlkZXJzLGEpLHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LmV4dHJhKSYmKDAsci5pdGVyYXRlRXh0cmFPcHRpb25zKSh0LmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKCh0LHIpPT57Y29uc3Qgbz0oMCxpLmFsbG9jV2FzbVN0cmluZykodCxhKSxzPSgwLGkuYWxsb2NXYXNtU3RyaW5nKShyLGEpO2lmKDAhPT1lLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkobixvLHMpKXRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7dH0gLSAke3J9YCl9KSksW24sYV19Y2F0Y2godCl7dGhyb3cgMCE9PW4mJmUuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhuKSxhLmZvckVhY2goZS5fZnJlZSksdH19fSw0OTgzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmFsbG9jV2FzbVN0cmluZz12b2lkIDA7Y29uc3Qgcj1uKDYzNjEpO2UuYWxsb2NXYXNtU3RyaW5nPSh0LGUpPT57Y29uc3Qgbj0oMCxyLmdldEluc3RhbmNlKSgpLGk9bi5sZW5ndGhCeXRlc1VURjgodCkrMSxvPW4uX21hbGxvYyhpKTtyZXR1cm4gbi5zdHJpbmdUb1VURjgodCxvLGkpLGUucHVzaChvKSxvfX0sMzQ5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzPWUuZW5kUHJvZmlsaW5nPWUucnVuPWUucmVsZWFzZVNlc3Npb249ZS5jcmVhdGVTZXNzaW9uPWUuY3JlYXRlU2Vzc2lvbkZpbmFsaXplPWUuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPWUuaW5pdE9ydD12b2lkIDA7Y29uc3Qgcj1uKDU4NiksaT1uKDQ5MTkpLG89big0OTgzKSxhPW4oNjM2MSk7ZS5pbml0T3J0PSh0LGUpPT57Y29uc3Qgbj0oMCxhLmdldEluc3RhbmNlKSgpLl9PcnRJbml0KHQsZSk7aWYoMCE9PW4pdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBpbml0aWFsaXplIG9ubnhydW50aW1lLiBlcnJvciBjb2RlID0gJHtufWApfTtjb25zdCBzPW5ldyBNYXA7ZS5jcmVhdGVTZXNzaW9uQWxsb2NhdGU9dD0+e2NvbnN0IGU9KDAsYS5nZXRJbnN0YW5jZSkoKSxuPWUuX21hbGxvYyh0LmJ5dGVMZW5ndGgpO3JldHVybiBlLkhFQVBVOC5zZXQodCxuKSxbbix0LmJ5dGVMZW5ndGhdfSxlLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT0odCxlKT0+e2NvbnN0IG49KDAsYS5nZXRJbnN0YW5jZSkoKTtsZXQgcj0wLG89MCx1PVtdO3RyeXtpZihbbyx1XT0oMCxpLnNldFNlc3Npb25PcHRpb25zKShlKSxyPW4uX09ydENyZWF0ZVNlc3Npb24odFswXSx0WzFdLG8pLDA9PT1yKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBhIHNlc3Npb25cIil9ZmluYWxseXtuLl9mcmVlKHRbMF0pLG4uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhvKSx1LmZvckVhY2gobi5fZnJlZSl9Y29uc3QgYz1uLl9PcnRHZXRJbnB1dENvdW50KHIpLGw9bi5fT3J0R2V0T3V0cHV0Q291bnQocikscD1bXSxmPVtdLGQ9W10saD1bXTtmb3IobGV0IHQ9MDt0PGM7dCsrKXtjb25zdCBlPW4uX09ydEdldElucHV0TmFtZShyLHQpO2lmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGdldCBhbiBpbnB1dCBuYW1lXCIpO2YucHVzaChlKSxwLnB1c2gobi5VVEY4VG9TdHJpbmcoZSkpfWZvcihsZXQgdD0wO3Q8bDt0Kyspe2NvbnN0IGU9bi5fT3J0R2V0T3V0cHV0TmFtZShyLHQpO2lmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGdldCBhbiBvdXRwdXQgbmFtZVwiKTtoLnB1c2goZSksZC5wdXNoKG4uVVRGOFRvU3RyaW5nKGUpKX1yZXR1cm4gcy5zZXQocixbcixmLGhdKSxbcixwLGRdfSxlLmNyZWF0ZVNlc3Npb249KHQsbik9Pntjb25zdCByPSgwLGUuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKSh0KTtyZXR1cm4oMCxlLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZSkocixuKX0sZS5yZWxlYXNlU2Vzc2lvbj10PT57Y29uc3QgZT0oMCxhLmdldEluc3RhbmNlKSgpLG49cy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2NvbnN0IHI9blswXSxpPW5bMV0sbz1uWzJdO2kuZm9yRWFjaChlLl9PcnRGcmVlKSxvLmZvckVhY2goZS5fT3J0RnJlZSksZS5fT3J0UmVsZWFzZVNlc3Npb24ocikscy5kZWxldGUodCl9O2NvbnN0IHU9dD0+e3N3aXRjaCh0KXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDE7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiAxMTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gODtjYXNlXCJpbnQ2NFwiOnJldHVybiA3O2Nhc2VcInVpbnQ2NFwiOnJldHVybiAxMztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R9YCl9fSxjPXQ9Pntzd2l0Y2godCl7Y2FzZSAzOnJldHVyblwiaW50OFwiO2Nhc2UgMjpyZXR1cm5cInVpbnQ4XCI7Y2FzZSA5OnJldHVyblwiYm9vbFwiO2Nhc2UgNTpyZXR1cm5cImludDE2XCI7Y2FzZSA0OnJldHVyblwidWludDE2XCI7Y2FzZSA2OnJldHVyblwiaW50MzJcIjtjYXNlIDEyOnJldHVyblwidWludDMyXCI7Y2FzZSAxOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgMTE6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSA4OnJldHVyblwic3RyaW5nXCI7Y2FzZSA3OnJldHVyblwiaW50NjRcIjtjYXNlIDEzOnJldHVyblwidWludDY0XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fWApfX0sbD10PT57c3dpdGNoKHQpe2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6Y2FzZVwiYm9vbFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImludDhcIjpyZXR1cm4gSW50OEFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcImludDMyXCI6cmV0dXJuIEludDMyQXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke3R9YCl9fTtlLnJ1bj0odCxlLG4saSxwKT0+e2NvbnN0IGY9KDAsYS5nZXRJbnN0YW5jZSkoKSxkPXMuZ2V0KHQpO2lmKCFkKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtjb25zdCBoPWRbMF0sZz1kWzFdLGI9ZFsyXSxtPWUubGVuZ3RoLHk9aS5sZW5ndGg7bGV0IF89MCx2PVtdO2NvbnN0IHc9W10seD1bXTt0cnl7W18sdl09KDAsci5zZXRSdW5PcHRpb25zKShwKTtmb3IobGV0IHQ9MDt0PG07dCsrKXtjb25zdCBlPW5bdF1bMF0scj1uW3RdWzFdLGk9blt0XVsyXTtsZXQgYSxzO2lmKEFycmF5LmlzQXJyYXkoaSkpe3M9NCppLmxlbmd0aCxhPWYuX21hbGxvYyhzKSx4LnB1c2goYSk7bGV0IHQ9YS80O2ZvcihsZXQgZT0wO2U8aS5sZW5ndGg7ZSsrKXtpZihcInN0cmluZ1wiIT10eXBlb2YgaVtlXSl0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke2V9IGlzIG5vdCBhIHN0cmluZ2ApO2YuSEVBUFUzMlt0KytdPSgwLG8uYWxsb2NXYXNtU3RyaW5nKShpW2VdLHgpfX1lbHNlIHM9aS5ieXRlTGVuZ3RoLGE9Zi5fbWFsbG9jKHMpLHgucHVzaChhKSxmLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoaS5idWZmZXIsaS5ieXRlT2Zmc2V0LHMpLGEpO2NvbnN0IGM9Zi5zdGFja1NhdmUoKSxsPWYuc3RhY2tBbGxvYyg0KnIubGVuZ3RoKTt0cnl7bGV0IHQ9bC80O3IuZm9yRWFjaCgoZT0+Zi5IRUFQMzJbdCsrXT1lKSk7Y29uc3Qgbj1mLl9PcnRDcmVhdGVUZW5zb3IodShlKSxhLHMsbCxyLmxlbmd0aCk7aWYoMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY3JlYXRlIGEgdGVuc29yXCIpO3cucHVzaChuKX1maW5hbGx5e2Yuc3RhY2tSZXN0b3JlKGMpfX1jb25zdCB0PWYuc3RhY2tTYXZlKCksYT1mLnN0YWNrQWxsb2MoNCptKSxzPWYuc3RhY2tBbGxvYyg0Km0pLGQ9Zi5zdGFja0FsbG9jKDQqeSksVD1mLnN0YWNrQWxsb2MoNCp5KTt0cnl7bGV0IG49YS80LHI9cy80LG89ZC80LHU9VC80O2ZvcihsZXQgdD0wO3Q8bTt0KyspZi5IRUFQVTMyW24rK109d1t0XSxmLkhFQVBVMzJbcisrXT1nW2VbdF1dO2ZvcihsZXQgdD0wO3Q8eTt0KyspZi5IRUFQVTMyW28rK109MCxmLkhFQVBVMzJbdSsrXT1iW2lbdF1dO2xldCBwPWYuX09ydFJ1bihoLHMsYSxtLFQseSxkLF8pO2NvbnN0IHY9W107aWYoMD09PXApZm9yKGxldCB0PTA7dDx5O3QrKyl7Y29uc3QgZT1mLkhFQVBVMzJbZC80K3RdLG49Zi5zdGFja1NhdmUoKSxyPWYuc3RhY2tBbGxvYygxNik7bGV0IGksbz0wO3RyeXtpZihwPWYuX09ydEdldFRlbnNvckRhdGEoZSxyLHIrNCxyKzgscisxMiksMCE9PXApdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhLiBlcnJvciBjb2RlID0gJHtwfWApO2xldCB0PXIvNDtjb25zdCBhPWYuSEVBUFUzMlt0KytdO289Zi5IRUFQVTMyW3QrK107Y29uc3Qgcz1mLkhFQVBVMzJbdCsrXSx1PWYuSEVBUFUzMlt0KytdLGQ9W107Zm9yKGxldCB0PTA7dDx1O3QrKylkLnB1c2goZi5IRUFQVTMyW3MvNCt0XSk7Zi5fT3J0RnJlZShzKTtjb25zdCBoPTA9PT1kLmxlbmd0aD8xOmQucmVkdWNlKCgodCxlKT0+dCplKSk7aWYoaT1jKGEpLFwic3RyaW5nXCI9PT1pKXtjb25zdCB0PVtdO2xldCBlPW8vNDtmb3IobGV0IG49MDtuPGg7bisrKXtjb25zdCByPWYuSEVBUFUzMltlKytdLGk9bj09PWgtMT92b2lkIDA6Zi5IRUFQVTMyW2VdLXI7dC5wdXNoKGYuVVRGOFRvU3RyaW5nKHIsaSkpfXYucHVzaChbaSxkLHRdKX1lbHNle2NvbnN0IHQ9bmV3KGwoaSkpKGgpO25ldyBVaW50OEFycmF5KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCx0LmJ5dGVMZW5ndGgpLnNldChmLkhFQVBVOC5zdWJhcnJheShvLG8rdC5ieXRlTGVuZ3RoKSksdi5wdXNoKFtpLGQsdF0pfX1maW5hbGx5e2Yuc3RhY2tSZXN0b3JlKG4pLFwic3RyaW5nXCI9PT1pJiZvJiZmLl9mcmVlKG8pLGYuX09ydFJlbGVhc2VUZW5zb3IoZSl9fWlmKDA9PT1wKXJldHVybiB2O3Rocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGNhbGwgT3J0UnVuKCkuIGVycm9yIGNvZGUgPSAke3B9LmApfWZpbmFsbHl7Zi5zdGFja1Jlc3RvcmUodCl9fWZpbmFsbHl7dy5mb3JFYWNoKGYuX09ydFJlbGVhc2VUZW5zb3IpLHguZm9yRWFjaChmLl9mcmVlKSxmLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyhfKSx2LmZvckVhY2goZi5fZnJlZSl9fSxlLmVuZFByb2ZpbGluZz10PT57Y29uc3QgZT0oMCxhLmdldEluc3RhbmNlKSgpLG49cy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2NvbnN0IHI9blswXSxpPWUuX09ydEVuZFByb2ZpbGluZyhyKTtpZigwPT09aSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBnZXQgYW4gcHJvZmlsZSBmaWxlIG5hbWVcIik7ZS5fT3J0RnJlZShpKX0sZS5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycz10PT57Y29uc3QgZT1bXTtmb3IoY29uc3QgbiBvZiB0KXtjb25zdCB0PW5bMl07IUFycmF5LmlzQXJyYXkodCkmJnQuYnVmZmVyJiZlLnB1c2godC5idWZmZXIpfXJldHVybiBlfX0sNjM2MTpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pO3ZhciBpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKTtpJiYhKFwiZ2V0XCJpbiBpPyFlLl9fZXNNb2R1bGU6aS53cml0YWJsZXx8aS5jb25maWd1cmFibGUpfHwoaT17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZVtuXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLGkpfTpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1uKSx0W3JdPWVbbl19KSxpPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih0LGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KX06ZnVuY3Rpb24odCxlKXt0LmRlZmF1bHQ9ZX0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgZT17fTtpZihudWxsIT10KWZvcih2YXIgbiBpbiB0KVwiZGVmYXVsdFwiIT09biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJnIoZSx0LG4pO3JldHVybiBpKGUsdCksZX0sYT10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmRpc3Bvc2U9ZS5nZXRJbnN0YW5jZT1lLmluaXRpYWxpemVXZWJBc3NlbWJseT12b2lkIDA7Y29uc3Qgcz1vKG4oNjQ0OSkpLHU9YShuKDkzMikpLGM9bigzNDc0KTtsZXQgbCxwPSExLGY9ITEsZD0hMTtjb25zdCBoPSh0LGUpPT5lP3Q/XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21cIjpcIm9ydC13YXNtLXRocmVhZGVkLndhc21cIjp0P1wib3J0LXdhc20tc2ltZC53YXNtXCI6XCJvcnQtd2FzbS53YXNtXCI7ZS5pbml0aWFsaXplV2ViQXNzZW1ibHk9YXN5bmMgdD0+e2lmKHApcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2lmKGYpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBkZXRlY3RlZC5cIik7aWYoZCl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZmFpbGVkLlwiKTtmPSEwO2NvbnN0IGU9dC5pbml0VGltZW91dCxyPXQubnVtVGhyZWFkcyxpPXQuc2ltZCxvPXI+MSYmKCgpPT57dHJ5e3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciYmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBNZXNzYWdlQ2hhbm5lbCYmKG5ldyBNZXNzYWdlQ2hhbm5lbCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpKX1jYXRjaCh0KXtyZXR1cm4hMX19KSgpLGE9aSYmKCgpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMzAsMSwyOCwwLDY1LDAsMjUzLDE1LDI1MywxMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1MywxODYsMSwyNiwxMV0pKX1jYXRjaCh0KXtyZXR1cm4hMX19KSgpLGc9XCJzdHJpbmdcIj09dHlwZW9mIHQud2FzbVBhdGhzP3Qud2FzbVBhdGhzOnZvaWQgMCxiPWgoITEsbyksbT1oKGEsbykseT1cIm9iamVjdFwiPT10eXBlb2YgdC53YXNtUGF0aHM/dC53YXNtUGF0aHNbbV06dm9pZCAwO2xldCBfPSExO2NvbnN0IHY9W107aWYoZT4wJiZ2LnB1c2gobmV3IFByb21pc2UoKHQ9PntzZXRUaW1lb3V0KCgoKT0+e189ITAsdCgpfSksZSl9KSkpLHYucHVzaChuZXcgUHJvbWlzZSgoKHQsZSk9Pntjb25zdCByPW8/Yzp1LmRlZmF1bHQsaT17bG9jYXRlRmlsZToodCxlKT0+byYmdC5lbmRzV2l0aChcIi53b3JrZXIuanNcIikmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBCbG9iP1VSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW24oNDE1NCldLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSk6dD09PWI/bnVsbCE9eT95OihudWxsIT1nP2c6ZSkrbTplK3R9O2lmKG8paWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIEJsb2IpaS5tYWluU2NyaXB0VXJsT3JCbG9iPXMuam9pbihcIi9cIixcIm9ydC13YXNtLXRocmVhZGVkLmpzXCIpO2Vsc2V7Y29uc3QgdD1gdmFyIG9ydFdhc21UaHJlYWRlZD0oZnVuY3Rpb24oKXt2YXIgX3NjcmlwdERpcjtyZXR1cm4gJHtyLnRvU3RyaW5nKCl9fSkoKTtgO2kubWFpblNjcmlwdFVybE9yQmxvYj1uZXcgQmxvYihbdF0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pfXIoaSkudGhlbigoZT0+e2Y9ITEscD0hMCxsPWUsdCgpfSksKHQ9PntmPSExLGQ9ITAsZSh0KX0pKX0pKSksYXdhaXQgUHJvbWlzZS5yYWNlKHYpLF8pdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7ZX1tc2ApfSxlLmdldEluc3RhbmNlPSgpPT57aWYocCYmbClyZXR1cm4gbDt0aHJvdyBuZXcgRXJyb3IoXCJXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LlwiKX0sZS5kaXNwb3NlPSgpPT57dmFyIHQ7IXB8fGZ8fGR8fChmPSEwLG51bGw9PT0odD1sLlBUaHJlYWQpfHx2b2lkIDA9PT10fHx0LnRlcm1pbmF0ZUFsbFRocmVhZHMoKSxsPXZvaWQgMCxmPSExLHA9ITEsZD0hMCl9fSw5NzEwOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtuLmQoZSx7WjooKT0+b30pO3ZhciByPW4oNDc3KSxpPW4ubihyKTtmdW5jdGlvbiBvKCl7cmV0dXJuIGkoKSgnLyohXFxuKiBPTk5YIFJ1bnRpbWUgV2ViIHYxLjE0LjBcXG4qIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxcbiovXFxuKCgpPT57dmFyIHQ9ezQ3NDoodCxlLG4pPT57dmFyIF9zY3JpcHREaXIscj0oX3NjcmlwdERpcj0oX3NjcmlwdERpcj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwKXx8XCIvaW5kZXguanNcIixmdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIGouYnVmZmVyIT1EJiZOKGouYnVmZmVyKSxQfWZ1bmN0aW9uIHIoKXtyZXR1cm4gai5idWZmZXIhPUQmJk4oai5idWZmZXIpLFV9ZnVuY3Rpb24gYSgpe3JldHVybiBqLmJ1ZmZlciE9RCYmTihqLmJ1ZmZlciksRn1mdW5jdGlvbiBpKCl7cmV0dXJuIGouYnVmZmVyIT1EJiZOKGouYnVmZmVyKSxJfWZ1bmN0aW9uIG8oKXtyZXR1cm4gai5idWZmZXIhPUQmJk4oai5idWZmZXIpLFd9dmFyIHUsYyxzO3Q9dHx8e30sdXx8KHU9dm9pZCAwIT09dD90Ont9KSx1LnJlYWR5PW5ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe2M9dCxzPWV9KSk7dmFyIGwsZixwLGgsZCx5LGI9T2JqZWN0LmFzc2lnbih7fSx1KSxtPVwiLi90aGlzLnByb2dyYW1cIixnPSh0LGUpPT57dGhyb3cgZX0sdj1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93LHc9XCJmdW5jdGlvblwiPT10eXBlb2YgaW1wb3J0U2NyaXB0cyxfPVwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzJiZcIm9iamVjdFwiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyYmXCJzdHJpbmdcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSxPPXUuRU5WSVJPTk1FTlRfSVNfUFRIUkVBRHx8ITEsQT1cIlwiO2Z1bmN0aW9uIFModCl7cmV0dXJuIHUubG9jYXRlRmlsZT91LmxvY2F0ZUZpbGUodCxBKTpBK3R9aWYoXyl7bGV0IGU7QT13P24oOTA4KS5kaXJuYW1lKEEpK1wiL1wiOlwiLy9cIix5PSgpPT57ZHx8KGg9bigzODQpLGQ9big5MDgpKX0sbD1mdW5jdGlvbih0LGUpe3JldHVybiB5KCksdD1kLm5vcm1hbGl6ZSh0KSxoLnJlYWRGaWxlU3luYyh0LGU/dm9pZCAwOlwidXRmOFwiKX0scD10PT4oKHQ9bCh0LCEwKSkuYnVmZmVyfHwodD1uZXcgVWludDhBcnJheSh0KSksdCksZj0odCxlLG4pPT57eSgpLHQ9ZC5ub3JtYWxpemUodCksaC5yZWFkRmlsZSh0LChmdW5jdGlvbih0LHIpe3Q/bih0KTplKHIuYnVmZmVyKX0pKX0sMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYobT1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXFxcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSxwcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIiwoZnVuY3Rpb24odCl7aWYoISh0IGluc3RhbmNlb2YgY3QpKXRocm93IHR9KSkscHJvY2Vzcy5vbihcInVuaGFuZGxlZFJlamVjdGlvblwiLChmdW5jdGlvbih0KXt0aHJvdyB0fSkpLGc9KHQsZSk9PntpZihRKCkpdGhyb3cgcHJvY2Vzcy5leGl0Q29kZT10LGU7ZSBpbnN0YW5jZW9mIGN0fHx4KFwiZXhpdGluZyBkdWUgdG8gZXhjZXB0aW9uOiBcIitlKSxwcm9jZXNzLmV4aXQodCl9LHUuaW5zcGVjdD1mdW5jdGlvbigpe3JldHVyblwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn07dHJ5e2U9big5MjUpfWNhdGNoKHQpe3Rocm93IGNvbnNvbGUuZXJyb3IoXFwnVGhlIFwid29ya2VyX3RocmVhZHNcIiBtb2R1bGUgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIG5vZGUuanMgYnVpbGQgLSBwZXJoYXBzIGEgbmV3ZXIgdmVyc2lvbiBpcyBuZWVkZWQ/XFwnKSx0fW4uZy5Xb3JrZXI9ZS5Xb3JrZXJ9ZWxzZSh2fHx3KSYmKHc/QT1zZWxmLmxvY2F0aW9uLmhyZWY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoQT1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksX3NjcmlwdERpciYmKEE9X3NjcmlwdERpciksQT0wIT09QS5pbmRleE9mKFwiYmxvYjpcIik/QS5zdWJzdHIoMCxBLnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOlwiXCIsX3x8KGw9dD0+e3ZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gZS5vcGVuKFwiR0VUXCIsdCwhMSksZS5zZW5kKG51bGwpLGUucmVzcG9uc2VUZXh0fSx3JiYocD10PT57dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBlLm9wZW4oXCJHRVRcIix0LCExKSxlLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsZS5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KGUucmVzcG9uc2UpfSksZj0odCxlLG4pPT57dmFyIHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3Iub3BlbihcIkdFVFwiLHQsITApLHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixyLm9ubG9hZD0oKT0+ezIwMD09ci5zdGF0dXN8fDA9PXIuc3RhdHVzJiZyLnJlc3BvbnNlP2Uoci5yZXNwb25zZSk6bigpfSxyLm9uZXJyb3I9bixyLnNlbmQobnVsbCl9KSk7XyYmXCJ1bmRlZmluZWRcIj09dHlwZW9mIHBlcmZvcm1hbmNlJiYobi5nLnBlcmZvcm1hbmNlPW4oOTUzKS5wZXJmb3JtYW5jZSk7dmFyIFQ9Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxFPWNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO18mJih5KCksVD10PT5oLndyaXRlU3luYygxLHQrXCJcXFxcblwiKSxFPXQ9Pmgud3JpdGVTeW5jKDIsdCtcIlxcXFxuXCIpKTt2YXIgTSxDPXUucHJpbnR8fFQseD11LnByaW50RXJyfHxFO09iamVjdC5hc3NpZ24odSxiKSxiPW51bGwsdS50aGlzUHJvZ3JhbSYmKG09dS50aGlzUHJvZ3JhbSksdS5xdWl0JiYoZz11LnF1aXQpLHUud2FzbUJpbmFyeSYmKE09dS53YXNtQmluYXJ5KTt2YXIgUj11Lm5vRXhpdFJ1bnRpbWV8fCExO1wib2JqZWN0XCIhPXR5cGVvZiBXZWJBc3NlbWJseSYmYXQoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciBqLGssRCxQLFUsRixJLFcsSD0hMSxMPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMDtmdW5jdGlvbiB6KHQsZSxuKXt2YXIgcj0oZT4+Pj0wKStuO2ZvcihuPWU7dFtuXSYmIShuPj1yKTspKytuO2lmKDE2PG4tZSYmdC5idWZmZXImJkwpcmV0dXJuIEwuZGVjb2RlKHQuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXI/dC5zbGljZShlLG4pOnQuc3ViYXJyYXkoZSxuKSk7Zm9yKHI9XCJcIjtlPG47KXt2YXIgYT10W2UrK107aWYoMTI4JmEpe3ZhciBpPTYzJnRbZSsrXTtpZigxOTI9PSgyMjQmYSkpcis9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmYSk8PDZ8aSk7ZWxzZXt2YXIgbz02MyZ0W2UrK107NjU1MzY+KGE9MjI0PT0oMjQwJmEpPygxNSZhKTw8MTJ8aTw8NnxvOig3JmEpPDwxOHxpPDwxMnxvPDw2fDYzJnRbZSsrXSk/cis9U3RyaW5nLmZyb21DaGFyQ29kZShhKTooYS09NjU1MzYscis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxhPj4xMCw1NjMyMHwxMDIzJmEpKX19ZWxzZSByKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpfXJldHVybiByfWZ1bmN0aW9uIFkodCxlKXtyZXR1cm4odD4+Pj0wKT96KHIoKSx0LGUpOlwiXCJ9ZnVuY3Rpb24gQih0LGUsbixyKXtpZighKDA8cikpcmV0dXJuIDA7dmFyIGE9bj4+Pj0wO3I9bityLTE7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDsrK2kpe3ZhciBvPXQuY2hhckNvZGVBdChpKTtpZig1NTI5Njw9byYmNTczNDM+PW8mJihvPTY1NTM2KygoMTAyMyZvKTw8MTApfDEwMjMmdC5jaGFyQ29kZUF0KCsraSkpLDEyNz49byl7aWYobj49cilicmVhaztlW24rKz4+PjBdPW99ZWxzZXtpZigyMDQ3Pj1vKXtpZihuKzE+PXIpYnJlYWs7ZVtuKys+Pj4wXT0xOTJ8bz4+Nn1lbHNle2lmKDY1NTM1Pj1vKXtpZihuKzI+PXIpYnJlYWs7ZVtuKys+Pj4wXT0yMjR8bz4+MTJ9ZWxzZXtpZihuKzM+PXIpYnJlYWs7ZVtuKys+Pj4wXT0yNDB8bz4+MTgsZVtuKys+Pj4wXT0xMjh8bz4+MTImNjN9ZVtuKys+Pj4wXT0xMjh8bz4+NiY2M31lW24rKz4+PjBdPTEyOHw2MyZvfX1yZXR1cm4gZVtuPj4+MF09MCxuLWF9ZnVuY3Rpb24gRyh0KXtmb3IodmFyIGU9MCxuPTA7bjx0Lmxlbmd0aDsrK24pe3ZhciByPXQuY2hhckNvZGVBdChuKTsxMjc+PXI/ZSsrOjIwNDc+PXI/ZSs9Mjo1NTI5Njw9ciYmNTczNDM+PXI/KGUrPTQsKytuKTplKz0zfXJldHVybiBlfWZ1bmN0aW9uIE4odCl7RD10LHUuSEVBUDg9UD1uZXcgSW50OEFycmF5KHQpLHUuSEVBUDE2PW5ldyBJbnQxNkFycmF5KHQpLHUuSEVBUDMyPUY9bmV3IEludDMyQXJyYXkodCksdS5IRUFQVTg9VT1uZXcgVWludDhBcnJheSh0KSx1LkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KHQpLHUuSEVBUFUzMj1JPW5ldyBVaW50MzJBcnJheSh0KSx1LkhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheSh0KSx1LkhFQVBGNjQ9Vz1uZXcgRmxvYXQ2NEFycmF5KHQpfU8mJihEPXUuYnVmZmVyKTt2YXIgVj11LklOSVRJQUxfTUVNT1JZfHwxNjc3NzIxNjtpZihPKWo9dS53YXNtTWVtb3J5LEQ9dS5idWZmZXI7ZWxzZSBpZih1Lndhc21NZW1vcnkpaj11Lndhc21NZW1vcnk7ZWxzZSBpZighKChqPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6Vi82NTUzNixtYXhpbXVtOjY1NTM2LHNoYXJlZDohMH0pKS5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikpdGhyb3cgeChcInJlcXVlc3RlZCBhIHNoYXJlZCBXZWJBc3NlbWJseS5NZW1vcnkgYnV0IHRoZSByZXR1cm5lZCBidWZmZXIgaXMgbm90IGEgU2hhcmVkQXJyYXlCdWZmZXIsIGluZGljYXRpbmcgdGhhdCB3aGlsZSB0aGUgYnJvd3NlciBoYXMgU2hhcmVkQXJyYXlCdWZmZXIgaXQgZG9lcyBub3QgaGF2ZSBXZWJBc3NlbWJseSB0aHJlYWRzIHN1cHBvcnQgLSB5b3UgbWF5IG5lZWQgdG8gc2V0IGEgZmxhZ1wiKSxfJiZjb25zb2xlLmxvZyhcIihvbiBub2RlIHlvdSBtYXkgbmVlZDogLS1leHBlcmltZW50YWwtd2FzbS10aHJlYWRzIC0tZXhwZXJpbWVudGFsLXdhc20tYnVsay1tZW1vcnkgYW5kIGFsc28gdXNlIGEgcmVjZW50IHZlcnNpb24pXCIpLEVycm9yKFwiYmFkIG1lbW9yeVwiKTtqJiYoRD1qLmJ1ZmZlciksVj1ELmJ5dGVMZW5ndGgsTihEKTt2YXIgJCxxPVtdLFg9W10sSj1bXSxaPVtdO2Z1bmN0aW9uIFEoKXtyZXR1cm4gUnx8ITF9ZnVuY3Rpb24gSygpe3ZhciB0PXUucHJlUnVuLnNoaWZ0KCk7cS51bnNoaWZ0KHQpfXZhciB0dCxldD0wLG50PW51bGwscnQ9bnVsbDtmdW5jdGlvbiBhdCh0KXt0aHJvdyBPP3Bvc3RNZXNzYWdlKHtjbWQ6XCJvbkFib3J0XCIsYXJnOnR9KTp1Lm9uQWJvcnQmJnUub25BYm9ydCh0KSx4KHQ9XCJBYm9ydGVkKFwiK3QrXCIpXCIpLEg9ITAsdD1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHQrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLHModCksdH1mdW5jdGlvbiBpdCgpe3JldHVybiB0dC5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKX1mdW5jdGlvbiBvdCgpe3ZhciB0PXR0O3RyeXtpZih0PT10dCYmTSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoTSk7aWYocClyZXR1cm4gcCh0KTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1jYXRjaCh0KXthdCh0KX19dHQ9XCJvcnQtd2FzbS10aHJlYWRlZC53YXNtXCIsaXQoKXx8KHR0PVModHQpKTt2YXIgdXQ9e307ZnVuY3Rpb24gY3QodCl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiLHRoaXMubWVzc2FnZT1cIlByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoXCIrdCtcIilcIix0aGlzLnN0YXR1cz10fWZ1bmN0aW9uIHN0KHQpeyh0PWh0LlZiW3RdKXx8YXQoKSxodC5tYyh0KX1mdW5jdGlvbiBsdCh0KXt2YXIgZT1odC5DYygpO2lmKCFlKXJldHVybiA2O2h0LmFjLnB1c2goZSksaHQuVmJbdC5VYl09ZSxlLlViPXQuVWI7dmFyIG49e2NtZDpcInJ1blwiLHN0YXJ0X3JvdXRpbmU6dC5JYyxhcmc6dC56YyxwdGhyZWFkX3B0cjp0LlVifTtyZXR1cm4gZS4kYj0oKT0+e24udGltZT1wZXJmb3JtYW5jZS5ub3coKSxlLnBvc3RNZXNzYWdlKG4sdC5OYyl9LGUubG9hZGVkJiYoZS4kYigpLGRlbGV0ZSBlLiRiKSwwfWZ1bmN0aW9uIGZ0KHQpe2lmKE8pcmV0dXJuICR0KDEsMSx0KTtRKCl8fChodC5vYygpLHUub25FeGl0JiZ1Lm9uRXhpdCh0KSxIPSEwKSxnKHQsbmV3IGN0KHQpKX1mdW5jdGlvbiBwdCh0LGUpe2lmKCFlJiZPKXRocm93IGJ0KHQpLFwidW53aW5kXCI7USgpfHxPfHwobWUoKSxkdChKKSxiZSgwKSxyZVsxXS5sZW5ndGgmJmFlKDEsMTApLHJlWzJdLmxlbmd0aCYmYWUoMiwxMCksaHQub2MoKSksZnQodCl9dmFyIGh0PXtZYjpbXSxhYzpbXSxxYzpbXSxWYjp7fSxmYzpmdW5jdGlvbigpe08mJmh0LkVjKCl9LFBjOmZ1bmN0aW9uKCl7fSxFYzpmdW5jdGlvbigpe2h0LnJlY2VpdmVPYmplY3RUcmFuc2Zlcj1odC5HYyxodC50aHJlYWRJbml0VExTPWh0LnBjLGh0LnNldEV4aXRTdGF0dXM9aHQubmMsUj0hMX0sbmM6ZnVuY3Rpb24oKXt9LG9jOmZ1bmN0aW9uKCl7Zm9yKHZhciB0IG9mIE9iamVjdC52YWx1ZXMoaHQuVmIpKWh0Lm1jKHQpO2Zvcih0IG9mIGh0LlliKXQudGVybWluYXRlKCk7aHQuWWI9W119LG1jOmZ1bmN0aW9uKHQpe3ZhciBlPXQuVWI7ZGVsZXRlIGh0LlZiW2VdLGh0LlliLnB1c2godCksaHQuYWMuc3BsaWNlKGh0LmFjLmluZGV4T2YodCksMSksdC5VYj0wLE9lKGUpfSxHYzpmdW5jdGlvbigpe30scGM6ZnVuY3Rpb24oKXtodC5xYy5mb3JFYWNoKCh0PT50KCkpKX0sRmM6ZnVuY3Rpb24odCxlKXt0Lm9ubWVzc2FnZT1uPT57dmFyIHI9KG49bi5kYXRhKS5jbWQ7aWYodC5VYiYmKGh0LkJjPXQuVWIpLG4udGFyZ2V0VGhyZWFkJiZuLnRhcmdldFRocmVhZCE9aGUoKSl7dmFyIGE9aHQuVmJbbi5RY107YT9hLnBvc3RNZXNzYWdlKG4sbi50cmFuc2Zlckxpc3QpOngoXFwnSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIlxcJytyK1xcJ1wiIHRvIHRhcmdldCBwdGhyZWFkIFxcJytuLnRhcmdldFRocmVhZCtcIiwgYnV0IHRoYXQgdGhyZWFkIG5vIGxvbmdlciBleGlzdHMhXCIpfWVsc2VcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCI9PT1yP3p0KG4ucXVldWUpOlwic3Bhd25UaHJlYWRcIj09PXI/bHQobik6XCJjbGVhbnVwVGhyZWFkXCI9PT1yP3N0KG4udGhyZWFkKTpcImtpbGxUaHJlYWRcIj09PXI/KG49bi50aHJlYWQscj1odC5WYltuXSxkZWxldGUgaHQuVmJbbl0sci50ZXJtaW5hdGUoKSxPZShuKSxodC5hYy5zcGxpY2UoaHQuYWMuaW5kZXhPZihyKSwxKSxyLlViPTApOlwiY2FuY2VsVGhyZWFkXCI9PT1yP2h0LlZiW24udGhyZWFkXS5wb3N0TWVzc2FnZSh7Y21kOlwiY2FuY2VsXCJ9KTpcImxvYWRlZFwiPT09cj8odC5sb2FkZWQ9ITAsZSYmZSh0KSx0LiRiJiYodC4kYigpLGRlbGV0ZSB0LiRiKSk6XCJwcmludFwiPT09cj9DKFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJwcmludEVyclwiPT09cj94KFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJhbGVydFwiPT09cj9hbGVydChcIlRocmVhZCBcIituLnRocmVhZElkK1wiOiBcIituLnRleHQpOlwic2V0aW1tZWRpYXRlXCI9PT1uLnRhcmdldD90LnBvc3RNZXNzYWdlKG4pOlwib25BYm9ydFwiPT09cj91Lm9uQWJvcnQmJnUub25BYm9ydChuLmFyZyk6ciYmeChcIndvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCBcIityKTtodC5CYz12b2lkIDB9LHQub25lcnJvcj10PT57dGhyb3cgeChcIndvcmtlciBzZW50IGFuIGVycm9yISBcIit0LmZpbGVuYW1lK1wiOlwiK3QubGluZW5vK1wiOiBcIit0Lm1lc3NhZ2UpLHR9LF8mJih0Lm9uKFwibWVzc2FnZVwiLChmdW5jdGlvbihlKXt0Lm9ubWVzc2FnZSh7ZGF0YTplfSl9KSksdC5vbihcImVycm9yXCIsKGZ1bmN0aW9uKGUpe3Qub25lcnJvcihlKX0pKSx0Lm9uKFwiZGV0YWNoZWRFeGl0XCIsKGZ1bmN0aW9uKCl7fSkpKSx0LnBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkXCIsdXJsT3JCbG9iOnUubWFpblNjcmlwdFVybE9yQmxvYnx8X3NjcmlwdERpcix3YXNtTWVtb3J5Omosd2FzbU1vZHVsZTprfSl9LHljOmZ1bmN0aW9uKCl7dmFyIHQ9UyhcIm9ydC13YXNtLXRocmVhZGVkLndvcmtlci5qc1wiKTtodC5ZYi5wdXNoKG5ldyBXb3JrZXIodCkpfSxDYzpmdW5jdGlvbigpe3JldHVybiAwPT1odC5ZYi5sZW5ndGgmJihodC55YygpLGh0LkZjKGh0LlliWzBdKSksaHQuWWIucG9wKCl9fTtmdW5jdGlvbiBkdCh0KXtmb3IoOzA8dC5sZW5ndGg7KXQuc2hpZnQoKSh1KX1mdW5jdGlvbiB5dCh0KXt2YXIgZT1FZSgpO3JldHVybiB0PXQoKSxNZShlKSx0fWZ1bmN0aW9uIGJ0KHQpe2lmKE8pcmV0dXJuICR0KDIsMCx0KTt0cnl7cHQodCl9Y2F0Y2godCl7dCBpbnN0YW5jZW9mIGN0fHxcInVud2luZFwiPT10fHxnKDEsdCl9fXUuUFRocmVhZD1odCx1LmVzdGFibGlzaFN0YWNrU3BhY2U9ZnVuY3Rpb24oKXt2YXIgdD1oZSgpLGU9YSgpW3QrNDQ+PjI+Pj4wXTt0PWEoKVt0KzQ4Pj4yPj4+MF0sVGUoZSxlLXQpLE1lKGUpfTt2YXIgbXQ9W107ZnVuY3Rpb24gZ3QodCl7dmFyIGU9bXRbdF07cmV0dXJuIGV8fCh0Pj1tdC5sZW5ndGgmJihtdC5sZW5ndGg9dCsxKSxtdFt0XT1lPSQuZ2V0KHQpKSxlfXUuaW52b2tlRW50cnlQb2ludD1mdW5jdGlvbih0LGUpe3Q9Z3QodCkoZSksUSgpP2h0Lm5jKHQpOkFlKHQpfTt2YXIgdnQsd3QsX3Q9W10sT3Q9MCxBdD0wO2Z1bmN0aW9uIFN0KHQpe3RoaXMuWmI9dCx0aGlzLlNiPXQtMjQsdGhpcy54Yz1mdW5jdGlvbih0KXtpKClbdGhpcy5TYis0Pj4yPj4+MF09dH0sdGhpcy5iYz1mdW5jdGlvbigpe3JldHVybiBpKClbdGhpcy5TYis0Pj4yPj4+MF19LHRoaXMud2M9ZnVuY3Rpb24odCl7aSgpW3RoaXMuU2IrOD4+Mj4+PjBdPXR9LHRoaXMuRGM9ZnVuY3Rpb24oKXtyZXR1cm4gaSgpW3RoaXMuU2IrOD4+Mj4+PjBdfSx0aGlzLnJjPWZ1bmN0aW9uKCl7YSgpW3RoaXMuU2I+PjI+Pj4wXT0wfSx0aGlzLmhjPWZ1bmN0aW9uKHQpe3Q9dD8xOjAsZSgpW3RoaXMuU2IrMTI+PjA+Pj4wXT10fSx0aGlzLnVjPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPWUoKVt0aGlzLlNiKzEyPj4wPj4+MF19LHRoaXMuaWM9ZnVuY3Rpb24odCl7dD10PzE6MCxlKClbdGhpcy5TYisxMz4+MD4+PjBdPXR9LHRoaXMua2M9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9ZSgpW3RoaXMuU2IrMTM+PjA+Pj4wXX0sdGhpcy5mYz1mdW5jdGlvbih0LGUpe3RoaXMuY2MoMCksdGhpcy54Yyh0KSx0aGlzLndjKGUpLHRoaXMucmMoKSx0aGlzLmhjKCExKSx0aGlzLmljKCExKX0sdGhpcy5zYz1mdW5jdGlvbigpe0F0b21pY3MuYWRkKGEoKSx0aGlzLlNiPj4yLDEpfSx0aGlzLkhjPWZ1bmN0aW9uKCl7cmV0dXJuIDE9PT1BdG9taWNzLnN1YihhKCksdGhpcy5TYj4+MiwxKX0sdGhpcy5jYz1mdW5jdGlvbih0KXtpKClbdGhpcy5TYisxNj4+Mj4+PjBdPXR9LHRoaXMudGM9ZnVuY3Rpb24oKXtyZXR1cm4gaSgpW3RoaXMuU2IrMTY+PjI+Pj4wXX0sdGhpcy52Yz1mdW5jdGlvbigpe2lmKFJlKHRoaXMuYmMoKSkpcmV0dXJuIGkoKVt0aGlzLlpiPj4yPj4+MF07dmFyIHQ9dGhpcy50YygpO3JldHVybiAwIT09dD90OnRoaXMuWmJ9fWZ1bmN0aW9uIFR0KHQpe3JldHVybiB5ZShuZXcgU3QodCkuU2IpfWZ1bmN0aW9uIEV0KHQsZSxuLHIpe3JldHVybiBPPyR0KDMsMSx0LGUsbixyKTpNdCh0LGUsbixyKX1mdW5jdGlvbiBNdCh0LGUsbixyKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIpcmV0dXJuIHgoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciBhPVtdO3JldHVybiBPJiYwPT09YS5sZW5ndGg/RXQodCxlLG4scik6KHQ9e0ljOm4sVWI6dCx6YzpyLE5jOmF9LE8/KHQuT2M9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKHQsYSksMCk6bHQodCkpfWZ1bmN0aW9uIEN0KHQsZSxuKXtyZXR1cm4gTz8kdCg0LDEsdCxlLG4pOjB9ZnVuY3Rpb24geHQodCxlKXtpZihPKXJldHVybiAkdCg1LDEsdCxlKX1mdW5jdGlvbiBSdCh0LGUpe2lmKE8pcmV0dXJuICR0KDYsMSx0LGUpfWZ1bmN0aW9uIGp0KHQsZSxuKXtpZihPKXJldHVybiAkdCg3LDEsdCxlLG4pfWZ1bmN0aW9uIGt0KHQsZSxuKXtyZXR1cm4gTz8kdCg4LDEsdCxlLG4pOjB9ZnVuY3Rpb24gRHQodCxlKXtpZihPKXJldHVybiAkdCg5LDEsdCxlKX1mdW5jdGlvbiBQdCh0LGUsbil7aWYoTylyZXR1cm4gJHQoMTAsMSx0LGUsbil9ZnVuY3Rpb24gVXQodCxlLG4scil7aWYoTylyZXR1cm4gJHQoMTEsMSx0LGUsbixyKX1mdW5jdGlvbiBGdCh0LGUsbixyKXtpZihPKXJldHVybiAkdCgxMiwxLHQsZSxuLHIpfWZ1bmN0aW9uIEl0KHQsZSxuLHIpe2lmKE8pcmV0dXJuICR0KDEzLDEsdCxlLG4scil9ZnVuY3Rpb24gV3QodCl7aWYoTylyZXR1cm4gJHQoMTQsMSx0KX1mdW5jdGlvbiBIdCh0LGUpe2lmKE8pcmV0dXJuICR0KDE1LDEsdCxlKX1mdW5jdGlvbiBMdCh0LGUsbil7aWYoTylyZXR1cm4gJHQoMTYsMSx0LGUsbil9ZnVuY3Rpb24genQodCl7QXRvbWljcy5zdG9yZShhKCksdD4+MiwxKSxoZSgpJiZfZSh0KSxBdG9taWNzLmNvbXBhcmVFeGNoYW5nZShhKCksdD4+MiwxLDApfWZ1bmN0aW9uIFl0KHQpe3JldHVybiBpKClbdD4+PjJdKzQyOTQ5NjcyOTYqYSgpW3QrND4+PjJdfWZ1bmN0aW9uIEJ0KHQsZSxuLHIsYSxpKXtyZXR1cm4gTz8kdCgxNywxLHQsZSxuLHIsYSxpKTotNTJ9ZnVuY3Rpb24gR3QodCxlLG4scixhLGkpe2lmKE8pcmV0dXJuICR0KDE4LDEsdCxlLG4scixhLGkpfWZ1bmN0aW9uIE50KHQpe3ZhciBuPUcodCkrMSxyPWRlKG4pO3JldHVybiByJiZCKHQsZSgpLHIsbikscn1mdW5jdGlvbiBWdCh0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4odD10LnRvVGltZVN0cmluZygpLm1hdGNoKC9cXFxcKChbQS1aYS16IF0rKVxcXFwpJC8pKT90WzFdOlwiR01UXCJ9aWYoTylyZXR1cm4gJHQoMTksMSx0LGUsbik7dmFyIG89KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpLHU9bmV3IERhdGUobywwLDEpLGM9bmV3IERhdGUobyw2LDEpO289dS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBzPWMuZ2V0VGltZXpvbmVPZmZzZXQoKSxsPU1hdGgubWF4KG8scyk7YSgpW3Q+PjI+Pj4wXT02MCpsLGEoKVtlPj4yPj4+MF09TnVtYmVyKG8hPXMpLHQ9cih1KSxlPXIoYyksdD1OdCh0KSxlPU50KGUpLHM8bz8oaSgpW24+PjI+Pj4wXT10LGkoKVtuKzQ+PjI+Pj4wXT1lKTooaSgpW24+PjI+Pj4wXT1lLGkoKVtuKzQ+PjI+Pj4wXT10KX1mdW5jdGlvbiAkdCh0LGUpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGgtMixyPWFyZ3VtZW50cztyZXR1cm4geXQoKCgpPT57Zm9yKHZhciBhPUNlKDgqbiksaT1hPj4zLHU9MDt1PG47dSsrKXt2YXIgYz1yWzIrdV07bygpW2krdT4+PjBdPWN9cmV0dXJuIHdlKHQsbixhLGUpfSkpfXUuZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZT16dCx3dD1fPygpPT57dmFyIHQ9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gMWUzKnRbMF0rdFsxXS8xZTZ9Ok8/KCk9PnBlcmZvcm1hbmNlLm5vdygpLXUuX19wZXJmb3JtYW5jZV9ub3dfY2xvY2tfZHJpZnQ6KCk9PnBlcmZvcm1hbmNlLm5vdygpO3ZhciBxdCxYdD1bXSxKdD17fTtmdW5jdGlvbiBadCgpe2lmKCFxdCl7dmFyIHQsZT17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzooXCJvYmplY3RcIj09dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzptfHxcIi4vdGhpcy5wcm9ncmFtXCJ9O2Zvcih0IGluIEp0KXZvaWQgMD09PUp0W3RdP2RlbGV0ZSBlW3RdOmVbdF09SnRbdF07dmFyIG49W107Zm9yKHQgaW4gZSluLnB1c2godCtcIj1cIitlW3RdKTtxdD1ufXJldHVybiBxdH1mdW5jdGlvbiBRdCh0LG4pe2lmKE8pcmV0dXJuICR0KDIwLDEsdCxuKTt2YXIgcj0wO3JldHVybiBadCgpLmZvckVhY2goKGZ1bmN0aW9uKGEsbyl7dmFyIHU9bityO2ZvcihvPWkoKVt0KzQqbz4+Mj4+PjBdPXUsdT0wO3U8YS5sZW5ndGg7Kyt1KWUoKVtvKys+PjA+Pj4wXT1hLmNoYXJDb2RlQXQodSk7ZSgpW28+PjA+Pj4wXT0wLHIrPWEubGVuZ3RoKzF9KSksMH1mdW5jdGlvbiBLdCh0LGUpe2lmKE8pcmV0dXJuICR0KDIxLDEsdCxlKTt2YXIgbj1adCgpO2koKVt0Pj4yPj4+MF09bi5sZW5ndGg7dmFyIHI9MDtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbih0KXtyKz10Lmxlbmd0aCsxfSkpLGkoKVtlPj4yPj4+MF09ciwwfWZ1bmN0aW9uIHRlKHQpe3JldHVybiBPPyR0KDIyLDEsdCk6NTJ9ZnVuY3Rpb24gZWUodCxlLG4scil7cmV0dXJuIE8/JHQoMjMsMSx0LGUsbixyKTo1Mn1mdW5jdGlvbiBuZSh0LGUsbixyLGEpe3JldHVybiBPPyR0KDI0LDEsdCxlLG4scixhKTo3MH12YXIgcmU9W251bGwsW10sW11dO2Z1bmN0aW9uIGFlKHQsZSl7dmFyIG49cmVbdF07MD09PWV8fDEwPT09ZT8oKDE9PT10P0M6eCkoeihuLDApKSxuLmxlbmd0aD0wKTpuLnB1c2goZSl9ZnVuY3Rpb24gaWUodCxlLG4sYSl7aWYoTylyZXR1cm4gJHQoMjUsMSx0LGUsbixhKTtmb3IodmFyIG89MCx1PTA7dTxuO3UrKyl7dmFyIGM9aSgpW2U+PjI+Pj4wXSxzPWkoKVtlKzQ+PjI+Pj4wXTtlKz04O2Zvcih2YXIgbD0wO2w8cztsKyspYWUodCxyKClbYytsPj4+MF0pO28rPXN9cmV0dXJuIGkoKVthPj4yPj4+MF09bywwfXZhciBvZT0wO2Z1bmN0aW9uIHVlKHQpe3JldHVybiAwPT10JTQmJigwIT10JTEwMHx8MD09dCU0MDApfXZhciBjZT1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLHNlPVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24gbGUodCxuLHIsaSl7ZnVuY3Rpb24gbyh0LGUsbil7Zm9yKHQ9XCJudW1iZXJcIj09dHlwZW9mIHQ/dC50b1N0cmluZygpOnR8fFwiXCI7dC5sZW5ndGg8ZTspdD1uWzBdK3Q7cmV0dXJuIHR9ZnVuY3Rpb24gdSh0LGUpe3JldHVybiBvKHQsZSxcIjBcIil9ZnVuY3Rpb24gYyh0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuIDA+dD8tMTowPHQ/MTowfXZhciByO3JldHVybiAwPT09KHI9bih0LmdldEZ1bGxZZWFyKCktZS5nZXRGdWxsWWVhcigpKSkmJjA9PT0ocj1uKHQuZ2V0TW9udGgoKS1lLmdldE1vbnRoKCkpKSYmKHI9bih0LmdldERhdGUoKS1lLmdldERhdGUoKSkpLHJ9ZnVuY3Rpb24gcyh0KXtzd2l0Y2godC5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiB0O2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBsKHQpe3ZhciBlPXQuV2I7Zm9yKHQ9bmV3IERhdGUobmV3IERhdGUodC5YYisxOTAwLDAsMSkuZ2V0VGltZSgpKTswPGU7KXt2YXIgbj10LmdldE1vbnRoKCkscj0odWUodC5nZXRGdWxsWWVhcigpKT9jZTpzZSlbbl07aWYoIShlPnItdC5nZXREYXRlKCkpKXt0LnNldERhdGUodC5nZXREYXRlKCkrZSk7YnJlYWt9ZS09ci10LmdldERhdGUoKSsxLHQuc2V0RGF0ZSgxKSwxMT5uP3Quc2V0TW9udGgobisxKToodC5zZXRNb250aCgwKSx0LnNldEZ1bGxZZWFyKHQuZ2V0RnVsbFllYXIoKSsxKSl9cmV0dXJuIG49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpKzEsMCw0KSxlPXMobmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsNCkpLG49cyhuKSwwPj1jKGUsdCk/MD49YyhuLHQpP3QuZ2V0RnVsbFllYXIoKSsxOnQuZ2V0RnVsbFllYXIoKTp0LmdldEZ1bGxZZWFyKCktMX12YXIgZj1hKClbaSs0MD4+Mj4+PjBdO2Zvcih2YXIgcCBpbiBpPXtMYzphKClbaT4+Mj4+PjBdLEtjOmEoKVtpKzQ+PjI+Pj4wXSxkYzphKClbaSs4Pj4yPj4+MF0samM6YSgpW2krMTI+PjI+Pj4wXSxlYzphKClbaSsxNj4+Mj4+PjBdLFhiOmEoKVtpKzIwPj4yPj4+MF0sVGI6YSgpW2krMjQ+PjI+Pj4wXSxXYjphKClbaSsyOD4+Mj4+PjBdLFJjOmEoKVtpKzMyPj4yPj4+MF0sSmM6YSgpW2krMzY+PjI+Pj4wXSxNYzpmP1koZik6XCJcIn0scj1ZKHIpLGY9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifSlyPXIucmVwbGFjZShuZXcgUmVnRXhwKHAsXCJnXCIpLGZbcF0pO3ZhciBoPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksZD1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7Zm9yKHAgaW4gZj17XCIlYVwiOmZ1bmN0aW9uKHQpe3JldHVybiBoW3QuVGJdLnN1YnN0cmluZygwLDMpfSxcIiVBXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGhbdC5UYl19LFwiJWJcIjpmdW5jdGlvbih0KXtyZXR1cm4gZFt0LmVjXS5zdWJzdHJpbmcoMCwzKX0sXCIlQlwiOmZ1bmN0aW9uKHQpe3JldHVybiBkW3QuZWNdfSxcIiVDXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUoKHQuWGIrMTkwMCkvMTAwfDAsMil9LFwiJWRcIjpmdW5jdGlvbih0KXtyZXR1cm4gdSh0LmpjLDIpfSxcIiVlXCI6ZnVuY3Rpb24odCl7cmV0dXJuIG8odC5qYywyLFwiIFwiKX0sXCIlZ1wiOmZ1bmN0aW9uKHQpe3JldHVybiBsKHQpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVHXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGwodCl9LFwiJUhcIjpmdW5jdGlvbih0KXtyZXR1cm4gdSh0LmRjLDIpfSxcIiVJXCI6ZnVuY3Rpb24odCl7cmV0dXJuIDA9PSh0PXQuZGMpP3Q9MTI6MTI8dCYmKHQtPTEyKSx1KHQsMil9LFwiJWpcIjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPTA7bjw9dC5lYy0xO2UrPSh1ZSh0LlhiKzE5MDApP2NlOnNlKVtuKytdKTtyZXR1cm4gdSh0LmpjK2UsMyl9LFwiJW1cIjpmdW5jdGlvbih0KXtyZXR1cm4gdSh0LmVjKzEsMil9LFwiJU1cIjpmdW5jdGlvbih0KXtyZXR1cm4gdSh0LktjLDIpfSxcIiVuXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcXFxuXCJ9LFwiJXBcIjpmdW5jdGlvbih0KXtyZXR1cm4gMDw9dC5kYyYmMTI+dC5kYz9cIkFNXCI6XCJQTVwifSxcIiVTXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUodC5MYywyKX0sXCIldFwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXFxcdFwifSxcIiV1XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuVGJ8fDd9LFwiJVVcIjpmdW5jdGlvbih0KXtyZXR1cm4gdShNYXRoLmZsb29yKCh0LldiKzctdC5UYikvNyksMil9LFwiJVZcIjpmdW5jdGlvbih0KXt2YXIgZT1NYXRoLmZsb29yKCh0LldiKzctKHQuVGIrNiklNykvNyk7aWYoMj49KHQuVGIrMzcxLXQuV2ItMiklNyYmZSsrLGUpNTM9PWUmJig0PT0obj0odC5UYiszNzEtdC5XYiklNyl8fDM9PW4mJnVlKHQuWGIpfHwoZT0xKSk7ZWxzZXtlPTUyO3ZhciBuPSh0LlRiKzctdC5XYi0xKSU3Oyg0PT1ufHw1PT1uJiZ1ZSh0LlhiJTQwMC0xKSkmJmUrK31yZXR1cm4gdShlLDIpfSxcIiV3XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuVGJ9LFwiJVdcIjpmdW5jdGlvbih0KXtyZXR1cm4gdShNYXRoLmZsb29yKCh0LldiKzctKHQuVGIrNiklNykvNyksMil9LFwiJXlcIjpmdW5jdGlvbih0KXtyZXR1cm4odC5YYisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlWVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LlhiKzE5MDB9LFwiJXpcIjpmdW5jdGlvbih0KXt2YXIgZT0wPD0odD10LkpjKTtyZXR1cm4gdD1NYXRoLmFicyh0KS82MCwoZT9cIitcIjpcIi1cIikrU3RyaW5nKFwiMDAwMFwiKyh0LzYwKjEwMCt0JTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuTWN9LFwiJSVcIjpmdW5jdGlvbigpe3JldHVyblwiJVwifX0scj1yLnJlcGxhY2UoLyUlL2csXCJcXFxcMFxcXFwwXCIpLGYpci5pbmNsdWRlcyhwKSYmKHI9ci5yZXBsYWNlKG5ldyBSZWdFeHAocCxcImdcIiksZltwXShpKSkpO3JldHVybiBwPWZ1bmN0aW9uKHQpe3ZhciBlPUFycmF5KEcodCkrMSk7cmV0dXJuIEIodCxlLDAsZS5sZW5ndGgpLGV9KHI9ci5yZXBsYWNlKC9cXFxcMFxcXFwwL2csXCIlXCIpKSxwLmxlbmd0aD5uPzA6KGZ1bmN0aW9uKHQsbil7ZSgpLnNldCh0LG4+Pj4wKX0ocCx0KSxwLmxlbmd0aC0xKX1odC5mYygpO3ZhciBmZT1bbnVsbCxmdCxidCxFdCxDdCx4dCxSdCxqdCxrdCxEdCxQdCxVdCxGdCxJdCxXdCxIdCxMdCxCdCxHdCxWdCxRdCxLdCx0ZSxlZSxuZSxpZV0scGU9e2I6ZnVuY3Rpb24odCl7cmV0dXJuIGRlKHQrMjQpKzI0fSxuOmZ1bmN0aW9uKHQpe3JldHVybih0PW5ldyBTdCh0KSkudWMoKXx8KHQuaGMoITApLE90LS0pLHQuaWMoITEpLF90LnB1c2godCksdC5zYygpLHQudmMoKX0sbWE6ZnVuY3Rpb24odCl7dGhyb3cgeChcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uIHRocm93biwgdGhpcyBpcyBub3QgcHJvcGVybHkgc3VwcG9ydGVkIC0gYWJvcnRpbmdcIiksSD0hMCx0fSx4OmZ1bmN0aW9uKCl7U2UoMCk7dmFyIHQ9X3QucG9wKCk7aWYodC5IYygpJiYhdC5rYygpKXt2YXIgZT10LkRjKCk7ZSYmZ3QoZSkodC5aYiksVHQodC5aYil9QXQ9MH0sZTpmdW5jdGlvbigpe3ZhciB0PUF0O2lmKCF0KXJldHVybiBvZT0wO3ZhciBlPW5ldyBTdCh0KTtlLmNjKHQpO3ZhciBuPWUuYmMoKTtpZighbilyZXR1cm4gb2U9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGE9MDthPHIubGVuZ3RoO2ErKyl7dmFyIGk9clthXTtpZigwPT09aXx8aT09PW4pYnJlYWs7aWYoeGUoaSxuLGUuU2IrMTYpKXJldHVybiBvZT1pLHR9cmV0dXJuIG9lPW4sdH0sbDpmdW5jdGlvbigpe3ZhciB0PUF0O2lmKCF0KXJldHVybiBvZT0wO3ZhciBlPW5ldyBTdCh0KTtlLmNjKHQpO3ZhciBuPWUuYmMoKTtpZighbilyZXR1cm4gb2U9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGE9MDthPHIubGVuZ3RoO2ErKyl7dmFyIGk9clthXTtpZigwPT09aXx8aT09PW4pYnJlYWs7aWYoeGUoaSxuLGUuU2IrMTYpKXJldHVybiBvZT1pLHR9cmV0dXJuIG9lPW4sdH0saDpmdW5jdGlvbigpe3ZhciB0PUF0O2lmKCF0KXJldHVybiBvZT0wO3ZhciBlPW5ldyBTdCh0KTtlLmNjKHQpO3ZhciBuPWUuYmMoKTtpZighbilyZXR1cm4gb2U9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGE9MDthPHIubGVuZ3RoO2ErKyl7dmFyIGk9clthXTtpZigwPT09aXx8aT09PW4pYnJlYWs7aWYoeGUoaSxuLGUuU2IrMTYpKXJldHVybiBvZT1pLHR9cmV0dXJuIG9lPW4sdH0sdDpUdCxNOmZ1bmN0aW9uKCl7dmFyIHQ9X3QucG9wKCk7dHx8YXQoXCJubyBleGNlcHRpb24gdG8gdGhyb3dcIik7dmFyIGU9dC5aYjt0aHJvdyB0LmtjKCl8fChfdC5wdXNoKHQpLHQuaWMoITApLHQuaGMoITEpLE90KyspLEF0PWUsZX0sYzpmdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IFN0KHQpLmZjKGUsbiksQXQ9dCxPdCsrLHR9LHBhOmZ1bmN0aW9uKCl7cmV0dXJuIE90fSxGYTpmdW5jdGlvbih0KXtnZSh0LCF3LDEsIXYpLGh0LnBjKCl9LFQ6ZnVuY3Rpb24odCl7Tz9wb3N0TWVzc2FnZSh7Y21kOlwiY2xlYW51cFRocmVhZFwiLHRocmVhZDp0fSk6c3QodCl9LHhhOk10LGo6ZnVuY3Rpb24odCl7dGhyb3cgQXR8fChBdD10KSx0fSxIOkN0LE1hOnh0LHVhOlJ0LHdhOmp0LG9hOmt0LEthOkR0LENhOlB0LEphOlV0LFY6RnQsdmE6SXQsc2E6V3QsTGE6SHQsdGE6THQsVGE6ZnVuY3Rpb24oKXt9LFg6ZnVuY3Rpb24oKXthdChcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxVYTpmdW5jdGlvbigpe2F0KFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LFc6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX0seWE6ZnVuY3Rpb24oKXtyZXR1cm4gMjA5NzE1Mn0sT2E6ZnVuY3Rpb24oKXtyZXR1cm4hMH0semE6ZnVuY3Rpb24odCxlLG4scil7aWYodD09ZSlzZXRUaW1lb3V0KCgoKT0+enQocikpKTtlbHNlIGlmKE8pcG9zdE1lc3NhZ2Uoe3RhcmdldFRocmVhZDp0LGNtZDpcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCIscXVldWU6cn0pO2Vsc2V7aWYoISh0PWh0LlZiW3RdKSlyZXR1cm47dC5wb3N0TWVzc2FnZSh7Y21kOlwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIixxdWV1ZTpyfSl9cmV0dXJuIDF9LEVhOmZ1bmN0aW9uKCl7cmV0dXJuLTF9LFBhOmZ1bmN0aW9uKHQsZSl7dD1uZXcgRGF0ZSgxZTMqWXQodCkpLGEoKVtlPj4yPj4+MF09dC5nZXRVVENTZWNvbmRzKCksYSgpW2UrND4+Mj4+PjBdPXQuZ2V0VVRDTWludXRlcygpLGEoKVtlKzg+PjI+Pj4wXT10LmdldFVUQ0hvdXJzKCksYSgpW2UrMTI+PjI+Pj4wXT10LmdldFVUQ0RhdGUoKSxhKClbZSsxNj4+Mj4+PjBdPXQuZ2V0VVRDTW9udGgoKSxhKClbZSsyMD4+Mj4+PjBdPXQuZ2V0VVRDRnVsbFllYXIoKS0xOTAwLGEoKVtlKzI0Pj4yPj4+MF09dC5nZXRVVENEYXkoKSx0PSh0LmdldFRpbWUoKS1EYXRlLlVUQyh0LmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwLGEoKVtlKzI4Pj4yPj4+MF09dH0sUWE6ZnVuY3Rpb24odCxlKXt0PW5ldyBEYXRlKDFlMypZdCh0KSksYSgpW2U+PjI+Pj4wXT10LmdldFNlY29uZHMoKSxhKClbZSs0Pj4yPj4+MF09dC5nZXRNaW51dGVzKCksYSgpW2UrOD4+Mj4+PjBdPXQuZ2V0SG91cnMoKSxhKClbZSsxMj4+Mj4+PjBdPXQuZ2V0RGF0ZSgpLGEoKVtlKzE2Pj4yPj4+MF09dC5nZXRNb250aCgpLGEoKVtlKzIwPj4yPj4+MF09dC5nZXRGdWxsWWVhcigpLTE5MDAsYSgpW2UrMjQ+PjI+Pj4wXT10LmdldERheSgpO3ZhciBuPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDEpLHI9KHQuZ2V0VGltZSgpLW4uZ2V0VGltZSgpKS84NjRlNXwwO2EoKVtlKzI4Pj4yPj4+MF09cixhKClbZSszNj4+Mj4+PjBdPS02MCp0LmdldFRpbWV6b25lT2Zmc2V0KCkscj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLHQ9MHwociE9KG49bi5nZXRUaW1lem9uZU9mZnNldCgpKSYmdC5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbihuLHIpKSxhKClbZSszMj4+Mj4+PjBdPXR9LFJhOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBEYXRlKGEoKVt0KzIwPj4yPj4+MF0rMTkwMCxhKClbdCsxNj4+Mj4+PjBdLGEoKVt0KzEyPj4yPj4+MF0sYSgpW3QrOD4+Mj4+PjBdLGEoKVt0KzQ+PjI+Pj4wXSxhKClbdD4+Mj4+PjBdLDApLG49YSgpW3QrMzI+PjI+Pj4wXSxyPWUuZ2V0VGltZXpvbmVPZmZzZXQoKSxpPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDEpLG89bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSx1PWkuZ2V0VGltZXpvbmVPZmZzZXQoKSxjPU1hdGgubWluKHUsbyk7cmV0dXJuIDA+bj9hKClbdCszMj4+Mj4+PjBdPU51bWJlcihvIT11JiZjPT1yKTowPG4hPShjPT1yKSYmKG89TWF0aC5tYXgodSxvKSxlLnNldFRpbWUoZS5nZXRUaW1lKCkrNmU0KigoMDxuP2M6byktcikpKSxhKClbdCsyND4+Mj4+PjBdPWUuZ2V0RGF5KCksbj0oZS5nZXRUaW1lKCktaS5nZXRUaW1lKCkpLzg2NGU1fDAsYSgpW3QrMjg+PjI+Pj4wXT1uLGEoKVt0Pj4yPj4+MF09ZS5nZXRTZWNvbmRzKCksYSgpW3QrND4+Mj4+PjBdPWUuZ2V0TWludXRlcygpLGEoKVt0Kzg+PjI+Pj4wXT1lLmdldEhvdXJzKCksYSgpW3QrMTI+PjI+Pj4wXT1lLmdldERhdGUoKSxhKClbdCsxNj4+Mj4+PjBdPWUuZ2V0TW9udGgoKSxlLmdldFRpbWUoKS8xZTN8MH0sQWE6QnQsQmE6R3QsU2E6ZnVuY3Rpb24gdChlLG4scil7dC5BY3x8KHQuQWM9ITAsVnQoZSxuLHIpKX0seTpmdW5jdGlvbigpe2F0KFwiXCIpfSxVOmZ1bmN0aW9uKCl7aWYoIV8mJiF3KXt2YXIgdD1cIkJsb2NraW5nIG9uIHRoZSBtYWluIHRocmVhZCBpcyB2ZXJ5IGRhbmdlcm91cywgc2VlIGh0dHBzOi8vZW1zY3JpcHRlbi5vcmcvZG9jcy9wb3J0aW5nL3B0aHJlYWRzLmh0bWwjYmxvY2tpbmctb24tdGhlLW1haW4tYnJvd3Nlci10aHJlYWRcIjt2dHx8KHZ0PXt9KSx2dFt0XXx8KHZ0W3RdPTEsXyYmKHQ9XCJ3YXJuaW5nOiBcIit0KSx4KHQpKX19LHJhOmZ1bmN0aW9uKCl7cmV0dXJuIDQyOTQ5MDE3NjB9LEI6d3QsSWE6ZnVuY3Rpb24odCxlLG4pe3IoKS5jb3B5V2l0aGluKHQ+Pj4wLGU+Pj4wLGUrbj4+PjApfSxGOmZ1bmN0aW9uKCl7cmV0dXJuIF8/big5OTMpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3l9LERhOmZ1bmN0aW9uKHQsZSxuKXtYdC5sZW5ndGg9ZSxuPj49Mztmb3IodmFyIHI9MDtyPGU7cisrKVh0W3JdPW8oKVtuK3I+Pj4wXTtyZXR1cm4oMD50P3V0Wy10LTFdOmZlW3RdKS5hcHBseShudWxsLFh0KX0scWE6ZnVuY3Rpb24odCl7dmFyIGU9cigpLmxlbmd0aDtpZigodD4+Pj0wKTw9ZXx8NDI5NDkwMTc2MDx0KXJldHVybiExO2Zvcih2YXIgbj0xOzQ+PW47bio9Mil7dmFyIGE9ZSooMSsuMi9uKTthPU1hdGgubWluKGEsdCsxMDA2NjMyOTYpO3ZhciBpPU1hdGg7YT1NYXRoLm1heCh0LGEpLGk9aS5taW4uY2FsbChpLDQyOTQ5MDE3NjAsYSsoNjU1MzYtYSU2NTUzNiklNjU1MzYpO3Q6e3RyeXtqLmdyb3coaS1ELmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNiksTihqLmJ1ZmZlcik7dmFyIG89MTticmVhayB0fWNhdGNoKHQpe31vPXZvaWQgMH1pZihvKXJldHVybiEwfXJldHVybiExfSxOYTpmdW5jdGlvbigpe3Rocm93XCJ1bndpbmRcIn0sR2E6UXQsSGE6S3QsSjpwdCxJOnRlLFM6ZWUsZ2E6bmUsUjppZSxkOmZ1bmN0aW9uKCl7cmV0dXJuIG9lfSxuYTpmdW5jdGlvbiB0KHIsYSl7dC5sY3x8KHQubGM9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+KGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdFswXSl9aWYoXyl0cnl7dmFyIGU9bihPYmplY3QoZnVuY3Rpb24oKXt2YXIgdD1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgXFwnY3J5cHRvXFwnXCIpO3Rocm93IHQuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIix0fSgpKSk7cmV0dXJuKCk9PmUucmFuZG9tQnl0ZXMoMSlbMF19Y2F0Y2godCl7fXJldHVybigpPT5hdChcInJhbmRvbURldmljZVwiKX0oKSk7Zm9yKHZhciBpPTA7aTxhO2krKyllKClbcitpPj4wPj4+MF09dC5sYygpO3JldHVybiAwfSxpYTpmdW5jdGlvbih0LGUsbil7dmFyIHI9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbil9Y2F0Y2godCl7aWYoTWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxqYTpmdW5jdGlvbih0LGUsbil7dmFyIHI9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbil9Y2F0Y2godCl7aWYoTWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxLOmZ1bmN0aW9uKHQpe3ZhciBlPUVlKCk7dHJ5e3JldHVybiBndCh0KSgpfWNhdGNoKHQpe2lmKE1lKGUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sZjpmdW5jdGlvbih0LGUpe3ZhciBuPUVlKCk7dHJ5e3JldHVybiBndCh0KShlKX1jYXRjaCh0KXtpZihNZShuKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LFA6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4pfWNhdGNoKHQpe2lmKE1lKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sUTpmdW5jdGlvbih0LGUsbil7dmFyIHI9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbil9Y2F0Y2godCl7aWYoTWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxrOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuKX1jYXRjaCh0KXtpZihNZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHA6ZnVuY3Rpb24odCxlLG4scil7dmFyIGE9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihNZShhKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHE6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuLHIsYSl9Y2F0Y2godCl7aWYoTWUoaSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxOOmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuLHIsYSxpKX1jYXRjaCh0KXtpZihNZShvKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHM6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4scixhLGkpfWNhdGNoKHQpe2lmKE1lKG8pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sdzpmdW5jdGlvbih0LGUsbixyLGEsaSxvKXt2YXIgdT1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuLHIsYSxpLG8pfWNhdGNoKHQpe2lmKE1lKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sTDpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBjPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihNZShjKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LEU6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1LGMscyxsLGYpe3ZhciBwPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4scixhLGksbyx1LGMscyxsLGYpfWNhdGNoKHQpe2lmKE1lKHApLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sYWE6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1KXt2YXIgYz1FZSgpO3RyeXtyZXR1cm4gSGUodCxlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihNZShjKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LF86ZnVuY3Rpb24odCxlLG4scixhLGksbyl7dmFyIHU9RWUoKTt0cnl7cmV0dXJuIGtlKHQsZSxuLHIsYSxpLG8pfWNhdGNoKHQpe2lmKE1lKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sWjpmdW5jdGlvbih0LGUsbixyLGEpe3ZhciBpPUVlKCk7dHJ5e3JldHVybiBMZSh0LGUsbixyLGEpfWNhdGNoKHQpe2lmKE1lKGkpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sY2E6ZnVuY3Rpb24odCxlLG4scil7dmFyIGE9RWUoKTt0cnl7cmV0dXJuIEllKHQsZSxuLHIpfWNhdGNoKHQpe2lmKE1lKGEpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sJDpmdW5jdGlvbih0KXt2YXIgZT1FZSgpO3RyeXtyZXR1cm4gamUodCl9Y2F0Y2godCl7aWYoTWUoZSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxiYTpmdW5jdGlvbih0LGUpe3ZhciBuPUVlKCk7dHJ5e3JldHVybiBXZSh0LGUpfWNhdGNoKHQpe2lmKE1lKG4pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sWTpmdW5jdGlvbih0LGUsbil7dmFyIHI9RWUoKTt0cnl7cmV0dXJuIERlKHQsZSxuKX1jYXRjaCh0KXtpZihNZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGc6ZnVuY3Rpb24odCl7dmFyIGU9RWUoKTt0cnl7Z3QodCkoKX1jYXRjaCh0KXtpZihNZShlKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHI6ZnVuY3Rpb24odCxlKXt2YXIgbj1FZSgpO3RyeXtndCh0KShlKX1jYXRjaCh0KXtpZihNZShuKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGk6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUVlKCk7dHJ5e2d0KHQpKGUsbil9Y2F0Y2godCl7aWYoTWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxoYTpmdW5jdGlvbih0LGUsbixyKXt2YXIgYT1FZSgpO3RyeXtndCh0KShlLG4scil9Y2F0Y2godCl7aWYoTWUoYSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxtOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPUVlKCk7dHJ5e2d0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihNZShhKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHY6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1FZSgpO3RyeXtndCh0KShlLG4scixhKX1jYXRjaCh0KXtpZihNZShpKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHU6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUVlKCk7dHJ5e2d0KHQpKGUsbixyLGEsaSl9Y2F0Y2godCl7aWYoTWUobyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxPOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8pe3ZhciB1PUVlKCk7dHJ5e2d0KHQpKGUsbixyLGEsaSxvKX1jYXRjaCh0KXtpZihNZSh1KSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LEE6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1KXt2YXIgYz1FZSgpO3RyeXtndCh0KShlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihNZShjKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGthOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSxjKXt2YXIgcz1FZSgpO3RyeXtndCh0KShlLG4scixhLGksbyx1LGMpfWNhdGNoKHQpe2lmKE1lKHMpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sQzpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUsYyxzLGwpe3ZhciBmPUVlKCk7dHJ5e2d0KHQpKGUsbixyLGEsaSxvLHUsYyxzLGwpfWNhdGNoKHQpe2lmKE1lKGYpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sRDpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUsYyxzLGwsZixwLGgsZCx5KXt2YXIgYj1FZSgpO3RyeXtndCh0KShlLG4scixhLGksbyx1LGMscyxsLGYscCxoLGQseSl9Y2F0Y2godCl7aWYoTWUoYiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxmYTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBjPUVlKCk7dHJ5e1BlKHQsZSxuLHIsYSxpLG8sdSl9Y2F0Y2godCl7aWYoTWUoYyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxkYTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUsYyxzLGwsZil7dmFyIHA9RWUoKTt0cnl7RmUodCxlLG4scixhLGksbyx1LGMscyxsLGYpfWNhdGNoKHQpe2lmKE1lKHApLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sZWE6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUVlKCk7dHJ5e1VlKHQsZSxuLHIsYSxpKX1jYXRjaCh0KXtpZihNZShvKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LG86ZnVuY3Rpb24odCl7cmV0dXJuIHR9LGE6anx8dS53YXNtTWVtb3J5LEc6ZnVuY3Rpb24odCl7b2U9dH0sbGE6bGUsejpmdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gbGUodCxlLG4scil9fTshZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dS5hc209dC5leHBvcnRzLGh0LnFjLnB1c2godS5hc20uc2IpLCQ9dS5hc20udWIsWC51bnNoaWZ0KHUuYXNtLlZhKSxrPWUsT3x8KGV0LS0sdS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZ1Lm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoZXQpLDA9PWV0JiYobnVsbCE9PW50JiYoY2xlYXJJbnRlcnZhbChudCksbnQ9bnVsbCkscnQmJih0PXJ0LHJ0PW51bGwsdCgpKSkpfWZ1bmN0aW9uIGUoZSl7dChlLmluc3RhbmNlLGUubW9kdWxlKX1mdW5jdGlvbiBuKHQpe3JldHVybiBmdW5jdGlvbigpe2lmKCFNJiYodnx8dykpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGZldGNoJiYhdHQuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpcmV0dXJuIGZldGNoKHR0LHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtpZighdC5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCBcXCdcIit0dCtcIlxcJ1wiO3JldHVybiB0LmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIG90KCl9KSk7aWYoZilyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7Zih0dCwoZnVuY3Rpb24oZSl7dChuZXcgVWludDhBcnJheShlKSl9KSxlKX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gb3QoKX0pKX0oKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUodCxyKX0pKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gdH0pKS50aGVuKHQsKGZ1bmN0aW9uKHQpe3goXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIit0KSxhdCh0KX0pKX12YXIgcj17YTpwZX07aWYoT3x8KGV0KyssdS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZ1Lm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoZXQpKSx1Lmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIHUuaW5zdGFudGlhdGVXYXNtKHIsdCl9Y2F0Y2godCl7cmV0dXJuIHgoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIit0KSwhMX0oTXx8XCJmdW5jdGlvblwiIT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fGl0KCl8fHR0LnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpfHxffHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBmZXRjaD9uKGUpOmZldGNoKHR0LHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcodCxyKS50aGVuKGUsKGZ1bmN0aW9uKHQpe3JldHVybiB4KFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK3QpLHgoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxuKGUpfSkpfSkpKS5jYXRjaChzKX0oKSx1Ll9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybih1Ll9fX3dhc21fY2FsbF9jdG9ycz11LmFzbS5WYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRJbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEluaXQ9dS5hc20uV2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9dS5hc20uWGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9dS5hc20uWWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT11LmFzbS5aYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPXUuYXNtLl9hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydENyZWF0ZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0Q3JlYXRlU2Vzc2lvbj11LmFzbS4kYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRSZWxlYXNlU2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRSZWxlYXNlU2Vzc2lvbj11LmFzbS5hYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRHZXRJbnB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEdldElucHV0Q291bnQ9dS5hc20uYmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0R2V0T3V0cHV0Q291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0R2V0T3V0cHV0Q291bnQ9dS5hc20uY2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0R2V0SW5wdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEdldElucHV0TmFtZT11LmFzbS5kYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRHZXRPdXRwdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEdldE91dHB1dE5hbWU9dS5hc20uZWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0RnJlZT1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRGcmVlPXUuYXNtLmZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydENyZWF0ZVRlbnNvcj1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRDcmVhdGVUZW5zb3I9dS5hc20uZ2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0R2V0VGVuc29yRGF0YT1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRHZXRUZW5zb3JEYXRhPXUuYXNtLmhiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydFJlbGVhc2VUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0UmVsZWFzZVRlbnNvcj11LmFzbS5pYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRDcmVhdGVSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydENyZWF0ZVJ1bk9wdGlvbnM9dS5hc20uamIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9dS5hc20ua2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9dS5hc20ubGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0UnVuPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydFJ1bj11LmFzbS5tYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRFbmRQcm9maWxpbmc9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0RW5kUHJvZmlsaW5nPXUuYXNtLm5iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBoZT11Ll9wdGhyZWFkX3NlbGY9ZnVuY3Rpb24oKXtyZXR1cm4oaGU9dS5fcHRocmVhZF9zZWxmPXUuYXNtLm9iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGRlPXUuX21hbGxvYz1mdW5jdGlvbigpe3JldHVybihkZT11Ll9tYWxsb2M9dS5hc20ucGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seWU9dS5fZnJlZT1mdW5jdGlvbigpe3JldHVybih5ZT11Ll9mcmVlPXUuYXNtLnFiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGJlPXUuX2ZmbHVzaD1mdW5jdGlvbigpe3JldHVybihiZT11Ll9mZmx1c2g9dS5hc20ucmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dS5fX2Vtc2NyaXB0ZW5fdGxzX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4odS5fX2Vtc2NyaXB0ZW5fdGxzX2luaXQ9dS5hc20uc2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIG1lPXUuX19fZnVuY3Nfb25fZXhpdD1mdW5jdGlvbigpe3JldHVybihtZT11Ll9fX2Z1bmNzX29uX2V4aXQ9dS5hc20udGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZ2U9dS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4oZ2U9dS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQ9dS5hc20udmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9ZnVuY3Rpb24oKXtyZXR1cm4odS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9dS5hc20ud2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIHZlLHdlPXUuX2Vtc2NyaXB0ZW5fcnVuX2luX21haW5fcnVudGltZV90aHJlYWRfanM9ZnVuY3Rpb24oKXtyZXR1cm4od2U9dS5fZW1zY3JpcHRlbl9ydW5faW5fbWFpbl9ydW50aW1lX3RocmVhZF9qcz11LmFzbS54YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxfZT11Ll9fZW1zY3JpcHRlbl9wcm94eV9leGVjdXRlX3Rhc2tfcXVldWU9ZnVuY3Rpb24oKXtyZXR1cm4oX2U9dS5fX2Vtc2NyaXB0ZW5fcHJveHlfZXhlY3V0ZV90YXNrX3F1ZXVlPXUuYXNtLnliKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE9lPXUuX19lbXNjcmlwdGVuX3RocmVhZF9mcmVlX2RhdGE9ZnVuY3Rpb24oKXtyZXR1cm4oT2U9dS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2ZyZWVfZGF0YT11LmFzbS56YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBZT11Ll9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD1mdW5jdGlvbigpe3JldHVybihBZT11Ll9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD11LmFzbS5BYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxTZT11Ll9zZXRUaHJldz1mdW5jdGlvbigpe3JldHVybihTZT11Ll9zZXRUaHJldz11LmFzbS5CYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxUZT11Ll9lbXNjcmlwdGVuX3N0YWNrX3NldF9saW1pdHM9ZnVuY3Rpb24oKXtyZXR1cm4oVGU9dS5fZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzPXUuYXNtLkNiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEVlPXUuc3RhY2tTYXZlPWZ1bmN0aW9uKCl7cmV0dXJuKEVlPXUuc3RhY2tTYXZlPXUuYXNtLkRiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE1lPXUuc3RhY2tSZXN0b3JlPWZ1bmN0aW9uKCl7cmV0dXJuKE1lPXUuc3RhY2tSZXN0b3JlPXUuYXNtLkViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LENlPXUuc3RhY2tBbGxvYz1mdW5jdGlvbigpe3JldHVybihDZT11LnN0YWNrQWxsb2M9dS5hc20uRmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seGU9dS5fX19jeGFfY2FuX2NhdGNoPWZ1bmN0aW9uKCl7cmV0dXJuKHhlPXUuX19fY3hhX2Nhbl9jYXRjaD11LmFzbS5HYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxSZT11Ll9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4oUmU9dS5fX19jeGFfaXNfcG9pbnRlcl90eXBlPXUuYXNtLkhiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGplPXUuZHluQ2FsbF9qPWZ1bmN0aW9uKCl7cmV0dXJuKGplPXUuZHluQ2FsbF9qPXUuYXNtLkliKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGtlPXUuZHluQ2FsbF9paWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oa2U9dS5keW5DYWxsX2lpaWlpaj11LmFzbS5KYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxEZT11LmR5bkNhbGxfamlpPWZ1bmN0aW9uKCl7cmV0dXJuKERlPXUuZHluQ2FsbF9qaWk9dS5hc20uS2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUGU9dS5keW5DYWxsX3ZpaWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oUGU9dS5keW5DYWxsX3ZpaWlpaWo9dS5hc20uTGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVWU9dS5keW5DYWxsX3Zqamk9ZnVuY3Rpb24oKXtyZXR1cm4oVWU9dS5keW5DYWxsX3Zqamk9dS5hc20uTWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRmU9dS5keW5DYWxsX3ZpaWlqamppaT1mdW5jdGlvbigpe3JldHVybihGZT11LmR5bkNhbGxfdmlpaWpqamlpPXUuYXNtLk5iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEllPXUuZHluQ2FsbF9paWo9ZnVuY3Rpb24oKXtyZXR1cm4oSWU9dS5keW5DYWxsX2lpaj11LmFzbS5PYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxXZT11LmR5bkNhbGxfamk9ZnVuY3Rpb24oKXtyZXR1cm4oV2U9dS5keW5DYWxsX2ppPXUuYXNtLlBiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEhlPXUuZHluQ2FsbF9paWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKEhlPXUuZHluQ2FsbF9paWlpaWlqPXUuYXNtLlFiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LExlPXUuZHluQ2FsbF9paWlqPWZ1bmN0aW9uKCl7cmV0dXJuKExlPXUuZHluQ2FsbF9paWlqPXUuYXNtLlJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIHplKCl7ZnVuY3Rpb24gdCgpe2lmKCF2ZSYmKHZlPSEwLHUuY2FsbGVkUnVuPSEwLCFIKSYmKE98fGR0KFgpLGModSksdS5vblJ1bnRpbWVJbml0aWFsaXplZCYmdS5vblJ1bnRpbWVJbml0aWFsaXplZCgpLCFPKSl7aWYodS5wb3N0UnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiB1LnBvc3RSdW4mJih1LnBvc3RSdW49W3UucG9zdFJ1bl0pO3UucG9zdFJ1bi5sZW5ndGg7KXt2YXIgdD11LnBvc3RSdW4uc2hpZnQoKTtaLnVuc2hpZnQodCl9ZHQoWil9fWlmKCEoMDxldCkpaWYoTyljKHUpLE98fGR0KFgpLHBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkZWRcIn0pO2Vsc2V7aWYodS5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHUucHJlUnVuJiYodS5wcmVSdW49W3UucHJlUnVuXSk7dS5wcmVSdW4ubGVuZ3RoOylLKCk7ZHQocSksMDxldHx8KHUuc2V0U3RhdHVzPyh1LnNldFN0YXR1cyhcIlJ1bm5pbmcuLi5cIiksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KChmdW5jdGlvbigpe3Uuc2V0U3RhdHVzKFwiXCIpfSksMSksdCgpfSksMSkpOnQoKSl9fWlmKHUuVVRGOFRvU3RyaW5nPVksdS5zdHJpbmdUb1VURjg9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBCKHQscigpLGUsbil9LHUubGVuZ3RoQnl0ZXNVVEY4PUcsdS5rZWVwUnVudGltZUFsaXZlPVEsdS53YXNtTWVtb3J5PWosdS5zdGFja1NhdmU9RWUsdS5zdGFja1Jlc3RvcmU9TWUsdS5zdGFja0FsbG9jPUNlLHUuRXhpdFN0YXR1cz1jdCx1LlBUaHJlYWQ9aHQscnQ9ZnVuY3Rpb24gdCgpe3ZlfHx6ZSgpLHZlfHwocnQ9dCl9LHUucHJlSW5pdClmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgdS5wcmVJbml0JiYodS5wcmVJbml0PVt1LnByZUluaXRdKTswPHUucHJlSW5pdC5sZW5ndGg7KXUucHJlSW5pdC5wb3AoKSgpO3JldHVybiB6ZSgpLHQucmVhZHl9KTt0LmV4cG9ydHM9cn0sOTMyOih0LGUsbik9Pnt2YXIgX3NjcmlwdERpcixyPShfc2NyaXB0RGlyPShfc2NyaXB0RGlyPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDApfHxcIi9pbmRleC5qc1wiLGZ1bmN0aW9uKHQpe3ZhciBlLHIsYTt0PXR8fHt9LGV8fChlPXZvaWQgMCE9PXQ/dDp7fSksZS5yZWFkeT1uZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxlKXtyPXQsYT1lfSkpO3ZhciBpLG8sdSxjLHMsbCxmPU9iamVjdC5hc3NpZ24oe30sZSkscD1cIi4vdGhpcy5wcm9ncmFtXCIsaD0odCxlKT0+e3Rocm93IGV9LGQ9XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyx5PVwiZnVuY3Rpb25cIj09dHlwZW9mIGltcG9ydFNjcmlwdHMsYj1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUsbT1cIlwiO2I/KG09eT9uKDkwOCkuZGlybmFtZShtKStcIi9cIjpcIi8vXCIsbD0oKT0+e3N8fChjPW4oMzg0KSxzPW4oOTA4KSl9LGk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbCgpLHQ9cy5ub3JtYWxpemUodCksYy5yZWFkRmlsZVN5bmModCxlP3ZvaWQgMDpcInV0ZjhcIil9LHU9dD0+KCh0PWkodCwhMCkpLmJ1ZmZlcnx8KHQ9bmV3IFVpbnQ4QXJyYXkodCkpLHQpLG89KHQsZSxuKT0+e2woKSx0PXMubm9ybWFsaXplKHQpLGMucmVhZEZpbGUodCwoZnVuY3Rpb24odCxyKXt0P24odCk6ZShyLmJ1ZmZlcil9KSl9LDE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKHA9cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFxcXFxcL2csXCIvXCIpKSxwcm9jZXNzLmFyZ3Yuc2xpY2UoMikscHJvY2Vzcy5vbihcInVuY2F1Z2h0RXhjZXB0aW9uXCIsKGZ1bmN0aW9uKHQpe2lmKCEodCBpbnN0YW5jZW9mIEopKXRocm93IHR9KSkscHJvY2Vzcy5vbihcInVuaGFuZGxlZFJlamVjdGlvblwiLChmdW5jdGlvbih0KXt0aHJvdyB0fSkpLGg9KHQsZSk9PntpZihffHwwPEwpdGhyb3cgcHJvY2Vzcy5leGl0Q29kZT10LGU7ZSBpbnN0YW5jZW9mIEp8fHcoXCJleGl0aW5nIGR1ZSB0byBleGNlcHRpb246IFwiK2UpLHByb2Nlc3MuZXhpdCh0KX0sZS5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifSk6KGR8fHkpJiYoeT9tPXNlbGYubG9jYXRpb24uaHJlZjpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihtPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxfc2NyaXB0RGlyJiYobT1fc2NyaXB0RGlyKSxtPTAhPT1tLmluZGV4T2YoXCJibG9iOlwiKT9tLnN1YnN0cigwLG0ucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIixpPXQ9Pnt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGUub3BlbihcIkdFVFwiLHQsITEpLGUuc2VuZChudWxsKSxlLnJlc3BvbnNlVGV4dH0seSYmKHU9dD0+e3ZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gZS5vcGVuKFwiR0VUXCIsdCwhMSksZS5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGUuc2VuZChudWxsKSxuZXcgVWludDhBcnJheShlLnJlc3BvbnNlKX0pLG89KHQsZSxuKT0+e3ZhciByPW5ldyBYTUxIdHRwUmVxdWVzdDtyLm9wZW4oXCJHRVRcIix0LCEwKSxyLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsci5vbmxvYWQ9KCk9PnsyMDA9PXIuc3RhdHVzfHwwPT1yLnN0YXR1cyYmci5yZXNwb25zZT9lKHIucmVzcG9uc2UpOm4oKX0sci5vbmVycm9yPW4sci5zZW5kKG51bGwpfSk7dmFyIGcsdj1lLnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLHc9ZS5wcmludEVycnx8Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbihlLGYpLGY9bnVsbCxlLnRoaXNQcm9ncmFtJiYocD1lLnRoaXNQcm9ncmFtKSxlLnF1aXQmJihoPWUucXVpdCksZS53YXNtQmluYXJ5JiYoZz1lLndhc21CaW5hcnkpO3ZhciBfPWUubm9FeGl0UnVudGltZXx8ITE7XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZWKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgTyxBLFMsVCxFLE0sQz0hMSx4PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMDtmdW5jdGlvbiBSKHQsZSxuKXt2YXIgcj0oZT4+Pj0wKStuO2ZvcihuPWU7dFtuXSYmIShuPj1yKTspKytuO2lmKDE2PG4tZSYmdC5idWZmZXImJngpcmV0dXJuIHguZGVjb2RlKHQuc3ViYXJyYXkoZSxuKSk7Zm9yKHI9XCJcIjtlPG47KXt2YXIgYT10W2UrK107aWYoMTI4JmEpe3ZhciBpPTYzJnRbZSsrXTtpZigxOTI9PSgyMjQmYSkpcis9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmYSk8PDZ8aSk7ZWxzZXt2YXIgbz02MyZ0W2UrK107NjU1MzY+KGE9MjI0PT0oMjQwJmEpPygxNSZhKTw8MTJ8aTw8NnxvOig3JmEpPDwxOHxpPDwxMnxvPDw2fDYzJnRbZSsrXSk/cis9U3RyaW5nLmZyb21DaGFyQ29kZShhKTooYS09NjU1MzYscis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxhPj4xMCw1NjMyMHwxMDIzJmEpKX19ZWxzZSByKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpfXJldHVybiByfWZ1bmN0aW9uIGoodCxlKXtyZXR1cm4odD4+Pj0wKT9SKFQsdCxlKTpcIlwifWZ1bmN0aW9uIGsodCxlLG4scil7aWYoISgwPHIpKXJldHVybiAwO3ZhciBhPW4+Pj49MDtyPW4rci0xO2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7KytpKXt2YXIgbz10LmNoYXJDb2RlQXQoaSk7aWYoNTUyOTY8PW8mJjU3MzQzPj1vJiYobz02NTUzNisoKDEwMjMmbyk8PDEwKXwxMDIzJnQuY2hhckNvZGVBdCgrK2kpKSwxMjc+PW8pe2lmKG4+PXIpYnJlYWs7ZVtuKys+Pj4wXT1vfWVsc2V7aWYoMjA0Nz49byl7aWYobisxPj1yKWJyZWFrO2VbbisrPj4+MF09MTkyfG8+PjZ9ZWxzZXtpZig2NTUzNT49byl7aWYobisyPj1yKWJyZWFrO2VbbisrPj4+MF09MjI0fG8+PjEyfWVsc2V7aWYobiszPj1yKWJyZWFrO2VbbisrPj4+MF09MjQwfG8+PjE4LGVbbisrPj4+MF09MTI4fG8+PjEyJjYzfWVbbisrPj4+MF09MTI4fG8+PjYmNjN9ZVtuKys+Pj4wXT0xMjh8NjMmb319cmV0dXJuIGVbbj4+PjBdPTAsbi1hfWZ1bmN0aW9uIEQodCl7Zm9yKHZhciBlPTAsbj0wO248dC5sZW5ndGg7KytuKXt2YXIgcj10LmNoYXJDb2RlQXQobik7MTI3Pj1yP2UrKzoyMDQ3Pj1yP2UrPTI6NTUyOTY8PXImJjU3MzQzPj1yPyhlKz00LCsrbik6ZSs9M31yZXR1cm4gZX1mdW5jdGlvbiBQKCl7dmFyIHQ9Ty5idWZmZXI7QT10LGUuSEVBUDg9Uz1uZXcgSW50OEFycmF5KHQpLGUuSEVBUDE2PW5ldyBJbnQxNkFycmF5KHQpLGUuSEVBUDMyPUU9bmV3IEludDMyQXJyYXkodCksZS5IRUFQVTg9VD1uZXcgVWludDhBcnJheSh0KSxlLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KHQpLGUuSEVBUFUzMj1NPW5ldyBVaW50MzJBcnJheSh0KSxlLkhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheSh0KSxlLkhFQVBGNjQ9bmV3IEZsb2F0NjRBcnJheSh0KX12YXIgVSxGPVtdLEk9W10sVz1bXSxIPVtdLEw9MDtmdW5jdGlvbiB6KCl7dmFyIHQ9ZS5wcmVSdW4uc2hpZnQoKTtGLnVuc2hpZnQodCl9dmFyIFksQj0wLEc9bnVsbCxOPW51bGw7ZnVuY3Rpb24gVih0KXt0aHJvdyBlLm9uQWJvcnQmJmUub25BYm9ydCh0KSx3KHQ9XCJBYm9ydGVkKFwiK3QrXCIpXCIpLEM9ITAsdD1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHQrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLGEodCksdH1mdW5jdGlvbiAkKCl7cmV0dXJuIFkuc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIil9aWYoWT1cIm9ydC13YXNtLndhc21cIiwhJCgpKXt2YXIgcT1ZO1k9ZS5sb2NhdGVGaWxlP2UubG9jYXRlRmlsZShxLG0pOm0rcX1mdW5jdGlvbiBYKCl7dmFyIHQ9WTt0cnl7aWYodD09WSYmZylyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZyk7aWYodSlyZXR1cm4gdSh0KTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1jYXRjaCh0KXtWKHQpfX1mdW5jdGlvbiBKKHQpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9XCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiK3QrXCIpXCIsdGhpcy5zdGF0dXM9dH1mdW5jdGlvbiBaKHQpe2Zvcig7MDx0Lmxlbmd0aDspdC5zaGlmdCgpKGUpfXZhciBRPVtdLEs9MCx0dD0wO2Z1bmN0aW9uIGV0KHQpe3RoaXMuRGI9dCx0aGlzLnpiPXQtMjQsdGhpcy5VYj1mdW5jdGlvbih0KXtNW3RoaXMuemIrND4+Mj4+PjBdPXR9LHRoaXMuRWI9ZnVuY3Rpb24oKXtyZXR1cm4gTVt0aGlzLnpiKzQ+PjI+Pj4wXX0sdGhpcy5TYj1mdW5jdGlvbih0KXtNW3RoaXMuemIrOD4+Mj4+PjBdPXR9LHRoaXMuV2I9ZnVuY3Rpb24oKXtyZXR1cm4gTVt0aGlzLnpiKzg+PjI+Pj4wXX0sdGhpcy5UYj1mdW5jdGlvbigpe0VbdGhpcy56Yj4+Mj4+PjBdPTB9LHRoaXMuSWI9ZnVuY3Rpb24odCl7U1t0aGlzLnpiKzEyPj4wPj4+MF09dD8xOjB9LHRoaXMuUGI9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9U1t0aGlzLnpiKzEyPj4wPj4+MF19LHRoaXMuSmI9ZnVuY3Rpb24odCl7U1t0aGlzLnpiKzEzPj4wPj4+MF09dD8xOjB9LHRoaXMuTGI9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9U1t0aGlzLnpiKzEzPj4wPj4+MF19LHRoaXMuUmI9ZnVuY3Rpb24odCxlKXt0aGlzLkZiKDApLHRoaXMuVWIodCksdGhpcy5TYihlKSx0aGlzLlRiKCksdGhpcy5JYighMSksdGhpcy5KYighMSl9LHRoaXMuTmI9ZnVuY3Rpb24oKXtFW3RoaXMuemI+PjI+Pj4wXSs9MX0sdGhpcy5YYj1mdW5jdGlvbigpe3ZhciB0PUVbdGhpcy56Yj4+Mj4+PjBdO3JldHVybiBFW3RoaXMuemI+PjI+Pj4wXT10LTEsMT09PXR9LHRoaXMuRmI9ZnVuY3Rpb24odCl7TVt0aGlzLnpiKzE2Pj4yPj4+MF09dH0sdGhpcy5PYj1mdW5jdGlvbigpe3JldHVybiBNW3RoaXMuemIrMTY+PjI+Pj4wXX0sdGhpcy5RYj1mdW5jdGlvbigpe2lmKE10KHRoaXMuRWIoKSkpcmV0dXJuIE1bdGhpcy5EYj4+Mj4+PjBdO3ZhciB0PXRoaXMuT2IoKTtyZXR1cm4gMCE9PXQ/dDp0aGlzLkRifX1mdW5jdGlvbiBudCh0KXtyZXR1cm4gdnQobmV3IGV0KHQpLnpiKX12YXIgcnQ9W107ZnVuY3Rpb24gYXQodCl7dmFyIGU9cnRbdF07cmV0dXJuIGV8fCh0Pj1ydC5sZW5ndGgmJihydC5sZW5ndGg9dCsxKSxydFt0XT1lPVUuZ2V0KHQpKSxlfWZ1bmN0aW9uIGl0KHQpe3ZhciBlPUQodCkrMSxuPWd0KGUpO3JldHVybiBuJiZrKHQsUyxuLGUpLG59dmFyIG90PXt9O2Z1bmN0aW9uIHV0KCl7aWYoIWN0KXt2YXIgdCxlPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOihcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOnB8fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKHQgaW4gb3Qpdm9pZCAwPT09b3RbdF0/ZGVsZXRlIGVbdF06ZVt0XT1vdFt0XTt2YXIgbj1bXTtmb3IodCBpbiBlKW4ucHVzaCh0K1wiPVwiK2VbdF0pO2N0PW59cmV0dXJuIGN0fXZhciBjdCxzdD1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gbHQodCxlKXt2YXIgbj1zdFt0XTswPT09ZXx8MTA9PT1lPygoMT09PXQ/djp3KShSKG4sMCkpLG4ubGVuZ3RoPTApOm4ucHVzaChlKX12YXIgZnQ9MDtmdW5jdGlvbiBwdCh0KXtyZXR1cm4gMD09dCU0JiYoMCE9dCUxMDB8fDA9PXQlNDAwKX12YXIgaHQ9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxkdD1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIHl0KHQsZSxuLHIpe2Z1bmN0aW9uIGEodCxlLG4pe2Zvcih0PVwibnVtYmVyXCI9PXR5cGVvZiB0P3QudG9TdHJpbmcoKTp0fHxcIlwiO3QubGVuZ3RoPGU7KXQ9blswXSt0O3JldHVybiB0fWZ1bmN0aW9uIGkodCxlKXtyZXR1cm4gYSh0LGUsXCIwXCIpfWZ1bmN0aW9uIG8odCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiAwPnQ/LTE6MDx0PzE6MH12YXIgcjtyZXR1cm4gMD09PShyPW4odC5nZXRGdWxsWWVhcigpLWUuZ2V0RnVsbFllYXIoKSkpJiYwPT09KHI9bih0LmdldE1vbnRoKCktZS5nZXRNb250aCgpKSkmJihyPW4odC5nZXREYXRlKCktZS5nZXREYXRlKCkpKSxyfWZ1bmN0aW9uIHUodCl7c3dpdGNoKHQuZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gdDtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gYyh0KXt2YXIgZT10LkJiO2Zvcih0PW5ldyBEYXRlKG5ldyBEYXRlKHQuQ2IrMTkwMCwwLDEpLmdldFRpbWUoKSk7MDxlOyl7dmFyIG49dC5nZXRNb250aCgpLHI9KHB0KHQuZ2V0RnVsbFllYXIoKSk/aHQ6ZHQpW25dO2lmKCEoZT5yLXQuZ2V0RGF0ZSgpKSl7dC5zZXREYXRlKHQuZ2V0RGF0ZSgpK2UpO2JyZWFrfWUtPXItdC5nZXREYXRlKCkrMSx0LnNldERhdGUoMSksMTE+bj90LnNldE1vbnRoKG4rMSk6KHQuc2V0TW9udGgoMCksdC5zZXRGdWxsWWVhcih0LmdldEZ1bGxZZWFyKCkrMSkpfXJldHVybiBuPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSsxLDAsNCksZT11KG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDQpKSxuPXUobiksMD49byhlLHQpPzA+PW8obix0KT90LmdldEZ1bGxZZWFyKCkrMTp0LmdldEZ1bGxZZWFyKCk6dC5nZXRGdWxsWWVhcigpLTF9dmFyIHM9RVtyKzQwPj4yPj4+MF07Zm9yKHZhciBsIGluIHI9eyRiOkVbcj4+Mj4+PjBdLFpiOkVbcis0Pj4yPj4+MF0sR2I6RVtyKzg+PjI+Pj4wXSxLYjpFW3IrMTI+PjI+Pj4wXSxIYjpFW3IrMTY+PjI+Pj4wXSxDYjpFW3IrMjA+PjI+Pj4wXSxBYjpFW3IrMjQ+PjI+Pj4wXSxCYjpFW3IrMjg+PjI+Pj4wXSxiYzpFW3IrMzI+PjI+Pj4wXSxZYjpFW3IrMzY+PjI+Pj4wXSxhYzpzP2oocyk6XCJcIn0sbj1qKG4pLHM9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifSluPW4ucmVwbGFjZShuZXcgUmVnRXhwKGwsXCJnXCIpLHNbbF0pO3ZhciBmPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIikscD1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7Zm9yKGwgaW4gcz17XCIlYVwiOmZ1bmN0aW9uKHQpe3JldHVybiBmW3QuQWJdLnN1YnN0cmluZygwLDMpfSxcIiVBXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGZbdC5BYl19LFwiJWJcIjpmdW5jdGlvbih0KXtyZXR1cm4gcFt0LkhiXS5zdWJzdHJpbmcoMCwzKX0sXCIlQlwiOmZ1bmN0aW9uKHQpe3JldHVybiBwW3QuSGJdfSxcIiVDXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGkoKHQuQ2IrMTkwMCkvMTAwfDAsMil9LFwiJWRcIjpmdW5jdGlvbih0KXtyZXR1cm4gaSh0LktiLDIpfSxcIiVlXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGEodC5LYiwyLFwiIFwiKX0sXCIlZ1wiOmZ1bmN0aW9uKHQpe3JldHVybiBjKHQpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVHXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGModCl9LFwiJUhcIjpmdW5jdGlvbih0KXtyZXR1cm4gaSh0LkdiLDIpfSxcIiVJXCI6ZnVuY3Rpb24odCl7cmV0dXJuIDA9PSh0PXQuR2IpP3Q9MTI6MTI8dCYmKHQtPTEyKSxpKHQsMil9LFwiJWpcIjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPTA7bjw9dC5IYi0xO2UrPShwdCh0LkNiKzE5MDApP2h0OmR0KVtuKytdKTtyZXR1cm4gaSh0LktiK2UsMyl9LFwiJW1cIjpmdW5jdGlvbih0KXtyZXR1cm4gaSh0LkhiKzEsMil9LFwiJU1cIjpmdW5jdGlvbih0KXtyZXR1cm4gaSh0LlpiLDIpfSxcIiVuXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcXFxuXCJ9LFwiJXBcIjpmdW5jdGlvbih0KXtyZXR1cm4gMDw9dC5HYiYmMTI+dC5HYj9cIkFNXCI6XCJQTVwifSxcIiVTXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGkodC4kYiwyKX0sXCIldFwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXFxcdFwifSxcIiV1XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuQWJ8fDd9LFwiJVVcIjpmdW5jdGlvbih0KXtyZXR1cm4gaShNYXRoLmZsb29yKCh0LkJiKzctdC5BYikvNyksMil9LFwiJVZcIjpmdW5jdGlvbih0KXt2YXIgZT1NYXRoLmZsb29yKCh0LkJiKzctKHQuQWIrNiklNykvNyk7aWYoMj49KHQuQWIrMzcxLXQuQmItMiklNyYmZSsrLGUpNTM9PWUmJig0PT0obj0odC5BYiszNzEtdC5CYiklNyl8fDM9PW4mJnB0KHQuQ2IpfHwoZT0xKSk7ZWxzZXtlPTUyO3ZhciBuPSh0LkFiKzctdC5CYi0xKSU3Oyg0PT1ufHw1PT1uJiZwdCh0LkNiJTQwMC0xKSkmJmUrK31yZXR1cm4gaShlLDIpfSxcIiV3XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuQWJ9LFwiJVdcIjpmdW5jdGlvbih0KXtyZXR1cm4gaShNYXRoLmZsb29yKCh0LkJiKzctKHQuQWIrNiklNykvNyksMil9LFwiJXlcIjpmdW5jdGlvbih0KXtyZXR1cm4odC5DYisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlWVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LkNiKzE5MDB9LFwiJXpcIjpmdW5jdGlvbih0KXt2YXIgZT0wPD0odD10LlliKTtyZXR1cm4gdD1NYXRoLmFicyh0KS82MCwoZT9cIitcIjpcIi1cIikrU3RyaW5nKFwiMDAwMFwiKyh0LzYwKjEwMCt0JTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuYWN9LFwiJSVcIjpmdW5jdGlvbigpe3JldHVyblwiJVwifX0sbj1uLnJlcGxhY2UoLyUlL2csXCJcXFxcMFxcXFwwXCIpLHMpbi5pbmNsdWRlcyhsKSYmKG49bi5yZXBsYWNlKG5ldyBSZWdFeHAobCxcImdcIiksc1tsXShyKSkpO3JldHVybiBsPWZ1bmN0aW9uKHQpe3ZhciBlPUFycmF5KEQodCkrMSk7cmV0dXJuIGsodCxlLDAsZS5sZW5ndGgpLGV9KG49bi5yZXBsYWNlKC9cXFxcMFxcXFwwL2csXCIlXCIpKSxsLmxlbmd0aD5lPzA6KFMuc2V0KGwsdD4+PjApLGwubGVuZ3RoLTEpfXZhciBidD17YTpmdW5jdGlvbih0KXtyZXR1cm4gZ3QodCsyNCkrMjR9LG06ZnVuY3Rpb24odCl7cmV0dXJuKHQ9bmV3IGV0KHQpKS5QYigpfHwodC5JYighMCksSy0tKSx0LkpiKCExKSxRLnB1c2godCksdC5OYigpLHQuUWIoKX0saWE6ZnVuY3Rpb24odCl7dGhyb3cgdyhcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uIHRocm93biwgdGhpcyBpcyBub3QgcHJvcGVybHkgc3VwcG9ydGVkIC0gYWJvcnRpbmdcIiksQz0hMCx0fSx3OmZ1bmN0aW9uKCl7T3QoMCk7dmFyIHQ9US5wb3AoKTtpZih0LlhiKCkmJiF0LkxiKCkpe3ZhciBlPXQuV2IoKTtlJiZhdChlKSh0LkRiKSxudCh0LkRiKX10dD0wfSxkOmZ1bmN0aW9uKCl7dmFyIHQ9dHQ7aWYoIXQpcmV0dXJuIGZ0PTA7dmFyIGU9bmV3IGV0KHQpO2UuRmIodCk7dmFyIG49ZS5FYigpO2lmKCFuKXJldHVybiBmdD0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksYT0wO2E8ci5sZW5ndGg7YSsrKXt2YXIgaT1yW2FdO2lmKDA9PT1pfHxpPT09bilicmVhaztpZihFdChpLG4sZS56YisxNikpcmV0dXJuIGZ0PWksdH1yZXR1cm4gZnQ9bix0fSxrOmZ1bmN0aW9uKCl7dmFyIHQ9dHQ7aWYoIXQpcmV0dXJuIGZ0PTA7dmFyIGU9bmV3IGV0KHQpO2UuRmIodCk7dmFyIG49ZS5FYigpO2lmKCFuKXJldHVybiBmdD0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksYT0wO2E8ci5sZW5ndGg7YSsrKXt2YXIgaT1yW2FdO2lmKDA9PT1pfHxpPT09bilicmVhaztpZihFdChpLG4sZS56YisxNikpcmV0dXJuIGZ0PWksdH1yZXR1cm4gZnQ9bix0fSxnOmZ1bmN0aW9uKCl7dmFyIHQ9dHQ7aWYoIXQpcmV0dXJuIGZ0PTA7dmFyIGU9bmV3IGV0KHQpO2UuRmIodCk7dmFyIG49ZS5FYigpO2lmKCFuKXJldHVybiBmdD0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksYT0wO2E8ci5sZW5ndGg7YSsrKXt2YXIgaT1yW2FdO2lmKDA9PT1pfHxpPT09bilicmVhaztpZihFdChpLG4sZS56YisxNikpcmV0dXJuIGZ0PWksdH1yZXR1cm4gZnQ9bix0fSxzOm50LEw6ZnVuY3Rpb24oKXt2YXIgdD1RLnBvcCgpO3R8fFYoXCJubyBleGNlcHRpb24gdG8gdGhyb3dcIik7dmFyIGU9dC5EYjt0aHJvdyB0LkxiKCl8fChRLnB1c2godCksdC5KYighMCksdC5JYighMSksSysrKSx0dD1lLGV9LGI6ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBldCh0KS5SYihlLG4pLHR0PXQsSysrLHR9LGxhOmZ1bmN0aW9uKCl7cmV0dXJuIEt9LGk6ZnVuY3Rpb24odCl7dGhyb3cgdHR8fCh0dD10KSx0fSxIOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LEJhOmZ1bmN0aW9uKCl7fSxwYTpmdW5jdGlvbigpe30scmE6ZnVuY3Rpb24oKXt9LGthOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LHphOmZ1bmN0aW9uKCl7fSx1YTpmdW5jdGlvbigpe30seWE6ZnVuY3Rpb24oKXt9LFI6ZnVuY3Rpb24oKXt9LHFhOmZ1bmN0aW9uKCl7fSxuYTpmdW5jdGlvbigpe30sQWE6ZnVuY3Rpb24oKXt9LG9hOmZ1bmN0aW9uKCl7fSxIYTpmdW5jdGlvbigpe30sSmE6ZnVuY3Rpb24oKXtWKFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LElhOmZ1bmN0aW9uKCl7VihcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxTOmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9LENhOmZ1bmN0aW9uKCl7cmV0dXJuITB9LERhOmZ1bmN0aW9uKHQsZSl7dD1uZXcgRGF0ZSgxZTMqKE1bdD4+PjJdKzQyOTQ5NjcyOTYqRVt0KzQ+Pj4yXSkpLEVbZT4+Mj4+PjBdPXQuZ2V0VVRDU2Vjb25kcygpLEVbZSs0Pj4yPj4+MF09dC5nZXRVVENNaW51dGVzKCksRVtlKzg+PjI+Pj4wXT10LmdldFVUQ0hvdXJzKCksRVtlKzEyPj4yPj4+MF09dC5nZXRVVENEYXRlKCksRVtlKzE2Pj4yPj4+MF09dC5nZXRVVENNb250aCgpLEVbZSsyMD4+Mj4+PjBdPXQuZ2V0VVRDRnVsbFllYXIoKS0xOTAwLEVbZSsyND4+Mj4+PjBdPXQuZ2V0VVRDRGF5KCksRVtlKzI4Pj4yPj4+MF09KHQuZ2V0VGltZSgpLURhdGUuVVRDKHQuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDB9LEVhOmZ1bmN0aW9uKHQsZSl7dD1uZXcgRGF0ZSgxZTMqKE1bdD4+PjJdKzQyOTQ5NjcyOTYqRVt0KzQ+Pj4yXSkpLEVbZT4+Mj4+PjBdPXQuZ2V0U2Vjb25kcygpLEVbZSs0Pj4yPj4+MF09dC5nZXRNaW51dGVzKCksRVtlKzg+PjI+Pj4wXT10LmdldEhvdXJzKCksRVtlKzEyPj4yPj4+MF09dC5nZXREYXRlKCksRVtlKzE2Pj4yPj4+MF09dC5nZXRNb250aCgpLEVbZSsyMD4+Mj4+PjBdPXQuZ2V0RnVsbFllYXIoKS0xOTAwLEVbZSsyND4+Mj4+PjBdPXQuZ2V0RGF5KCk7dmFyIG49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSk7RVtlKzI4Pj4yPj4+MF09KHQuZ2V0VGltZSgpLW4uZ2V0VGltZSgpKS84NjRlNXwwLEVbZSszNj4+Mj4+PjBdPS02MCp0LmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHI9bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtuPW4uZ2V0VGltZXpvbmVPZmZzZXQoKSxFW2UrMzI+PjI+Pj4wXT0wfChyIT1uJiZ0LmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKG4scikpfSxGYTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgRGF0ZShFW3QrMjA+PjI+Pj4wXSsxOTAwLEVbdCsxNj4+Mj4+PjBdLEVbdCsxMj4+Mj4+PjBdLEVbdCs4Pj4yPj4+MF0sRVt0KzQ+PjI+Pj4wXSxFW3Q+PjI+Pj4wXSwwKSxuPUVbdCszMj4+Mj4+PjBdLHI9ZS5nZXRUaW1lem9uZU9mZnNldCgpLGE9bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMSksaT1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLG89YS5nZXRUaW1lem9uZU9mZnNldCgpLHU9TWF0aC5taW4obyxpKTtyZXR1cm4gMD5uP0VbdCszMj4+Mj4+PjBdPU51bWJlcihpIT1vJiZ1PT1yKTowPG4hPSh1PT1yKSYmKGk9TWF0aC5tYXgobyxpKSxlLnNldFRpbWUoZS5nZXRUaW1lKCkrNmU0KigoMDxuP3U6aSktcikpKSxFW3QrMjQ+PjI+Pj4wXT1lLmdldERheSgpLEVbdCsyOD4+Mj4+PjBdPShlLmdldFRpbWUoKS1hLmdldFRpbWUoKSkvODY0ZTV8MCxFW3Q+PjI+Pj4wXT1lLmdldFNlY29uZHMoKSxFW3QrND4+Mj4+PjBdPWUuZ2V0TWludXRlcygpLEVbdCs4Pj4yPj4+MF09ZS5nZXRIb3VycygpLEVbdCsxMj4+Mj4+PjBdPWUuZ2V0RGF0ZSgpLEVbdCsxNj4+Mj4+PjBdPWUuZ2V0TW9udGgoKSxlLmdldFRpbWUoKS8xZTN8MH0sc2E6ZnVuY3Rpb24oKXtyZXR1cm4tNTJ9LHRhOmZ1bmN0aW9uKCl7fSxHYTpmdW5jdGlvbiB0KGUsbixyKXt0LlZifHwodC5WYj0hMCxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4odD10LnRvVGltZVN0cmluZygpLm1hdGNoKC9cXFxcKChbQS1aYS16IF0rKVxcXFwpJC8pKT90WzFdOlwiR01UXCJ9dmFyIGE9KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpLGk9bmV3IERhdGUoYSwwLDEpLG89bmV3IERhdGUoYSw2LDEpO2E9aS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciB1PW8uZ2V0VGltZXpvbmVPZmZzZXQoKTtFW3Q+PjI+Pj4wXT02MCpNYXRoLm1heChhLHUpLEVbZT4+Mj4+PjBdPU51bWJlcihhIT11KSx0PXIoaSksZT1yKG8pLHQ9aXQodCksZT1pdChlKSx1PGE/KE1bbj4+Mj4+PjBdPXQsTVtuKzQ+PjI+Pj4wXT1lKTooTVtuPj4yPj4+MF09ZSxNW24rND4+Mj4+PjBdPXQpfShlLG4scikpfSxCOmZ1bmN0aW9uKCl7VihcIlwiKX0sbWE6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sSTpiPygpPT57dmFyIHQ9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gMWUzKnRbMF0rdFsxXS8xZTZ9OigpPT5wZXJmb3JtYW5jZS5ub3coKSx4YTpmdW5jdGlvbih0LGUsbil7VC5jb3B5V2l0aGluKHQ+Pj4wLGU+Pj4wLGUrbj4+PjApfSxHOmZ1bmN0aW9uKHQpe3ZhciBlPVQubGVuZ3RoO2lmKDQyOTQ5MDE3NjA8KHQ+Pj49MCkpcmV0dXJuITE7Zm9yKHZhciBuPTE7ND49bjtuKj0yKXt2YXIgcj1lKigxKy4yL24pO3I9TWF0aC5taW4ocix0KzEwMDY2MzI5Nik7dmFyIGE9TWF0aDtyPU1hdGgubWF4KHQsciksYT1hLm1pbi5jYWxsKGEsNDI5NDkwMTc2MCxyKyg2NTUzNi1yJTY1NTM2KSU2NTUzNik7dDp7dHJ5e08uZ3JvdyhhLUEuYnl0ZUxlbmd0aCs2NTUzNT4+PjE2KSxQKCk7dmFyIGk9MTticmVhayB0fWNhdGNoKHQpe31pPXZvaWQgMH1pZihpKXJldHVybiEwfXJldHVybiExfSx2YTpmdW5jdGlvbih0LGUpe3ZhciBuPTA7cmV0dXJuIHV0KCkuZm9yRWFjaCgoZnVuY3Rpb24ocixhKXt2YXIgaT1lK247Zm9yKGE9TVt0KzQqYT4+Mj4+PjBdPWksaT0wO2k8ci5sZW5ndGg7KytpKVNbYSsrPj4wPj4+MF09ci5jaGFyQ29kZUF0KGkpO1NbYT4+MD4+PjBdPTAsbis9ci5sZW5ndGgrMX0pKSwwfSx3YTpmdW5jdGlvbih0LGUpe3ZhciBuPXV0KCk7TVt0Pj4yPj4+MF09bi5sZW5ndGg7dmFyIHI9MDtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbih0KXtyKz10Lmxlbmd0aCsxfSkpLE1bZT4+Mj4+PjBdPXIsMH0sYmE6ZnVuY3Rpb24odCl7X3x8MDxMfHwoX3QoKSxaKFcpLHd0KDApLHN0WzFdLmxlbmd0aCYmbHQoMSwxMCksc3RbMl0ubGVuZ3RoJiZsdCgyLDEwKSksX3x8MDxMfHwoZS5vbkV4aXQmJmUub25FeGl0KHQpLEM9ITApLGgodCxuZXcgSih0KSl9LEU6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LFE6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LGNhOmZ1bmN0aW9uKCl7cmV0dXJuIDcwfSxQOmZ1bmN0aW9uKHQsZSxuLHIpe2Zvcih2YXIgYT0wLGk9MDtpPG47aSsrKXt2YXIgbz1NW2U+PjI+Pj4wXSx1PU1bZSs0Pj4yPj4+MF07ZSs9ODtmb3IodmFyIGM9MDtjPHU7YysrKWx0KHQsVFtvK2M+Pj4wXSk7YSs9dX1yZXR1cm4gTVtyPj4yPj4+MF09YSwwfSxjOmZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSxqYTpmdW5jdGlvbiB0KGUscil7dC5NYnx8KHQuTWI9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+KGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdFswXSl9aWYoYil0cnl7dmFyIGU9bihPYmplY3QoZnVuY3Rpb24oKXt2YXIgdD1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgXFwnY3J5cHRvXFwnXCIpO3Rocm93IHQuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIix0fSgpKSk7cmV0dXJuKCk9PmUucmFuZG9tQnl0ZXMoMSlbMF19Y2F0Y2godCl7fXJldHVybigpPT5WKFwicmFuZG9tRGV2aWNlXCIpfSgpKTtmb3IodmFyIGE9MDthPHI7YSsrKVNbZSthPj4wPj4+MF09dC5NYigpO3JldHVybiAwfSxlYTpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxmYTpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxKOmZ1bmN0aW9uKHQpe3ZhciBlPUF0KCk7dHJ5e3JldHVybiBhdCh0KSgpfWNhdGNoKHQpe2lmKFN0KGUpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sZTpmdW5jdGlvbih0LGUpe3ZhciBuPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlKX1jYXRjaCh0KXtpZihTdChuKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LE46ZnVuY3Rpb24odCxlLG4pe3ZhciByPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sTzpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxqOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LG86ZnVuY3Rpb24odCxlLG4scil7dmFyIGE9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHA6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuLHIsYSl9Y2F0Y2godCl7aWYoU3QoaSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxNOmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuLHIsYSxpKX1jYXRjaCh0KXtpZihTdChvKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHI6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4scixhLGkpfWNhdGNoKHQpe2lmKFN0KG8pLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sdjpmdW5jdGlvbih0LGUsbixyLGEsaSxvKXt2YXIgdT1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuLHIsYSxpLG8pfWNhdGNoKHQpe2lmKFN0KHUpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sSzpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBjPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihTdChjKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LEQ6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1LGMscyxsLGYpe3ZhciBwPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4scixhLGksbyx1LGMscyxsLGYpfWNhdGNoKHQpe2lmKFN0KHApLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sWDpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBjPUF0KCk7dHJ5e3JldHVybiBGdCh0LGUsbixyLGEsaSxvLHUpfWNhdGNoKHQpe2lmKFN0KGMpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sVjpmdW5jdGlvbih0LGUsbixyLGEsaSxvKXt2YXIgdT1BdCgpO3RyeXtyZXR1cm4geHQodCxlLG4scixhLGksbyl9Y2F0Y2godCl7aWYoU3QodSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxVOmZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIGk9QXQoKTt0cnl7cmV0dXJuIEl0KHQsZSxuLHIsYSl9Y2F0Y2godCl7aWYoU3QoaSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxaOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPUF0KCk7dHJ5e3JldHVybiBQdCh0LGUsbixyKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LFc6ZnVuY3Rpb24odCl7dmFyIGU9QXQoKTt0cnl7cmV0dXJuIEN0KHQpfWNhdGNoKHQpe2lmKFN0KGUpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sWTpmdW5jdGlvbih0LGUpe3ZhciBuPUF0KCk7dHJ5e3JldHVybiBVdCh0LGUpfWNhdGNoKHQpe2lmKFN0KG4pLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sVDpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIFJ0KHQsZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LGY6ZnVuY3Rpb24odCl7dmFyIGU9QXQoKTt0cnl7YXQodCkoKX1jYXRjaCh0KXtpZihTdChlKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHE6ZnVuY3Rpb24odCxlKXt2YXIgbj1BdCgpO3RyeXthdCh0KShlKX1jYXRjaCh0KXtpZihTdChuKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LGg6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUF0KCk7dHJ5e2F0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxkYTpmdW5jdGlvbih0LGUsbixyKXt2YXIgYT1BdCgpO3RyeXthdCh0KShlLG4scil9Y2F0Y2godCl7aWYoU3QoYSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxsOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPUF0KCk7dHJ5e2F0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHQ6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1BdCgpO3RyeXthdCh0KShlLG4scixhKX1jYXRjaCh0KXtpZihTdChpKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHU6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUF0KCk7dHJ5e2F0KHQpKGUsbixyLGEsaSl9Y2F0Y2godCl7aWYoU3QobyksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSx4OmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8pe3ZhciB1PUF0KCk7dHJ5e2F0KHQpKGUsbixyLGEsaSxvKX1jYXRjaCh0KXtpZihTdCh1KSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHo6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1KXt2YXIgYz1BdCgpO3RyeXthdCh0KShlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihTdChjKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LGdhOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSxjKXt2YXIgcz1BdCgpO3RyeXthdCh0KShlLG4scixhLGksbyx1LGMpfWNhdGNoKHQpe2lmKFN0KHMpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sQTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUsYyxzLGwpe3ZhciBmPUF0KCk7dHJ5e2F0KHQpKGUsbixyLGEsaSxvLHUsYyxzLGwpfWNhdGNoKHQpe2lmKFN0KGYpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sQzpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUsYyxzLGwsZixwLGgsZCx5KXt2YXIgYj1BdCgpO3RyeXthdCh0KShlLG4scixhLGksbyx1LGMscyxsLGYscCxoLGQseSl9Y2F0Y2godCl7aWYoU3QoYiksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxhYTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBjPUF0KCk7dHJ5e2p0KHQsZSxuLHIsYSxpLG8sdSl9Y2F0Y2godCl7aWYoU3QoYyksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxfOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSxjLHMsbCxmKXt2YXIgcD1BdCgpO3RyeXtEdCh0LGUsbixyLGEsaSxvLHUsYyxzLGwsZil9Y2F0Y2godCl7aWYoU3QocCksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSwkOmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1BdCgpO3RyeXtrdCh0LGUsbixyLGEsaSl9Y2F0Y2godCl7aWYoU3QobyksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxuOmZ1bmN0aW9uKHQpe3JldHVybiB0fSxGOmZ1bmN0aW9uKHQpe2Z0PXR9LGhhOnl0LHk6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHl0KHQsZSxuLHIpfX07IWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtlLmFzbT10LmV4cG9ydHMsTz1lLmFzbS5LYSxQKCksVT1lLmFzbS5pYixJLnVuc2hpZnQoZS5hc20uTGEpLEItLSxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhCKSwwPT1CJiYobnVsbCE9PUcmJihjbGVhckludGVydmFsKEcpLEc9bnVsbCksTiYmKHQ9TixOPW51bGwsdCgpKSl9ZnVuY3Rpb24gbihlKXt0KGUuaW5zdGFuY2UpfWZ1bmN0aW9uIHIodCl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoIWcmJihkfHx5KSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZmV0Y2gmJiFZLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpKXJldHVybiBmZXRjaChZLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtpZighdC5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCBcXCdcIitZK1wiXFwnXCI7cmV0dXJuIHQuYXJyYXlCdWZmZXIoKX0pKS5jYXRjaCgoZnVuY3Rpb24oKXtyZXR1cm4gWCgpfSkpO2lmKG8pcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe28oWSwoZnVuY3Rpb24oZSl7dChuZXcgVWludDhBcnJheShlKSl9KSxlKX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gWCgpfSkpfSgpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh0LGkpfSkpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpLnRoZW4odCwoZnVuY3Rpb24odCl7dyhcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK3QpLFYodCl9KSl9dmFyIGk9e2E6YnR9O2lmKEIrKyxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhCKSxlLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIGUuaW5zdGFudGlhdGVXYXNtKGksdCl9Y2F0Y2godCl7cmV0dXJuIHcoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIit0KSwhMX0oZ3x8XCJmdW5jdGlvblwiIT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fCQoKXx8WS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8Ynx8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/cihuKTpmZXRjaChZLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcodCxpKS50aGVuKG4sKGZ1bmN0aW9uKHQpe3JldHVybiB3KFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK3QpLHcoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxyKG4pfSkpfSkpKS5jYXRjaChhKX0oKSxlLl9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybihlLl9fX3dhc21fY2FsbF9jdG9ycz1lLmFzbS5MYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRJbml0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEluaXQ9ZS5hc20uTWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZS5hc20uTmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZS5hc20uT2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1lLmFzbS5QYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWUuYXNtLlFhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydENyZWF0ZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0Q3JlYXRlU2Vzc2lvbj1lLmFzbS5SYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRSZWxlYXNlU2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybihlLl9PcnRSZWxlYXNlU2Vzc2lvbj1lLmFzbS5TYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRHZXRJbnB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldElucHV0Q291bnQ9ZS5hc20uVGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0T3V0cHV0Q291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0R2V0T3V0cHV0Q291bnQ9ZS5hc20uVWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0SW5wdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldElucHV0TmFtZT1lLmFzbS5WYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRHZXRPdXRwdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldE91dHB1dE5hbWU9ZS5hc20uV2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0RnJlZT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRGcmVlPWUuYXNtLlhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydENyZWF0ZVRlbnNvcj1mdW5jdGlvbigpe3JldHVybihlLl9PcnRDcmVhdGVUZW5zb3I9ZS5hc20uWWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0VGVuc29yRGF0YT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRHZXRUZW5zb3JEYXRhPWUuYXNtLlphKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydFJlbGVhc2VUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVRlbnNvcj1lLmFzbS5fYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRDcmVhdGVSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydENyZWF0ZVJ1bk9wdGlvbnM9ZS5hc20uJGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZS5hc20uYWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZS5hc20uYmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UnVuPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydFJ1bj1lLmFzbS5jYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRFbmRQcm9maWxpbmc9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0RW5kUHJvZmlsaW5nPWUuYXNtLmRiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBtdCxndD1lLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oZ3Q9ZS5fbWFsbG9jPWUuYXNtLmViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHZ0PWUuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4odnQ9ZS5fZnJlZT1lLmFzbS5mYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx3dD1lLl9mZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4od3Q9ZS5fZmZsdXNoPWUuYXNtLmdiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LF90PWUuX19fZnVuY3Nfb25fZXhpdD1mdW5jdGlvbigpe3JldHVybihfdD1lLl9fX2Z1bmNzX29uX2V4aXQ9ZS5hc20uaGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sT3Q9ZS5fc2V0VGhyZXc9ZnVuY3Rpb24oKXtyZXR1cm4oT3Q9ZS5fc2V0VGhyZXc9ZS5hc20uamIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQXQ9ZS5zdGFja1NhdmU9ZnVuY3Rpb24oKXtyZXR1cm4oQXQ9ZS5zdGFja1NhdmU9ZS5hc20ua2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU3Q9ZS5zdGFja1Jlc3RvcmU9ZnVuY3Rpb24oKXtyZXR1cm4oU3Q9ZS5zdGFja1Jlc3RvcmU9ZS5hc20ubGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVHQ9ZS5zdGFja0FsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKFR0PWUuc3RhY2tBbGxvYz1lLmFzbS5tYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFdD1lLl9fX2N4YV9jYW5fY2F0Y2g9ZnVuY3Rpb24oKXtyZXR1cm4oRXQ9ZS5fX19jeGFfY2FuX2NhdGNoPWUuYXNtLm5iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE10PWUuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1mdW5jdGlvbigpe3JldHVybihNdD1lLl9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZS5hc20ub2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQ3Q9ZS5keW5DYWxsX2o9ZnVuY3Rpb24oKXtyZXR1cm4oQ3Q9ZS5keW5DYWxsX2o9ZS5hc20ucGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seHQ9ZS5keW5DYWxsX2lpaWlpaj1mdW5jdGlvbigpe3JldHVybih4dD1lLmR5bkNhbGxfaWlpaWlqPWUuYXNtLnFiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFJ0PWUuZHluQ2FsbF9qaWk9ZnVuY3Rpb24oKXtyZXR1cm4oUnQ9ZS5keW5DYWxsX2ppaT1lLmFzbS5yYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxqdD1lLmR5bkNhbGxfdmlpaWlpaj1mdW5jdGlvbigpe3JldHVybihqdD1lLmR5bkNhbGxfdmlpaWlpaj1lLmFzbS5zYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxrdD1lLmR5bkNhbGxfdmpqaT1mdW5jdGlvbigpe3JldHVybihrdD1lLmR5bkNhbGxfdmpqaT1lLmFzbS50YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxEdD1lLmR5bkNhbGxfdmlpaWpqamlpPWZ1bmN0aW9uKCl7cmV0dXJuKER0PWUuZHluQ2FsbF92aWlpampqaWk9ZS5hc20udWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUHQ9ZS5keW5DYWxsX2lpaj1mdW5jdGlvbigpe3JldHVybihQdD1lLmR5bkNhbGxfaWlqPWUuYXNtLnZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFV0PWUuZHluQ2FsbF9qaT1mdW5jdGlvbigpe3JldHVybihVdD1lLmR5bkNhbGxfamk9ZS5hc20ud2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRnQ9ZS5keW5DYWxsX2lpaWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oRnQ9ZS5keW5DYWxsX2lpaWlpaWo9ZS5hc20ueGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSXQ9ZS5keW5DYWxsX2lpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oSXQ9ZS5keW5DYWxsX2lpaWo9ZS5hc20ueWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07ZnVuY3Rpb24gV3QoKXtmdW5jdGlvbiB0KCl7aWYoIW10JiYobXQ9ITAsZS5jYWxsZWRSdW49ITAsIUMpKXtpZihaKEkpLHIoZSksZS5vblJ1bnRpbWVJbml0aWFsaXplZCYmZS5vblJ1bnRpbWVJbml0aWFsaXplZCgpLGUucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgZS5wb3N0UnVuJiYoZS5wb3N0UnVuPVtlLnBvc3RSdW5dKTtlLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIHQ9ZS5wb3N0UnVuLnNoaWZ0KCk7SC51bnNoaWZ0KHQpfVooSCl9fWlmKCEoMDxCKSl7aWYoZS5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUucHJlUnVuJiYoZS5wcmVSdW49W2UucHJlUnVuXSk7ZS5wcmVSdW4ubGVuZ3RoOyl6KCk7WihGKSwwPEJ8fChlLnNldFN0YXR1cz8oZS5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtlLnNldFN0YXR1cyhcIlwiKX0pLDEpLHQoKX0pLDEpKTp0KCkpfX1pZihlLlVURjhUb1N0cmluZz1qLGUuc3RyaW5nVG9VVEY4PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gayh0LFQsZSxuKX0sZS5sZW5ndGhCeXRlc1VURjg9RCxlLnN0YWNrU2F2ZT1BdCxlLnN0YWNrUmVzdG9yZT1TdCxlLnN0YWNrQWxsb2M9VHQsTj1mdW5jdGlvbiB0KCl7bXR8fFd0KCksbXR8fChOPXQpfSxlLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUucHJlSW5pdCYmKGUucHJlSW5pdD1bZS5wcmVJbml0XSk7MDxlLnByZUluaXQubGVuZ3RoOyllLnByZUluaXQucG9wKCkoKTtyZXR1cm4gV3QoKSx0LnJlYWR5fSk7dC5leHBvcnRzPXJ9LDk2NzoodCxlKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuaXRlcmF0ZUV4dHJhT3B0aW9ucz12b2lkIDAsZS5pdGVyYXRlRXh0cmFPcHRpb25zPSh0LG4scixhKT0+e2lmKFwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT09dCl7aWYoci5oYXModCkpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnNcIik7ci5hZGQodCl9T2JqZWN0LmVudHJpZXModCkuZm9yRWFjaCgoKFt0LGldKT0+e2NvbnN0IG89bj9uK3Q6dDtpZihcIm9iamVjdFwiPT10eXBlb2YgaSkoMCxlLml0ZXJhdGVFeHRyYU9wdGlvbnMpKGksbytcIi5cIixyLGEpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGl8fFwibnVtYmVyXCI9PXR5cGVvZiBpKWEobyxpLnRvU3RyaW5nKCkpO2Vsc2V7aWYoXCJib29sZWFuXCIhPXR5cGVvZiBpKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiBcIit0eXBlb2YgaSk7YShvLGk/XCIxXCI6XCIwXCIpfX0pKX19LDU4NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5zZXRSdW5PcHRpb25zPXZvaWQgMDtjb25zdCByPW4oOTY3KSxhPW4oOTgzKSxpPW4oMzYxKTtlLnNldFJ1bk9wdGlvbnM9dD0+e2NvbnN0IGU9KDAsaS5nZXRJbnN0YW5jZSkoKTtsZXQgbj0wO2NvbnN0IG89W10sdT10fHx7fTt0cnl7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nU2V2ZXJpdHlMZXZlbCkpdS5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dTZXZlcml0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1NldmVyaXR5TGV2ZWwpfHx0LmxvZ1NldmVyaXR5TGV2ZWw8MHx8dC5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nVmVyYm9zaXR5TGV2ZWwpKXUubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKFwibnVtYmVyXCIhPXR5cGVvZiB0LmxvZ1ZlcmJvc2l0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke3QubG9nVmVyYm9zaXR5TGV2ZWx9YCk7dm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQudGVybWluYXRlKSYmKHUudGVybWluYXRlPSExKTtsZXQgaT0wO2lmKHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LnRhZykmJihpPSgwLGEuYWxsb2NXYXNtU3RyaW5nKSh0LnRhZyxvKSksbj1lLl9PcnRDcmVhdGVSdW5PcHRpb25zKHUubG9nU2V2ZXJpdHlMZXZlbCx1LmxvZ1ZlcmJvc2l0eUxldmVsLCEhdS50ZXJtaW5hdGUsaSksMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBjcmVhdGUgcnVuIG9wdGlvbnNcIik7cmV0dXJuIHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LmV4dHJhKSYmKDAsci5pdGVyYXRlRXh0cmFPcHRpb25zKSh0LmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKCh0LHIpPT57Y29uc3QgaT0oMCxhLmFsbG9jV2FzbVN0cmluZykodCxvKSx1PSgwLGEuYWxsb2NXYXNtU3RyaW5nKShyLG8pO2lmKDAhPT1lLl9PcnRBZGRSdW5Db25maWdFbnRyeShuLGksdSkpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7dH0gLSAke3J9YCl9KSksW24sb119Y2F0Y2godCl7dGhyb3cgMCE9PW4mJmUuX09ydFJlbGVhc2VSdW5PcHRpb25zKG4pLG8uZm9yRWFjaChlLl9mcmVlKSx0fX19LDkxOToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5zZXRTZXNzaW9uT3B0aW9ucz12b2lkIDA7Y29uc3Qgcj1uKDk2NyksYT1uKDk4MyksaT1uKDM2MSk7ZS5zZXRTZXNzaW9uT3B0aW9ucz10PT57Y29uc3QgZT0oMCxpLmdldEluc3RhbmNlKSgpO2xldCBuPTA7Y29uc3Qgbz1bXSx1PXR8fHt9Oyh0PT57dC5leHRyYXx8KHQuZXh0cmE9e30pLHQuZXh0cmEuc2Vzc2lvbnx8KHQuZXh0cmEuc2Vzc2lvbj17fSk7Y29uc3QgZT10LmV4dHJhLnNlc3Npb247ZS51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5fHwoZS51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5PVwiMVwiKX0pKHUpO3RyeXt2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5ncmFwaE9wdGltaXphdGlvbkxldmVsKSYmKHUuZ3JhcGhPcHRpbWl6YXRpb25MZXZlbD1cImFsbFwiKTtjb25zdCBjPSh0PT57c3dpdGNoKHQpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke3R9YCl9fSkodS5ncmFwaE9wdGltaXphdGlvbkxldmVsKTt2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5lbmFibGVDcHVNZW1BcmVuYSkmJih1LmVuYWJsZUNwdU1lbUFyZW5hPSEwKSx2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5lbmFibGVNZW1QYXR0ZXJuKSYmKHUuZW5hYmxlTWVtUGF0dGVybj0hMCksdm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQuZXhlY3V0aW9uTW9kZSkmJih1LmV4ZWN1dGlvbk1vZGU9XCJzZXF1ZW50aWFsXCIpO2NvbnN0IHM9KHQ9Pntzd2l0Y2godCl7Y2FzZVwic2VxdWVudGlhbFwiOnJldHVybiAwO2Nhc2VcInBhcmFsbGVsXCI6cmV0dXJuIDE7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV4ZWN1dGlvbiBtb2RlOiAke3R9YCl9fSkodS5leGVjdXRpb25Nb2RlKTtsZXQgbD0wO2lmKHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LmxvZ0lkKSYmKGw9KDAsYS5hbGxvY1dhc21TdHJpbmcpKHQubG9nSWQsbykpLHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1NldmVyaXR5TGV2ZWwpKXUubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYoXCJudW1iZXJcIiE9dHlwZW9mIHQubG9nU2V2ZXJpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dTZXZlcml0eUxldmVsKXx8dC5sb2dTZXZlcml0eUxldmVsPDB8fHQubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7dC5sb2dTZXZlcml0eUxldmVsfWApO2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1ZlcmJvc2l0eUxldmVsKSl1LmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dWZXJib3NpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1ZlcmJvc2l0eUxldmVsfWApO2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmVuYWJsZVByb2ZpbGluZykmJih1LmVuYWJsZVByb2ZpbGluZz0hMSksbj1lLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhjLCEhdS5lbmFibGVDcHVNZW1BcmVuYSwhIXUuZW5hYmxlTWVtUGF0dGVybixzLCEhdS5lbmFibGVQcm9maWxpbmcsMCxsLHUubG9nU2V2ZXJpdHlMZXZlbCx1LmxvZ1ZlcmJvc2l0eUxldmVsKSwwPT09bil0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnNcIik7cmV0dXJuKG51bGw9PXQ/dm9pZCAwOnQuZXhlY3V0aW9uUHJvdmlkZXJzKSYmKCh0LGUsbik9Pntmb3IoY29uc3QgciBvZiBlKXtsZXQgZT1cInN0cmluZ1wiPT10eXBlb2Ygcj9yOnIubmFtZTtzd2l0Y2goZSl7Y2FzZVwieG5ucGFja1wiOmU9XCJYTk5QQUNLXCI7YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIEVQOiAke2V9YCl9Y29uc3Qgbz0oMCxhLmFsbG9jV2FzbVN0cmluZykoZSxuKTtpZigwIT09KDAsaS5nZXRJbnN0YW5jZSkoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIodCxvKSl0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtlfWApfX0pKG4sdC5leGVjdXRpb25Qcm92aWRlcnMsbyksdm9pZCAwIT09KG51bGw9PXQ/dm9pZCAwOnQuZXh0cmEpJiYoMCxyLml0ZXJhdGVFeHRyYU9wdGlvbnMpKHQuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoKHQscik9Pntjb25zdCBpPSgwLGEuYWxsb2NXYXNtU3RyaW5nKSh0LG8pLHU9KDAsYS5hbGxvY1dhc21TdHJpbmcpKHIsbyk7aWYoMCE9PWUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShuLGksdSkpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke3R9IC0gJHtyfWApfSkpLFtuLG9dfWNhdGNoKHQpe3Rocm93IDAhPT1uJiZlLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMobiksby5mb3JFYWNoKGUuX2ZyZWUpLHR9fX0sOTgzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmFsbG9jV2FzbVN0cmluZz12b2lkIDA7Y29uc3Qgcj1uKDM2MSk7ZS5hbGxvY1dhc21TdHJpbmc9KHQsZSk9Pntjb25zdCBuPSgwLHIuZ2V0SW5zdGFuY2UpKCksYT1uLmxlbmd0aEJ5dGVzVVRGOCh0KSsxLGk9bi5fbWFsbG9jKGEpO3JldHVybiBuLnN0cmluZ1RvVVRGOCh0LGksYSksZS5wdXNoKGkpLGl9fSwzNDk6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnM9ZS5lbmRQcm9maWxpbmc9ZS5ydW49ZS5yZWxlYXNlU2Vzc2lvbj1lLmNyZWF0ZVNlc3Npb249ZS5jcmVhdGVTZXNzaW9uRmluYWxpemU9ZS5jcmVhdGVTZXNzaW9uQWxsb2NhdGU9ZS5pbml0T3J0PXZvaWQgMDtjb25zdCByPW4oNTg2KSxhPW4oOTE5KSxpPW4oOTgzKSxvPW4oMzYxKTtlLmluaXRPcnQ9KHQsZSk9Pntjb25zdCBuPSgwLG8uZ2V0SW5zdGFuY2UpKCkuX09ydEluaXQodCxlKTtpZigwIT09bil0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3QgaW5pdGlhbGl6ZSBvbm54cnVudGltZS4gZXJyb3IgY29kZSA9ICR7bn1gKX07Y29uc3QgdT1uZXcgTWFwO2UuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCksbj1lLl9tYWxsb2ModC5ieXRlTGVuZ3RoKTtyZXR1cm4gZS5IRUFQVTguc2V0KHQsbiksW24sdC5ieXRlTGVuZ3RoXX0sZS5jcmVhdGVTZXNzaW9uRmluYWxpemU9KHQsZSk9Pntjb25zdCBuPSgwLG8uZ2V0SW5zdGFuY2UpKCk7bGV0IHI9MCxpPTAsYz1bXTt0cnl7aWYoW2ksY109KDAsYS5zZXRTZXNzaW9uT3B0aW9ucykoZSkscj1uLl9PcnRDcmVhdGVTZXNzaW9uKHRbMF0sdFsxXSxpKSwwPT09cil0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGNyZWF0ZSBhIHNlc3Npb25cIil9ZmluYWxseXtuLl9mcmVlKHRbMF0pLG4uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhpKSxjLmZvckVhY2gobi5fZnJlZSl9Y29uc3Qgcz1uLl9PcnRHZXRJbnB1dENvdW50KHIpLGw9bi5fT3J0R2V0T3V0cHV0Q291bnQociksZj1bXSxwPVtdLGg9W10sZD1bXTtmb3IobGV0IHQ9MDt0PHM7dCsrKXtjb25zdCBlPW4uX09ydEdldElucHV0TmFtZShyLHQpO2lmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgZ2V0IGFuIGlucHV0IG5hbWVcIik7cC5wdXNoKGUpLGYucHVzaChuLlVURjhUb1N0cmluZyhlKSl9Zm9yKGxldCB0PTA7dDxsO3QrKyl7Y29uc3QgZT1uLl9PcnRHZXRPdXRwdXROYW1lKHIsdCk7aWYoMD09PWUpdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBnZXQgYW4gb3V0cHV0IG5hbWVcIik7ZC5wdXNoKGUpLGgucHVzaChuLlVURjhUb1N0cmluZyhlKSl9cmV0dXJuIHUuc2V0KHIsW3IscCxkXSksW3IsZixoXX0sZS5jcmVhdGVTZXNzaW9uPSh0LG4pPT57Y29uc3Qgcj0oMCxlLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSkodCk7cmV0dXJuKDAsZS5jcmVhdGVTZXNzaW9uRmluYWxpemUpKHIsbil9LGUucmVsZWFzZVNlc3Npb249dD0+e2NvbnN0IGU9KDAsby5nZXRJbnN0YW5jZSkoKSxuPXUuZ2V0KHQpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtjb25zdCByPW5bMF0sYT1uWzFdLGk9blsyXTthLmZvckVhY2goZS5fT3J0RnJlZSksaS5mb3JFYWNoKGUuX09ydEZyZWUpLGUuX09ydFJlbGVhc2VTZXNzaW9uKHIpLHUuZGVsZXRlKHQpfTtjb25zdCBjPXQ9Pntzd2l0Y2godCl7Y2FzZVwiaW50OFwiOnJldHVybiAzO2Nhc2VcInVpbnQ4XCI6cmV0dXJuIDI7Y2FzZVwiYm9vbFwiOnJldHVybiA5O2Nhc2VcImludDE2XCI6cmV0dXJuIDU7Y2FzZVwidWludDE2XCI6cmV0dXJuIDQ7Y2FzZVwiaW50MzJcIjpyZXR1cm4gNjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gMTI7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiAxO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gMTE7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIDg7Y2FzZVwiaW50NjRcIjpyZXR1cm4gNztjYXNlXCJ1aW50NjRcIjpyZXR1cm4gMTM7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fWApfX0scz10PT57c3dpdGNoKHQpe2Nhc2UgMzpyZXR1cm5cImludDhcIjtjYXNlIDI6cmV0dXJuXCJ1aW50OFwiO2Nhc2UgOTpyZXR1cm5cImJvb2xcIjtjYXNlIDU6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgNDpyZXR1cm5cInVpbnQxNlwiO2Nhc2UgNjpyZXR1cm5cImludDMyXCI7Y2FzZSAxMjpyZXR1cm5cInVpbnQzMlwiO2Nhc2UgMTpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIDExOnJldHVyblwiZmxvYXQ2NFwiO2Nhc2UgODpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgNzpyZXR1cm5cImludDY0XCI7Y2FzZSAxMzpyZXR1cm5cInVpbnQ2NFwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH1gKX19LGw9dD0+e3N3aXRjaCh0KXtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJ1aW50OFwiOmNhc2VcImJvb2xcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJpbnQ4XCI6cmV0dXJuIEludDhBcnJheTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gSW50MTZBcnJheTtjYXNlXCJpbnQzMlwiOnJldHVybiBJbnQzMkFycmF5O2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gRmxvYXQ2NEFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJpbnQ2NFwiOnJldHVybiBCaWdJbnQ2NEFycmF5O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBCaWdVaW50NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZTogJHt0fWApfX07ZS5ydW49KHQsZSxuLGEsZik9Pntjb25zdCBwPSgwLG8uZ2V0SW5zdGFuY2UpKCksaD11LmdldCh0KTtpZighaCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7Y29uc3QgZD1oWzBdLHk9aFsxXSxiPWhbMl0sbT1lLmxlbmd0aCxnPWEubGVuZ3RoO2xldCB2PTAsdz1bXTtjb25zdCBfPVtdLE89W107dHJ5e1t2LHddPSgwLHIuc2V0UnVuT3B0aW9ucykoZik7Zm9yKGxldCB0PTA7dDxtO3QrKyl7Y29uc3QgZT1uW3RdWzBdLHI9blt0XVsxXSxhPW5bdF1bMl07bGV0IG8sdTtpZihBcnJheS5pc0FycmF5KGEpKXt1PTQqYS5sZW5ndGgsbz1wLl9tYWxsb2ModSksTy5wdXNoKG8pO2xldCB0PW8vNDtmb3IobGV0IGU9MDtlPGEubGVuZ3RoO2UrKyl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGFbZV0pdGhyb3cgbmV3IFR5cGVFcnJvcihgdGVuc29yIGRhdGEgYXQgaW5kZXggJHtlfSBpcyBub3QgYSBzdHJpbmdgKTtwLkhFQVBVMzJbdCsrXT0oMCxpLmFsbG9jV2FzbVN0cmluZykoYVtlXSxPKX19ZWxzZSB1PWEuYnl0ZUxlbmd0aCxvPXAuX21hbGxvYyh1KSxPLnB1c2gobykscC5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLGEuYnl0ZU9mZnNldCx1KSxvKTtjb25zdCBzPXAuc3RhY2tTYXZlKCksbD1wLnN0YWNrQWxsb2MoNCpyLmxlbmd0aCk7dHJ5e2xldCB0PWwvNDtyLmZvckVhY2goKGU9PnAuSEVBUDMyW3QrK109ZSkpO2NvbnN0IG49cC5fT3J0Q3JlYXRlVGVuc29yKGMoZSksbyx1LGwsci5sZW5ndGgpO2lmKDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgY3JlYXRlIGEgdGVuc29yXCIpO18ucHVzaChuKX1maW5hbGx5e3Auc3RhY2tSZXN0b3JlKHMpfX1jb25zdCB0PXAuc3RhY2tTYXZlKCksbz1wLnN0YWNrQWxsb2MoNCptKSx1PXAuc3RhY2tBbGxvYyg0Km0pLGg9cC5zdGFja0FsbG9jKDQqZyksQT1wLnN0YWNrQWxsb2MoNCpnKTt0cnl7bGV0IG49by80LHI9dS80LGk9aC80LGM9QS80O2ZvcihsZXQgdD0wO3Q8bTt0KyspcC5IRUFQVTMyW24rK109X1t0XSxwLkhFQVBVMzJbcisrXT15W2VbdF1dO2ZvcihsZXQgdD0wO3Q8Zzt0KyspcC5IRUFQVTMyW2krK109MCxwLkhFQVBVMzJbYysrXT1iW2FbdF1dO2xldCBmPXAuX09ydFJ1bihkLHUsbyxtLEEsZyxoLHYpO2NvbnN0IHc9W107aWYoMD09PWYpZm9yKGxldCB0PTA7dDxnO3QrKyl7Y29uc3QgZT1wLkhFQVBVMzJbaC80K3RdLG49cC5zdGFja1NhdmUoKSxyPXAuc3RhY2tBbGxvYygxNik7bGV0IGEsaT0wO3RyeXtpZihmPXAuX09ydEdldFRlbnNvckRhdGEoZSxyLHIrNCxyKzgscisxMiksMCE9PWYpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IGFjY2VzcyBvdXRwdXQgdGVuc29yIGRhdGEuIGVycm9yIGNvZGUgPSAke2Z9YCk7bGV0IHQ9ci80O2NvbnN0IG89cC5IRUFQVTMyW3QrK107aT1wLkhFQVBVMzJbdCsrXTtjb25zdCB1PXAuSEVBUFUzMlt0KytdLGM9cC5IRUFQVTMyW3QrK10saD1bXTtmb3IobGV0IHQ9MDt0PGM7dCsrKWgucHVzaChwLkhFQVBVMzJbdS80K3RdKTtwLl9PcnRGcmVlKHUpO2NvbnN0IGQ9MD09PWgubGVuZ3RoPzE6aC5yZWR1Y2UoKCh0LGUpPT50KmUpKTtpZihhPXMobyksXCJzdHJpbmdcIj09PWEpe2NvbnN0IHQ9W107bGV0IGU9aS80O2ZvcihsZXQgbj0wO248ZDtuKyspe2NvbnN0IHI9cC5IRUFQVTMyW2UrK10sYT1uPT09ZC0xP3ZvaWQgMDpwLkhFQVBVMzJbZV0tcjt0LnB1c2gocC5VVEY4VG9TdHJpbmcocixhKSl9dy5wdXNoKFthLGgsdF0pfWVsc2V7Y29uc3QgdD1uZXcobChhKSkoZCk7bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0LHQuYnl0ZUxlbmd0aCkuc2V0KHAuSEVBUFU4LnN1YmFycmF5KGksaSt0LmJ5dGVMZW5ndGgpKSx3LnB1c2goW2EsaCx0XSl9fWZpbmFsbHl7cC5zdGFja1Jlc3RvcmUobiksXCJzdHJpbmdcIj09PWEmJmkmJnAuX2ZyZWUoaSkscC5fT3J0UmVsZWFzZVRlbnNvcihlKX19aWYoMD09PWYpcmV0dXJuIHc7dGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS4gZXJyb3IgY29kZSA9ICR7Zn0uYCl9ZmluYWxseXtwLnN0YWNrUmVzdG9yZSh0KX19ZmluYWxseXtfLmZvckVhY2gocC5fT3J0UmVsZWFzZVRlbnNvciksTy5mb3JFYWNoKHAuX2ZyZWUpLHAuX09ydFJlbGVhc2VSdW5PcHRpb25zKHYpLHcuZm9yRWFjaChwLl9mcmVlKX19LGUuZW5kUHJvZmlsaW5nPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCksbj11LmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7Y29uc3Qgcj1uWzBdLGE9ZS5fT3J0RW5kUHJvZmlsaW5nKHIpO2lmKDA9PT1hKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lXCIpO2UuX09ydEZyZWUoYSl9LGUuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnM9dD0+e2NvbnN0IGU9W107Zm9yKGNvbnN0IG4gb2YgdCl7Y29uc3QgdD1uWzJdOyFBcnJheS5pc0FycmF5KHQpJiZ0LmJ1ZmZlciYmZS5wdXNoKHQuYnVmZmVyKX1yZXR1cm4gZX19LDM2MTpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pO3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKTthJiYhKFwiZ2V0XCJpbiBhPyFlLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpfHwoYT17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZVtuXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLGEpfTpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1uKSx0W3JdPWVbbl19KSxhPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih0LGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KX06ZnVuY3Rpb24odCxlKXt0LmRlZmF1bHQ9ZX0pLGk9dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgZT17fTtpZihudWxsIT10KWZvcih2YXIgbiBpbiB0KVwiZGVmYXVsdFwiIT09biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJnIoZSx0LG4pO3JldHVybiBhKGUsdCksZX0sbz10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmRpc3Bvc2U9ZS5nZXRJbnN0YW5jZT1lLmluaXRpYWxpemVXZWJBc3NlbWJseT12b2lkIDA7Y29uc3QgdT1pKG4oNDQ5KSksYz1vKG4oOTMyKSkscz1uKDQ3NCk7bGV0IGwsZj0hMSxwPSExLGg9ITE7Y29uc3QgZD0odCxlKT0+ZT90P1wib3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtXCI6XCJvcnQtd2FzbS10aHJlYWRlZC53YXNtXCI6dD9cIm9ydC13YXNtLXNpbWQud2FzbVwiOlwib3J0LXdhc20ud2FzbVwiO2UuaW5pdGlhbGl6ZVdlYkFzc2VtYmx5PWFzeW5jIHQ9PntpZihmKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtpZihwKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvIFxcJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpXFwnIGRldGVjdGVkLlwiKTtpZihoKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gXFwnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KClcXCcgZmFpbGVkLlwiKTtwPSEwO2NvbnN0IGU9dC5pbml0VGltZW91dCxyPXQubnVtVGhyZWFkcyxhPXQuc2ltZCxpPXI+MSYmKCgpPT57dHJ5e3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciYmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBNZXNzYWdlQ2hhbm5lbCYmKG5ldyBNZXNzYWdlQ2hhbm5lbCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpKX1jYXRjaCh0KXtyZXR1cm4hMX19KSgpLG89YSYmKCgpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMzAsMSwyOCwwLDY1LDAsMjUzLDE1LDI1MywxMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1MywxODYsMSwyNiwxMV0pKX1jYXRjaCh0KXtyZXR1cm4hMX19KSgpLHk9XCJzdHJpbmdcIj09dHlwZW9mIHQud2FzbVBhdGhzP3Qud2FzbVBhdGhzOnZvaWQgMCxiPWQoITEsaSksbT1kKG8saSksZz1cIm9iamVjdFwiPT10eXBlb2YgdC53YXNtUGF0aHM/dC53YXNtUGF0aHNbbV06dm9pZCAwO2xldCB2PSExO2NvbnN0IHc9W107aWYoZT4wJiZ3LnB1c2gobmV3IFByb21pc2UoKHQ9PntzZXRUaW1lb3V0KCgoKT0+e3Y9ITAsdCgpfSksZSl9KSkpLHcucHVzaChuZXcgUHJvbWlzZSgoKHQsZSk9Pntjb25zdCByPWk/czpjLmRlZmF1bHQsYT17bG9jYXRlRmlsZToodCxlKT0+aSYmdC5lbmRzV2l0aChcIi53b3JrZXIuanNcIikmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBCbG9iP1VSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW24oMTU0KV0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pKTp0PT09Yj9udWxsIT1nP2c6KG51bGwhPXk/eTplKSttOmUrdH07aWYoaSlpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgQmxvYilhLm1haW5TY3JpcHRVcmxPckJsb2I9dS5qb2luKFwiL1wiLFwib3J0LXdhc20tdGhyZWFkZWQuanNcIik7ZWxzZXtjb25zdCB0PWB2YXIgb3J0V2FzbVRocmVhZGVkPShmdW5jdGlvbigpe3ZhciBfc2NyaXB0RGlyO3JldHVybiAke3IudG9TdHJpbmcoKX19KSgpO2A7YS5tYWluU2NyaXB0VXJsT3JCbG9iPW5ldyBCbG9iKFt0XSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSl9cihhKS50aGVuKChlPT57cD0hMSxmPSEwLGw9ZSx0KCl9KSwodD0+e3A9ITEsaD0hMCxlKHQpfSkpfSkpKSxhd2FpdCBQcm9taXNlLnJhY2Uodyksdil0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHtlfW1zYCl9LGUuZ2V0SW5zdGFuY2U9KCk9PntpZihmJiZsKXJldHVybiBsO3Rocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuXCIpfSxlLmRpc3Bvc2U9KCk9Pnt2YXIgdDshZnx8cHx8aHx8KHA9ITAsbnVsbD09PSh0PWwuUFRocmVhZCl8fHZvaWQgMD09PXR8fHQudGVybWluYXRlQWxsVGhyZWFkcygpLGw9dm9pZCAwLHA9ITEsZj0hMSxoPSEwKX19LDE1NDp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPVxcJ1widXNlIHN0cmljdFwiO3ZhciBlPXt9LHQ9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO2lmKHQpe3ZhciByPXJlcXVpcmUoXCJ3b3JrZXJfdGhyZWFkc1wiKSxhPXIucGFyZW50UG9ydDthLm9uKFwibWVzc2FnZVwiLChlPT5vbm1lc3NhZ2Uoe2RhdGE6ZX0pKSk7dmFyIG89cmVxdWlyZShcImZzXCIpO09iamVjdC5hc3NpZ24oZ2xvYmFsLHtzZWxmOmdsb2JhbCxyZXF1aXJlOnJlcXVpcmUsTW9kdWxlOmUsbG9jYXRpb246e2hyZWY6X19maWxlbmFtZX0sV29ya2VyOnIuV29ya2VyLGltcG9ydFNjcmlwdHM6ZnVuY3Rpb24oZSl7KDAsZXZhbCkoby5yZWFkRmlsZVN5bmMoZSxcInV0ZjhcIikpfSxwb3N0TWVzc2FnZTpmdW5jdGlvbihlKXthLnBvc3RNZXNzYWdlKGUpfSxwZXJmb3JtYW5jZTpnbG9iYWwucGVyZm9ybWFuY2V8fHtub3c6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX19fSl9dmFyIHM9ITEsbj1bXSxpPWZ1bmN0aW9uKCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTt0P28ud3JpdGVTeW5jKDIsZStcIlxcXFxcXFxcblwiKTpjb25zb2xlLmVycm9yKGUpfTtzZWxmLmFsZXJ0PWZ1bmN0aW9uKCl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtwb3N0TWVzc2FnZSh7Y21kOlwiYWxlcnRcIix0ZXh0OnQsdGhyZWFkSWQ6ZS5fcHRocmVhZF9zZWxmKCl9KX0sZS5pbnN0YW50aWF0ZVdhc209KHQscik9Pnt2YXIgYT1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UoZS53YXNtTW9kdWxlLHQpO3JldHVybiByKGEpLGUud2FzbU1vZHVsZT1udWxsLGEuZXhwb3J0c30sc2VsZi5vbnVuaGFuZGxlZHJlamVjdGlvbj1lPT57dGhyb3cgZS5yZWFzb24/P2V9LHNlbGYub25tZXNzYWdlPXQ9Pnt0cnl7aWYoXCJsb2FkXCI9PT10LmRhdGEuY21kKXtpZihlLndhc21Nb2R1bGU9dC5kYXRhLndhc21Nb2R1bGUsZS53YXNtTWVtb3J5PXQuZGF0YS53YXNtTWVtb3J5LGUuYnVmZmVyPWUud2FzbU1lbW9yeS5idWZmZXIsZS5FTlZJUk9OTUVOVF9JU19QVEhSRUFEPSEwLFwic3RyaW5nXCI9PXR5cGVvZiB0LmRhdGEudXJsT3JCbG9iKWltcG9ydFNjcmlwdHModC5kYXRhLnVybE9yQmxvYik7ZWxzZXt2YXIgcj1VUkwuY3JlYXRlT2JqZWN0VVJMKHQuZGF0YS51cmxPckJsb2IpO2ltcG9ydFNjcmlwdHMociksVVJMLnJldm9rZU9iamVjdFVSTChyKX1vcnRXYXNtVGhyZWFkZWQoZSkudGhlbigoZnVuY3Rpb24odCl7ZT10fSkpfWVsc2UgaWYoXCJydW5cIj09PXQuZGF0YS5jbWQpe2UuX19wZXJmb3JtYW5jZV9ub3dfY2xvY2tfZHJpZnQ9cGVyZm9ybWFuY2Uubm93KCktdC5kYXRhLnRpbWUsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQodC5kYXRhLnB0aHJlYWRfcHRyLDAsMCwxKSxlLmVzdGFibGlzaFN0YWNrU3BhY2UoKSxlLlBUaHJlYWQucmVjZWl2ZU9iamVjdFRyYW5zZmVyKHQuZGF0YSksZS5QVGhyZWFkLnRocmVhZEluaXRUTFMoKSxzfHwobi5mb3JFYWNoKCh0PT57ZS5leGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlKHQpfSkpLG49W10scz0hMCk7dHJ5e2UuaW52b2tlRW50cnlQb2ludCh0LmRhdGEuc3RhcnRfcm91dGluZSx0LmRhdGEuYXJnKX1jYXRjaCh0KXtpZihcInVud2luZFwiIT10KXtpZighKHQgaW5zdGFuY2VvZiBlLkV4aXRTdGF0dXMpKXRocm93IHQ7ZS5rZWVwUnVudGltZUFsaXZlKCl8fGUuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0KHQuc3RhdHVzKX19fWVsc2VcImNhbmNlbFwiPT09dC5kYXRhLmNtZD9lLl9wdGhyZWFkX3NlbGYoKSYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQoLTEpOlwic2V0aW1tZWRpYXRlXCI9PT10LmRhdGEudGFyZ2V0fHwoXCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiPT09dC5kYXRhLmNtZD9zP2UuZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZSh0LmRhdGEucXVldWUpOm4ucHVzaCh0LmRhdGEucXVldWUpOihpKFwid29ya2VyLmpzIHJlY2VpdmVkIHVua25vd24gY29tbWFuZCBcIit0LmRhdGEuY21kKSxpKHQuZGF0YSkpKX1jYXRjaCh0KXt0aHJvdyBpKFwid29ya2VyLmpzIG9ubWVzc2FnZSgpIGNhcHR1cmVkIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbjogXCIrdCksdCYmdC5zdGFjayYmaSh0LnN0YWNrKSxlLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZCYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQoKSx0fX07XFxcXG5cXCd9LDM4NDooKT0+e30sOTkzOigpPT57fSw5MDg6KCk9Pnt9LDk1MzooKT0+e30sOTI1OigpPT57fSw0NDk6KCk9Pnt9fSxlPXt9O2Z1bmN0aW9uIG4ocil7dmFyIGE9ZVtyXTtpZih2b2lkIDAhPT1hKXJldHVybiBhLmV4cG9ydHM7dmFyIGk9ZVtyXT17ZXhwb3J0czp7fX07cmV0dXJuIHRbcl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsbiksaS5leHBvcnRzfW4uZz1mdW5jdGlvbigpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWxUaGlzKXJldHVybiBnbG9iYWxUaGlzO3RyeXtyZXR1cm4gdGhpc3x8bmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKX1jYXRjaCh0KXtpZihcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93KXJldHVybiB3aW5kb3d9fSgpLCgoKT0+e1widXNlIHN0cmljdFwiO2NvbnN0IHQ9bigzNDkpLGU9bigzNjEpO3NlbGYub25tZXNzYWdlPW49Pntzd2l0Y2gobi5kYXRhLnR5cGUpe2Nhc2VcImluaXQtd2FzbVwiOigwLGUuaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KShuLmRhdGEuaW4pLnRoZW4oKCgpPT5wb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtd2FzbVwifSkpLCh0PT5wb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtd2FzbVwiLGVycjp0fSkpKTticmVhaztjYXNlXCJpbml0LW9ydFwiOnRyeXtjb25zdHtudW1UaHJlYWRzOmUsbG9nZ2luZ0xldmVsOnJ9PW4uZGF0YS5pbjsoMCx0LmluaXRPcnQpKGUscikscG9zdE1lc3NhZ2Uoe3R5cGU6XCJpbml0LW9ydFwifSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJpbml0LW9ydFwiLGVycjp0fSl9YnJlYWs7Y2FzZVwiY3JlYXRlX2FsbG9jYXRlXCI6dHJ5e2NvbnN0e21vZGVsOmV9PW4uZGF0YS5pbixyPSgwLHQuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKShlKTtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZV9hbGxvY2F0ZVwiLG91dDpyfSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVfYWxsb2NhdGVcIixlcnI6dH0pfWJyZWFrO2Nhc2VcImNyZWF0ZV9maW5hbGl6ZVwiOnRyeXtjb25zdHttb2RlbGRhdGE6ZSxvcHRpb25zOnJ9PW4uZGF0YS5pbixhPSgwLHQuY3JlYXRlU2Vzc2lvbkZpbmFsaXplKShlLHIpO3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlX2ZpbmFsaXplXCIsb3V0OmF9KX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZV9maW5hbGl6ZVwiLGVycjp0fSl9YnJlYWs7Y2FzZVwiY3JlYXRlXCI6dHJ5e2NvbnN0e21vZGVsOmUsb3B0aW9uczpyfT1uLmRhdGEuaW4sYT0oMCx0LmNyZWF0ZVNlc3Npb24pKGUscik7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVcIixvdXQ6YX0pfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlXCIsZXJyOnR9KX1icmVhaztjYXNlXCJyZWxlYXNlXCI6dHJ5e2NvbnN0IGU9bi5kYXRhLmluOygwLHQucmVsZWFzZVNlc3Npb24pKGUpLHBvc3RNZXNzYWdlKHt0eXBlOlwicmVsZWFzZVwifSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJyZWxlYXNlXCIsZXJyOnR9KX1icmVhaztjYXNlXCJydW5cIjp0cnl7Y29uc3R7c2Vzc2lvbklkOmUsaW5wdXRJbmRpY2VzOnIsaW5wdXRzOmEsb3V0cHV0SW5kaWNlczppLG9wdGlvbnM6b309bi5kYXRhLmluLHU9KDAsdC5ydW4pKGUscixhLGksbyk7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJydW5cIixvdXQ6dX0sKDAsdC5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycykodSkpfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwicnVuXCIsZXJyOnR9KX1icmVhaztjYXNlXCJlbmQtcHJvZmlsaW5nXCI6dHJ5e2NvbnN0IGU9bi5kYXRhLmluOygwLHQuZW5kUHJvZmlsaW5nKShlKSxwb3N0TWVzc2FnZSh7dHlwZTpcImVuZC1wcm9maWxpbmdcIn0pfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGVycjp0fSl9fX19KSgpfSkoKTtcXG4nLFwiV29ya2VyXCIsdm9pZCAwLHZvaWQgMCl9fSw0Nzc6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUsbixyKXt2YXIgaT1zZWxmfHx3aW5kb3c7dHJ5e3RyeXt2YXIgbzt0cnl7bz1uZXcgaS5CbG9iKFt0XSl9Y2F0Y2goZSl7KG89bmV3KGkuQmxvYkJ1aWxkZXJ8fGkuV2ViS2l0QmxvYkJ1aWxkZXJ8fGkuTW96QmxvYkJ1aWxkZXJ8fGkuTVNCbG9iQnVpbGRlcikpLmFwcGVuZCh0KSxvPW8uZ2V0QmxvYigpfXZhciBhPWkuVVJMfHxpLndlYmtpdFVSTCxzPWEuY3JlYXRlT2JqZWN0VVJMKG8pLHU9bmV3IGlbZV0ocyxuKTtyZXR1cm4gYS5yZXZva2VPYmplY3RVUkwocyksdX1jYXRjaChyKXtyZXR1cm4gbmV3IGlbZV0oXCJkYXRhOmFwcGxpY2F0aW9uL2phdmFzY3JpcHQsXCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudCh0KSksbil9fWNhdGNoKHQpe2lmKCFyKXRocm93IEVycm9yKFwiSW5saW5lIHdvcmtlciBpcyBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiBuZXcgaVtlXShyLG4pfX19LDQxNTQ6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz0nXCJ1c2Ugc3RyaWN0XCI7dmFyIGU9e30sdD1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7aWYodCl7dmFyIHI9cmVxdWlyZShcIndvcmtlcl90aHJlYWRzXCIpLGE9ci5wYXJlbnRQb3J0O2Eub24oXCJtZXNzYWdlXCIsKGU9Pm9ubWVzc2FnZSh7ZGF0YTplfSkpKTt2YXIgbz1yZXF1aXJlKFwiZnNcIik7T2JqZWN0LmFzc2lnbihnbG9iYWwse3NlbGY6Z2xvYmFsLHJlcXVpcmU6cmVxdWlyZSxNb2R1bGU6ZSxsb2NhdGlvbjp7aHJlZjpfX2ZpbGVuYW1lfSxXb3JrZXI6ci5Xb3JrZXIsaW1wb3J0U2NyaXB0czpmdW5jdGlvbihlKXsoMCxldmFsKShvLnJlYWRGaWxlU3luYyhlLFwidXRmOFwiKSl9LHBvc3RNZXNzYWdlOmZ1bmN0aW9uKGUpe2EucG9zdE1lc3NhZ2UoZSl9LHBlcmZvcm1hbmNlOmdsb2JhbC5wZXJmb3JtYW5jZXx8e25vdzpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfX19KX12YXIgcz0hMSxuPVtdLGk9ZnVuY3Rpb24oKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO3Q/by53cml0ZVN5bmMoMixlK1wiXFxcXG5cIik6Y29uc29sZS5lcnJvcihlKX07c2VsZi5hbGVydD1mdW5jdGlvbigpe3ZhciB0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIiBcIik7cG9zdE1lc3NhZ2Uoe2NtZDpcImFsZXJ0XCIsdGV4dDp0LHRocmVhZElkOmUuX3B0aHJlYWRfc2VsZigpfSl9LGUuaW5zdGFudGlhdGVXYXNtPSh0LHIpPT57dmFyIGE9bmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKGUud2FzbU1vZHVsZSx0KTtyZXR1cm4gcihhKSxlLndhc21Nb2R1bGU9bnVsbCxhLmV4cG9ydHN9LHNlbGYub251bmhhbmRsZWRyZWplY3Rpb249ZT0+e3Rocm93IGUucmVhc29uPz9lfSxzZWxmLm9ubWVzc2FnZT10PT57dHJ5e2lmKFwibG9hZFwiPT09dC5kYXRhLmNtZCl7aWYoZS53YXNtTW9kdWxlPXQuZGF0YS53YXNtTW9kdWxlLGUud2FzbU1lbW9yeT10LmRhdGEud2FzbU1lbW9yeSxlLmJ1ZmZlcj1lLndhc21NZW1vcnkuYnVmZmVyLGUuRU5WSVJPTk1FTlRfSVNfUFRIUkVBRD0hMCxcInN0cmluZ1wiPT10eXBlb2YgdC5kYXRhLnVybE9yQmxvYilpbXBvcnRTY3JpcHRzKHQuZGF0YS51cmxPckJsb2IpO2Vsc2V7dmFyIHI9VVJMLmNyZWF0ZU9iamVjdFVSTCh0LmRhdGEudXJsT3JCbG9iKTtpbXBvcnRTY3JpcHRzKHIpLFVSTC5yZXZva2VPYmplY3RVUkwocil9b3J0V2FzbVRocmVhZGVkKGUpLnRoZW4oKGZ1bmN0aW9uKHQpe2U9dH0pKX1lbHNlIGlmKFwicnVuXCI9PT10LmRhdGEuY21kKXtlLl9fcGVyZm9ybWFuY2Vfbm93X2Nsb2NrX2RyaWZ0PXBlcmZvcm1hbmNlLm5vdygpLXQuZGF0YS50aW1lLGUuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0KHQuZGF0YS5wdGhyZWFkX3B0ciwwLDAsMSksZS5lc3RhYmxpc2hTdGFja1NwYWNlKCksZS5QVGhyZWFkLnJlY2VpdmVPYmplY3RUcmFuc2Zlcih0LmRhdGEpLGUuUFRocmVhZC50aHJlYWRJbml0VExTKCksc3x8KG4uZm9yRWFjaCgodD0+e2UuZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZSh0KX0pKSxuPVtdLHM9ITApO3RyeXtlLmludm9rZUVudHJ5UG9pbnQodC5kYXRhLnN0YXJ0X3JvdXRpbmUsdC5kYXRhLmFyZyl9Y2F0Y2godCl7aWYoXCJ1bndpbmRcIiE9dCl7aWYoISh0IGluc3RhbmNlb2YgZS5FeGl0U3RhdHVzKSl0aHJvdyB0O2Uua2VlcFJ1bnRpbWVBbGl2ZSgpfHxlLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdCh0LnN0YXR1cyl9fX1lbHNlXCJjYW5jZWxcIj09PXQuZGF0YS5jbWQ/ZS5fcHRocmVhZF9zZWxmKCkmJmUuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0KC0xKTpcInNldGltbWVkaWF0ZVwiPT09dC5kYXRhLnRhcmdldHx8KFwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIj09PXQuZGF0YS5jbWQ/cz9lLmV4ZWN1dGVOb3RpZmllZFByb3h5aW5nUXVldWUodC5kYXRhLnF1ZXVlKTpuLnB1c2godC5kYXRhLnF1ZXVlKTooaShcIndvcmtlci5qcyByZWNlaXZlZCB1bmtub3duIGNvbW1hbmQgXCIrdC5kYXRhLmNtZCksaSh0LmRhdGEpKSl9Y2F0Y2godCl7dGhyb3cgaShcIndvcmtlci5qcyBvbm1lc3NhZ2UoKSBjYXB0dXJlZCBhbiB1bmNhdWdodCBleGNlcHRpb246IFwiK3QpLHQmJnQuc3RhY2smJmkodC5zdGFjayksZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQmJmUuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkKCksdH19O1xcbid9LDE2NzA6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1fX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18xNjcwX199LDcwNjc6KCk9Pnt9LDEyOTY6KCk9Pnt9LDEzODQ6KCk9Pnt9LDM5OTM6KCk9Pnt9LDkwODooKT0+e30sNjk1MzooKT0+e30sOTkyNTooKT0+e30sMjgwNjooKT0+e30sNjQ0OTooKT0+e30sMjg1MDooKT0+e30sNTM4MTooKT0+e30sNTY4NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7bi5yKGUpLG4uZChlLHtmbGF0YnVmZmVyczooKT0+cn0pO3ZhciByPXt9O3IuT2Zmc2V0LHIuVGFibGUsci5TSVpFT0ZfU0hPUlQ9MixyLlNJWkVPRl9JTlQ9NCxyLkZJTEVfSURFTlRJRklFUl9MRU5HVEg9NCxyLlNJWkVfUFJFRklYX0xFTkdUSD00LHIuRW5jb2Rpbmc9e1VURjhfQllURVM6MSxVVEYxNl9TVFJJTkc6Mn0sci5pbnQzMj1uZXcgSW50MzJBcnJheSgyKSxyLmZsb2F0MzI9bmV3IEZsb2F0MzJBcnJheShyLmludDMyLmJ1ZmZlciksci5mbG9hdDY0PW5ldyBGbG9hdDY0QXJyYXkoci5pbnQzMi5idWZmZXIpLHIuaXNMaXR0bGVFbmRpYW49MT09PW5ldyBVaW50MTZBcnJheShuZXcgVWludDhBcnJheShbMSwwXSkuYnVmZmVyKVswXSxyLkxvbmc9ZnVuY3Rpb24odCxlKXt0aGlzLmxvdz0wfHQsdGhpcy5oaWdoPTB8ZX0sci5Mb25nLmNyZWF0ZT1mdW5jdGlvbih0LGUpe3JldHVybiAwPT10JiYwPT1lP3IuTG9uZy5aRVJPOm5ldyByLkxvbmcodCxlKX0sci5Mb25nLnByb3RvdHlwZS50b0Zsb2F0NjQ9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5sb3c+Pj4wKSs0Mjk0OTY3Mjk2KnRoaXMuaGlnaH0sci5Mb25nLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubG93PT10LmxvdyYmdGhpcy5oaWdoPT10LmhpZ2h9LHIuTG9uZy5aRVJPPW5ldyByLkxvbmcoMCwwKSxyLkJ1aWxkZXI9ZnVuY3Rpb24odCl7aWYodCllPXQ7ZWxzZSB2YXIgZT0xMDI0O3RoaXMuYmI9ci5CeXRlQnVmZmVyLmFsbG9jYXRlKGUpLHRoaXMuc3BhY2U9ZSx0aGlzLm1pbmFsaWduPTEsdGhpcy52dGFibGU9bnVsbCx0aGlzLnZ0YWJsZV9pbl91c2U9MCx0aGlzLmlzTmVzdGVkPSExLHRoaXMub2JqZWN0X3N0YXJ0PTAsdGhpcy52dGFibGVzPVtdLHRoaXMudmVjdG9yX251bV9lbGVtcz0wLHRoaXMuZm9yY2VfZGVmYXVsdHM9ITF9LHIuQnVpbGRlci5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLmJiLmNsZWFyKCksdGhpcy5zcGFjZT10aGlzLmJiLmNhcGFjaXR5KCksdGhpcy5taW5hbGlnbj0xLHRoaXMudnRhYmxlPW51bGwsdGhpcy52dGFibGVfaW5fdXNlPTAsdGhpcy5pc05lc3RlZD0hMSx0aGlzLm9iamVjdF9zdGFydD0wLHRoaXMudnRhYmxlcz1bXSx0aGlzLnZlY3Rvcl9udW1fZWxlbXM9MCx0aGlzLmZvcmNlX2RlZmF1bHRzPSExfSxyLkJ1aWxkZXIucHJvdG90eXBlLmZvcmNlRGVmYXVsdHM9ZnVuY3Rpb24odCl7dGhpcy5mb3JjZV9kZWZhdWx0cz10fSxyLkJ1aWxkZXIucHJvdG90eXBlLmRhdGFCdWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYn0sci5CdWlsZGVyLnByb3RvdHlwZS5hc1VpbnQ4QXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYi5ieXRlcygpLnN1YmFycmF5KHRoaXMuYmIucG9zaXRpb24oKSx0aGlzLmJiLnBvc2l0aW9uKCkrdGhpcy5vZmZzZXQoKSl9LHIuQnVpbGRlci5wcm90b3R5cGUucHJlcD1mdW5jdGlvbih0LGUpe3Q+dGhpcy5taW5hbGlnbiYmKHRoaXMubWluYWxpZ249dCk7Zm9yKHZhciBuPTErfih0aGlzLmJiLmNhcGFjaXR5KCktdGhpcy5zcGFjZStlKSZ0LTE7dGhpcy5zcGFjZTxuK3QrZTspe3ZhciBpPXRoaXMuYmIuY2FwYWNpdHkoKTt0aGlzLmJiPXIuQnVpbGRlci5ncm93Qnl0ZUJ1ZmZlcih0aGlzLmJiKSx0aGlzLnNwYWNlKz10aGlzLmJiLmNhcGFjaXR5KCktaX10aGlzLnBhZChuKX0sci5CdWlsZGVyLnByb3RvdHlwZS5wYWQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0O2UrKyl0aGlzLmJiLndyaXRlSW50OCgtLXRoaXMuc3BhY2UsMCl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uKHQpe3RoaXMuYmIud3JpdGVJbnQ4KHRoaXMuc3BhY2UtPTEsdCl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQxNj1mdW5jdGlvbih0KXt0aGlzLmJiLndyaXRlSW50MTYodGhpcy5zcGFjZS09Mix0KX0sci5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDMyPWZ1bmN0aW9uKHQpe3RoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlLT00LHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlSW50NjQ9ZnVuY3Rpb24odCl7dGhpcy5iYi53cml0ZUludDY0KHRoaXMuc3BhY2UtPTgsdCl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyPWZ1bmN0aW9uKHQpe3RoaXMuYmIud3JpdGVGbG9hdDMyKHRoaXMuc3BhY2UtPTQsdCl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVGbG9hdDY0PWZ1bmN0aW9uKHQpe3RoaXMuYmIud3JpdGVGbG9hdDY0KHRoaXMuc3BhY2UtPTgsdCl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50OD1mdW5jdGlvbih0KXt0aGlzLnByZXAoMSwwKSx0aGlzLndyaXRlSW50OCh0KX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRJbnQxNj1mdW5jdGlvbih0KXt0aGlzLnByZXAoMiwwKSx0aGlzLndyaXRlSW50MTYodCl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50MzI9ZnVuY3Rpb24odCl7dGhpcy5wcmVwKDQsMCksdGhpcy53cml0ZUludDMyKHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDY0PWZ1bmN0aW9uKHQpe3RoaXMucHJlcCg4LDApLHRoaXMud3JpdGVJbnQ2NCh0KX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGbG9hdDMyPWZ1bmN0aW9uKHQpe3RoaXMucHJlcCg0LDApLHRoaXMud3JpdGVGbG9hdDMyKHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZsb2F0NjQ9ZnVuY3Rpb24odCl7dGhpcy5wcmVwKDgsMCksdGhpcy53cml0ZUZsb2F0NjQodCl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQ4PWZ1bmN0aW9uKHQsZSxuKXsodGhpcy5mb3JjZV9kZWZhdWx0c3x8ZSE9bikmJih0aGlzLmFkZEludDgoZSksdGhpcy5zbG90KHQpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDE2PWZ1bmN0aW9uKHQsZSxuKXsodGhpcy5mb3JjZV9kZWZhdWx0c3x8ZSE9bikmJih0aGlzLmFkZEludDE2KGUpLHRoaXMuc2xvdCh0KSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQzMj1mdW5jdGlvbih0LGUsbil7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fGUhPW4pJiYodGhpcy5hZGRJbnQzMihlKSx0aGlzLnNsb3QodCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkSW50NjQ9ZnVuY3Rpb24odCxlLG4peyF0aGlzLmZvcmNlX2RlZmF1bHRzJiZlLmVxdWFscyhuKXx8KHRoaXMuYWRkSW50NjQoZSksdGhpcy5zbG90KHQpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEZsb2F0MzI9ZnVuY3Rpb24odCxlLG4peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHxlIT1uKSYmKHRoaXMuYWRkRmxvYXQzMihlKSx0aGlzLnNsb3QodCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkRmxvYXQ2ND1mdW5jdGlvbih0LGUsbil7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fGUhPW4pJiYodGhpcy5hZGRGbG9hdDY0KGUpLHRoaXMuc2xvdCh0KSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRPZmZzZXQ9ZnVuY3Rpb24odCxlLG4peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHxlIT1uKSYmKHRoaXMuYWRkT2Zmc2V0KGUpLHRoaXMuc2xvdCh0KSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRTdHJ1Y3Q9ZnVuY3Rpb24odCxlLG4pe2UhPW4mJih0aGlzLm5lc3RlZChlKSx0aGlzLnNsb3QodCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLm5lc3RlZD1mdW5jdGlvbih0KXtpZih0IT10aGlzLm9mZnNldCgpKXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBzdHJ1Y3QgbXVzdCBiZSBzZXJpYWxpemVkIGlubGluZS5cIil9LHIuQnVpbGRlci5wcm90b3R5cGUubm90TmVzdGVkPWZ1bmN0aW9uKCl7aWYodGhpcy5pc05lc3RlZCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogb2JqZWN0IHNlcmlhbGl6YXRpb24gbXVzdCBub3QgYmUgbmVzdGVkLlwiKX0sci5CdWlsZGVyLnByb3RvdHlwZS5zbG90PWZ1bmN0aW9uKHQpe3RoaXMudnRhYmxlW3RdPXRoaXMub2Zmc2V0KCl9LHIuQnVpbGRlci5wcm90b3R5cGUub2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmIuY2FwYWNpdHkoKS10aGlzLnNwYWNlfSxyLkJ1aWxkZXIuZ3Jvd0J5dGVCdWZmZXI9ZnVuY3Rpb24odCl7dmFyIGU9dC5jYXBhY2l0eSgpO2lmKDMyMjEyMjU0NzImZSl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogY2Fubm90IGdyb3cgYnVmZmVyIGJleW9uZCAyIGdpZ2FieXRlcy5cIik7dmFyIG49ZTw8MSxpPXIuQnl0ZUJ1ZmZlci5hbGxvY2F0ZShuKTtyZXR1cm4gaS5zZXRQb3NpdGlvbihuLWUpLGkuYnl0ZXMoKS5zZXQodC5ieXRlcygpLG4tZSksaX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRPZmZzZXQ9ZnVuY3Rpb24odCl7dGhpcy5wcmVwKHIuU0laRU9GX0lOVCwwKSx0aGlzLndyaXRlSW50MzIodGhpcy5vZmZzZXQoKS10K3IuU0laRU9GX0lOVCl9LHIuQnVpbGRlci5wcm90b3R5cGUuc3RhcnRPYmplY3Q9ZnVuY3Rpb24odCl7dGhpcy5ub3ROZXN0ZWQoKSxudWxsPT10aGlzLnZ0YWJsZSYmKHRoaXMudnRhYmxlPVtdKSx0aGlzLnZ0YWJsZV9pbl91c2U9dDtmb3IodmFyIGU9MDtlPHQ7ZSsrKXRoaXMudnRhYmxlW2VdPTA7dGhpcy5pc05lc3RlZD0hMCx0aGlzLm9iamVjdF9zdGFydD10aGlzLm9mZnNldCgpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmVuZE9iamVjdD1mdW5jdGlvbigpe2lmKG51bGw9PXRoaXMudnRhYmxlfHwhdGhpcy5pc05lc3RlZCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogZW5kT2JqZWN0IGNhbGxlZCB3aXRob3V0IHN0YXJ0T2JqZWN0XCIpO3RoaXMuYWRkSW50MzIoMCk7Zm9yKHZhciB0PXRoaXMub2Zmc2V0KCksZT10aGlzLnZ0YWJsZV9pbl91c2UtMTtlPj0wJiYwPT10aGlzLnZ0YWJsZVtlXTtlLS0pO2Zvcih2YXIgbj1lKzE7ZT49MDtlLS0pdGhpcy5hZGRJbnQxNigwIT10aGlzLnZ0YWJsZVtlXT90LXRoaXMudnRhYmxlW2VdOjApO3RoaXMuYWRkSW50MTYodC10aGlzLm9iamVjdF9zdGFydCk7dmFyIGk9KG4rMikqci5TSVpFT0ZfU0hPUlQ7dGhpcy5hZGRJbnQxNihpKTt2YXIgbz0wLGE9dGhpcy5zcGFjZTt0OmZvcihlPTA7ZTx0aGlzLnZ0YWJsZXMubGVuZ3RoO2UrKyl7dmFyIHM9dGhpcy5iYi5jYXBhY2l0eSgpLXRoaXMudnRhYmxlc1tlXTtpZihpPT10aGlzLmJiLnJlYWRJbnQxNihzKSl7Zm9yKHZhciB1PXIuU0laRU9GX1NIT1JUO3U8aTt1Kz1yLlNJWkVPRl9TSE9SVClpZih0aGlzLmJiLnJlYWRJbnQxNihhK3UpIT10aGlzLmJiLnJlYWRJbnQxNihzK3UpKWNvbnRpbnVlIHQ7bz10aGlzLnZ0YWJsZXNbZV07YnJlYWt9fXJldHVybiBvPyh0aGlzLnNwYWNlPXRoaXMuYmIuY2FwYWNpdHkoKS10LHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlLG8tdCkpOih0aGlzLnZ0YWJsZXMucHVzaCh0aGlzLm9mZnNldCgpKSx0aGlzLmJiLndyaXRlSW50MzIodGhpcy5iYi5jYXBhY2l0eSgpLXQsdGhpcy5vZmZzZXQoKS10KSksdGhpcy5pc05lc3RlZD0hMSx0fSxyLkJ1aWxkZXIucHJvdG90eXBlLmZpbmlzaD1mdW5jdGlvbih0LGUsbil7dmFyIGk9bj9yLlNJWkVfUFJFRklYX0xFTkdUSDowO2lmKGUpe3ZhciBvPWU7aWYodGhpcy5wcmVwKHRoaXMubWluYWxpZ24sci5TSVpFT0ZfSU5UK3IuRklMRV9JREVOVElGSUVSX0xFTkdUSCtpKSxvLmxlbmd0aCE9ci5GSUxFX0lERU5USUZJRVJfTEVOR1RIKXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBmaWxlIGlkZW50aWZpZXIgbXVzdCBiZSBsZW5ndGggXCIrci5GSUxFX0lERU5USUZJRVJfTEVOR1RIKTtmb3IodmFyIGE9ci5GSUxFX0lERU5USUZJRVJfTEVOR1RILTE7YT49MDthLS0pdGhpcy53cml0ZUludDgoby5jaGFyQ29kZUF0KGEpKX10aGlzLnByZXAodGhpcy5taW5hbGlnbixyLlNJWkVPRl9JTlQraSksdGhpcy5hZGRPZmZzZXQodCksaSYmdGhpcy5hZGRJbnQzMih0aGlzLmJiLmNhcGFjaXR5KCktdGhpcy5zcGFjZSksdGhpcy5iYi5zZXRQb3NpdGlvbih0aGlzLnNwYWNlKX0sci5CdWlsZGVyLnByb3RvdHlwZS5maW5pc2hTaXplUHJlZml4ZWQ9ZnVuY3Rpb24odCxlKXt0aGlzLmZpbmlzaCh0LGUsITApfSxyLkJ1aWxkZXIucHJvdG90eXBlLnJlcXVpcmVkRmllbGQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmJiLmNhcGFjaXR5KCktdCxyPW4tdGhpcy5iYi5yZWFkSW50MzIobik7aWYoMD09dGhpcy5iYi5yZWFkSW50MTYocitlKSl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogZmllbGQgXCIrZStcIiBtdXN0IGJlIHNldFwiKX0sci5CdWlsZGVyLnByb3RvdHlwZS5zdGFydFZlY3Rvcj1mdW5jdGlvbih0LGUsbil7dGhpcy5ub3ROZXN0ZWQoKSx0aGlzLnZlY3Rvcl9udW1fZWxlbXM9ZSx0aGlzLnByZXAoci5TSVpFT0ZfSU5ULHQqZSksdGhpcy5wcmVwKG4sdCplKX0sci5CdWlsZGVyLnByb3RvdHlwZS5lbmRWZWN0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53cml0ZUludDMyKHRoaXMudmVjdG9yX251bV9lbGVtcyksdGhpcy5vZmZzZXQoKX0sci5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVTdHJpbmc9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpdmFyIGU9dDtlbHNle2U9W107Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDspe3ZhciByLGk9dC5jaGFyQ29kZUF0KG4rKyk7KHI9aTw1NTI5Nnx8aT49NTYzMjA/aTooaTw8MTApK3QuY2hhckNvZGVBdChuKyspKy01NjYxMzg4OCk8MTI4P2UucHVzaChyKToocjwyMDQ4P2UucHVzaChyPj42JjMxfDE5Mik6KHI8NjU1MzY/ZS5wdXNoKHI+PjEyJjE1fDIyNCk6ZS5wdXNoKHI+PjE4Jjd8MjQwLHI+PjEyJjYzfDEyOCksZS5wdXNoKHI+PjYmNjN8MTI4KSksZS5wdXNoKDYzJnJ8MTI4KSl9fXRoaXMuYWRkSW50OCgwKSx0aGlzLnN0YXJ0VmVjdG9yKDEsZS5sZW5ndGgsMSksdGhpcy5iYi5zZXRQb3NpdGlvbih0aGlzLnNwYWNlLT1lLmxlbmd0aCksbj0wO2Zvcih2YXIgbz10aGlzLnNwYWNlLGE9dGhpcy5iYi5ieXRlcygpO248ZS5sZW5ndGg7bisrKWFbbysrXT1lW25dO3JldHVybiB0aGlzLmVuZFZlY3RvcigpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmNyZWF0ZUxvbmc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gci5Mb25nLmNyZWF0ZSh0LGUpfSxyLkJ5dGVCdWZmZXI9ZnVuY3Rpb24odCl7dGhpcy5ieXRlc189dCx0aGlzLnBvc2l0aW9uXz0wfSxyLkJ5dGVCdWZmZXIuYWxsb2NhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyByLkJ5dGVCdWZmZXIobmV3IFVpbnQ4QXJyYXkodCkpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5wb3NpdGlvbl89MH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5ieXRlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ5dGVzX30sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5wb3NpdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvc2l0aW9uX30sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbj1mdW5jdGlvbih0KXt0aGlzLnBvc2l0aW9uXz10fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLmNhcGFjaXR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnl0ZXNfLmxlbmd0aH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWFkVWludDgodCk8PDI0Pj4yNH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDg9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYnl0ZXNfW3RdfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWFkVWludDE2KHQpPDwxNj4+MTZ9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ieXRlc19bdF18dGhpcy5ieXRlc19bdCsxXTw8OH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYnl0ZXNfW3RdfHRoaXMuYnl0ZXNfW3QrMV08PDh8dGhpcy5ieXRlc19bdCsyXTw8MTZ8dGhpcy5ieXRlc19bdCszXTw8MjR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWFkSW50MzIodCk+Pj4wfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ2ND1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IHIuTG9uZyh0aGlzLnJlYWRJbnQzMih0KSx0aGlzLnJlYWRJbnQzMih0KzQpKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDY0PWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgci5Mb25nKHRoaXMucmVhZFVpbnQzMih0KSx0aGlzLnJlYWRVaW50MzIodCs0KSl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0MzI9ZnVuY3Rpb24odCl7cmV0dXJuIHIuaW50MzJbMF09dGhpcy5yZWFkSW50MzIodCksci5mbG9hdDMyWzBdfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdDY0PWZ1bmN0aW9uKHQpe3JldHVybiByLmludDMyW3IuaXNMaXR0bGVFbmRpYW4/MDoxXT10aGlzLnJlYWRJbnQzMih0KSxyLmludDMyW3IuaXNMaXR0bGVFbmRpYW4/MTowXT10aGlzLnJlYWRJbnQzMih0KzQpLHIuZmxvYXQ2NFswXX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24odCxlKXt0aGlzLmJ5dGVzX1t0XT1lfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDg9ZnVuY3Rpb24odCxlKXt0aGlzLmJ5dGVzX1t0XT1lfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTY9ZnVuY3Rpb24odCxlKXt0aGlzLmJ5dGVzX1t0XT1lLHRoaXMuYnl0ZXNfW3QrMV09ZT4+OH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNj1mdW5jdGlvbih0LGUpe3RoaXMuYnl0ZXNfW3RdPWUsdGhpcy5ieXRlc19bdCsxXT1lPj44fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzI9ZnVuY3Rpb24odCxlKXt0aGlzLmJ5dGVzX1t0XT1lLHRoaXMuYnl0ZXNfW3QrMV09ZT4+OCx0aGlzLmJ5dGVzX1t0KzJdPWU+PjE2LHRoaXMuYnl0ZXNfW3QrM109ZT4+MjR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzI9ZnVuY3Rpb24odCxlKXt0aGlzLmJ5dGVzX1t0XT1lLHRoaXMuYnl0ZXNfW3QrMV09ZT4+OCx0aGlzLmJ5dGVzX1t0KzJdPWU+PjE2LHRoaXMuYnl0ZXNfW3QrM109ZT4+MjR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ2ND1mdW5jdGlvbih0LGUpe3RoaXMud3JpdGVJbnQzMih0LGUubG93KSx0aGlzLndyaXRlSW50MzIodCs0LGUuaGlnaCl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50NjQ9ZnVuY3Rpb24odCxlKXt0aGlzLndyaXRlVWludDMyKHQsZS5sb3cpLHRoaXMud3JpdGVVaW50MzIodCs0LGUuaGlnaCl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyPWZ1bmN0aW9uKHQsZSl7ci5mbG9hdDMyWzBdPWUsdGhpcy53cml0ZUludDMyKHQsci5pbnQzMlswXSl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdDY0PWZ1bmN0aW9uKHQsZSl7ci5mbG9hdDY0WzBdPWUsdGhpcy53cml0ZUludDMyKHQsci5pbnQzMltyLmlzTGl0dGxlRW5kaWFuPzA6MV0pLHRoaXMud3JpdGVJbnQzMih0KzQsci5pbnQzMltyLmlzTGl0dGxlRW5kaWFuPzE6MF0pfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLmdldEJ1ZmZlcklkZW50aWZpZXI9ZnVuY3Rpb24oKXtpZih0aGlzLmJ5dGVzXy5sZW5ndGg8dGhpcy5wb3NpdGlvbl8rci5TSVpFT0ZfSU5UK3IuRklMRV9JREVOVElGSUVSX0xFTkdUSCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogQnl0ZUJ1ZmZlciBpcyB0b28gc2hvcnQgdG8gY29udGFpbiBhbiBpZGVudGlmaWVyLlwiKTtmb3IodmFyIHQ9XCJcIixlPTA7ZTxyLkZJTEVfSURFTlRJRklFUl9MRU5HVEg7ZSsrKXQrPVN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkSW50OCh0aGlzLnBvc2l0aW9uXytyLlNJWkVPRl9JTlQrZSkpO3JldHVybiB0fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fb2Zmc2V0PWZ1bmN0aW9uKHQsZSl7dmFyIG49dC10aGlzLnJlYWRJbnQzMih0KTtyZXR1cm4gZTx0aGlzLnJlYWRJbnQxNihuKT90aGlzLnJlYWRJbnQxNihuK2UpOjB9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX191bmlvbj1mdW5jdGlvbih0LGUpe3JldHVybiB0LmJiX3Bvcz1lK3RoaXMucmVhZEludDMyKGUpLHQuYmI9dGhpcyx0fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fc3RyaW5nPWZ1bmN0aW9uKHQsZSl7dCs9dGhpcy5yZWFkSW50MzIodCk7dmFyIG49dGhpcy5yZWFkSW50MzIodCksaT1cIlwiLG89MDtpZih0Kz1yLlNJWkVPRl9JTlQsZT09PXIuRW5jb2RpbmcuVVRGOF9CWVRFUylyZXR1cm4gdGhpcy5ieXRlc18uc3ViYXJyYXkodCx0K24pO2Zvcig7bzxuOyl7dmFyIGEscz10aGlzLnJlYWRVaW50OCh0K28rKyk7aWYoczwxOTIpYT1zO2Vsc2V7dmFyIHU9dGhpcy5yZWFkVWludDgodCtvKyspO2lmKHM8MjI0KWE9KDMxJnMpPDw2fDYzJnU7ZWxzZXt2YXIgYz10aGlzLnJlYWRVaW50OCh0K28rKyk7YT1zPDI0MD8oMTUmcyk8PDEyfCg2MyZ1KTw8Nnw2MyZjOig3JnMpPDwxOHwoNjMmdSk8PDEyfCg2MyZjKTw8Nnw2MyZ0aGlzLnJlYWRVaW50OCh0K28rKyl9fWE8NjU1MzY/aSs9U3RyaW5nLmZyb21DaGFyQ29kZShhKTooYS09NjU1MzYsaSs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NisoYT4+MTApLDU2MzIwKygxMDIzJmEpKSl9cmV0dXJuIGl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19pbmRpcmVjdD1mdW5jdGlvbih0KXtyZXR1cm4gdCt0aGlzLnJlYWRJbnQzMih0KX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3ZlY3Rvcj1mdW5jdGlvbih0KXtyZXR1cm4gdCt0aGlzLnJlYWRJbnQzMih0KStyLlNJWkVPRl9JTlR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX192ZWN0b3JfbGVuPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnJlYWRJbnQzMih0K3RoaXMucmVhZEludDMyKHQpKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX2hhc19pZGVudGlmaWVyPWZ1bmN0aW9uKHQpe2lmKHQubGVuZ3RoIT1yLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IGZpbGUgaWRlbnRpZmllciBtdXN0IGJlIGxlbmd0aCBcIityLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpO2Zvcih2YXIgZT0wO2U8ci5GSUxFX0lERU5USUZJRVJfTEVOR1RIO2UrKylpZih0LmNoYXJDb2RlQXQoZSkhPXRoaXMucmVhZEludDgodGhpcy5wb3NpdGlvbl8rci5TSVpFT0ZfSU5UK2UpKXJldHVybiExO3JldHVybiEwfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLmNyZWF0ZUxvbmc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gci5Mb25nLmNyZWF0ZSh0LGUpfX19LF9fd2VicGFja19tb2R1bGVfY2FjaGVfXz17fTtmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKHQpe3ZhciBlPV9fd2VicGFja19tb2R1bGVfY2FjaGVfX1t0XTtpZih2b2lkIDAhPT1lKXJldHVybiBlLmV4cG9ydHM7dmFyIG49X193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW3RdPXtleHBvcnRzOnt9fTtyZXR1cm4gX193ZWJwYWNrX21vZHVsZXNfX1t0XS5jYWxsKG4uZXhwb3J0cyxuLG4uZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKSxuLmV4cG9ydHN9X193ZWJwYWNrX3JlcXVpcmVfXy5uPXQ9Pnt2YXIgZT10JiZ0Ll9fZXNNb2R1bGU/KCk9PnQuZGVmYXVsdDooKT0+dDtyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5kKGUse2E6ZX0pLGV9LF9fd2VicGFja19yZXF1aXJlX18uZD0odCxlKT0+e2Zvcih2YXIgbiBpbiBlKV9fd2VicGFja19yZXF1aXJlX18ubyhlLG4pJiYhX193ZWJwYWNrX3JlcXVpcmVfXy5vKHQsbikmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4se2VudW1lcmFibGU6ITAsZ2V0OmVbbl19KX0sX193ZWJwYWNrX3JlcXVpcmVfXy5nPWZ1bmN0aW9uKCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbFRoaXMpcmV0dXJuIGdsb2JhbFRoaXM7dHJ5e3JldHVybiB0aGlzfHxuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfWNhdGNoKHQpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cpcmV0dXJuIHdpbmRvd319KCksX193ZWJwYWNrX3JlcXVpcmVfXy5vPSh0LGUpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSxfX3dlYnBhY2tfcmVxdWlyZV9fLnI9dD0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9O3ZhciBfX3dlYnBhY2tfZXhwb3J0c19fPV9fd2VicGFja19yZXF1aXJlX18oNjAxOCk7cmV0dXJuIF9fd2VicGFja19leHBvcnRzX199KSgpKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcnQtd2ViLm1pbi5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplU3RhdGVWYWx1ZShzdGF0ZVZhbHVlKSB7XG4gIGlmICh0eXBlb2Ygc3RhdGVWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzdGF0ZVZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2Ygc3RhdGVWYWx1ZSA9PT0gJ29iamVjdCcgJiYgc3RhdGVWYWx1ZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdGF0ZVZhbHVlKVxuICAgICAgLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IG5lc3RlZFZhbHVlID0gc3RhdGVWYWx1ZVtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSAnb2JqZWN0JyAmJiBuZXN0ZWRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBgJHtrZXl9Onske3NlcmlhbGl6ZVN0YXRlVmFsdWUobmVzdGVkVmFsdWUpfX1gO1xuICAgICAgICB9IFxuICAgICAgICByZXR1cm4gYCR7a2V5fToke25lc3RlZFZhbHVlfWA7XG4gICAgICB9KVxuICAgICAgLmpvaW4oXCIsXCIpO1xuICB9XG4gIHJldHVybiBTdHJpbmcoc3RhdGVWYWx1ZSk7XG59XG5cbmNsYXNzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKHByZWZpeCA9IFwiU2F5UGlcIikge1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIC8vIFRPRE86IE1ha2UgZGVidWdNb2RlIGNvbmZpZ3VyYWJsZSwgZS5nLiwgdmlhIHN0b3JhZ2Ugb3IgYSBnbG9iYWwgZmxhZ1xuICAgIHRoaXMuZGVidWdNb2RlID0gdHJ1ZTsgLy8gRGVmYXVsdCB0byB0cnVlIGZvciBlYXNpZXIgZGV2ZWxvcG1lbnQsIGNhbiBiZSBjaGFuZ2VkXG4gIH1cblxuICBzZXREZWJ1Z01vZGUoZW5hYmxlZCkge1xuICAgIHRoaXMuZGVidWdNb2RlID0gZW5hYmxlZDtcbiAgfVxuXG4gIF9mb3JtYXRBcmdzKGFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5tYXAoYXJnID0+IFxuICAgICAgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsICYmICEoYXJnIGluc3RhbmNlb2YgRXJyb3IpID8gSlNPTi5zdHJpbmdpZnkoYXJnLCBudWxsLCAyKSA6IGFyZ1xuICAgICk7XG4gIH1cblxuICBsb2coLi4uYXJncykge1xuICAgIGNvbnNvbGUubG9nKGBbJHt0aGlzLnByZWZpeH1dYCwgLi4udGhpcy5fZm9ybWF0QXJncyhhcmdzKSk7XG4gIH1cblxuICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICBjb25zb2xlLmRlYnVnKGBbJHt0aGlzLnByZWZpeH0gREVCVUddYCwgLi4udGhpcy5fZm9ybWF0QXJncyhhcmdzKSk7XG4gICAgfVxuICB9XG5cbiAgaW5mbyguLi5hcmdzKSB7IC8vIEFsaWFzIGZvciBsb2dcbiAgICBjb25zb2xlLmluZm8oYFske3RoaXMucHJlZml4fSBJTkZPXWAsIC4uLnRoaXMuX2Zvcm1hdEFyZ3MoYXJncykpO1xuICB9XG5cbiAgd2FybiguLi5hcmdzKSB7XG4gICAgY29uc29sZS53YXJuKGBbJHt0aGlzLnByZWZpeH0gV0FSTklOR11gLCAuLi50aGlzLl9mb3JtYXRBcmdzKGFyZ3MpKTtcbiAgfVxuXG4gIGVycm9yKC4uLmFyZ3MpIHtcbiAgICBjb25zb2xlLmVycm9yKGBbJHt0aGlzLnByZWZpeH0gRVJST1JdYCwgLi4udGhpcy5fZm9ybWF0QXJncyhhcmdzKSk7XG4gIH1cblxuICBncm91cChsYWJlbCkge1xuICAgIGNvbnNvbGUuZ3JvdXAoYFske3RoaXMucHJlZml4fV0gJHtsYWJlbH1gKTtcbiAgfVxuXG4gIGdyb3VwRW5kKCkge1xuICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgfVxuXG4gIHJlcG9ydEVycm9yKGVycm9yLCBjb250ZXh0ID0ge30sIGFkZGl0aW9uYWxNZXNzYWdlID0gXCJcIikge1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGFkZGl0aW9uYWxNZXNzYWdlID8gYCR7YWRkaXRpb25hbE1lc3NhZ2V9OiAke2Vycm9yLm1lc3NhZ2UgfHwgU3RyaW5nKGVycm9yKX1gIDogKGVycm9yLm1lc3NhZ2UgfHwgU3RyaW5nKGVycm9yKSk7XG4gICAgY29uc3QgZXJyb3JJbmZvID0ge1xuICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgICAgc3RhY2s6IGVycm9yLnN0YWNrLFxuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgcHJlZml4OiB0aGlzLnByZWZpeCxcbiAgICB9O1xuXG4gICAgdGhpcy5lcnJvcihlcnJvck1lc3NhZ2UsIFwiQ29udGV4dDpcIiwgY29udGV4dCwgXCJTdGFjazpcIiwgZXJyb3Iuc3RhY2spO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNocm9tZS5ydW50aW1lLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogXCJMT0dfRVJST1JfUkVQT1JUXCIsIC8vIENoYW5nZWQgdHlwZSB0byBiZSBtb3JlIHNwZWNpZmljXG4gICAgICAgIGVycm9yOiBlcnJvckluZm8sXG4gICAgICAgIG9yaWdpbjogXCJsb2dnZXItcmVwb3J0RXJyb3JcIiAvLyBJZGVudGlmeSB0aGUgc291cmNlIG9mIHRoaXMgbWVzc2FnZVxuICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgIC8vIFRoaXMgY2F0Y2ggaXMgZm9yIHNlbmRNZXNzYWdlIGl0c2VsZiBmYWlsaW5nIChlLmcuIGlmIGJhY2tncm91bmQgaXNuJ3QgcmVhZHkpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbTG9nZ2VyXSBGYWlsZWQgdG8gc2VuZCBlcnJvciByZXBvcnQgdG8gYmFja2dyb3VuZDpcIiwgZSwgZXJyb3JJbmZvKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIENhdGNoIHN5bmNocm9ub3VzIGVycm9ycyBmcm9tIHNlbmRNZXNzYWdlLCB0aG91Z2ggbGVzcyBjb21tb25cbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbTG9nZ2VyXSBTeW5jaHJvbm91cyBlcnJvciBzZW5kaW5nIGVycm9yIHJlcG9ydCB0byBiYWNrZ3JvdW5kOlwiLCBlLCBlcnJvckluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JJbmZvO1xuICB9XG59XG5cbi8vIEV4cG9ydCBhIHNpbmdsZSBpbnN0YW5jZSBvZiB0aGUgbG9nZ2VyXG5leHBvcnQgY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcihcIlNheVBpXCIpO1xuXG4vLyBFeGFtcGxlIHVzYWdlIChvcHRpb25hbCwgZm9yIHRlc3RpbmcpOlxuLy8gbG9nZ2VyLnNldERlYnVnTW9kZSh0cnVlKTtcbi8vIGxvZ2dlci5kZWJ1ZyhcIlRoaXMgaXMgYSBkZWJ1ZyBtZXNzYWdlXCIsIHsgYTogMSB9KTtcbi8vIGxvZ2dlci5pbmZvKFwiVGhpcyBpcyBhbiBpbmZvIG1lc3NhZ2VcIik7XG4vLyBsb2dnZXIud2FybihcIlRoaXMgaXMgYSB3YXJuaW5nXCIpO1xuLy8gdHJ5IHtcbi8vICAgdGhyb3cgbmV3IEVycm9yKFwiVGVzdCBlcnJvciBmb3IgcmVwb3J0aW5nXCIpO1xuLy8gfSBjYXRjaCAoZSkge1xuLy8gICBsb2dnZXIucmVwb3J0RXJyb3IoZSwgeyBjdXN0b21Db250ZXh0OiBcIlRlc3QgY29udGV4dFwiIH0sIFwiQ2F1Z2h0IGFuIGV4Y2VwdGlvblwiKTtcbi8vIH1cbiIsImltcG9ydCB7IGVuY29kZVdBViB9IGZyb20gXCIuL1dhdkVuY29kZXJcIjtcblxuLyoqXG4gKiBDb252ZXJ0IGEgRmxvYXQzMkFycmF5IG9mIGF1ZGlvIHNhbXBsZXMgdG8gYSBXQVYgYXJyYXkgYnVmZmVyXG4gKiBAcGFyYW0gYXVkaW9EYXRhIC0gVGhlIGF1ZGlvIHNhbXBsZXNcbiAqIEByZXR1cm5zIC0gVGhlIGF1ZGlvIGluIFdBViBmb3JtYXQgYXMgYW4gQXJyYXlCdWZmZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb1dhdkJ1ZmZlcihhdWRpb0RhdGE6IEZsb2F0MzJBcnJheSk6IEFycmF5QnVmZmVyIHtcbiAgY29uc3QgYXJyYXlCdWZmZXIgPSBlbmNvZGVXQVYoYXVkaW9EYXRhKTtcbiAgcmV0dXJuIGFycmF5QnVmZmVyO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBGbG9hdDMyQXJyYXkgb2YgYXVkaW8gc2FtcGxlcyB0byBhIFdBViBCbG9iXG4gKiBAcGFyYW0gYXVkaW9EYXRhIC0gVGhlIGF1ZGlvIHNhbXBsZXNcbiAqIEByZXR1cm5zIC0gVGhlIGF1ZGlvIGluIFdBViBmb3JtYXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb1dhdkJsb2IoYXVkaW9EYXRhOiBGbG9hdDMyQXJyYXkpOiBCbG9iIHtcbiAgY29uc3QgYXJyYXlCdWZmZXIgPSBjb252ZXJ0VG9XYXZCdWZmZXIoYXVkaW9EYXRhKTtcbiAgcmV0dXJuIG5ldyBCbG9iKFthcnJheUJ1ZmZlcl0sIHsgdHlwZTogXCJhdWRpby93YXZcIiB9KTtcbn1cbiIsIi8vIE1vc3Qgb2YgdGhlIGNvZGUgaGVyZSBjb21lIGZyb20gcmlja3kwMTIzL3ZhZC13ZWJcbi8vIFdobyBpbiB0dXJuIGNvcGllZCBpdCBmcm9tIGxpbnRvLWFpL1dlYlZvaWNlU0RLXG5cbmV4cG9ydCBmdW5jdGlvbiBtaW5GcmFtZXNGb3JUYXJnZXRNUyhcbiAgdGFyZ2V0RHVyYXRpb246IG51bWJlcixcbiAgZnJhbWVTYW1wbGVzOiBudW1iZXIsXG4gIHNyID0gMTYwMDBcbik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLmNlaWwoKHRhcmdldER1cmF0aW9uICogc3IpIC8gMTAwMCAvIGZyYW1lU2FtcGxlcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUJ1ZmZlclRvQmFzZTY0KGJ1ZmZlcjogQXJyYXlCdWZmZXIpIHtcbiAgdmFyIGJpbmFyeSA9IFwiXCI7XG4gIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gIHZhciBsZW4gPSBieXRlcy5ieXRlTGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gYXMgbnVtYmVyKTtcbiAgfVxuICByZXR1cm4gYnRvYShiaW5hcnkpO1xufVxuXG4vKlxuICBUaGlzIHJlc3Qgb2YgdGhpcyB3YXMgbW9zdGx5IGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9saW50by1haS9XZWJWb2ljZVNES1xuICAqL1xuXG4vLyB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZW5jb2RlIHRoZSBGbG9hdDMyQXJyYXkgYXVkaW8gZGF0YSBwcm9kdWNlZCBmcm9tIGEgTWljVkFEXG4vLyBhcyBhIFdBViBmaWxlIGF1ZGlvIGJ1ZmZlclxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVdBVihcbiAgc2FtcGxlczogRmxvYXQzMkFycmF5LFxuICBmb3JtYXQ6IG51bWJlciA9IDMsXG4gIHNhbXBsZVJhdGU6IG51bWJlciA9IDE2MDAwLFxuICBudW1DaGFubmVsczogbnVtYmVyID0gMSxcbiAgYml0RGVwdGg6IG51bWJlciA9IDMyXG4pIHtcbiAgdmFyIGJ5dGVzUGVyU2FtcGxlID0gYml0RGVwdGggLyA4O1xuICB2YXIgYmxvY2tBbGlnbiA9IG51bUNoYW5uZWxzICogYnl0ZXNQZXJTYW1wbGU7XG4gIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoNDQgKyBzYW1wbGVzLmxlbmd0aCAqIGJ5dGVzUGVyU2FtcGxlKTtcbiAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgLyogUklGRiBpZGVudGlmaWVyICovXG4gIHdyaXRlU3RyaW5nKHZpZXcsIDAsIFwiUklGRlwiKTtcbiAgLyogUklGRiBjaHVuayBsZW5ndGggKi9cbiAgdmlldy5zZXRVaW50MzIoNCwgMzYgKyBzYW1wbGVzLmxlbmd0aCAqIGJ5dGVzUGVyU2FtcGxlLCB0cnVlKTtcbiAgLyogUklGRiB0eXBlICovXG4gIHdyaXRlU3RyaW5nKHZpZXcsIDgsIFwiV0FWRVwiKTtcbiAgLyogZm9ybWF0IGNodW5rIGlkZW50aWZpZXIgKi9cbiAgd3JpdGVTdHJpbmcodmlldywgMTIsIFwiZm10IFwiKTtcbiAgLyogZm9ybWF0IGNodW5rIGxlbmd0aCAqL1xuICB2aWV3LnNldFVpbnQzMigxNiwgMTYsIHRydWUpO1xuICAvKiBzYW1wbGUgZm9ybWF0IChyYXcpICovXG4gIHZpZXcuc2V0VWludDE2KDIwLCBmb3JtYXQsIHRydWUpO1xuICAvKiBjaGFubmVsIGNvdW50ICovXG4gIHZpZXcuc2V0VWludDE2KDIyLCBudW1DaGFubmVscywgdHJ1ZSk7XG4gIC8qIHNhbXBsZSByYXRlICovXG4gIHZpZXcuc2V0VWludDMyKDI0LCBzYW1wbGVSYXRlLCB0cnVlKTtcbiAgLyogYnl0ZSByYXRlIChzYW1wbGUgcmF0ZSAqIGJsb2NrIGFsaWduKSAqL1xuICB2aWV3LnNldFVpbnQzMigyOCwgc2FtcGxlUmF0ZSAqIGJsb2NrQWxpZ24sIHRydWUpO1xuICAvKiBibG9jayBhbGlnbiAoY2hhbm5lbCBjb3VudCAqIGJ5dGVzIHBlciBzYW1wbGUpICovXG4gIHZpZXcuc2V0VWludDE2KDMyLCBibG9ja0FsaWduLCB0cnVlKTtcbiAgLyogYml0cyBwZXIgc2FtcGxlICovXG4gIHZpZXcuc2V0VWludDE2KDM0LCBiaXREZXB0aCwgdHJ1ZSk7XG4gIC8qIGRhdGEgY2h1bmsgaWRlbnRpZmllciAqL1xuICB3cml0ZVN0cmluZyh2aWV3LCAzNiwgXCJkYXRhXCIpO1xuICAvKiBkYXRhIGNodW5rIGxlbmd0aCAqL1xuICB2aWV3LnNldFVpbnQzMig0MCwgc2FtcGxlcy5sZW5ndGggKiBieXRlc1BlclNhbXBsZSwgdHJ1ZSk7XG4gIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAvLyBSYXcgUENNXG4gICAgZmxvYXRUbzE2Qml0UENNKHZpZXcsIDQ0LCBzYW1wbGVzKTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZUZsb2F0MzIodmlldywgNDQsIHNhbXBsZXMpO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGludGVybGVhdmUoaW5wdXRMOiBGbG9hdDMyQXJyYXksIGlucHV0UjogRmxvYXQzMkFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBpbnB1dEwubGVuZ3RoICsgaW5wdXRSLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkobGVuZ3RoKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGlucHV0SW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXgrK10gPSBpbnB1dExbaW5wdXRJbmRleF0gYXMgbnVtYmVyO1xuICAgIHJlc3VsdFtpbmRleCsrXSA9IGlucHV0UltpbnB1dEluZGV4XSBhcyBudW1iZXI7XG4gICAgaW5wdXRJbmRleCsrO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQzMihvdXRwdXQ6IERhdGFWaWV3LCBvZmZzZXQ6IG51bWJlciwgaW5wdXQ6IEZsb2F0MzJBcnJheSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgIG91dHB1dC5zZXRGbG9hdDMyKG9mZnNldCwgaW5wdXRbaV0gYXMgbnVtYmVyLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmbG9hdFRvMTZCaXRQQ00oXG4gIG91dHB1dDogRGF0YVZpZXcsXG4gIG9mZnNldDogbnVtYmVyLFxuICBpbnB1dDogRmxvYXQzMkFycmF5XG4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKywgb2Zmc2V0ICs9IDIpIHtcbiAgICB2YXIgcyA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCBpbnB1dFtpXSBhcyBudW1iZXIpKTtcbiAgICBvdXRwdXQuc2V0SW50MTYob2Zmc2V0LCBzIDwgMCA/IHMgKiAweDgwMDAgOiBzICogMHg3ZmZmLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZVN0cmluZyh2aWV3OiBEYXRhVmlldywgb2Zmc2V0OiBudW1iZXIsIHN0cmluZzogc3RyaW5nKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQgKyBpLCBzdHJpbmcuY2hhckNvZGVBdChpKSk7XG4gIH1cbn1cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0IHsgTWljVkFELCBSZWFsVGltZVZBRE9wdGlvbnMgfSBmcm9tIFwiQHJpY2t5MDEyMy92YWQtd2ViXCI7XG5pbXBvcnQgeyBjb252ZXJ0VG9XYXZCbG9iIH0gZnJvbSBcIi4uL2F1ZGlvL0F1ZGlvRW5jb2RlclwiOyAvLyBBc3N1bWluZyB0aGlzIGlzIG5lZWRlZCBmb3Igb25TcGVlY2hFbmRcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCIuLi9Mb2dnaW5nTW9kdWxlLmpzXCI7IC8vIEltcG9ydCB0aGUgZW5oYW5jZWQgbG9nZ2VyXG4vLyBJZiBnZXRSZXNvdXJjZVVybCBvciBzaW1pbGFyIGlzIG5lZWRlZCBmcm9tIGFub3RoZXIgbW9kdWxlLCBpbXBvcnQgaXQuXG4vLyBGb3Igbm93LCB3ZSBhc3N1bWUgcGF0aHMgd2lsbCBiZSByZWxhdGl2ZSBvciBjb25zdHJ1Y3RlZCB2aWEgY2hyb21lLnJ1bnRpbWUuZ2V0VVJMKClcblxubG9nZ2VyLmxvZyhcIltTYXlQaSBWQUQgT2Zmc2NyZWVuXSBTY3JpcHQgbG9hZGVkLlwiKTtcblxuaW50ZXJmYWNlIE15UmVhbFRpbWVWQURDYWxsYmFja3Mge1xuICBvblNwZWVjaFN0YXJ0PzogKCkgPT4gYW55O1xuICBvblNwZWVjaEVuZD86IChhdWRpbzogRmxvYXQzMkFycmF5KSA9PiBhbnk7XG4gIG9uVkFETWlzZmlyZT86ICgpID0+IGFueTtcbiAgb25GcmFtZVByb2Nlc3NlZD86IChwcm9iYWJpbGl0aWVzOiB7IGlzU3BlZWNoOiBudW1iZXI7IG5vdFNwZWVjaDogbnVtYmVyIH0pID0+IGFueTtcbn1cblxubGV0IGN1cnJlbnRBY3RpdmVUYWJJZDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5sZXQgdmFkSW5zdGFuY2U6IE1pY1ZBRCB8IG51bGwgPSBudWxsO1xubGV0IHN0cmVhbTogTWVkaWFTdHJlYW0gfCBudWxsID0gbnVsbDtcbmxldCBzcGVlY2hTdGFydFRpbWUgPSAwO1xuXG4vLyBGdW5jdGlvbiB0byBnZXQgcmVzb3VyY2UgVVJMcyB3aXRoaW4gdGhlIGV4dGVuc2lvbiBwYWNrYWdlXG5mdW5jdGlvbiBnZXRFeHRlbnNpb25GaWxlVXJsKHJlbGF0aXZlUGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc29sZS5sb2coXCJbU2F5UGkgVkFEIE9mZnNjcmVlbl0gR2V0dGluZyBleHRlbnNpb24gZmlsZSBVUkwgZm9yOlwiLCByZWxhdGl2ZVBhdGgpO1xuICByZXR1cm4gY2hyb21lLnJ1bnRpbWUuZ2V0VVJMKHJlbGF0aXZlUGF0aCk7XG59XG5cbmNvbnN0IGNvbW1vbk1pY1ZBRE9wdGlvbnM6IFBhcnRpYWw8UmVhbFRpbWVWQURPcHRpb25zPiAmIE15UmVhbFRpbWVWQURDYWxsYmFja3MgPSB7XG4gIC8vIG1vZGVsOiBcInY1XCIsIC8vIFRoaXMgd2lsbCBiZSBkZWZhdWx0IGlmIG5vdCBzcGVjaWZpZWQsIG9yIGNhbiBiZSBleHBsaWNpdFxuICBvcnRDb25maWc6IChvcnQ6IGFueSkgPT4ge1xuICAgIC8vIFBhdGhzIG5lZWQgdG8gYmUgYWNjZXNzaWJsZSBmcm9tIHRoZSBleHRlbnNpb24ncyByb290XG4gICAgLy8gVGhlIGZpbGVzIGFyZSBpbiBgcHVibGljL2AgZm9sZGVyIGFzIHBlciBtYW5pZmVzdC5qc29uIHdlYl9hY2Nlc3NpYmxlX3Jlc291cmNlc1xuICAgIG9ydC5lbnYud2FzbS53YXNtUGF0aHMgPSB7XG4gICAgICAnb3J0LXdhc20ud2FzbSc6IGdldEV4dGVuc2lvbkZpbGVVcmwoJ3B1YmxpYy9vcnQtd2FzbS53YXNtJyksXG4gICAgICAnb3J0LXdhc20tc2ltZC53YXNtJzogZ2V0RXh0ZW5zaW9uRmlsZVVybCgncHVibGljL29ydC13YXNtLXNpbWQud2FzbScpLFxuICAgICAgJ29ydC13YXNtLXRocmVhZGVkLndhc20nOiBnZXRFeHRlbnNpb25GaWxlVXJsKCdwdWJsaWMvb3J0LXdhc20tdGhyZWFkZWQud2FzbScpLFxuICAgICAgJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbSc6IGdldEV4dGVuc2lvbkZpbGVVcmwoJ3B1YmxpYy9vcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc20nKSxcbiAgICB9O1xuICAgIG9ydC5lbnYud2FzbS5udW1UaHJlYWRzID0gMTtcbiAgICBvcnQuZW52Lndhc20uc2ltZCA9IGZhbHNlOyAvLyBTdGFydCB3aXRoIFNJTUQgZmFsc2UgZm9yIGJyb2FkZXIgY29tcGF0aWJpbGl0eSwgY2FuIGJlIHRydWUgaWYgaXNzdWVzIGFyZSByZXNvbHZlZC5cbiAgICBsb2dnZXIuZGVidWcoXCJbU2F5UGkgVkFEIE9mZnNjcmVlbl0gT1JUIGNvbmZpZyBhcHBsaWVkOlwiLCBvcnQuZW52Lndhc20ud2FzbVBhdGhzKTtcbiAgfSxcbiAgcG9zaXRpdmVTcGVlY2hUaHJlc2hvbGQ6IDAuOCxcbiAgbWluU3BlZWNoRnJhbWVzOiAzLFxuICBwcmVTcGVlY2hQYWRGcmFtZXM6IDEwLFxuICBtb2RlbDogXCJ2NVwiLFxuICAvL3dvcmtsZXRVUkw6IGdldEV4dGVuc2lvbkZpbGVVcmwoJ3B1YmxpYy92YWQud29ya2xldC5idW5kbGUubWluLmpzJyksIC8vIENvbnNpZGVyIGJyb3dzZXIgZGV0ZWN0aW9uIGZvciAuanMgdnMgLm1pbi5qcyBpZiBuZWVkZWRcbiAgLy8gbW9kZWxVUkw6IGdldEV4dGVuc2lvbkZpbGVVcmwoJ3B1YmxpYy9zaWxlcm9fdmFkLm9ubngnKSwgLy8gRW5zdXJlIHRoaXMgcGF0aCBpcyBjb3JyZWN0IGFuZCBtb2RlbCBpcyB3ZWJfYWNjZXNzaWJsZVxuXG4gIG9uU3BlZWNoU3RhcnQ6ICgpID0+IHtcbiAgICBsb2dnZXIuZGVidWcoXCJbU2F5UGkgVkFEIE9mZnNjcmVlbl0gU3BlZWNoIHN0YXJ0ZWQuXCIpO1xuICAgIHNwZWVjaFN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgaWYgKGN1cnJlbnRBY3RpdmVUYWJJZCAhPT0gbnVsbCkge1xuICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBcIlZBRF9TUEVFQ0hfU1RBUlRcIixcbiAgICAgICAgdGFyZ2V0VGFiSWQ6IGN1cnJlbnRBY3RpdmVUYWJJZCxcbiAgICAgICAgb3JpZ2luOiBcIm9mZnNjcmVlbi1kb2N1bWVudFwiLFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBvblNwZWVjaEVuZDogKHJhd0F1ZGlvRGF0YTogRmxvYXQzMkFycmF5KSA9PiB7XG4gICAgY29uc3Qgc3BlZWNoU3RvcFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHNwZWVjaER1cmF0aW9uID0gc3BlZWNoU3RvcFRpbWUgLSBzcGVlY2hTdGFydFRpbWU7XG4gICAgY29uc3QgYXVkaW9CbG9iID0gY29udmVydFRvV2F2QmxvYihyYXdBdWRpb0RhdGEpO1xuICAgIGxvZ2dlci5kZWJ1ZyhgW1NheVBpIFZBRCBPZmZzY3JlZW5dIFNwZWVjaCBlbmRlZC4gRHVyYXRpb246ICR7c3BlZWNoRHVyYXRpb259bXMsIFNpemU6ICR7YXVkaW9CbG9iLnNpemV9IGJ5dGVzYCk7XG4gICAgaWYgKGN1cnJlbnRBY3RpdmVUYWJJZCAhPT0gbnVsbCkge1xuICAgICAgLy8gU2VuZGluZyB0aGUgYmxvYiBkaXJlY3RseSBtaWdodCBiZSB0b28gbGFyZ2UgZm9yIHJ1bnRpbWUuc2VuZE1lc3NhZ2UuXG4gICAgICAvLyBDb25zaWRlciBhbHRlcm5hdGl2ZSBmb3IgbGFyZ2UgZGF0YSBvciBqdXN0IHNlbmQgbm90aWZpY2F0aW9uLlxuICAgICAgLy8gRm9yIG5vdywganVzdCBzZW5kaW5nIHRoZSBldmVudCBhbmQgZHVyYXRpb24uXG4gICAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IFwiVkFEX1NQRUVDSF9FTkRcIixcbiAgICAgICAgZHVyYXRpb246IHNwZWVjaER1cmF0aW9uLFxuICAgICAgICAvLyBibG9iOiBhdWRpb0Jsb2IsIC8vIFBvdGVudGlhbGx5IHRvbyBsYXJnZSwgaGFuZGxlIGFwcHJvcHJpYXRlbHlcbiAgICAgICAgdGFyZ2V0VGFiSWQ6IGN1cnJlbnRBY3RpdmVUYWJJZCxcbiAgICAgICAgb3JpZ2luOiBcIm9mZnNjcmVlbi1kb2N1bWVudFwiLFxuICAgICAgfSk7XG4gICAgICAvLyBUT0RPOiBJZiBibG9iIG5lZWRzIHRvIGJlIHNlbnQsIHVzZSBhIGRpZmZlcmVudCBtZWNoYW5pc20gb3IgY29uZmlybSBzaXplIGxpbWl0cy5cbiAgICB9XG4gIH0sXG4gIG9uVkFETWlzZmlyZTogKCkgPT4ge1xuICAgIGxvZ2dlci5kZWJ1ZyhcIltTYXlQaSBWQUQgT2Zmc2NyZWVuXSBWQUQgbWlzZmlyZS5cIik7XG4gICAgaWYgKGN1cnJlbnRBY3RpdmVUYWJJZCAhPT0gbnVsbCkge1xuICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBcIlZBRF9NSVNGSVJFXCIsXG4gICAgICAgIHRhcmdldFRhYklkOiBjdXJyZW50QWN0aXZlVGFiSWQsXG4gICAgICAgIG9yaWdpbjogXCJvZmZzY3JlZW4tZG9jdW1lbnRcIixcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgb25GcmFtZVByb2Nlc3NlZChwcm9iYWJpbGl0aWVzOiB7IGlzU3BlZWNoOiBudW1iZXI7IG5vdFNwZWVjaDogbnVtYmVyIH0pIHtcbiAgICAvLyBUaGlzIGNhbiBiZSBjaGF0dHksIGVuYWJsZSBmb3IgZGVidWdnaW5nIGlmIG5lY2Vzc2FyeVxuICAgIC8vIGNvbnNvbGUubG9nKFwiW1NheVBpIFZBRCBPZmZzY3JlZW5dIEZyYW1lIHByb2Nlc3NlZDpcIiwgcHJvYmFiaWxpdGllcyk7XG4gICAgaWYgKGN1cnJlbnRBY3RpdmVUYWJJZCAhPT0gbnVsbCkge1xuICAgICAgIGNocm9tZS5ydW50aW1lLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgIHR5cGU6IFwiVkFEX0ZSQU1FX1BST0NFU1NFRFwiLFxuICAgICAgICAgcHJvYmFiaWxpdGllcyxcbiAgICAgICAgIHRhcmdldFRhYklkOiBjdXJyZW50QWN0aXZlVGFiSWQsXG4gICAgICAgICBvcmlnaW46IFwib2Zmc2NyZWVuLWRvY3VtZW50XCIsXG4gICAgICAgfSk7XG4gICAgIH1cbiAgfSxcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIHRyeUluaXRpYWxpemVWQUQoYXR0ZW1wdE5hbWU6IHN0cmluZywgY3VzdG9tT3B0aW9uczogUGFydGlhbDxSZWFsVGltZVZBRE9wdGlvbnM+LCBjdXJyZW50U3RyZWFtOiBNZWRpYVN0cmVhbSk6IFByb21pc2U8TWljVkFEPiB7XG4gIGxvZ2dlci5sb2coYFtTYXlQaSBWQUQgT2Zmc2NyZWVuXSBBdHRlbXB0aW5nIFZBRCBpbml0aWFsaXphdGlvbjogJHthdHRlbXB0TmFtZX1gKTtcbiAgY29uc3QgYmFzZU9wdGlvbnM6IFBhcnRpYWw8UmVhbFRpbWVWQURPcHRpb25zPiA9IHtcbiAgICBvcnRDb25maWc6IChvcnQ6IGFueSkgPT4ge1xuICAgICAgb3J0LmVudi53YXNtLndhc21QYXRocyA9IHtcbiAgICAgICAgJ29ydC13YXNtLndhc20nOiBnZXRFeHRlbnNpb25GaWxlVXJsKCdwdWJsaWMvb3J0LXdhc20ud2FzbScpLFxuICAgICAgICAnb3J0LXdhc20tc2ltZC53YXNtJzogZ2V0RXh0ZW5zaW9uRmlsZVVybCgncHVibGljL29ydC13YXNtLXNpbWQud2FzbScpLFxuICAgICAgICAnb3J0LXdhc20tdGhyZWFkZWQud2FzbSc6IGdldEV4dGVuc2lvbkZpbGVVcmwoJ3B1YmxpYy9vcnQtd2FzbS10aHJlYWRlZC53YXNtJyksXG4gICAgICAgICdvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc20nOiBnZXRFeHRlbnNpb25GaWxlVXJsKCdwdWJsaWMvb3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtJyksXG4gICAgICB9O1xuICAgICAgLy8gQXBwbHkgc2ltZC9udW1UaHJlYWRzIGZyb20gY3VzdG9tT3B0aW9ucyBvciB1c2UgZGVmYXVsdHNcbiAgICAgIG9ydC5lbnYud2FzbS5zaW1kID0gKGN1c3RvbU9wdGlvbnMub3J0Q29uZmlnIGFzIGFueSk/LnNpbWQgPz8gZmFsc2U7XG4gICAgICBvcnQuZW52Lndhc20ubnVtVGhyZWFkcyA9IChjdXN0b21PcHRpb25zLm9ydENvbmZpZyBhcyBhbnkpPy5udW1UaHJlYWRzID8/IDE7XG4gICAgICBsb2dnZXIuZGVidWcoYFtTYXlQaSBWQUQgT2Zmc2NyZWVuXSAke2F0dGVtcHROYW1lfSAtIE9SVCBjb25maWcgYXBwbGllZDpgLCBvcnQuZW52Lndhc20pO1xuICAgIH0sXG4gICAgcG9zaXRpdmVTcGVlY2hUaHJlc2hvbGQ6IGNvbW1vbk1pY1ZBRE9wdGlvbnMucG9zaXRpdmVTcGVlY2hUaHJlc2hvbGQsXG4gICAgbWluU3BlZWNoRnJhbWVzOiBjb21tb25NaWNWQURPcHRpb25zLm1pblNwZWVjaEZyYW1lcyxcbiAgICBwcmVTcGVlY2hQYWRGcmFtZXM6IGNvbW1vbk1pY1ZBRE9wdGlvbnMucHJlU3BlZWNoUGFkRnJhbWVzLFxuICAgIG9uU3BlZWNoU3RhcnQ6IGNvbW1vbk1pY1ZBRE9wdGlvbnMub25TcGVlY2hTdGFydCxcbiAgICBvblNwZWVjaEVuZDogY29tbW9uTWljVkFET3B0aW9ucy5vblNwZWVjaEVuZCxcbiAgICBvblZBRE1pc2ZpcmU6IGNvbW1vbk1pY1ZBRE9wdGlvbnMub25WQURNaXNmaXJlLFxuICAgIG9uRnJhbWVQcm9jZXNzZWQ6IGNvbW1vbk1pY1ZBRE9wdGlvbnMub25GcmFtZVByb2Nlc3NlZCxcbiAgICBzdHJlYW06IGN1cnJlbnRTdHJlYW0sXG4gICAgbW9kZWw6IFwidjVcIixcbiAgICAvL3dvcmtsZXRVUkw6IGdldEV4dGVuc2lvbkZpbGVVcmwoJ3B1YmxpYy92YWQud29ya2xldC5idW5kbGUubWluLmpzJyksIC8vIENvbnNpZGVyIGJyb3dzZXIgZGV0ZWN0aW9uIGZvciAuanMgdnMgLm1pbi5qcyBpZiBuZWVkZWRcbiAgfTtcblxuICAvLyBNZXJnZSBjdXN0b21PcHRpb25zIGRlZXBseSwgZXNwZWNpYWxseSBmb3Igb3J0Q29uZmlnIHBhcnRzIGlmIHByb3ZpZGVkIHNlcGFyYXRlbHlcbiAgY29uc3QgZmluYWxPcHRpb25zID0geyAuLi5iYXNlT3B0aW9ucywgLi4uY3VzdG9tT3B0aW9ucyB9O1xuICBpZiAoY3VzdG9tT3B0aW9ucy5vcnRDb25maWcgJiYgYmFzZU9wdGlvbnMub3J0Q29uZmlnKSB7IC8vIE5lZWQgdG8gbWVyZ2Ugb3J0Q29uZmlnIHByb3BlcnRpZXNcbiAgICBmaW5hbE9wdGlvbnMub3J0Q29uZmlnID0gKG9ydDogYW55KSA9PiB7IFxuICAgICAgICBiYXNlT3B0aW9ucy5vcnRDb25maWchKG9ydCk7IC8vIEFwcGx5IGJhc2Ugd2FzbVBhdGhzIGV0Yy5cbiAgICAgICAgLy8gVGhlbiBsZXQgY3VzdG9tT3B0aW9ucyBvdmVycmlkZSBzcGVjaWZpY3MgbGlrZSBzaW1kL251bVRocmVhZHMgaWYgdGhleSB3ZXJlIG1lYW50IGZvciBvcnRDb25maWcgZGlyZWN0bHlcbiAgICAgICAgY29uc3QgY3VzdG9tT3J0U2ltZCA9IChjdXN0b21PcHRpb25zLm9ydENvbmZpZyBhcyBhbnkpPy5zaW1kO1xuICAgICAgICBjb25zdCBjdXN0b21PcnROdW1UaHJlYWRzID0gKGN1c3RvbU9wdGlvbnMub3J0Q29uZmlnIGFzIGFueSk/Lm51bVRocmVhZHM7XG4gICAgICAgIGlmICh0eXBlb2YgY3VzdG9tT3J0U2ltZCA9PT0gJ2Jvb2xlYW4nKSBvcnQuZW52Lndhc20uc2ltZCA9IGN1c3RvbU9ydFNpbWQ7XG4gICAgICAgIGlmICh0eXBlb2YgY3VzdG9tT3J0TnVtVGhyZWFkcyA9PT0gJ251bWJlcicpIG9ydC5lbnYud2FzbS5udW1UaHJlYWRzID0gY3VzdG9tT3J0TnVtVGhyZWFkcztcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBbU2F5UGkgVkFEIE9mZnNjcmVlbl0gJHthdHRlbXB0TmFtZX0gLSBNZXJnZWQgT1JUIGNvbmZpZyAtIFNJTUQ6ICR7b3J0LmVudi53YXNtLnNpbWR9LCBUaHJlYWRzOiAke29ydC5lbnYud2FzbS5udW1UaHJlYWRzfWApO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoY3VzdG9tT3B0aW9ucy5vcnRDb25maWcpIHtcbiAgICBmaW5hbE9wdGlvbnMub3J0Q29uZmlnID0gY3VzdG9tT3B0aW9ucy5vcnRDb25maWc7XG4gIH1cblxuICBsb2dnZXIuZGVidWcoYFtTYXlQaSBWQUQgT2Zmc2NyZWVuXSAke2F0dGVtcHROYW1lfSAtIEZpbmFsIFZBRCBPcHRpb25zOmAsIGZpbmFsT3B0aW9ucyk7XG4gIHJldHVybiBNaWNWQUQubmV3KGZpbmFsT3B0aW9ucyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemVWQUQob3B0aW9uczogUGFydGlhbDxSZWFsVGltZVZBRE9wdGlvbnM+ID0ge30pIHtcbiAgaWYgKHZhZEluc3RhbmNlKSB7XG4gICAgbG9nZ2VyLmxvZyhcIltTYXlQaSBWQUQgT2Zmc2NyZWVuXSBWQUQgYWxyZWFkeSBpbml0aWFsaXplZC5cIik7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbW9kZTogXCJleGlzdGluZ1wiIH07XG4gIH1cbiAgdHJ5IHtcbiAgICBsb2dnZXIubG9nKFwiW1NheVBpIFZBRCBPZmZzY3JlZW5dIEFjcXVpcmluZyBtaWNyb3Bob25lIHN0cmVhbSBmb3IgVkFEIGluaXRpYWxpemF0aW9uLi4uXCIpO1xuICAgIHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcbiAgICAgIGF1ZGlvOiB7XG4gICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgZWNob0NhbmNlbGxhdGlvbjogdHJ1ZSwgLy8gUmVjb21tZW5kZWQgZm9yIFZBRFxuICAgICAgICBhdXRvR2FpbkNvbnRyb2w6IHRydWUsICAvLyBSZWNvbW1lbmRlZCBmb3IgVkFEXG4gICAgICAgIG5vaXNlU3VwcHJlc3Npb246IHRydWUsIC8vIFJlY29tbWVuZGVkIGZvciBWQURcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsb2dnZXIubG9nKFwiW1NheVBpIFZBRCBPZmZzY3JlZW5dIE1pY3JvcGhvbmUgc3RyZWFtIGFjcXVpcmVkLlwiKTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGxvZ2dlci5yZXBvcnRFcnJvcihlcnJvciwgeyBmdW5jdGlvbjogJ2luaXRpYWxpemVWQUQnLCBzdGVwOiAnZ2V0VXNlck1lZGlhJyB9LCBcIk1pYyBzdHJlYW0gYWNxdWlzaXRpb24gZmFpbGVkXCIpO1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogYE1pYyBzdHJlYW0gZXJyb3I6ICR7ZXJyb3IubWVzc2FnZSB8fCBcIlVua25vd24gZXJyb3JcIn1gLCBtb2RlOiBcImZhaWxlZF9taWNcIiB9O1xuICB9XG5cbiAgbGV0IGxhc3RFcnJvcjogYW55ID0gbnVsbDtcblxuICAvLyBBdHRlbXB0IDE6IE9wdGltaXN0aWMgKFNJTUQsIHNvbWUgdGhyZWFkaW5nKVxuICB0cnkge1xuICAgIGNvbnN0IHRocmVhZHMgPSBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSAmJiBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSA+IDEgPyBNYXRoLm1pbigyLCBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSkgOiAxO1xuICAgIHZhZEluc3RhbmNlID0gYXdhaXQgdHJ5SW5pdGlhbGl6ZVZBRChcIkF0dGVtcHQgMTogU0lNRC9UaHJlYWRlZFwiLCB7IG9ydENvbmZpZzogKG9ydDphbnkpID0+IHsgb3J0LmVudi53YXNtLnNpbWQgPSB0cnVlOyBvcnQuZW52Lndhc20ubnVtVGhyZWFkcyA9IHRocmVhZHM7IH0gfSwgc3RyZWFtISk7XG4gICAgbG9nZ2VyLmxvZyhcIltTYXlQaSBWQUQgT2Zmc2NyZWVuXSBNaWNWQUQgaW5zdGFuY2UgY3JlYXRlZCAoQXR0ZW1wdCAxKS5cIik7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbW9kZTogXCJzaW1kX3RocmVhZGVkXCIgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIud2FybihcIltTYXlQaSBWQUQgT2Zmc2NyZWVuXSBBdHRlbXB0IDEgKFNJTUQvVGhyZWFkZWQpIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgIGxhc3RFcnJvciA9IGVycm9yO1xuICB9XG5cbiAgLy8gQXR0ZW1wdCAyOiBTYWZlIEZhbGxiYWNrIChObyBTSU1ELCBTaW5nbGUgVGhyZWFkIC0gYXMgcGVyIG9yaWdpbmFsIGNvbW1vbk1pY1ZBRE9wdGlvbnMpXG4gIHRyeSB7XG4gICAgdmFkSW5zdGFuY2UgPSBhd2FpdCB0cnlJbml0aWFsaXplVkFEKFwiQXR0ZW1wdCAyOiBObyBTSU1EL1NpbmdsZSBUaHJlYWRcIiwgeyBvcnRDb25maWc6IChvcnQ6YW55KSA9PiB7IG9ydC5lbnYud2FzbS5zaW1kID0gZmFsc2U7IG9ydC5lbnYud2FzbS5udW1UaHJlYWRzID0gMTsgfSB9LCBzdHJlYW0hKTtcbiAgICBsb2dnZXIubG9nKFwiW1NheVBpIFZBRCBPZmZzY3JlZW5dIE1pY1ZBRCBpbnN0YW5jZSBjcmVhdGVkIChBdHRlbXB0IDIpLlwiKTtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtb2RlOiBcIm5vX3NpbWRfc2luZ2xlX3RocmVhZFwiIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nZ2VyLndhcm4oXCJbU2F5UGkgVkFEIE9mZnNjcmVlbl0gQXR0ZW1wdCAyIChObyBTSU1EL1NpbmdsZSBUaHJlYWQpIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgIGxhc3RFcnJvciA9IGVycm9yO1xuICB9XG4gIFxuICAvLyBBdHRlbXB0IDM6IE1pbmltYWwgQ29uZmlnIChObyBTSU1ELCBTaW5nbGUgVGhyZWFkLCBhZGp1c3RlZCBWQUQgcGFyYW1zKVxuICB0cnkge1xuICAgIHZhZEluc3RhbmNlID0gYXdhaXQgdHJ5SW5pdGlhbGl6ZVZBRChcIkF0dGVtcHQgMzogTWluaW1hbCBQYXJhbXNcIiwgeyBcbiAgICAgICAgb3J0Q29uZmlnOiAob3J0OmFueSkgPT4geyBvcnQuZW52Lndhc20uc2ltZCA9IGZhbHNlOyBvcnQuZW52Lndhc20ubnVtVGhyZWFkcyA9IDE7IH0sXG4gICAgICAgIHBvc2l0aXZlU3BlZWNoVGhyZXNob2xkOiAwLjc1LCAvLyBTbGlnaHRseSBtb3JlIGxlbmllbnRcbiAgICAgICAgbWluU3BlZWNoRnJhbWVzOiAyLCAgICAgICAgICAvLyBGZXdlciBmcmFtZXNcbiAgICAgICAgcHJlU3BlZWNoUGFkRnJhbWVzOiA1LCAgICAgICAvLyBMZXNzIHBhZGRpbmdcbiAgICAgfSwgc3RyZWFtISk7XG4gICAgbG9nZ2VyLmxvZyhcIltTYXlQaSBWQUQgT2Zmc2NyZWVuXSBNaWNWQUQgaW5zdGFuY2UgY3JlYXRlZCAoQXR0ZW1wdCAzKS5cIik7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbW9kZTogXCJtaW5pbWFsX3BhcmFtc1wiIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nZ2VyLnJlcG9ydEVycm9yKGVycm9yLCB7IGZ1bmN0aW9uOiAnaW5pdGlhbGl6ZVZBRCcsIHN0ZXA6ICdBdHRlbXB0IDMgTWluaW1hbCBQYXJhbXMnLCBwcmV2aW91c0Vycm9yOiBsYXN0RXJyb3IgfSwgXCJBbGwgVkFEIGluaXQgYXR0ZW1wdHMgZmFpbGVkXCIpO1xuICAgIGlmIChzdHJlYW0pIHsgLy8gQ2xlYW4gdXAgc3RyZWFtIGlmIGFsbCBhdHRlbXB0cyBmYWlsZWRcbiAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgICAgc3RyZWFtID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZmluYWxFcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBmaW5hbEVycm9yTWVzc2FnZSB8fCBcIlVua25vd24gVkFEIGluaXRpYWxpemF0aW9uIGVycm9yIGFmdGVyIGFsbCBmYWxsYmFja3NcIiwgbW9kZTogXCJmYWlsZWRfYWxsXCIgfTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBzdGFydFZBRCh0YWJJZDogbnVtYmVyKSB7XG4gIGN1cnJlbnRBY3RpdmVUYWJJZCA9IHRhYklkO1xuICBpZiAoIXZhZEluc3RhbmNlKSB7XG4gICAgY29uc3QgaW5pdFJlc3VsdCA9IGF3YWl0IGluaXRpYWxpemVWQUQoKTtcbiAgICBpZiAoIWluaXRSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIGluaXRSZXN1bHQ7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgaWYgKHZhZEluc3RhbmNlKSB7XG4gICAgICBsb2dnZXIubG9nKFwiW1NheVBpIFZBRCBPZmZzY3JlZW5dIFN0YXJ0aW5nIFZBRC4uLlwiKTtcbiAgICAgIHZhZEluc3RhbmNlLnN0YXJ0KCk7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJWQUQgaW5zdGFuY2Ugbm90IGF2YWlsYWJsZSBhZnRlciBpbml0IGF0dGVtcHQuXCIgfTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGxvZ2dlci5yZXBvcnRFcnJvcihlcnJvciwgeyBmdW5jdGlvbjogJ3N0YXJ0VkFEJywgdGFiSWQgfSwgXCJFcnJvciBzdGFydGluZyBWQURcIik7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8IFwiVW5rbm93biBWQUQgc3RhcnQgZXJyb3JcIiB9O1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHN0b3BWQUQoKSB7XG4gIGlmICh2YWRJbnN0YW5jZSkge1xuICAgIHRyeSB7XG4gICAgICBsb2dnZXIubG9nKFwiW1NheVBpIFZBRCBPZmZzY3JlZW5dIFN0b3BwaW5nIFZBRC4uLlwiKTtcbiAgICAgIHZhZEluc3RhbmNlLnBhdXNlKCk7IC8vIFVzZSBwYXVzZSwgb3IgZGVzdHJveSBpZiBpdCdzIGEgZnVsbCBzdG9wXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgbG9nZ2VyLnJlcG9ydEVycm9yKGVycm9yLCB7IGZ1bmN0aW9uOiAnc3RvcFZBRCcgfSwgXCJFcnJvciBzdG9wcGluZyBWQURcIik7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgXCJVbmtub3duIFZBRCBzdG9wIGVycm9yXCIgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIlZBRCBub3QgaW5pdGlhbGl6ZWQgb3IgYWxyZWFkeSBzdG9wcGVkLlwiIH07XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lWQUQoKSB7XG4gIGxvZ2dlci5sb2coXCJbU2F5UGkgVkFEIE9mZnNjcmVlbl0gRGVzdHJveWluZyBWQUQuLi5cIik7XG4gIGlmICh2YWRJbnN0YW5jZSkge1xuICAgIHZhZEluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICB2YWRJbnN0YW5jZSA9IG51bGw7XG4gIH1cbiAgaWYgKHN0cmVhbSkge1xuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgc3RyZWFtID0gbnVsbDtcbiAgfVxuICBjdXJyZW50QWN0aXZlVGFiSWQgPSBudWxsO1xuICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG59XG5cbi8vIExpc3RlbiBmb3IgbWVzc2FnZXMgZnJvbSB0aGUgYmFja2dyb3VuZCBzY3JpcHRcbmNocm9tZS5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcigobWVzc2FnZSwgc2VuZGVyLCBzZW5kUmVzcG9uc2UpID0+IHtcbiAgLy8gRW5zdXJlIG1lc3NhZ2VzIGFyZSBmcm9tIHRoZSBiYWNrZ3JvdW5kIHNjcmlwdCBvciBhbiBleHBlY3RlZCBpbnRlcm5hbCBzb3VyY2UgaWYgYW55XG4gIC8vIHNlbmRlci5pZCBpcyB0aGUgZXh0ZW5zaW9uIElELiBGb3IgbWVzc2FnZXMgZnJvbSBiYWNrZ3JvdW5kLCBzZW5kZXIudXJsIG1pZ2h0IGJlIHVuZGVmaW5lZCBvciBiYWNrZ3JvdW5kIHNjcmlwdCBVUkxcbiAgLy8gV2UgYXJlIGV4cGVjdGluZyBtZXNzYWdlcyBmb3J3YXJkZWQgYnkgYmFja2dyb3VuZC5qcyB3aGljaCB3aWxsIGhhdmUgYG1lc3NhZ2Uub3JpZ2luID09PSAnY29udGVudC1zY3JpcHQnYFxuICAvLyBhbmQgYG1lc3NhZ2Uuc291cmNlVGFiSWRgXG4gIGlmIChtZXNzYWdlLm9yaWdpbiAhPT0gXCJjb250ZW50LXNjcmlwdFwiIHx8IG1lc3NhZ2Uuc291cmNlVGFiSWQgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGNvbnNvbGUuZGVidWcoXCJbU2F5UGkgVkFEIE9mZnNjcmVlbl0gSWdub3JpbmcgbWVzc2FnZSBub3QgZnJvbSBjb250ZW50IHNjcmlwdCB2aWEgYmFja2dyb3VuZDpcIiwgbWVzc2FnZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbG9nZ2VyLmRlYnVnKFwiW1NheVBpIFZBRCBPZmZzY3JlZW5dIFJlY2VpdmVkIG1lc3NhZ2UgZnJvbSBiYWNrZ3JvdW5kOlwiLCBtZXNzYWdlKTtcbiAgY29uc3QgeyB0eXBlLCBvcHRpb25zLCBzb3VyY2VUYWJJZCB9ID0gbWVzc2FnZTsgLy8gYHNvdXJjZVRhYklkYCBpcyB0aGUgb3JpZ2luYWwgdGFiSWQgZnJvbSBjb250ZW50IHNjcmlwdFxuICBsZXQgcHJvbWlzZTogUHJvbWlzZTxhbnk+IHwgbnVsbCA9IG51bGw7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcIlZBRF9JTklUSUFMSVpFX1JFUVVFU1RcIjpcbiAgICAgIHByb21pc2UgPSBpbml0aWFsaXplVkFEKG9wdGlvbnMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlZBRF9TVEFSVF9SRVFVRVNUXCI6XG4gICAgICBwcm9taXNlID0gc3RhcnRWQUQoc291cmNlVGFiSWQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlZBRF9TVE9QX1JFUVVFU1RcIjpcbiAgICAgIHByb21pc2UgPSBzdG9wVkFEKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiVkFEX0RFU1RST1lfUkVRVUVTVFwiOlxuICAgICAgLy8gTm8gYXN5bmMgb3BlcmF0aW9uIGhlcmUsIGp1c3QgYSBkaXJlY3QgY2FsbFxuICAgICAgc2VuZFJlc3BvbnNlKGRlc3Ryb3lWQUQoKSk7IFxuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBJbmRpY2F0ZSBzeW5jaHJvbm91cyByZXNwb25zZSBmb3IgdGhpcyBzcGVjaWZpYyBjYXNlIGlmIHNlbmRSZXNwb25zZSBpcyB1c2VkIGRpcmVjdGx5XG4gICAgZGVmYXVsdDpcbiAgICAgIGxvZ2dlci53YXJuKFwiW1NheVBpIFZBRCBPZmZzY3JlZW5dIFVua25vd24gbWVzc2FnZSB0eXBlIHJlY2VpdmVkOlwiLCB0eXBlKTtcbiAgICAgIHNlbmRSZXNwb25zZSh7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJVbmtub3duIG1lc3NhZ2UgdHlwZVwiIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHByb21pc2UpIHtcbiAgICBwcm9taXNlLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgLy8gU2VuZCByZXNwb25zZSBiYWNrIHRvIHRoZSBvcmlnaW5hdGluZyBjb250ZW50IHNjcmlwdCB2aWEgYmFja2dyb3VuZFxuICAgICAgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiBgT0ZGU0NSRUVOXyR7dHlwZX1fUkVTUE9OU0VgLFxuICAgICAgICBwYXlsb2FkOiByZXNwb25zZSxcbiAgICAgICAgdGFyZ2V0VGFiSWQ6IHNvdXJjZVRhYklkLCAvLyBlbnN1cmUgdGhpcyBpcyB0aGUgb3JpZ2luYWwgdGFiSWRcbiAgICAgICAgb3JpZ2luOiBcIm9mZnNjcmVlbi1kb2N1bWVudFwiLFxuICAgICAgfSk7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgbG9nZ2VyLnJlcG9ydEVycm9yKGVycm9yLCB7IGZ1bmN0aW9uOiAnb25NZXNzYWdlIExpc3RlbmVyJywgbWVzc2FnZVR5cGU6IHR5cGUsIHRhYklkOiBzb3VyY2VUYWJJZCB9LCBcIkVycm9yIHByb2Nlc3NpbmcgVkFEIHJlcXVlc3RcIik7XG4gICAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IGBPRkZTQ1JFRU5fJHt0eXBlfV9FUlJPUmAsXG4gICAgICAgIHBheWxvYWQ6IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8IFwiVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uXCIgfSxcbiAgICAgICAgdGFyZ2V0VGFiSWQ6IHNvdXJjZVRhYklkLFxuICAgICAgICBvcmlnaW46IFwib2Zmc2NyZWVuLWRvY3VtZW50XCIsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTsgLy8gSW5kaWNhdGUgdGhhdCBzZW5kUmVzcG9uc2Ugd2lsbCBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHlcbiAgfVxuICByZXR1cm4gZmFsc2U7IC8vIERlZmF1bHQgdG8gc3luY2hyb25vdXMgaWYgbm8gcHJvbWlzZSB3YXMgaGFuZGxlZFxufSk7ICJdLCJuYW1lcyI6WyJzZXJpYWxpemVTdGF0ZVZhbHVlIiwic3RhdGVWYWx1ZSIsIl90eXBlb2YiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwia2V5IiwibmVzdGVkVmFsdWUiLCJjb25jYXQiLCJqb2luIiwiU3RyaW5nIiwiTG9nZ2VyIiwicHJlZml4IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiX2NsYXNzQ2FsbENoZWNrIiwiZGVidWdNb2RlIiwiX2NyZWF0ZUNsYXNzIiwidmFsdWUiLCJzZXREZWJ1Z01vZGUiLCJlbmFibGVkIiwiX2Zvcm1hdEFyZ3MiLCJhcmdzIiwiYXJnIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwibG9nIiwiX2NvbnNvbGUiLCJfbGVuIiwiQXJyYXkiLCJfa2V5IiwiY29uc29sZSIsImFwcGx5IiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiZGVidWciLCJfY29uc29sZTIiLCJfbGVuMiIsIl9rZXkyIiwiaW5mbyIsIl9jb25zb2xlMyIsIl9sZW4zIiwiX2tleTMiLCJ3YXJuIiwiX2NvbnNvbGU0IiwiX2xlbjQiLCJfa2V5NCIsImVycm9yIiwiX2NvbnNvbGU1IiwiX2xlbjUiLCJfa2V5NSIsImdyb3VwIiwibGFiZWwiLCJncm91cEVuZCIsInJlcG9ydEVycm9yIiwiY29udGV4dCIsImFkZGl0aW9uYWxNZXNzYWdlIiwiZXJyb3JNZXNzYWdlIiwibWVzc2FnZSIsImVycm9ySW5mbyIsInN0YWNrIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY2hyb21lIiwicnVudGltZSIsInNlbmRNZXNzYWdlIiwidHlwZSIsIm9yaWdpbiIsImUiLCJsb2dnZXIiXSwic291cmNlUm9vdCI6IiJ9