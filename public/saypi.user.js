// ==UserScript==
// @name         Say, Pi
// @name:zh-CN   说，Pi 
// @namespace    http://www.saypi.ai/
// @version      1.4.9
// @description  Seamless speech-to-text enhancement for Pi, the conversational AI. Enjoy hands-free, high-accuracy conversations in any language.
// @description:zh-CN  为Pi聊天机器人提供无手操作的高精度语音转文字功能，支持多种语言。
// @author       Ross Cadogan
// @match        https://pi.ai/talk
// @inject-into  page
// @updateURL    https://app.saypi.ai/saypi.user.js
// @downloadURL  https://app.saypi.ai/saypi.user.js
// @license      MIT
// ==/UserScript==

/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@ricky0123/vad-web/dist/_common/frame-processor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/_common/frame-processor.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
Some of this code, together with the default options found in index.ts,
were taken (or took inspiration) from https://github.com/snakers4/silero-vad
*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FrameProcessor = exports.validateOptions = exports.defaultFrameProcessorOptions = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/@ricky0123/vad-web/dist/_common/messages.js");
const logging_1 = __webpack_require__(/*! ./logging */ "./node_modules/@ricky0123/vad-web/dist/_common/logging.js");
const RECOMMENDED_FRAME_SAMPLES = [512, 1024, 1536];
exports.defaultFrameProcessorOptions = {
    positiveSpeechThreshold: 0.5,
    negativeSpeechThreshold: 0.5 - 0.15,
    preSpeechPadFrames: 1,
    redemptionFrames: 8,
    frameSamples: 1536,
    minSpeechFrames: 3,
};
function validateOptions(options) {
    if (!RECOMMENDED_FRAME_SAMPLES.includes(options.frameSamples)) {
        logging_1.log.warn("You are using an unusual frame size");
    }
    if (options.positiveSpeechThreshold < 0 ||
        options.negativeSpeechThreshold > 1) {
        logging_1.log.error("postiveSpeechThreshold should be a number between 0 and 1");
    }
    if (options.negativeSpeechThreshold < 0 ||
        options.negativeSpeechThreshold > options.positiveSpeechThreshold) {
        logging_1.log.error("negativeSpeechThreshold should be between 0 and postiveSpeechThreshold");
    }
    if (options.preSpeechPadFrames < 0) {
        logging_1.log.error("preSpeechPadFrames should be positive");
    }
    if (options.redemptionFrames < 0) {
        logging_1.log.error("preSpeechPadFrames should be positive");
    }
}
exports.validateOptions = validateOptions;
const concatArrays = (arrays) => {
    const sizes = arrays.reduce((out, next) => {
        out.push(out.at(-1) + next.length);
        return out;
    }, [0]);
    const outArray = new Float32Array(sizes.at(-1));
    arrays.forEach((arr, index) => {
        const place = sizes[index];
        outArray.set(arr, place);
    });
    return outArray;
};
class FrameProcessor {
    constructor(modelProcessFunc, modelResetFunc, options) {
        this.modelProcessFunc = modelProcessFunc;
        this.modelResetFunc = modelResetFunc;
        this.options = options;
        this.speaking = false;
        this.redemptionCounter = 0;
        this.active = false;
        this.reset = () => {
            this.speaking = false;
            this.audioBuffer = [];
            this.modelResetFunc();
            this.redemptionCounter = 0;
        };
        this.pause = () => {
            this.active = false;
            this.reset();
        };
        this.resume = () => {
            this.active = true;
        };
        this.endSegment = () => {
            const audioBuffer = this.audioBuffer;
            this.audioBuffer = [];
            const speaking = this.speaking;
            this.reset();
            const speechFrameCount = audioBuffer.reduce((acc, item) => {
                return acc + +item.isSpeech;
            }, 0);
            if (speaking) {
                if (speechFrameCount >= this.options.minSpeechFrames) {
                    const audio = concatArrays(audioBuffer.map((item) => item.frame));
                    return { msg: messages_1.Message.SpeechEnd, audio };
                }
                else {
                    return { msg: messages_1.Message.VADMisfire };
                }
            }
            return {};
        };
        this.process = async (frame) => {
            if (!this.active) {
                return {};
            }
            const probs = await this.modelProcessFunc(frame);
            this.audioBuffer.push({
                frame,
                isSpeech: probs.isSpeech >= this.options.positiveSpeechThreshold,
            });
            if (probs.isSpeech >= this.options.positiveSpeechThreshold &&
                this.redemptionCounter) {
                this.redemptionCounter = 0;
            }
            if (probs.isSpeech >= this.options.positiveSpeechThreshold &&
                !this.speaking) {
                this.speaking = true;
                return { probs, msg: messages_1.Message.SpeechStart };
            }
            if (probs.isSpeech < this.options.negativeSpeechThreshold &&
                this.speaking &&
                ++this.redemptionCounter >= this.options.redemptionFrames) {
                this.redemptionCounter = 0;
                this.speaking = false;
                const audioBuffer = this.audioBuffer;
                this.audioBuffer = [];
                const speechFrameCount = audioBuffer.reduce((acc, item) => {
                    return acc + +item.isSpeech;
                }, 0);
                if (speechFrameCount >= this.options.minSpeechFrames) {
                    const audio = concatArrays(audioBuffer.map((item) => item.frame));
                    return { probs, msg: messages_1.Message.SpeechEnd, audio };
                }
                else {
                    return { probs, msg: messages_1.Message.VADMisfire };
                }
            }
            if (!this.speaking) {
                while (this.audioBuffer.length > this.options.preSpeechPadFrames) {
                    this.audioBuffer.shift();
                }
            }
            return { probs };
        };
        this.audioBuffer = [];
        this.reset();
    }
}
exports.FrameProcessor = FrameProcessor;
//# sourceMappingURL=frame-processor.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/_common/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/_common/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.utils = void 0;
const _utils = __importStar(__webpack_require__(/*! ./utils */ "./node_modules/@ricky0123/vad-web/dist/_common/utils.js"));
exports.utils = {
    minFramesForTargetMS: _utils.minFramesForTargetMS,
    arrayBufferToBase64: _utils.arrayBufferToBase64,
    encodeWAV: _utils.encodeWAV,
};
__exportStar(__webpack_require__(/*! ./non-real-time-vad */ "./node_modules/@ricky0123/vad-web/dist/_common/non-real-time-vad.js"), exports);
__exportStar(__webpack_require__(/*! ./frame-processor */ "./node_modules/@ricky0123/vad-web/dist/_common/frame-processor.js"), exports);
__exportStar(__webpack_require__(/*! ./messages */ "./node_modules/@ricky0123/vad-web/dist/_common/messages.js"), exports);
__exportStar(__webpack_require__(/*! ./logging */ "./node_modules/@ricky0123/vad-web/dist/_common/logging.js"), exports);
__exportStar(__webpack_require__(/*! ./models */ "./node_modules/@ricky0123/vad-web/dist/_common/models.js"), exports);
__exportStar(__webpack_require__(/*! ./resampler */ "./node_modules/@ricky0123/vad-web/dist/_common/resampler.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/_common/logging.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/_common/logging.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.log = exports.LOG_PREFIX = void 0;
exports.LOG_PREFIX = "[VAD]";
const levels = ["error", "debug", "warn"];
function getLog(level) {
    return (...args) => {
        console[level](exports.LOG_PREFIX, ...args);
    };
}
const _log = levels.reduce((acc, level) => {
    acc[level] = getLog(level);
    return acc;
}, {});
exports.log = _log;
//# sourceMappingURL=logging.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/_common/messages.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/_common/messages.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Message = void 0;
var Message;
(function (Message) {
    Message["AudioFrame"] = "AUDIO_FRAME";
    Message["SpeechStart"] = "SPEECH_START";
    Message["VADMisfire"] = "VAD_MISFIRE";
    Message["SpeechEnd"] = "SPEECH_END";
})(Message = exports.Message || (exports.Message = {}));
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/_common/models.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/_common/models.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Silero = void 0;
// @ts-ignore
const logging_1 = __webpack_require__(/*! ./logging */ "./node_modules/@ricky0123/vad-web/dist/_common/logging.js");
class Silero {
    constructor(ort, modelFetcher) {
        this.ort = ort;
        this.modelFetcher = modelFetcher;
        this.init = async () => {
            logging_1.log.debug("initializing vad");
            const modelArrayBuffer = await this.modelFetcher();
            this._session = await this.ort.InferenceSession.create(modelArrayBuffer);
            this._sr = new this.ort.Tensor("int64", [16000n]);
            this.reset_state();
            logging_1.log.debug("vad is initialized");
        };
        this.reset_state = () => {
            const zeroes = Array(2 * 64).fill(0);
            this._h = new this.ort.Tensor("float32", zeroes, [2, 1, 64]);
            this._c = new this.ort.Tensor("float32", zeroes, [2, 1, 64]);
        };
        this.process = async (audioFrame) => {
            const t = new this.ort.Tensor("float32", audioFrame, [1, audioFrame.length]);
            const inputs = {
                input: t,
                h: this._h,
                c: this._c,
                sr: this._sr,
            };
            const out = await this._session.run(inputs);
            this._h = out.hn;
            this._c = out.cn;
            const [isSpeech] = out.output.data;
            const notSpeech = 1 - isSpeech;
            return { notSpeech, isSpeech };
        };
    }
}
exports.Silero = Silero;
_a = Silero;
Silero.new = async (ort, modelFetcher) => {
    const model = new Silero(ort, modelFetcher);
    await model.init();
    return model;
};
//# sourceMappingURL=models.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/_common/non-real-time-vad.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/_common/non-real-time-vad.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlatformAgnosticNonRealTimeVAD = exports.defaultNonRealTimeVADOptions = void 0;
const frame_processor_1 = __webpack_require__(/*! ./frame-processor */ "./node_modules/@ricky0123/vad-web/dist/_common/frame-processor.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/@ricky0123/vad-web/dist/_common/messages.js");
const models_1 = __webpack_require__(/*! ./models */ "./node_modules/@ricky0123/vad-web/dist/_common/models.js");
const resampler_1 = __webpack_require__(/*! ./resampler */ "./node_modules/@ricky0123/vad-web/dist/_common/resampler.js");
exports.defaultNonRealTimeVADOptions = {
    ...frame_processor_1.defaultFrameProcessorOptions,
};
class PlatformAgnosticNonRealTimeVAD {
    static async _new(modelFetcher, ort, options = {}) {
        const vad = new this(modelFetcher, ort, {
            ...exports.defaultNonRealTimeVADOptions,
            ...options,
        });
        await vad.init();
        return vad;
    }
    constructor(modelFetcher, ort, options) {
        this.modelFetcher = modelFetcher;
        this.ort = ort;
        this.options = options;
        this.init = async () => {
            const model = await models_1.Silero.new(this.ort, this.modelFetcher);
            this.frameProcessor = new frame_processor_1.FrameProcessor(model.process, model.reset_state, {
                frameSamples: this.options.frameSamples,
                positiveSpeechThreshold: this.options.positiveSpeechThreshold,
                negativeSpeechThreshold: this.options.negativeSpeechThreshold,
                redemptionFrames: this.options.redemptionFrames,
                preSpeechPadFrames: this.options.preSpeechPadFrames,
                minSpeechFrames: this.options.minSpeechFrames,
            });
            this.frameProcessor.resume();
        };
        this.run = async function* (inputAudio, sampleRate) {
            const resamplerOptions = {
                nativeSampleRate: sampleRate,
                targetSampleRate: 16000,
                targetFrameSize: this.options.frameSamples,
            };
            const resampler = new resampler_1.Resampler(resamplerOptions);
            const frames = resampler.process(inputAudio);
            let start, end;
            for (const i of [...Array(frames.length)].keys()) {
                const f = frames[i];
                const { msg, audio } = await this.frameProcessor.process(f);
                switch (msg) {
                    case messages_1.Message.SpeechStart:
                        start = (i * this.options.frameSamples) / 16;
                        break;
                    case messages_1.Message.SpeechEnd:
                        end = ((i + 1) * this.options.frameSamples) / 16;
                        // @ts-ignore
                        yield { audio, start, end };
                        break;
                    default:
                        break;
                }
            }
            const { msg, audio } = this.frameProcessor.endSegment();
            if (msg == messages_1.Message.SpeechEnd) {
                yield {
                    audio,
                    // @ts-ignore
                    start,
                    end: (frames.length * this.options.frameSamples) / 16,
                };
            }
        };
        (0, frame_processor_1.validateOptions)(options);
    }
}
exports.PlatformAgnosticNonRealTimeVAD = PlatformAgnosticNonRealTimeVAD;
//# sourceMappingURL=non-real-time-vad.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/_common/resampler.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/_common/resampler.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Resampler = void 0;
const logging_1 = __webpack_require__(/*! ./logging */ "./node_modules/@ricky0123/vad-web/dist/_common/logging.js");
class Resampler {
    constructor(options) {
        this.options = options;
        this.process = (audioFrame) => {
            const outputFrames = [];
            for (const sample of audioFrame) {
                this.inputBuffer.push(sample);
            }
            while ((this.inputBuffer.length * this.options.targetSampleRate) /
                this.options.nativeSampleRate >
                this.options.targetFrameSize) {
                const outputFrame = new Float32Array(this.options.targetFrameSize);
                let outputIndex = 0;
                let inputIndex = 0;
                while (outputIndex < this.options.targetFrameSize) {
                    let sum = 0;
                    let num = 0;
                    while (inputIndex <
                        Math.min(this.inputBuffer.length, ((outputIndex + 1) * this.options.nativeSampleRate) /
                            this.options.targetSampleRate)) {
                        sum += this.inputBuffer[inputIndex];
                        num++;
                        inputIndex++;
                    }
                    outputFrame[outputIndex] = sum / num;
                    outputIndex++;
                }
                this.inputBuffer = this.inputBuffer.slice(inputIndex);
                outputFrames.push(outputFrame);
            }
            return outputFrames;
        };
        if (options.nativeSampleRate < 16000) {
            logging_1.log.error("nativeSampleRate is too low. Should have 16000 = targetSampleRate <= nativeSampleRate");
        }
        this.inputBuffer = [];
    }
}
exports.Resampler = Resampler;
//# sourceMappingURL=resampler.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/_common/utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/_common/utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeWAV = exports.arrayBufferToBase64 = exports.minFramesForTargetMS = void 0;
function minFramesForTargetMS(targetDuration, frameSamples, sr = 16000) {
    return Math.ceil((targetDuration * sr) / 1000 / frameSamples);
}
exports.minFramesForTargetMS = minFramesForTargetMS;
function arrayBufferToBase64(buffer) {
    var binary = "";
    var bytes = new Uint8Array(buffer);
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}
exports.arrayBufferToBase64 = arrayBufferToBase64;
/*
This rest of this was mostly copied from https://github.com/linto-ai/WebVoiceSDK
*/
function encodeWAV(samples, format = 3, sampleRate = 16000, numChannels = 1, bitDepth = 32) {
    var bytesPerSample = bitDepth / 8;
    var blockAlign = numChannels * bytesPerSample;
    var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
    var view = new DataView(buffer);
    /* RIFF identifier */
    writeString(view, 0, "RIFF");
    /* RIFF chunk length */
    view.setUint32(4, 36 + samples.length * bytesPerSample, true);
    /* RIFF type */
    writeString(view, 8, "WAVE");
    /* format chunk identifier */
    writeString(view, 12, "fmt ");
    /* format chunk length */
    view.setUint32(16, 16, true);
    /* sample format (raw) */
    view.setUint16(20, format, true);
    /* channel count */
    view.setUint16(22, numChannels, true);
    /* sample rate */
    view.setUint32(24, sampleRate, true);
    /* byte rate (sample rate * block align) */
    view.setUint32(28, sampleRate * blockAlign, true);
    /* block align (channel count * bytes per sample) */
    view.setUint16(32, blockAlign, true);
    /* bits per sample */
    view.setUint16(34, bitDepth, true);
    /* data chunk identifier */
    writeString(view, 36, "data");
    /* data chunk length */
    view.setUint32(40, samples.length * bytesPerSample, true);
    if (format === 1) {
        // Raw PCM
        floatTo16BitPCM(view, 44, samples);
    }
    else {
        writeFloat32(view, 44, samples);
    }
    return buffer;
}
exports.encodeWAV = encodeWAV;
function interleave(inputL, inputR) {
    var length = inputL.length + inputR.length;
    var result = new Float32Array(length);
    var index = 0;
    var inputIndex = 0;
    while (index < length) {
        result[index++] = inputL[inputIndex];
        result[index++] = inputR[inputIndex];
        inputIndex++;
    }
    return result;
}
function writeFloat32(output, offset, input) {
    for (var i = 0; i < input.length; i++, offset += 4) {
        output.setFloat32(offset, input[i], true);
    }
}
function floatTo16BitPCM(output, offset, input) {
    for (var i = 0; i < input.length; i++, offset += 2) {
        var s = Math.max(-1, Math.min(1, input[i]));
        output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
    }
}
function writeString(view, offset, string) {
    for (var i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/asset-path.js":
/*!************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/asset-path.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assetPath = void 0;
const currentScript = window.document.currentScript;
let basePath = "";
if (currentScript) {
    basePath = currentScript.src
        .replace(/#.*$/, "")
        .replace(/\?.*$/, "")
        .replace(/\/[^\/]+$/, "/");
}
const assetPath = (file) => {
    return basePath + file;
};
exports.assetPath = assetPath;
//# sourceMappingURL=asset-path.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultRealTimeVADOptions = exports.AudioNodeVAD = exports.MicVAD = exports.NonRealTimeVAD = exports.Message = exports.FrameProcessor = exports.utils = void 0;
const ort = __importStar(__webpack_require__(/*! onnxruntime-web */ "./node_modules/onnxruntime-web/dist/ort.min.js"));
const _common_1 = __webpack_require__(/*! ./_common */ "./node_modules/@ricky0123/vad-web/dist/_common/index.js");
Object.defineProperty(exports, "FrameProcessor", ({ enumerable: true, get: function () { return _common_1.FrameProcessor; } }));
Object.defineProperty(exports, "Message", ({ enumerable: true, get: function () { return _common_1.Message; } }));
const model_fetcher_1 = __webpack_require__(/*! ./model-fetcher */ "./node_modules/@ricky0123/vad-web/dist/model-fetcher.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@ricky0123/vad-web/dist/utils.js");
class NonRealTimeVAD extends _common_1.PlatformAgnosticNonRealTimeVAD {
    static async new(options = {}) {
        return await this._new(model_fetcher_1.modelFetcher, ort, options);
    }
}
exports.NonRealTimeVAD = NonRealTimeVAD;
exports.utils = { audioFileToArray: utils_1.audioFileToArray, ..._common_1.utils };
var real_time_vad_1 = __webpack_require__(/*! ./real-time-vad */ "./node_modules/@ricky0123/vad-web/dist/real-time-vad.js");
Object.defineProperty(exports, "MicVAD", ({ enumerable: true, get: function () { return real_time_vad_1.MicVAD; } }));
Object.defineProperty(exports, "AudioNodeVAD", ({ enumerable: true, get: function () { return real_time_vad_1.AudioNodeVAD; } }));
Object.defineProperty(exports, "defaultRealTimeVADOptions", ({ enumerable: true, get: function () { return real_time_vad_1.defaultRealTimeVADOptions; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/model-fetcher.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/model-fetcher.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.modelFetcher = void 0;
const asset_path_1 = __webpack_require__(/*! ./asset-path */ "./node_modules/@ricky0123/vad-web/dist/asset-path.js");
const modelFetcher = async () => {
    const modelURL = (0, asset_path_1.assetPath)("silero_vad.onnx");
    return await fetch(modelURL).then((r) => r.arrayBuffer());
};
exports.modelFetcher = modelFetcher;
//# sourceMappingURL=model-fetcher.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/real-time-vad.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/real-time-vad.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AudioNodeVAD = exports.MicVAD = exports.defaultRealTimeVADOptions = void 0;
const ort = __importStar(__webpack_require__(/*! onnxruntime-web */ "./node_modules/onnxruntime-web/dist/ort.min.js"));
const _common_1 = __webpack_require__(/*! ./_common */ "./node_modules/@ricky0123/vad-web/dist/_common/index.js");
const model_fetcher_1 = __webpack_require__(/*! ./model-fetcher */ "./node_modules/@ricky0123/vad-web/dist/model-fetcher.js");
const asset_path_1 = __webpack_require__(/*! ./asset-path */ "./node_modules/@ricky0123/vad-web/dist/asset-path.js");
const _getWorkletURL = () => {
    return (0, asset_path_1.assetPath)("vad.worklet.bundle.min.js");
};
exports.defaultRealTimeVADOptions = {
    ..._common_1.defaultFrameProcessorOptions,
    onFrameProcessed: (probabilities) => { },
    onVADMisfire: () => {
        _common_1.log.debug("VAD misfire");
    },
    onSpeechStart: () => {
        _common_1.log.debug("Detected speech start");
    },
    onSpeechEnd: () => {
        _common_1.log.debug("Detected speech end");
    },
    workletURL: _getWorkletURL(),
    stream: undefined,
};
class MicVAD {
    static async new(options = {}) {
        const vad = new MicVAD({ ...exports.defaultRealTimeVADOptions, ...options });
        await vad.init();
        return vad;
    }
    constructor(options) {
        this.options = options;
        this.listening = false;
        this.init = async () => {
            if (this.options.stream === undefined)
                this.stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        ...this.options.additionalAudioConstraints,
                        channelCount: 1,
                        echoCancellation: true,
                        autoGainControl: true,
                        noiseSuppression: true,
                    },
                });
            else
                this.stream = this.options.stream;
            this.audioContext = new AudioContext();
            const source = new MediaStreamAudioSourceNode(this.audioContext, {
                mediaStream: this.stream,
            });
            this.audioNodeVAD = await AudioNodeVAD.new(this.audioContext, this.options);
            this.audioNodeVAD.receive(source);
        };
        this.pause = () => {
            this.audioNodeVAD.pause();
            this.listening = false;
        };
        this.start = () => {
            this.audioNodeVAD.start();
            this.listening = true;
        };
        (0, _common_1.validateOptions)(options);
    }
}
exports.MicVAD = MicVAD;
class AudioNodeVAD {
    static async new(ctx, options = {}) {
        const vad = new AudioNodeVAD(ctx, {
            ...exports.defaultRealTimeVADOptions,
            ...options,
        });
        await vad.init();
        return vad;
    }
    constructor(ctx, options) {
        this.ctx = ctx;
        this.options = options;
        this.pause = () => {
            this.frameProcessor.pause();
        };
        this.start = () => {
            this.frameProcessor.resume();
        };
        this.receive = (node) => {
            node.connect(this.entryNode);
        };
        this.processFrame = async (frame) => {
            const { probs, msg, audio } = await this.frameProcessor.process(frame);
            if (probs !== undefined) {
                this.options.onFrameProcessed(probs);
            }
            switch (msg) {
                case _common_1.Message.SpeechStart:
                    this.options.onSpeechStart();
                    break;
                case _common_1.Message.VADMisfire:
                    this.options.onVADMisfire();
                    break;
                case _common_1.Message.SpeechEnd:
                    // @ts-ignore
                    this.options.onSpeechEnd(audio);
                    break;
                default:
                    break;
            }
        };
        this.init = async () => {
            await this.ctx.audioWorklet.addModule(this.options.workletURL);
            const vadNode = new AudioWorkletNode(this.ctx, "vad-helper-worklet", {
                processorOptions: {
                    frameSamples: this.options.frameSamples,
                },
            });
            this.entryNode = vadNode;
            const model = await _common_1.Silero.new(ort, model_fetcher_1.modelFetcher);
            this.frameProcessor = new _common_1.FrameProcessor(model.process, model.reset_state, {
                frameSamples: this.options.frameSamples,
                positiveSpeechThreshold: this.options.positiveSpeechThreshold,
                negativeSpeechThreshold: this.options.negativeSpeechThreshold,
                redemptionFrames: this.options.redemptionFrames,
                preSpeechPadFrames: this.options.preSpeechPadFrames,
                minSpeechFrames: this.options.minSpeechFrames,
            });
            vadNode.port.onmessage = async (ev) => {
                switch (ev.data?.message) {
                    case _common_1.Message.AudioFrame:
                        const buffer = ev.data.data;
                        const frame = new Float32Array(buffer);
                        await this.processFrame(frame);
                        break;
                    default:
                        break;
                }
            };
        };
        (0, _common_1.validateOptions)(options);
    }
}
exports.AudioNodeVAD = AudioNodeVAD;
//# sourceMappingURL=real-time-vad.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.audioFileToArray = void 0;
async function audioFileToArray(audioFileData) {
    const ctx = new OfflineAudioContext(1, 1, 44100);
    const reader = new FileReader();
    let audioBuffer = null;
    await new Promise((res) => {
        reader.addEventListener("loadend", (ev) => {
            const audioData = reader.result;
            ctx.decodeAudioData(audioData, (buffer) => {
                audioBuffer = buffer;
                ctx
                    .startRendering()
                    .then((renderedBuffer) => {
                    console.log("Rendering completed successfully");
                    res();
                })
                    .catch((err) => {
                    console.error(`Rendering failed: ${err}`);
                });
            }, (e) => {
                console.log(`Error with decoding audio data: ${e}`);
            });
        });
        reader.readAsArrayBuffer(audioFileData);
    });
    if (audioBuffer === null) {
        throw Error("some shit");
    }
    let _audioBuffer = audioBuffer;
    let out = new Float32Array(_audioBuffer.length);
    for (let i = 0; i < _audioBuffer.length; i++) {
        for (let j = 0; j < _audioBuffer.numberOfChannels; j++) {
            // @ts-ignore
            out[i] += _audioBuffer.getChannelData(j)[i];
        }
    }
    return { audio: out, sampleRate: _audioBuffer.sampleRate };
}
exports.audioFileToArray = audioFileToArray;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles/rectangles.css":
/*!*************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles/rectangles.css ***!
  \*************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `@keyframes pulse_outermost {
  0%,
  100% {
    transform: scale(1);
  }
  50% {
    transform: scale(0.92);
  }
}
.outermost {
  animation: pulse_outermost 5s infinite;
  transform-origin: center;
}

@keyframes pulse_second {
  0%,
  100% {
    transform: scale(1);
  }
  50% {
    transform: scale(0.856);
  }
}
.second {
  animation: pulse_second 5s infinite;
  transform-origin: center;
}

@keyframes pulse_third {
  0%,
  100% {
    transform: scale(1);
  }
  50% {
    transform: scale(0.792);
  }
}
.third {
  animation: pulse_third 5s infinite;
  transform-origin: center;
}

@keyframes pulse_fourth {
  0%,
  100% {
    transform: scale(1);
  }
  50% {
    transform: scale(0.728);
  }
}
.fourth {
  animation: pulse_fourth 5s infinite;
  transform-origin: center;
}

@keyframes pulse_fifth {
  0%,
  100% {
    transform: scale(1);
  }
  50% {
    transform: scale(0.664);
  }
}
.fifth {
  animation: pulse_fifth 5s infinite;
  transform-origin: center;
}

@keyframes pulse_innermost {
  0%,
  100% {
    transform: scale(1);
  }
  50% {
    transform: scale(0.6);
  }
}
.innermost {
  animation: pulse_innermost 5s infinite;
  transform-origin: center;
}

/* playful animation to indicate Pi is speaking */
@keyframes speaking_outermost {
  0%,
  100% {
    transform: scale(1) rotate(0deg);
  }
  25% {
    transform: scale(0.995);
  }
  50% {
    transform: scale(0.9);
  }
  75% {
    transform: scale(0.895);
  }
}
.outermost.piSpeaking {
  animation: speaking_outermost 2s infinite;
  transform-origin: center;
}

@keyframes speaking_second {
  0%,
  100% {
    transform: scale(1) rotate(0deg);
  }
  25% {
    transform: scale(0.98) rotate(-1deg);
  }
  50% {
    transform: scale(0.87) rotate(0deg);
  }
  75% {
    transform: scale(0.865) rotate(1deg);
  }
}
.second.piSpeaking {
  animation: speaking_second 2s infinite;
  transform-origin: center;
}

@keyframes speaking_third {
  0%,
  100% {
    transform: scale(1) rotate(0deg);
  }
  25% {
    transform: scale(0.965) rotate(-2deg);
  }
  50% {
    transform: scale(0.84) rotate(0deg);
  }
  75% {
    transform: scale(0.835) rotate(2deg);
  }
}
.third.piSpeaking {
  animation: speaking_third 2s infinite;
  transform-origin: center;
}

@keyframes speaking_fourth {
  0%,
  100% {
    transform: scale(1) rotate(0deg);
  }
  25% {
    transform: scale(0.95) rotate(-3deg);
  }
  50% {
    transform: scale(0.81) rotate(0deg);
  }
  75% {
    transform: scale(0.805) rotate(3deg);
  }
}
.fourth.piSpeaking {
  animation: speaking_fourth 2s infinite;
  transform-origin: center;
}

@keyframes speaking_fifth {
  0%,
  100% {
    transform: scale(1) rotate(0deg);
  }
  25% {
    transform: scale(0.935) rotate(-4deg);
  }
  50% {
    transform: scale(0.78) rotate(0deg);
  }
  75% {
    transform: scale(0.775) rotate(4deg);
  }
}
.fifth.piSpeaking {
  animation: speaking_fifth 2s infinite;
  transform-origin: center;
}

@keyframes speaking_innermost {
  0%,
  100% {
    transform: scale(1) rotate(0deg);
  }
  25% {
    transform: scale(0.92) rotate(-5deg);
  }
  50% {
    transform: scale(0.75) rotate(0deg);
  }
  75% {
    transform: scale(0.745) rotate(5deg);
  }
}
.innermost.piSpeaking {
  animation: speaking_innermost 2s infinite;
  transform-origin: center;
}

/* wave animation to indicate user is speaking */
@keyframes userSpeakingAnimation {
  50% {
    transform: scaleY(0.05) scaleX(var(--width-factor))
      translateX(calc(-50% + var(--spread-amount)));
  }
  100% {
    transform: scaleY(1) scaleX(var(--width-factor))
      translateX(calc(-50% + var(--spread-amount)));
  }
}
/* user speaking oscillation animation */
@keyframes waveform_outermost {
  0%,
  100% {
    transform: scaleY(1) scaleX(1);
  }
  25%,
  75% {
    transform: scaleY(0.9) scaleX(0.9);
  }
}

@keyframes waveform_second {
  0%,
  100% {
    transform: scaleY(0.9) scaleX(0.9);
  }
  25%,
  75% {
    transform: scaleY(0.8) scaleX(0.8);
  }
}

@keyframes waveform_third {
  0%,
  100% {
    transform: scaleY(0.8) scaleX(0.8);
  }
  25%,
  75% {
    transform: scaleY(0.7) scaleX(0.7);
  }
}

@keyframes waveform_fourth {
  0%,
  100% {
    transform: scaleY(0.7) scaleX(0.7);
  }
  25%,
  75% {
    transform: scaleY(0.6) scaleX(0.6);
  }
}

@keyframes waveform_fifth {
  0%,
  100% {
    transform: scaleY(0.6) scaleX(0.6);
  }
  25%,
  75% {
    transform: scaleY(0.5) scaleX(0.5);
  }
}

@keyframes waveform_innermost {
  0%,
  100% {
    transform: scaleY(0.5) scaleX(0.5);
  }
  25%,
  75% {
    transform: scaleY(0.4) scaleX(0.4);
  }
}

.outermost.userSpeaking {
  animation: waveform_outermost 0.7s infinite alternate;
}

.second.userSpeaking {
  animation: waveform_second 0.65s infinite alternate;
}

.third.userSpeaking {
  animation: waveform_third 0.6s infinite alternate;
}

.fourth.userSpeaking {
  animation: waveform_fourth 0.55s infinite alternate;
}

.fifth.userSpeaking {
  animation: waveform_fifth 0.5s infinite alternate;
}

.innermost.userSpeaking {
  animation: waveform_innermost 0.45s infinite alternate;
}

/* flipcard animation to indicate Say, Pi is transcribing audio to text */
@keyframes transcribingFlip {
  0%,
  100% {
    transform: rotateY(0deg);
    fill: var(--original-color);
  }
  50% {
    transform: rotateY(180deg);
    fill: var(--transcribing-color);
  }
}

.outermost.transcribing {
  --original-color: #e4f2d1;
  --transcribing-color: #b3e0fe;
  animation: transcribingFlip 1.5s infinite;
}

.second.transcribing {
  --original-color: #cce8b5;
  --transcribing-color: #89c2ff;
  animation: transcribingFlip 1.6s infinite;
}

.third.transcribing {
  --original-color: #b3db95;
  --transcribing-color: #5fa4ff;
  animation: transcribingFlip 1.7s infinite;
}

.fourth.transcribing {
  --original-color: #9bd078;
  --transcribing-color: #3586ff;
  animation: transcribingFlip 1.8s infinite;
}

.fifth.transcribing {
  --original-color: #83c55c;
  --transcribing-color: #0b69e3;
  animation: transcribingFlip 1.9s infinite;
}

.innermost.transcribing {
  --original-color: #428a2f;
  --transcribing-color: #0053bf;
  animation: transcribingFlip 2s infinite;
}

/* heartbeat animation to indicate Pi is preparing to speak */
@keyframes heartbeat {
  0%,
  100% {
    opacity: 1;
    fill: var(--original-color);
  }
  50% {
    opacity: 0.5;
    fill: rgb(245 238 223); /* bg-cream-550 */
  }
}

/* toned-down dissary animation to indicate an error */
/* toned-down error animation with reduced opacity */
@keyframes errorAnimation {
  0% {
    transform: rotate(0deg) translate(0%, 0%);
  }
  25% {
    transform: rotate(-5deg) translate(-5%, 5%);
  }
  50% {
    transform: rotate(5deg) translate(5%, -5%);
  }
  75% {
    transform: rotate(-5deg) translate(-5%, 5%);
  }
  100% {
    transform: rotate(0deg) translate(0%, 0%);
  }
}

.outermost.error {
  animation: errorAnimation 25s 1;
  fill: #ff0000;
  fill-opacity: 0.7;
}

.second.error {
  animation: errorAnimation 25s 1;
  fill: #ff3300;
  fill-opacity: 0.7;
}

.third.error {
  animation: errorAnimation 25s 1;
  fill: #ff6600;
  fill-opacity: 0.7;
}

.fourth.error {
  animation: errorAnimation 25s 1;
  fill: #ff9900;
  fill-opacity: 0.7;
}

.fifth.error {
  animation: errorAnimation 25s 1;
  fill: #ffcc00;
  fill-opacity: 0.7;
}

.innermost.error {
  animation: errorAnimation 25s 1;
  fill: #ffff00;
  fill-opacity: 0.7;
}
`, "",{"version":3,"sources":["webpack://./src/styles/rectangles.css"],"names":[],"mappings":"AAAA;EACE;;IAEE,mBAAmB;EACrB;EACA;IACE,sBAAsB;EACxB;AACF;AACA;EACE,sCAAsC;EACtC,wBAAwB;AAC1B;;AAEA;EACE;;IAEE,mBAAmB;EACrB;EACA;IACE,uBAAuB;EACzB;AACF;AACA;EACE,mCAAmC;EACnC,wBAAwB;AAC1B;;AAEA;EACE;;IAEE,mBAAmB;EACrB;EACA;IACE,uBAAuB;EACzB;AACF;AACA;EACE,kCAAkC;EAClC,wBAAwB;AAC1B;;AAEA;EACE;;IAEE,mBAAmB;EACrB;EACA;IACE,uBAAuB;EACzB;AACF;AACA;EACE,mCAAmC;EACnC,wBAAwB;AAC1B;;AAEA;EACE;;IAEE,mBAAmB;EACrB;EACA;IACE,uBAAuB;EACzB;AACF;AACA;EACE,kCAAkC;EAClC,wBAAwB;AAC1B;;AAEA;EACE;;IAEE,mBAAmB;EACrB;EACA;IACE,qBAAqB;EACvB;AACF;AACA;EACE,sCAAsC;EACtC,wBAAwB;AAC1B;;AAEA,iDAAiD;AACjD;EACE;;IAEE,gCAAgC;EAClC;EACA;IACE,uBAAuB;EACzB;EACA;IACE,qBAAqB;EACvB;EACA;IACE,uBAAuB;EACzB;AACF;AACA;EACE,yCAAyC;EACzC,wBAAwB;AAC1B;;AAEA;EACE;;IAEE,gCAAgC;EAClC;EACA;IACE,oCAAoC;EACtC;EACA;IACE,mCAAmC;EACrC;EACA;IACE,oCAAoC;EACtC;AACF;AACA;EACE,sCAAsC;EACtC,wBAAwB;AAC1B;;AAEA;EACE;;IAEE,gCAAgC;EAClC;EACA;IACE,qCAAqC;EACvC;EACA;IACE,mCAAmC;EACrC;EACA;IACE,oCAAoC;EACtC;AACF;AACA;EACE,qCAAqC;EACrC,wBAAwB;AAC1B;;AAEA;EACE;;IAEE,gCAAgC;EAClC;EACA;IACE,oCAAoC;EACtC;EACA;IACE,mCAAmC;EACrC;EACA;IACE,oCAAoC;EACtC;AACF;AACA;EACE,sCAAsC;EACtC,wBAAwB;AAC1B;;AAEA;EACE;;IAEE,gCAAgC;EAClC;EACA;IACE,qCAAqC;EACvC;EACA;IACE,mCAAmC;EACrC;EACA;IACE,oCAAoC;EACtC;AACF;AACA;EACE,qCAAqC;EACrC,wBAAwB;AAC1B;;AAEA;EACE;;IAEE,gCAAgC;EAClC;EACA;IACE,oCAAoC;EACtC;EACA;IACE,mCAAmC;EACrC;EACA;IACE,oCAAoC;EACtC;AACF;AACA;EACE,yCAAyC;EACzC,wBAAwB;AAC1B;;AAEA,gDAAgD;AAChD;EACE;IACE;mDAC+C;EACjD;EACA;IACE;mDAC+C;EACjD;AACF;AACA,wCAAwC;AACxC;EACE;;IAEE,8BAA8B;EAChC;EACA;;IAEE,kCAAkC;EACpC;AACF;;AAEA;EACE;;IAEE,kCAAkC;EACpC;EACA;;IAEE,kCAAkC;EACpC;AACF;;AAEA;EACE;;IAEE,kCAAkC;EACpC;EACA;;IAEE,kCAAkC;EACpC;AACF;;AAEA;EACE;;IAEE,kCAAkC;EACpC;EACA;;IAEE,kCAAkC;EACpC;AACF;;AAEA;EACE;;IAEE,kCAAkC;EACpC;EACA;;IAEE,kCAAkC;EACpC;AACF;;AAEA;EACE;;IAEE,kCAAkC;EACpC;EACA;;IAEE,kCAAkC;EACpC;AACF;;AAEA;EACE,qDAAqD;AACvD;;AAEA;EACE,mDAAmD;AACrD;;AAEA;EACE,iDAAiD;AACnD;;AAEA;EACE,mDAAmD;AACrD;;AAEA;EACE,iDAAiD;AACnD;;AAEA;EACE,sDAAsD;AACxD;;AAEA,yEAAyE;AACzE;EACE;;IAEE,wBAAwB;IACxB,2BAA2B;EAC7B;EACA;IACE,0BAA0B;IAC1B,+BAA+B;EACjC;AACF;;AAEA;EACE,yBAAyB;EACzB,6BAA6B;EAC7B,yCAAyC;AAC3C;;AAEA;EACE,yBAAyB;EACzB,6BAA6B;EAC7B,yCAAyC;AAC3C;;AAEA;EACE,yBAAyB;EACzB,6BAA6B;EAC7B,yCAAyC;AAC3C;;AAEA;EACE,yBAAyB;EACzB,6BAA6B;EAC7B,yCAAyC;AAC3C;;AAEA;EACE,yBAAyB;EACzB,6BAA6B;EAC7B,yCAAyC;AAC3C;;AAEA;EACE,yBAAyB;EACzB,6BAA6B;EAC7B,uCAAuC;AACzC;;AAEA,6DAA6D;AAC7D;EACE;;IAEE,UAAU;IACV,2BAA2B;EAC7B;EACA;IACE,YAAY;IACZ,sBAAsB,EAAE,iBAAiB;EAC3C;AACF;;AAEA,sDAAsD;AACtD,oDAAoD;AACpD;EACE;IACE,yCAAyC;EAC3C;EACA;IACE,2CAA2C;EAC7C;EACA;IACE,0CAA0C;EAC5C;EACA;IACE,2CAA2C;EAC7C;EACA;IACE,yCAAyC;EAC3C;AACF;;AAEA;EACE,+BAA+B;EAC/B,aAAa;EACb,iBAAiB;AACnB;;AAEA;EACE,+BAA+B;EAC/B,aAAa;EACb,iBAAiB;AACnB;;AAEA;EACE,+BAA+B;EAC/B,aAAa;EACb,iBAAiB;AACnB;;AAEA;EACE,+BAA+B;EAC/B,aAAa;EACb,iBAAiB;AACnB;;AAEA;EACE,+BAA+B;EAC/B,aAAa;EACb,iBAAiB;AACnB;;AAEA;EACE,+BAA+B;EAC/B,aAAa;EACb,iBAAiB;AACnB","sourcesContent":["@keyframes pulse_outermost {\n  0%,\n  100% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(0.92);\n  }\n}\n.outermost {\n  animation: pulse_outermost 5s infinite;\n  transform-origin: center;\n}\n\n@keyframes pulse_second {\n  0%,\n  100% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(0.856);\n  }\n}\n.second {\n  animation: pulse_second 5s infinite;\n  transform-origin: center;\n}\n\n@keyframes pulse_third {\n  0%,\n  100% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(0.792);\n  }\n}\n.third {\n  animation: pulse_third 5s infinite;\n  transform-origin: center;\n}\n\n@keyframes pulse_fourth {\n  0%,\n  100% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(0.728);\n  }\n}\n.fourth {\n  animation: pulse_fourth 5s infinite;\n  transform-origin: center;\n}\n\n@keyframes pulse_fifth {\n  0%,\n  100% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(0.664);\n  }\n}\n.fifth {\n  animation: pulse_fifth 5s infinite;\n  transform-origin: center;\n}\n\n@keyframes pulse_innermost {\n  0%,\n  100% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(0.6);\n  }\n}\n.innermost {\n  animation: pulse_innermost 5s infinite;\n  transform-origin: center;\n}\n\n/* playful animation to indicate Pi is speaking */\n@keyframes speaking_outermost {\n  0%,\n  100% {\n    transform: scale(1) rotate(0deg);\n  }\n  25% {\n    transform: scale(0.995);\n  }\n  50% {\n    transform: scale(0.9);\n  }\n  75% {\n    transform: scale(0.895);\n  }\n}\n.outermost.piSpeaking {\n  animation: speaking_outermost 2s infinite;\n  transform-origin: center;\n}\n\n@keyframes speaking_second {\n  0%,\n  100% {\n    transform: scale(1) rotate(0deg);\n  }\n  25% {\n    transform: scale(0.98) rotate(-1deg);\n  }\n  50% {\n    transform: scale(0.87) rotate(0deg);\n  }\n  75% {\n    transform: scale(0.865) rotate(1deg);\n  }\n}\n.second.piSpeaking {\n  animation: speaking_second 2s infinite;\n  transform-origin: center;\n}\n\n@keyframes speaking_third {\n  0%,\n  100% {\n    transform: scale(1) rotate(0deg);\n  }\n  25% {\n    transform: scale(0.965) rotate(-2deg);\n  }\n  50% {\n    transform: scale(0.84) rotate(0deg);\n  }\n  75% {\n    transform: scale(0.835) rotate(2deg);\n  }\n}\n.third.piSpeaking {\n  animation: speaking_third 2s infinite;\n  transform-origin: center;\n}\n\n@keyframes speaking_fourth {\n  0%,\n  100% {\n    transform: scale(1) rotate(0deg);\n  }\n  25% {\n    transform: scale(0.95) rotate(-3deg);\n  }\n  50% {\n    transform: scale(0.81) rotate(0deg);\n  }\n  75% {\n    transform: scale(0.805) rotate(3deg);\n  }\n}\n.fourth.piSpeaking {\n  animation: speaking_fourth 2s infinite;\n  transform-origin: center;\n}\n\n@keyframes speaking_fifth {\n  0%,\n  100% {\n    transform: scale(1) rotate(0deg);\n  }\n  25% {\n    transform: scale(0.935) rotate(-4deg);\n  }\n  50% {\n    transform: scale(0.78) rotate(0deg);\n  }\n  75% {\n    transform: scale(0.775) rotate(4deg);\n  }\n}\n.fifth.piSpeaking {\n  animation: speaking_fifth 2s infinite;\n  transform-origin: center;\n}\n\n@keyframes speaking_innermost {\n  0%,\n  100% {\n    transform: scale(1) rotate(0deg);\n  }\n  25% {\n    transform: scale(0.92) rotate(-5deg);\n  }\n  50% {\n    transform: scale(0.75) rotate(0deg);\n  }\n  75% {\n    transform: scale(0.745) rotate(5deg);\n  }\n}\n.innermost.piSpeaking {\n  animation: speaking_innermost 2s infinite;\n  transform-origin: center;\n}\n\n/* wave animation to indicate user is speaking */\n@keyframes userSpeakingAnimation {\n  50% {\n    transform: scaleY(0.05) scaleX(var(--width-factor))\n      translateX(calc(-50% + var(--spread-amount)));\n  }\n  100% {\n    transform: scaleY(1) scaleX(var(--width-factor))\n      translateX(calc(-50% + var(--spread-amount)));\n  }\n}\n/* user speaking oscillation animation */\n@keyframes waveform_outermost {\n  0%,\n  100% {\n    transform: scaleY(1) scaleX(1);\n  }\n  25%,\n  75% {\n    transform: scaleY(0.9) scaleX(0.9);\n  }\n}\n\n@keyframes waveform_second {\n  0%,\n  100% {\n    transform: scaleY(0.9) scaleX(0.9);\n  }\n  25%,\n  75% {\n    transform: scaleY(0.8) scaleX(0.8);\n  }\n}\n\n@keyframes waveform_third {\n  0%,\n  100% {\n    transform: scaleY(0.8) scaleX(0.8);\n  }\n  25%,\n  75% {\n    transform: scaleY(0.7) scaleX(0.7);\n  }\n}\n\n@keyframes waveform_fourth {\n  0%,\n  100% {\n    transform: scaleY(0.7) scaleX(0.7);\n  }\n  25%,\n  75% {\n    transform: scaleY(0.6) scaleX(0.6);\n  }\n}\n\n@keyframes waveform_fifth {\n  0%,\n  100% {\n    transform: scaleY(0.6) scaleX(0.6);\n  }\n  25%,\n  75% {\n    transform: scaleY(0.5) scaleX(0.5);\n  }\n}\n\n@keyframes waveform_innermost {\n  0%,\n  100% {\n    transform: scaleY(0.5) scaleX(0.5);\n  }\n  25%,\n  75% {\n    transform: scaleY(0.4) scaleX(0.4);\n  }\n}\n\n.outermost.userSpeaking {\n  animation: waveform_outermost 0.7s infinite alternate;\n}\n\n.second.userSpeaking {\n  animation: waveform_second 0.65s infinite alternate;\n}\n\n.third.userSpeaking {\n  animation: waveform_third 0.6s infinite alternate;\n}\n\n.fourth.userSpeaking {\n  animation: waveform_fourth 0.55s infinite alternate;\n}\n\n.fifth.userSpeaking {\n  animation: waveform_fifth 0.5s infinite alternate;\n}\n\n.innermost.userSpeaking {\n  animation: waveform_innermost 0.45s infinite alternate;\n}\n\n/* flipcard animation to indicate Say, Pi is transcribing audio to text */\n@keyframes transcribingFlip {\n  0%,\n  100% {\n    transform: rotateY(0deg);\n    fill: var(--original-color);\n  }\n  50% {\n    transform: rotateY(180deg);\n    fill: var(--transcribing-color);\n  }\n}\n\n.outermost.transcribing {\n  --original-color: #e4f2d1;\n  --transcribing-color: #b3e0fe;\n  animation: transcribingFlip 1.5s infinite;\n}\n\n.second.transcribing {\n  --original-color: #cce8b5;\n  --transcribing-color: #89c2ff;\n  animation: transcribingFlip 1.6s infinite;\n}\n\n.third.transcribing {\n  --original-color: #b3db95;\n  --transcribing-color: #5fa4ff;\n  animation: transcribingFlip 1.7s infinite;\n}\n\n.fourth.transcribing {\n  --original-color: #9bd078;\n  --transcribing-color: #3586ff;\n  animation: transcribingFlip 1.8s infinite;\n}\n\n.fifth.transcribing {\n  --original-color: #83c55c;\n  --transcribing-color: #0b69e3;\n  animation: transcribingFlip 1.9s infinite;\n}\n\n.innermost.transcribing {\n  --original-color: #428a2f;\n  --transcribing-color: #0053bf;\n  animation: transcribingFlip 2s infinite;\n}\n\n/* heartbeat animation to indicate Pi is preparing to speak */\n@keyframes heartbeat {\n  0%,\n  100% {\n    opacity: 1;\n    fill: var(--original-color);\n  }\n  50% {\n    opacity: 0.5;\n    fill: rgb(245 238 223); /* bg-cream-550 */\n  }\n}\n\n/* toned-down dissary animation to indicate an error */\n/* toned-down error animation with reduced opacity */\n@keyframes errorAnimation {\n  0% {\n    transform: rotate(0deg) translate(0%, 0%);\n  }\n  25% {\n    transform: rotate(-5deg) translate(-5%, 5%);\n  }\n  50% {\n    transform: rotate(5deg) translate(5%, -5%);\n  }\n  75% {\n    transform: rotate(-5deg) translate(-5%, 5%);\n  }\n  100% {\n    transform: rotate(0deg) translate(0%, 0%);\n  }\n}\n\n.outermost.error {\n  animation: errorAnimation 25s 1;\n  fill: #ff0000;\n  fill-opacity: 0.7;\n}\n\n.second.error {\n  animation: errorAnimation 25s 1;\n  fill: #ff3300;\n  fill-opacity: 0.7;\n}\n\n.third.error {\n  animation: errorAnimation 25s 1;\n  fill: #ff6600;\n  fill-opacity: 0.7;\n}\n\n.fourth.error {\n  animation: errorAnimation 25s 1;\n  fill: #ff9900;\n  fill-opacity: 0.7;\n}\n\n.fifth.error {\n  animation: errorAnimation 25s 1;\n  fill: #ffcc00;\n  fill-opacity: 0.7;\n}\n\n.innermost.error {\n  animation: errorAnimation 25s 1;\n  fill: #ffff00;\n  fill-opacity: 0.7;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./src/styles/common.scss":
/*!*********************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./src/styles/common.scss ***!
  \*********************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.hidden {
  display: none !important;
}

#saypi-callButton.disabled svg path.circle {
  fill: rgb(245, 238, 223); /* bg-cream-550 */
}

.mobile-device {
  /* maximize (mobile view) button is only displayed on compatible devices */
}
.mobile-device #saypi-enterButton,
.mobile-device #saypi-exitButton {
  position: fixed;
  top: 4rem;
  left: 10px;
  width: 3rem;
  height: 3rem;
  padding: 6px;
  border: 0;
  z-index: 60;
}
.mobile-device #saypi-enterButton svg path.inner,
.mobile-device #saypi-exitButton svg path.inner {
  color: rgb(13, 60, 38); /* text-primary-700 */
}`, "",{"version":3,"sources":["webpack://./src/styles/common.scss"],"names":[],"mappings":"AAAA;EACE,wBAAA;AACF;;AAEA;EACE,wBAAA,EAAA,iBAAA;AACF;;AAEA;EACE,0EAAA;AACF;AAAE;;EAEE,eAAA;EACA,SAAA;EACA,UAAA;EACA,WAAA;EACA,YAAA;EACA,YAAA;EACA,SAAA;EACA,WAAA;AAEJ;AADI;;EACE,sBAAA,EAAA,qBAAA;AAIN","sourcesContent":[".hidden {\n  display: none !important;\n}\n\n#saypi-callButton.disabled svg path.circle {\n  fill: rgb(245 238 223); /* bg-cream-550 */\n}\n\n.mobile-device {\n  /* maximize (mobile view) button is only displayed on compatible devices */\n  #saypi-enterButton,\n  #saypi-exitButton {\n    position: fixed;\n    top: 4rem;\n    left: 10px;\n    width: 3rem;\n    height: 3rem;\n    padding: 6px;\n    border: 0;\n    z-index: 60;\n    svg path.inner {\n      color: rgb(13 60 38); /* text-primary-700 */\n    }\n  }\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./src/styles/desktop.scss":
/*!**********************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./src/styles/desktop.scss ***!
  \**********************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `@keyframes pulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(0.9);
  }
  100% {
    transform: scale(1);
  }
}
html.desktop-view #saypi-talkButton {
  /* not needed on desktop with call button */
  display: none;
}
html.desktop-view #saypi-callButton {
  height: 2.25rem;
  width: 2.25rem;
  position: relative;
  margin: 0.5rem 0 0.5rem 0;
}
html.desktop-view .saypi-prompt-container {
  /* make room in the prompt text area for the call button */
  padding-right: 0;
}
html.desktop-view #saypi-notification > svg {
  width: 3rem;
  height: 3rem;
  bottom: 4rem;
  right: 12rem;
  position: fixed;
}
html.desktop-view #saypi-exitButton {
  display: none;
}`, "",{"version":3,"sources":["webpack://./src/styles/desktop.scss"],"names":[],"mappings":"AACE;EACE;IACE,mBAAA;EAAJ;EAEE;IACE,qBAAA;EAAJ;EAEE;IACE,mBAAA;EAAJ;AACF;AAGE;EACE,2CAAA;EACA,aAAA;AADJ;AAIE;EACE,eAAA;EACA,cAAA;EACA,kBAAA;EACA,yBAAA;AAFJ;AAKE;EACE,0DAAA;EACA,gBAAA;AAHJ;AAME;EACE,WAAA;EACA,YAAA;EACA,YAAA;EACA,YAAA;EACA,eAAA;AAJJ;AAOE;EACE,aAAA;AALJ","sourcesContent":["html.desktop-view {\n  @keyframes pulse {\n    0% {\n      transform: scale(1);\n    }\n    50% {\n      transform: scale(0.9);\n    }\n    100% {\n      transform: scale(1);\n    }\n  }\n\n  #saypi-talkButton {\n    /* not needed on desktop with call button */\n    display: none;\n  }\n\n  #saypi-callButton {\n    height: 2.25rem;\n    width: 2.25rem;\n    position: relative;\n    margin: 0.5rem 0 0.5rem 0;\n  }\n\n  .saypi-prompt-container {\n    /* make room in the prompt text area for the call button */\n    padding-right: 0;\n  }\n\n  #saypi-notification > svg {\n    width: 3rem;\n    height: 3rem;\n    bottom: 4rem;\n    right: 12rem;\n    position: fixed;\n  }\n\n  #saypi-exitButton {\n    display: none;\n  }\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./src/styles/mobile.scss":
/*!*********************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./src/styles/mobile.scss ***!
  \*********************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `html.mobile-view {
  /* Pi controls: ellipsis, experiences */
  /* hide an ugly artifact */
  /* Pi controls: mute/unmute */
  /* fix an alignment issue with the "new ui layout" */
}
html.mobile-view #saypi-panel,
html.mobile-view .notification {
  width: 100%;
  position: fixed;
  left: 0;
  background-color: rgba(245, 238, 223, 0.98);
  height: 100svh;
  top: 0;
}
html.mobile-view #saypi-talkButton {
  background-color: transparent;
  border-radius: 0;
  margin: 0;
}
html.mobile-view #saypi-talkButton svg {
  width: 100vw;
  height: 100svh;
}
html.mobile-view #saypi-notification {
  z-index: 100;
  background-color: transparent;
}
html.mobile-view #saypi-notification svg {
  width: 75%;
  height: 100%;
  margin: auto;
}
html.mobile-view #__next > main > div > div > div.fixed.top-4.right-6 > button,
html.mobile-view #saypi-experiences-button {
  transform: scale(1.5);
}
html.mobile-view div.bg-gradient-to-b {
  display: none;
}
html.mobile-view #saypi-audio-controls {
  /* hide the voice options */
  /* scale the mute button */
}
html.mobile-view #saypi-audio-controls div.p-1 {
  display: none;
}
html.mobile-view #saypi-audio-controls button.group {
  transform: scale(2) !important;
  z-index: 50;
  /* hide the voice selector twisty */
}
html.mobile-view #saypi-audio-controls button.group + button {
  display: none;
}
html.mobile-view .text-body-chat-m {
  padding-top: 0;
}
html.mobile-view #saypi-enterButton {
  display: none;
}
html.mobile-view #saypi-footer {
  display: none;
}
html.mobile-view #saypi-prompt-ancestor {
  /* hides the row containing the text area control */
  /* important: hides virtual keyboard on android */
  display: none;
  /* the call button, usually nested in the prompt, is detached while in mobile view */
}
html.mobile-view #saypi-submitButton {
  display: none;
}
html.mobile-view #saypi-callButton {
  position: fixed;
  bottom: 4rem;
  left: 0;
  right: 0;
  margin: auto;
  width: 4.5rem;
  height: 4.5rem;
  padding: 6px;
  border: 0;
  z-index: 80;
}`, "",{"version":3,"sources":["webpack://./src/styles/mobile.scss"],"names":[],"mappings":"AAAA;EAgCE,uCAAA;EAMA,0BAAA;EAKA,6BAAA;EAiBA,oDAAA;AAvDF;AAJE;;EAEE,WAAA;EACA,eAAA;EACA,OAAA;EACA,2CAAA;EAEA,cAAA;EACA,MAAA;AAKJ;AAFE;EACE,6BAAA;EACA,gBAAA;EACA,SAAA;AAIJ;AAHI;EACE,YAAA;EACA,cAAA;AAKN;AADE;EACE,YAAA;EACA,6BAAA;AAGJ;AAFI;EACE,UAAA;EACA,YAAA;EACA,YAAA;AAIN;AACE;;EAEE,qBAAA;AACJ;AAGE;EACE,aAAA;AADJ;AAKE;EACE,2BAAA;EAIA,0BAAA;AANJ;AAGI;EACE,aAAA;AADN;AAII;EACE,8BAAA;EACA,WAAA;EACA,mCAAA;AAFN;AAGM;EACE,aAAA;AADR;AAOE;EACE,cAAA;AALJ;AAQE;EACE,aAAA;AANJ;AASE;EACE,aAAA;AAPJ;AAUE;EACE,mDAAA;EACA,iDAAA;EACA,aAAA;EACA,oFAAA;AARJ;AAWE;EACE,aAAA;AATJ;AAYE;EACE,eAAA;EACA,YAAA;EACA,OAAA;EACA,QAAA;EACA,YAAA;EACA,aAAA;EACA,cAAA;EACA,YAAA;EACA,SAAA;EACA,WAAA;AAVJ","sourcesContent":["html.mobile-view {\n  #saypi-panel,\n  .notification {\n    width: 100%;\n    position: fixed;\n    left: 0;\n    background-color: rgba(245, 238, 223, 0.98);\n\n    height: 100svh;\n    top: 0;\n  }\n\n  #saypi-talkButton {\n    background-color: transparent;\n    border-radius: 0;\n    margin: 0;\n    svg {\n      width: 100vw;\n      height: 100svh;\n    }\n  }\n\n  #saypi-notification {\n    z-index: 100;\n    background-color: transparent;\n    svg {\n      width: 75%;\n      height: 100%;\n      margin: auto;\n    }\n  }\n\n  /* Pi controls: ellipsis, experiences */\n  #__next > main > div > div > div.fixed.top-4.right-6 > button,\n  #saypi-experiences-button {\n    transform: scale(1.5);\n  }\n\n  /* hide an ugly artifact */\n  div.bg-gradient-to-b {\n    display: none;\n  }\n\n  /* Pi controls: mute/unmute */\n  #saypi-audio-controls {\n    /* hide the voice options */\n    div.p-1 {\n      display: none;\n    }\n    /* scale the mute button */\n    button.group {\n      transform: scale(2) !important;\n      z-index: 50;\n      /* hide the voice selector twisty */\n      + button {\n        display: none;\n      }\n    }\n  }\n\n  /* fix an alignment issue with the \"new ui layout\" */\n  .text-body-chat-m {\n    padding-top: 0;\n  }\n\n  #saypi-enterButton {\n    display: none;\n  }\n\n  #saypi-footer {\n    display: none;\n  }\n\n  #saypi-prompt-ancestor {\n    /* hides the row containing the text area control */\n    /* important: hides virtual keyboard on android */\n    display: none;\n    /* the call button, usually nested in the prompt, is detached while in mobile view */\n  }\n\n  #saypi-submitButton {\n    display: none;\n  }\n\n  #saypi-callButton {\n    position: fixed;\n    bottom: 4rem;\n    left: 0;\n    right: 0;\n    margin: auto;\n    width: 4.5rem;\n    height: 4.5rem;\n    padding: 6px;\n    border: 0;\n    z-index: 80;\n  }\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/onnxruntime-web/dist/ort.min.js":
/*!******************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.min.js ***!
  \******************************************************/
/***/ ((module) => {

/*!
* ONNX Runtime Web v1.15.1
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/
!function(e,t){ true?module.exports=t():0}(self,(()=>(()=>{var __webpack_modules__={8453:(e,t,n)=>{"use strict";n.r(t),n.d(t,{InferenceSession:()=>f,Tensor:()=>p,env:()=>a,registerBackend:()=>i});const r={},o=[],i=(e,t,n)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createSessionHandler)throw new TypeError("not a valid backend");{const i=r[e];if(void 0===i)r[e]={backend:t,priority:n};else{if(i.priority>n)return;if(i.priority===n&&i.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){const t=o.indexOf(e);-1!==t&&o.splice(t,1);for(let t=0;t<o.length;t++)if(r[o[t]].priority<=n)return void o.splice(t,0,e);o.push(e)}}},a=new class{constructor(){this.wasm={},this.webgl={},this.webgpu={},this.logLevelInternal="warning"}set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);this.logLevelInternal=e}}get logLevel(){return this.logLevelInternal}},s=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),u=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let l=!1;class c{constructor(e,t,n){let r,o,i;if((()=>{if(!l){l=!0;const e="undefined"!=typeof BigInt64Array&&"function"==typeof BigInt64Array.from,t="undefined"!=typeof BigUint64Array&&"function"==typeof BigUint64Array.from;e&&(s.set("int64",BigInt64Array),u.set(BigInt64Array,"int64")),t&&(s.set("uint64",BigUint64Array),u.set(BigUint64Array,"uint64"))}})(),"string"==typeof e)if(r=e,i=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");o=t}else{const n=s.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t))o=n.from(t);else{if(!(t instanceof n))throw new TypeError(`A ${r} tensor's data must be type of ${n}`);o=t}}else if(i=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const t=typeof e[0];if("string"===t)r="string",o=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",o=Uint8Array.from(e)}}else{const t=u.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,o=e}if(void 0===i)i=[o.length];else if(!Array.isArray(i))throw new TypeError("A tensor's dims must be a number array");const a=(e=>{let t=1;for(let n=0;n<e.length;n++){const r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t})(i);if(a!==o.length)throw new Error(`Tensor's size(${a}) does not match data length(${o.length}).`);this.dims=i,this.type=r,this.data=o,this.size=a}static bufferToTensor(e,t){if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");const{height:n,width:r}=t,o=t.norm??{mean:255,bias:0};let i,a;i="number"==typeof o.mean?[o.mean,o.mean,o.mean,o.mean]:[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],a="number"==typeof o.bias?[o.bias,o.bias,o.bias,o.bias]:[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];const s=void 0!==t.bitmapFormat?t.bitmapFormat:"RGBA",u=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",l=n*r,p="RGBA"===u?new Float32Array(4*l):new Float32Array(3*l);let d=4,f=0,h=1,g=2,m=3,b=0,y=l,w=2*l,_=-1;"RGB"===s&&(d=3,f=0,h=1,g=2,m=-1),"RGBA"===u?_=3*l:"RBG"===u?(b=0,w=l,y=2*l):"BGR"===u&&(w=0,y=l,b=2*l);for(let t=0;t<l;t++,f+=d,g+=d,h+=d,m+=d)p[b++]=(e[f]+a[0])/i[0],p[y++]=(e[h]+a[1])/i[1],p[w++]=(e[g]+a[2])/i[2],-1!==_&&-1!==m&&(p[_++]=(e[m]+a[3])/i[3]);return new c("float32",p,"RGBA"===u?[1,4,n,r]:[1,3,n,r])}static async fromImage(e,t){const n="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,r="undefined"!=typeof ImageData&&e instanceof ImageData,o="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,i="string"==typeof e;let a,s=t??{};if(n){const n=document.createElement("canvas");n.width=e.width,n.height=e.height;const r=n.getContext("2d");if(null==r)throw new Error("Can not access image data");{let n=e.height,o=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(n=t.resizedHeight,o=t.resizedWidth),void 0!==t){if(s=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(s.tensorFormat="RGBA",void 0!==t.height&&t.height!==n)throw new Error("Image input config height doesn't match HTMLImageElement height");if(s.height=n,void 0!==t.width&&t.width!==o)throw new Error("Image input config width doesn't match HTMLImageElement width");s.width=o}else s.tensorFormat="RGBA",s.height=n,s.width=o;r.drawImage(e,0,0),a=r.getImageData(0,0,o,n).data}}else{if(!r){if(o){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");if(void 0!==t.bitmapFormat)throw new Error("Image input config format must be defined for ImageBitmap");const n=document.createElement("canvas").getContext("2d");if(null!=n){const r=e.height,o=e.width;if(n.drawImage(e,0,0,o,r),a=n.getImageData(0,0,o,r).data,void 0!==t){if(void 0!==t.height&&t.height!==r)throw new Error("Image input config height doesn't match ImageBitmap height");if(s.height=r,void 0!==t.width&&t.width!==o)throw new Error("Image input config width doesn't match ImageBitmap width");s.width=o}else s.height=r,s.width=o;return c.bufferToTensor(a,s)}throw new Error("Can not access image data")}if(i)return new Promise(((n,r)=>{const o=document.createElement("canvas"),i=o.getContext("2d");if(!e||!i)return r();const a=new Image;a.crossOrigin="Anonymous",a.src=e,a.onload=()=>{o.width=a.width,o.height=a.height,i.drawImage(a,0,0,o.width,o.height);const e=i.getImageData(0,0,o.width,o.height);if(void 0!==t){if(void 0!==t.height&&t.height!==o.height)throw new Error("Image input config height doesn't match height");if(s.height=o.height,void 0!==t.width&&t.width!==o.width)throw new Error("Image input config width doesn't match width");s.width=o.width}else s.height=o.height,s.width=o.width;n(c.bufferToTensor(e.data,s))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{const n="RGBA";let r,o;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(r=t.resizedHeight,o=t.resizedWidth):(r=e.height,o=e.width),void 0!==t){if(s=t,void 0!==t.bitmapFormat&&t.bitmapFormat!==n)throw new Error("Image input config format must be RGBA for ImageData");s.bitmapFormat="RGBA"}else s.bitmapFormat="RGBA";if(s.height=r,s.width=o,void 0!==t){const t=document.createElement("canvas");t.width=o,t.height=r;const n=t.getContext("2d");if(null==n)throw new Error("Can not access image data");n.putImageData(e,0,0),a=n.getImageData(0,0,o,r).data}else a=e.data}}if(void 0!==a)return c.bufferToTensor(a,s);throw new Error("Input data provided is not supported - aborted tensor creation")}toDataURL(e){const t=document.createElement("canvas");t.width=this.dims[3],t.height=this.dims[2];const n=t.getContext("2d");if(null!=n){let r,o;void 0!==e?.tensorLayout&&"NHWC"===e.tensorLayout?(r=this.dims[2],o=this.dims[3]):(r=this.dims[3],o=this.dims[2]);const i=void 0!==e?.format?e.format:"RGB",a=e?.norm;let s,u;void 0===a||void 0===a.mean?s=[255,255,255,255]:"number"==typeof a.mean?s=[a.mean,a.mean,a.mean,a.mean]:(s=[a.mean[0],a.mean[1],a.mean[2],0],void 0!==a.mean[3]&&(s[3]=a.mean[3])),void 0===a||void 0===a.bias?u=[0,0,0,0]:"number"==typeof a.bias?u=[a.bias,a.bias,a.bias,a.bias]:(u=[a.bias[0],a.bias[1],a.bias[2],0],void 0!==a.bias[3]&&(u[3]=a.bias[3]));const l=o*r;let c=0,p=l,d=2*l,f=-1;"RGBA"===i?(c=0,p=l,d=2*l,f=3*l):"RGB"===i?(c=0,p=l,d=2*l):"RBG"===i&&(c=0,d=l,p=2*l);for(let e=0;e<o;e++)for(let t=0;t<r;t++){const r=(this.data[c++]-u[0])*s[0],o=(this.data[p++]-u[1])*s[1],i=(this.data[d++]-u[2])*s[2],a=-1===f?255:(this.data[f++]-u[3])*s[3];n.fillStyle="rgba("+r+","+o+","+i+","+a+")",n.fillRect(t,e,1,1)}return t.toDataURL()}throw new Error("Can not access image data")}toImageData(e){const t=document.createElement("canvas").getContext("2d");let n;if(null==t)throw new Error("Can not access image data");{let r,o,i;void 0!==e?.tensorLayout&&"NHWC"===e.tensorLayout?(r=this.dims[2],o=this.dims[1],i=this.dims[3]):(r=this.dims[3],o=this.dims[2],i=this.dims[1]);const a=void 0!==e&&void 0!==e.format?e.format:"RGB",s=e?.norm;let u,l;void 0===s||void 0===s.mean?u=[255,255,255,255]:"number"==typeof s.mean?u=[s.mean,s.mean,s.mean,s.mean]:(u=[s.mean[0],s.mean[1],s.mean[2],255],void 0!==s.mean[3]&&(u[3]=s.mean[3])),void 0===s||void 0===s.bias?l=[0,0,0,0]:"number"==typeof s.bias?l=[s.bias,s.bias,s.bias,s.bias]:(l=[s.bias[0],s.bias[1],s.bias[2],0],void 0!==s.bias[3]&&(l[3]=s.bias[3]));const c=o*r;if(void 0!==e){if(void 0!==e.height&&e.height!==o)throw new Error("Image output config height doesn't match tensor height");if(void 0!==e.width&&e.width!==r)throw new Error("Image output config width doesn't match tensor width");if(void 0!==e.format&&4===i&&"RGBA"!==e.format||3===i&&"RGB"!==e.format&&"BGR"!==e.format)throw new Error("Tensor format doesn't match input tensor dims")}const p=4;let d=0,f=1,h=2,g=3,m=0,b=c,y=2*c,w=-1;"RGBA"===a?(m=0,b=c,y=2*c,w=3*c):"RGB"===a?(m=0,b=c,y=2*c):"RBG"===a&&(m=0,y=c,b=2*c),n=t.createImageData(r,o);for(let e=0;e<o*r;d+=p,f+=p,h+=p,g+=p,e++)n.data[d]=(this.data[m++]-l[0])*u[0],n.data[f]=(this.data[b++]-l[1])*u[1],n.data[h]=(this.data[y++]-l[2])*u[2],n.data[g]=-1===w?255:(this.data[w++]-l[3])*u[3]}return n}reshape(e){return new c(this.type,this.data,e)}}const p=c;class d{constructor(e){this.handler=e}async run(e,t,n){const r={};let o={};if("object"!=typeof e||null===e||e instanceof p||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof p)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");i=!1;for(const e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)o=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else{let e=!1;const a=Object.getOwnPropertyNames(t);for(const n of this.outputNames)if(-1!==a.indexOf(n)){const o=t[n];(null===o||o instanceof p)&&(e=!0,i=!1,r[n]=o)}if(e){if("object"==typeof n&&null!==n)o=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else o=t}}else if(void 0!==t)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const t of this.inputNames)if(void 0===e[t])throw new Error(`input '${t}' is missing in 'feeds'.`);if(i)for(const e of this.outputNames)r[e]=null;const a=await this.handler.run(e,r,o),s={};for(const e in a)Object.hasOwnProperty.call(a,e)&&(s[e]=new p(a[e].type,a[e].data,a[e].dims));return s}static async create(e,t,n,i){let a,s={};if("string"==typeof e){if(a=e,"object"==typeof t&&null!==t)s=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(a=e,"object"==typeof t&&null!==t)s=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else{if(!(e instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const r=e;let o=0,u=e.byteLength;if("object"==typeof t&&null!==t)s=t;else if("number"==typeof t){if(o=t,!Number.isSafeInteger(o))throw new RangeError("'byteOffset' must be an integer.");if(o<0||o>=r.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${r.byteLength}).`);if(u=e.byteLength-o,"number"==typeof n){if(u=n,!Number.isSafeInteger(u))throw new RangeError("'byteLength' must be an integer.");if(u<=0||o+u>r.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${r.byteLength-o}].`);if("object"==typeof i&&null!==i)s=i;else if(void 0!==i)throw new TypeError("'options' must be an object.")}else if(void 0!==n)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==t)throw new TypeError("'options' must be an object.");a=new Uint8Array(r,o,u)}}const u=(s.executionProviders||[]).map((e=>"string"==typeof e?e:e.name)),l=await(async e=>{const t=0===e.length?o:e,n=[];for(const e of t){const t=r[e];if(t){if(t.initialized)return t.backend;if(t.aborted)continue;const r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init()),await t.initPromise,t.initialized=!0,t.backend}catch(o){r||n.push({name:e,err:o}),t.aborted=!0}finally{delete t.initPromise}}}throw new Error(`no available backend found. ERR: ${n.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`)})(u),c=await l.createSessionHandler(a,s);return new d(c)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}const f=d},5716:(e,t,n)=>{"use strict";t.R=void 0;const r=n(6027),o=n(1723);t.R=new class{async init(){}async createSessionHandler(e,t){const n=new r.Session(t);return await n.loadModel(e),new o.OnnxjsSessionHandler(n)}}},2818:(e,t,n)=>{"use strict";t.c8=t.rX=void 0;const r=n(8453),o=n(5381),i=n(9544),a=n(6640);t.rX=()=>{if(("number"!=typeof r.env.wasm.initTimeout||r.env.wasm.initTimeout<0)&&(r.env.wasm.initTimeout=0),"boolean"!=typeof r.env.wasm.simd&&(r.env.wasm.simd=!0),"boolean"!=typeof r.env.wasm.proxy&&(r.env.wasm.proxy=!1),"number"!=typeof r.env.wasm.numThreads||!Number.isInteger(r.env.wasm.numThreads)||r.env.wasm.numThreads<=0){const e="undefined"==typeof navigator?(0,o.cpus)().length:navigator.hardwareConcurrency;r.env.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},t.c8=new class{async init(){(0,t.rX)(),await(0,i.initWasm)()}async createSessionHandler(e,t){const n=new a.OnnxruntimeWebAssemblySessionHandler;return await n.loadModel(e,t),Promise.resolve(n)}}},1057:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var o=Object.getOwnPropertyDescriptor(t,n);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,o)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),o=this&&this.__exportStar||function(e,t){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(t,n)||r(t,e,n)};Object.defineProperty(t,"__esModule",{value:!0}),o(n(8453),t);const i=n(8453);{const e=n(5716).R;(0,i.registerBackend)("webgl",e,-10)}{const e=n(2818).c8;(0,i.registerBackend)("cpu",e,10),(0,i.registerBackend)("wasm",e,10),(0,i.registerBackend)("xnnpack",e,9)}},4910:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createAttributeWithCacheKey=void 0;class n{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this._cacheKey}}t.createAttributeWithCacheKey=e=>new n(e)},6874:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Attribute=void 0;const r=n(1446),o=n(1287),i=n(9240),a=n(7273);var s=o.onnxruntime.experimental.fbs;class u{constructor(e){if(this._attributes=new Map,null!=e){for(const t of e)t instanceof r.onnx.AttributeProto?this._attributes.set(t.name,[u.getValue(t),u.getType(t)]):t instanceof s.Attribute&&this._attributes.set(t.name(),[u.getValue(t),u.getType(t)]);if(this._attributes.size<e.length)throw new Error("duplicated attribute names")}}set(e,t,n){this._attributes.set(e,[n,t])}delete(e){this._attributes.delete(e)}getFloat(e,t){return this.get(e,"float",t)}getInt(e,t){return this.get(e,"int",t)}getString(e,t){return this.get(e,"string",t)}getTensor(e,t){return this.get(e,"tensor",t)}getFloats(e,t){return this.get(e,"floats",t)}getInts(e,t){return this.get(e,"ints",t)}getStrings(e,t){return this.get(e,"strings",t)}getTensors(e,t){return this.get(e,"tensors",t)}get(e,t,n){const r=this._attributes.get(e);if(void 0===r){if(void 0!==n)return n;throw new Error(`required attribute not found: ${e}`)}if(r[1]!==t)throw new Error(`type mismatch: expected ${t} but got ${r[1]}`);return r[0]}static getType(e){const t=e instanceof r.onnx.AttributeProto?e.type:e.type();switch(t){case r.onnx.AttributeProto.AttributeType.FLOAT:return"float";case r.onnx.AttributeProto.AttributeType.INT:return"int";case r.onnx.AttributeProto.AttributeType.STRING:return"string";case r.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case r.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case r.onnx.AttributeProto.AttributeType.INTS:return"ints";case r.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case r.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${r.onnx.AttributeProto.AttributeType[t]}`)}}static getValue(e){const t=e instanceof r.onnx.AttributeProto?e.type:e.type();if(t===r.onnx.AttributeProto.AttributeType.GRAPH||t===r.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const n=this.getValueNoCheck(e);if(t===r.onnx.AttributeProto.AttributeType.INT&&a.LongUtil.isLong(n))return a.LongUtil.longToNumber(n);if(t===r.onnx.AttributeProto.AttributeType.INTS){const e=n,t=new Array(e.length);for(let n=0;n<e.length;n++){const r=e[n];t[n]=a.LongUtil.longToNumber(r)}return t}if(t===r.onnx.AttributeProto.AttributeType.TENSOR)return e instanceof r.onnx.AttributeProto?i.Tensor.fromProto(n):i.Tensor.fromOrtTensor(n);if(t===r.onnx.AttributeProto.AttributeType.TENSORS){if(e instanceof r.onnx.AttributeProto)return n.map((e=>i.Tensor.fromProto(e)));if(e instanceof s.Attribute)return n.map((e=>i.Tensor.fromOrtTensor(e)))}if(t===r.onnx.AttributeProto.AttributeType.STRING&&e instanceof r.onnx.AttributeProto){const e=n;return(0,a.decodeUtf8String)(e)}return t===r.onnx.AttributeProto.AttributeType.STRINGS&&e instanceof r.onnx.AttributeProto?n.map(a.decodeUtf8String):n}static getValueNoCheck(e){return e instanceof r.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(e):this.getValueNoCheckFromOrtFormat(e)}static getValueNoCheckFromOnnxFormat(e){switch(e.type){case r.onnx.AttributeProto.AttributeType.FLOAT:return e.f;case r.onnx.AttributeProto.AttributeType.INT:return e.i;case r.onnx.AttributeProto.AttributeType.STRING:return e.s;case r.onnx.AttributeProto.AttributeType.TENSOR:return e.t;case r.onnx.AttributeProto.AttributeType.GRAPH:return e.g;case r.onnx.AttributeProto.AttributeType.FLOATS:return e.floats;case r.onnx.AttributeProto.AttributeType.INTS:return e.ints;case r.onnx.AttributeProto.AttributeType.STRINGS:return e.strings;case r.onnx.AttributeProto.AttributeType.TENSORS:return e.tensors;case r.onnx.AttributeProto.AttributeType.GRAPHS:return e.graphs;default:throw new Error(`unsupported attribute type: ${r.onnx.AttributeProto.AttributeType[e.type]}`)}}static getValueNoCheckFromOrtFormat(e){switch(e.type()){case s.AttributeType.FLOAT:return e.f();case s.AttributeType.INT:return e.i();case s.AttributeType.STRING:return e.s();case s.AttributeType.TENSOR:return e.t();case s.AttributeType.GRAPH:return e.g();case s.AttributeType.FLOATS:return e.floatsArray();case s.AttributeType.INTS:{const t=[];for(let n=0;n<e.intsLength();n++)t.push(e.ints(n));return t}case s.AttributeType.STRINGS:{const t=[];for(let n=0;n<e.stringsLength();n++)t.push(e.strings(n));return t}case s.AttributeType.TENSORS:{const t=[];for(let n=0;n<e.tensorsLength();n++)t.push(e.tensors(n));return t}default:throw new Error(`unsupported attribute type: ${s.AttributeType[e.type()]}`)}}}t.Attribute=u},1975:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.resolveBackend=t.backend=void 0;const r=n(4418),o=new Map;async function i(e){const n=t.backend;if(void 0!==n[e]&&function(e){const t=e;return"initialize"in t&&"function"==typeof t.initialize&&"createSessionHandler"in t&&"function"==typeof t.createSessionHandler&&"dispose"in t&&"function"==typeof t.dispose}(n[e])){const t=n[e];let r=t.initialize();if("object"==typeof r&&"then"in r&&(r=await r),r)return o.set(e,t),t}}t.backend={webgl:new r.WebGLBackend},t.resolveBackend=async function e(t){if(!t)return e(["webgl"]);{const e="string"==typeof t?[t]:t;for(const t of e){const e=o.get(t);if(e)return e;const n=await i(t);if(n)return n}}throw new Error("no available backend to use")}},4418:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLBackend=void 0;const r=n(8453),o=n(1315),i=n(2171),a=n(3389);t.WebGLBackend=class{get contextId(){return r.env.webgl.contextId}set contextId(e){r.env.webgl.contextId=e}get matmulMaxBatchSize(){return r.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(e){r.env.webgl.matmulMaxBatchSize=e}get textureCacheMode(){return r.env.webgl.textureCacheMode}set textureCacheMode(e){r.env.webgl.textureCacheMode=e}get pack(){return r.env.webgl.pack}set pack(e){r.env.webgl.pack=e}get async(){return r.env.webgl.async}set async(e){r.env.webgl.async=e}initialize(){try{return this.glContext=(0,a.createWebGLContext)(this.contextId),"number"!=typeof this.matmulMaxBatchSize&&(this.matmulMaxBatchSize=16),"string"!=typeof this.textureCacheMode&&(this.textureCacheMode="full"),"boolean"!=typeof this.pack&&(this.pack=!1),"boolean"!=typeof this.async&&(this.async=!1),o.Logger.setWithEnv(r.env),o.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(e){return o.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${e}`),!1}}createSessionHandler(e){return new i.WebGLSessionHandler(this,e)}dispose(){this.glContext.dispose()}}},6859:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.CoordsGlslLib=void 0;const r=n(7273),o=n(1997),i=n(6757),a=n(7618),s=n(432);class u extends o.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new o.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ")}}coordsToOffset(){return{coordsToOffset:new o.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ")}}getOutputSamplingSnippet(){const e=this.context.outputTextureLayout;return e.isPacked?this.getPackedOutputSamplingSnippet(e):this.getUnpackedOutputSamplingSnippet(e)}getPackedOutputSamplingSnippet(e){const t=e.unpackedShape,n=[e.width,e.height],r={},a="getOutputCoords";switch(t.length){case 0:r[a]=this.getOutputScalarCoords();break;case 1:r[a]=this.getOutputPacked1DCoords(t,n);break;case 2:r[a]=this.getOutputPacked2DCoords(t,n);break;case 3:r[a]=this.getOutputPacked3DCoords(t,n);break;default:r[a]=this.getOutputPackedNDCoords(t,n)}const s=`\n      void setOutput(vec4 val) {\n        ${(0,i.getGlsl)(this.context.glContext.version).output} = val;\n      }\n    `;return r.floatTextureSetRGBA=new o.GlslLibRoutine(s),r}getUnpackedOutputSamplingSnippet(e){const t=e.unpackedShape,n=[e.width,e.height],r={},a="getOutputCoords";switch(t.length){case 0:r[a]=this.getOutputScalarCoords();break;case 1:r[a]=this.getOutputUnpacked1DCoords(t,n);break;case 2:r[a]=this.getOutputUnpacked2DCoords(t,n);break;case 3:r[a]=this.getOutputUnpacked3DCoords(t,n);break;case 4:r[a]=this.getOutputUnpacked4DCoords(t,n);break;case 5:r[a]=this.getOutputUnpacked5DCoords(t,n);break;case 6:r[a]=this.getOutputUnpacked6DCoords(t,n);break;default:throw new Error(`Unsupported output dimensionality: ${t.length}`)}const s=`\n        void setOutput(float val) {\n          ${(0,i.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\n        }\n    `;return r.floatTextureSetR=new o.GlslLibRoutine(s),r}getOutputScalarCoords(){return new o.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ")}getOutputPacked1DCoords(e,t){const n=t;let r="";return 1===n[0]?(r=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${n[1]}.0);\n          }\n        `,new o.GlslLibRoutine(r)):1===n[1]?(r=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${n[0]}.0);\n          }\n        `,new o.GlslLibRoutine(r)):(r=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${n[0]}, ${n[1]}));\n          return 2 * (resTexRC.y * ${n[0]} + resTexRC.x);\n        }\n      `,new o.GlslLibRoutine(r))}getOutputPacked2DCoords(e,t){let n="";if(r.ArrayUtil.arraysEqual(e,t))return n=`\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${t[0]}, ${t[1]}));\n        }\n      `,new o.GlslLibRoutine(n);const i=t,a=Math.ceil(e[1]/2);return n=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${i[0]}, ${i[1]}));\n\n          int index = resTexRC.y * ${i[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${a}) * 2;\n          int c = 2 * (index / ${a});\n\n          return ivec2(r, c);\n        }\n      `,new o.GlslLibRoutine(n)}getOutputPacked3DCoords(e,t){const n=[t[0],t[1]],r=Math.ceil(e[2]/2),i=r*Math.ceil(e[1]/2),a=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${n[0]}, ${n[1]}));\n          int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n          int b = index / ${i};\n          index -= b * ${i};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${r}) * 2;\n          int c = 2 * (index / ${r});\n\n          return ivec3(b, r, c);\n        }\n      `;return new o.GlslLibRoutine(a)}getOutputPackedNDCoords(e,t){const n=[t[0],t[1]],r=Math.ceil(e[e.length-1]/2),i=r*Math.ceil(e[e.length-2]/2);let a=i,s="",u="b, r, c";for(let t=2;t<e.length-1;t++)a*=e[e.length-t-1],s=`\n      int b${t} = index / ${a};\n      index -= b${t} * ${a};\n    `+s,u=`b${t}, `+u;const l=`\n      ivec${e.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n        ${s}\n\n        int b = index / ${i};\n        index -= b * ${i};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${r}) * 2;\n        int c = 2 * (index / ${r});\n\n        return ivec${e.length}(${u});\n      }\n    `;return new o.GlslLibRoutine(l)}getOutputUnpacked1DCoords(e,t){const n=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          return resTexRC.y * ${t[0]} + resTexRC.x;\n        }\n      `;return new o.GlslLibRoutine(n)}getOutputUnpacked2DCoords(e,t){const n=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          int r = index / ${e[1]};\n          int c = index - r * ${e[1]};\n          return ivec2(r, c);\n        }\n      `;return new o.GlslLibRoutine(n)}getOutputUnpacked3DCoords(e,t){let n="";const r=e.length;let i=null;r<2&&(i=[]),i=new Array(r-1),i[r-2]=e[r-1];for(let t=r-3;t>=0;--t)i[t]=i[t+1]*e[t+1];const a=["r","c","d"],s=i.map(((e,t)=>`int ${a[t]} = index / ${e}; ${t===i.length-1?`int ${a[t+1]} = index - ${a[t]} * ${e}`:`index -= ${a[t]} * ${e}`};`)).join("");return n=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${s}\n          return ivec3(r, c, d);\n        }\n      `,new o.GlslLibRoutine(n)}getOutputUnpacked4DCoords(e,t){let n="";const r=e.length;let i=null;r<2&&(i=[]),i=new Array(r-1),i[r-2]=e[r-1];for(let t=r-3;t>=0;--t)i[t]=i[t+1]*e[t+1];const a=["r","c","d","d2"],s=i.map(((e,t)=>`int ${a[t]} = index / ${e}; ${t===i.length-1?`int ${a[t+1]} = index - ${a[t]} * ${e}`:`index -= ${a[t]} * ${e}`};`)).join("");return n=`\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${s}\n          return ivec4(r, c, d, d2);\n        }\n      `,new o.GlslLibRoutine(n)}getOutputUnpacked5DCoords(e,t){let n="";const r=e.length;let i=null;r<2&&(i=[]),i=new Array(r-1),i[r-2]=e[r-1];for(let t=r-3;t>=0;--t)i[t]=i[t+1]*e[t+1];const a=["r","c","d","d2","d3"],s=i.map(((e,t)=>`int ${a[t]} = index / ${e}; ${t===i.length-1?`int ${a[t+1]} = index - ${a[t]} * ${e}`:`index -= ${a[t]} * ${e}`};`)).join("");return n=`\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${s}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `,new o.GlslLibRoutine(n)}getOutputUnpacked6DCoords(e,t){let n="";const r=e.length;let i=null;r<2&&(i=[]),i=new Array(r-1),i[r-2]=e[r-1];for(let t=r-3;t>=0;--t)i[t]=i[t+1]*e[t+1];const a=["r","c","d","d2","d3","d4"],s=i.map(((e,t)=>`int ${a[t]} = index / ${e}; ${t===i.length-1?`int ${a[t+1]} = index - ${a[t]} * ${e}`:`index -= ${a[t]} * ${e}`};`)).join("");return n=`\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${t[0]}, ${t[1]}));\n         int index = resTexRC.y * ${t[0]} + resTexRC.x;\n         ${s}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `,new o.GlslLibRoutine(n)}getCommonUtilFuncs(){const e={};let t="uvFromFlat";e[t]=new o.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "),t="packedUVfrom1D",e[t]=new o.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),t="packedUVfrom2D",e[t]=new o.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),t="packedUVfrom3D",e[t]=new o.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),t="sampleTexture";const n=(0,i.getGlsl)(this.context.glContext.version);return e[t]=new o.GlslLibRoutine(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${n.texture2D}(textureSampler, uv).r;\n        }`),e}getInputsSamplingSnippets(){const e={},t=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach(((n,r)=>{const o=this.context.inputTextureLayouts[r],i=(0,s.generateShaderFuncNameFromInputSamplerName)(n);o.isPacked?e[i]=this.getPackedSamplerFromInput(i,n,o):e[i]=this.getUnpackedSamplerFromInput(i,n,o);const a=(0,s.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n);o.unpackedShape.length<=t.unpackedShape.length&&(o.isPacked?e[a]=this.getPackedSamplerAtOutputCoords(a,o,t,n):e[a]=this.getUnpackedSamplerAtOutputCoords(a,o,t,n))})),e}getPackedSamplerAtOutputCoords(e,t,n,i){const a=t.unpackedShape,u=n.unpackedShape,l=i,c=(0,s.generateShaderFuncNameFromInputSamplerName)(l),p=a.length,d=u.length,f=r.BroadcastUtil.getBroadcastDims(a,u),h=(0,s.getCoordsDataType)(d),g=d-p;let m;const b=(0,s.getGlChannels)();m=0===p?"":d<2&&f.length>=1?"coords = 0;":f.map((e=>`coords.${b[e+g]} = 0;`)).join("\n");let y="";y=d<2&&p>0?"coords":a.map(((e,t)=>`coords.${b[t+g]}`)).join(", ");let w="return outputValue;";const _=1===r.ShapeUtil.size(a),v=1===r.ShapeUtil.size(u);if(1!==p||_||v){if(_&&!v)w=1===d?"\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        ":"\n          return vec4(outputValue.x);\n        ";else if(f.length){const e=p-2,t=p-1;f.indexOf(e)>-1&&f.indexOf(t)>-1?w="return vec4(outputValue.x);":f.indexOf(e)>-1?w="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":f.indexOf(t)>-1&&(w="return vec4(outputValue.xx, outputValue.zz);")}}else w="\n        return vec4(outputValue.xy, outputValue.xy);\n      ";const x=`\n      vec4 ${e}() {\n        ${h} coords = getOutputCoords();\n        \n        int lastDim = coords.${b[d-1]};\n        coords.${b[d-1]} = coords.${b[d-2]};\n        coords.${b[d-2]} = lastDim;\n      \n        ${m}\n        vec4 outputValue = ${c}(${y});\n        ${w}\n      }\n    `;return new o.GlslLibRoutine(x,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(e,t,n,i){const a=[n.width,n.height],u=[t.width,t.height],l=t.unpackedShape.length,c=n.unpackedShape.length,p=t.unpackedShape,d=n.unpackedShape,f=(0,s.generateShaderFuncNameFromInputSamplerName)(i);if(l===c&&r.ArrayUtil.arraysEqual(u,a)){const t=`\n          float ${e}() {\n            return sampleTexture(${i}, TexCoords);\n          }\n        `;return new o.GlslLibRoutine(t,["coordinates.sampleTexture"])}const h=(0,s.getCoordsDataType)(c),g=r.BroadcastUtil.getBroadcastDims(p,d),m=c-l;let b;const y=(0,s.getGlChannels)();b=0===l?"":c<2&&g.length>=1?"coords = 0;":g.map((e=>`coords.${y[e+m]} = 0;`)).join("\n");let w="";w=c<2&&l>0?"coords":t.unpackedShape.map(((e,t)=>`coords.${y[t+m]}`)).join(", ");const _=`\n        float ${e}() {\n          ${h} coords = getOutputCoords();\n          ${b}\n          return ${f}(${w});\n        }\n      `;return new o.GlslLibRoutine(_,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(e,t,n){switch(n.unpackedShape.length){case 0:return this.getPackedSamplerScalar(e,t);case 1:return this.getPackedSampler1D(e,t,n);case 2:return this.getPackedSampler2D(e,t,n);case 3:return this.getPackedSampler3D(e,t,n);default:return this.getPackedSamplerND(e,t,n)}}getUnpackedSamplerFromInput(e,t,n){const r=n.unpackedShape;switch(r.length){case 0:return this.getUnpackedSamplerScalar(e,t,n);case 1:return this.getUnpackedSampler1D(e,t,n);case 2:return this.getUnpackedSampler2D(e,t,n);case 3:return this.getUnpackedSampler3D(e,t,n);case 4:return this.getUnpackedSampler4D(e,t,n);case 5:return this.getUnpackedSampler5D(e,t,n);case 6:return this.getUnpackedSampler6D(e,t,n);default:throw new Error(`Unsupported dimension ${r.length}-D`)}}getPackedSamplerScalar(e,t){const n=`\n          vec4 ${e}() {\n            return ${(0,i.getGlsl)(this.context.glContext.version).texture2D}(${t}, halfCR);\n          }\n        `;return new o.GlslLibRoutine(n)}getPackedSampler1D(e,t,n){const r=[n.width,n.height],a=[r[1],r[0]],s=(0,i.getGlsl)(this.context.glContext.version),u=`vec4 ${e}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${a[0]}, ${a[1]}, index);\n      return ${s.texture2D}(${t}, uv);\n    }`;return new o.GlslLibRoutine(u,["coordinates.packedUVfrom1D"])}getPackedSampler2D(e,t,n){const a=n.unpackedShape,s=[n.width,n.height],u=(0,i.getGlsl)(this.context.glContext.version),l=s[0],c=s[1];if(null!=s&&r.ArrayUtil.arraysEqual(a,s)){const n=`vec4 ${e}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${l}.0);\n        return ${u.texture2D}(${t}, uv);\n      }`;return new o.GlslLibRoutine(n)}const p=s,d=Math.ceil(a[1]/2),f=`vec4 ${e}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${d}, row, col);\n      return ${u.texture2D}(${t}, uv);\n    }`;return new o.GlslLibRoutine(f,["coordinates.packedUVfrom2D"])}getPackedSampler3D(e,t,n){const r=n.unpackedShape,a=[n.width,n.height],u=[a[0],a[1]],l=(0,i.getGlsl)(this.context.glContext.version);if(1===r[0]){const i=r.slice(1),a=[1,2],u=(0,s.squeezeInputShape)(r,i),l=["b","row","col"],c=JSON.parse(JSON.stringify(n));c.unpackedShape=u;const p=this.getPackedSamplerFromInput(e,t,c),d=`${p.routineBody}\n      vec4 ${e}(int b, int row, int col) {\n        return ${e}(${(0,s.getSqueezedParams)(l,a)});\n      } `;return new o.GlslLibRoutine(d,p.dependencies)}const c=u[0],p=u[1],d=Math.ceil(r[2]/2),f=`vec4 ${e}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${p}, ${c}, ${d*Math.ceil(r[1]/2)}, ${d}, b, row, col);\n      return ${l.texture2D}(${t}, uv);}`;return new o.GlslLibRoutine(f,["coordinates.packedUVfrom3D"])}getPackedSamplerND(e,t,n){const r=n.unpackedShape,a=r.length,s=[n.width,n.height],u=(0,i.getGlsl)(this.context.glContext.version),l=[s[0],s[1]],c=l[1],p=l[0],d=Math.ceil(r[a-1]/2);let f=d*Math.ceil(r[a-2]/2),h="int b, int row, int col",g=`b * ${f} + (row / 2) * ${d} + (col / 2)`;for(let e=2;e<a-1;e++)h=`int b${e}, `+h,f*=r[a-e-1],g=`b${e} * ${f} + `+g;const m=`vec4 ${e}(${h}) {\n      int index = ${g};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${c});\n      return ${u.texture2D}(${t}, uv);\n    }`;return new o.GlslLibRoutine(m)}getUnpackedSamplerScalar(e,t,n){const[r,i]=[n.width,n.height];if(1===r&&1===i){const n=`\n          float ${e}() {\n            return sampleTexture(${t}, halfCR);\n          }\n        `;return new o.GlslLibRoutine(n,["coordinates.sampleTexture"])}const a=`\n        float ${e}() {\n          int offset_${t} = coordsToOffset(TexCoords, ${r}, ${i});\n          vec2 uv = uvFromFlat(${r}, ${i}, offset_${t});\n          return sampleTexture(${t}, uv);\n        }\n      `;return new o.GlslLibRoutine(a,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(e,t,n){const r=n.width,i=n.height;if(1===i&&1===r){const n=`\n        float ${e}(int index) {\n          return sampleTexture(${t}, halfCR);\n        }\n      `;return new o.GlslLibRoutine(n,["coordinates.sampleTexture"])}if(1===i){const n=`\n          float ${e}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${r}.0, 0.5);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new o.GlslLibRoutine(n,["coordinates.sampleTexture"])}if(1===r){const n=`\n          float ${e}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${i}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new o.GlslLibRoutine(n,["coordinates.sampleTexture"])}const a=`\n        float ${e}(int index) {\n          vec2 uv = uvFromFlat(${r}, ${i}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new o.GlslLibRoutine(a,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(e,t,n){const i=n.unpackedShape,u=[n.height,n.width];if(null!=u&&r.ArrayUtil.arraysEqual(i,u)){const n=`\n          float ${e}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u[1]}.0, ${u[0]}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new o.GlslLibRoutine(n,["coordinates.sampleTexture"])}const{newShape:l,keptDims:c}=(0,a.squeezeShape)(i),p=l;if(p.length<i.length){const r=(0,s.squeezeInputShape)(i,p),a=JSON.parse(JSON.stringify(n));a.unpackedShape=r;const u=["col","row"],l=`\n          ${this.getUnpackedSamplerFromInput(e,t,a).routineBody}\n          float ${e}(int row, int col) {\n            return ${e}(${(0,s.getSqueezedParams)(u,c)});\n          }\n        `;return new o.GlslLibRoutine(l,["coordinates.sampleTexture"])}const d=u[1],f=u[0];if(1===f){const n=`\n          float ${e}(int row, int col) {\n            int offset_${t} = coordsToOffset(TexCoords, ${d}, ${f});\n            float index = dot(vec3(row, col, offset_${t}), vec3(${i[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new o.GlslLibRoutine(n,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(1===d){const n=`\n          float ${e}(int row, int col) {\n            int offset_${t} = coordsToOffset(TexCoords, ${d}, ${f});\n            float index = dot(vec3(row, col, offset_${t}), vec3(${i[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${f}.0, 0.5);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new o.GlslLibRoutine(n,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const h=`\n        float ${e}(int row, int col) {\n          int index = col * ${i[1]} + row;\n          vec2 uv = uvFromFlat(${d}, ${f}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new o.GlslLibRoutine(h,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(e,t,n){const r=n.unpackedShape,i=r[1]*r[2],u=r[2],{newShape:l,keptDims:c}=(0,a.squeezeShape)(r),p=l;if(p.length<r.length){const i=(0,s.squeezeInputShape)(r,p),a=["batch","col","row"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=i;const l=this.getUnpackedSamplerFromInput(e,t,u),d=c.reverse(),f=`\n          ${l.routineBody}\n          float ${e}(int batch, int row, int col) {\n            return ${e}(${(0,s.getSqueezedParams)(a,d)});\n          }\n        `;return new o.GlslLibRoutine(f,l.dependencies)}const d=`\n          float ${e}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${i} + col * ${u} + row;\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n            return sampleTexture(${t}, uv);\n          }\n      `;return new o.GlslLibRoutine(d,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(e,t,n){const r=n.unpackedShape,i=r[3],a=r[2]*i,s=`\n        float ${e}(int row, int col, int depth, int depth2) {\n          int index = row * ${r[1]*a} + col * ${a} +\n              depth2 * ${i} + depth;\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new o.GlslLibRoutine(s,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(e,t,n){const r=n.unpackedShape,i=r[4],u=r[3]*i,l=r[2]*u,c=r[1]*l,{newShape:p,keptDims:d}=(0,a.squeezeShape)(r);if(p.length<r.length){const i=(0,s.squeezeInputShape)(r,p),a=["row","col","depth","depth2","depth3"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=i;const l=`\n          ${this.getUnpackedSamplerFromInput(e,t,u).routineBody}\n          float ${e}(int row, int col, int depth, int depth2, int depth3) {\n            return ${e}(${(0,s.getSqueezedParams)(a,d)});\n          }\n        `;return new o.GlslLibRoutine(l,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const f=`\n        float ${e}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${c} + col * ${l} + depth * ${u} +\n          depth3 * ${i} + depth2;\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new o.GlslLibRoutine(f,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(e,t,n){const r=n.unpackedShape,i=r[5],u=r[4]*i,l=r[3]*u,c=r[2]*l,p=r[1]*c,{newShape:d,keptDims:f}=(0,a.squeezeShape)(r);if(d.length<r.length){const i=(0,s.squeezeInputShape)(r,d),a=["row","col","depth","depth2","depth3","depth4"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=i;const l=`\n            ${this.getUnpackedSamplerFromInput(e,t,u).routineBody}\n            float ${e}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${e}(${(0,s.getSqueezedParams)(a,f)});\n            }\n          `;return new o.GlslLibRoutine(l,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const h=`\n          float ${e}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${p} + col * ${c} + depth * ${l} +\n            depth2 * ${u} + depth3 * ${i} + depth4;\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new o.GlslLibRoutine(h,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const e=this.context.outputTextureLayout,t=e.shape.length,n=e.strides,r=e.width,i=e.height,a=[];for(let e=0;e<t-1;++e)a.push(`\n        c[${e}] = offset / ${n[e]};`),a.push(`\n        offset -= c[${e}] * ${n[e]};`);a.push(`\n        c[${t-1}] = offset;`);const s=`\n      void toVec(vec2 texCoords, out int c[${t}]) {\n        int offset = coordsToOffset(texCoords, ${r}, ${i});\n        ${a.join("")}\n      }\n      void toVec(int offset, out int c[${t}]) {\n        ${a.join("")}\n      }\n    `;return{toVec:new o.GlslLibRoutine(s,["coordinates.coordsToOffset"])}}valueFrom(){const e={};return this.context.programInfo.inputNames.forEach(((t,n)=>{const r=this.context.inputTextureLayouts[n],i=(r.unpackedShape.length>0?r.unpackedShape:r.shape).length;let a=`_${t}`;e[a]=new o.GlslLibRoutine(this.getValueFromSingle(t,i,r.width,r.height,!1),[`shapeUtils.indicesToOffset${a}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),a+="_T",e[a]=new o.GlslLibRoutine(this.getValueFromSingle(t,i,r.width,r.height,!0),[`shapeUtils.indicesToOffset${a}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])})),e}getValueFromSingle(e,t,n,r,o){let a=`_${e}`;return o&&(a+="_T"),`\n        float ${a}(int m[${t}]) {\n          int offset = indicesToOffset${a}(m);\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\n          float value = getColorAsFloat(${(0,i.getGlsl)(this.context.glContext.version).texture2D}(${e}, coords));\n          return value;\n        }\n        `}getPackedValueFrom(e,t,n,r,o){let a=`_${e}_Pack`;return o&&(a+="_T"),`\n        vec4 ${a}(int m[${t}]) {\n          int offset = indicesToOffset_${e}(m);\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\n          return ${(0,i.getGlsl)(this.context.glContext.version).texture2D}(${e}, coords);\n        }\n        `}}t.CoordsGlslLib=u},1997:(e,t)=>{"use strict";var n;Object.defineProperty(t,"__esModule",{value:!0}),t.TopologicalSortGlslRoutines=t.GlslLibRoutineNode=t.GlslLibRoutine=t.GlslLib=t.GlslContext=t.FunctionType=void 0,(n=t.FunctionType||(t.FunctionType={}))[n.ValueBased=0]="ValueBased",n[n.Positional=1]="Positional",t.GlslContext=class{constructor(e,t,n,r){this.glContext=e,this.programInfo=t,this.inputTextureLayouts=n,this.outputTextureLayout=r}},t.GlslLib=class{constructor(e){this.context=e}},t.GlslLibRoutine=class{constructor(e,t){this.routineBody=e,this.dependencies=t}},t.GlslLibRoutineNode=class{constructor(e,t,n){this.name=e,this.dependencies=n||[],t&&(this.routineBody=t)}addDependency(e){e&&this.dependencies.push(e)}},t.TopologicalSortGlslRoutines=class{static returnOrderedNodes(e){if(!e||0===e.length)return[];if(1===e.length)return e;const t=new Set,n=new Set,r=new Array;return this.createOrderedNodes(e,t,n,r),r}static createOrderedNodes(e,t,n,r){for(let o=0;o<e.length;++o)this.dfsTraverse(e[o],t,n,r)}static dfsTraverse(e,t,n,r){if(!e||n.has(e.name))return;if(t.has(e.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");t.add(e.name);const o=e.dependencies;if(o&&o.length>0)for(let e=0;e<o.length;++e)this.dfsTraverse(o[e],t,n,r);r.push(e),n.add(e.name),t.delete(e.name)}}},1371:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.EncodingGlslLib=void 0;const r=n(1997);class o extends r.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new r.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ")}}decodeFloat32(){return{decode:new r.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ")}}encodeUint8(){const e=o.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new r.GlslLibRoutine(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${e}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `)}}decodeUint8(){const e=o.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new r.GlslLibRoutine(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${e}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `)}}static isLittleEndian(){const e=new ArrayBuffer(4),t=new Uint32Array(e),n=new Uint8Array(e);if(t[0]=3735928559,239===n[0])return!0;if(222===n[0])return!1;throw new Error("unknown endianness")}}t.EncodingGlslLib=o},2691:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FragColorGlslLib=void 0;const r=n(1997),o=n(6757);class i extends r.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const e=(0,o.getGlsl)(this.context.glContext.version);return{setFragColor:new r.GlslLibRoutine(`\n        void setFragColor(float value) {\n            ${e.output} = encode(value);\n        }\n        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new r.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ",["encoding.decode"])}}}t.FragColorGlslLib=i},3878:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.replaceInlines=void 0;const n=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;t.replaceInlines=function(e){const t={};let r;for(;null!==(r=n.exec(e));){const e=r[3].split(",").map((e=>{const t=e.trim().split(" ");return t&&2===t.length?{type:t[0],name:t[1]}:null})).filter((e=>null!==e));t[r[2]]={params:e,body:r[4]}}for(const n in t){const o="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",n),i=new RegExp(o,"gm");for(;null!==(r=i.exec(e));){const o=r[1],i=r[2],a=r[3].split(","),s=o?`${o} ${i};`:"";let u=t[n].body,l="";t[n].params.forEach(((e,t)=>{e&&(l+=`${e.type} ${e.name} = ${a[t]};\n`)})),u=`${l}\n ${u}`,u=u.replace("return",`${i} = `);const c=`\n      ${s}\n      {\n        ${u}\n      }\n      `;e=e.replace(r[0],c)}}return e.replace(n,"")}},8897:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GlslPreprocessor=void 0;const r=n(1997),o=n(3878),i=n(1248),a=n(6757);t.GlslPreprocessor=class{constructor(e,t,n,o){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new r.GlslContext(e,t,n,o),Object.keys(i.glslRegistry).forEach((e=>{const t=new i.glslRegistry[e](this.context);this.libs[e]=t}));const a=this.glslLibRoutineDependencyGraph;for(const e in this.libs){const t=this.libs[e].getFunctions();for(const n in t){const o=e+"."+n;let i;a[o]?(i=a[o],i.routineBody=t[n].routineBody):(i=new r.GlslLibRoutineNode(o,t[n].routineBody),a[o]=i);const s=t[n].dependencies;if(s)for(let e=0;e<s.length;++e)if(a[s[e]])i.addDependency(a[s[e]]);else{const t=new r.GlslLibRoutineNode(s[e]);a[s[e]]=t,i.addDependency(t)}}}}preprocess(){const e=this.context.programInfo;let t=e.shaderSource;return this.context.programInfo.hasMain||(t=`${t}\n      ${(0,a.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),t=(0,o.replaceInlines)(t),`${(0,a.getFragShaderPreamble)(this.context.glContext.version)}\n    ${this.getUniforms(e.inputNames,e.variables)}\n    ${this.getImports(t)}\n    ${t}`}getImports(e){const t=this.selectGlslLibRoutinesToBeIncluded(e);if(0===t.length)return"";let n="";for(let e=0;e<t.length;++e){if(!t[e].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${t[e].name}`);n+=t[e].routineBody+"\n"}return n}selectGlslLibRoutinesToBeIncluded(e){const t=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n=>{const r=n.split(".")[1];-1!==e.indexOf(r)&&t.push(this.glslLibRoutineDependencyGraph[n])})),r.TopologicalSortGlslRoutines.returnOrderedNodes(t)}getUniforms(e,t){const n=[];if(e)for(const t of e)n.push(`uniform sampler2D ${t};`);if(t)for(const e of t)n.push(`uniform ${e.type} ${e.name}${e.arrayLength?`[${e.arrayLength}]`:""};`);return n.join("\n")}}},1248:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.glslRegistry=void 0;const r=n(6859),o=n(1371),i=n(2691),a=n(9183),s=n(9314);t.glslRegistry={encoding:o.EncodingGlslLib,fragcolor:i.FragColorGlslLib,vec:s.VecGlslLib,shapeUtils:a.ShapeUtilsGlslLib,coordinates:r.CoordsGlslLib}},9183:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ShapeUtilsGlslLib=void 0;const r=n(1997);class o extends r.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const e=this.context.outputTextureLayout.shape.length,t={};return this.context.programInfo.inputNames.forEach(((n,o)=>{const i=this.context.inputTextureLayouts[o].unpackedShape;if(i.length<=e){const o=i.length,a=e-o,s=`bcastIndices_${n}`;let u="";for(let e=0;e<o;++e)u+=`\n          realIndices[${e}] = int( mod(float(bcastedIndices[${a+e}]), ${i[e]}.0) );\n          `;const l=`\n        void ${s} (int bcastedIndices[${e}], out int realIndices[${o}]) {\n          ${u}\n        }\n        `;t[s]=new r.GlslLibRoutine(l)}})),t}bcastMatmulIndex(){const e=this.context.outputTextureLayout.shape.length,t={};return this.context.programInfo.inputNames.forEach(((n,o)=>{const i=this.context.inputTextureLayouts[o].shape;if(!(i.length<2||i.length>e)){const o=i.length,a=e-o,s=`bcastMatmulIndices_${n}`;let u="";for(let e=0;e<o-2;++e)u+=`\n          realIndices[${e}] = int( mod(float(bcastedIndices[${a+e}]), ${i[e]}.0) );\n          `;const l=`\n        void ${s}(int bcastedIndices[${e}], out int realIndices[${o}]) {\n          ${u}\n          realIndices[${o-1}] = bcastedIndices[${e-1}];\n          realIndices[${o-2}] = bcastedIndices[${e-2}];\n        }\n        `;t[s]=new r.GlslLibRoutine(l)}})),t}indicesToOffset(){const e={};return this.context.programInfo.inputNames.forEach(((t,n)=>{const i=this.context.inputTextureLayouts[n].shape,a=this.context.inputTextureLayouts[n].strides,s=i.length;let u=`indicesToOffset_${t}`;e[u]=new r.GlslLibRoutine(o.indexToOffsetSingle(u,s,a)),u=`indicesToOffset_${t}_T`,e[u]=new r.GlslLibRoutine(o.indexToOffsetSingle(u,s,a.slice().reverse()))})),e}static indexToOffsetSingle(e,t,n){let r="";for(let e=t-1;e>=0;--e)r+=`\n        offset += indices[${e}] * ${n[e]};\n        `;return`\n      int ${e}(int indices[${t}]) {\n        int offset = 0;\n        ${r}\n        return offset;\n      }\n      `}offsetToIndices(){const e={};return this.context.programInfo.inputNames.forEach(((t,n)=>{const i=this.context.inputTextureLayouts[n].shape,a=this.context.inputTextureLayouts[n].strides,s=i.length;let u=`offsetToIndices_${t}`;e[u]=new r.GlslLibRoutine(o.offsetToIndicesSingle(u,s,a)),u=`offsetToIndices_${t}_T`,e[u]=new r.GlslLibRoutine(o.offsetToIndicesSingle(u,s,a.slice().reverse()))})),e}static offsetToIndicesSingle(e,t,n){const r=[];for(let e=0;e<t-1;++e)r.push(`\n      indices[${e}] = offset / ${n[e]};`),r.push(`\n        offset -= indices[${e}] * ${n[e]};`);return r.push(`\n      indices[${t-1}] = offset;`),`\n      void ${e}(int offset, out int indices[${t}]) {\n        ${r.join("")}\n      }\n      `}incrementIndices(){const e={};return this.context.programInfo.inputNames.forEach(((t,n)=>{const o=this.context.inputTextureLayouts[n].shape,i=o.length,a=`incrementIndices_${t}`;let s="";for(let e=0;e<i;++e)s+=`\n        shape[${e}] = ${o[e]};`;const u=`\n        void ${a}(int axis, out int indices[${i}]) {\n          int shape[${i}];\n          ${s};\n          for(int i = ${i} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `;e[a]=new r.GlslLibRoutine(u)})),e}}t.ShapeUtilsGlslLib=o},6757:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getDefaultFragShaderMain=t.getFragShaderPreamble=t.getVertexShaderSource=t.getGlsl=void 0;const n={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},r={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function o(e){return 1===e?n:r}t.getGlsl=o,t.getVertexShaderSource=function(e){const t=o(e);return`${t.version}\n      precision highp float;\n      ${t.attribute} vec3 position;\n      ${t.attribute} vec2 textureCoord;\n\n      ${t.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`},t.getFragShaderPreamble=function(e){const t=o(e);return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFrag} vec2 TexCoords;\n    ${t.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `},t.getDefaultFragShaderMain=function(e,t){return`\n  void main() {\n    int indices[${t}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${o(e).output} = result;\n  }\n  `}},9314:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.VecGlslLib=void 0;const r=n(1997);class o extends r.GlslLib{constructor(e){super(e)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const e=this.context.outputTextureLayout.shape.length,t={add:"+=",sub:"-=",mul:"*=",div:"/="},n={};for(const o in t){const i=`${o}Vec`;let a="";for(let n=0;n<e;++n)a+=`\n          dest[${n}] ${t[o]} src[${n}];\n          `;const s=`\n        void ${i}(int src[${e}], out int dest[${e}]) {\n          ${a}\n        }\n        `;n[i]=new r.GlslLibRoutine(s)}return n}copyVec(){const e=this.context.outputTextureLayout.shape.length;let t="";for(let n=0;n<e;++n)t+=`\n        dest[${n}] = src[${n}];\n        `;const n=`\n      void copyVec(int src[${e}], out int dest[${e}]) {\n        ${t}\n      }\n      `;return{copyVec:new r.GlslLibRoutine(n)}}setVecItem(){const e=this.context.outputTextureLayout.shape.length;let t=`\n        if(index < 0)\n            index =${e} + index;\n        if (index == 0)\n            m[0] = value;\n        `;for(let n=1;n<e-1;++n)t+=`\n        else if (index == ${n})\n            m[${n}] = value;\n            `;t+=`\n        else\n            m[${e-1}] = value;\n        `;const n=`\n      void setVecItem(out int m[${e}], int index, int value) {\n        ${t}\n      }\n        `;return{setVecItem:new r.GlslLibRoutine(n)}}getVecItem(){const e=this.context.outputTextureLayout.shape.length;let t=`\n        if(index < 0)\n            index = ${e} + index;\n        if (index == 0)\n            return m[0];\n      `;for(let n=1;n<e-1;++n)t+=`\n        else if (index == ${n})\n            return m[${n}];\n      `;t+=`\n        else\n            return m[${e-1}];\n        `;const n=`\n      int getVecItem(int m[${e}], int index) {\n        ${t}\n      }\n    `;return{getVecItem:new r.GlslLibRoutine(n)}}}t.VecGlslLib=o},7860:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLInferenceHandler=void 0;const r=n(1315),o=n(9240),i=n(7273),a=n(9),s=n(7379),u=n(2488),l=n(540),c=n(3314),p=n(5639);t.WebGLInferenceHandler=class{constructor(e){this.session=e,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,t){return(0,c.calculateTextureWidthAndHeight)(this.session.layoutStrategy,e,t)}executeProgram(e,t){if(t.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");const n=[];for(let r=0;r<e.inputNames.length;++r)n[r]=this.getOrCreateTextureData(t[r],e.inputTypes[r]);const r=((e,t)=>{const n=t.map((e=>`${e.unpackedShape.join(",")};${e.width}x${e.height}`)).join("_");let r=e.name;return e.cacheHint&&(r+="["+e.cacheHint+"]"),r+=":"+n,r})(e,n);let o=this.session.programManager.getArtifact(r);const i=o?o.programInfo:"function"==typeof e.get?e.get():e,a=(0,c.createTextureLayoutFromTextureType)(this.session.layoutStrategy,i.output.dims,i.output.textureType),s=this.createTextureData(a,i.output.type);return o||(o=this.session.programManager.build(i,n,s),this.session.programManager.setArtifact(r,o)),this.runProgram(o,n,s),s}run(e,t){return this.executeProgram(e,t).tensor}runProgram(e,t,n){for(let n=0;n<t.length;++n)if(!!t[n].isPacked!=(e.programInfo.inputTypes[n]===p.TextureType.packed))throw new Error(`input[${n}] property packed inconsistent`);if(!!n.isPacked!=(e.programInfo.output.textureType===p.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(e,t,n)}getOrCreateTextureData(e,t){let n=this.getTextureData(e.dataId,t===p.TextureType.packed);if(!n&&(n=this.getTextureData(e.dataId,t!==p.TextureType.packed),n))return t===p.TextureType.packed?this.pack(n):this.unpack(n);if(!n){const r=(0,c.createTextureLayoutFromTextureType)(this.session.layoutStrategy,e.dims,t);if(t===p.TextureType.packedLastDimension){const n=1,r=4,o=e.dims;if(4===o.length){const i=[o[0],Math.ceil(o[1]*o[2]*o[3]/r)],a=(0,c.createTextureLayoutFromTextureType)(this.session.layoutStrategy,i,t);let s=e.numberData;if(o[1]*o[2]*o[3]%r!=0){const t=o[0],i=o[1]*o[2]*o[3],a=Math.ceil(i*n/r)*r;s=new Float32Array(t*a);for(let r=0;r<t;++r){const t=r*i,o=r*a+r%n*i;s.set(e.numberData.subarray(t,t+i),o)}}return this.createTextureData(a,e.type,s,e,1)}}if(t===p.TextureType.packed){const t=(0,c.createTextureLayoutFromShape)(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),r=this.createTextureData(t,e.type,e.numberData,e,1);n=this.pack(r)}else n=this.createTextureData(r,e.type,e.numberData,e,1)}return n}createTextureDataFromLayoutBindTensor(e,t,n,r){return this.createTextureData(e,t,n,r,1)}createTextureData(e,t,n,o,i){r.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);const a=this.session.textureManager.createTextureFromLayout(t,e,n,i);return this.createTextureDataFromTexture(e,t,a,o)}reshapeUnpacked(e,t){const n=this.getOrCreateTextureData(e,p.TextureType.unpacked),r={channels:n.channels,height:n.height,width:n.width,shape:0!==t.length?t:[1],strides:i.ShapeUtil.computeStrides(t),unpackedShape:t};return this.createTextureDataFromTexture(r,e.type,n.texture).tensor}reshapePacked(e,t){const n=this.getOrCreateTextureData(e,p.TextureType.packed);if((0,s.isReshapeCheap)(e.dims,t)){const r={channels:n.channels,height:n.height,width:n.width,shape:0!==t.length?t:[1],strides:i.ShapeUtil.computeStrides(t),unpackedShape:t,isPacked:!0};return this.createTextureDataFromTexture(r,e.type,n.texture).tensor}const r=(0,s.processDims3D)(e.dims),o=(0,s.processDims3D)(t),a=this.reshapePacked(e,r),u=this.run((0,s.createPackedReshape3DProgramInfoLoader)(this,a,o),[a]);return this.reshapePacked(u,t)}cast(e,t){const n=this.getOrCreateTextureData(e,p.TextureType.unpacked);return this.createTextureDataFromTexture(n,t,n.texture).tensor}createTextureDataFromTexture(e,t,n,r,i){const a=Object.assign(Object.assign({},e),{tensor:r||new o.Tensor(e.unpackedShape,t,(e=>this.readTexture(a)),(async e=>this.readTextureAsync(a)),void 0,i),texture:n});return this.setTextureData(a.tensor.dataId,a,e.isPacked),a}getTextureData(e,t=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,t):t?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,t,n=!1){this.session.isInitializer(e)?this.session.setTextureData(e,t,n):(n?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,t)}isTextureLayoutCached(e,t=!1){return!!this.getTextureData(e.dataId,t)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((e=>this.session.textureManager.releaseTexture(e))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((e=>this.session.textureManager.releaseTexture(e))),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,u.encodeAsUint8)(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,u.encodeAsUint8)(this,e))}pack(e){return this.executeProgram((0,a.createPackProgramInfoLoader)(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram((0,l.createUnpackProgramInfoLoader)(this,e.tensor),[e.tensor])}}},4110:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var o=Object.getOwnPropertyDescriptor(t,n);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,o)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return o(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.WEBGL_OP_RESOLVE_RULES=void 0;const a=n(8817),s=i(n(5194)),u=n(4752),l=n(6668),c=n(9754),p=n(5042),d=n(6742),f=n(4125),h=n(6149),g=n(5378),m=n(6981),b=n(7413),y=n(7006),w=n(8276),_=n(5565),v=n(2834),x=n(1010),T=n(8126),S=n(2801),O=n(565),A=n(2444),E=n(815),I=n(564),$=n(5416),P=n(1240),D=n(5944),k=n(5707),C=i(n(9087)),R=n(7862),M=n(3980);t.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",C.abs],["Acos","","7+",C.acos],["Add","","7+",s.add],["And","","7+",s.and],["Asin","","7+",C.asin],["Atan","","7+",C.atan],["AveragePool","","7+",v.averagePool,v.parseAveragePoolAttributes],["BatchNormalization","","7+",a.batchNormalization,a.parseBatchNormalizationAttributes],["Cast","","6+",u.cast,u.parseCastAttributes],["Ceil","","6+",C.ceil],["Clip","","6-10",C.clip,C.parseClipAttributes],["Clip","","11+",C.clipV11],["Concat","","4+",l.concat,l.parseConcatAttributes],["Conv","","1+",c.conv,c.parseConvAttributes],["ConvTranspose","","1+",p.convTranspose,p.parseConvTransposeAttributes],["Cos","","7+",C.cos],["Div","","7+",s.div],["Dropout","","7+",C.identity],["DepthToSpace","","1+",d.depthToSpace,d.parseDepthToSpaceAttributes],["Equal","","7+",s.equal],["Elu","","6+",C.elu,C.parseEluAttributes],["Exp","","6+",C.exp],["Flatten","","1+",f.flatten,f.parseFlattenAttributes],["Floor","","6+",C.floor],["FusedConv","com.microsoft","1+",c.conv,c.parseConvAttributes],["Gather","","1+",h.gather,h.parseGatherAttributes],["Gemm","","7-10",g.gemm,g.parseGemmAttributesV7],["Gemm","","11+",g.gemm,g.parseGemmAttributesV11],["GlobalAveragePool","","1+",v.globalAveragePool,v.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",v.globalMaxPool],["Greater","","7+",s.greater],["Identity","","1+",C.identity],["ImageScaler","","1+",m.imageScaler,m.parseImageScalerAttributes],["InstanceNormalization","","6+",b.instanceNormalization,b.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",C.leakyRelu,C.parseLeakyReluAttributes],["Less","","7+",s.less],["LRN","","1+",y.lrn,y.parseLrnAttributes],["Log","","6+",C.log],["MatMul","","1+",w.matMul,w.parseMatMulAttributes],["MaxPool","","1+",v.maxPool,v.parseMaxPoolAttributes],["Mul","","7+",s.mul],["Neg","","6+",C.neg],["Not","","1+",C.not],["Or","","7+",s.or],["Pad","","2-10",_.padV2,_.parsePadAttributesV2],["Pad","","11+",_.padV11,_.parsePadAttributesV11],["Pow","","7+",s.pow],["PRelu","","7+",s.pRelu],["ReduceLogSum","","1+",x.reduceLogSum,x.parseReduceAttributes],["ReduceMax","","1+",x.reduceMax,x.parseReduceAttributes],["ReduceMean","","1+",x.reduceMean,x.parseReduceAttributes],["ReduceMin","","1+",x.reduceMin,x.parseReduceAttributes],["ReduceProd","","1+",x.reduceProd,x.parseReduceAttributes],["ReduceSum","","1-12",x.reduceSum,x.parseReduceAttributes],["ReduceSumSquare","","1+",x.reduceLogSumSquare,x.parseReduceAttributes],["Relu","","6+",C.relu],["Reshape","","5+",T.reshape],["Resize","","10",S.resize,S.parseResizeAttributesV10],["Resize","","11+",S.resize,S.parseResizeAttributesV11],["Shape","","1+",O.shape],["Sigmoid","","6+",C.sigmoid],["Sin","","7+",C.sin],["Slice","","10+",A.sliceV10],["Slice","","1-9",A.slice,A.parseSliceAttributes],["Softmax","","1-12",E.softmax,E.parseSoftmaxAttributes],["Softmax","","13+",E.softmaxV13,E.parseSoftmaxAttributesV13],["Split","","2-12",I.split,I.parseSplitAttributes],["Sqrt","","6+",C.sqrt],["Squeeze","","1-12",$.squeeze,$.parseSqueezeAttributes],["Squeeze","","13+",$.squeezeV13],["Sub","","7+",s.sub],["Sum","","6+",P.sum],["Tan","","7+",C.tan],["Tanh","","6+",C.tanh],["Tile","","6+",D.tile],["Transpose","","1+",k.transpose,k.parseTransposeAttributes],["Upsample","","7-8",M.upsample,M.parseUpsampleAttributesV7],["Upsample","","9",M.upsample,M.parseUpsampleAttributesV9],["Unsqueeze","","1-12",R.unsqueeze,R.parseUnsqueezeAttributes],["Unsqueeze","","13+",R.unsqueezeV13],["Xor","","7+",s.xor]]},8817:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseBatchNormalizationAttributes=t.batchNormalization=void 0;const r=n(4910),o=n(6757),i=n(5639),a={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked]};t.batchNormalization=(e,t,n)=>(u(t),[e.run(Object.assign(Object.assign({},a),{cacheHint:n.cacheKey,get:()=>s(e,t,n)}),t)]),t.parseBatchNormalizationAttributes=e=>{const t=e.attributes.getFloat("epsilon",1e-5),n=e.attributes.getFloat("momentum",.9),o=e.attributes.getInt("spatial",1);return(0,r.createAttributeWithCacheKey)({epsilon:t,momentum:n,spatial:o})};const s=(e,t,n)=>{const r=(0,o.getGlsl)(e.session.backend.glContext.version),s=t[0].dims.length,[u,l]=e.calculateTextureWidthAndHeight(t[1].dims,i.TextureType.unpacked),c=`\n  float process(int[${s}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${u}, ${l});\n    float scale = getColorAsFloat(${r.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${r.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${r.texture2D}(Variance, position));\n    float b = getColorAsFloat(${r.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;\n  }`;return Object.assign(Object.assign({},a),{output:{dims:t[0].dims,type:t[0].type,textureType:i.TextureType.unpacked},shaderSource:c})},u=e=>{if(!e||5!==e.length)throw new Error("BatchNormalization requires 5 inputs.");const t=e[0],n=e[1],r=e[2],o=e[3],i=e[4];if(t.dims.length<3||1!==n.dims.length||1!==r.dims.length||1!==o.dims.length||1!==i.dims.length)throw new Error("invalid input shape.");if(n.dims[0]!==t.dims[1]||r.dims[0]!==t.dims[1]||o.dims[0]!==t.dims[1]||i.dims[0]!==t.dims[1])throw new Error("invalid input shape.");if("float32"!==t.type&&"float64"!==t.type||"float32"!==n.type&&"float64"!==n.type||"float32"!==r.type&&"float64"!==r.type||"float32"!==o.type&&"float64"!==o.type||"float32"!==i.type&&"float64"!==i.type)throw new Error("invalid input tensor types.")}},5194:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.xor=t.sub=t.pRelu=t.pow=t.or=t.mul=t.less=t.greater=t.equal=t.div=t.and=t.add=t.glslPRelu=t.glslPow=t.glslXor=t.glslOr=t.glslAnd=t.glslLess=t.glslGreater=t.glslEqual=t.glslSub=t.glslMul=t.glslDiv=t.glslAdd=void 0;const r=n(7273),o=n(1997),i=n(6757),a=n(5639);function s(){const e="add_";return{body:`\n  float ${e}(float a, float b) {\n    return a + b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function u(){const e="div_";return{body:`\n  float ${e}(float a, float b) {\n    return a / b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function l(){const e="mul_";return{body:`\n  float ${e}(float a, float b) {\n    return a * b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function c(){const e="sub_";return{body:`\n  float ${e}(float a, float b) {\n    return a - b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function p(){const e="equal_";return{body:`\n  float ${e}(float a, float b) {\n    return float(a == b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function d(){const e="greater_";return{body:`\n  float ${e}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function f(){const e="less_";return{body:`\n  float ${e}(float a, float b) {\n    return float(a < b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function h(){const e="and_";return{body:`\n  float ${e}(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function g(){const e="or_";return{body:`\n  float ${e}(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function m(){const e="xor_";return{body:`\n  float ${e}(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function b(){return function(e){const t=`${e}_`;return{body:`\n  float ${t}(float a, float b) {\n    return ${e}(a, b);\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return ${e}(v1, v2);\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}("pow")}function y(){const e="prelu_";return{body:`\n  float ${e}(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}t.glslAdd=s,t.glslDiv=u,t.glslMul=l,t.glslSub=c,t.glslEqual=p,t.glslGreater=d,t.glslLess=f,t.glslAnd=h,t.glslOr=g,t.glslXor=m,t.glslPow=b,t.glslPRelu=y;const w=(e,t,n,r=t[0].type,o)=>{const i=e.session.pack?a.TextureType.packed:a.TextureType.unpacked;return{name:n.name,inputNames:["A","B"],inputTypes:[i,i],cacheHint:o,get:()=>_(e,t,n,r)}},_=(e,t,n,o=t[0].type)=>{const s=e.session.pack?a.TextureType.packed:a.TextureType.unpacked,u=!r.ShapeUtil.areEqual(t[0].dims,t[1].dims);let l=t[0].dims;const c=e.session.pack;if(u){const a=r.BroadcastUtil.calcShape(t[0].dims,t[1].dims,!1);if(!a)throw new Error("Can't perform binary op on the given tensors");l=a;const u=l.length,p=0!==t[0].dims.length?t[0].dims.length:1,d=0!==t[1].dims.length?t[1].dims.length:1,f=0!==t[0].dims.length?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",h=0!==t[1].dims.length?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",g=(0,i.getGlsl)(e.session.backend.glContext.version),m=c?`\n      ${n.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${n.name}(a, b);\n        ${g.output} = result;\n      }`:`\n      ${n.body}\n      float process(int indices[${u}]) {\n        int aindices[${p}];\n        int bindices[${d}];\n        ${f}\n        ${h}\n        return ${n.name}(_A(aindices), _B(bindices));\n      }`;return{name:n.name,inputNames:["A","B"],inputTypes:[s,s],output:{dims:l,type:o,textureType:s},shaderSource:m,hasMain:c}}const p=(0,i.getGlsl)(e.session.backend.glContext.version),d=`\n    ${n.body}\n    void main() {\n      vec4 v1 = ${p.texture2D}(A, TexCoords);\n      vec4 v2 = ${p.texture2D}(B, TexCoords);\n      vec4 result = ${n.name}(v1, v2);\n      ${p.output} = result;\n    }\n    `;return{name:n.name,inputNames:["A","B"],inputTypes:[s,s],output:{dims:t[0].dims,type:o,textureType:s},shaderSource:d,hasMain:!0}};t.add=(e,t)=>[e.run(w(e,t,s()),t)],t.and=(e,t)=>[e.run(w(e,t,h(),"bool"),t)],t.div=(e,t)=>[e.run(w(e,t,u()),t)],t.equal=(e,t)=>[e.run(w(e,t,p(),"bool"),t)],t.greater=(e,t)=>[e.run(w(e,t,d(),"bool"),t)],t.less=(e,t)=>[e.run(w(e,t,f(),"bool"),t)],t.mul=(e,t)=>[e.run(w(e,t,l()),t)],t.or=(e,t)=>[e.run(w(e,t,g(),"bool"),t)],t.pow=(e,t)=>[e.run(w(e,t,b()),t)],t.pRelu=(e,t)=>[e.run(w(e,t,y()),t)],t.sub=(e,t)=>[e.run(w(e,t,c()),t)],t.xor=(e,t)=>[e.run(w(e,t,m(),"bool"),t)]},4752:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseCastAttributes=t.cast=void 0;const r=n(7273);t.cast=(e,t,n)=>(o(t),[e.cast(t[0],n)]),t.parseCastAttributes=e=>r.ProtoUtil.tensorDataTypeFromProto(e.attributes.getInt("to"));const o=e=>{if(!e||1!==e.length)throw new Error("Cast requires 1 input.");if("string"===e[0].type)throw new Error("Invalid input type.")}},4595:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedConcatProgramInfoLoader=void 0;const r=n(6757),o=n(5639),i=n(432),a=n(5614);t.createPackedConcatProgramInfoLoader=(e,t,n)=>{const u=(l=t.length,c=n.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:l},((e,t)=>`X${t}`)),inputTypes:Array(l).fill(o.TextureType.packed),cacheHint:c});var l,c;return Object.assign(Object.assign({},u),{get:()=>((e,t,n,u)=>{const l=n[0].dims.slice();if(u>=l.length||u<-1*l.length)throw new Error("axis specified for concat doesn't match input dimensionality");u<0&&(u=l.length+u);const c=l.slice(0);for(let e=1;e<n.length;e++){const t=n[e].dims.slice();for(let e=0;e<l.length;e++)if(e===u)c[u]+=t[e];else if(l[e]!==t[e])throw new Error("non concat dimensions must match")}const p=c.length,d=(0,a.getChannels)("coords",p),f=(0,i.getCoordsDataType)(p),h=(0,a.unpackFromChannel)(),g=n.map((e=>e.dims)),m=(0,i.getGlChannels)(p),b=new Array(g.length-1);b[0]=g[0][u];for(let e=1;e<b.length;e++)b[e]=b[e-1]+g[e][u];const y=m[u],w=m.slice(-2),_=m.join();let v=`if (${y} < ${b[0]}) {\n        return getChannel(\n            getX0(${_}), vec2(${w.join()}));\n        }`;for(let e=1;e<b.length;e++){const t=b[e-1];v+=`\n            if (${y} < ${b[e]}  && ${y} >= ${b[e-1]}) {\n              return getChannel(\n                getX${e}(${s(m,y,t)}),\n                vec2(${s(w,y,t)}));\n            }`}const x=b.length,T=b[b.length-1];v+=`\n            return getChannel(\n              getX${x}(${s(m,y,T)}),\n              vec2(${s(w,y,T)}));`;const S=(0,r.getGlsl)(e.session.backend.glContext.version),O=`\n          ${h}\n          float getValue(${m.map((e=>"int "+e))}) {\n            ${v}\n          }\n\n          void main() {\n            ${f} coords = getOutputCoords();\n            int lastDim = coords.${m[p-1]};\n            coords.${m[p-1]} = coords.${m[p-2]};\n            coords.${m[p-2]} = lastDim;\n\n            vec4 result = vec4(getValue(${d}), 0., 0., 0.);\n\n            ${d[p-1]} = ${d[p-1]} + 1;\n            if (${d[p-1]} < ${c[p-1]}) {\n              result.g = getValue(${d});\n            }\n\n            ${d[p-2]} = ${d[p-2]} + 1;\n            if (${d[p-2]} < ${c[p-2]}) {\n              result.a = getValue(${d});\n            }\n\n            ${d[p-1]} = ${d[p-1]} - 1;\n            if (${d[p-2]} < ${c[p-2]} &&\n                ${d[p-1]} < ${c[p-1]}) {\n              result.b = getValue(${d});\n            }\n            ${S.output} = result;\n          }\n        `;return Object.assign(Object.assign({},t),{output:{dims:c,type:n[0].type,textureType:o.TextureType.packed},shaderSource:O,hasMain:!0})})(e,u,t,n.axis)})};const s=(e,t,n)=>{const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}},6668:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseConcatAttributes=t.concat=void 0;const r=n(4910),o=n(5639),i=n(4595);t.concat=(e,t,n)=>(p(t),e.session.pack&&t[0].dims.length>1?[e.run((0,i.createPackedConcatProgramInfoLoader)(e,t,n),t)]:[e.run(a(e,t,n),t)]);const a=(e,t,n)=>{const r=(i=t.length,a=n.cacheKey,{name:"Concat",inputNames:Array.from({length:i},((e,t)=>`X${t}`)),inputTypes:Array(i).fill(o.TextureType.unpacked),cacheHint:a});var i,a;return Object.assign(Object.assign({},r),{get:()=>((e,t,n,r)=>{const i=n[0].dims.slice();if(r>=i.length||r<-1*i.length)throw new Error("axis specified for concat doesn't match input dimensionality");r<0&&(r=i.length+r);const a=i.slice(0);for(let e=1;e<n.length;e++){const t=n[e].dims.slice();for(let e=0;e<i.length;e++)if(e===r)a[r]+=t[e];else if(i[e]!==t[e])throw new Error("non concat dimensions must match")}const p=a.length,d=new Array(n.length);let f=0;for(let e=0;e<d.length;++e)f+=n[e].dims[r],d[e]=f;let h="";h=n.length<5?s(d):u(d);const g=`\n        ${l(n.length,p)}\n        ${c(d)}\n        ${h}\n        float process(int indices[${p}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${r}]);\n\n          if(textureIndex != 0) {\n            indices[${r}] = indices[${r}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;return Object.assign(Object.assign({},t),{output:{dims:a,type:n[0].type,textureType:o.TextureType.unpacked},shaderSource:g})})(0,r,t,n.axis)})},s=e=>`int getTextureWhereDataResides(int index) {\n      ${e.map(((e,t)=>`if(index<${e}) {return ${t};}\n`)).join("")}\n    }`,u=e=>s(e),l=(e,t)=>{const n=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${t}]) {`];for(let t=0;t<e;++t)0===t?n.push(`\tif (textureIndex == ${t}) { return _X${t}(indices); }`):t===e-1?n.push(`\telse { return _X${t}(indices); }`):n.push(`\telse if (textureIndex == ${t}) { return _X${t}(indices); }`);return n.push("\t}"),n.join("\n")},c=e=>{const t=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let n=0;n<e.length;++n)0===n?t.push(`\tif (index == ${n}) { return ${e[n]}; }`):n===e.length-1?t.push(`\telse { return ${e[n]}; }`):t.push(`\telse if (index == ${n}) { return ${e[n]}; }`);return t.push("\t}"),t.join("\n")};t.parseConcatAttributes=e=>(0,r.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis")});const p=e=>{if(!e||e.length<1)throw new Error("too few inputs");const t=e[0].type,n=e[0].dims.length;if("string"===t)throw new Error("string tensor is not supported yet");for(const r of e){if(r.type!==t)throw new Error("input tensors should be one type");if(r.dims.length!==n)throw new Error("input tensors should have the same shape")}}},7825:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createUnpackedGroupedConvProgramInfoLoader=void 0;const r=n(1315),o=n(6757),i=n(5639),a=n(9754),s=n(2150);t.createUnpackedGroupedConvProgramInfoLoader=(e,t,n)=>{const u=(l=t.length>2,c=n.cacheKey,{name:"GroupedConv",inputNames:l?["X","W","Bias"]:["X","W"],inputTypes:l?[i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked]:[i.TextureType.unpacked,i.TextureType.unpacked],cacheHint:c});var l,c;return Object.assign(Object.assign({},u),{get:()=>((e,t,n,u)=>{const l=t.length>2?"value += getBias(output_channel);":"",c=t[0].dims.slice(),p=t[1].dims.slice(),d=p[0]/u.group;r.Logger.verbose("GroupedConv",`autpPad:${u.autoPad}, dilations:${u.dilations}, group:${u.group}, kernelShape:${u.kernelShape}, pads:${u.pads}, strides:${u.strides}`);const f=(0,a.calculateOutputShape)(c,p,u.dilations,u.pads,u.strides),h=(0,o.getGlsl)(e.session.backend.glContext.version),{activationFunction:g,applyActivation:m}=(0,s.getActivationSnippet)(u),b=`\n  const ivec2 strides = ivec2(${u.strides[0]}, ${u.strides[1]});\n  const ivec2 pads = ivec2(${u.pads[0]}, ${u.pads[1]});\n  ${g}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${d};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {\n      int input_channel = group_id * ${p[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${u.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${c[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${u.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${c[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${l}\n    ${m}\n    ${h.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},n),{output:{dims:f,type:t[0].type,textureType:i.TextureType.unpacked},shaderSource:b,hasMain:!0})})(e,t,u,n)})}},7708:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.conv2DPacked=t.conv2DPackedPointwise=void 0;const r=n(9754),o=n(5950),i=n(5632);t.conv2DPackedPointwise=(e,t,n)=>{const o=t[0].dims,a=t[1].dims,s=(0,r.calculateOutputShape)(o,a,n.dilations,n.pads,n.strides),u=e.reshapePacked(t[0],[o[1],o[2]*o[3]]),l=e.reshapePacked(t[1],[a[0],a[1]]),c=t.length>2?[l,u,t[2]]:[l,u],p=e.run((0,i.createPackedMatmulProgramInfoLoader)(e,c,n),c);return e.reshapePacked(p,s)},t.conv2DPacked=(e,t,n)=>{const a=t[0].dims,s=t[1].dims,u=(0,r.calculateOutputShape)(a,s,n.dilations,n.pads,n.strides),l=e.run((0,o.createPackedIm2ColProgramInfoLoader)(e,t[0],t[1],u,n),[t[0]]),c=e.reshapePacked(t[1],[s[0],s[1]*s[2]*s[3]]),p=3===t.length?[c,l,t[2]]:[c,l],d=e.run((0,i.createPackedMatmulProgramInfoLoader)(e,p,n),p);return e.reshapePacked(d,u)}},5042:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseConvTransposeAttributes=t.convTranspose=void 0;const r=n(4910),o=n(6757),i=n(5639),a=n(2150),s=(e,t,n,r,o,i)=>(e-1)*t+n+(r-1)*o+1-i,u=(e,t,n,r,o)=>{const i=Math.floor(e/2);"SAME_UPPER"===t?(n[r]=i,n[o]=e-i):"SAME_LOWER"===t&&(n[r]=e-i,n[o]=i)};t.convTranspose=(e,t,n)=>(d(t,n),l(e,t,n));const l=(e,t,n)=>{const r=p(n,t);return[c(e,t,r)]},c=(e,t,n)=>e.run(((e,t,n)=>{const r=(s=t.length>2,u=n.cacheKey,{name:"ConvTranspose",inputNames:s?["X","W","B"]:["X","W"],inputTypes:s?[i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked]:[i.TextureType.unpacked,i.TextureType.unpacked],cacheHint:u});var s,u;return Object.assign(Object.assign({},r),{get:()=>((e,t,n,r)=>{const s=t.length>2?"getB(output_channel)":"0.0",u=t[0].dims,l=t[1].dims,c=l[1],p=l[0]/r.group,d=[t[0].dims[0],t[1].dims[1]*r.group,...r.outputShape],f=(0,o.getGlsl)(e.session.backend.glContext.version),{activationFunction:h,applyActivation:g}=(0,a.getActivationSnippet)(r),m=`\n  const ivec2 strides = ivec2(${r.strides[0]}, ${r.strides[1]});\n  const ivec2 pads = ivec2(${r.pads[0]}, ${r.pads[1]});\n  ${h}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${c};\n    int wOutChannel = output_channel - group_id * ${c};\n\n    float value = ${s};\n    for (int inChannelOffset = 0; inChannelOffset < ${p}; inChannelOffset++) {\n      int input_channel = group_id * ${p} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${l[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${l[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${r.dilations[0]}, wHOff * ${r.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${u[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${u[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${g}\n    ${f.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},n),{output:{dims:d,type:t[0].type,textureType:i.TextureType.unpacked},shaderSource:m,hasMain:!0})})(e,t,r,n)})})(e,t,n),t),p=(e,t)=>{const n=e.kernelShape.slice();if(0===e.kernelShape.length)for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e]);const r=e.pads.slice(),o=e.outputShape.slice();((e,t,n,r,o,i,a,l)=>{const c=e.length-2,p=0===l.length;for(let d=0;d<c;++d){const f=p?e[d+2]*i[d]:l[d],h=s(e[d+2],i[d],o[d],t[d],n[d],f);u(h,r,o,d,d+c),p&&l.push(i[d]*(e[d+2]-1)+a[d]+(t[d]-1)*n[d]+1-o[d]-o[d+c])}})(t[0].dims,n,e.dilations,e.autoPad,r,e.strides,e.outputPadding,o);const i=Object.assign({},e);return Object.assign(i,{kernelShape:n,pads:r,outputShape:o,cacheKey:e.cacheKey}),i};t.parseConvTransposeAttributes=e=>{const t=e.attributes,n=(0,a.parseInternalActivationAttributes)(t),o=t.getString("auto_pad","NOTSET"),i=t.getInts("dilations",[1,1]),s=t.getInt("group",1),u=t.getInts("kernel_shape",[]),l=t.getInts("output_padding",[0,0]),c=t.getInts("output_shape",[]),p=t.getInts("pads",[0,0,0,0]),d=t.getInts("strides",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:o,dilations:i,group:s,kernelShape:u,outputPadding:l,outputShape:c,pads:p,strides:d},n))};const d=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length||4!==e[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims[1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const n=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==n))throw new Error("invalid bias");const r=e[0].dims.length-2;if(t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(t.outputPadding.length!==r)throw new Error(`output_padding should be ${r}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape");if("float32"!==e[0].type||"float32"!==e[1].type)throw new Error("ConvTranspose input(X,W) should be float tensor");if(3===e.length&&"float32"!==e[2].type)throw new Error("ConvTranspose input(bias) should be float tensor")}},9754:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseConvAttributes=t.conv=t.calculateOutputShape=void 0;const r=n(4910),o=n(7273),i=n(7825),a=n(7708),s=n(3281),u=n(2150),l=n(1625),c=n(8276);t.calculateOutputShape=(e,t,n,r,o)=>{const i=e[0],a=e.slice(2),s=a.length,u=t[0],l=t.slice(2).map(((e,t)=>e+(e-1)*(n[t]-1))),c=a.map(((e,t)=>e+r[t]+r[t+s])).map(((e,t)=>Math.floor((e-l[t]+o[t])/o[t])));return[i,u].concat(...c)},t.conv=(e,t,n)=>(g(t,n),p(e,t,n));const p=(e,t,n)=>{const r=h(n,t),o=e.session.pack,s=1===r.kernelShape[0]&&1===r.kernelShape[1];return r.group>1?[e.run((0,i.createUnpackedGroupedConvProgramInfoLoader)(e,t,r),t)]:s&&o?[d(e,t,r)]:o&&4===t[0].dims.length&&1===t[0].dims[0]&&!s?[(0,a.conv2DPacked)(e,t,r)]:[f(e,t,r)]},d=(e,n,r)=>{const o=n[0].dims,i=n[1].dims,a=(0,t.calculateOutputShape)(o,i,r.dilations,r.pads,r.strides),s=e.reshapeUnpacked(n[0],[o[1],o[2]*o[3]]),u=e.reshapeUnpacked(n[1],[i[0],i[1]]),l=n.length>2?[u,s,n[2]]:[u,s],p=e.run((0,c.createMatmulProgramInfoLoader)(l,r),l);return e.reshapeUnpacked(p,a)},f=(e,n,r)=>{const o=n[0].dims,i=n[1].dims,a=(0,t.calculateOutputShape)(o,i,r.dilations,r.pads,r.strides),u=e.run((0,l.createIm2ColProgramInfoLoader)(e,n[0],n[1],a,r),[n[0]]),c=3===n.length?[u,n[1],n[2]]:[u,n[1]];return e.run((0,s.createDotProductProgramInfoLoader)(e,n,a,r),c)},h=(e,t)=>{const n=e.kernelShape.slice();if(0===e.kernelShape.length)for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e]);const r=e.pads.slice();o.PoolConvUtil.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,e.autoPad);const i=Object.assign({},e);return Object.assign(i,{kernelShape:n,pads:r,cacheKey:e.cacheKey}),i};t.parseConvAttributes=e=>{const t=e.attributes,n=(0,u.parseInternalActivationAttributes)(t),o=t.getString("auto_pad","NOTSET"),i=t.getInts("dilations",[1,1]),a=t.getInt("group",1),s=t.getInts("kernel_shape",[]),l=t.getInts("pads",[0,0,0,0]),c=t.getInts("strides",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:o,dilations:i,group:a,kernelShape:s,pads:l,strides:c},n))};const g=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length||4!==e[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims[1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");const n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if("float32"!==e[0].type||"float32"!==e[1].type)throw new Error("Conv input(X,W) should be float tensor");if(3===e.length&&"float32"!==e[2].type)throw new Error("Conv input(bias) should be float tensor")}},6742:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseDepthToSpaceAttributes=t.depthToSpace=void 0;const r=n(5707);t.depthToSpace=(e,t,n)=>{o(t);const i=n.blocksize,a=i*i,s="DCR"===n.mode?[0,3,4,1,5,2]:[0,1,4,2,5,3],u="DCR"===n.mode?[t[0].dims[0],i,i,t[0].dims[1]/a,t[0].dims[2],t[0].dims[3]]:[t[0].dims[0],t[0].dims[1]/a,i,i,t[0].dims[2],t[0].dims[3]],l=e.reshapeUnpacked(t[0],u),c={perm:s,cacheKey:`${s}`},[p]=(0,r.transpose)(e,[l],c),d=[t[0].dims[0],t[0].dims[1]/a,t[0].dims[2]*i,t[0].dims[3]*i];return[e.reshapeUnpacked(p,d)]},t.parseDepthToSpaceAttributes=e=>{const t=e.attributes.getInt("blocksize");if(t<1)throw new Error(`blocksize must be >= 1, but got : ${t} for DepthToSpace`);const n=e.attributes.getString("mode","DCR");if("DCR"!==n&&"CRD"!==n)throw new Error(`unrecognized mode: ${n} for DepthToSpace`);return{mode:n,blocksize:t}};const o=e=>{if(1!==e.length)throw new Error(`DepthToSpace expect 1 inputs, but got ${e.length}`);if("string"===e[0].type||4!==e[0].dims.length)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},3281:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createDotProductProgramInfoLoader=void 0;const r=n(7273),o=n(6757),i=n(5639),a=n(2150),s=n(1625);t.createDotProductProgramInfoLoader=(e,t,n,u)=>{const l=((e,t)=>({name:"ConvDotProduct",inputNames:e?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:e?[i.TextureType.unpacked,i.TextureType.packedLastDimension,i.TextureType.unpacked]:[i.TextureType.unpacked,i.TextureType.packedLastDimension],cacheKey:t.activationCacheKey}))(t.length>2,u);return Object.assign(Object.assign({},l),{get:()=>((e,t,n,u,l)=>{const c=n[0].dims,p=n[1].dims,d=[p[0],Math.ceil(c[1]*p[2]*p[3]/4)],f=(0,s.calculateIm2ColDims)(c,p,u),[h,g]=e.calculateTextureWidthAndHeight(d,i.TextureType.packedLastDimension),m=r.ShapeUtil.computeStrides(f),[b,y]=e.calculateTextureWidthAndHeight(f,i.TextureType.packedLastDimension),w=u.length,_=n.length<3?"0.0":"_B(b)",v=Math.ceil(c[1]*p[2]*p[3]/4),{activationFunction:x,applyActivation:T}=(0,a.getActivationSnippet)(l),S=(0,o.getGlsl)(e.session.backend.glContext.version),O=`\n${x}\nfloat process(int indices[${w}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${m[0]} + im2col[1] * ${m[1]} + im2col[2] * ${m[2]};\n  int kernelOffset = indices[1] * ${d[1]};\n  float value = ${_};\n  for (int i = 0; i < ${v}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${b}, ${y});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h}, ${g});\n    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${T}\n  return value;\n}`;return Object.assign(Object.assign({},t),{output:{dims:u,type:n[0].type,textureType:i.TextureType.unpacked},shaderSource:O})})(e,l,t,n,u)})}},4125:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseFlattenAttributes=t.flatten=void 0;const r=n(7273);t.flatten=(e,t,n)=>{o(t,n);const i=r.ShapeUtil.flattenShape(t[0].dims,n);return[e.reshapeUnpacked(t[0],i)]},t.parseFlattenAttributes=e=>e.attributes.getInt("axis",1);const o=(e,t)=>{if(!e||1!==e.length)throw new Error("Flatten requires 1 input.");const n=e[0].dims.length;if(0===n)throw new Error("scalar tensor is not supported.");if(t<-n||t>n)throw new Error("Invalid axis");if("string"===e[0].type)throw new Error("string tensor is not supported.")}},2150:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseInternalActivationAttributes=t.getActivationSnippet=void 0;const r=n(7273),o=n(9087);t.getActivationSnippet=function(e){let t;switch(e.activation){case"Relu":t=(0,o.glslRelu)();break;case"Sigmoid":t=(0,o.glslSigmoid)();break;case"Clip":t=(0,o.glslClip)(e.clipMin,e.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const n=t.name;return{activationFunction:t.body,applyActivation:`value = ${n}_(value);`}},t.parseInternalActivationAttributes=e=>{const t=e.getString("activation","");if("Clip"===t){const[n,o]=e.getFloats("activation_params",[r.MIN_CLIP,r.MAX_CLIP]);return{activation:t,clipMax:o,clipMin:n,activationCacheKey:`${t}:${n},${o}`}}return{activation:t,activationCacheKey:t}}},6149:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseGatherAttributes=t.gather=void 0;const r=n(4910),o=n(6145),i=n(7273),a=n(5639);t.gather=(e,t,n)=>(l(t,n.axis),[e.run(u(e,t,n),t)]),t.parseGatherAttributes=e=>(0,r.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis",0)});const s={name:"Gather",inputNames:["A","B"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked]},u=(e,t,n)=>{const r=Object.assign(Object.assign({},s),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((e,t,n,r)=>{const o=n[0].dims.slice(),s=n[1].dims.slice(),u=new Array(o.length+s.length-1);r=i.ShapeUtil.normalizeAxis(r,o.length);const l=[];for(let e=0;e<u.length;e++)e<r?(u[e]=o[e],l.push(`inputIdx[${e}] = outputIdx[${e}];`)):e<r+s.length?(u[e]=s[e-r],l.push(`indexDataIdx[${e-r}] = outputIdx[${e}];`)):(u[e]=o[e-s.length+1],l.push(`inputIdx[${e-s.length+1}] = outputIdx[${e}];`));const c=`\n      float process(int outputIdx[${u.length||1}]) {\n        int inputIdx[${o.length}];\n        int indexDataIdx[${s.length||1}];\n        indexDataIdx[0] = 0;\n        ${l.join("\n        ")}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${r}] = idx < 0 ? idx + ${o[r]} : idx;\n        return _A(inputIdx);\n      }`;return Object.assign(Object.assign({},t),{output:{dims:u,type:n[0].type,textureType:a.TextureType.unpacked},shaderSource:c})})(0,r,t,n.axis)})},l=(e,t)=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.");const n=e[0].dims.length;if(n<1)throw new Error("Invalid input shape.");if(t<-n||t>n-1)throw new Error("Invalid axis.");if(-1===o.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invaid input type.");if("int32"!==e[1].type&&"int16"!==e[1].type)throw new Error("Invaid input type.")}},5378:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseGemmAttributesV11=t.parseGemmAttributesV7=t.gemm=void 0;const r=n(4910),o=n(7273),i=n(5639);t.gemm=(e,t,n)=>(l(t,n),[e.run(s(t,n),t)]);const a=(e,t)=>{const n=0!==e.attributes.getInt("transA",0),o=0!==e.attributes.getInt("transB",0),i=e.attributes.getFloat("alpha",1),a=e.attributes.getFloat("beta",1);return(0,r.createAttributeWithCacheKey)({transA:n,transB:o,alpha:i,beta:a,isOptionalC:t})};t.parseGemmAttributesV7=e=>a(e,!1),t.parseGemmAttributesV11=e=>a(e,!0);const s=(e,t)=>{const n={name:"Gemm",inputNames:3===e.length?["A","B","C"]:["A","B"],inputTypes:3===e.length?[i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked]:[i.TextureType.unpacked,i.TextureType.unpacked],key:t.cacheKey};return Object.assign(Object.assign({},n),{get:()=>u(n,e,t)})},u=(e,t,n)=>{const r=t[0].dims.slice(),a=t[1].dims.slice(),[s,u]=o.GemmUtil.getShapeOfGemmResult(r,n.transA,a,n.transB,3===t.length?t[2].dims:void 0),l=[s,u];if(!l)throw new Error("Can't use gemm on the given tensors");let c=r[r.length-1],p="";n.transA&&(c=r[0]),n.transA&&n.transB?p="value += _A_T(a) * _B_T(b);":n.transA&&!n.transB?p="value += _A_T(a) * _B(b);":!n.transA&&n.transB?p="value += _A(a) * _B_T(b);":n.transA||n.transB||(p="value += _A(a) * _B(b);");const d=l.length,f=`\n      float process(int indices[${d}]) {\n          int a[${d}];\n          int b[${d}];\n          ${3===t.length?`int c[${t[2].dims.length}];`:""}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${3===t.length?"bcastIndices_C(indices, c);":""}\n\n          float value = 0.0;\n          for (int k=0; k<${c}; ++k) {\n              a[${d-1}] = k;\n              b[${d-2}] = k;\n              ${p}\n          }\n\n          value = value * alpha;\n          ${3===t.length?"value += beta * _C(c);":""}\n          return value;\n      }`;return Object.assign(Object.assign({},e),{output:{dims:l,type:t[0].type,textureType:i.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:n.alpha},{name:"beta",type:"float",data:n.beta}],shaderSource:f})},l=(e,t)=>{if(!e)throw new Error("Input is missing");if(t.isOptionalC&&(e.length<2||e.length>3))throw new Error("Invaid input shape.");if(!t.isOptionalC&&3!==e.length)throw new Error("Gemm requires 3 inputs");if(3===e.length&&1!==e[2].dims.length&&2!==e[2].dims.length)throw new Error("Invalid input shape of C");if("float32"!==e[0].type&&"float64"!==e[0].type||"float32"!==e[1].type&&"float64"!==e[1].type||3===e.length&&"float32"!==e[2].type&&"float64"!==e[2].type)throw new Error("Invalid input type.");if(e[0].type!==e[1].type||3===e.length&&e[0].type!==e[2].type)throw new Error("Input types are mismatched")}},5950:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedIm2ColProgramInfoLoader=void 0;const r=n(6757),o=n(5639),i=n(5614);t.createPackedIm2ColProgramInfoLoader=(e,t,n,a,s)=>{const u=(l=s.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[o.TextureType.packed],cacheHint:l});var l;return Object.assign(Object.assign({},u),{get:()=>((e,t,n,a,s,u)=>{const l=n.dims,c=a.dims,p=s.length,d=[c[1]*c[2]*c[3],s[2]*s[3]],f=c[2]*c[3],h=(0,i.unpackFromChannel)(),g=(0,r.getGlsl)(e.session.backend.glContext.version);let m="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)m+=`\n            blockIndex = rc.x + ${t};\n            pos = rc.y + ${e};\n\n            if(blockIndex < ${d[1]} && pos < ${d[0]}) {\n              offsetY = int(blockIndex / (${s[p-1]})) * ${u.strides[0]} -\n                ${u.pads[0]};\n              d0 = offsetY + ${u.dilations[0]} * (imod(pos, ${f}) / ${c[2]});\n\n              if(d0 < ${l[2]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${s[p-1]}) * ${u.strides[1]} -\n                  ${u.pads[1]};\n                d1 = offsetX + ${u.dilations[1]} * imod(imod(pos, ${f}), ${c[2]});\n\n                if(d1 < ${l[3]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${f}.);\n                    innerDims = vec2(d0, d1);\n                    result[${2*e+t}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;const b=`\n      ${h}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${m}\n          ${g.output} = result;\n      }\n            `;return Object.assign(Object.assign({},t),{output:{dims:d,type:n.type,textureType:o.TextureType.packed},shaderSource:b,hasMain:!0})})(e,u,t,n,a,s)})}},1625:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.calculateIm2ColDims=t.createIm2ColProgramInfoLoader=void 0;const r=n(5639);t.createIm2ColProgramInfoLoader=(e,n,o,i,a)=>{const s=(u=a.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[r.TextureType.unpacked],cacheHint:u});var u;return Object.assign(Object.assign({},s),{get:()=>((e,n,o,i,a,s)=>{const u=o.dims,l=i.dims,c=a.length,p=(0,t.calculateIm2ColDims)(u,l,a,4),d=`\n        const int XC = ${u[1]};\n        const int XH = ${u[2]};\n        const int XW = ${u[3]};\n        const int KH = ${s.kernelShape[0]};\n        const int KW = ${s.kernelShape[1]};\n        const int dilationH = ${s.dilations[0]};\n        const int dilationW = ${s.dilations[1]};\n        const int strideH = ${s.strides[0]};\n        const int strideW = ${s.strides[1]};\n        const int padH = ${s.pads[0]};\n        const int padW = ${s.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${c}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${u.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;return Object.assign(Object.assign({},n),{output:{dims:p,type:o.type,textureType:r.TextureType.packedLastDimension},shaderSource:d})})(0,s,n,o,i,a)})},t.calculateIm2ColDims=(e,t,n,r=4)=>[n[0],n[2],n[3],Math.ceil(e[1]*t[2]*t[3]/r)]},6981:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseImageScalerAttributes=t.imageScaler=void 0;const r=n(4910),o=n(5639);t.imageScaler=(e,t,n)=>(u(t),[e.run(a(e,t,n),t)]),t.parseImageScalerAttributes=e=>{const t=e.attributes.getFloat("scale"),n=e.attributes.getFloats("bias");return(0,r.createAttributeWithCacheKey)({scale:t,bias:n})};const i={name:"ImageScaler",inputNames:["X"],inputTypes:[o.TextureType.unpacked]},a=(e,t,n)=>{const r=Object.assign(Object.assign({},i),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((e,t,n,r)=>{const i=n[0].dims.slice(),a=i.length,u=`\n      ${s(r.bias.length)}\n      float process(int indices[${a}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;return Object.assign(Object.assign({},t),{output:{dims:i,type:n[0].type,textureType:o.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:r.bias.length,data:r.bias},{name:"scale",type:"float",data:r.scale}],shaderSource:u})})(0,r,t,n)})},s=e=>{const t=[`float getBias(float bias[${e}], int channel) {`];for(let n=0;n<e;++n)0===n?t.push(`\tif (channel == ${n}) { return bias[${n}]; }`):n===e-1?t.push(`\telse { return bias[${n}]; }`):t.push(`\telse if (channel == ${n}) { return bias[${n}]; }`);return t.push("\t}"),t.join("\n")},u=e=>{if(!e||1!==e.length)throw new Error("ImageScaler requires 1 input.");if(4!==e[0].dims.length)throw new Error("Invalid input shape.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.")}},7413:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseInstanceNormalizationAttributes=t.instanceNormalization=void 0;const r=n(6757),o=n(5639);t.instanceNormalization=(e,t,n)=>{l(t);const r=e.run(a(t[0]),t);return[e.run(u(e,t[0],n,r.dims),[t[0],r,t[1],t[2]])]},t.parseInstanceNormalizationAttributes=e=>e.attributes.getFloat("epsilon",1e-5);const i={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[o.TextureType.unpacked]},a=e=>Object.assign(Object.assign({},i),{get:()=>((e,t)=>{const n=t.dims.slice(),r=n[1],i=n[2]*n[3],a=[n[0],r],s=`\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${n[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${n[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${i});\n        temp = 0.0;\n        for(int a2=0; a2<${n[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${n[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${i});\n\n        return v;\n      }`;return Object.assign(Object.assign({},e),{output:{dims:a,type:t.type,textureType:o.TextureType.packedLastDimension},shaderSource:s})})(i,e)}),s={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[o.TextureType.unpacked,o.TextureType.packedLastDimension,o.TextureType.unpacked,o.TextureType.unpacked]},u=(e,t,n,i)=>{const a=Object.assign(Object.assign({},s),{cacheHint:`${n}`});return Object.assign(Object.assign({},a),{get:()=>((e,t,n,i,a)=>{const s=(0,r.getGlsl)(e.session.backend.glContext.version),[u,l]=e.calculateTextureWidthAndHeight(a,o.TextureType.packedLastDimension),[c,p]=[u/4,l],d=`\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${c}, ${p});\n        return ${s.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;return Object.assign(Object.assign({},t),{output:{dims:n.dims,type:n.type,textureType:o.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:i}],shaderSource:d})})(e,a,t,n,i)})},l=e=>{if(!e||3!==e.length)throw new Error("InstanceNormalization requires 3 inputs.");const t=e[0],n=e[1],r=e[2];if(t.dims.length<3||1!==n.dims.length||1!==r.dims.length)throw new Error("Invalid input shape.");if(n.dims[0]!==t.dims[1]||r.dims[0]!==t.dims[1])throw new Error("Input shapes are mismatched.");if("float32"!==t.type&&"float64"!==t.type||"float32"!==n.type&&"float64"!==n.type||"float32"!==r.type&&"float64"!==r.type)throw new Error("Invalid input type.");if(4!==e[0].dims.length)throw new Error("Only support 4-D input shape.")}},7006:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createLrnProgramInfoLoader=t.parseLrnAttributes=t.lrn=void 0;const r=n(4910),o=n(5639);t.lrn=(e,t,n)=>(s(t),[e.run(a(t,n),t)]),t.parseLrnAttributes=e=>{const t=e.attributes.getFloat("alpha",1e-4),n=e.attributes.getFloat("beta",.75),o=e.attributes.getFloat("bias",1),i=e.attributes.getInt("size");return(0,r.createAttributeWithCacheKey)({alpha:t,beta:n,bias:o,size:i})};const i={name:"LRN",inputNames:["X"],inputTypes:[o.TextureType.unpacked]};function a(e,t){return Object.assign(Object.assign({},i),{cacheHint:t.cacheKey,get:()=>function(e,t){const n=e[0].dims[1],r=e[0].dims.length,a=-Math.floor((t.size-1)/2),s=Math.ceil((t.size-1)/2),u=`float(${t.alpha}) / float(${t.size})`,l=`\n    float process(int indices[${r}]) {\n        int c = indices[1];\n        float x = _X(indices);\n        float square_sum = 0.0;\n\n        for (int i = ${a}; i <= ${s}; i++) {\n          int idx = c + i;\n          if (c >= 0 && c < ${n}) {\n            indices[1] = idx;\n            float j = _X(indices);\n            square_sum += j * j;\n          }\n        }\n        return x / pow(float(${t.bias}) + ${u} * square_sum, float(${t.beta}));\n    }`;return Object.assign(Object.assign({},i),{cacheHint:t.cacheKey,output:{dims:e[0].dims,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:l})}(e,t)})}t.createLrnProgramInfoLoader=a;const s=e=>{if(!e||1!==e.length)throw new Error("LRN requires 1 input.");if(4!==e[0].dims.length)throw new Error('currently only support LRN for input with "NCHW" format');if("float32"!==e[0].type)throw new Error("input should be float type")}},5632:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedMatmulProgramInfoLoader=void 0;const r=n(7273),o=n(6757),i=n(5639),a=n(432),s=n(2150),u=n(8276);t.createPackedMatmulProgramInfoLoader=(e,t,n)=>{const l=(c=t.length>2,p=n.activationCacheKey,{name:"MatMul (packed)",inputNames:c?["A","B","Bias"]:["A","B"],inputTypes:c?[i.TextureType.packed,i.TextureType.packed,i.TextureType.packed]:[i.TextureType.packed,i.TextureType.packed],cacheHint:p});var c,p;return Object.assign(Object.assign({},l),{get:()=>((e,t,n,l)=>{const c=n.length>2,p=c?"value += getBiasForMatmul();":"",d=n[0].dims,f=n[1].dims,h=r.BroadcastUtil.calcShape(d,f,!0),g=!r.ShapeUtil.areEqual(n[0].dims,n[1].dims);if(!h)throw new Error("Can't use matmul on the given tensors");const m=d[d.length-1],b=Math.ceil(m/2),y=d.length,w=f.length,_=(0,o.getGlsl)(e.session.backend.glContext.version),v=(0,a.getCoordsDataType)(h.length),x=h.length,T=(0,a.getGlChannels)(),{activationFunction:S,applyActivation:O}=(0,s.getActivationSnippet)(l),A=c?`${(0,u.getBiasForMatmul)(v,T,n[2].dims,h,!0)}`:"",E=g?`${function(e,t,n,o){let i=[],a=[];const s=n[0].dims,u=n[1].dims,l=s.length,c=u.length,p=o.length,d=p-l,f=p-c;i=s.map(((e,n)=>`coords.${t[n+d]}`)),i[l-1]="i*2",i.join(", "),a=u.map(((e,n)=>`coords.${t[n+f]}`)),a[c-2]="i*2",a.join(", ");const h=r.BroadcastUtil.getBroadcastDims(s,o),g=r.BroadcastUtil.getBroadcastDims(u,o),m=h.map((e=>`coords.${t[e+d]} = 0;`)).join("\n"),b=g.map((e=>`coords.${t[e+f]} = 0;`)).join("\n"),y=`int lastDim = coords.${t[p-1]};\n  coords.${t[p-1]} = coords.${t[p-2]};\n  coords.${t[p-2]} = lastDim;`;return`\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${e} coords = getOutputCoords();\n  ${y}\n  ${m}\n  vec4 outputValue = getA(${i});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${e} coords = getOutputCoords();\n  ${y}\n  ${b}\n  vec4 outputValue = getB(${a});\n  return outputValue;\n}`}(v,T,n,h)}`:"",I=g?"getAAtOutCoordsMatmul(i)":`getA(${function(e,t){let n="";for(let r=0;r<t-2;r++)n+=`rc.${e[r]}, `;return n+=`rc.${e[t-2]}, i*2`,n}(T,y)})`,$=g?"getBAtOutCoordsMatmul(i)":`getB(${function(e,t){let n="";for(let r=0;r<t-2;r++)n+=`rc.${e[r]}, `;return n+=`i*2, rc.${e[t-1]}`,n}(T,w)})`,P=`\n            ${E}\n            ${A}\n            ${S}\n            void main() {\n              ${g?"":`${v} rc =\n          getOutputCoords(); int lastDim = rc.${T[x-1]}; rc.${T[x-1]} =\n          rc.${T[x-2]}; rc.${T[x-2]} = lastDim;\n      `}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${b}; i++) {\n                vec4 a = ${I};\n                vec4 b = ${$};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${p}\n              ${O}\n              ${_.output} = value;\n            }`;return Object.assign(Object.assign({},t),{output:{dims:h,type:n[0].type,textureType:i.TextureType.packed},shaderSource:P,hasMain:!0})})(e,l,t,n)})}},8276:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getBiasForMatmul=t.createMatmulProgramInfoLoader=t.parseMatMulAttributes=t.matMul=void 0;const r=n(7273),o=n(5639),i=n(432),a=n(2150),s=n(5632);t.matMul=(e,t,n)=>(c(t),e.session.pack?[e.run((0,s.createPackedMatmulProgramInfoLoader)(e,t,n),t)]:[e.run(l(t,n),t)]),t.parseMatMulAttributes=e=>(0,a.parseInternalActivationAttributes)(e.attributes);const u=(e,t)=>({name:"MatMul",inputNames:e?["A","B","Bias"]:["A","B"],inputTypes:e?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],cacheHint:t});function l(e,t){const n=u(e.length>2,t.activationCacheKey);return Object.assign(Object.assign({},n),{get:()=>function(e,t,n){const s=t[0].dims,u=t[1].dims,l=r.BroadcastUtil.calcShape(s,u,!0);if(!l)throw new Error("Can't use matmul on the given tensors");const c=(0,i.getCoordsDataType)(l.length),d=(0,i.getGlChannels)(),{activationFunction:f,applyActivation:h}=(0,a.getActivationSnippet)(n),g=t.length>2,m=g?"value += getBiasForMatmul();":"",b=g?`${p(c,d,t[2].dims,l,!1)}`:"",y=l.length,w=s.length,_=u.length,v=`\n    ${f}\n    ${b}\n    float process(int indices[${y}]) {\n        int a[${w}];\n        int b[${_}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${s[s.length-1]}; ++k) {\n            a[${w-1}] = k;\n            b[${_-2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${m}\n        ${h}\n        return value;\n    }`;return Object.assign(Object.assign({},e),{output:{dims:l,type:t[0].type,textureType:o.TextureType.unpacked},shaderSource:v})}(n,e,t)})}t.createMatmulProgramInfoLoader=l;const c=e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if("float32"!==e[0].type&&"float64"!==e[0].type||"float32"!==e[1].type&&"float64"!==e[1].type)throw new Error("inputs should be float type");if(e[0].type!==e[1].type)throw new Error("inputs types should match")};function p(e,t,n,o,i){let a="";const s=n.length,u=o.length,l=u-s;a=u<2&&s>0?"coords":n.map(((e,n)=>`coords.${t[n+l]}`)).join(", ");const c=r.BroadcastUtil.getBroadcastDims(n,o).map((e=>`coords.${t[e+l]} = 0;`)).join("\n");let p="vec4(outputValue.xx, outputValue.yy)";return 1===r.ShapeUtil.size(n)&&(p="vec4(outputValue.x)"),i?`\nvec4 getBiasForMatmul() {\n  ${e} coords = getOutputCoords();\n  ${c}\n  vec4 outputValue = getBias(${a});\n  return ${p};\n}`:`\nfloat getBiasForMatmul() {\n  ${e} coords = getOutputCoords();\n  ${c}\n  return getBias(coords.x);\n}`}t.getBiasForMatmul=p},9:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createPackProgramInfoLoader=void 0;const r=n(6757),o=n(5639),i=n(432),a=n(5614),s={name:"pack",inputNames:["A"],inputTypes:[o.TextureType.unpackedReversed]};t.createPackProgramInfoLoader=(e,t)=>Object.assign(Object.assign({},s),{get:()=>((e,t)=>{const n=(0,r.getGlsl)(e.session.backend.glContext.version),u=t.dims,l=u.length,c=t.dims.length,p=(0,i.getCoordsDataType)(c),d=(0,a.getChannels)("rc",c),f=(h=c,g=d,m=u[u.length-2],b=u[u.length-1],0===h||1===h?"":`\n    int r = ${g[h-2]};\n    int c = ${g[h-1]};\n    int rp1 = ${g[h-2]} + 1;\n    int cp1 = ${g[h-1]} + 1;\n    bool rEdge = rp1 >= ${b};\n    bool cEdge = cp1 >= ${m};\n    `);var h,g,m,b;let y;y=0===l?[1,1]:1===l?[u[0],1]:[u[c-1],u[c-2]];const w=function(e,t,n){if(0===e)return"false";if(1===e)return`rc > ${t[0]}`;let r="";for(let o=e-2;o<e;o++)r+=`${n[o]} >= ${t[o-e+2]}`,o<e-1&&(r+="||");return r}(c,y,d),_=function(e,t){const n=e.length;if(0===n)return"getA(), 0, 0, 0";if(1===n)return`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`;let r="";if(n>2)for(let e=0;e<n-2;++e)r+=`${t[e]},`;return`getA(${r}r, c),\n          rEdge ? 0. : getA(${r}rp1, c),\n          cEdge ? 0. : getA(${r}r, cp1),\n          rEdge || cEdge ? 0. : getA(${r}rp1, cp1)`}(u,d),v=`\n        void main() {\n          ${p} rc = getOutputCoords();\n\n          if(${w}) {\n            ${n.output} = vec4(0);\n          } else {\n            ${f}\n\n            ${n.output} = vec4(${_});\n          }\n        }\n      `;return Object.assign(Object.assign({},s),{hasMain:!0,output:{dims:t.dims,type:t.type,textureType:o.TextureType.packed},shaderSource:v})})(e,t)})},5614:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.unpackFromChannel=t.getChannels=t.getVecChannels=void 0;const r=n(432);function o(e,t){return(0,r.getGlChannels)(t).map((t=>`${e}.${t}`))}t.getVecChannels=o,t.getChannels=function(e,t){return 1===t?[e]:o(e,t)},t.unpackFromChannel=function(){return"\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  "}},5565:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parsePadAttributesV11=t.padV11=t.parsePadAttributesV2=t.padV2=void 0;const r=n(4910),o=n(7273),i=n(6757),a=n(5639),s={name:"Pad",inputNames:["A"],inputTypes:[a.TextureType.unpacked]};t.padV2=(e,t,n)=>(c(t),[e.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>l(e,t[0],n)}),t)]),t.parsePadAttributesV2=e=>{const t=e.attributes.getString("mode","constant"),n=e.attributes.getFloat("value",0),o=e.attributes.getInts("pads");return(0,r.createAttributeWithCacheKey)({mode:t,value:n,pads:o})},t.padV11=(e,n,r)=>{p(n);const o=u(e,n,r);return(0,t.padV2)(e,[n[0]],o)},t.parsePadAttributesV11=e=>e.attributes.getString("mode","constant");const u=(e,t,n)=>{if(!e.session.isInitializer(t[1].dataId)||t.length>=3&&!e.session.isInitializer(t[2].dataId))throw new Error("dynamic pad attributes are not allowed");const o=Array.from(t[1].integerData),i=t.length>=3?t[2].floatData[0]:0;return(0,r.createAttributeWithCacheKey)({mode:n,pads:o,value:i})},l=(e,t,n)=>{const r=o.ShapeUtil.padShape(t.dims.slice(),n.pads),i=r.length,s=`\n      ${d(e,t,n)}\n      float process(int[${i}] indices) {\n          return padA(indices);\n      }`;return{name:"Pad",inputNames:["A"],inputTypes:[a.TextureType.unpacked],output:{dims:r,type:t.type,textureType:a.TextureType.unpacked},shaderSource:s}},c=e=>{if(!e||1!==e.length)throw new Error("Pad requires 1 input");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.")},p=e=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Pad requires 2 or 3 inputs");if("int32"!==e[1].type)throw new Error("Invalid input type.");if(e.length>=3&&"string"===e[2].type)throw new Error("Invalid input type.")},d=(e,t,n)=>{const r=(0,i.getGlsl)(e.session.backend.glContext.version),[s,u]=e.calculateTextureWidthAndHeight(t.dims,a.TextureType.unpacked),l=o.ShapeUtil.computeStrides(t.dims);switch(n.mode){case"constant":return f(r,t.dims,l,s,u,n.pads,n.value);case"reflect":return h(r,t.dims,l,s,u,n.pads);case"edge":return g(r,t.dims,l,s,u,n.pads);default:throw new Error("Invalid mode")}},f=(e,t,n,r,o,i,a)=>{const s=t.length;let u="";for(let e=s-1;e>=0;--e)u+=`\n        k = m[${e}] - ${i[e]};\n        if (k < 0)  return constant;\n        if (k >= ${t[e]}) return constant;\n        offset += k * ${n[e]};\n        `;return`\n      float padA(int m[${s}]) {\n        const float constant = float(${a});\n        int offset = 0;\n        int k = 0;\n        ${u}\n        vec2 coords = offsetToCoords(offset, ${r}, ${o});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `},h=(e,t,n,r,o,i)=>{const a=t.length;let s="";for(let e=a-1;e>=0;--e)s+=`\n        k = m[${e}] - ${i[e]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2*(t[e]-1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${t[e]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${n[e]};\n        `;return`\n      float padA(int m[${a}]) {\n        int offset = 0;\n        int k = 0;\n        ${s}\n        vec2 coords = offsetToCoords(offset, ${r}, ${o});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `},g=(e,t,n,r,o,i)=>{const a=t.length;let s="";for(let e=a-1;e>=0;--e)s+=`\n        k = m[${e}] - ${i[e]};\n        if (k < 0)  k = 0;\n        if (k >= ${t[e]}) k = ${t[e]-1};\n        offset += k * ${n[e]};\n      `;return`\n      float padA(int m[${a}]) {\n        int offset = 0;\n        int k = 0;\n        ${s}\n        vec2 coords = offsetToCoords(offset, ${r}, ${o});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `}},2834:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.globalMaxPool=t.parseMaxPoolAttributes=t.maxPool=t.parseGlobalAveragePoolAttributes=t.globalAveragePool=t.parseAveragePoolAttributes=t.averagePool=void 0;const r=n(4910),o=n(7273),i=n(5639);t.averagePool=(e,t,n)=>{p(t);const r={name:"AveragePool",inputNames:["X"],inputTypes:[i.TextureType.unpacked],cacheHint:n.cacheKey};return[e.run(Object.assign(Object.assign({},r),{get:()=>a(t,r,!1,n)}),t)]},t.parseAveragePoolAttributes=e=>{const t=e.attributes.getString("auto_pad","NOTSET"),n=e.attributes.getInt("ceil_mode",0),o=0!==e.attributes.getInt("count_include_pad",0),i=e.attributes.getInts("kernel_shape"),a=e.attributes.getInts("strides",[]),s=e.attributes.getInts("pads",[]);if(0!==n)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,r.createAttributeWithCacheKey)({autoPad:t,ceilMode:n,countIncludePad:o,kernelShape:i,strides:a,pads:s})};const a=(e,t,n,r)=>{const[a,s]=u(e,r,n),l=o.ShapeUtil.size(a.kernelShape);let c="";a.countIncludePad?c+=`value /= float(${l});`:c+=`value /= float(${l} - pad);`;const p=`\n        ${d(e[0].dims,a,"value += _X(x);",c,"0.0")}\n      `;return Object.assign(Object.assign({},t),{output:{dims:s,type:e[0].type,textureType:i.TextureType.unpacked},shaderSource:p})};t.globalAveragePool=(e,t,n)=>{p(t);const r={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[i.TextureType.unpacked],cacheHint:`${n.countIncludePad}`};return[e.run(Object.assign(Object.assign({},r),{get:()=>a(t,r,!0,n)}),t)]},t.parseGlobalAveragePoolAttributes=e=>{const t=0!==e.attributes.getInt("count_include_pad",0);return(0,r.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:t,kernelShape:[],strides:[],pads:[]})},t.maxPool=(e,t,n)=>{p(t);const r={name:"MaxPool",inputNames:["X"],inputTypes:[i.TextureType.unpacked],cacheHint:n.cacheKey};return[e.run(Object.assign(Object.assign({},r),{get:()=>s(t,r,!1,n)}),t)]},t.parseMaxPoolAttributes=e=>{const t=e.attributes.getString("auto_pad","NOTSET"),n=e.attributes.getInt("ceil_mode",0),o=e.attributes.getInts("kernel_shape"),i=e.attributes.getInts("strides",[]),a=e.attributes.getInts("pads",[]),s=e.attributes.getInt("storage_order",0),u=e.attributes.getInts("dilations",[]);if(0!==s)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==n)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,r.createAttributeWithCacheKey)({autoPad:t,ceilMode:n,countIncludePad:!1,kernelShape:o,strides:i,pads:a,storageOrder:s,dilations:u})};const s=(e,t,n,r)=>{const[o,a]=u(e,r,n),s=`\n      ${d(e[0].dims,o,"\n      value = max(_X(x), value);\n    ","","-1e5")}\n    `;return Object.assign(Object.assign({},t),{output:{dims:a,type:e[0].type,textureType:i.TextureType.unpacked},shaderSource:s})},u=(e,t,n)=>{const r=e[0].dims.slice(),i=Object.hasOwnProperty.call(t,"dilations"),a=t.kernelShape.slice(),s=t.strides.slice(),u=i?t.dilations.slice():[],l=t.pads.slice();o.PoolConvUtil.adjustPoolAttributes(n,r,a,s,u,l);const c=o.PoolConvUtil.computePoolOutputShape(n,r,s,u,a,l,t.autoPad),p=Object.assign({},t);return i?Object.assign(p,{kernelShape:a,strides:s,pads:l,dilations:u,cacheKey:t.cacheKey}):Object.assign(p,{kernelShape:a,strides:s,pads:l,cacheKey:t.cacheKey}),[p,c]},l={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},c={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[i.TextureType.unpacked]};t.globalMaxPool=(e,t)=>(p(t),[e.run(Object.assign(Object.assign({},c),{get:()=>s(t,c,!0,l)}),t)]);const p=e=>{if(!e||1!==e.length)throw new Error("Pool ops requires 1 input.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.")},d=(e,t,n,r,i)=>{const a=e.length;if(t.kernelShape.length<=2){const o=t.kernelShape[t.kernelShape.length-1],s=t.strides[t.strides.length-1],u=t.pads[t.pads.length/2-1],l=t.pads[t.pads.length-1],c=e[a-1];let p="",d="",f="";if(p=u+l!==0?`\n          for (int i = 0; i < ${o}; i++) {\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\n            if (x[${a} - 1] < 0 || x[${a} - 1] >= ${c}) {\n              pad++;\n              continue;\n            }\n            ${n}\n          }`:`\n          for (int i = 0; i < ${o}; i++) {\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\n            ${n}\n          }`,2===t.kernelShape.length){const n=t.kernelShape[t.kernelShape.length-2],r=t.strides[t.strides.length-2],i=t.pads[t.pads.length/2-2],s=t.pads[t.pads.length-2],u=e[a-2];d=i+s!==0?`\n            for (int j = 0; j < ${n}; j++) {\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${i} + j;\n              if (x[${a} - 2] < 0 || x[${a} - 2] >= ${u}) {\n                pad+= ${o};\n                continue;\n              }\n          `:`\n            for (int j = 0; j < ${n}; j++) {\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${i} + j;\n            `,f="\n          }\n        "}return`\n        float process(int indices[${a}]) {\n          int x[${a}];\n          copyVec(indices, x);\n\n          float value = ${i};\n          int pad = 0;\n          ${d}\n          ${p}\n          ${f}\n          ${r}\n          return value;\n        }\n      `}{const s=o.ShapeUtil.size(t.kernelShape),u=o.ShapeUtil.computeStrides(t.kernelShape),l=u.length,c=t.pads.length,p=h(l),d=f(e,"inputDims"),g=f(t.pads,"pads"),m=f(u,"kernelStrides"),b=f(t.strides,"strides");let y="";return y=t.pads.reduce(((e,t)=>e+t))?`\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${n}\n          }`:`\n          }\n          ${n}\n        `,`\n        ${p}\n        float process(int indices[${a}]) {\n          int x[${a}];\n          copyVec(indices, x);\n          int offset[${l}];\n          int pads[${c}];\n          int inputDims[${a}];\n          int kernelStrides[${l}];\n          int strides[${l}];\n          ${g}\n          ${d}\n          ${b}\n          ${m}\n\n          float value = ${i};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${s}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${a} - ${l}; j < ${a}; j++) {\n              x[j] = indices[j] * strides[j - ${a} + ${l}]\n                + offset[j - ${a} + ${l}] - pads[j - 2];\n              ${y}\n          }\n          ${r}\n\n          return value;\n        }\n      `}},f=(e,t)=>{let n="";for(let r=0;r<e.length;r++)n+=`\n      ${t}[${r}] = ${e[r]};\n    `;return n},h=e=>`\n  void offsetToIndices(int offset, int[${e}] strides, out int[${e}] indices) {\n    if (${e} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${e} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${e} - 1] = offset;\n  }`},1010:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.reduceLogSumSquare=t.reduceLogSum=t.reduceProd=t.reduceMin=t.reduceMax=t.reduceMean=t.reduceSum=t.parseReduceAttributes=void 0;const r=n(4910),o=n(6145),i=n(7273),a=n(5639),s=(e,t,n,r,o)=>{l(t);const i={name:r,inputNames:["A"],inputTypes:[a.TextureType.unpacked]};return[e.run(Object.assign(Object.assign({},i),{cacheHint:n.cacheKey,get:()=>u(e,t,n,r,o,i)}),t)]};t.parseReduceAttributes=e=>{const t=e.attributes.getInts("axes",[]),n=1===e.attributes.getInt("keepdims",1);return(0,r.createAttributeWithCacheKey)({axes:t,keepDims:n})};const u=(e,t,n,r,o,s)=>{const u=[],l=t[0].dims.length||1,c=[],p=i.ShapeUtil.normalizeAxes(n.axes,t[0].dims.length),d=o(t,p);let f=d[1];for(let e=0;e<t[0].dims.length;e++)p.indexOf(e)>=0||0===p.length?(n.keepDims&&u.push(1),f=`\n          for(int j${e} = 0; j${e} < ${t[0].dims[e]}; j${e}++) {\n            inputIdx[${e}] = j${e};\n            ${f}\n          }`):(c.push(`inputIdx[${e}] = outputIdx[${u.length}];`),u.push(t[0].dims[e]));const h=`\n      float process(int outputIdx[${u.length||1}]) {\n        float value;                 // final result\n        int inputIdx[${l}];      // addressing input data\n        ${c.join("\n")}\n        ${d[0]}       // init ops for reduce max/min\n        ${f}\n        ${d[2]}       // final computation for reduce mean\n        return value;\n      }`;return Object.assign(Object.assign({},s),{output:{dims:u,type:t[0].type,textureType:a.TextureType.unpacked},shaderSource:h})},l=e=>{if(!e||1!==e.length)throw new Error("Reduce op requires 1 input.");if(-1===o.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invalid input type.")};t.reduceSum=(e,t,n)=>s(e,t,n,"ReduceSum",(()=>["value = 0.0;","value += _A(inputIdx);",""])),t.reduceMean=(e,t,n)=>s(e,t,n,"ReduceMean",((e,t)=>{let n=1;for(let r=0;r<e[0].dims.length;r++)(t.indexOf(r)>=0||0===t.length)&&(n*=e[0].dims[r]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${n}.;`]})),t.reduceMax=(e,t,n)=>s(e,t,n,"ReduceMax",((e,t)=>{const n=[];for(let r=0;r<e[0].dims.length;r++)(t.indexOf(r)>=0||0===t.length)&&n.push(`inputIdx[${r}] = 0;`);return[`${n.join("\n")}\nvalue = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]})),t.reduceMin=(e,t,n)=>s(e,t,n,"ReduceMin",((e,t)=>{const n=[];for(let r=0;r<e[0].dims.length;r++)(t.indexOf(r)>=0||0===t.length)&&n.push(`inputIdx[${r}] = 0;`);return[`${n.join("\n")}\nvalue = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]})),t.reduceProd=(e,t,n)=>s(e,t,n,"ReduceProd",(()=>["value = 1.0;","value *= _A(inputIdx);",""])),t.reduceLogSum=(e,t,n)=>s(e,t,n,"ReduceLogSum",(()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"])),t.reduceLogSumSquare=(e,t,n)=>s(e,t,n,"ReduceLogSumSquare",(()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""]))},7379:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isReshapeCheap=t.processDims3D=t.createPackedReshape3DProgramInfoLoader=void 0;const r=n(7273),o=n(6757),i=n(5639),a=n(5614);t.createPackedReshape3DProgramInfoLoader=(e,t,n)=>{const s=(e=>({name:"Reshape (packed)",inputTypes:[i.TextureType.packed],inputNames:["A"],cacheHint:`${e}`}))(n);return Object.assign(Object.assign({},s),{get:()=>((e,t,n,s)=>{const u=t.dims,l=s;let c="";for(let e=0;e<4;e++){let t="";switch(e){case 0:t="outputCoords = rc;";break;case 1:t="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:t="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:t="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}c+=`\n        ${t}\n        ${e>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${e>0?"}":""}\n      `}const p=(0,o.getGlsl)(e.session.backend.glContext.version),d=`\n      ${function(e){const t=r.ShapeUtil.computeStrides(e),n=["b","r","c"],o="index";return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t.map(((e,r)=>`int ${n[r]} = ${o} / ${e}; ${r===t.length-1?`int ${n[r+1]} = ${o} - ${n[r]} * ${e}`:`index -= ${n[r]} * ${e}`};`)).join("")}\n      return ivec3(b, r, c);\n    }\n  `}(u)}\n      ${function(e){const t=r.ShapeUtil.computeStrides(e);return`\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${t[0]} + coords.z * ${t[1]} + coords.y;\n  }\n`}(l)}\n      ${(0,a.unpackFromChannel)()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${l[2]};\n        int cols = ${l[1]};\n\n        ${c}\n        ${p.output} = result;\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:l,type:t.type,textureType:i.TextureType.packed},shaderSource:d,hasMain:!0})})(e,t,s,n)})},t.processDims3D=function(e){if(0===e.length)return[1,1,1];let t=1;for(let n=0;n<e.length-2;++n)t*=e[n];return[t,e.length>1?e[e.length-2]:1,e[e.length-1]]},t.isReshapeCheap=function(e,t){let n=!1;return n=0===e.length||0===t.length||(e.length<2||t.length<2?e[e.length-1]===t[t.length-1]:e[e.length-1]===t[t.length-1]&&e[e.length-2]===t[t.length-2]),n}},8126:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.reshape=void 0;const r=n(7273);t.reshape=(e,t)=>{const n=r.ShapeUtil.calculateReshapedDims(t[0].dims,t[1].integerData);return e.session.pack?[e.reshapePacked(t[0],n)]:[e.reshapeUnpacked(t[0],n)]}},2801:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseResizeAttributesV11=t.parseResizeAttributesV10=t.resize=void 0;const r=n(6757),o=n(5639),i=n(432),a=n(5614),s=n(3980),u={name:"Resize",inputNames:["A"],inputTypes:[o.TextureType.packed]};t.resize=(e,t,n)=>((0,s.validateInputs)(t,n),[e.run(Object.assign(Object.assign({},u),{cacheHint:n.cacheKey,get:()=>l(e,t,n)}),t)]),t.parseResizeAttributesV10=e=>(0,s.parseUpsampleAttributes)(e,10),t.parseResizeAttributesV11=e=>(0,s.parseUpsampleAttributes)(e,11);const l=(e,t,n)=>{const s=(0,r.getGlsl)(e.session.backend.glContext.version),[l,p]=c(t,n);if(l.every((e=>1===e))&&"tf_crop_and_resize"!==n.coordinateTransformMode)return Object.assign(Object.assign({},u),{output:{dims:p,type:t[0].type,textureType:o.TextureType.packed},hasMain:!0,shaderSource:`void main() {\n                    vec4 v = ${s.texture2D}(X, TexCoords);\n                    ${s.output} = v;\n                }`});const d=p.length;if(d<2)throw new Error(`output dimension should be at least 2, but got ${d}`);const f=p[d-2],h=p[d-1],g=t[0].dims;if(d!==g.length)throw new Error(`output dimension should match input ${g.length}, but got ${d}`);const m=g[d-2],b=g[d-1],y=l[d-2],w=l[d-1];let _="";if("linear"!==n.mode)throw new Error(`resize (packed) does not support mode: '${n.mode}'`);switch(n.coordinateTransformMode){case"asymmetric":_="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";break;case"half_pixel":_="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";break;case"pytorch_half_pixel":_=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${h}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${f}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${h}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${f}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;break;case"align_corners":_=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${h}.0 - 1.0, ${f}.0 - 1.0, ${h}.0 - 1.0,\n                            ${f}.0 - 1.0);\n                        vec4 original = vec4(${b}.0 - 1.0, ${m}.0 - 1.0, ${b}.0 - 1.0,\n                            ${m}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n.coordinateTransformMode}'`)}const v=(0,i.getCoordsDataType)(d),x=`\n            const vec2 inputWH = vec2(${m}.0, ${b}.0);\n            const vec4 scaleWHWH = vec4(float(${y}), float(${w}), float(${y}), float(${w}));\n            ${(0,a.unpackFromChannel)()}\n            ${_}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${v} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${f-1};\n                bool hasNextCol = rc.z < ${h-1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${s.output} = vec4(newValue);\n            }\n        `;return Object.assign(Object.assign({},u),{output:{dims:p,type:t[0].type,textureType:o.TextureType.packed},hasMain:!0,shaderSource:x})},c=(e,t)=>{const n=e[0].dims;let r,o=t.scales;if(0===o.length){const i=e[t.scalesInputIdx];if(i&&0!==i.size){if(e[t.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");o=p(i,t.mode,t.isResize)}else{const i=e[t.sizesInputIdx];if(!i||0===i.size)throw new Error("Either scales or sizes MUST be provided as input.");r=Array.from(i.integerData),o=d(r,n,t.mode,t.isResize)}}else if(e[t.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const i=r||n.map(((e,t)=>Math.floor(e*o[t])));return[o,i]},p=(e,t,n)=>{const r=Array.from(e.floatData);return(0,s.scalesValidation)(r,t,n),r},d=(e,t,n,r)=>{const o=t.length,i=new Array(o);for(let n=0,r=o;n<r;n++)if(0===t[n]){if(0!==e[n])throw new Error("Input dim is zero but required output dim is non-zero.");i[n]=1}else i[n]=e[n]/t[n];return(0,s.scalesValidation)(i,n,r),i}},565:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.shape=void 0;const r=n(9240);t.shape=(e,t)=>(o(t),[new r.Tensor([t[0].dims.length],"int32",void 0,void 0,new Int32Array(t[0].dims))]);const o=e=>{if(!e||1!==e.length)throw new Error("Shape requires 1 input.")}},2444:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.sliceV10=t.parseSliceAttributes=t.slice=void 0;const r=n(4910),o=n(6145),i=n(7273),a=n(5639),s={name:"Slice",inputNames:["A"],inputTypes:[a.TextureType.unpacked]};t.slice=(e,t,n)=>(l(t),[e.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>u(e,t[0],n)}),t)]),t.parseSliceAttributes=e=>{const t=e.attributes.getInts("starts"),n=e.attributes.getInts("ends"),o=e.attributes.getInts("axes",[]);return(0,r.createAttributeWithCacheKey)({starts:t,ends:n,axes:o})};const u=(e,t,n)=>{const r=0===n.axes.length?t.dims.slice(0).map(((e,t)=>t)):n.axes,o=i.ShapeUtil.normalizeAxes(r,t.dims.length),u=n.starts.map(((e,n)=>e>t.dims[o[n]]-1?t.dims[o[n]]:i.ShapeUtil.normalizeAxis(e,t.dims[o[n]]))),l=n.ends.map(((e,n)=>e>t.dims[o[n]]-1?t.dims[o[n]]:i.ShapeUtil.normalizeAxis(e,t.dims[o[n]]))),c=t.dims.slice(),p=[];for(let e=0;e<o.length;e++)c[o[e]]=l[e]-u[e],u[e]>0&&p.push(`outputIdx[${o[e]}] += ${u[e]};`);const d=`\n      float process(int outputIdx[${c.length}]) {\n        ${p.join("\n      ")}\n        return _A(outputIdx);\n      }`;return Object.assign(Object.assign({},s),{output:{dims:c,type:t.type,textureType:a.TextureType.unpacked},shaderSource:d})},l=e=>{if(!e||1!==e.length)throw new Error("Slice requires 1 input.");if(-1===o.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invalid input type.")};t.sliceV10=(e,t)=>{p(t);const n=c(e,t);return[e.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>u(e,t[0],n)}),[t[0]])]};const c=(e,t)=>{if(!e.session.isInitializer(t[1].dataId)||!e.session.isInitializer(t[2].dataId)||t.length>=4&&!e.session.isInitializer(t[3].dataId)||t.length>=5&&!e.session.isInitializer(t[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(t.length>=5&&t[4].integerData.some((e=>1!==e)))throw new Error("currently non-1 steps is not supported for Slice");const n=Array.from(t[1].integerData),r=Array.from(t[2].integerData),o=t.length>=4?Array.from(t[3].integerData):[];return{starts:n,ends:r,axes:o,cacheKey:`${o};${n};${r}`}},p=e=>{if(!e||e.length<3||e.length>5)throw new Error("Invalid input number.");if("int32"!==e[1].type||1!==e[1].dims.length)throw new Error("Invalid input type.");if("int32"!==e[2].type||1!==e[2].dims.length)throw new Error("Invalid input type.");if(e.length>=4&&("int32"!==e[3].type||1!==e[3].dims.length))throw new Error("Invalid input type.");if(e.length>=5&&("int32"!==e[4].type||1!==e[4].dims.length))throw new Error("Invalid input type.")}},815:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.softmaxV13=t.parseSoftmaxAttributesV13=t.parseSoftmaxAttributes=t.softmax=void 0;const r=n(4910),o=n(7273),i=n(6757),a=n(5639),s=n(5707),u={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[a.TextureType.unpacked]},l={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked]},c={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]};t.softmax=(e,t,n)=>{g(t);const r=t[0].dims.slice(),i=o.ShapeUtil.normalizeAxis(n.axis,r.length),a=o.ShapeUtil.sizeToDimension(r,i),s=o.ShapeUtil.sizeFromDimension(r,i);return p(e,t,n,a,s)},t.parseSoftmaxAttributes=e=>(0,r.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis",1)}),t.parseSoftmaxAttributesV13=e=>(0,r.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis",-1)}),t.softmaxV13=(e,t,n)=>{g(t);const i=t[0].dims.slice(),a=o.ShapeUtil.normalizeAxis(n.axis,i.length),u=i.length,l=a!==u-1,c=[];let d,f=[],h=[];l&&(f=Array.from({length:u}).map(((e,t)=>t)),f[a]=u-1,f[u-1]=a,f.map((e=>c.push(i[e]))),d=(0,r.createAttributeWithCacheKey)({perm:f}),h=(0,s.transpose)(e,t,d));const m=l?o.ShapeUtil.sizeToDimension(c,u-1):o.ShapeUtil.sizeToDimension(i,u-1),b=l?o.ShapeUtil.sizeFromDimension(c,u-1):o.ShapeUtil.sizeFromDimension(i,u-1),y=p(e,l?h:t,n,m,b);return l?(0,s.transpose)(e,y,d):y};const p=(e,t,n,r,o)=>{const i=d(e,t[0],r,o,[r]),a=e.run(Object.assign(Object.assign({},u),{cacheHint:n.cacheKey,get:()=>i}),t),s=f(e,t[0],r,o,i.output.dims,[r]),p=e.run(Object.assign(Object.assign({},l),{cacheHint:n.cacheKey,get:()=>s}),[t[0],a]),g=h(e,t[0],r,o,i.output.dims,s.output.dims);return[e.run(Object.assign(Object.assign({},c),{cacheHint:n.cacheKey,get:()=>g}),[t[0],a,p])]},d=(e,t,n,r,o)=>{const[s,l]=e.calculateTextureWidthAndHeight(t.dims,a.TextureType.unpacked),c=o.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==o.length)throw new Error("Dimensionality of the output should be 1");if(o[0]!==n)throw new Error("Shape of the output should be equal to logical row count");const p=(0,i.getGlsl)(e.session.backend.glContext.version),d=`\n      float process(int[${c}] indices) {\n        int logical_row_start_offset = indices[0] * ${r};\n\n        float max = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s},\n        ${l} )));\n        for(int i=1; i<${r}; ++i)\n        {\n          float current = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${s}, ${l})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;return Object.assign(Object.assign({},u),{output:{dims:o,type:t.type,textureType:a.TextureType.unpacked},shaderSource:d})},f=(e,t,n,r,o,s)=>{const[u,c]=e.calculateTextureWidthAndHeight(t.dims,a.TextureType.unpacked),p=s.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==s.length)throw new Error("Dimensionality of the output should be 1");if(s[0]!==n)throw new Error("Shape of the output should be equal to logical row count");if(1!==o.length)throw new Error("Dimensionality of the intermediate results should be 1");if(o[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");const d=`\n      float process(int[${p}] indices) {\n        int logical_row_start_offset = indices[0] * ${r};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${r}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${(0,i.getGlsl)(e.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${u}, ${c}))) - max);\n        }\n\n        return norm_factor;\n      }`;return Object.assign(Object.assign({},l),{output:{dims:s,type:t.type,textureType:a.TextureType.unpacked},shaderSource:d})},h=(e,t,n,r,o,i)=>{const[s,u]=e.calculateTextureWidthAndHeight(t.dims,a.TextureType.unpacked),l=t.dims.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==o.length||1!==i.length)throw new Error("Dimensionality of the intermediate results should be 1");if(o[0]!==n||i[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");const p=`\n      float process(int[${l}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${s}, ${u});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${r};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;return Object.assign(Object.assign({},c),{output:{dims:t.dims,type:t.type,textureType:a.TextureType.unpacked},shaderSource:p})},g=e=>{if(!e||1!==e.length)throw new Error("Softmax requires 1 input.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type")}},564:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseSplitAttributes=t.split=void 0;const r=n(4910),o=n(7273),i=n(5639),a={name:"Split",inputNames:["A"],inputTypes:[i.TextureType.unpacked]};t.split=(e,t,n)=>{l(t);const r=o.ShapeUtil.normalizeAxis(n.axis,t[0].dims.length),i=s(e,t,r,n),c=[];for(let o=0;o<i;++o)c.push(e.run(Object.assign(Object.assign({},a),{cacheHint:`${n.cacheKey};${o}`,get:()=>u(e,t[0],n,r,o)}),t));return c},t.parseSplitAttributes=e=>{const t=e.attributes.getInt("axis",0),n=e.attributes.getInts("split",[]),o=e.outputs.length;return(0,r.createAttributeWithCacheKey)({axis:t,split:n,numOutputs:o})};const s=(e,t,n,r)=>{const[,i]=o.SplitUtil.splitShape(t[0].dims,n,r.split,r.numOutputs);return i.length},u=(e,t,n,r,s)=>{const[u,l]=o.SplitUtil.splitShape(t.dims,r,n.split,n.numOutputs),c=l[s],p=u[s],d=`\n      float process(int indices[${p.length}]) {\n        indices[${r}] += ${c};\n        return _A(indices);\n      }\n    `;return Object.assign(Object.assign({},a),{cacheHint:`${n.cacheKey}:${s}`,output:{dims:p,type:t.type,textureType:i.TextureType.unpacked},shaderSource:d})},l=e=>{if(!e||1!==e.length)throw new Error("Split requires one input.");if("int8"!==e[0].type&&"uint8"!==e[0].type&&"int16"!==e[0].type&&"uint16"!==e[0].type&&"int32"!==e[0].type&&"uint32"!==e[0].type&&"float32"!==e[0].type&&"float64"!==e[0].type&&"bool"!==e[0].type)throw new Error("Invalid input type.")}},5416:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseSqueezeAttributes=t.squeezeV13=t.squeeze=void 0;const r=n(7273);t.squeeze=(e,t,n)=>{o(t);const i=r.ShapeUtil.squeezeShape(t[0].dims,n);return[e.reshapeUnpacked(t[0],i)]},t.squeezeV13=(e,n)=>(i(n),(0,t.squeeze)(e,[n[0]],Array.from(n[1].integerData))),t.parseSqueezeAttributes=e=>e.attributes.getInts("axes");const o=e=>{if(!e||1!==e.length)throw new Error("Squeeze requires 1 input.");if("string"===e[0].type)throw new Error("invalid input tensor types.")},i=e=>{if(!e||2!==e.length)throw new Error("Squeeze requires 2 inputs.");if("int32"!==e[1].type)throw new Error("Invalid input type.")}},1240:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.sum=void 0;const r=n(6757),o=n(5639);t.sum=(e,t)=>{a(t);const n={name:"Sum",inputNames:t.map(((e,t)=>`X${t}`)),inputTypes:new Array(t.length).fill(o.TextureType.unpacked)};return[e.run(Object.assign(Object.assign({},n),{get:()=>i(e,t,n)}),t)]};const i=(e,t,n)=>{const i=(0,r.getGlsl)(e.session.backend.glContext.version),a=t[0].dims.slice(),s=`\n      void main() {\n        vec4 result = ${t.map(((e,t)=>`${i.texture2D}(X${t},TexCoords)`)).join(" + ")};\n        ${i.output} = result;\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:a,type:t[0].type,textureType:o.TextureType.unpacked},hasMain:!0,shaderSource:s})},a=e=>{if(!e||0===e.length)throw new Error("Sum requires inputs.");const t=e[0].dims.length;for(let n=1;n<e.length;n++){if(t!==e[n].dims.length)throw new Error("Input shapes are mismatched.");for(let r=0;r<t;r++)if(e[0].dims[r]!==e[n].dims[r])throw new Error("Input shapes are not matched.")}if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.");for(let t=1;t<e.length;t++)if(e[0].type!==e[t].type)throw new Error("Input types are not matched.")}},5944:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.tile=void 0;const r=n(6145),o=n(5639);t.tile=(e,t)=>{a(t);const n={name:"Tile",inputNames:["A"],inputTypes:[o.TextureType.unpacked]};return[e.run(Object.assign(Object.assign({},n),{get:()=>i(e,t,n)}),t)]};const i=(e,t,n)=>{const r=t[0].dims.slice(),i=new Array(r.length),a=[];for(let e=0;e<r.length;e++)i[e]=r[e]*t[1].numberData[e],a.push(`inputIdx[${e}] = int(mod(float(outputIdx[${e}]), ${r[e]}.));`);const s=i.length,u=`\n      float process(int outputIdx[${s}]) {\n        int inputIdx[${s}];\n        ${a.join("\n")}\n        return _A(inputIdx);\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:i,type:t[0].type,textureType:o.TextureType.unpacked},shaderSource:u})},a=e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 input.");if(1!==e[1].dims.length)throw new Error("The second input shape must 1 dimension.");if(e[1].dims[0]!==e[0].dims.length)throw new Error("Invalid input shape.");if(-1===r.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invalid input type.");if("int32"!==e[1].type&&"int16"!==e[1].type)throw new Error("Invalid repeat type.")}},5707:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseTransposeAttributes=t.transpose=void 0;const r=n(4910),o=n(7273),i=n(5639),a={name:"Transpose",inputNames:["A"],inputTypes:[i.TextureType.unpacked]};t.transpose=(e,t,n)=>(p(t),[e.run(Object.assign(Object.assign({},a),{cacheHint:n.cacheKey,get:()=>s(e,t[0],n.perm)}),t)]),t.parseTransposeAttributes=e=>(0,r.createAttributeWithCacheKey)({perm:e.attributes.getInts("perm",[])});const s=(e,t,n)=>{const r=t.dims;n=u(r,n);const o=l(r,n),s=r.length,p=`\n      ${c("perm",n,s)}\n      float process(int indices[${s}]) {\n        int a[${s}];\n        perm(a, indices);\n        return _A(a);\n      }`;return Object.assign(Object.assign({},a),{output:{dims:o,type:t.type,textureType:i.TextureType.unpacked},shaderSource:p})},u=(e,t)=>(t&&t.length!==e.length&&(t=[...e.keys()].reverse()),t),l=(e,t)=>(t=u(e,t),o.ShapeUtil.sortBasedOnPerm(e,t)),c=(e,t,n)=>{const r=[];r.push(`void ${e}(out int a[${n}], int src[${n}]) {`);for(let e=0;e<n;++e)r.push(`\ta[${t[e]}]=src[${e}];`);return r.push("\t}"),r.join("\n")},p=e=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("input should be float tensor")}},2488:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.encodeAsUint8=void 0;const r=n(6757),o=n(5639);t.encodeAsUint8=(e,t)=>{const n=t.shape,i=(0,r.getGlsl)(e.session.backend.glContext.version),a=`\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${i.texture2D}(X,TexCoords).r;\n      ${i.output} = encodeAsUint8(value);\n    }`,s={name:"Uint8Encode",inputTypes:[o.TextureType.unpacked],inputNames:["X"],output:{dims:n,type:t.tensor.type,textureType:o.TextureType.downloadUint8AsFloat},shaderSource:a,hasMain:!0};return e.executeProgram(s,[t.tensor])}},9087:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.tanh=t.tan=t.sqrt=t.sin=t.sigmoid=t.relu=t.not=t.neg=t.log=t.parseLeakyReluAttributes=t.leakyRelu=t.identity=t.floor=t.exp=t.parseEluAttributes=t.elu=t.cos=t.ceil=t.clipV11=t.parseClipAttributes=t.clip=t.atan=t.asin=t.acos=t.abs=t.glslTanh=t.glslTan=t.glslSqrt=t.glslSigmoid=t.glslRelu=t.glslSin=t.glslNot=t.glslNeg=t.glslLog=t.glslLeakyRelu=t.glslIdentity=t.glslClip=t.glslFloor=t.glslExp=t.glslElu=t.glslCos=t.glslCeil=t.glslAtan=t.glslAsin=t.glslAcos=t.glslAbs=void 0;const r=n(4910),o=n(7273),i=n(1997),a=n(6757),s=n(5639);function u(){return $("abs")}function l(){return $("acos")}function c(){return $("asin")}function p(){return $("atan")}function d(){return $("ceil")}function f(){return $("cos")}function h(e){const t="elu";return{body:`\n  const float alpha = float(${e});\n\n  float ${t}_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 ${t}_(vec4 v) {\n    return vec4(${t}_(v.x), ${t}_(v.y), ${t}_(v.z), ${t}_(v.w));\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function g(){return $("exp")}function m(){return $("floor")}function b(e,t){const n="clip";return{body:`\n  const float min = float(${e});\n  const float max = float(${t});\n\n  float ${n}_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 ${n}_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `,name:n,type:i.FunctionType.ValueBased}}function y(){const e="indentity";return{body:`\n  float ${e}_(float a) {\n    return a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return v;\n  }\n  `,name:e,type:i.FunctionType.ValueBased}}function w(e){const t="leakyRelu";return{body:`\n  const float alpha = float(${e});\n\n  float ${t}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${t}_(vec4 v) {\n    return vec4(${t}_(v.x), ${t}_(v.y), ${t}_(v.z), ${t}_(v.w));\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function _(){return $("log")}function v(){const e="neg";return{body:`\n  float ${e}_(float a) {\n    return -a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return -v;\n  }\n  `,name:e,type:i.FunctionType.ValueBased}}function x(){const e="not";return{body:`\n  float ${e}_(float a) {\n    return float( ! bool(a) );\n  }\n  bool ${e}_(bool a) {\n    return !a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 ${e}_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  `,name:e,type:i.FunctionType.ValueBased}}function T(){return $("sin")}function S(){const e="relu";return{body:`\n  float ${e}_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 ${e}_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  `,name:e,type:i.FunctionType.ValueBased}}function O(){const e="sigmoid";return{body:`\n  float ${e}_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 ${e}_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  `,name:e,type:i.FunctionType.ValueBased}}function A(){return $("sqrt")}function E(){return $("tan")}function I(){const e="tanh";return{body:`\n  float ${e}_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 ${e}_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  `,name:e,type:i.FunctionType.ValueBased}}function $(e){return{body:`\n  float ${e}_(float a) {\n    return ${e}(a);\n  }\n  vec4 ${e}_(vec4 v) {\n    return ${e}(v);\n  }\n  `,name:e,type:i.FunctionType.ValueBased}}t.glslAbs=u,t.glslAcos=l,t.glslAsin=c,t.glslAtan=p,t.glslCeil=d,t.glslCos=f,t.glslElu=h,t.glslExp=g,t.glslFloor=m,t.glslClip=b,t.glslIdentity=y,t.glslLeakyRelu=w,t.glslLog=_,t.glslNeg=v,t.glslNot=x,t.glslSin=T,t.glslRelu=S,t.glslSigmoid=O,t.glslSqrt=A,t.glslTan=E,t.glslTanh=I;const P=(e,t,n,r)=>{const o=e.session.pack?s.TextureType.packed:s.TextureType.unpacked,i={name:n.name,inputTypes:[o],inputNames:["A"],cacheHint:r};return Object.assign(Object.assign({},i),{get:()=>((e,t,n,r)=>{const o=e.session.pack?s.TextureType.packed:s.TextureType.unpacked,i=(0,a.getGlsl)(e.session.backend.glContext.version);return Object.assign(Object.assign({},t),{output:{dims:n.dims,type:n.type,textureType:o},shaderSource:`\n     ${r.body}\n     void main() {\n       vec4 v = ${i.texture2D}(A, TexCoords);\n       v = ${r.name}_(v);\n       ${i.output} = v;\n     }\n     `,hasMain:!0})})(e,i,t,n)})};t.abs=(e,t)=>[e.run(P(e,t[0],u()),t)],t.acos=(e,t)=>[e.run(P(e,t[0],l()),t)],t.asin=(e,t)=>[e.run(P(e,t[0],c()),t)],t.atan=(e,t)=>[e.run(P(e,t[0],p()),t)],t.clip=(e,t,n)=>[e.run(P(e,t[0],b(n.min,n.max),n.cacheKey),t)],t.parseClipAttributes=e=>(0,r.createAttributeWithCacheKey)({min:e.attributes.getFloat("min",o.MIN_CLIP),max:e.attributes.getFloat("max",o.MAX_CLIP)}),t.clipV11=(e,n)=>{const r=D(e,n);return(0,t.clip)(e,[n[0]],r)};const D=(e,t)=>{if(t.length>=3&&(!e.session.isInitializer(t[1].dataId)||!e.session.isInitializer(t[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const n=t.length>=3?t[1].numberData[0]:o.MIN_CLIP,i=t.length>=3?t[2].numberData[0]:o.MAX_CLIP;return(0,r.createAttributeWithCacheKey)({min:n,max:i})};t.ceil=(e,t)=>[e.run(P(e,t[0],d()),t)],t.cos=(e,t)=>[e.run(P(e,t[0],f()),t)],t.elu=(e,t,n)=>[e.run(P(e,t[0],h(n.alpha),n.cacheKey),t)],t.parseEluAttributes=e=>(0,r.createAttributeWithCacheKey)({alpha:e.attributes.getFloat("alpha",1)}),t.exp=(e,t)=>[e.run(P(e,t[0],g()),t)],t.floor=(e,t)=>[e.run(P(e,t[0],m()),t)],t.identity=(e,t)=>[e.run(P(e,t[0],y()),t)],t.leakyRelu=(e,t,n)=>[e.run(P(e,t[0],w(n.alpha),n.cacheKey),t)],t.parseLeakyReluAttributes=e=>(0,r.createAttributeWithCacheKey)({alpha:e.attributes.getFloat("alpha",.01)}),t.log=(e,t)=>[e.run(P(e,t[0],_()),t)],t.neg=(e,t)=>[e.run(P(e,t[0],v()),t)],t.not=(e,t)=>[e.run(P(e,t[0],x()),t)],t.relu=(e,t)=>[e.run(P(e,t[0],S()),t)],t.sigmoid=(e,t)=>[e.run(P(e,t[0],O()),t)],t.sin=(e,t)=>[e.run(P(e,t[0],T()),t)],t.sqrt=(e,t)=>[e.run(P(e,t[0],A()),t)],t.tan=(e,t)=>[e.run(P(e,t[0],E()),t)],t.tanh=(e,t)=>[e.run(P(e,t[0],I()),t)]},540:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createUnpackProgramInfoLoader=t.createUnpackProgramInfo=void 0;const r=n(6757),o=n(5639),i=n(432),a=n(5614),s={name:"unpack",inputNames:["A"],inputTypes:[o.TextureType.packed]};t.createUnpackProgramInfo=(e,t)=>{const n=t.dims.length,u=(0,a.getChannels)("rc",n),l=u.slice(-2),c=(0,i.getCoordsDataType)(n),p=(0,a.unpackFromChannel)(),d=0===t.dims.length?"":function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(n,u),f=n<=1?"rc":`vec2(${l.join(",")})`,h=`\n    ${p}\n    void main() {\n      ${c} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${d});\n\n       ${(0,r.getGlsl)(e.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${f}), 0, 0, 0);\n     }\n   `;return Object.assign(Object.assign({},s),{hasMain:!0,output:{dims:t.dims,type:t.type,textureType:o.TextureType.unpacked},shaderSource:h})},t.createUnpackProgramInfoLoader=(e,n)=>Object.assign(Object.assign({},s),{get:()=>(0,t.createUnpackProgramInfo)(e,n)})},7862:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseUnsqueezeAttributes=t.unsqueezeV13=t.unsqueeze=void 0;const r=n(7273);t.unsqueeze=(e,t,n)=>{o(t);const i=r.ShapeUtil.unsqueezeShape(t[0].dims,n);return[e.reshapeUnpacked(t[0],i)]},t.unsqueezeV13=(e,n)=>(i(n),(0,t.unsqueeze)(e,[n[0]],Array.from(n[1].integerData))),t.parseUnsqueezeAttributes=e=>e.attributes.getInts("axes");const o=e=>{if(!e||1!==e.length)throw new Error("Unsqueeze requires 1 input.");if("string"===e[0].type)throw new Error("invalid input tensor types.")},i=e=>{if(!e||2!==e.length)throw new Error("Unsqueeze requires 2 inputs.");if("int32"!==e[1].type)throw new Error("Invalid input type.")}},3980:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.scalesValidation=t.validateInputs=t.parseUpsampleAttributes=t.parseUpsampleAttributesV9=t.parseUpsampleAttributesV7=t.upsample=void 0;const r=n(4910),o=n(6757),i=n(5639),a={name:"Upsample",inputNames:["X"],inputTypes:[i.TextureType.unpacked]};t.upsample=(e,n,r)=>((0,t.validateInputs)(n,r),[e.run(Object.assign(Object.assign({},a),{cacheHint:r.cacheKey,get:()=>s(e,n,r)}),n)]),t.parseUpsampleAttributesV7=e=>(0,t.parseUpsampleAttributes)(e,7),t.parseUpsampleAttributesV9=e=>(0,t.parseUpsampleAttributes)(e,9),t.parseUpsampleAttributes=(e,n)=>{const o=n>=10,i=e.attributes.getString("mode","nearest");if("nearest"!==i&&"linear"!==i&&(n<11||"cubic"!==i))throw new Error(`unrecognized mode: ${i}`);let a=[];n<9&&(a=e.attributes.getFloats("scales"),(0,t.scalesValidation)(a,i,o));const s=e.attributes.getFloat("extrapolation_value",0),u=n>10?e.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(-1===["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(u))throw new Error(`coordinate_transform_mode '${u}' is not supported`);const l="tf_crop_and_resize"===u,c=l,p="nearest"===i&&n>=11?e.attributes.getString("nearest_mode","round_prefer_floor"):"";if(-1===["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(p))throw new Error(`nearest_mode '${p}' is not supported`);const d=e.attributes.getFloat("cubic_coeff_a",-.75),f=0!==e.attributes.getInt("exclude_outside",0);if(f&&"cubic"!==i)throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const h=n<11||"nearest"===i&&"asymmetric"===u&&"floor"===p;let g=0,m=0,b=0;return n>10?e.inputs.length>2?(g=1,m=2,b=3):(m=1,b=2):9===n&&(m=1),(0,r.createAttributeWithCacheKey)({opset:n,isResize:o,mode:i,scales:a,extrapolationValue:s,coordinateTransformMode:u,useExtrapolation:c,needRoiInput:l,nearestMode:p,cubicCoefficientA:d,excludeOutside:f,useNearest2xOptimization:h,roiInputIdx:g,scalesInputIdx:m,sizesInputIdx:b})};const s=(e,t,n)=>{const r=(0,o.getGlsl)(e.session.backend.glContext.version),[s,u]=e.calculateTextureWidthAndHeight(t[0].dims,i.TextureType.unpacked),l=t[0].dims.map(((e,t)=>Math.floor(e*n.scales[t]))),[c,p]=e.calculateTextureWidthAndHeight(l,i.TextureType.unpacked),d=l.length,f=new Array(d),h=new Array(d);let g=`\n      int output_pitches[${d}];\n      int input_pitches[${d}];\n      `;for(let e=d-1;e>=0;e--)f[e]=e===d-1?1:f[e+1]*l[e+1],h[e]=e===d-1?1:h[e+1]*t[0].dims[e+1],g+=`\n        output_pitches[${e}] = ${f[e]};\n        input_pitches[${e}] = ${h[e]};\n        `;const m=`\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${s}, ${u});\n        float value = getColorAsFloat(${r.texture2D}(X, coords));\n        return value;\n      }\n      `,b="nearest"===n.mode?`\n    ${m}\n    float process(int indices[${d}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${c}, ${p});\n\n      ${g}\n\n      int d, m;\n      for (int dim = 0; dim < ${d}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }`:4===d?`\n    ${m}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${c}, ${p});\n\n      ${g}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${t[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }`:`\n    ${m}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${c}, ${p});\n\n      ${g}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${t[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;return Object.assign(Object.assign({},a),{output:{dims:l,type:t[0].type,textureType:i.TextureType.unpacked},shaderSource:b,variables:[{name:"scales",type:"int",arrayLength:n.scales.length,data:n.scales.map((e=>Math.ceil(e)))}]})};t.validateInputs=(e,t)=>{if(!e||t.opset<9&&1!==e.length||t.opset>=9&&t.opset<11&&2!==e.length||t.opset>=11&&e.length<2)throw new Error("invalid inputs.");if(t.scales.length>0&&e[0].dims.length!==t.scales.length)throw new Error("Invalid input shape.");if("string"===e[0].type)throw new Error("Invalid input tensor types.")},t.scalesValidation=(e,t,n)=>{if(n){for(const t of e)if(t<=0)throw new Error("Scale value should be greater than 0.")}else for(const t of e)if(t<1)throw new Error("Scale value should be greater than or equal to 1.");if(!("linear"!==t&&"cubic"!==t||2===e.length||4===e.length&&1===e[0]&&1===e[1]))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n?"Resize":"Upsample"} opeartor.`)}},2757:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ProgramManager=void 0;const r=n(8453),o=n(1315),i=n(8897),a=n(6757);t.ProgramManager=class{constructor(e,t,n){this.profiler=e,this.glContext=t,this.textureLayoutStrategy=n,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n){var r;this.profiler.event("op",`ProgramManager.run ${null!==(r=e.programInfo.name)&&void 0!==r?r:"unknown kernel"}`,(()=>{var r;const i=this.glContext.gl,a=e.program;i.useProgram(a);try{this.bindOutput(n),this.attributesBound||this.bindAttributes(e.attribLocations),this.bindUniforms(e.uniformLocations,null!==(r=e.programInfo.variables)&&void 0!==r?r:[],t)}catch(t){throw o.Logger.error("ProgramManager",e.programInfo.shaderSource),t}this.profiler.event("backend","GlContext.draw()",(()=>{this.glContext.draw()}))}),this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach((e=>this.glContext.deleteProgram(e.program)))}build(e,t,n){return this.profiler.event("backend","ProgramManager.build",(()=>{const r=new i.GlslPreprocessor(this.glContext,e,t,n),o=r.preprocess(),a=this.compile(o);return{programInfo:e,program:a,uniformLocations:this.getUniformLocations(a,r.context.programInfo.inputNames,r.context.programInfo.variables),attribLocations:this.getAttribLocations(a)}}))}compile(e){if(!this.vertexShader){o.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const e=(0,a.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(e,this.glContext.gl.VERTEX_SHADER)}r.env.debug&&o.Logger.verbose("ProrgramManager",`FragShader:\n${e}\n`);const t=this.glContext.compileShader(e,this.glContext.gl.FRAGMENT_SHADER),n=this.glContext.createProgram(this.vertexShader,t);return this.glContext.deleteShader(t),n}bindOutput(e){const t=e.width,n=e.height;o.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${t}/${n}, shape=${e.shape}, type=${e.tensor.type}`),this.glContext.attachFramebuffer(e.texture,t,n)}bindAttributes(e){const t=e.position,n=e.textureCoord;this.glContext.setVertexAttributes(t,n),this.attributesBound=!0}bindUniforms(e,t,n){var r;const o=this.glContext.gl;let i=0;for(const{name:a,type:s,location:u,arrayLength:l}of e){const e=null===(r=t.find((e=>e.name===a)))||void 0===r?void 0:r.data;if("sampler2D"!==s&&!e)throw new Error(`variable '${a}' does not have data defined in program info`);switch(s){case"sampler2D":this.bindTexture(n[i],u,i),i++;break;case"float":l?o.uniform1fv(u,e):o.uniform1f(u,e);break;case"int":l?o.uniform1iv(u,e):o.uniform1i(u,e);break;default:throw new Error(`Uniform not implemented: ${s}`)}}}bindTexture(e,t,n){this.glContext.bindTextureToUniform(e.texture,n,t)}getAttribLocations(e){return{position:this.getAttribLocation(e,"position"),textureCoord:this.getAttribLocation(e,"textureCoord")}}getUniformLocations(e,t,n){const r=[];if(t)for(const n of t)r.push({name:n,type:"sampler2D",location:this.getUniformLocation(e,n)});if(n)for(const t of n)r.push(Object.assign(Object.assign({},t),{location:this.getUniformLocation(e,t.name)}));return r}getUniformLocation(e,t){const n=this.glContext.gl.getUniformLocation(e,t);if(null===n)throw new Error(`Uniform ${t} not found.`);return n}getAttribLocation(e,t){return this.glContext.gl.getAttribLocation(e,t)}}},2171:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLSessionHandler=void 0;const r=n(1315),o=n(5881),i=n(7860),a=n(4110),s=n(2757),u=n(7618),l=n(5243);t.WebGLSessionHandler=class{constructor(e,t){this.backend=e,this.context=t,this.layoutStrategy=new u.PreferLogicalStrategy(e.glContext.maxTextureSize),this.programManager=new s.ProgramManager(this.context.profiler,e.glContext,this.layoutStrategy),this.textureManager=new l.TextureManager(e.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:"full"===e.textureCacheMode}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=e.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new i.WebGLInferenceHandler(this)}onGraphInitialized(e){const t=e.getValues().filter((e=>-1===e.from&&e.tensor)).map((e=>e.tensor.dataId));this.initializers=new Set(t)}isInitializer(e){return!!this.initializers&&this.initializers.has(e)}addInitializer(e){this.initializers.add(e)}getTextureData(e,t){return t?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,t,n=!1){r.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),n?this.packedTextureDataCache.set(e,t):this.unpackedTextureDataCache.set(e,t)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((e=>this.textureManager.releaseTexture(e,!0))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((e=>this.textureManager.releaseTexture(e,!0))),this.unpackedTextureDataCache=new Map}resolve(e,t,n){const r=(0,o.resolveOperator)(e,t,a.WEBGL_OP_RESOLVE_RULES);return{impl:r.opImpl,context:r.opInit?r.opInit(e,n):e}}}},9622:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Uint8DataEncoder=t.RGBAFloatDataEncoder=t.RedFloat32DataEncoder=void 0;const r=n(1315);t.RedFloat32DataEncoder=class{constructor(e,t=1){if(1===t)this.internalFormat=e.R32F,this.format=e.RED,this.textureType=e.FLOAT,this.channelSize=t;else{if(4!==t)throw new Error(`Invalid number of channels: ${t}`);this.internalFormat=e.RGBA32F,this.format=e.RGBA,this.textureType=e.FLOAT,this.channelSize=t}}encode(e,t){let n,o;return e.constructor!==Float32Array&&(r.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),o=new Float32Array(e)),t*this.channelSize>e.length?(r.Logger.warning("Encoder","Source data too small. Allocating larger array"),o=e,n=this.allocate(t*this.channelSize),o.forEach(((e,t)=>n[t]=e))):(o=e,n=o),n}allocate(e){return new Float32Array(4*e)}decode(e,t){return 1===this.channelSize?e.filter(((e,t)=>t%4==0)).subarray(0,t):e.subarray(0,t)}},t.RGBAFloatDataEncoder=class{constructor(e,t=1,n){if(1!==t&&4!==t)throw new Error(`Invalid number of channels: ${t}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.channelSize=t,this.textureType=n||e.FLOAT}encode(e,t){let n=e;return 1===this.channelSize&&(r.Logger.verbose("Encoder","Exploding into a larger array"),n=this.allocate(t),e.forEach(((e,t)=>n[4*t]=e))),n}allocate(e){return new Float32Array(4*e)}decode(e,t){return 1===this.channelSize?e.filter(((e,t)=>t%4==0)).subarray(0,t):e.subarray(0,t)}},t.Uint8DataEncoder=class{constructor(e,t=1){if(this.channelSize=4,1===t)this.internalFormat=e.ALPHA,this.format=e.ALPHA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=t;else{if(4!==t)throw new Error(`Invalid number of channels: ${t}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=t}}encode(e,t){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}allocate(e){return new Uint8Array(e*this.channelSize)}decode(e,t){if(e instanceof Uint8Array)return e.subarray(0,t);throw new Error(`Invalid array type: ${e.constructor}`)}}},7618:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getBatchDim=t.sizeToSquarishShape=t.getRowsCols=t.sizeFromShape=t.isInt=t.parseAxisParam=t.squeezeShape=t.PreferLogicalStrategy=t.AlwaysKeepOriginalSizeStrategy=void 0;const r=n(1315),o=n(7273);function i(e,t){const n=[],r=[],o=null!=t&&Array.isArray(t)&&0===t.length,i=null==t||o?null:a(t,e).sort();let s=0;for(let t=0;t<e.length;++t){if(null!=i){if(i[s]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==i[s]||i[s]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),i[s]<=t&&s++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function a(e,t){const n=t.length;return e=null==e?t.map(((e,t)=>t)):[].concat(e),(0,o.assert)(e.every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),(0,o.assert)(e.every(s),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function s(e){return e%1==0}function u(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function l(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}t.AlwaysKeepOriginalSizeStrategy=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,t){if(0===e.length)return[1,1];const n=this.maxTextureSize;if(t&&void 0!==t.breakAxis){const o=t.breakAxis>=e.length?1:e.slice(t.breakAxis).reduce(((e,t)=>e*t)),i=t.breakAxis<=0?1:e.slice(0,t.breakAxis).reduce(((e,t)=>e*t));if(!(o>n||i>n))return[o,i];r.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${t.breakAxis}`)}const o=e.reduce(((e,t)=>e*t));let i=Math.floor(Math.sqrt(o));for(;i<n&&i<o&&o%i!=0;i++);if(i>=n||o%i!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${e}`);return[i,o/i]}},t.PreferLogicalStrategy=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,t){const n=this.computeTexture(e,t);return t&&t.isPacked&&(n[0]/=2,n[1]/=2),t&&t.reverseWH?[n[1],n[0]]:n}computeTexture(e,t){const n=t&&t.isPacked;if(0===e.length)return n?[2,2]:[1,1];let o=this.maxTextureSize;if(t&&void 0!==t.breakAxis){const n=t.breakAxis>=e.length?1:e.slice(t.breakAxis).reduce(((e,t)=>e*t)),i=t.breakAxis<=0?1:e.slice(0,t.breakAxis).reduce(((e,t)=>e*t));if(!(n>o||i>o))return[n,i];r.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${t.breakAxis}`)}let a=e.slice(0);if(n&&(o*=2,a=a.map(((e,t)=>t>=a.length-2?a[t]%2==0?a[t]:a[t]+1:a[t])),1===a.length&&(a=[2,a[0]])),2!==a.length){const e=i(a);a=e.newShape}const s=u(a);return a.length<=1&&s<=o?[1,s]:2===a.length&&a[0]<=o&&a[1]<=o?a:3===a.length&&a[0]*a[1]<=o&&a[2]<=o?[a[0]*a[1],a[2]]:3===a.length&&a[0]<=o&&a[1]*a[2]<=o?[a[0],a[1]*a[2]]:4===a.length&&a[0]*a[1]*a[2]<=o&&a[3]<=o?[a[0]*a[1]*a[2],a[3]]:4===a.length&&a[0]<=o&&a[1]*a[2]*a[3]<=o?[a[0],a[1]*a[2]*a[3]]:n?l(s/4).map((e=>2*e)):l(s)}},t.squeezeShape=i,t.parseAxisParam=a,t.isInt=s,t.sizeFromShape=u,t.getRowsCols=function(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]},t.sizeToSquarishShape=l,t.getBatchDim=function(e,t=2){return u(e.slice(0,e.length-t))}},3314:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createTextureLayoutFromShape=t.calculateTextureWidthAndHeight=t.createTextureLayoutFromTextureType=void 0;const r=n(7273),o=n(5639);t.createTextureLayoutFromTextureType=(e,n,r)=>{const i=r===o.TextureType.unpacked||r===o.TextureType.unpackedReversed?1:4,a=r===o.TextureType.packed,s=r===o.TextureType.unpackedReversed||r===o.TextureType.packed,u=r===o.TextureType.packedLastDimension?n.length-1:void 0,l=r===o.TextureType.packedLastDimension?n.map(((e,t)=>t===n.length-1?4*e:e)):void 0;return(0,t.createTextureLayoutFromShape)(e,n,i,l,{isPacked:a,reverseWH:s,breakAxis:u})},t.calculateTextureWidthAndHeight=(e,n,r)=>{const o=(0,t.createTextureLayoutFromTextureType)(e,n,r);return[o.width,o.height]},t.createTextureLayoutFromShape=(e,t,n=1,o,i)=>{const a=!(!i||!i.isPacked),[s,u]=e.computeTextureWH(a&&o||t,i),l=t.length;let c=t.slice(0);if(0===l&&(c=[1]),1===n)o=t;else if(a){if(4!==n)throw new Error("a packed texture must be 4-channel");o=t,l>0&&(c[l-1]=Math.ceil(c[l-1]/2)),l>1&&(c[l-2]=Math.ceil(c[l-2]/2))}else if(!o)throw new Error("Unpacked shape is needed when using channels > 1");return{width:s,height:u,channels:n,isPacked:a,shape:c,strides:r.ShapeUtil.computeStrides(c),unpackedShape:o,reversedWH:i&&i.reverseWH}}},5243:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.TextureManager=void 0;const r=n(1315);t.TextureManager=class{constructor(e,t,n,r){this.glContext=e,this.layoutStrategy=t,this.profiler=n,this.config=r,this.pendingRead=new Map,r.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(e,t,n,o){const i=this.toEncoderType(e),a=this.glContext.getEncoder(i,t.channels||1,o);if(t.isPacked&&1===o)throw new Error("not implemented");const s=t.width,u=t.height;let l,c;if(this.config.reuseTextures){l=`${s}x${u}_${a.format}_${a.internalFormat}_${a.textureType}`,c=this.inUseTextures.get(l),c||(c=[],this.inUseTextures.set(l,c));const t=this.idleTextures.get(l);if(t&&t.length>0){const r=t.pop();return c.push(r),1===o&&this.glContext.updateTexture(r,s,u,a,this.toTextureData(e,n)),r}}r.Logger.verbose("TextureManager",`Creating new texture of size ${t.width}x${t.height}`);const p=this.glContext.allocateTexture(s,u,a,this.toTextureData(e,n));return this.config.reuseTextures&&(c.push(p),this.textureLookup.set(p,l)),p}readTexture(e,t,n){return n||(n=1),this.profiler.event("backend","TextureManager.readTexture",(()=>{const r=e.shape.reduce(((e,t)=>e*t))*n,o=this.glContext.readTexture(e.texture,e.width,e.height,r,this.toEncoderType(t),n);return this.toTensorData(t,o)}))}async readTextureAsync(e,t,n){const r=e.tensor.dataId;if(n||(n=1),this.pendingRead.has(r)){const e=this.pendingRead.get(r);return new Promise((t=>null==e?void 0:e.push(t)))}return this.profiler.event("backend","TextureManager.readTextureAsync",(async()=>{this.pendingRead.set(r,[]);const o=e.shape.reduce(((e,t)=>e*t))*n;await this.glContext.createAndWaitForFence();const i=this.glContext.readTexture(e.texture,e.width,e.height,o,this.toEncoderType(t),n),a=this.toTensorData(t,i),s=this.pendingRead.get(r);return this.pendingRead.delete(r),null==s||s.forEach((e=>e(a))),a}))}readUint8TextureAsFloat(e){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",(()=>{const t=e.shape.reduce(((e,t)=>e*t)),n=this.glContext.readTexture(e.texture,e.width,e.height,4*t,"byte",4);return new Float32Array(n.buffer,n.byteOffset,t)}))}releaseTexture(e,t){let n;if(this.config.reuseTextures&&(n=this.textureLookup.get(e.texture),n)){t&&this.textureLookup.delete(n);const r=this.inUseTextures.get(n);if(r){const t=r.indexOf(e.texture);if(-1!==t){r.splice(t,1);let o=this.idleTextures.get(n);o||(o=[],this.idleTextures.set(n,o)),o.push(e.texture)}}}n&&!t||(r.Logger.verbose("TextureManager",`Deleting texture of size ${e.width}x${e.height}`),this.glContext.deleteTexture(e.texture))}toTensorData(e,t){switch(e){case"int16":return t instanceof Int16Array?t:Int16Array.from(t);case"int32":return t instanceof Int32Array?t:Int32Array.from(t);case"int8":return t instanceof Int8Array?t:Int8Array.from(t);case"uint16":return t instanceof Uint16Array?t:Uint16Array.from(t);case"uint32":return t instanceof Uint32Array?t:Uint32Array.from(t);case"uint8":case"bool":return t instanceof Uint8Array?t:Uint8Array.from(t);case"float32":return t instanceof Float32Array?t:Float32Array.from(t);case"float64":return t instanceof Float64Array?t:Float64Array.from(t);default:throw new Error(`TensorData type ${e} is not supported`)}}toTextureData(e,t){if(t)return t instanceof Float32Array?t:new Float32Array(t)}toEncoderType(e){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},5639:(e,t)=>{"use strict";var n;Object.defineProperty(t,"__esModule",{value:!0}),t.TextureType=void 0,(n=t.TextureType||(t.TextureType={}))[n.unpacked=0]="unpacked",n[n.unpackedReversed=1]="unpackedReversed",n[n.packed=2]="packed",n[n.downloadUint8AsFloat=3]="downloadUint8AsFloat",n[n.packedLastDimension=4]="packedLastDimension"},432:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getGlChannels=t.getCoordsDataType=t.getSqueezedParams=t.squeezeInputShape=t.generateShaderFuncNameFromInputSamplerNameAtOutCoords=t.generateShaderFuncNameFromInputSamplerName=t.repeatedTry=t.getPackedShape=void 0;const r=n(7273);t.getPackedShape=function(e){const t=e.length;return e.slice(0,t-1).concat(e[t-1]/4)},t.repeatedTry=async function(e,t=(e=>0),n){return new Promise(((r,o)=>{let i=0;const a=()=>{if(e())return void r();i++;const s=t(i);null!=n&&i>=n?o():setTimeout(a,s)};a()}))},t.generateShaderFuncNameFromInputSamplerName=function(e){return(0,r.assert)(void 0!==e&&0!==e.length,(()=>"empty string found for sampler name")),"get"+e.charAt(0).toUpperCase()+e.slice(1)},t.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(e){return(0,r.assert)(void 0!==e&&0!==e.length,(()=>"empty string found for sampler name")),"get"+e.charAt(0).toUpperCase()+e.slice(1)+"AtOutCoords"},t.squeezeInputShape=function(e,t){let n=JSON.parse(JSON.stringify(e));return n=t,n},t.getSqueezedParams=function(e,t){return t.map((t=>e[t])).join(", ")},t.getCoordsDataType=function(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)},t.getGlChannels=function(e=6){return["x","y","z","w","u","v"].slice(0,e)}},3389:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createNewWebGLContext=t.createWebGLContext=void 0;const r=n(1315),o=n(3524),i={};function a(e){const t=function(){if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas)throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const e=document.createElement("canvas");return e.width=1,e.height=1,e}();let n;const i={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!e||"webgl2"===e)&&(n=t.getContext("webgl2",i),n))try{return new o.WebGLContext(n,2)}catch(e){r.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${e}`)}if((!e||"webgl"===e)&&(n=t.getContext("webgl",i)||t.getContext("experimental-webgl",i),n))try{return new o.WebGLContext(n,1)}catch(e){r.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${e}`)}throw new Error("WebGL is not supported")}t.createWebGLContext=function e(t){let n;t&&"webgl2"!==t||!("webgl2"in i)?t&&"webgl"!==t||!("webgl"in i)||(n=i.webgl):n=i.webgl2,n=n||a(t),t=t||1===n.version?"webgl":"webgl2";const r=n.gl;return i[t]=n,r.isContextLost()?(delete i[t],e(t)):(r.disable(r.DEPTH_TEST),r.disable(r.STENCIL_TEST),r.disable(r.BLEND),r.disable(r.DITHER),r.disable(r.POLYGON_OFFSET_FILL),r.disable(r.SAMPLE_COVERAGE),r.enable(r.SCISSOR_TEST),r.enable(r.CULL_FACE),r.cullFace(r.BACK),n)},t.createNewWebGLContext=a},3524:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var o=Object.getOwnPropertyDescriptor(t,n);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,o)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return o(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLContext=t.linearSearchLastTrue=void 0;const a=n(8453),s=i(n(9622)),u=n(432);function l(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}t.linearSearchLastTrue=l,t.WebGLContext=class{constructor(e,t){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=e,this.version=t,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(e,t,n,r){const o=this.gl,i=o.createTexture();o.bindTexture(o.TEXTURE_2D,i),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MIN_FILTER,o.NEAREST),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MAG_FILTER,o.NEAREST),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_S,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_T,o.CLAMP_TO_EDGE);const a=r?n.encode(r,e*t):null;return o.texImage2D(o.TEXTURE_2D,0,n.internalFormat,e,t,0,n.format,n.textureType,a),this.checkError(),i}updateTexture(e,t,n,r,o){const i=this.gl;i.bindTexture(i.TEXTURE_2D,e);const a=r.encode(o,t*n);i.texSubImage2D(i.TEXTURE_2D,0,0,0,t,n,r.format,r.textureType,a),this.checkError()}attachFramebuffer(e,t,n){const r=this.gl;r.bindTexture(r.TEXTURE_2D,e),r.bindFramebuffer(r.FRAMEBUFFER,this.framebuffer),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0),this.checkError(),r.viewport(0,0,t,n),r.scissor(0,0,t,n)}readTexture(e,t,n,r,o,i){const a=this.gl;i||(i=1),this.frameBufferBound||this.attachFramebuffer(e,t,n);const s=this.getEncoder(o,i),u=s.allocate(t*n);return a.bindTexture(a.TEXTURE_2D,e),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e,0),a.readPixels(0,0,t,n,a.RGBA,s.textureType,u),this.checkError(),s.decode(u,r)}isFramebufferReady(){return!0}getActiveTexture(){const e=this.gl;return"TEXTURE"+(e.getParameter(this.gl.ACTIVE_TEXTURE)-e.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(e,t){const n=this.gl;n.vertexAttribPointer(e,3,n.FLOAT,!1,20,0),n.enableVertexAttribArray(e),-1!==t&&(n.vertexAttribPointer(t,2,n.FLOAT,!1,20,12),n.enableVertexAttribArray(t)),this.checkError()}createProgram(e,t){const n=this.gl,r=n.createProgram();return n.attachShader(r,e),n.attachShader(r,t),n.linkProgram(r),r}compileShader(e,t){const n=this.gl,r=n.createShader(t);if(!r)throw new Error(`createShader() returned null with type ${t}`);if(n.shaderSource(r,e),n.compileShader(r),!1===n.getShaderParameter(r,n.COMPILE_STATUS))throw new Error(`Failed to compile shader: ${n.getShaderInfoLog(r)}\nShader source:\n${e}`);return r}deleteShader(e){this.gl.deleteShader(e)}bindTextureToUniform(e,t,n){const r=this.gl;r.activeTexture(r.TEXTURE0+t),this.checkError(),r.bindTexture(r.TEXTURE_2D,e),this.checkError(),r.uniform1i(n,t),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(a.env.debug){const e=this.gl,t=e.getError();let n="";switch(t){case e.NO_ERROR:return;case e.INVALID_ENUM:n="INVALID_ENUM";break;case e.INVALID_VALUE:n="INVALID_VALUE";break;case e.INVALID_OPERATION:n="INVALID_OPERATION";break;case e.INVALID_FRAMEBUFFER_OPERATION:n="INVALID_FRAMEBUFFER_OPERATION";break;case e.OUT_OF_MEMORY:n="OUT_OF_MEMORY";break;case e.CONTEXT_LOST_WEBGL:n="CONTEXT_LOST_WEBGL";break;default:n=`Unknown WebGL Error: ${t.toString(16)}`}throw new Error(n)}}deleteTexture(e){this.gl.deleteTexture(e)}deleteProgram(e){this.gl.deleteProgram(e)}getEncoder(e,t,n=0){if(2===this.version)return new s.RedFloat32DataEncoder(this.gl,t);switch(e){case"float":return 1===n||this.isRenderFloat32Supported?new s.RGBAFloatDataEncoder(this.gl,t):new s.RGBAFloatDataEncoder(this.gl,t,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new s.Uint8DataEncoder(this.gl,t);default:throw new Error(`Invalid dataType: ${e}`)}}clearActiveTextures(){const e=this.gl;for(let t=0;t<this.maxTextureImageUnits;++t)e.activeTexture(e.TEXTURE0+t),e.bindTexture(e.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(this.framebuffer),e.bindBuffer(e.ARRAY_BUFFER,null),e.deleteBuffer(this.vertexbuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const e=this.gl,t=e.createBuffer();if(!t)throw new Error("createBuffer() returned null");const n=this.createDefaultGeometry();return e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW),this.checkError(),t}createFramebuffer(){const e=this.gl.createFramebuffer();if(!e)throw new Error("createFramebuffer returned null");return e}queryVitalParameters(){const e=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),1===this.version&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){2===this.version?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const e=this.gl,t=e.createTexture();e.bindTexture(e.TEXTURE_2D,t);const n=2===this.version?e.RGBA32F:e.RGBA;e.texImage2D(e.TEXTURE_2D,0,n,1,1,0,e.RGBA,e.FLOAT,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(t),e.deleteFramebuffer(r),o}checkRenderFloat32(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else{if(!this.textureFloatExtension)return!1;if(!this.gl.getExtension("WEBGL_color_buffer_float"))return!1}return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const e=this.gl;let t,n,r,o,i;try{t=e.createTexture(),n=e.createFramebuffer(),e.bindTexture(e.TEXTURE_2D,t);const a=2===this.version?e.RGBA32F:e.RGBA;return e.texImage2D(e.TEXTURE_2D,0,a,1,1,0,e.RGBA,e.FLOAT,null),e.bindFramebuffer(e.FRAMEBUFFER,n),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0),e.enable(e.BLEND),r=e.createShader(e.VERTEX_SHADER),!!r&&(e.shaderSource(r,"void main(){}"),e.compileShader(r),o=e.createShader(e.FRAGMENT_SHADER),!!o&&(e.shaderSource(o,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),e.compileShader(o),i=e.createProgram(),!!i&&(e.attachShader(i,r),e.attachShader(i,o),e.linkProgram(i),e.useProgram(i),e.drawArrays(e.POINTS,0,1),e.getError()===e.NO_ERROR)))}finally{e.disable(e.BLEND),i&&e.deleteProgram(i),r&&e.deleteShader(r),o&&e.deleteShader(o),n&&(e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(n)),t&&(e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(t))}}beginTimer(){if(2===this.version&&this.disjointTimerQueryWebgl2Extension){const e=this.gl,t=this.disjointTimerQueryWebgl2Extension,n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const e=this.gl,t=this.disjointTimerQueryWebgl2Extension;e.endQuery(t.TIME_ELAPSED_EXT)}}isTimerResultAvailable(e){let t=!1,n=!1;if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const r=this.gl,o=this.disjointTimerQueryWebgl2Extension;t=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE),n=r.getParameter(o.GPU_DISJOINT_EXT)}return t&&!n}getTimerResult(e){let t=0;if(2!==this.version)throw new Error("WebGL1 profiling currently not supported");{const n=this.gl;t=n.getQueryParameter(e,n.QUERY_RESULT),n.deleteQuery(e)}return t/1e6}async waitForQueryAndGetTime(e){return await(0,u.repeatedTry)((()=>this.isTimerResultAvailable(e))),this.getTimerResult(e)}async createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t;const n=e,r=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),t=null===r?()=>!0:()=>{const e=n.clientWaitSync(r,0,0);return e===n.ALREADY_SIGNALED||e===n.CONDITION_SATISFIED},{query:r,isFencePassed:t}}async pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=l(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}async addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||await(0,u.repeatedTry)((()=>(this.pollItems(),0===this.itemsToPoll.length)))}}},6496:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ExecutionPlan=void 0;const r=n(1315);class o{constructor(e,t){this.op=e,this.node=t}}t.ExecutionPlan=class{constructor(e,t,n){this.graph=e,this.profiler=n,this.initialize(t)}initialize(e){this.profiler.event("session","ExecutionPlan.initialize",(()=>{const t=this.graph.getNodes();if(t.length!==e.length)throw new Error("The size of nodes and OPs do not match.");this._ops=e.map(((e,n)=>new o(e,t[n]))),this.reset(),this._starter=[],this._ops.forEach(((e,t)=>{let n=!0;for(const t of e.node.inputs)if(!this._values[t]&&-1===this.graph.getInputIndices().indexOf(t)){n=!1;break}n&&this._starter.push(t)}))}))}reset(){this._values=this.graph.getValues().map((e=>e.tensor))}async execute(e,t){return this.profiler.event("session","ExecutionPlan.execute",(async()=>{this.reset();const n=e.createInferenceHandler(),o=this.graph.getInputIndices();if(t.length!==o.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${t.length} expected: ${o.length}`);t.forEach(((e,t)=>{const n=o[t];this._values[n]=e}));const i=this._starter.slice(0),a=this.graph.getValues(),s=this.graph.getNodes();let u=0;for(;u<i.length;){const e=i[u++],t=this._ops[e],o=t.node.inputs.map((e=>this._values[e]));if(-1!==o.indexOf(void 0))throw new Error(`unresolved input detected: op: ${t.node}`);const l=o;r.Logger.verbose("ExecPlan",`Runing op:${t.node.name} (${l.map(((e,n)=>`'${t.node.inputs[n]}': ${e.type}[${e.dims.join(",")}]`)).join(", ")})`);const c=await this.profiler.event("node",t.node.name,(async()=>t.op.impl(n,l,t.op.context)));if(c.length!==t.node.outputs.length)throw new Error("the size of output does not match model definition.");c.forEach(((e,n)=>{const r=t.node.outputs[n];if(this._values[r])throw new Error(`output [${r}] already has value: op:${t.node.name}`);this._values[r]=e}));const p=new Set;c.forEach(((e,n)=>{const r=t.node.outputs[n];for(const e of a[r].to){const t=s[e];let n=!0;for(const e of t.inputs)if(!this._values[e]){n=!1;break}n&&p.add(e)}})),i.push(...p)}const l=[];for(let e=0;e<this.graph.getOutputIndices().length;e++){const t=this.graph.getOutputIndices()[e],n=this._values[t];if(void 0===n)throw new Error(`required output [${t}] does not have value`);0===t?await n.getData():n.data,l.push(n)}return r.Logger.verbose("ExecPlan","disposing of inferenceHandler"),n.dispose(),l}))}}},4662:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Graph=void 0;const r=n(1446),o=n(6874),i=n(1287),a=n(9240),s=n(7273);var u=i.onnxruntime.experimental.fbs;t.Graph={from:(e,t)=>new p(e,t)};class l{constructor(e){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,e&&(this.type=s.ProtoUtil.tensorValueTypeFromProto(e.type.tensorType))}get from(){return this._from}get to(){return this._to}}class c{constructor(e,t){e instanceof r.onnx.NodeProto?(this.name=e.name,this.opType=e.opType,this.attributes=new o.Attribute(e.attribute)):e instanceof u.Node&&(this.name=null!=t?t:e.name(),this.opType=e.opType(),this.attributes=new o.Attribute(s.ProtoUtil.tensorAttributesFromORTFormat(e))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class p{constructor(e,t){if(!e)throw new TypeError("graph is empty");this.buildGraph(e),this.transformGraph(t),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(e){if(e instanceof r.onnx.GraphProto)this.buildGraphFromOnnxFormat(e);else{if(!(e instanceof u.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(e)}}buildGraphFromOnnxFormat(e){const t=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const n=new Map;if(!e.input)throw new Error("missing information in graph: input");const r=[];for(const n of e.input){if(t.has(n.name))throw new Error(`duplicated input name: ${n.name}`);const e=this._allData.push(new l(n))-1;t.set(n.name,e),r.push(n.name)}if(!e.initializer)throw new Error("missing information in graph: initializer");for(const n of e.initializer){let e=t.get(n.name);if(void 0===e){const r=new l;r.type={shape:{dims:s.ProtoUtil.tensorDimsFromProto(n.dims)},tensorType:s.ProtoUtil.tensorDataTypeFromProto(n.dataType)},e=this._allData.push(r)-1,t.set(n.name,e)}this._allData[e]._from=-1,this._allData[e].tensor=a.Tensor.fromProto(n)}for(let e=0;e<this._allData.length;e++)this._allData[e].tensor||(this._allInputIndices.push(e),this._allInputNames.push(r[e]));if(!e.output)throw new Error("missing information in graph: output");for(const n of e.output){if(t.has(n.name))throw new Error(`duplicated output name: ${n.name}`);const e=this._allData.push(new l(n))-1;t.set(n.name,e),this._allOutputIndices.push(e),this._allOutputNames.push(n.name)}if(!e.node)throw new Error("missing information in graph: node");for(const t of e.node){if(!t.name)for(let e=0;;e++){const r=`unnamed_${t.opType}_${e}`;if(!n.has(r)){t.name=r;break}}if(n.has(t.name))throw new Error(`duplicated node name: ${t.name}`);const e=this._nodes.push(new c(t))-1;n.set(t.name,e)}for(let n=0;n<this._nodes.length;n++){const r=this._nodes[n],o=e.node[n];if(!o.output)throw new Error(`missing output for node: ${o.name}`);for(const e of o.output){let i=t.get(e);if(void 0===i&&(i=this._allData.push(new l)-1,t.set(e,i)),r.outputs.push(i),void 0!==this._allData[i]._from)throw new Error(`multiple nodes output to one data value: ${i}`);if(this._allData[i]._from=n,"Constant"===o.opType){if(!o.attribute||1!==o.attribute.length||!o.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!o.output||1!==o.output.length)throw new Error("missing output or incorrect number of outputs for this Constant operator");r.outputs.pop(),r.executeNode=!1,this._allData[i]._from=-1,this._allData[i].tensor=a.Tensor.fromProto(o.attribute[0].t)}}}for(let n=0;n<this._nodes.length;n++){const r=this._nodes[n],o=e.node[n];if(!o.input)throw new Error(`missing input for node: ${o.name}`);for(const e of o.input){const i=t.get(e);if(void 0===i){if(""===e&&3===o.input.length&&"Resize"===o.opType)continue;throw new Error(`unrecognized input '${e}' for node: ${o.name}`)}r.inputs.push(i),this._allData[i]._to.push(n)}}return!0}buildGraphFromOrtFormat(e){var t,n,r;const o=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const i=new Map,p=[];for(let i=0;i<e.inputsLength();i++){const a=e.inputs(i);if(o.has(a))throw new Error(`duplicated input name: ${a}`);for(let i=0;i<e.nodeArgsLength();i++)if((null===(t=e.nodeArgs(i))||void 0===t?void 0:t.name())===a){const t=new l;if((null===(r=null===(n=e.nodeArgs(i))||void 0===n?void 0:n.type())||void 0===r?void 0:r.valueType())!==u.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const c=e.nodeArgs(i).type().value(new u.TensorTypeAndShape),d=s.ProtoUtil.tensorDataTypeFromProto(c.elemType()),f=c.shape(),h=[];for(let e=0;e<f.dimLength();e++)h.push(s.LongUtil.longToNumber(f.dim(e).value().dimValue()));t.type={shape:{dims:h},tensorType:d};const g=this._allData.push(t)-1;o.set(a,g),p.push(a)}}for(let t=0;t<e.initializersLength();t++){const n=e.initializers(t);let r=o.get(n.name());if(void 0===r){const e=new l,t=s.ProtoUtil.tensorDimsFromORTFormat(n),i=s.ProtoUtil.tensorDataTypeFromProto(n.dataType());e.type={shape:{dims:t},tensorType:i},r=this._allData.push(e)-1,o.set(n.name(),r)}this._allData[r]._from=-1,this._allData[r].tensor=a.Tensor.fromOrtTensor(n)}for(let e=0;e<this._allData.length;e++)this._allData[e].tensor||(this._allInputIndices.push(e),this._allInputNames.push(p[e]));for(let t=0;t<e.outputsLength();t++){const n=e.outputs(t);if(o.has(n))throw new Error(`duplicated output name: ${n}`);const r=this._allData.push(new l)-1;o.set(n,r),this._allOutputIndices.push(r),this._allOutputNames.push(n)}if(!e.nodes)throw new Error("missing information in graph: node");for(let t=0;t<e.nodesLength();t++){const n=e.nodes(t);let r=n.name();if(!r)for(let e=0;r=`unnamed_${n.opType()}_${e}`,i.has(r);e++);if(i.has(r))throw new Error(`duplicated node name: ${r}`);const o=this._nodes.push(new c(n,r))-1;i.set(r,o)}for(let t=0;t<this._nodes.length;t++){const n=this._nodes[t],r=e.nodes(t);if(null==r)throw new Error(`No node exists at index ${t}`);if(0===(null==r?void 0:r.outputsLength()))throw new Error(`missing output for node: ${r.name}`);for(let e=0;e<(null==r?void 0:r.outputsLength());e++){const i=null==r?void 0:r.outputs(e);let s=o.get(i);if(void 0===s&&(s=this._allData.push(new l)-1,o.set(i,s)),n.outputs.push(s),void 0!==this._allData[s]._from)throw new Error(`multiple nodes output to one data value: ${s}`);if(this._allData[s]._from=t,"Constant"===r.opType()){if(1!==r.attributesLength()||!r.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(1!==r.outputsLength())throw new Error("missing output or incorrect number of outputs for this Constant operator");n.outputs.pop(),n.executeNode=!1,this._allData[s]._from=-1,this._allData[s].tensor=a.Tensor.fromOrtTensor(r.attributes(0).t())}}}for(let t=0;t<this._nodes.length;t++){const n=this._nodes[t],r=e.nodes(t);if(0===r.inputsLength())throw new Error(`missing input for node: ${r.name}`);for(let e=0;e<r.inputsLength();e++){const i=r.inputs(e),a=o.get(i);if(void 0===a)throw new Error(`unrecognized input '${i}' for node: ${r.name()}`);n.inputs.push(a),this._allData[a]._to.push(t)}}}checkIsAcyclic(){const e=new Set;this._allInputIndices.forEach((t=>{this._allData[t]._to.forEach((t=>{e.add(t)}))}));const t=Array.from(e),n=new Array(this._nodes.length).fill("white");for(;t.length>0;){const e=t.pop();"gray"===n[e]?n[e]="black":(t.push(e),n[e]="gray",this._nodes[e].outputs.forEach((r=>{const o=this._allData[r];if(void 0!==o.tensor)throw new Error("node outputs should not be initialized");if(o._from!==e)throw new Error("from property of the Value object doesn't match index of Node being processed");o._to.forEach((e=>{if("gray"===n[e])throw new Error("model graph is cyclic");"white"===n[e]&&t.push(e)}))})))}}transformGraph(e){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),e&&e.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let e=0;const t=new Array(this._nodes.length,0);let n=0;for(let e=0;e<this._nodes.length;e++)t[e]=n,this._nodes[e].executeNode?(n!==e&&(this._nodes[n]=this._nodes[e]),n++):this._nodes[e].outputs.forEach((e=>{this._allData[e]._from=-2}));this._nodes.splice(n,this._nodes.length-n);for(let e=0;e<this._allData.length;e++){const n=this._allData[e];void 0!==n._from&&-1!==n._from&&-2!==n._from&&(n._from=t[n._from]);for(let e=0;e<n._to.length;e++){if(!(n._to[e]>=0))throw new Error("Trying to update a removed node");n._to[e]=t[n._to[e]]}}e=0;for(let t=0;t<this._allData.length;t++)if(-2!==this._allData[t].from||-1!==this._allOutputIndices.indexOf(t+e)){if(e>0){let n=-1;void 0!==this._allData[t].from&&-1!==this._allData[t].from?(n=this._nodes[this._allData[t].from].outputs.indexOf(t+e),-1!==n&&(this._nodes[this._allData[t].from].outputs[n]=t)):(n=this._allInputIndices.indexOf(t+e),-1!==n&&(this._allInputIndices[n]=t)),this._allData[t].to.forEach((r=>{n=this._nodes[r].inputs.indexOf(t+e),-1!==n&&(this._nodes[r].inputs[n]=t)})),0===this._allData[t].to.length&&(n=this._allOutputIndices.indexOf(t+e),-1!==n&&(this._allOutputIndices[n]=t))}}else e++,this._allData.splice(t,1),t--}deleteNode(e){const t=this._nodes[e];if(t.outputs.length>1)for(let e=1;e<t.outputs.length;e++)if(this._allData[t.outputs[e]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");t.executeNode=!1;const n=t.inputs[0],r=t.outputs[0],o=this._allData[r].to;for(let n=0;n<t.inputs.length;n++){const r=this._allData[t.inputs[n]].to.indexOf(e);if(-1===r)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[t.inputs[n]].to.splice(r,1)}this._allData[r]._to=[];const i=this._allOutputIndices.indexOf(r);if(-1!==i&&(this._allOutputIndices[i]=n),o&&o.length>0)for(const e of o){const t=this._nodes[e].inputs.indexOf(r);if(-1===t)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[e].inputs[t]=n,this._allData[n].to.push(e)}}removeAllDropoutNodes(){let e=0;for(const t of this._nodes){if("Dropout"===t.opType){if(1!==t.inputs.length)throw new Error("Dropout nodes should only contain one input. ");if(1!==t.outputs.length&&2!==t.outputs.length)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(2===t.outputs.length&&0!==this._allData[t.outputs[1]]._to.length)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(e)}e++}}removeAllIdentityNodes(){let e=0;for(const t of this._nodes)"Identity"===t.opType&&this.deleteNode(e),e++}isActivation(e){switch(e.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const e of this._nodes)if("Conv"===e.opType){const t=this._allData[e.outputs[0]]._to;if(1===t.length&&this.isActivation(this._nodes[t[0]])){const n=this._nodes[t[0]];if("Clip"===n.opType)if(1===n.inputs.length)try{e.attributes.set("activation_params","floats",[n.attributes.getFloat("min"),n.attributes.getFloat("max")])}catch(t){e.attributes.set("activation_params","floats",[s.MIN_CLIP,s.MAX_CLIP])}else{if(!(n.inputs.length>=3&&void 0!==this._allData[n.inputs[1]].tensor&&void 0!==this._allData[n.inputs[2]].tensor))continue;e.attributes.set("activation_params","floats",[this._allData[n.inputs[1]].tensor.floatData[0],this._allData[n.inputs[2]].tensor.floatData[0]])}e.attributes.set("activation","string",n.opType),this.deleteNode(t[0])}}}}},1315:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.now=t.Profiler=t.Logger=void 0;const n={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},r={none:new class{log(e,t,n){}},console:new class{log(e,t,n){console.log(`${this.color(e)} ${n?"[35m"+n+"[0m ":""}${t}`)}color(e){switch(e){case"verbose":return"[34;40mv[0m";case"info":return"[32mi[0m";case"warning":return"[30;43mw[0m";case"error":return"[31;40me[0m";case"fatal":return"[101mf[0m";default:throw new Error(`unsupported severity: ${e}`)}}}},o={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let i={"":o};function a(e,t,n,r){if(void 0===t)return o=e,{verbose:a.verbose.bind(null,o),info:a.info.bind(null,o),warning:a.warning.bind(null,o),error:a.error.bind(null,o),fatal:a.fatal.bind(null,o)};if(void 0===n)s(e,t);else if("number"==typeof n&&void 0===r)s(e,t);else if("string"==typeof n&&void 0===r)s(e,n,0,t);else{if("string"!=typeof n||"number"!=typeof r)throw new TypeError("input is valid");s(e,n,0,t)}var o}function s(e,t,o,a){const s=i[a||""]||i[""];n[e]<n[s.minimalSeverity]||(s.logDateTime&&(t=`${(new Date).toISOString()}|${t}`),s.logSourceLocation,r[s.provider].log(e,t,a))}!function(e){function t(e){i={},n("",e||{})}function n(e,n){if("*"===e)t(n);else{const t=i[e]||o;i[e]={provider:n.provider||t.provider,minimalSeverity:n.minimalSeverity||t.minimalSeverity,logDateTime:void 0===n.logDateTime?t.logDateTime:n.logDateTime,logSourceLocation:void 0===n.logSourceLocation?t.logSourceLocation:n.logSourceLocation}}}e.verbose=function(t,n){e("verbose",t,n)},e.info=function(t,n){e("info",t,n)},e.warning=function(t,n){e("warning",t,n)},e.error=function(t,n){e("error",t,n)},e.fatal=function(t,n){e("fatal",t,n)},e.reset=t,e.set=n,e.setWithEnv=function(e){const t={};e.logLevel&&(t.minimalSeverity=e.logLevel),n("",t)}}(a||(a={})),t.Logger=a;class u{constructor(e,t,n,r,o,i){this.category=e,this.name=t,this.startTime=n,this.endCallback=r,this.timer=o,this.ctx=i}async end(){return this.endCallback(this)}async checkTimer(){if(void 0===this.ctx||void 0===this.timer)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class l{constructor(e,t,n,r){this.category=e,this.name=t,this.startTime=n,this.endTime=r}}t.Profiler=class{static create(e){return void 0===e?new this:new this(e.maxNumberEvents,e.flushBatchSize,e.flushIntervalInMilliseconds)}constructor(e,t,n){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=void 0===e?1e4:e,this._flushBatchSize=void 0===t?10:t,this._flushIntervalInMilliseconds=void 0===n?5e3:n}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,t.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(e,t,n,r){const o=this._started?this.begin(e,t,r):void 0;let i=!1;const a=n();if(a&&"function"==typeof a.then)return i=!0,new Promise(((e,t)=>{a.then((async t=>{o&&await o.end(),e(t)}),(async e=>{o&&await o.end(),t(e)}))}));if(!i&&o){const e=o.end();if(e&&"function"==typeof e.then)return new Promise(((t,n)=>{e.then((()=>{t(a)}),(e=>{n(e)}))}))}return a}begin(e,n,r){if(!this._started)throw new Error("profiler is not started yet");if(void 0===r){const r=(0,t.now)();return this.flush(r),new u(e,n,r,(e=>this.endSync(e)))}{const t=r.beginTimer();return new u(e,n,0,(async e=>this.end(e)),t,r)}}async end(e){const t=await e.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new l(e.category,e.name,e.startTime,t)),this.flush(t))}endSync(e){const n=(0,t.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new l(e.category,e.name,e.startTime,n)),this.flush(n))}logOneEvent(e){t.Logger.verbose(`Profiler.${e.category}`,`${(e.endTime-e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`)}flush(e){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||e-this._flushTime>=this._flushIntervalInMilliseconds){for(const e=this._flushPointer;this._flushPointer<e+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,t.now)()}}get started(){return this._started}},t.now="undefined"!=typeof performance&&performance.now?()=>performance.now():Date.now},1745:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Model=void 0;const r=n(5686),o=n(1446),i=n(4662),a=n(1287),s=n(7273);var u=a.onnxruntime.experimental.fbs;t.Model=class{constructor(){}load(e,t,n){if(!n)try{return void this.loadFromOnnxFormat(e,t)}catch(e){if(void 0!==n)throw e}this.loadFromOrtFormat(e,t)}loadFromOnnxFormat(e,t){const n=o.onnx.ModelProto.decode(e);if(s.LongUtil.longToNumber(n.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=n.opsetImport.map((e=>({domain:e.domain,version:s.LongUtil.longToNumber(e.version)}))),this._graph=i.Graph.from(n.graph,t)}loadFromOrtFormat(e,t){const n=new r.flatbuffers.ByteBuffer(e),o=u.InferenceSession.getRootAsInferenceSession(n).model();if(s.LongUtil.longToNumber(o.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let e=0;e<o.opsetImportLength();e++){const t=o.opsetImport(e);this._opsets.push({domain:null==t?void 0:t.domain(),version:s.LongUtil.longToNumber(t.version())})}this._graph=i.Graph.from(o.graph(),t)}get graph(){return this._graph}get opsets(){return this._opsets}}},6145:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FLOAT_TYPES=t.INT_TYPES=t.NUMBER_TYPES=void 0,t.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],t.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],t.FLOAT_TYPES=["float32","float64"]},5881:(e,t)=>{"use strict";function n(e,t){if(t.endsWith("+")){const n=Number.parseInt(t.substring(0,t.length-1),10);return!isNaN(n)&&n<=e}if(2===t.split("-").length){const n=t.split("-"),r=Number.parseInt(n[0],10),o=Number.parseInt(n[1],10);return!isNaN(r)&&!isNaN(o)&&r<=e&&e<=o}return Number.parseInt(t,10)===e}Object.defineProperty(t,"__esModule",{value:!0}),t.resolveOperator=void 0,t.resolveOperator=function(e,t,r){for(const o of r){const r=o[0],i=o[1],a=o[2],s=o[3],u=o[4];if(e.opType===r)for(const e of t)if((e.domain===i||"ai.onnx"===e.domain&&""===i)&&n(e.version,a))return{opImpl:s,opInit:u}}throw new TypeError(`cannot resolve operator '${e.opType}' with opsets: ${t.map((e=>`${e.domain||"ai.onnx"} v${e.version}`)).join(", ")}`)}},1287:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.onnxruntime=void 0;const r=n(5686);var o,i;o=t.onnxruntime||(t.onnxruntime={}),function(e){let t;!function(e){e[e.UNDEFINED=0]="UNDEFINED",e[e.FLOAT=1]="FLOAT",e[e.INT=2]="INT",e[e.STRING=3]="STRING",e[e.TENSOR=4]="TENSOR",e[e.GRAPH=5]="GRAPH",e[e.FLOATS=6]="FLOATS",e[e.INTS=7]="INTS",e[e.STRINGS=8]="STRINGS",e[e.TENSORS=9]="TENSORS",e[e.GRAPHS=10]="GRAPHS",e[e.SPARSE_TENSOR=11]="SPARSE_TENSOR",e[e.SPARSE_TENSORS=12]="SPARSE_TENSORS"}(t=e.AttributeType||(e.AttributeType={}))}((i=o.experimental||(o.experimental={})).fbs||(i.fbs={})),function(e){!function(e){!function(e){let t;!function(e){e[e.UNKNOWN=0]="UNKNOWN",e[e.VALUE=1]="VALUE",e[e.PARAM=2]="PARAM"}(t=e.DimensionValueType||(e.DimensionValueType={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){let t;!function(e){e[e.UNDEFINED=0]="UNDEFINED",e[e.FLOAT=1]="FLOAT",e[e.UINT8=2]="UINT8",e[e.INT8=3]="INT8",e[e.UINT16=4]="UINT16",e[e.INT16=5]="INT16",e[e.INT32=6]="INT32",e[e.INT64=7]="INT64",e[e.STRING=8]="STRING",e[e.BOOL=9]="BOOL",e[e.FLOAT16=10]="FLOAT16",e[e.DOUBLE=11]="DOUBLE",e[e.UINT32=12]="UINT32",e[e.UINT64=13]="UINT64",e[e.COMPLEX64=14]="COMPLEX64",e[e.COMPLEX128=15]="COMPLEX128",e[e.BFLOAT16=16]="BFLOAT16"}(t=e.TensorDataType||(e.TensorDataType={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){let t;!function(e){e[e.Primitive=0]="Primitive",e[e.Fused=1]="Fused"}(t=e.NodeType||(e.NodeType={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){let t;!function(e){e[e.NONE=0]="NONE",e[e.tensor_type=1]="tensor_type",e[e.sequence_type=2]="sequence_type",e[e.map_type=3]="map_type"}(t=e.TypeInfoValue||(e.TypeInfoValue={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsShape(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsShape(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}dim(t,n){let r=this.bb.__offset(this.bb_pos,4);return r?(n||new e.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}dimLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}static startShape(e){e.startObject(1)}static addDim(e,t){e.addFieldOffset(0,t,0)}static createDimVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startDimVector(e,t){e.startVector(4,t,4)}static endShape(e){return e.endObject()}static createShape(e,t){return n.startShape(e),n.addDim(e,t),n.endShape(e)}}t.Shape=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsDimension(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsDimension(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}value(t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new e.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}denotation(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}static startDimension(e){e.startObject(2)}static addValue(e,t){e.addFieldOffset(0,t,0)}static addDenotation(e,t){e.addFieldOffset(1,t,0)}static endDimension(e){return e.endObject()}static createDimension(e,t,r){return n.startDimension(e),n.addValue(e,t),n.addDenotation(e,r),n.endDimension(e)}}t.Dimension=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsDimensionValue(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsDimensionValue(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}dimType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt8(this.bb_pos+t):e.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}dimParam(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}static startDimensionValue(e){e.startObject(3)}static addDimType(t,n){t.addFieldInt8(0,n,e.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(e,t){e.addFieldInt64(1,t,e.createLong(0,0))}static addDimParam(e,t){e.addFieldOffset(2,t,0)}static endDimensionValue(e){return e.endObject()}static createDimensionValue(e,t,r,o){return n.startDimensionValue(e),n.addDimType(e,t),n.addDimValue(e,r),n.addDimParam(e,o),n.endDimensionValue(e)}}t.DimensionValue=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTensorTypeAndShape(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTensorTypeAndShape(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}elemType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.TensorDataType.UNDEFINED}shape(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startTensorTypeAndShape(e){e.startObject(2)}static addElemType(t,n){t.addFieldInt32(0,n,e.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(e,t){e.addFieldOffset(1,t,0)}static endTensorTypeAndShape(e){return e.endObject()}static createTensorTypeAndShape(e,t,r){return n.startTensorTypeAndShape(e),n.addElemType(e,t),n.addShape(e,r),n.endTensorTypeAndShape(e)}}t.TensorTypeAndShape=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsMapType(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsMapType(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}keyType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.TensorDataType.UNDEFINED}valueType(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startMapType(e){e.startObject(2)}static addKeyType(t,n){t.addFieldInt32(0,n,e.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(e,t){e.addFieldOffset(1,t,0)}static endMapType(e){return e.endObject()}static createMapType(e,t,r){return n.startMapType(e),n.addKeyType(e,t),n.addValueType(e,r),n.endMapType(e)}}t.MapType=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSequenceType(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSequenceType(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}elemType(t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSequenceType(e){e.startObject(1)}static addElemType(e,t){e.addFieldOffset(0,t,0)}static endSequenceType(e){return e.endObject()}static createSequenceType(e,t){return n.startSequenceType(e),n.addElemType(e,t),n.endSequenceType(e)}}t.SequenceType=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){(e.fbs||(e.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(e,t,n,r){return e.prep(4,12),e.writeInt32(r),e.writeInt32(n),e.writeInt32(t),e.offset()}}}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsNodeEdge(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsNodeEdge(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}nodeIndex(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb_pos+e):0}inputEdges(t,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+r)+12*t,this.bb):null}inputEdgesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}outputEdges(t,n){let r=this.bb.__offset(this.bb_pos,8);return r?(n||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+r)+12*t,this.bb):null}outputEdgesLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}static startNodeEdge(e){e.startObject(3)}static addNodeIndex(e,t){e.addFieldInt32(0,t,0)}static addInputEdges(e,t){e.addFieldOffset(1,t,0)}static startInputEdgesVector(e,t){e.startVector(12,t,4)}static addOutputEdges(e,t){e.addFieldOffset(2,t,0)}static startOutputEdgesVector(e,t){e.startVector(12,t,4)}static endNodeEdge(e){return e.endObject()}static createNodeEdge(e,t,r,o){return n.startNodeEdge(e),n.addNodeIndex(e,t),n.addInputEdges(e,r),n.addOutputEdges(e,o),n.endNodeEdge(e)}}t.NodeEdge=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsNode(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsNode(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}domain(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}sinceVersion(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readInt32(this.bb_pos+e):0}index(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint32(this.bb_pos+e):0}opType(e){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb_pos+t,e):null}type(){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.NodeType.Primitive}executionProviderType(e){let t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__string(this.bb_pos+t,e):null}inputs(e,t){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}inputsLength(){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__vector_len(this.bb_pos+e):0}outputs(e,t){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}outputsLength(){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__vector_len(this.bb_pos+e):0}attributes(t,n){let r=this.bb.__offset(this.bb_pos,24);return r?(n||new e.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}attributesLength(){let e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__vector_len(this.bb_pos+e):0}inputArgCounts(e){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readInt32(this.bb.__vector(this.bb_pos+t)+4*e):0}inputArgCountsLength(){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__vector_len(this.bb_pos+e):0}inputArgCountsArray(){let e=this.bb.__offset(this.bb_pos,26);return e?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}implicitInputs(e,t){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}implicitInputsLength(){let e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__vector_len(this.bb_pos+e):0}static startNode(e){e.startObject(13)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addDomain(e,t){e.addFieldOffset(2,t,0)}static addSinceVersion(e,t){e.addFieldInt32(3,t,0)}static addIndex(e,t){e.addFieldInt32(4,t,0)}static addOpType(e,t){e.addFieldOffset(5,t,0)}static addType(t,n){t.addFieldInt32(6,n,e.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(e,t){e.addFieldOffset(7,t,0)}static addInputs(e,t){e.addFieldOffset(8,t,0)}static createInputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startInputsVector(e,t){e.startVector(4,t,4)}static addOutputs(e,t){e.addFieldOffset(9,t,0)}static createOutputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startOutputsVector(e,t){e.startVector(4,t,4)}static addAttributes(e,t){e.addFieldOffset(10,t,0)}static createAttributesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startAttributesVector(e,t){e.startVector(4,t,4)}static addInputArgCounts(e,t){e.addFieldOffset(11,t,0)}static createInputArgCountsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addInt32(t[n]);return e.endVector()}static startInputArgCountsVector(e,t){e.startVector(4,t,4)}static addImplicitInputs(e,t){e.addFieldOffset(12,t,0)}static createImplicitInputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startImplicitInputsVector(e,t){e.startVector(4,t,4)}static endNode(e){return e.endObject()}static createNode(e,t,r,o,i,a,s,u,l,c,p,d,f,h){return n.startNode(e),n.addName(e,t),n.addDocString(e,r),n.addDomain(e,o),n.addSinceVersion(e,i),n.addIndex(e,a),n.addOpType(e,s),n.addType(e,u),n.addExecutionProviderType(e,l),n.addInputs(e,c),n.addOutputs(e,p),n.addAttributes(e,d),n.addInputArgCounts(e,f),n.addImplicitInputs(e,h),n.endNode(e)}}t.Node=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsValueInfo(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsValueInfo(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}type(t){let n=this.bb.__offset(this.bb_pos,8);return n?(t||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startValueInfo(e){e.startObject(3)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addType(e,t){e.addFieldOffset(2,t,0)}static endValueInfo(e){return e.endObject()}static createValueInfo(e,t,r,o){return n.startValueInfo(e),n.addName(e,t),n.addDocString(e,r),n.addType(e,o),n.endValueInfo(e)}}t.ValueInfo=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTypeInfo(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTypeInfo(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}denotation(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}valueType(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint8(this.bb_pos+t):e.experimental.fbs.TypeInfoValue.NONE}value(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__union(e,this.bb_pos+t):null}static startTypeInfo(e){e.startObject(3)}static addDenotation(e,t){e.addFieldOffset(0,t,0)}static addValueType(t,n){t.addFieldInt8(1,n,e.experimental.fbs.TypeInfoValue.NONE)}static addValue(e,t){e.addFieldOffset(2,t,0)}static endTypeInfo(e){return e.endObject()}static createTypeInfo(e,t,r,o){return n.startTypeInfo(e),n.addDenotation(e,t),n.addValueType(e,r),n.addValue(e,o),n.endTypeInfo(e)}}t.TypeInfo=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){class t{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsOperatorSetId(e,n){return(n||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsOperatorSetId(e,n){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(n||new t).__init(e.readInt32(e.position())+e.position(),e)}domain(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}version(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}static startOperatorSetId(e){e.startObject(2)}static addDomain(e,t){e.addFieldOffset(0,t,0)}static addVersion(e,t){e.addFieldInt64(1,t,e.createLong(0,0))}static endOperatorSetId(e){return e.endObject()}static createOperatorSetId(e,n,r){return t.startOperatorSetId(e),t.addDomain(e,n),t.addVersion(e,r),t.endOperatorSetId(e)}}e.OperatorSetId=t}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTensor(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTensor(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}dims(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}dimsLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}dataType(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.TensorDataType.UNDEFINED}rawData(e){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readUint8(this.bb.__vector(this.bb_pos+t)+e):0}rawDataLength(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__vector_len(this.bb_pos+e):0}rawDataArray(){let e=this.bb.__offset(this.bb_pos,12);return e?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}stringData(e,t){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}stringDataLength(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__vector_len(this.bb_pos+e):0}static startTensor(e){e.startObject(6)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addDims(e,t){e.addFieldOffset(2,t,0)}static createDimsVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startDimsVector(e,t){e.startVector(8,t,8)}static addDataType(t,n){t.addFieldInt32(3,n,e.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(e,t){e.addFieldOffset(4,t,0)}static createRawDataVector(e,t){e.startVector(1,t.length,1);for(let n=t.length-1;n>=0;n--)e.addInt8(t[n]);return e.endVector()}static startRawDataVector(e,t){e.startVector(1,t,1)}static addStringData(e,t){e.addFieldOffset(5,t,0)}static createStringDataVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startStringDataVector(e,t){e.startVector(4,t,4)}static endTensor(e){return e.endObject()}static createTensor(e,t,r,o,i,a,s){return n.startTensor(e),n.addName(e,t),n.addDocString(e,r),n.addDims(e,o),n.addDataType(e,i),n.addRawData(e,a),n.addStringData(e,s),n.endTensor(e)}}t.Tensor=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSparseTensor(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSparseTensor(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}values(t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}indices(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}dims(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}dimsLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}static startSparseTensor(e){e.startObject(3)}static addValues(e,t){e.addFieldOffset(0,t,0)}static addIndices(e,t){e.addFieldOffset(1,t,0)}static addDims(e,t){e.addFieldOffset(2,t,0)}static createDimsVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startDimsVector(e,t){e.startVector(8,t,8)}static endSparseTensor(e){return e.endObject()}static createSparseTensor(e,t,r,o){return n.startSparseTensor(e),n.addValues(e,t),n.addIndices(e,r),n.addDims(e,o),n.endSparseTensor(e)}}t.SparseTensor=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsAttribute(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsAttribute(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}type(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.AttributeType.UNDEFINED}f(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readFloat32(this.bb_pos+e):0}i(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}s(e){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb_pos+t,e):null}t(t){let n=this.bb.__offset(this.bb_pos,16);return n?(t||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}g(t){let n=this.bb.__offset(this.bb_pos,18);return n?(t||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}floats(e){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.readFloat32(this.bb.__vector(this.bb_pos+t)+4*e):0}floatsLength(){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__vector_len(this.bb_pos+e):0}floatsArray(){let e=this.bb.__offset(this.bb_pos,20);return e?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}ints(e){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}intsLength(){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__vector_len(this.bb_pos+e):0}strings(e,t){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}stringsLength(){let e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__vector_len(this.bb_pos+e):0}tensors(t,n){let r=this.bb.__offset(this.bb_pos,26);return r?(n||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}tensorsLength(){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__vector_len(this.bb_pos+e):0}graphs(t,n){let r=this.bb.__offset(this.bb_pos,28);return r?(n||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}graphsLength(){let e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__vector_len(this.bb_pos+e):0}static startAttribute(e){e.startObject(13)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addType(t,n){t.addFieldInt32(2,n,e.experimental.fbs.AttributeType.UNDEFINED)}static addF(e,t){e.addFieldFloat32(3,t,0)}static addI(e,t){e.addFieldInt64(4,t,e.createLong(0,0))}static addS(e,t){e.addFieldOffset(5,t,0)}static addT(e,t){e.addFieldOffset(6,t,0)}static addG(e,t){e.addFieldOffset(7,t,0)}static addFloats(e,t){e.addFieldOffset(8,t,0)}static createFloatsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addFloat32(t[n]);return e.endVector()}static startFloatsVector(e,t){e.startVector(4,t,4)}static addInts(e,t){e.addFieldOffset(9,t,0)}static createIntsVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startIntsVector(e,t){e.startVector(8,t,8)}static addStrings(e,t){e.addFieldOffset(10,t,0)}static createStringsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startStringsVector(e,t){e.startVector(4,t,4)}static addTensors(e,t){e.addFieldOffset(11,t,0)}static createTensorsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startTensorsVector(e,t){e.startVector(4,t,4)}static addGraphs(e,t){e.addFieldOffset(12,t,0)}static createGraphsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startGraphsVector(e,t){e.startVector(4,t,4)}static endAttribute(e){return e.endObject()}static createAttribute(e,t,r,o,i,a,s,u,l,c,p,d,f,h){return n.startAttribute(e),n.addName(e,t),n.addDocString(e,r),n.addType(e,o),n.addF(e,i),n.addI(e,a),n.addS(e,s),n.addT(e,u),n.addG(e,l),n.addFloats(e,c),n.addInts(e,p),n.addStrings(e,d),n.addTensors(e,f),n.addGraphs(e,h),n.endAttribute(e)}}t.Attribute=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsGraph(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsGraph(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}initializers(t,n){let r=this.bb.__offset(this.bb_pos,4);return r?(n||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}initializersLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}nodeArgs(t,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new e.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}nodeArgsLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}nodes(t,n){let r=this.bb.__offset(this.bb_pos,8);return r?(n||new e.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}nodesLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}maxNodeIndex(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb_pos+e):0}nodeEdges(t,n){let r=this.bb.__offset(this.bb_pos,12);return r?(n||new e.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}nodeEdgesLength(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__vector_len(this.bb_pos+e):0}inputs(e,t){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}inputsLength(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__vector_len(this.bb_pos+e):0}outputs(e,t){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}outputsLength(){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.__vector_len(this.bb_pos+e):0}sparseInitializers(t,n){let r=this.bb.__offset(this.bb_pos,18);return r?(n||new e.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}sparseInitializersLength(){let e=this.bb.__offset(this.bb_pos,18);return e?this.bb.__vector_len(this.bb_pos+e):0}static startGraph(e){e.startObject(8)}static addInitializers(e,t){e.addFieldOffset(0,t,0)}static createInitializersVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startInitializersVector(e,t){e.startVector(4,t,4)}static addNodeArgs(e,t){e.addFieldOffset(1,t,0)}static createNodeArgsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startNodeArgsVector(e,t){e.startVector(4,t,4)}static addNodes(e,t){e.addFieldOffset(2,t,0)}static createNodesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startNodesVector(e,t){e.startVector(4,t,4)}static addMaxNodeIndex(e,t){e.addFieldInt32(3,t,0)}static addNodeEdges(e,t){e.addFieldOffset(4,t,0)}static createNodeEdgesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startNodeEdgesVector(e,t){e.startVector(4,t,4)}static addInputs(e,t){e.addFieldOffset(5,t,0)}static createInputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startInputsVector(e,t){e.startVector(4,t,4)}static addOutputs(e,t){e.addFieldOffset(6,t,0)}static createOutputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startOutputsVector(e,t){e.startVector(4,t,4)}static addSparseInitializers(e,t){e.addFieldOffset(7,t,0)}static createSparseInitializersVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startSparseInitializersVector(e,t){e.startVector(4,t,4)}static endGraph(e){return e.endObject()}static createGraph(e,t,r,o,i,a,s,u,l){return n.startGraph(e),n.addInitializers(e,t),n.addNodeArgs(e,r),n.addNodes(e,o),n.addMaxNodeIndex(e,i),n.addNodeEdges(e,a),n.addInputs(e,s),n.addOutputs(e,u),n.addSparseInitializers(e,l),n.endGraph(e)}}t.Graph=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsModel(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsModel(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}irVersion(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}opsetImport(t,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new e.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}opsetImportLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}producerName(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}producerVersion(e){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__string(this.bb_pos+t,e):null}domain(e){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__string(this.bb_pos+t,e):null}modelVersion(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}docString(e){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__string(this.bb_pos+t,e):null}graph(t){let n=this.bb.__offset(this.bb_pos,18);return n?(t||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}graphDocString(e){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__string(this.bb_pos+t,e):null}static startModel(e){e.startObject(9)}static addIrVersion(e,t){e.addFieldInt64(0,t,e.createLong(0,0))}static addOpsetImport(e,t){e.addFieldOffset(1,t,0)}static createOpsetImportVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startOpsetImportVector(e,t){e.startVector(4,t,4)}static addProducerName(e,t){e.addFieldOffset(2,t,0)}static addProducerVersion(e,t){e.addFieldOffset(3,t,0)}static addDomain(e,t){e.addFieldOffset(4,t,0)}static addModelVersion(e,t){e.addFieldInt64(5,t,e.createLong(0,0))}static addDocString(e,t){e.addFieldOffset(6,t,0)}static addGraph(e,t){e.addFieldOffset(7,t,0)}static addGraphDocString(e,t){e.addFieldOffset(8,t,0)}static endModel(e){return e.endObject()}static createModel(e,t,r,o,i,a,s,u,l,c){return n.startModel(e),n.addIrVersion(e,t),n.addOpsetImport(e,r),n.addProducerName(e,o),n.addProducerVersion(e,i),n.addDomain(e,a),n.addModelVersion(e,s),n.addDocString(e,u),n.addGraph(e,l),n.addGraphDocString(e,c),n.endModel(e)}}t.Model=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){class t{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsKernelCreateInfos(e,n){return(n||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsKernelCreateInfos(e,n){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(n||new t).__init(e.readInt32(e.position())+e.position(),e)}nodeIndices(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb.__vector(this.bb_pos+t)+4*e):0}nodeIndicesLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}nodeIndicesArray(){let e=this.bb.__offset(this.bb_pos,4);return e?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}kernelDefHashes(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}kernelDefHashesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}static startKernelCreateInfos(e){e.startObject(2)}static addNodeIndices(e,t){e.addFieldOffset(0,t,0)}static createNodeIndicesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addInt32(t[n]);return e.endVector()}static startNodeIndicesVector(e,t){e.startVector(4,t,4)}static addKernelDefHashes(e,t){e.addFieldOffset(1,t,0)}static createKernelDefHashesVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startKernelDefHashesVector(e,t){e.startVector(8,t,8)}static endKernelCreateInfos(e){return e.endObject()}static createKernelCreateInfos(e,n,r){return t.startKernelCreateInfos(e),t.addNodeIndices(e,n),t.addKernelDefHashes(e,r),t.endKernelCreateInfos(e)}}e.KernelCreateInfos=t}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSubGraphSessionState(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSubGraphSessionState(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}graphId(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}sessionState(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSubGraphSessionState(e){e.startObject(2)}static addGraphId(e,t){e.addFieldOffset(0,t,0)}static addSessionState(e,t){e.addFieldOffset(1,t,0)}static endSubGraphSessionState(e){let t=e.endObject();return e.requiredField(t,4),t}static createSubGraphSessionState(e,t,r){return n.startSubGraphSessionState(e),n.addGraphId(e,t),n.addSessionState(e,r),n.endSubGraphSessionState(e)}}t.SubGraphSessionState=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSessionState(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSessionState(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}kernels(t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new e.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}subGraphSessionStates(t,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new e.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}subGraphSessionStatesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}static startSessionState(e){e.startObject(2)}static addKernels(e,t){e.addFieldOffset(0,t,0)}static addSubGraphSessionStates(e,t){e.addFieldOffset(1,t,0)}static createSubGraphSessionStatesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startSubGraphSessionStatesVector(e,t){e.startVector(4,t,4)}static endSessionState(e){return e.endObject()}static createSessionState(e,t,r){return n.startSessionState(e),n.addKernels(e,t),n.addSubGraphSessionStates(e,r),n.endSessionState(e)}}t.SessionState=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsInferenceSession(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsInferenceSession(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static bufferHasIdentifier(e){return e.__has_identifier("ORTM")}ortVersion(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}model(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}sessionState(t){let n=this.bb.__offset(this.bb_pos,8);return n?(t||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startInferenceSession(e){e.startObject(3)}static addOrtVersion(e,t){e.addFieldOffset(0,t,0)}static addModel(e,t){e.addFieldOffset(1,t,0)}static addSessionState(e,t){e.addFieldOffset(2,t,0)}static endInferenceSession(e){return e.endObject()}static finishInferenceSessionBuffer(e,t){e.finish(t,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(e,t){e.finish(t,"ORTM",!0)}static createInferenceSession(e,t,r,o){return n.startInferenceSession(e),n.addOrtVersion(e,t),n.addModel(e,r),n.addSessionState(e,o),n.endInferenceSession(e)}}t.InferenceSession=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={}))},1723:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.OnnxjsSessionHandler=void 0;const r=n(8453),o=n(9240);t.OnnxjsSessionHandler=class{constructor(e){this.session=e,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(e,t,n){const i=new Map;for(const t in e)if(Object.hasOwnProperty.call(e,t)){const n=e[t];i.set(t,new o.Tensor(n.dims,n.type,void 0,void 0,n.data))}const a=await this.session.run(i),s={};return a.forEach(((e,t)=>{s[t]=new r.Tensor(e.type,e.data,e.dims)})),s}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6027:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Session=void 0;const r=n(7067),o=n(1296),i=n(1975),a=n(6496),s=n(1315),u=n(1745);t.Session=class{constructor(e={}){this._initialized=!1,this.backendHint=e.backendHint,this.profiler=s.Profiler.create(e.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(e,t,n){await this.profiler.event("session","Session.loadModel",(async()=>{const a=await(0,i.resolveBackend)(this.backendHint);if(this.sessionHandler=a.createSessionHandler(this.context),this._model=new u.Model,"string"==typeof e){const t=e.endsWith(".ort");if("undefined"==typeof fetch){const n=await(0,o.promisify)(r.readFile)(e);this.initialize(n,t)}else{const n=await fetch(e),r=await n.arrayBuffer();this.initialize(new Uint8Array(r),t)}}else if(ArrayBuffer.isView(e))this.initialize(e);else{const r=new Uint8Array(e,t||0,n||e.byteLength);this.initialize(r)}}))}initialize(e,t){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",(()=>{const n=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(e,n,t),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new a.ExecutionPlan(this._model.graph,this._ops,this.profiler)})),this._initialized=!0}async run(e){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",(async()=>{const t=this.normalizeAndValidateInputs(e),n=await this._executionPlan.execute(this.sessionHandler,t);return this.createOutput(n)}))}normalizeAndValidateInputs(e){const t=this._model.graph.getInputNames();if(Array.isArray(e)){if(e.length!==t.length)throw new Error(`incorrect input array length: expected ${t.length} but got ${e.length}`)}else{if(e.size!==t.length)throw new Error(`incorrect input map size: expected ${t.length} but got ${e.size}`);const n=new Array(e.size);let r=0;for(let o=0;o<t.length;++o){const i=e.get(t[o]);if(!i)throw new Error(`missing input tensor for: '${name}'`);n[r++]=i}e=n}if(this.context.graphInputTypes&&0!==this.context.graphInputTypes.length&&this.context.graphInputDims&&0!==this.context.graphInputDims.length)this.validateInputTensorDims(this.context.graphInputDims,e,!1);else{const t=this._model.graph.getInputIndices(),n=this._model.graph.getValues(),r=new Array(t.length);for(let o=0;o<t.length;++o){const i=n[t[o]];r[o]=i.type.shape.dims,this.context.graphInputTypes.push(i.type.tensorType),this.context.graphInputDims.push(e[o].dims)}this.validateInputTensorDims(r,e,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,e),e}validateInputTensorTypes(e,t){for(let n=0;n<t.length;n++){const r=e[n],o=t[n].type;if(r!==o)throw new Error(`input tensor[${n}] check failed: expected type '${r}' but got ${o}`)}}validateInputTensorDims(e,t,n){for(let r=0;r<t.length;r++){const o=e[r],i=t[r].dims;if(!this.compareTensorDims(o,i,n))throw new Error(`input tensor[${r}] check failed: expected shape '[${o.join(",")}]' but got [${i.join(",")}]`)}}compareTensorDims(e,t,n){if(e.length!==t.length)return!1;for(let r=0;r<e.length;++r)if(e[r]!==t[r]&&(!n||0!==e[r]))return!1;return!0}createOutput(e){const t=this._model.graph.getOutputNames();if(e.length!==t.length)throw new Error("expected number of outputs do not match number of generated outputs");const n=new Map;for(let r=0;r<t.length;++r)n.set(t[r],e[r]);return n}initializeOps(e){const t=e.getNodes();this._ops=new Array(t.length);for(let n=0;n<t.length;n++)this._ops[n]=this.sessionHandler.resolve(t[n],this._model.opsets,e)}}},9240:function(e,t,n){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.Tensor=void 0;const o=n(3442),i=r(n(3720)),a=n(1446),s=n(1287),u=n(7273);var l=s.onnxruntime.experimental.fbs;class c{get data(){if(void 0===this.cache){const e=this.dataProvider(this.dataId);if(e.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=e}return this.cache}get stringData(){if("string"!==this.type)throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if("string"!==this.type)return this.data;throw new TypeError("type cannot be non-number (string)")}get(e){return this.data[u.ShapeUtil.indicesToOffset(e,this.strides)]}set(e,t){this.data[u.ShapeUtil.indicesToOffset(e,this.strides)]=t}async getData(){return void 0===this.cache&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=u.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(e,t,n,r,i,a=o.Guid.create()){this.dims=e,this.type=t,this.dataProvider=n,this.asyncDataProvider=r,this.cache=i,this.dataId=a,this.size=u.ShapeUtil.validateDimsAndCalcSize(e);const s=this.size,l=void 0===n&&void 0===r&&void 0===i;if(void 0!==i&&i.length!==s)throw new RangeError("Input dims doesn't match data length.");if("string"===t){if(!(void 0===i||Array.isArray(i)&&i.every((e=>"string"==typeof e))))throw new TypeError("cache should be a string array");l&&(this.cache=new Array(s))}else{if(void 0!==i){const e=d(t);if(!(i instanceof e))throw new TypeError(`cache should be type ${e.name}`)}if(l){const e=new ArrayBuffer(s*function(e){switch(e){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${e}`)}}(t));this.cache=function(e,t){return new(d(t))(e)}(e,t)}}}static fromProto(e){if(!e)throw new Error("cannot construct Value from an empty tensor");const t=u.ProtoUtil.tensorDataTypeFromProto(e.dataType),n=u.ProtoUtil.tensorDimsFromProto(e.dims),r=new c(n,t);if("string"===t)e.stringData.forEach(((e,t)=>{r.data[t]=(0,u.decodeUtf8String)(e)}));else if(e.rawData&&"number"==typeof e.rawData.byteLength&&e.rawData.byteLength>0){const t=r.data,n=new DataView(e.rawData.buffer,e.rawData.byteOffset,e.rawData.byteLength),o=p(e.dataType),i=e.rawData.byteLength/o;if(e.rawData.byteLength%o!=0)throw new Error("invalid buffer length");if(t.length!==i)throw new Error("buffer length mismatch");for(let r=0;r<i;r++){const i=h(n,e.dataType,r*o);t[r]=i}}else{let t;switch(e.dataType){case a.onnx.TensorProto.DataType.FLOAT:t=e.floatData;break;case a.onnx.TensorProto.DataType.INT32:case a.onnx.TensorProto.DataType.INT16:case a.onnx.TensorProto.DataType.UINT16:case a.onnx.TensorProto.DataType.INT8:case a.onnx.TensorProto.DataType.UINT8:case a.onnx.TensorProto.DataType.BOOL:t=e.int32Data;break;case a.onnx.TensorProto.DataType.INT64:t=e.int64Data;break;case a.onnx.TensorProto.DataType.DOUBLE:t=e.doubleData;break;case a.onnx.TensorProto.DataType.UINT32:case a.onnx.TensorProto.DataType.UINT64:t=e.uint64Data;break;default:throw new Error("unspecific error")}if(null==t)throw new Error("failed to populate data from a tensorproto value");const n=r.data;if(n.length!==t.length)throw new Error("array length mismatch");for(let r=0;r<t.length;r++){const o=t[r];i.default.isLong(o)?n[r]=f(o,e.dataType):n[r]=o}}return r}static fromData(e,t,n){return new c(t,n,void 0,void 0,e)}static fromOrtTensor(e){if(!e)throw new Error("cannot construct Value from an empty tensor");const t=u.ProtoUtil.tensorDimsFromORTFormat(e),n=u.ProtoUtil.tensorDataTypeFromProto(e.dataType()),r=new c(t,n);if("string"===n)for(let t=0;t<e.stringDataLength();t++)r.data[t]=e.stringData(t);else if(e.rawDataArray()&&"number"==typeof e.rawDataLength()&&e.rawDataLength()>0){const t=r.data,n=new DataView(e.rawDataArray().buffer,e.rawDataArray().byteOffset,e.rawDataLength()),o=p(e.dataType()),i=e.rawDataLength()/o;if(e.rawDataLength()%o!=0)throw new Error("invalid buffer length");if(t.length!==i)throw new Error("buffer length mismatch");for(let r=0;r<i;r++){const i=h(n,e.dataType(),r*o);t[r]=i}}return r}}function p(e){switch(e){case a.onnx.TensorProto.DataType.UINT8:case a.onnx.TensorProto.DataType.INT8:case a.onnx.TensorProto.DataType.BOOL:return 1;case a.onnx.TensorProto.DataType.UINT16:case a.onnx.TensorProto.DataType.INT16:return 2;case a.onnx.TensorProto.DataType.FLOAT:case a.onnx.TensorProto.DataType.INT32:case a.onnx.TensorProto.DataType.UINT32:return 4;case a.onnx.TensorProto.DataType.INT64:case a.onnx.TensorProto.DataType.DOUBLE:case a.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${a.onnx.TensorProto.DataType[e]}`)}}function d(e){switch(e){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function f(e,t){if(t===a.onnx.TensorProto.DataType.INT64||t===l.TensorDataType.INT64){if(e.greaterThanOrEqual(2147483648)||e.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(t!==a.onnx.TensorProto.DataType.UINT32&&t!==l.TensorDataType.UINT32&&t!==a.onnx.TensorProto.DataType.UINT64&&t!==l.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${a.onnx.TensorProto.DataType[t]}`);if(e.greaterThanOrEqual(4294967296)||e.lessThan(0))throw new TypeError("uint64 is not supported")}return e.toNumber()}function h(e,t,n){switch(t){case a.onnx.TensorProto.DataType.BOOL:case a.onnx.TensorProto.DataType.UINT8:return e.getUint8(n);case a.onnx.TensorProto.DataType.INT8:return e.getInt8(n);case a.onnx.TensorProto.DataType.UINT16:return e.getUint16(n,!0);case a.onnx.TensorProto.DataType.INT16:return e.getInt16(n,!0);case a.onnx.TensorProto.DataType.FLOAT:return e.getFloat32(n,!0);case a.onnx.TensorProto.DataType.INT32:return e.getInt32(n,!0);case a.onnx.TensorProto.DataType.UINT32:return e.getUint32(n,!0);case a.onnx.TensorProto.DataType.INT64:return f(i.default.fromBits(e.getUint32(n,!0),e.getUint32(n+4,!0),!1),t);case a.onnx.TensorProto.DataType.DOUBLE:return e.getFloat64(n,!0);case a.onnx.TensorProto.DataType.UINT64:return f(i.default.fromBits(e.getUint32(n,!0),e.getUint32(n+4,!0),!0),t);default:throw new Error(`cannot read from DataView for type ${a.onnx.TensorProto.DataType[t]}`)}}t.Tensor=c},7273:function(e,t,n){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.decodeUtf8String=t.MAX_CLIP=t.MIN_CLIP=t.PoolConvUtil=t.ReduceUtil=t.SplitUtil=t.MathUtil=t.ShapeUtil=t.LongUtil=t.ProtoUtil=t.GemmUtil=t.arrayCopyHelper=t.BroadcastUtil=t.MatMulUtil=t.ArrayUtil=t.assert=t.checkInputsShape=void 0;const o=n(5686),i=r(n(3720)),a=n(1446),s=n(9240);t.checkInputsShape=function(e,...t){if(!e||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(!e[n].dims||e[n].dims.length!==t[n])return!1;return!0},t.assert=function(e,t){if(!e)throw new Error("string"==typeof t?t:t())},t.ArrayUtil=class{static arraysEqual(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}};class u{static preprocessInputShapes(e,t){return[1===e.length?[1,e[0]]:e,1===t.length?[t[0],1]:t]}static postprocessOutputShape(e,t,n){1===t&&e.splice(e.length-2,1),1===n&&e.pop()}static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}}t.MatMulUtil=u;class l{static calcShape(e,t,n=!1){const r=e.length,o=t.length;if(0===r)return t;if(0===o)return e;const i=Math.max(e.length,t.length),a=new Array(i);if(n){if(r<2||o<2)return;const n=u.calcMatMulShape([e[r-2],e[r-1]],[t[o-2],t[o-1]]);if(void 0===n)return;[a[i-2],a[i-1]]=n}for(let s=n?3:1;s<=i;s++){const n=r-s<0?1:e[r-s],u=o-s<0?1:t[o-s];if(n!==u&&n>1&&u>1)return;a[i-s]=Math.max(n,u)}return a}static index(e,t){const n=new Array(t.length);return l.fillIndex(e,t,n),n}static fillIndex(e,t,n){const r=e.length-t.length;for(let o=0;o<t.length;o++)n[o]=e[r+o]%t[o]}static calc(e,t,n,r,o){const i=l.calcShape(e.dims,t.dims);if(i){if(r&&!d.areEqual(i,e.dims))return;const a=d.size(i),u=r?e:new s.Tensor(i,o||e.type);if(0===i.length)u.set([],n(e.get([]),t.get([])));else{const r=new Array(i.length),o=new Array(e.dims.length),s=new Array(t.dims.length);let c,p=0,d=0,f=!1,h=!1;0===e.dims.length&&(p=e.get([]),f=!0),0===t.dims.length&&(d=t.get([]),h=!0);for(let g=0;g<a;g++){c=g;for(let e=i.length-1;e>=0;e--)r[e]=c%i[e],c=Math.floor(c/i[e]);f||(l.fillIndex(r,e.dims,o),p=e.get(o)),h||(l.fillIndex(r,t.dims,s),d=t.get(s)),u.set(r,n(p,d))}}return u}}static isValidBroadcast(e,t){const n=e.length,r=t.length;if(n>r)return!1;for(let o=1;o<=n;o++)if(1!==e[n-o]&&e[n-o]!==t[r-o])return!1;return!0}static getBroadcastDims(e,t){const n=e.length,r=[];for(let o=0;o<n;o++){const i=n-1-o,a=e[i]||1;(t[t.length-1-o]||1)>1&&1===a&&r.unshift(i)}return r}}t.BroadcastUtil=l,t.arrayCopyHelper=function(e,t,n,r,o){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+o>t.length)throw new Error("source indices to be copied are outside bounds");if(n+o>e.length)throw new Error("target array is too small to hold result");for(let i=0;i<o;i++)e[n+i]=t[r+i]},t.GemmUtil=class{static getShapeOfGemmResult(e,t,n,r,o){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let i,a,s;t?(i=e[1],a=e[0]):(i=e[0],a=e[1]);let u=-1;if(r?(s=n[0],u=1):(s=n[1],u=0),n[u]!==a)throw new Error("dimension mismatch");if(i<=0||s<=0||a<=0)throw new Error("invalid shape specified");if(o&&!l.isValidBroadcast(o,[i,s]))throw new Error("gemm: invalid bias shape for broadcast");return[i,s,a]}};class c{static tensorDataTypeFromProto(e){switch(e){case a.onnx.TensorProto.DataType.INT8:return"int8";case a.onnx.TensorProto.DataType.UINT8:return"uint8";case a.onnx.TensorProto.DataType.BOOL:return"bool";case a.onnx.TensorProto.DataType.INT16:return"int16";case a.onnx.TensorProto.DataType.UINT16:return"uint16";case a.onnx.TensorProto.DataType.INT32:return"int32";case a.onnx.TensorProto.DataType.UINT32:return"uint32";case a.onnx.TensorProto.DataType.FLOAT:return"float32";case a.onnx.TensorProto.DataType.DOUBLE:return"float64";case a.onnx.TensorProto.DataType.STRING:return"string";case a.onnx.TensorProto.DataType.INT64:return"int32";case a.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${a.onnx.TensorProto.DataType[e]}`)}}static tensorDataTypeStringToEnum(e){switch(e){case"int8":return a.onnx.TensorProto.DataType.INT8;case"uint8":return a.onnx.TensorProto.DataType.UINT8;case"bool":return a.onnx.TensorProto.DataType.BOOL;case"int16":return a.onnx.TensorProto.DataType.INT16;case"uint16":return a.onnx.TensorProto.DataType.UINT16;case"int32":return a.onnx.TensorProto.DataType.INT32;case"uint32":return a.onnx.TensorProto.DataType.UINT32;case"float32":return a.onnx.TensorProto.DataType.FLOAT;case"float64":return a.onnx.TensorProto.DataType.DOUBLE;case"string":return a.onnx.TensorProto.DataType.STRING;case"int64":return a.onnx.TensorProto.DataType.INT64;case"uint64":return a.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${e}`)}}static tensorDimsFromProto(e){return e.map((e=>i.default.isLong(e)?e.toNumber():e))}static tensorValueTypeFromProto(e){return{tensorType:c.tensorDataTypeFromProto(e.elemType),shape:{dims:c.tensorDimsFromProto(e.shape.dim.map((e=>e.dimValue)))}}}static tensorDimsFromORTFormat(e){const t=[];for(let n=0;n<e.dimsLength();n++)t.push(p.longToNumber(e.dims(n)));return t}static tensorAttributesFromORTFormat(e){const t=[];for(let n=0;n<e.attributesLength();n++)t.push(e.attributes(n));return t}}t.ProtoUtil=c;class p{static longToNumber(e,t){return i.default.isLong(e)?e.toNumber():e instanceof o.flatbuffers.Long?i.default.fromValue({low:e.low,high:e.high,unsigned:null!=t&&t}).toNumber():e}static isLong(e){return i.default.isLong(e)||e instanceof o.flatbuffers.Long}}t.LongUtil=p;class d{static size(e){return d.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return d.getSizeFromDimensionRange(e,t,e.length)}static sizeToDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${e.length} dimensions.`);return d.getSizeFromDimensionRange(e,0,t)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let o=t;o<n;o++){if(e[o]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");r*=e[o]}return r}static computeStrides(e){const t=e.length;if(0===t)return[];if(1===t)return[1];const n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static transpose(e){return e.slice().reverse()}static indicesToOffset(e,t,n){void 0===n&&(n=e.length);let r=0;for(let o=0;o<n;++o)r+=t[o]*e[o];return r}static offsetToIndices(e,t){const n=t.length;if(0===n)return[];if(1===n)return[e*t[0]];const r=new Array(t.length);for(let n=0;n<r.length-1;++n)r[n]=Math.floor(e/t[n]),e-=r[n]*t[n];return r[r.length-1]=e,r}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((e=>this.normalizeAxis(e,t)))}static incrementIndex(e,t,n){if(0===t.length||0===e.length)throw new Error("Index incrementing unsupported for scalar Tensor");if(void 0===n)n=t.length;else if(n<=0||n>t.length)throw new Error("Incorrect axis to increment on");for(let r=n-1;r>=0&&(e[r]++,!(e[r]<t[r]));--r)e[r]=0}static calculateReshapedDims(e,t){if(0===t.length){if(0===e.length||1===d.size(e))return[];throw new Error("cannot reshape to a scalar Tensor")}const n=t.length,r=new Array(n);let o=-1,i=1;for(let a=0;a<n;a++){if(t[a]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(-1===t[a]){if(-1!==o)throw new Error("at most one dimension in shape hints can be -1");o=a}else{if(0===t[a]){if(a>=e.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");r[a]=e[a]}else r[a]=t[a];i*=r[a]}}const a=d.size(e);if(-1!==o){if(a%i!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e}] Output shape: [${t}]`);r[o]=a/i}else if(i!==a)throw new Error("reshapedDims and originalDims don't have matching sizes");return r}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){const n=e.length;return e.map(((e,r)=>e+t[r]+t[r+n]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,n)=>e===t[n]))}static validateDimsAndCalcSize(e){if(e.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let t=1;for(const n of e){if(!Number.isInteger(n))throw new TypeError(`Invalid shape: ${n} is not an integer`);if(n<0||n>2147483647)throw new TypeError(`Invalid shape: length ${n} is not allowed`);t*=n}return t}static flattenShape(e,t){t<0&&(t+=e.length);const n=e.reduce(((e,t)=>e*t),1),r=e.slice(t).reduce(((e,t)=>e*t),1);return[n/r,r]}static squeezeShape(e,t){const n=new Array;t=d.normalizeAxes(t,e.length);for(let r=0;r<e.length;r++){const o=t.indexOf(r)>=0;if(o&&1!==e[r])throw new Error("squeeze an axis of size different than 1");(0===t.length&&e[r]>1||t.length>0&&!o)&&n.push(e[r])}return n}static unsqueezeShape(e,t){const n=new Array(e.length+t.length);n.fill(0);for(let e=0;e<t.length;e++){const r=d.normalizeAxis(t[e],n.length);if(r>=n.length)throw new Error("'axes' has an out of range axis");if(0!==n[r])throw new Error("'axes' has a duplicate axis");n[r]=1}let r=0;for(let t=0;t<n.length;t++)0===n[t]&&(n[t]=e[r++]);if(r!==e.length)throw new Error("the unsqueezed dimension could not be established");return n}}t.ShapeUtil=d,t.MathUtil=class{static sqr(e,t,n,r,o){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+o>t.length)throw new Error("source indices to be copied are outside bounds");if(n+o>e.length)throw new Error("target array is too small to hold result");for(let i=0;i<o;i++)e[n+i]+=Math.pow(t[r+i],2)}static axpy(e,t,n,r,o,i){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+o>t.length)throw new Error("source indices to be copied are outside bounds");if(n+o>e.length)throw new Error("target array is too small to hold result");for(let a=0;a<o;a++)e[n+a]+=i*t[r+a]}static powx(e,t,n,r,o,i){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+o>t.length)throw new Error("source indices to be copied are outside bounds");if(n+o>e.length)throw new Error("target array is too small to hold result");for(let a=0;a<o;a++)e[n+a]=Math.pow(t[r+a],i)}static mul(e,t,n,r,o){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+o>t.length)throw new Error("source indices to be copied are outside bounds");if(n+o>e.length)throw new Error("target array is too small to hold result");for(let i=0;i<o;i++)e[n+i]=t[r+i]*e[n+i]}};class f{static splitShape(e,t,n,r){if(0===n.length){if(!r)throw new Error("need to know number of outputs when the 'split' attribute is not specified");f.determineSplit(e[t],r,n)}const o=[],i=[0];for(let r=0;r<n.length;++r){0!==r&&i.push(i[r-1]+n[r-1]);const a=e.slice();a[t]=n[r],o.push(a)}return[o,i]}static determineSplit(e,t,n){if(e%t!=0)throw new Error("cannot split tensor to equal sized parts");for(let r=0;r<t;++r)n.push(e/t)}}t.SplitUtil=f;class h{static calcReduce(e,t,n,r,o){const i=e.dims.slice(0);0===t.length&&i.forEach(((e,n)=>t.push(n)));const a=h.calcReduceShape(i,t,!0),u=d.size(a),c=new s.Tensor(a,e.type),p=d.computeStrides(a),f=d.computeStrides(i),g=new Array(i.length);for(let n=0;n<u;n++){const a=d.offsetToIndices(n,p);l.fillIndex(a,i,g),c.set(a,h.calcReduceByAxis(e.numberData,t,i,0,d.indicesToOffset(g,f),r,o))}return n?c:new s.Tensor(h.calcReduceShape(i,t,n),c.type,void 0,void 0,c.data,c.dataId)}static calcReduceByAxis(e,t,n,r,o,i,a){let s=0;if(r>=t.length)return i(e[o]);const u=t[r],l=u>=n.length?1:d.size(n.slice(u+1));for(let c=0;c<n[u];c++)s=0===c?h.calcReduceByAxis(e,t,n,r+1,o,i,a):a(s,h.calcReduceByAxis(e,t,n,r+1,o,i,a)),o+=l;return s}static calcReduceShape(e,t,n){const r=e.slice();for(let e=0;e<t.length;e++)r[t[e]]=n?1:0;return r.filter((e=>0!==e))}}t.ReduceUtil=h;class g{static adjustPoolAttributes(e,t,n,r,o,i){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<o.length){if(o[e]<0)throw new Error("dilations should be greater than or equal to 1")}else o.push(1);for(let e=0;e<2*n.length;e++)if(e<i.length){if(i[e]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[e]>=n[e]||i[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,t,n,r,o,i){if(i){if(o.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(t.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let a=0;a<e.length-2;a++)g.adjustPadAndReturnShape(e[a+2],t[a],n[a],r[a],o,a,a+e.length-2,i)}}static computePoolOutputShape(e,t,n,r,o,i,a){if(t.length<=0)throw new Error("input shape must be of size greater than 0");const s=[t[0],t[1]];return g.computeShapeHelper(e,t,s,n,r,o,i,a),s}static computeConvOutputShape(e,t,n,r,o,i,a){if(e.length<=0||t.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const s=[e[0],t[0]];return g.computeShapeHelper(!1,e,s,n,r,o,i,a),s}static computeShapeHelper(e,t,n,r,o,i,a,s){if(e)for(let e=0;e<t.length-2;e++)n.push(1);else for(let e=0;e<t.length-2;e++)n.push(g.adjustPadAndReturnShape(t[e+2],r[e],o[e],i[e],a,e,e+t.length-2,s))}static adjustPadAndReturnShape(e,t,n,r,o,i,a,s){const u=n*(r-1)+1;if(!s||"NOTSET"===s)return Math.floor((e+o[i]+o[a]-u)/t+1);switch(s){case"VALID":return o[i]=0,o[a]=0,Math.floor((e-u)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const n=((e+t-1)/t-1)*t+r-e;return o[i]="SAME_LOWER"===s?Math.floor((n+1)/2):Math.floor(n/2),o[a]=n-o[i],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}}t.PoolConvUtil=g,t.MIN_CLIP=-34028234663852886e22,t.MAX_CLIP=34028234663852886e22,t.decodeUtf8String=function(e){return(new TextDecoder).decode(e)}},3838:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebGpuBackend=void 0;const r=n(8453),o=n(4955),i=n(7771),a=n(8510),s=n(8305);t.WebGpuBackend=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.pendingDispatchNumber=0,this.profilingEnabled=!1}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");const e=await navigator.gpu.requestAdapter();if(!e)throw new Error("WebGpuBackend: Failed to get GPU adapter.");const t={requiredLimits:{maxComputeWorkgroupStorageSize:e.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:e.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:e.limits.maxStorageBufferBindingSize}};e.features.has("timestamp-query-inside-passes")&&"default"===r.env.webgpu.profilingMode&&(this.profilingEnabled=!0,t.requiredFeatures=["timestamp-query-inside-passes"]),this.device=await e.requestDevice(t),this.gpuDataManager=(0,i.createGpuDataManager)(this),this.programManager=new s.ProgramManager(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,this.device.onuncapturederror=e=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},this.profilingEnabled&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2}))}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0}run(e,t,n,r,i){if(t.length!==e.inputTypes.length)throw new Error(`Input size must be equal to ${e.inputTypes.length}.`);const a=[];for(let e=0;e<t.length;++e){const n=this.gpuDataManager.get(t[e].data);if(!n)throw new Error(`no GPU data for input: ${t[e].data}`);a[e]=n}const s=((e,t,n)=>{const r=t.map((e=>`${e.join(",")}`)).join("_"),o=n.join("_");let i=e.name;return e.cacheHint&&(i+="["+e.cacheHint+"]"),i+=":"+r+";"+o,i})(e,t.map((e=>e.dims)),a.map((e=>e.type)));let u=this.programManager.getArtifact(s);const l=u?u.programInfo:"function"==typeof e.get?e.get():e,c=0===n.length?l.outputs.map(((e,t)=>t)):n;if(c.length!==l.outputs.length)throw new Error(`Output size ${c.length} must be equal to ${l.outputs.length}.`);const p=[],d=[];for(let e=0;e<l.outputs.length;++e){if(!Number.isInteger(c[e])||c[e]<-2||c[e]>=l.outputs.length)throw new Error(`Invalid output index: ${c[e]}`);const t=-1===c[e],n=-2===c[e],o=t||n?i(l.outputs[e].dataType,l.outputs[e].dims):r(c[e],l.outputs[e].dataType,l.outputs[e].dims),a=this.gpuDataManager.get(o.data);if(!a)throw new Error(`no GPU data for output: ${o.data}`);if(t&&this.temporaryData.push(a),n){let e=this.kernelPersistentData.get(this.currentKernelId);e||(e=[],this.kernelPersistentData.set(this.currentKernelId,e)),e.push(a)}p.push(o),d.push(a)}const f=this.programManager.normalizeDispatchGroupSize(l.dispatchGroup(t));return u||(u=this.programManager.build(l,f),this.programManager.setArtifact(s,u)),(0,o.LOG_DEBUG)("info",(()=>`[ProgramManager] run "${l.name}" (key=${s}) with ${f[0]}x${f[1]}x${f[2]}`)),this.programManager.run(u,a,d,f),p}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){const n=await this.gpuDataManager.download(e);t().set(new Uint8Array(n))}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n){const r=a.WEBGPU_OP_RESOLVE_RULES.get(e);if(!r)throw new Error(`kernel not implemented: ${e}`);this.kernels.set(t,[e,r[0],[r[1],n]])}releaseKernel(e){const t=this.kernelPersistentData.get(e);if(t){for(const e of t)this.gpuDataManager.release(e.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t){const n=this.kernels.get(e);if(!n)throw new Error(`kernel not created: ${e}`);const[r,i,a]=n;if(null!==this.currentKernelId)throw new Error(`kernel "${r}" is not allowed to be called recursively`);this.currentKernelId=e,a[0]&&(a[1]=a[0](a[1]),a[0]=void 0),(0,o.LOG_DEBUG)("info",(()=>`[WebGPU] Start to run kernel "${r}"...`)),this.temporaryData=[];try{return i(t,a[1]),0}catch(e){return(0,o.LOG_DEBUG)("warning",`[WebGPU] Kernel "${r}" failed. Error: ${e}`),1}finally{for(const e of this.temporaryData)this.gpuDataManager.release(e.id);this.temporaryData=[],this.currentKernelId=null}}}},7675:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.init=void 0;const r=n(7917),o=n(3838),i=n(4955),a=n(6952);class s{constructor(e,t,n,r){this.module=e,this.dataType=t,this.data=n,this.dims=r}getFloat32Array(){return new Float32Array(this.module.HEAP8.buffer,this.data,a.ShapeUtil.size(this.dims))}reshape(e){if(a.ShapeUtil.size(e)!==a.ShapeUtil.size(this.dims))throw new Error("Invalid new shape");return new s(this.module,this.dataType,this.data,e)}}class u{get customData(){return this.backend.currentKernelCustomData}constructor(e,t,n){this.module=e,this.backend=t;const r=e.HEAPU32;let o=n>>2;this.opKernelContext=r[o++];const i=r[o++],a=[];for(let t=0;t<i;t++){const t=r[o++],n=r[o++],i=r[o++],u=[];for(let e=0;e<i;e++)u.push(r[o++]);a.push(new s(e,t,n,u))}this.inputs=a}compute(e,t){var n,o,i;const u=null!==(o=null===(n=null==t?void 0:t.inputs)||void 0===n?void 0:n.map((e=>"number"==typeof e?this.inputs[e]:e)))&&void 0!==o?o:this.inputs,l=null!==(i=null==t?void 0:t.outputs)&&void 0!==i?i:[];return this.backend.run(e,u,l,((e,t,n)=>new s(this.module,t,this.output(e,n),n)),((e,t)=>{const n=(0,r.getTensorElementSize)(e);if(!n)throw new Error(`Unsupported data type: ${e}`);const o=n*a.ShapeUtil.size(t);return new s(this.module,e,this.backend.gpuDataManager.create(o).id,t)}))}output(e,t){const n=this.module.stackSave();try{const n=this.module.stackAlloc(4*(1+t.length));let r=n>>2;this.module.HEAPU32[r++]=t.length;for(let e=0;e<t.length;e++)this.module.HEAPU32[r++]=t[e];return this.module._JsepOutput(this.opKernelContext,e,n)}finally{this.module.stackRestore(n)}}}t.init=async e=>{const t=e.jsepInit;if(t&&navigator.gpu){const n=new o.WebGpuBackend;await n.initialize(),t({backend:n},(e=>n.alloc(e)),(e=>n.free(e)),((t,r,o,a=!1)=>{if(a)(0,i.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepCopyGpuToGpu: src=${t}, dst=${r}, size=${o}`)),n.memcpy(t,r);else{(0,i.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${t}, gpuDataId=${r}, size=${o}`));const a=e.HEAPU8.subarray(t,t+o);n.upload(r,a)}}),(async(t,r,o)=>{(0,i.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${t}, dataOffset=${r}, size=${o}`)),await n.download(t,(()=>e.HEAPU8.subarray(r,r+o)))}),((e,t,r)=>n.createKernel(e,t,r)),(e=>n.releaseKernel(e)),((t,r)=>{(0,i.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepRun: kernel=${t}, contextDataOffset=${r}`));const o=new u(e,n,r);return n.computeKernel(t,o)}))}}},4955:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.LOG_DEBUG=t.LOG=void 0;const r=n(8453),o=n(7917),i=["V","I","W","E","F"];t.LOG=(e,t)=>{const n=(0,o.logLevelStringToEnum)(e);var a,s;n>=(0,o.logLevelStringToEnum)(r.env.logLevel)&&(a=n,s="function"==typeof t?t():t,console.log(`[${i[a]},${(new Date).toISOString()}]${s}`))},t.LOG_DEBUG=(...e)=>{r.env.debug&&(0,t.LOG)(...e)}},6952:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MAX_CLIP=t.MIN_CLIP=t.GemmUtil=t.PoolConvUtil=t.ShapeUtil=t.BroadcastUtil=t.MatMulUtil=void 0;class n{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}}t.MatMulUtil=n;class r{static calcShape(e,t,r=!1){const o=e.length,i=t.length;if(0===o)return t;if(0===i)return e;const a=Math.max(e.length,t.length),s=new Array(a);if(r){if(o<2||i<2)return;const r=n.calcMatMulShape([e[o-2],e[o-1]],[t[i-2],t[i-1]]);if(void 0===r)return;[s[a-2],s[a-1]]=r}for(let n=r?3:1;n<=a;n++){const r=o-n<0?1:e[o-n],u=i-n<0?1:t[i-n];if(r!==u&&r>1&&u>1)return;s[a-n]=Math.max(r,u)}return s}static isValidBroadcast(e,t){const n=e.length,r=t.length;if(n>r)return!1;for(let o=1;o<=n;o++)if(1!==e[n-o]&&e[n-o]!==t[r-o])return!1;return!0}}t.BroadcastUtil=r;class o{static size(e){return o.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return o.getSizeFromDimensionRange(e,t,e.length)}static sizeToDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${e.length} dimensions.`);return o.getSizeFromDimensionRange(e,0,t)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let o=t;o<n;o++){if(e[o]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");r*=e[o]}return r}static computeStrides(e){const t=e.length;if(0===t)return[];if(1===t)return[1];const n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((n=>this.normalizeAxis(n,null!=t?t:e.length)))}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){const n=e.length;return e.map(((e,r)=>e+t[r]+t[r+n]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,n)=>e===t[n]))}}t.ShapeUtil=o;class i{static adjustPoolAttributes(e,t,n,r,o,i){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<o.length){if(o[e]<0)throw new Error("dilations should be greater than or equal to 1")}else o.push(1);for(let e=0;e<2*n.length;e++)if(e<i.length){if(i[e]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[e]>=n[e]||i[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,t,n,r,o,a,s){if(s){if(o.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(t.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let u=0;u<e.length-2;u++)i.adjustPadAndReturnShape(e[u+(a?1:2)],t[u],n[u],r[u],o,u,u+e.length-2,s)}}static computePoolOutputShape(e,t,n,r,o,a,s){if(t.length<=0)throw new Error("input shape must be of size greater than 0");const u=[t[0],t[1]];return i.computeShapeHelper(e,t,u,n,r,o,a,s),u}static computeConvOutputShape(e,t,n,r,o,a,s){if(e.length<=0||t.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const u=[e[0],t[0]];return i.computeShapeHelper(!1,e,u,n,r,o,a,s),u}static computeShapeHelper(e,t,n,r,o,a,s,u){if(e)for(let e=0;e<t.length-2;e++)n.push(1);else for(let e=0;e<t.length-2;e++)n.push(i.adjustPadAndReturnShape(t[e+2],r[e],o[e],a[e],s,e,e+t.length-2,u))}static adjustPadAndReturnShape(e,t,n,r,o,i,a,s){const u=n*(r-1)+1;if(!s||"NOTSET"===s)return Math.floor((e+o[i]+o[a]-u)/t+1);switch(s){case"VALID":return o[i]=0,o[a]=0,Math.floor((e-u)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const n=((e+t-1)/t-1)*t+r-e;return o[i]="SAME_LOWER"===s?Math.floor((n+1)/2):Math.floor(n/2),o[a]=n-o[i],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}}t.PoolConvUtil=i,t.GemmUtil=class{static getShapeOfGemmResult(e,t,n,o,i){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let a,s,u;t?(a=e[1],s=e[0]):(a=e[0],s=e[1]);let l=-1;if(o?(u=n[0],l=1):(u=n[1],l=0),n[l]!==s)throw new Error("dimension mismatch");if(a<=0||u<=0||s<=0)throw new Error("invalid shape specified");if(i&&!r.isValidBroadcast(i,[a,u]))throw new Error("gemm: invalid bias shape for broadcast");return[a,u,s]}},t.MIN_CLIP=-34028234663852886e22,t.MAX_CLIP=34028234663852886e22},387:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createAttributeWithCacheKey=void 0;class n{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this._cacheKey}}t.createAttributeWithCacheKey=e=>new n(e)},7771:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createGpuDataManager=void 0;const r=n(4955),o=n(1163),i=e=>16*Math.ceil(e/16);let a=0;class s{constructor(e){this.backend=e,this.storageCache=new Map,this.downloadCache=new Map,this.buffersForUploadingPending=[],this.buffersPending=[]}upload(e,t){const n=t.buffer,o=t.byteOffset,a=t.byteLength,s=i(a),u=this.storageCache.get(e);if(!u)throw new Error("gpu data for uploading does not exist");if(u.originalSize!==a)throw new Error(`inconsistent data size. gpu data size=${u.originalSize}, data size=${a}`);const l=this.backend.device.createBuffer({mappedAtCreation:!0,size:s,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),c=l.getMappedRange();new Uint8Array(c).set(new Uint8Array(n,o,a)),l.unmap();const p=this.backend.getCommandEncoder();this.backend.endComputePass(),p.copyBufferToBuffer(l,0,u.gpuData.buffer,0,s),(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] GpuDataManager.upload(id=${e})`)),this.buffersForUploadingPending.push(l)}memcpy(e,t){const n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");const r=this.storageCache.get(t);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");const o=i(n.originalSize);this.backend.getCommandEncoder().copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,o)}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){const n=i(e),s=this.backend.device.createBuffer({size:n,usage:t}),u={id:a++,type:o.GpuDataType.default,buffer:s};return this.storageCache.set(u.id,{gpuData:u,originalSize:e}),(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${u.id}`)),u}get(e){var t;return null===(t=this.storageCache.get(e))||void 0===t?void 0:t.gpuData}release(e){const t=this.storageCache.get(e);if(!t)throw new Error("releasing data does not exist");return(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${t.gpuData.id}`)),this.storageCache.delete(e),this.buffersPending.push(t.gpuData.buffer),this.downloadCache.get(e)&&this.downloadCache.delete(e),t.originalSize}async download(e){const t=this.downloadCache.get(e);if(t)return t.data;const n=this.storageCache.get(e);if(!n)throw new Error("data does not exist");const r=this.backend.getCommandEncoder();this.backend.endComputePass();const o=this.backend.device.createBuffer({size:n.originalSize,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});r.copyBufferToBuffer(n.gpuData.buffer,0,o,0,n.originalSize),this.backend.flush();const i=new Promise((e=>{o.mapAsync(GPUMapMode.READ).then((()=>{const t=o.getMappedRange().slice(0);o.destroy(),e(t)}))}));return this.downloadCache.set(e,{data:i}),i}refreshPendingBuffers(){for(const e of this.buffersForUploadingPending)e.destroy();for(const e of this.buffersPending)e.destroy()}}t.createGpuDataManager=(...e)=>new s(...e)},8510:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var o=Object.getOwnPropertyDescriptor(t,n);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,o)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return o(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.WEBGPU_OP_RESOLVE_RULES=void 0;const a=i(n(504)),s=n(9770),u=n(4271),l=n(1522),c=i(n(5262)),p=n(2625),d=i(n(9302));t.WEBGPU_OP_RESOLVE_RULES=new Map([["Abs",[d.abs]],["Acos",[d.acos]],["Acosh",[d.acosh]],["Add",[a.add]],["Asin",[d.asin]],["Asinh",[d.asinh]],["Atan",[d.atan]],["Atanh",[d.atanh]],["AveragePool",[c.averagePool,c.parseAveragePoolAttributes]],["Ceil",[d.ceil]],["ClipV10",[d.clipV10]],["Clip",[d.clip]],["Conv",[s.conv,s.parseConvAttributes]],["Cos",[d.cos]],["Cosh",[d.cosh]],["Div",[a.div]],["Elu",[d.elu,d.parseAlphaAttributes]],["Erf",[d.erf]],["Exp",[d.exp]],["Floor",[d.floor]],["Gemm",[u.gemm,u.parseGemmAttributes]],["GlobalAveragePool",[c.globalAveragePool,c.parseGlobalAveragePoolAttributes]],["GlobalMaxPool",[c.globalMaxPool,c.parseGlobalMaxPoolAttributes]],["LeakyRelu",[d.leakyRelu,d.parseAlphaAttributes]],["MatMul",[l.matMul]],["MaxPool",[c.maxPool,c.parseMaxPoolAttributes]],["Mul",[a.mul]],["Neg",[d.neg]],["Pow",[a.pow]],["Reciprocal",[d.reciprocal]],["Relu",[d.relu]],["Sigmoid",[d.sigmoid]],["Sin",[d.sin]],["Sinh",[d.sinh]],["Sqrt",[d.sqrt]],["Sub",[a.sub]],["Tan",[d.tan]],["Tanh",[d.tanh]],["ThresholdedRelu",[d.thresholdedRelu,d.parseAlphaAttributes]],["Transpose",[p.transpose,p.parseTransposeAttributes]]])},1427:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.biasActivationSnippet=t.activationFnSnippet=t.typeSnippet=void 0,t.typeSnippet=e=>{switch(e){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${e}-component is not supported.`)}},t.activationFnSnippet=(e,t=!1,n=!1,r=3)=>"",t.biasActivationSnippet=(e,t)=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      ${t?"value = activation(value, coords);":""}\n      `},9456:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createConv2DMatMulProgramInfo=void 0;const r=n(4955),o=n(6952),i=n(1163),a=n(1427),s=n(4085),u=n(158);t.createConv2DMatMulProgramInfo=(e,t,n,l,c,p,d,f,h)=>{const g="NHWC"===n.format,m=g?e[0].dims[3]:e[0].dims[1],b=l[0],y=g?l[2]:l[3],w=g?l[1]:l[2],_=g?l[3]:l[1],v=((m%4==0||m%3==0)&&g||y%4==0&&!g)&&_%4==0,x=g?_:y*w,T=g?y*w:_,S=v?[8,8,1]:[x<=4?4:16,x>4&&T<=4?4:16,1],O=v?[4,4,1]:[x<=4?1:2,x>4&&T<=4?1:2,1],A=[Math.ceil(x/S[0]/O[0]),Math.ceil(T/S[1]/O[1]),Math.ceil(b/S[2]/O[1])];(0,r.LOG_DEBUG)("verbose",(()=>`[conv2d_mm_webgpu] dispatch = ${A}`));const E=v?g&&m%4!=0?3:4:O[0],I=S[1]*O[1],$=S[0]*O[0],P=Math.max(S[0]*E,S[1]),D=c%I==0,k=p%$==0,C=d%P==0,R=v?[E,4,4]:[1,1,1],M=[`@group(0) @binding(0) var<storage, read> x: array<${v&&4===E?"vec4<f32>":"f32"}>;`,`@group(0) @binding(1) var<storage, read> w: array<${v?"vec4<f32>":"f32"}>;`];let N=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${v?"vec4<f32>":"f32"}) {\n        result[flatIndex] = ${v?"vec4<f32>":"f32"}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${v?"vec4<f32>":"f32"}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${v?"/ 4":""}, value);\n      }`;return f&&(M.push(`@group(0) @binding(2) var<storage, read> bias: array<${v?"vec4<f32>":"f32"}>;`),N+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${v?"vec4<f32>":"f32"} {\n          return bias[coords.${g?"w":"y"}${v?"/ 4":""}];\n        }`),Object.assign(Object.assign({},t),{outputs:[{dims:l,dataType:e[0].dataType,gpuDataType:i.GpuDataType.default}],dispatchGroup:()=>({x:A[0],y:A[1],z:A[2]}),getShaderSource:()=>`\n        ${s.utilFunctions}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${M.join("")}\n        @group(0) @binding(${M.length}) var<storage, read_write> result: array<${v?"vec4<f32>":"f32"}>;\n        //@group(0) @binding(${M.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${l.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${o.ShapeUtil.computeStrides(l).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${n.kernelShape[0]}, ${n.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${n.pads[0]}, ${n.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${n.strides[0]}, ${n.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${n.dilations[0]}, ${n.dilations[1]});\n        const dimAOuter : i32 = ${c};\n        const dimBOuter : i32 = ${p};\n        const dimInner : i32 = ${d};\n        ${N}\n        ${((e,t,n,r,o=!1,i,s=!1,u=4,l=4,c=4)=>{const p=e?"\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    ":"\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    ",d=e?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",f=e?"xShape[1]":"xShape[2]",h=e?"xShape[2]":"xShape[3]",g=e?"row":"col",m=e?"col":"row",b=`\n    let inChannels = wShape[2];\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\n    let outRow = ${g} / outWidth;\n    let outCol = ${g} % outWidth;\n\n    let WRow = ${m} / (filterDims[1] * inChannels);\n    let WCol = ${m} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${m} % inChannels;\n    var resData = ${(0,a.typeSnippet)(u)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${h}) {\n      ${p}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u)}\n    }\n    return resData;`,y=e?t&&r?`\n    let col = colIn * ${u};\n    ${b}`:`\n    let col = colIn * ${u};\n    if (row < dimAOuter && col < dimInner) {\n      ${b}\n    }\n    return ${(0,a.typeSnippet)(u)}(0.0);`:r&&n?`\n    let col = colIn * ${u};\n    ${b}`:`\n    let col = colIn * ${u};\n    if (row < dimInner && col < dimBOuter) {\n      ${b}\n    }\n    return ${(0,a.typeSnippet)(u)}(0.0);`,w=`${(e=>{switch(e){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(l)}`,_=(0,a.typeSnippet)(c),v=e?(0,a.typeSnippet)(u):(0,a.typeSnippet)(l),x=e?(0,a.typeSnippet)(l):(0,a.typeSnippet)(u);return`\n    ${(0,a.activationFnSnippet)(i,s,4===c,4)}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${v} {\n      ${e?y:w}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${x} {\n      ${e?w:y}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${_}) {\n      let col = colIn * ${c};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${d}\n      ${(0,a.biasActivationSnippet)(o,i)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`})(g,D,k,C,f,void 0,!1,R[0],R[1],R[2])}\n            ${v?(0,u.makeMatMulPackedVec4Source)(O,S,!g,P):(0,u.makeMatMulPackedSource)(O,S,!g,P,!1,void 0,h)}`})}},4085:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.utilFunctions=void 0,t.utilFunctions="\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n"},158:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.makeMatMulPackedSource=t.makeMatMulPackedVec4Source=void 0,t.makeMatMulPackedVec4Source=(e,t,n=!1,r=32,o=!1,i=32,a=!1)=>{const s=t[1]*e[1],u=t[0]*e[0],l=n?s:r,c=n?r:s,p=l/t[0],d=r/t[1];if((!n||4!==p||4!==e[1])&&(n||3!==p&&4!==p)||l%t[0]!=0||r%t[1]!=0||4!==e[0])throw new Error(`If transposeA ${n} is true, innerElementSize ${p} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${p} must be 3 or 4.\n  tileAWidth ${l} must be divisible by workgroupSize[0]${t[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub : array<array<vec${p}<f32>, ${l/p}>, ${c}>;\nvar<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/e[0]}>, ${r}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${p};\nconst tileInner = ${r};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = ${a?"0":"localRow * rowPerThread"};\n  let tileCol = i32(localId.x);\n\n  let globalRow = ${a?"0":"i32(globalId.y) * rowPerThread"};\n  let globalCol = i32(globalId.x);\n  let batch = ${o?"0":"i32(globalId.z)"};\n  let globalRowStart = i32(workgroupId.y) * ${s};\n\n  let numTiles = ${o?`${Math.ceil(i/r)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${o?`i32(globalId.z) * ${i}`:"0"};\n\n  var acc: array<vec4<f32>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${d};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${f=n,f?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol);\n        "}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${d}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${3===p?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${((e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${3===t?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`)(n,p)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`;var f};const n=e=>e?"\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol);\n            ":"\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol);\n            ";t.makeMatMulPackedSource=(e,t,r=!1,o=32,i=!1,a=32,s=!1)=>{const u=e[1]*t[1],l=e[0]*t[0],c=r?u:o,p=r?o:u;if(p%t[1]!=0||c%t[0]!=0||o%t[1]!=0)throw new Error(`tileAHight ${p} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${o} must be divisible by workgroupSize[1]${t[1]}`);const d=p/t[1],f=c/t[0],h=o/t[1],g=s?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${u};\n    let globalColStart = i32(workgroupId.x) * ${l};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\n          ${n(r)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${o}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol);\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<f32, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${r?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${u};\n\nlet tileRowA = i32(localId.y) * ${d};\nlet tileColA = i32(localId.x) * ${f};\nlet tileRowB = i32(localId.y) * ${h};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${d}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${f}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${n(r)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol);\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<f32, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${(e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(r)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<f32, ${c}>, ${p}>;\n  var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${o}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${o};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${i?"0":"i32(globalId.z)"};\n    let numTiles = ${i?`${Math.ceil(a/o)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${i?`i32(globalId.z) * ${a}`:"0"};\n\n    var acc : array<array<f32, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${g}\n  }\n`}},504:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.sub=t.pow=t.mul=t.div=t.add=void 0;const r=n(6952),o=n(1163),i=n(2075),a=(e,t,n,a,s)=>{const u={name:t,inputTypes:[o.GpuDataType.default,o.GpuDataType.default],cacheHint:s};return Object.assign(Object.assign({},u),{get:()=>((e,t,n,a,s,u=t.dataType)=>{var l,c;const p=!r.ShapeUtil.areEqual(t.dims,n.dims);let d=t.dims,f=r.ShapeUtil.size(t.dims),h=!1;if(p){const e=r.BroadcastUtil.calcShape(t.dims,n.dims,!1);if(!e)throw new Error("Can't perform binary op on the given tensors");d=e,f=r.ShapeUtil.size(d);let o=1;for(let e=0;e<d.length;e++){const r=null!==(l=t.dims[t.dims.length-e])&&void 0!==l?l:1;if(r!==(null!==(c=n.dims[n.dims.length-e])&&void 0!==c?c:1))break;o*=r}o%4==0&&(h=!0)}else h=!0;return Object.assign(Object.assign({},e),{getShaderSource:e=>((e,t,n,o,a,s,u,l,c="f32",p="f32",d="f32")=>{const f=r.ShapeUtil.size(o),h=Math.ceil(f/4);let g,m;"string"==typeof u?g=m=(e,t)=>`${u}((${e}),(${t}))`:"function"==typeof u?g=m=u:(g=u.scalar,m=u.vector);let b="";const y=(0,i.createIndicesHelper)("output",o);if(s){const e=e=>{const t=r.ShapeUtil.computeStrides(e),n=[];for(let r=e.length-1;r>=0;r--){const i=0===o.length?"0u":1===o.length?"(*outputIndices)":`(*outputIndices)[${r+o.length-e.length}]`;n.push(`${t[r]}u * (${i} % ${e[r]}u)`)}return n.length>0?n.join("+"):"0u"};b=`\n  ${y.o2iImpl}\n\n  fn calcOffsetA(outputIndices: ptr<function, ${y.iType}>) -> u32 {\n    return ${e(t)};\n  }\n\n  fn calcOffsetB(outputIndices: ptr<function, ${y.iType}>) -> u32 {\n    return ${e(n)};\n  }\n  `}let w;if(a)w=s?`\n      ${y.indicesVariableDeclaration("outputIndices")}\n      ${y.o2iCall("global_idx * 4u","outputIndices")}\n      let offsetA = calcOffsetA(&outputIndices);\n      let offsetB = calcOffsetB(&outputIndices);\n      outputData[global_idx] = ${m("aData[offsetA / 4u]","bData[offsetB / 4u]")};`:`outputData[global_idx] = ${m("aData[global_idx]","bData[global_idx]")};`;else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");const e=e=>{const t=`aData[indexA${e}][componentA${e}]`,n=`bData[indexB${e}][componentB${e}]`;return`\n      ${y.o2iCall(`global_idx * 4u + ${e}u`,"outputIndices")}\n      let offsetA${e} = calcOffsetA(&outputIndices);\n      let offsetB${e} = calcOffsetB(&outputIndices);\n      let indexA${e} = offsetA${e} / 4u;\n      let indexB${e} = offsetB${e} / 4u;\n      let componentA${e} = offsetA${e} % 4u;\n      let componentB${e} = offsetB${e} % 4u;\n      outputData[global_idx][${e}] = ${g(t,n)};`};w=`\n      ${y.indicesVariableDeclaration("outputIndices")}\n      ${e(0)}\n      ${e(1)}\n      ${e(2)}\n      ${e(3)}`}return`\n  @group(0) @binding(0) var<storage, read> aData : array<vec4<${c}>>;\n  @group(0) @binding(1) var<storage, read> bData : array<vec4<${p}>>;\n  @group(0) @binding(2) var<storage, read_write> outputData : array<vec4<${d}>>;\n\n  ${null!=l?l:""}\n  ${b}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n    ${w}\n  }`})(e,t.dims,n.dims,d,h,p,a,s),outputs:[{dims:d,dataType:u,gpuDataType:o.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(f/64/(h?4:1))})})})(u,e[0],e[1],n,a)})};t.add=e=>{e.compute(a(e.inputs,"Add",((e,t)=>`${e}+${t}`)))},t.div=e=>{e.compute(a(e.inputs,"Div",((e,t)=>`${e}/${t}`)))},t.mul=e=>{e.compute(a(e.inputs,"Mul",((e,t)=>`${e}*${t}`)))},t.pow=e=>{e.compute(a(e.inputs,"Pow",{scalar:(e,t)=>`pow_f32(${e},${t})`,vector:(e,t)=>`pow_vf32(${e},${t})`},"\n    fn pow_f32(a : f32, b : f32) -> f32 {\n      if (b == 0.0) {\n        return 1.0;\n      } else if (a < 0.0 && b != floor(b)) {\n        return pow(a, b); // NaN\n      }\n      return select(sign(a), 1.0, round(abs(b) % 2.0) != 1.0) * pow(abs(a), b);\n    }\n    fn pow_vf32(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {\n      // TODO: implement vectorized pow\n      return vec4<f32>(pow_f32(a.x, b.x), pow_f32(a.y, b.y), pow_f32(a.z, b.z), pow_f32(a.w, b.w));\n    }\n      "))},t.sub=e=>{e.compute(a(e.inputs,"Sub",((e,t)=>`${e}-${t}`)))}},2075:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createShaderHelper=t.createIndicesHelper=t.WORKGROUP_SIZE=void 0;const r=n(6952);t.WORKGROUP_SIZE=64,t.createIndicesHelper=(e,t)=>{const n=t.length<2?"u32":`array<u32, ${t.length}>`,o=r.ShapeUtil.computeStrides(t);let i="";for(let e=0;e<t.length-1;e++)i+=`\n    let dim${e} = current / ${o[e]}u;\n    let rest${e} = current % ${o[e]}u;\n    (*indices)[${e}] = dim${e};\n    current = rest${e};\n    `;i+=`(*indices)[${t.length-1}] = current;`;const a=t.length<2?"":`\n  fn ih_o2i_${e}(offset: u32, indices: ptr<function, ${n}>) {\n    var current = offset;\n    ${i}\n  }`,s=[];if(0===t.length)s.push("0u");else if(t.length<2)s.push("(*indices)");else for(let e=t.length-1;e>=0;e--)s.push(`${o[e]}u * ((*indices)[${e}])`);return{o2iImpl:a,o2iCall:(n,r)=>t.length<2?`${r}=${n};`:`ih_o2i_${e}(${n}, &${r});`,i2oImpl:t.length<2?"":`\n  fn ih_i2o_${e}(indices: ptr<function, ${n}>) -> u32 {\n    return ${s.join("+")};\n  }`,i2oExpression:(n,r)=>t.length<2?`(${r?"*":""}${n})`:`ih_i2o_${e}(${r?"":"&"}${n})`,indicesVariableDeclaration:(e,t)=>`var ${e}:${n}${t?`=${n}(${t.join(",")})`:""};`,iType:n}};class o{constructor(e){this.normalizedDispatchGroup=e}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${"number"==typeof e?`${e}u`:e}) { return; }`}mainStart(e=t.WORKGROUP_SIZE){const n="number"==typeof e?e:e[0],r="number"==typeof e?1:e[1],o="number"==typeof e?1:e[2],i=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${n}, ${r}, ${o})\n  fn main(${i?"@builtin(global_invocation_id) global_id : vec3<u32>":"@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>"}) {\n    ${i?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +\n          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${n*r*o}u + local_index;`}\n  `}}t.createShaderHelper=e=>new o(e)},9192:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createGroupedConvProgramInfoLoader=void 0;const r=n(6952),o=n(1163),i=n(2075),a=n(9770),s=n(3997);t.createGroupedConvProgramInfoLoader=(e,t,n)=>{const u=(l=e.length>2,c=t.cacheKey,{name:"GroupedConv",inputTypes:l?[o.GpuDataType.default,o.GpuDataType.default,o.GpuDataType.default]:[o.GpuDataType.default,o.GpuDataType.default],cacheHint:c});var l,c;return Object.assign(Object.assign({},u),{get:()=>((e,t,n,u)=>{const l=e.length>2,c=l?"value += b[output_channel];":"",p=e[0].dims,d=e[1].dims,f=d[0]/n.group,h="f32",{activationFunction:g,applyActivation:m}=(0,s.getActicationSnippet)(n),b=[`@group(0) @binding(0) var<storage, read> x : array<${h}>;`,`@group(0) @binding(1) var<storage, read> w : array<${h}>;`];l&&b.push(`@group(0) @binding(2) var<storage, read> b : array<${h}>;`);const y="NHWC"===n.format,w=(0,a.calculateOutputShape)(p,d,n.dilations,n.pads,n.strides,y),_=r.ShapeUtil.size(w),v=(0,i.createIndicesHelper)("output",w),x=(0,i.createIndicesHelper)("x",p),T=(0,i.createIndicesHelper)("w",d);return Object.assign(Object.assign({},t),{outputs:[{dims:u?u(w):w,dataType:e[0].dataType,gpuDataType:o.GpuDataType.default}],getShaderSource:e=>`\n  const strides: vec2<u32> = vec2(${n.strides[0]}u, ${n.strides[1]}u);\n  const pads: vec2<u32> = vec2(${n.pads[0]}u, ${n.pads[1]}u);\n\n  ${b.join("\n")}\n  @group(0) @binding(${b.length}) var<storage, read_write> output : array<${h}>;\n\n  ${g}\n  ${v.o2iImpl}\n  ${x.i2oImpl}\n  ${T.i2oImpl}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(_)}\n\n    ${v.indicesVariableDeclaration("outputIndices")}\n    ${v.o2iCall("global_idx","outputIndices")}\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${y?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${y?1:2}], outputIndices[${y?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${f}u;\n\n    var value: ${h} = ${h}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${d[1]}u; wInChannel++) {\n      let input_channel = group_id * ${d[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${d[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${n.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${p[y?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${d[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${n.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${p[y?2:3]}u) {\n            continue;\n          }\n\n          ${x.indicesVariableDeclaration("xIndices",y?["batch","xHeight","xWidth","input_channel"]:["batch","input_channel","xHeight","xWidth"])}\n          let xVal = x[${x.i2oExpression("xIndices")}];\n          ${T.indicesVariableDeclaration("wIndices",["output_channel","wInChannel","wHeight","wWidth"])}\n          let wVal = w[${T.i2oExpression("wIndices")}];\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${c}\n    ${m}\n    output[global_idx] = value;\n  }`,dispatchGroup:()=>({x:Math.ceil(_/64)})})})(e,u,t,n)})}},9770:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.conv=t.parseConvAttributes=t.calculateOutputShape=void 0;const r=n(6952),o=n(387),i=n(9192),a=n(3822),s=n(3997),u=n(2625);t.calculateOutputShape=(e,t,n,r,o,i)=>{const a=e[0],s=e.slice(i?1:2,i?3:4),u=s.length,l=t[0],c=t.slice(2).map(((e,t)=>e+(e-1)*(n[t]-1))),p=s.map(((e,t)=>e+r[t]+r[t+u])).map(((e,t)=>Math.floor((e-c[t]+o[t])/o[t])));return p.splice(0,0,a),p.splice(i?3:1,0,l),p};const l=(0,o.createAttributeWithCacheKey)({perm:[2,3,1,0]}),c=(e,t)=>{const n=e.kernelShape.slice();for(let e=2;e<t[1].dims.length;++e)0===n[e-2]&&(n[e-2]=t[1].dims[e]);const o=e.pads.slice();r.PoolConvUtil.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,o,"NHWC"===e.format,e.autoPad);const i=Object.assign({},e);return Object.assign(i,{kernelShape:n,pads:o,cacheKey:e.cacheKey}),i};t.parseConvAttributes=e=>{const t=(0,s.parseInternalActivationAttributes)(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],i=e.dilations,a=e.group,u=e.kernel_shape,l=e.pads,c=e.strides,p=e.w_is_const();return(0,o.createAttributeWithCacheKey)(Object.assign({autoPad:r,format:n,dilations:i,group:a,kernelShape:u,pads:l,strides:c,wIsConst:p},t))},t.conv=(e,n)=>{((e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");const n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("Conv input(X,W) should be float tensor");if(3===e.length&&1!==e[2].dataType)throw new Error("Conv input(bias) should be float tensor")})(e.inputs,n),3===e.inputs[0].dims.length?((e,t)=>{const n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);const o=[0,t.pads[0],0,t.pads[1]],a=[1].concat(t.strides),s=[1].concat(t.dilations),u=[1].concat(t.kernelShape),l=c(Object.assign(Object.assign({},t),{pads:o,strides:a,dilations:s,kernelShape:u}),r);e.compute((0,i.createGroupedConvProgramInfoLoader)(r,l,(e=>n?[e[0],e[2],e[3]]:[])))})(e,n):((e,n,r)=>{var o;const s=c(r,n),p=3===n.length,d="NHWC"===r.format,f=n[0].dims[d?1:2],h=n[0].dims[d?2:3],g=n[0].dims[d?3:1],m=n[1].dims[2],b=n[1].dims[3],y=(0,t.calculateOutputShape)(n[0].dims,n[1].dims,r.dilations,s.pads,r.strides,d),w=y[d?1:2],_=y[d?2:3],v=y[d?3:1];if(d&&m===f&&b===h&&"VALID"===r.autoPad||1===m&&1===b&&1===r.dilations[0]&&1===r.dilations[1]&&1===r.strides[0]&&1===r.strides[1]&&("SAME_UPPER"===r.autoPad||"SAME_LOWER"===r.autoPad||"VALID"===r.autoPad))return void e.compute((0,i.createGroupedConvProgramInfoLoader)(n,s));if(!d||1!==r.group)return void e.compute((0,i.createGroupedConvProgramInfoLoader)(n,s));const x=d?w*_:v,T=d?v:w*_,S=m*b*g,O=null!==(o=e.customData.wT)&&void 0!==o?o:e.compute(Object.assign(Object.assign({},u.transposeProgramMetadata),{cacheHint:l.cacheKey,get:()=>(0,u.createTransposeProgramInfo)(n[1],l.perm)}),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.customData.wT&&(e.customData.wT=O);const A=[n[0],O];p&&(d||1!==n[2].dims.length?A.push(n[2]):A.push(n[2].reshape([n[2].dims[0],1,1]))),e.compute((0,a.createConv2DMatMulProgramInfoLoader)(A,s,y,x,T,S,p,!0),{inputs:A})})(e,e.inputs,n)}},3822:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createConv2DMatMulProgramInfoLoader=void 0;const r=n(1163),o=n(9456);t.createConv2DMatMulProgramInfoLoader=(e,t,n,i,a,s,u,l)=>{const c=((e,t)=>({name:"Conv2DMatMul",inputTypes:e?[r.GpuDataType.default,r.GpuDataType.default,r.GpuDataType.default]:[r.GpuDataType.default,r.GpuDataType.default],cacheHint:t}))(u,t.cacheKey);return Object.assign(Object.assign({},c),{get:()=>(0,o.createConv2DMatMulProgramInfo)(e,c,t,n,i,a,s,u,l)})}},3997:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseInternalActivationAttributes=t.getActicationSnippet=void 0;const r=n(6952);t.getActicationSnippet=e=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},t.parseInternalActivationAttributes=e=>{const t=(null==e?void 0:e.activation)||"";if("Clip"===t){const[n,o]=(null==e?void 0:e.activation_params)||[r.MIN_CLIP,r.MAX_CLIP];return{activation:t,clipMax:o,clipMin:n,activationCacheKey:`${t}:${n},${o}`}}return{activation:t,activationCacheKey:t}}},4271:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseGemmAttributes=t.gemm=void 0;const r=n(6952),o=n(387),i=n(1163);t.gemm=(e,t)=>{(e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(3===e.length&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(1!==e[0].dataType||1!==e[1].dataType||3===e.length&&1!==e[2].dataType)throw new Error("Invalid input type.");if(e[0].dataType!==e[1].dataType||3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")})(e.inputs),e.compute(((e,t)=>{const n={name:"Gemm",inputTypes:3===e.length?[i.GpuDataType.default,i.GpuDataType.default,i.GpuDataType.default]:[i.GpuDataType.default,i.GpuDataType.default],cacheHint:t.cacheKey};return Object.assign(Object.assign({},n),{get:()=>((e,t,n)=>{const o=t[0].dims.slice(),a=t[1].dims.slice(),[s,u,l]=r.GemmUtil.getShapeOfGemmResult(o,n.transA,a,n.transB,3===t.length?t[2].dims:void 0),c=[s,u];if(!c)throw new Error("Can't use gemm on the given tensors");const p=r.ShapeUtil.size(c);let d="";n.transA&&n.transB?d="value += a[k * M + m] * b[n * K + k];":n.transA&&!n.transB?d="value += a[k * M + m] * b[k * N + n];":!n.transA&&n.transB?d="value += a[m * K + k] * b[n * K + k];":n.transA||n.transB||(d="value += a[m * K + k] * b[k * N + n];");const f="f32",h=1===n.alpha?"":"value *= alpha;",g=3===t.length?`value += beta * c[${((e,t,n)=>{if(0===n.length)return"0u";const r=1===n.length&&1!==e||2===n.length&&n[0]!==e,o=n[n.length-1]!==t;let i="0u";return r||(i+=`+ m * ${n[n.length-1]}u`),o||(i+="+n"),i})(s,u,t[2].dims)}];`:"",m=[`@group(0) @binding(0) var<storage, read> a : array<${f}>;`,`@group(0) @binding(1) var<storage, read> b : array<${f}>;`];return 3===t.length&&m.push(`@group(0) @binding(2) var<storage, read> c : array<${f}>;`),Object.assign(Object.assign({},e),{outputs:[{dims:c,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>`\n  const M: u32 = ${s}u;\n  const N: u32 = ${u}u;\n  const K: u32 = ${l}u;\n  const alpha = ${f}(${n.alpha});\n  const beta = ${f}(${n.beta});\n\n  ${m.join("\n")}\n  @group(0) @binding(${t.length}) var<storage, read_write> output : array<${f}>;\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${f}(0);\n    for (var k: u32 = 0u; k<${l}u; k++) {\n      ${d}\n    }\n\n    ${h}\n    ${g}\n    output[global_id.x] = value;\n\n  }`,dispatchGroup:()=>({x:Math.ceil(p/64)})})})(n,e,t)})})(e.inputs,t))},t.parseGemmAttributes=e=>(0,o.createAttributeWithCacheKey)(e)},1522:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.matMul=t.createMatmulProgramInfoLoader=void 0;const r=n(6952),o=n(1163),i=n(3997);t.createMatmulProgramInfoLoader=(e,t)=>{const n=(a=e.length>2,s=t.activationCacheKey,{name:"MatMul",inputTypes:a?[o.GpuDataType.default,o.GpuDataType.default,o.GpuDataType.default]:[o.GpuDataType.default,o.GpuDataType.default],cacheHint:s});var a,s;return Object.assign(Object.assign({},n),{get:()=>((e,t,n)=>{const a=t[0].dims,s=t[1].dims,u=r.BroadcastUtil.calcShape(a,s,!0);if(!u)throw new Error("Can't use matmul on the given tensors");const l=r.ShapeUtil.size(u),c="f32",{activationFunction:p,applyActivation:d}=(0,i.getActicationSnippet)(n),f=u[u.length-2],h=a[a.length-1],g=u[u.length-1];return Object.assign(Object.assign({},e),{outputs:[{dims:u,dataType:t[0].dataType,gpuDataType:o.GpuDataType.default}],getShaderSource:e=>`\n  const M: u32 = ${f}u;\n  const N: u32 = ${g}u;\n  const K: u32 = ${h}u;\n\n  @group(0) @binding(0) var<storage, read> a : array<${c}>;\n  @group(0) @binding(1) var<storage, read> b : array<${c}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${c}>;\n\n  ${p}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n\n    let stack = global_idx / (M * N);\n    let mn = global_idx % (M * N);\n    let n = global_idx % N;\n    let m = mn / N;\n\n    let offsetA = stack * (M * K);\n    let offsetB = stack * (K * N);\n\n    var value = ${c}(0);\n    for (var k: u32 = 0u; k<${h}u; k++) {\n      value += a[offsetA + m * K + k] * b[offsetB + k * N + n];\n    }\n    ${d}\n    output[global_idx] = value;\n  }`,dispatchGroup:()=>({x:Math.ceil(l/64)})})})(n,e,t)})},t.matMul=e=>{(e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("inputs should be float type")})(e.inputs),e.compute((0,t.createMatmulProgramInfoLoader)(e.inputs,{activation:"",activationCacheKey:""}))}},5262:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.globalMaxPool=t.parseGlobalMaxPoolAttributes=t.parseMaxPoolAttributes=t.maxPool=t.globalAveragePool=t.parseGlobalAveragePoolAttributes=t.averagePool=t.parseAveragePoolAttributes=void 0;const r=n(6952),o=n(387),i=n(1163),a=n(2075),s=e=>{if(!e||1!==e.length)throw new Error("Pool ops requires 1 input.");if(4!==e[0].dims.length)throw new Error("Pool ops supports 2-D inputs only for now.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},u=(e,t,n)=>{const o="NHWC"===t.format,i=o?[e[0].dims[0],e[0].dims[3],e[0].dims[1],e[0].dims[2]]:e[0].dims.slice(),a=Object.hasOwnProperty.call(t,"dilations"),s=t.kernelShape.slice(),u=t.strides.slice(),l=a?t.dilations.slice():[],c=t.pads.slice();r.PoolConvUtil.adjustPoolAttributes(n,i,s,u,l,c);const p=r.PoolConvUtil.computePoolOutputShape(n,i,u,l,s,c,t.autoPad),d=Object.assign({},t);return a?Object.assign(d,{kernelShape:s,strides:u,pads:c,dilations:l,cacheKey:t.cacheKey}):Object.assign(d,{kernelShape:s,strides:u,pads:c,cacheKey:t.cacheKey}),[d,o?[p[0],p[2],p[3],p[1]]:p]},l=(e,t,n,o,i,s,u,l)=>{const c="NHWC"===o.format,p=t.length,d=r.ShapeUtil.size(n),f=(0,a.createIndicesHelper)("output",n),h=(0,a.createIndicesHelper)("x",t);if(o.kernelShape.length<=2){const n=o.kernelShape[o.kernelShape.length-1],r=o.strides[o.strides.length-1],a=o.pads[o.pads.length/2-1],g=p-(c?2:1);let m="",b="",y="";if(m=a+o.pads[o.pads.length-1]!==0?`\n              for (var i: u32 = 0u; i < ${n}u; i++) {\n                xIndices[${g}] = indices[${g}] * ${r} - ${a} + i;\n                if (xIndices[${g}] < 0 || xIndices[${g}] >= ${t[g]}) {\n                  pad++;\n                  continue;\n                }\n                let x_val = x[${h.i2oExpression("xIndices")}];\n                ${i}\n              }`:`\n              for (var i: u32 = 0u; i < ${n}u; i++) {\n                xIndices[${g}] = indices[${g}] * ${r} - ${a} + i;\n                let x_val = x[${h.i2oExpression("xIndices")}];\n                ${i}\n              }`,2===o.kernelShape.length){const e=o.kernelShape[o.kernelShape.length-2],r=o.strides[o.strides.length-2],i=o.pads[o.pads.length/2-2],a=o.pads[o.pads.length-2],s=p-(c?3:2),u=t[s];b=i+a!==0?`\n                for (var j: u32 = 0u; j < ${e}u; j++) {\n                  xIndices[${s}] = indices[${s}] * ${r} - ${i} + j;\n                  if (xIndices[${s}] < 0 || xIndices[${s}] >= ${u}) {\n                    pad+= ${n};\n                    continue;\n                  }\n              `:`\n                for (var j: u32 = 0u; j < ${e}u; j++) {\n                  xIndices[${s}] = indices[${s}] * ${r} - ${i} + j;\n                `,y="\n              }\n            "}return`\n            @group(0) @binding(0) var<storage, read> x : array<${u}>;\n            @group(0) @binding(1) var<storage, read_write> output : array<${u}>;\n\n            ${f.o2iImpl}\n            ${h.i2oImpl}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(d)}\n\n              ${f.indicesVariableDeclaration("indices")}\n              ${f.o2iCall("global_idx","indices")}\n              ${f.indicesVariableDeclaration("xIndices")}\n              ${f.o2iCall("global_idx","xIndices")}\n\n              var value: ${u} = ${u}(${l});\n              var pad = 0;\n              ${b}\n              ${m}\n              ${y}\n              ${s}\n\n              output[global_idx] = value;\n            }`}{if(c)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");const n=r.ShapeUtil.size(o.kernelShape),a=r.ShapeUtil.computeStrides(o.kernelShape),g=a.length,m=o.pads.length;let b="";return b=o.pads.reduce(((e,t)=>e+t))?`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${h.i2oExpression("xIndices")}];\n                ${i}\n              }`:`\n              }\n              let x_val = x[${h.i2oExpression("xIndices")}];\n              ${i}\n            `,`\n            @group(0) @binding(0) var<storage, read> x : array<${u}>;\n            @group(0) @binding(1) var<storage, read_write> output : array<${u}>;\n\n            ${f.o2iImpl}\n            ${h.i2oImpl}\n\n            const pads = array<u32, ${m}>(${o.pads.map((e=>`${e}u`)).join(",")});\n            const inputDims = array<u32, ${p}>(${t.map((e=>`${e}u`)).join(",")});\n            const kernelStrides = array<u32, ${g}>(${a.map((e=>`${e}u`)).join(",")});\n            const strides = array<u32, ${g}>(${o.strides.map((e=>`${e}u`)).join(",")});\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(d)}\n\n              ${f.indicesVariableDeclaration("indices")}\n              ${f.o2iCall("global_idx","indices")}\n              ${f.indicesVariableDeclaration("xIndices")}\n              ${f.o2iCall("global_idx","xIndices")}\n\n              var offsets: array<u32, ${g}>;\n\n              var value = ${u}(${l});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${n}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${g-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${g-1}] = offset;\n\n                isPad = false;\n                for (var j = ${p-g}u; j < ${p}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${p-g}u]\n                    + offsets[j - ${p-g}u] - pads[j - 2u];\n                  ${b}\n              }\n              ${s}\n\n              output[global_idx] = value;\n            }`}},c=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),p=(e,t,n,o)=>{const[a,s]=u(e,o,n),c=r.ShapeUtil.size(a.kernelShape),p="f32";let d="";return a.countIncludePad?d+=`value /= ${p}(${c});`:d+=`value /= ${p}(${c} - pad);`,Object.assign(Object.assign({},t),{outputs:[{dims:s,dataType:e[0].dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:t=>l(t,e[0].dims,s,a,"value += x_val;",d,p,"0.0"),dispatchGroup:()=>({x:Math.ceil(r.ShapeUtil.size(s)/64)})})};t.parseAveragePoolAttributes=e=>{const t=0!==e.count_include_pad,n=c(e);if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,o.createAttributeWithCacheKey)(Object.assign({countIncludePad:t},n))},t.averagePool=(e,t)=>{s(e.inputs);const n={name:"AveragePool",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>p(e.inputs,n,!1,t)}))};const d={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""};t.parseGlobalAveragePoolAttributes=e=>{const t=e.format;return Object.assign(Object.assign({format:t},d),{cacheKey:t})},t.globalAveragePool=(e,t)=>{s(e.inputs);const n={name:"GlobalAveragePool",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>p(e.inputs,n,!0,t)}))};const f=(e,t,n,o)=>{const[a,s]=u(e,o,n);return Object.assign(Object.assign({},t),{outputs:[{dims:s,dataType:e[0].dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:t=>l(t,e[0].dims,s,a,"\n      value = max(x_val, value);\n    ","","f32","-1e5"),dispatchGroup:()=>({x:Math.ceil(r.ShapeUtil.size(s)/64)})})};t.maxPool=(e,t)=>{s(e.inputs);const n={name:"MaxPool",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>f(e.inputs,n,!1,t)}))},t.parseMaxPoolAttributes=e=>{const t=e.storage_order,n=e.dilations,r=c(e);if(0!==t)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==r.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,o.createAttributeWithCacheKey)(Object.assign({storageOrder:t,dilations:n},r))},t.parseGlobalMaxPoolAttributes=e=>{const t=e.format;return Object.assign(Object.assign({format:t},d),{cacheKey:t})},t.globalMaxPool=(e,t)=>{s(e.inputs);const n={name:"GlobalMaxPool",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>f(e.inputs,n,!0,t)}))}},2625:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseTransposeAttributes=t.transpose=t.createTransposeProgramInfo=t.transposeProgramMetadata=void 0;const r=n(6952),o=n(387),i=n(1163),a=n(2075);t.transposeProgramMetadata={name:"Transpose",inputTypes:[i.GpuDataType.default]};const s=(e,t)=>t&&t.length!==e.length?[...e.keys()].reverse():t;t.createTransposeProgramInfo=(e,n)=>{const o=e.dims,u=s(o,n),l=((e,t)=>r.ShapeUtil.sortBasedOnPerm(e,s(e,t)))(o,u),c=o.length,p=r.ShapeUtil.size(l),d=(0,a.createIndicesHelper)("output",l),f=(0,a.createIndicesHelper)("a",o);return Object.assign(Object.assign({},t.transposeProgramMetadata),{outputs:[{dims:l,dataType:e.dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>`\n  @group(0) @binding(0) var<storage, read> a : array<f32>;\n  @group(0) @binding(1) var<storage, read_write> output : array<f32>;\n\n  ${((e,t)=>{const n=[];n.push(`fn perm(a: ptr<function, array<u32, ${t}>>, i: ptr<function, array<u32, ${t}>>) {`);for(let r=0;r<t;++r)n.push(`\t(*a)[${e[r]}]=(*i)[${r}];`);return n.push("\t}"),n.join("\n")})(u,c)}\n  ${d.o2iImpl}\n  ${f.i2oImpl}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n\n    ${d.indicesVariableDeclaration("indices")}\n    ${d.o2iCall("global_idx","indices")}\n    ${f.indicesVariableDeclaration("aIndices")}\n    perm(&aIndices, &indices);\n\n    output[global_idx] = a[${f.i2oExpression("aIndices")}];\n  }`,dispatchGroup:()=>({x:Math.ceil(p/64)})})},t.transpose=(e,n)=>{(e=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.");if(1!==e[0].dataType)throw new Error("input should be float tensor")})(e.inputs),e.compute(Object.assign(Object.assign({},t.transposeProgramMetadata),{cacheHint:n.cacheKey,get:()=>(0,t.createTransposeProgramInfo)(e.inputs[0],n.perm)}))},t.parseTransposeAttributes=e=>(0,o.createAttributeWithCacheKey)({perm:e.perm})},9302:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.thresholdedRelu=t.tanh=t.tan=t.sqrt=t.sinh=t.sin=t.sigmoid=t.relu=t.reciprocal=t.neg=t.leakyRelu=t.floor=t.exp=t.erf=t.elu=t.parseAlphaAttributes=t.cosh=t.cos=t.ceil=t.clip=t.clipV10=t.atanh=t.atan=t.asinh=t.asin=t.acosh=t.acos=t.abs=void 0;const r=n(6952),o=n(387),i=n(1163),a=(e,t,n,o,a)=>{const s={name:t,inputTypes:[i.GpuDataType.default],cacheHint:a};return Object.assign(Object.assign({},s),{get:()=>((e,t,n,o)=>Object.assign(Object.assign({},e),{getShaderSource:e=>((e,t,n,r)=>{const o=Math.ceil(t/4);let i="";return i="string"==typeof n?`${n}(a)`:n("a"),`\n  @group(0) @binding(0) var<storage, read> inputData : array<vec4<f32>>;\n  @group(0) @binding(1) var<storage, read_write> outputData : array<vec4<f32>>;\n\n  ${null!=r?r:""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n\n    let a = inputData[global_idx];\n    outputData[global_idx] = ${i};\n  }`})(e,r.ShapeUtil.size(t.dims),n,o),outputs:[{dims:t.dims,dataType:t.dataType,gpuDataType:i.GpuDataType.default}],dispatchGroup:e=>({x:Math.ceil(r.ShapeUtil.size(e[0].dims)/64/4)})}))(s,e,n,o)})};t.abs=e=>{e.compute(a(e.inputs[0],"Abs","abs"))},t.acos=e=>{e.compute(a(e.inputs[0],"Acos","acos"))},t.acosh=e=>{e.compute(a(e.inputs[0],"Acosh","acosh"))},t.asin=e=>{e.compute(a(e.inputs[0],"Asin","asin"))},t.asinh=e=>{e.compute(a(e.inputs[0],"Asinh","asinh"))},t.atan=e=>{e.compute(a(e.inputs[0],"Atan","atan"))},t.atanh=e=>{e.compute(a(e.inputs[0],"Atanh","atanh"))},t.clipV10=(e,t)=>{e.compute(a(e.inputs[0],"Clip",(e=>`clamp(${e}, clip_min_, clip_max_)`),`\n    const clip_min_: vec4<f32> = vec4(f32(${t.min}));\n    const clip_max_: vec4<f32> = vec4(f32(${t.max}));\n`,t.cacheKey),{inputs:[0]})},t.clip=e=>{const n=(e=>{const t=e.length>=2?e[1].getFloat32Array()[0]:r.MIN_CLIP,n=e.length>=3?e[2].getFloat32Array()[0]:r.MAX_CLIP;return(0,o.createAttributeWithCacheKey)({min:t,max:n})})(e.inputs);(0,t.clipV10)(e,n)},t.ceil=e=>{e.compute(a(e.inputs[0],"Ceil","ceil"))},t.cos=e=>{e.compute(a(e.inputs[0],"Cos","cos"))},t.cosh=e=>{e.compute(a(e.inputs[0],"Cosh","cosh"))},t.parseAlphaAttributes=e=>(0,o.createAttributeWithCacheKey)(e),t.elu=(e,t)=>{e.compute(a(e.inputs[0],"Elu",(e=>`elu_vf32(${e})`),`\n  const elu_alpha_: f32 = f32(${t.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},t.erf=e=>{e.compute(a(e.inputs[0],"Erf",(e=>`erf_vf32(${e})`),"\n  const r0: f32 = 0.3275911;\n  const r1: f32 = 0.254829592;\n  const r2: f32 = -0.284496736;\n  const r3: f32 = 1.421413741;\n  const r4: f32 = -1.453152027;\n  const r5: f32 = 1.061405429;\n\n  fn erf_vf32(v: vec4<f32>) -> vec4<f32> {\n    let absv = abs(v);\n    let x = 1.0 / (1.0 + r0 * absv);\n    return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n  }"))},t.exp=e=>{e.compute(a(e.inputs[0],"Exp","exp"))},t.floor=e=>{e.compute(a(e.inputs[0],"Floor","floor"))},t.leakyRelu=(e,t)=>{e.compute(a(e.inputs[0],"LeakyRelu",(e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<f32>(0.0))`),`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},t.neg=e=>{e.compute(a(e.inputs[0],"Neg",(e=>`-${e}`)))},t.reciprocal=e=>{e.compute(a(e.inputs[0],"Reciprocal",(e=>`1.0/${e}`)))},t.relu=e=>{e.compute(a(e.inputs[0],"Relu",(e=>`select(vec4<f32>(0.0), ${e}, ${e} > vec4<f32>(0.0))`)))},t.sigmoid=e=>{e.compute(a(e.inputs[0],"Sigmoid",(e=>`(1.0 / (1.0 + exp(-${e})))`)))},t.sin=e=>{e.compute(a(e.inputs[0],"Sin","sin"))},t.sinh=e=>{e.compute(a(e.inputs[0],"Sinh","sinh"))},t.sqrt=e=>{e.compute(a(e.inputs[0],"Sqrt","sqrt"))},t.tan=e=>{e.compute(a(e.inputs[0],"Tan","tan"))},t.tanh=e=>{e.compute(a(e.inputs[0],"Tanh","tanh"))},t.thresholdedRelu=(e,t)=>(e.compute(a(e.inputs[0],"ThresholdedRelu",(e=>`select(vec4<f32>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`),`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0)},8305:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ProgramManager=void 0;const r=n(4955),o=n(2075);t.ProgramManager=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,r){const o=this.backend.device,i=this.backend.getComputePassEncoder();this.backend.profilingEnabled&&i.writeTimestamp(this.backend.profilingQuerySet,0),i.setPipeline(e.computePipeline);const a=[];for(const e of t)a.push({binding:a.length,resource:{buffer:e.buffer}});for(const e of n)a.push({binding:a.length,resource:{buffer:e.buffer}});const s=o.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:a});if(i.setBindGroup(0,s),i.dispatchWorkgroups(...r),this.backend.pendingDispatchNumber++,this.backend.profilingEnabled){i.writeTimestamp(this.backend.profilingQuerySet,1);const e=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),t=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,e.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(e.buffer,0,t.buffer,0,16),this.backend.flush();const n=this.backend.currentKernelId,r=this.backend.kernels.get(n)[0];t.buffer.mapAsync(GPUMapMode.READ).then((()=>{const o=new BigUint64Array(t.buffer.getMappedRange()),i=o[0],a=o[1];t.buffer.unmap(),void 0===this.backend.profilingTimeBase&&(this.backend.profilingTimeBase=i);const s=Number(i-this.backend.profilingTimeBase),u=Number(a-this.backend.profilingTimeBase);if(!Number.isSafeInteger(s)||!Number.isSafeInteger(u))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(e.id),this.backend.gpuDataManager.release(t.id),console.log(`[profiling] kernel "${n}|${r}" execution time: ${u-s} ns`)}))}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(e,t){const n=this.backend.device,i=e.getShaderSource((0,o.createShaderHelper)(t)),a=n.createShaderModule({code:i});return(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] shader code: ${i}`)),{programInfo:e,computePipeline:n.createComputePipeline({compute:{module:a,entryPoint:"main"},layout:"auto"})}}normalizeDispatchGroupSize(e){const t="number"==typeof e?e:e.x,n="number"==typeof e?1:e.y||1,r="number"==typeof e?1:e.z||1,o=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=o&&n<=o&&r<=o)return[t,n,r];const i=t*n*r;let a=Math.ceil(Math.sqrt(i));if(a>o){if(a=Math.ceil(Math.cbrt(i)),a>o)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[a,a,a]}return[a,a,1]}}},1163:(e,t)=>{"use strict";var n;Object.defineProperty(t,"__esModule",{value:!0}),t.GpuDataType=void 0,(n=t.GpuDataType||(t.GpuDataType={}))[n.default=0]="default",n[n.upload=1]="upload",n[n.profile=2]="profile"},3899:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.iterateExtraOptions=void 0,t.iterateExtraOptions=(e,n,r,o)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,i])=>{const a=n?n+e:e;if("object"==typeof i)(0,t.iterateExtraOptions)(i,a+".",r,o);else if("string"==typeof i||"number"==typeof i)o(a,i.toString());else{if("boolean"!=typeof i)throw new Error("Can't handle extra config type: "+typeof i);o(a,i?"1":"0")}}))}},9544:function(e,t,n){"use strict";var r,o=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var o=Object.getOwnPropertyDescriptor(t,n);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,o)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),i=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&o(t,e,n);return i(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=t.initWasm=void 0;const s=n(8453),u=n(7675),l=a(n(1259)),c=n(263),p=()=>!!s.env.wasm.proxy&&"undefined"!=typeof document;let d,f,h,g=!1,m=!1,b=!1;const y=[],w=[],_=[],v=[],x=[],T=[],S=()=>{if(g||!m||b||!d)throw new Error("worker not ready")},O=e=>{switch(e.data.type){case"init-wasm":g=!1,e.data.err?(b=!0,f[1](e.data.err)):(m=!0,f[0]());break;case"init-ort":e.data.err?h[1](e.data.err):h[0]();break;case"create_allocate":e.data.err?y.shift()[1](e.data.err):y.shift()[0](e.data.out);break;case"create_finalize":e.data.err?w.shift()[1](e.data.err):w.shift()[0](e.data.out);break;case"create":e.data.err?_.shift()[1](e.data.err):_.shift()[0](e.data.out);break;case"release":e.data.err?v.shift()[1](e.data.err):v.shift()[0]();break;case"run":e.data.err?x.shift()[1](e.data.err):x.shift()[0](e.data.out);break;case"end-profiling":e.data.err?T.shift()[1](e.data.err):T.shift()[0]()}},A="undefined"!=typeof document?null===(r=null===document||void 0===document?void 0:document.currentScript)||void 0===r?void 0:r.src:void 0;t.initWasm=async()=>{if(p()){if(m)return;if(g)throw new Error("multiple calls to 'initWasm()' detected.");if(b)throw new Error("previous call to 'initWasm()' failed.");return g=!0,void 0===s.env.wasm.wasmPaths&&A&&0!==A.indexOf("blob:")&&(s.env.wasm.wasmPaths=A.substr(0,+A.lastIndexOf("/")+1)),new Promise(((e,t)=>{null==d||d.terminate(),d=n(8050).Z(),d.onmessage=O,f=[e,t];const r={type:"init-wasm",in:s.env.wasm};d.postMessage(r)}))}return(0,c.initializeWebAssembly)(s.env.wasm)},t.initOrt=async(e,t)=>{if(p())return S(),new Promise(((n,r)=>{h=[n,r];const o={type:"init-ort",in:{numThreads:e,loggingLevel:t}};d.postMessage(o)}));l.initOrt(e,t),await(0,u.init)((0,c.getInstance)())},t.createSessionAllocate=async e=>p()?(S(),new Promise(((t,n)=>{y.push([t,n]);const r={type:"create_allocate",in:{model:e}};d.postMessage(r,[e.buffer])}))):l.createSessionAllocate(e),t.createSessionFinalize=async(e,t)=>p()?(S(),new Promise(((n,r)=>{w.push([n,r]);const o={type:"create_finalize",in:{modeldata:e,options:t}};d.postMessage(o)}))):l.createSessionFinalize(e,t),t.createSession=async(e,t)=>p()?(S(),new Promise(((n,r)=>{_.push([n,r]);const o={type:"create",in:{model:e,options:t}};d.postMessage(o,[e.buffer])}))):l.createSession(e,t),t.releaseSession=async e=>{if(p())return S(),new Promise(((t,n)=>{v.push([t,n]);const r={type:"release",in:e};d.postMessage(r)}));l.releaseSession(e)},t.run=async(e,t,n,r,o)=>p()?(S(),new Promise(((i,a)=>{x.push([i,a]);const s={type:"run",in:{sessionId:e,inputIndices:t,inputs:n,outputIndices:r,options:o}};d.postMessage(s,l.extractTransferableBuffers(n))}))):l.run(e,t,n,r,o),t.endProfiling=async e=>{if(p())return S(),new Promise(((t,n)=>{T.push([t,n]);const r={type:"end-profiling",in:e};d.postMessage(r)}));l.endProfiling(e)}},7918:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=n(3899),o=n(9444),i=n(263);t.setRunOptions=e=>{const t=(0,i.getInstance)();let n=0;const a=[],s=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(s.terminate=!1);let i=0;if(void 0!==(null==e?void 0:e.tag)&&(i=(0,o.allocWasmString)(e.tag,a)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,i),0===n)throw new Error("Can't create run options");return void 0!==(null==e?void 0:e.extra)&&(0,r.iterateExtraOptions)(e.extra,"",new WeakSet,((e,r)=>{const i=(0,o.allocWasmString)(e,a),s=(0,o.allocWasmString)(r,a);if(0!==t._OrtAddRunConfigEntry(n,i,s))throw new Error(`Can't set a run config entry: ${e} - ${r}`)})),[n,a]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),a.forEach(t._free),e}}},6640:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.OnnxruntimeWebAssemblySessionHandler=void 0;const r=n(2806),o=n(8453),i=n(2850),a=n(9544),s=n(7917);let u;t.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(e){const t=await fetch(e),n=await t.arrayBuffer();return(0,a.createSessionAllocate)(new Uint8Array(n))}async loadModel(e,t){if(u||(await(0,a.initOrt)(o.env.wasm.numThreads,(0,s.logLevelStringToEnum)(o.env.logLevel)),u=!0),"string"==typeof e)if("undefined"==typeof fetch){const n=await(0,i.promisify)(r.readFile)(e);[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSession)(n,t)}else{const n=await this.createSessionAllocate(e);[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSessionFinalize)(n,t)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSession)(e,t)}async dispose(){return(0,a.releaseSession)(this.sessionId)}async run(e,t,n){const r=[],i=[];Object.entries(e).forEach((e=>{const t=e[0],n=e[1],o=this.inputNames.indexOf(t);if(-1===o)throw new Error(`invalid input '${t}'`);r.push(n),i.push(o)}));const s=[];Object.entries(t).forEach((e=>{const t=e[0],n=this.outputNames.indexOf(t);if(-1===n)throw new Error(`invalid output '${t}'`);s.push(n)}));const u=await(0,a.run)(this.sessionId,i,r.map((e=>[e.type,e.dims,e.data])),s,n),l={};for(let e=0;e<u.length;e++)l[this.outputNames[s[e]]]=new o.Tensor(u[e][0],u[e][2],u[e][1]);return l}startProfiling(){}endProfiling(){(0,a.endProfiling)(this.sessionId)}}},7622:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=n(3899),o=n(9444),i=n(263);t.setSessionOptions=e=>{var t,n,a,s;const u=(0,i.getInstance)();let l=0;const c=[],p=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(p);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=p.graphOptimizationLevel)&&void 0!==t?t:"all"),d=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(n=p.executionMode)&&void 0!==n?n:"sequential"),f="string"==typeof p.logId?(0,o.allocWasmString)(p.logId,c):0,h=null!==(a=p.logSeverityLevel)&&void 0!==a?a:2;if(!Number.isInteger(h)||h<0||h>4)throw new Error(`log serverity level is not valid: ${h}`);const g=null!==(s=p.logVerbosityLevel)&&void 0!==s?s:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const m="string"==typeof p.optimizedModelFilePath?(0,o.allocWasmString)(p.optimizedModelFilePath,c):0;if(l=u._OrtCreateSessionOptions(e,!!p.enableCpuMemArena,!!p.enableMemPattern,d,!!p.enableProfiling,0,f,h,g,m),0===l)throw new Error("Can't create session options");return p.executionProviders&&((e,t,n)=>{for(const r of t){let t="string"==typeof r?r:r.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${t}`)}const a=(0,o.allocWasmString)(t,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(e,a))throw new Error(`Can't append execution provider: ${t}`)}})(l,p.executionProviders,c),void 0!==p.extra&&(0,r.iterateExtraOptions)(p.extra,"",new WeakSet,((e,t)=>{const n=(0,o.allocWasmString)(e,c),r=(0,o.allocWasmString)(t,c);if(0!==u._OrtAddSessionConfigEntry(l,n,r))throw new Error(`Can't set a session config entry: ${e} - ${t}`)})),[l,c]}catch(e){throw 0!==l&&u._OrtReleaseSessionOptions(l),c.forEach(u._free),e}}},9444:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allocWasmString=void 0;const r=n(263);t.allocWasmString=(e,t)=>{const n=(0,r.getInstance)(),o=n.lengthBytesUTF8(e)+1,i=n._malloc(o);return n.stringToUTF8(e,i,o),t.push(i),i}},7917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},1259:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=void 0;const r=n(7918),o=n(7622),i=n(9444),a=n(7917),s=n(263);t.initOrt=(e,t)=>{const n=(0,s.getInstance)()._OrtInit(e,t);if(0!==n)throw new Error(`Can't initialize onnxruntime. error code = ${n}`)};const u=new Map;t.createSessionAllocate=e=>{const t=(0,s.getInstance)(),n=t._malloc(e.byteLength);return t.HEAPU8.set(e,n),[n,e.byteLength]},t.createSessionFinalize=(e,t)=>{const n=(0,s.getInstance)();let r=0,i=0,a=[];try{if([i,a]=(0,o.setSessionOptions)(t),r=n._OrtCreateSession(e[0],e[1],i),0===r)throw new Error("Can't create a session")}finally{n._free(e[0]),0!==i&&n._OrtReleaseSessionOptions(i),a.forEach(n._free)}const l=n._OrtGetInputCount(r),c=n._OrtGetOutputCount(r),p=[],d=[],f=[],h=[];for(let e=0;e<l;e++){const t=n._OrtGetInputName(r,e);if(0===t)throw new Error("Can't get an input name");d.push(t),p.push(n.UTF8ToString(t))}for(let e=0;e<c;e++){const t=n._OrtGetOutputName(r,e);if(0===t)throw new Error("Can't get an output name");h.push(t),f.push(n.UTF8ToString(t))}return u.set(r,[r,d,h]),[r,p,f]},t.createSession=(e,n)=>{const r=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(r,n)},t.releaseSession=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],o=n[1],i=n[2];o.forEach(t._OrtFree),i.forEach(t._OrtFree),t._OrtReleaseSession(r),u.delete(e)},t.run=async(e,t,n,o,l)=>{const c=(0,s.getInstance)(),p=u.get(e);if(!p)throw new Error("invalid session id");const d=p[0],f=p[1],h=p[2],g=t.length,m=o.length;let b=0,y=[];const w=[],_=[];try{[b,y]=(0,r.setRunOptions)(l);for(let e=0;e<g;e++){const t=n[e][0],r=n[e][1],o=n[e][2];let s,u;if(Array.isArray(o)){u=4*o.length,s=c._malloc(u),_.push(s);let e=s/4;for(let t=0;t<o.length;t++){if("string"!=typeof o[t])throw new TypeError(`tensor data at index ${t} is not a string`);c.HEAPU32[e++]=(0,i.allocWasmString)(o[t],_)}}else u=o.byteLength,s=c._malloc(u),_.push(s),c.HEAPU8.set(new Uint8Array(o.buffer,o.byteOffset,u),s);const l=c.stackSave(),p=c.stackAlloc(4*r.length);try{let e=p/4;r.forEach((t=>c.HEAP32[e++]=t));const n=c._OrtCreateTensor((0,a.tensorDataTypeStringToEnum)(t),s,u,p,r.length);if(0===n)throw new Error("Can't create a tensor");w.push(n)}finally{c.stackRestore(l)}}const e=c.stackSave(),s=c.stackAlloc(4*g),u=c.stackAlloc(4*g),p=c.stackAlloc(4*m),v=c.stackAlloc(4*m);try{let e=s/4,n=u/4,r=p/4,i=v/4;for(let r=0;r<g;r++)c.HEAPU32[e++]=w[r],c.HEAPU32[n++]=f[t[r]];for(let e=0;e<m;e++)c.HEAPU32[r++]=0,c.HEAPU32[i++]=h[o[e]];let l=c._OrtRun(d,u,s,g,v,m,p,b);const y=c.jsepRunPromise;y&&void 0!==y.then&&(l=await y);const _=[];if(0===l)for(let e=0;e<m;e++){const t=c.HEAPU32[p/4+e],n=c.stackSave(),r=c.stackAlloc(16);let o,i=0;try{if(l=c._OrtGetTensorData(t,r,r+4,r+8,r+12),0!==l)throw new Error(`Can't access output tensor data. error code = ${l}`);let e=r/4;const n=c.HEAPU32[e++];i=c.HEAPU32[e++];const s=c.HEAPU32[e++],u=c.HEAPU32[e++],p=[];for(let e=0;e<u;e++)p.push(c.HEAPU32[s/4+e]);c._OrtFree(s);const d=0===p.length?1:p.reduce(((e,t)=>e*t));if(o=(0,a.tensorDataTypeEnumToString)(n),"string"===o){const e=[];let t=i/4;for(let n=0;n<d;n++){const r=c.HEAPU32[t++],o=n===d-1?void 0:c.HEAPU32[t]-r;e.push(c.UTF8ToString(r,o))}_.push([o,p,e])}else{const e=new((0,a.tensorTypeToTypedArrayConstructor)(o))(d);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(c.HEAPU8.subarray(i,i+e.byteLength)),_.push([o,p,e])}}finally{c.stackRestore(n),"string"===o&&i&&c._free(i),c._OrtReleaseTensor(t)}}if(0===l)return _;throw new Error(`failed to call OrtRun(). error code = ${l}.`)}finally{c.stackRestore(e)}}finally{w.forEach(c._OrtReleaseTensor),_.forEach(c._free),c._OrtReleaseRunOptions(b),y.forEach(c._free)}},t.endProfiling=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],o=t._OrtEndProfiling(r);if(0===o)throw new Error("Can't get an profile file name");t._OrtFree(o)},t.extractTransferableBuffers=e=>{const t=[];for(const n of e){const e=n[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var o=Object.getOwnPropertyDescriptor(t,n);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,o)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return o(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const a=i(n(6449)),s=n(932),u=n(3474);let l,c=!1,p=!1,d=!1;t.initializeWebAssembly=async e=>{if(c)return Promise.resolve();if(p)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(d)throw new Error("previous call to 'initializeWebAssembly()' failed.");p=!0;const t=e.initTimeout,r=e.numThreads,o=e.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),f=o&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),h=e.wasmPaths,g="string"==typeof h?h:void 0,m=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(f,i),b="object"==typeof h?h[m]:void 0;let y=!1;const w=[];if(t>0&&w.push(new Promise((e=>{setTimeout((()=>{y=!0,e()}),t)}))),w.push(new Promise(((e,t)=>{const r=i?u:s,o={locateFile:(e,t)=>i&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(4154)],{type:"text/javascript"})):e.endsWith(".wasm")?b||(null!=g?g:t)+m:t+e};if(i)if("undefined"==typeof Blob)o.mainScriptUrlOrBlob=a.join("/","ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;o.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}r(o).then((t=>{p=!1,c=!0,l=t,e()}),(e=>{p=!1,d=!0,t(e)}))}))),await Promise.race(w),y)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(c&&l)return l;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!c||p||d||(p=!0,null===(e=l.PThread)||void 0===e||e.terminateAllThreads(),l=void 0,p=!1,c=!1,d=!0)}},8050:(e,t,n)=>{"use strict";n.d(t,{Z:()=>i});var r=n(6614),o=n.n(r);function i(){return o()('/*!\n* ONNX Runtime Web v1.15.1\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={899:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.iterateExtraOptions=void 0,t.iterateExtraOptions=(e,n,r,a)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,o])=>{const i=n?n+e:e;if("object"==typeof o)(0,t.iterateExtraOptions)(o,i+".",r,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can\'t handle extra config type: "+typeof o);a(i,o?"1":"0")}}))}},918:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setRunOptions=e=>{const t=(0,o.getInstance)();let n=0;const i=[],s=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(s.terminate=!1);let o=0;if(void 0!==(null==e?void 0:e.tag)&&(o=(0,a.allocWasmString)(e.tag,i)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,o),0===n)throw new Error("Can\'t create run options");return void 0!==(null==e?void 0:e.extra)&&(0,r.iterateExtraOptions)(e.extra,"",new WeakSet,((e,r)=>{const o=(0,a.allocWasmString)(e,i),s=(0,a.allocWasmString)(r,i);if(0!==t._OrtAddRunConfigEntry(n,o,s))throw new Error(`Can\'t set a run config entry: ${e} - ${r}`)})),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),i.forEach(t._free),e}}},622:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setSessionOptions=e=>{var t,n,i,s;const u=(0,o.getInstance)();let c=0;const l=[],f=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(f);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=f.graphOptimizationLevel)&&void 0!==t?t:"all"),p=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(n=f.executionMode)&&void 0!==n?n:"sequential"),d="string"==typeof f.logId?(0,a.allocWasmString)(f.logId,l):0,m=null!==(i=f.logSeverityLevel)&&void 0!==i?i:2;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log serverity level is not valid: ${m}`);const g=null!==(s=f.logVerbosityLevel)&&void 0!==s?s:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h="string"==typeof f.optimizedModelFilePath?(0,a.allocWasmString)(f.optimizedModelFilePath,l):0;if(c=u._OrtCreateSessionOptions(e,!!f.enableCpuMemArena,!!f.enableMemPattern,p,!!f.enableProfiling,0,d,m,g,h),0===c)throw new Error("Can\'t create session options");return f.executionProviders&&((e,t,n)=>{for(const r of t){let t="string"==typeof r?r:r.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${t}`)}const i=(0,a.allocWasmString)(t,n);if(0!==(0,o.getInstance)()._OrtAppendExecutionProvider(e,i))throw new Error(`Can\'t append execution provider: ${t}`)}})(c,f.executionProviders,l),void 0!==f.extra&&(0,r.iterateExtraOptions)(f.extra,"",new WeakSet,((e,t)=>{const n=(0,a.allocWasmString)(e,l),r=(0,a.allocWasmString)(t,l);if(0!==u._OrtAddSessionConfigEntry(c,n,r))throw new Error(`Can\'t set a session config entry: ${e} - ${t}`)})),[c,l]}catch(e){throw 0!==c&&u._OrtReleaseSessionOptions(c),l.forEach(u._free),e}}},444:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allocWasmString=void 0;const r=n(263);t.allocWasmString=(e,t)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(e)+1,o=n._malloc(a);return n.stringToUTF8(e,o,a),t.push(o),o}},917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=void 0;const r=n(918),a=n(622),o=n(444),i=n(917),s=n(263);t.initOrt=(e,t)=>{const n=(0,s.getInstance)()._OrtInit(e,t);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;t.createSessionAllocate=e=>{const t=(0,s.getInstance)(),n=t._malloc(e.byteLength);return t.HEAPU8.set(e,n),[n,e.byteLength]},t.createSessionFinalize=(e,t)=>{const n=(0,s.getInstance)();let r=0,o=0,i=[];try{if([o,i]=(0,a.setSessionOptions)(t),r=n._OrtCreateSession(e[0],e[1],o),0===r)throw new Error("Can\'t create a session")}finally{n._free(e[0]),0!==o&&n._OrtReleaseSessionOptions(o),i.forEach(n._free)}const c=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],d=[],m=[];for(let e=0;e<c;e++){const t=n._OrtGetInputName(r,e);if(0===t)throw new Error("Can\'t get an input name");p.push(t),f.push(n.UTF8ToString(t))}for(let e=0;e<l;e++){const t=n._OrtGetOutputName(r,e);if(0===t)throw new Error("Can\'t get an output name");m.push(t),d.push(n.UTF8ToString(t))}return u.set(r,[r,p,m]),[r,f,d]},t.createSession=(e,n)=>{const r=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(r,n)},t.releaseSession=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],o=n[2];a.forEach(t._OrtFree),o.forEach(t._OrtFree),t._OrtReleaseSession(r),u.delete(e)},t.run=async(e,t,n,a,c)=>{const l=(0,s.getInstance)(),f=u.get(e);if(!f)throw new Error("invalid session id");const p=f[0],d=f[1],m=f[2],g=t.length,h=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,r.setRunOptions)(c);for(let e=0;e<g;e++){const t=n[e][0],r=n[e][1],a=n[e][2];let s,u;if(Array.isArray(a)){u=4*a.length,s=l._malloc(u),w.push(s);let e=s/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,o.allocWasmString)(a[t],w)}}else u=a.byteLength,s=l._malloc(u),w.push(s),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),s);const c=l.stackSave(),f=l.stackAlloc(4*r.length);try{let e=f/4;r.forEach((t=>l.HEAP32[e++]=t));const n=l._OrtCreateTensor((0,i.tensorDataTypeStringToEnum)(t),s,u,f,r.length);if(0===n)throw new Error("Can\'t create a tensor");b.push(n)}finally{l.stackRestore(c)}}const e=l.stackSave(),s=l.stackAlloc(4*g),u=l.stackAlloc(4*g),f=l.stackAlloc(4*h),_=l.stackAlloc(4*h);try{let e=s/4,n=u/4,r=f/4,o=_/4;for(let r=0;r<g;r++)l.HEAPU32[e++]=b[r],l.HEAPU32[n++]=d[t[r]];for(let e=0;e<h;e++)l.HEAPU32[r++]=0,l.HEAPU32[o++]=m[a[e]];let c=l._OrtRun(p,u,s,g,_,h,f,y);const v=l.jsepRunPromise;v&&void 0!==v.then&&(c=await v);const w=[];if(0===c)for(let e=0;e<h;e++){const t=l.HEAPU32[f/4+e],n=l.stackSave(),r=l.stackAlloc(16);let a,o=0;try{if(c=l._OrtGetTensorData(t,r,r+4,r+8,r+12),0!==c)throw new Error(`Can\'t access output tensor data. error code = ${c}`);let e=r/4;const n=l.HEAPU32[e++];o=l.HEAPU32[e++];const s=l.HEAPU32[e++],u=l.HEAPU32[e++],f=[];for(let e=0;e<u;e++)f.push(l.HEAPU32[s/4+e]);l._OrtFree(s);const p=0===f.length?1:f.reduce(((e,t)=>e*t));if(a=(0,i.tensorDataTypeEnumToString)(n),"string"===a){const e=[];let t=o/4;for(let n=0;n<p;n++){const r=l.HEAPU32[t++],a=n===p-1?void 0:l.HEAPU32[t]-r;e.push(l.UTF8ToString(r,a))}w.push([a,f,e])}else{const e=new((0,i.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(o,o+e.byteLength)),w.push([a,f,e])}}finally{l.stackRestore(n),"string"===a&&o&&l._free(o),l._OrtReleaseTensor(t)}}if(0===c)return w;throw new Error(`failed to call OrtRun(). error code = ${c}.`)}finally{l.stackRestore(e)}}finally{b.forEach(l._OrtReleaseTensor),w.forEach(l._free),l._OrtReleaseRunOptions(y),v.forEach(l._free)}},t.endProfiling=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=t._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const n of e){const e=n[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const i=o(n(449)),s=n(932),u=n(474);let c,l=!1,f=!1,p=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(p)throw new Error("previous call to \'initializeWebAssembly()\' failed.");f=!0;const t=e.initTimeout,r=e.numThreads,a=e.simd,o=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),d=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),m=e.wasmPaths,g="string"==typeof m?m:void 0,h=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(d,o),y="object"==typeof m?m[h]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const r=o?u:s,a={locateFile:(e,t)=>o&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):e.endsWith(".wasm")?y||(null!=g?g:t)+h:t+e};if(o)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=i.join("/","ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}r(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,p=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!l||f||p||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,p=!0)}},474:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){function t(){return P.buffer!=D&&G(P.buffer),F}function r(){return P.buffer!=D&&G(P.buffer),U}function a(){return P.buffer!=D&&G(P.buffer),I}function o(){return P.buffer!=D&&G(P.buffer),W}function i(){return P.buffer!=D&&G(P.buffer),j}var s,u,c;e=e||{},s||(s=void 0!==e?e:{}),s.ready=new Promise((function(e,t){u=e,c=t}));var l,f,p,d,m,g,h=Object.assign({},s),y="./this.program",v=(e,t)=>{throw t},b="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=s.ENVIRONMENT_IS_PTHREAD||!1,S="";function T(e){return s.locateFile?s.locateFile(e,S):S+e}if(_){let t;S=w?n(908).dirname(S)+"/":"//",g=()=>{m||(d=n(384),m=n(908))},l=function(e,t){return g(),e=m.normalize(e),d.readFileSync(e,t?void 0:"utf8")},p=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,n)=>{g(),e=m.normalize(e),d.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(y=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof ie))throw e})),process.on("unhandledRejection",(function(e){throw e})),v=(e,t)=>{if(C)throw process.exitCode=e,t;t instanceof ie||x("exiting due to exception: "+t),process.exit(e)},s.inspect=function(){return"[Emscripten Module object]"};try{t=n(925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}n.g.Worker=t.Worker}else(b||w)&&(w?S=self.location.href:"undefined"!=typeof document&&document.currentScript&&(S=document.currentScript.src),_scriptDir&&(S=_scriptDir),S=0!==S.indexOf("blob:")?S.substr(0,S.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},w&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var A=console.log.bind(console),E=console.warn.bind(console);_&&(g(),A=e=>d.writeSync(1,e+"\\n"),E=e=>d.writeSync(2,e+"\\n"));var M,R=s.print||A,x=s.printErr||E;Object.assign(s,h),h=null,s.thisProgram&&(y=s.thisProgram),s.quit&&(v=s.quit),s.wasmBinary&&(M=s.wasmBinary);var C=s.noExitRuntime||!0;"object"!=typeof WebAssembly&&ne("no native wasm support detected");var P,k,D,F,U,I,W,j,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function Y(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&L)return L.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function z(e,t){return(e>>>=0)?Y(r(),e,t):""}function B(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function N(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function G(e){D=e,s.HEAP8=F=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=I=new Int32Array(e),s.HEAPU8=U=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=W=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=j=new Float64Array(e)}O&&(D=s.buffer);var q=s.INITIAL_MEMORY||16777216;if(O)P=s.wasmMemory,D=s.buffer;else if(s.wasmMemory)P=s.wasmMemory;else if(!((P=new WebAssembly.Memory({initial:q/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");P&&(D=P.buffer),q=D.byteLength,G(D);var $,V=[],J=[],Q=[];function X(){var e=s.preRun.shift();V.unshift(e)}var K,Z=0,ee=null,te=null;function ne(e){throw O?postMessage({cmd:"onAbort",arg:e}):s.onAbort&&s.onAbort(e),x(e="Aborted("+e+")"),H=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),c(e),e}function re(){return K.startsWith("data:application/octet-stream;base64,")}function ae(){var e=K;try{if(e==K&&M)return new Uint8Array(M);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}catch(e){ne(e)}}K="ort-wasm-threaded.wasm",re()||(K=T(K));var oe={};function ie(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function se(e){(e=fe.La[e])||ne(),fe.Xa(e)}function ue(e){var t=fe.lb();if(!t)return 6;fe.Ra.push(t),fe.La[e.Ka]=t,t.Ka=e.Ka;var n={cmd:"run",start_routine:e.pb,arg:e.ib,pthread_ptr:e.Ka};return t.Qa=()=>{n.time=performance.now(),t.postMessage(n,e.vb)},t.loaded&&(t.Qa(),delete t.Qa),0}function ce(e){if(O)return He(1,1,e);C||(fe.qb(),s.onExit&&s.onExit(e),H=!0),v(e,new ie(e))}function le(e,t){if(!t&&O)throw de(e),"unwind";ce(e)}var fe={Oa:[],Ra:[],$a:[],La:{},Ua:function(){O&&fe.mb()},xb:function(){},mb:function(){fe.receiveObjectTransfer=fe.ob,fe.threadInitTLS=fe.Za,fe.setExitStatus=fe.Ya,C=!1},Ya:function(){},qb:function(){for(var e of Object.values(fe.La))fe.Xa(e);for(e of fe.Oa)e.terminate();fe.Oa=[]},Xa:function(e){var t=e.Ka;delete fe.La[t],fe.Oa.push(e),fe.Ra.splice(fe.Ra.indexOf(e),1),e.Ka=0,ct(t)},ob:function(){},Za:function(){fe.$a.forEach((e=>e()))},nb:function(e,t){e.onmessage=n=>{var r=(n=n.data).cmd;if(e.Ka&&(fe.kb=e.Ka),n.targetThread&&n.targetThread!=rt()){var a=fe.La[n.yb];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?De(n.queue):"spawnThread"===r?ue(n):"cleanupThread"===r?se(n.thread):"killThread"===r?(n=n.thread,r=fe.La[n],delete fe.La[n],r.terminate(),ct(n),fe.Ra.splice(fe.Ra.indexOf(r),1),r.Ka=0):"cancelThread"===r?fe.La[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t&&t(e),e.Qa&&(e.Qa(),delete e.Qa)):"print"===r?R("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"onAbort"===r?s.onAbort&&s.onAbort(n.arg):r&&x("worker sent an unknown command "+r);fe.kb=void 0},e.onerror=e=>{throw x("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},_&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){}))),e.postMessage({cmd:"load",urlOrBlob:s.mainScriptUrlOrBlob||_scriptDir,wasmMemory:P,wasmModule:k})},hb:function(){var e=T("ort-wasm-threaded.worker.js");fe.Oa.push(new Worker(e))},lb:function(){return 0==fe.Oa.length&&(fe.hb(),fe.nb(fe.Oa[0])),fe.Oa.pop()}};function pe(e){for(;0<e.length;)e.shift()(s)}function de(e){if(O)return He(2,0,e);try{le(e)}catch(e){e instanceof ie||"unwind"==e||v(1,e)}}s.PThread=fe,s.establishStackSpace=function(){var e=rt(),t=a()[e+44>>2>>>0];e=a()[e+48>>2>>>0],ft(t,t-e),dt(t)};var me,ge,he=[];function ye(e){this.Pa=e-24,this.gb=function(e){o()[this.Pa+4>>2>>>0]=e},this.cb=function(e){o()[this.Pa+8>>2>>>0]=e},this.eb=function(){a()[this.Pa>>2>>>0]=0},this.bb=function(){t()[this.Pa+12>>0>>>0]=0},this.fb=function(){t()[this.Pa+13>>0>>>0]=0},this.Ua=function(e,t){this.ab(),this.gb(e),this.cb(t),this.eb(),this.bb(),this.fb()},this.ab=function(){o()[this.Pa+16>>2>>>0]=0}}function ve(e,t,n,r){return O?He(3,1,e,t,n,r):be(e,t,n,r)}function be(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?ve(e,t,n,r):(e={pb:n,Ka:e,ib:r,vb:a},O?(e.wb="spawnThread",postMessage(e,a),0):ue(e))}function we(e,t,n){return O?He(4,1,e,t,n):0}function _e(e,t){if(O)return He(5,1,e,t)}function Oe(e,t){if(O)return He(6,1,e,t)}function Se(e,t,n){if(O)return He(7,1,e,t,n)}function Te(e,t,n){return O?He(8,1,e,t,n):0}function Ae(e,t){if(O)return He(9,1,e,t)}function Ee(e,t,n){if(O)return He(10,1,e,t,n)}function Me(e,t,n,r){if(O)return He(11,1,e,t,n,r)}function Re(e,t,n,r){if(O)return He(12,1,e,t,n,r)}function xe(e,t,n,r){if(O)return He(13,1,e,t,n,r)}function Ce(e){if(O)return He(14,1,e)}function Pe(e,t){if(O)return He(15,1,e,t)}function ke(e,t,n){if(O)return He(16,1,e,t,n)}function De(e){Atomics.store(a(),e>>2,1),rt()&&ut(e),Atomics.compareExchange(a(),e>>2,1,0)}function Fe(e){return o()[e>>>2]+4294967296*a()[e+4>>>2]}function Ue(e,t,n,r,a,o){return O?He(17,1,e,t,n,r,a,o):-52}function Ie(e,t,n,r,a,o){if(O)return He(18,1,e,t,n,r,a,o)}function We(e){var n=N(e)+1,r=at(n);return r&&B(e,t(),r,n),r}function je(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}if(O)return He(19,1,e,t,n);var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(i,c);a()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(i!=c),e=r(s),t=r(u),e=We(e),t=We(t),c<i?(o()[n>>2>>>0]=e,o()[n+4>>2>>>0]=t):(o()[n>>2>>>0]=t,o()[n+4>>2>>>0]=e)}function He(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=pt();return e=e(),dt(t),e}((()=>{for(var a=mt(8*n),o=a>>3,s=0;s<n;s++){var u=r[2+s];i()[o+s>>>0]=u}return st(e,n,a,t)}))}s.invokeEntryPoint=function(e,t){var n=he[e];n||(e>=he.length&&(he.length=e+1),he[e]=n=$.get(e)),e=n(t),C?fe.Ya(e):lt(e)},s.executeNotifiedProxyingQueue=De,ge=_?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:O?()=>performance.now()-s.__performance_now_clock_drift:()=>performance.now();var Le,Ye=[],ze={};function Be(){if(!Le){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:y||"./this.program"};for(e in ze)void 0===ze[e]?delete t[e]:t[e]=ze[e];var n=[];for(e in t)n.push(e+"="+t[e]);Le=n}return Le}function Ne(e,n){if(O)return He(20,1,e,n);var r=0;return Be().forEach((function(a,i){var s=n+r;for(i=o()[e+4*i>>2>>>0]=s,s=0;s<a.length;++s)t()[i++>>0>>>0]=a.charCodeAt(s);t()[i>>0>>>0]=0,r+=a.length+1})),0}function Ge(e,t){if(O)return He(21,1,e,t);var n=Be();o()[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),o()[t>>2>>>0]=r,0}function qe(e){return O?He(22,1,e):52}function $e(e,t,n,r){return O?He(23,1,e,t,n,r):52}function Ve(e,t,n,r,a){return O?He(24,1,e,t,n,r,a):70}var Je=[null,[],[]];function Qe(e,t,n,a){if(O)return He(25,1,e,t,n,a);for(var i=0,s=0;s<n;s++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=r()[u+l>>>0],p=Je[e];0===f||10===f?((1===e?R:x)(Y(p,0)),p.length=0):p.push(f)}i+=c}return o()[a>>2>>>0]=i,0}function Xe(e){return 0==e%4&&(0!=e%100||0==e%400)}var Ke=[31,29,31,30,31,30,31,31,30,31,30,31],Ze=[31,28,31,30,31,30,31,31,30,31,30,31];function et(e,n,r,o){function i(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function s(e,t){return i(e,t,"0")}function u(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function c(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function l(e){var t=e.Ma;for(e=new Date(new Date(e.Na+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(Xe(e.getFullYear())?Ke:Ze)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=c(new Date(e.getFullYear(),0,4)),n=c(n),0>=u(t,e)?0>=u(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var f=a()[o+40>>2>>>0];for(var p in o={tb:a()[o>>2>>>0],sb:a()[o+4>>2>>>0],Sa:a()[o+8>>2>>>0],Va:a()[o+12>>2>>>0],Ta:a()[o+16>>2>>>0],Na:a()[o+20>>2>>>0],Ja:a()[o+24>>2>>>0],Ma:a()[o+28>>2>>>0],zb:a()[o+32>>2>>>0],rb:a()[o+36>>2>>>0],ub:f?z(f):""},r=z(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),m="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(e){return d[e.Ja].substring(0,3)},"%A":function(e){return d[e.Ja]},"%b":function(e){return m[e.Ta].substring(0,3)},"%B":function(e){return m[e.Ta]},"%C":function(e){return s((e.Na+1900)/100|0,2)},"%d":function(e){return s(e.Va,2)},"%e":function(e){return i(e.Va,2," ")},"%g":function(e){return l(e).toString().substring(2)},"%G":function(e){return l(e)},"%H":function(e){return s(e.Sa,2)},"%I":function(e){return 0==(e=e.Sa)?e=12:12<e&&(e-=12),s(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.Ta-1;t+=(Xe(e.Na+1900)?Ke:Ze)[n++]);return s(e.Va+t,3)},"%m":function(e){return s(e.Ta+1,2)},"%M":function(e){return s(e.sb,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.Sa&&12>e.Sa?"AM":"PM"},"%S":function(e){return s(e.tb,2)},"%t":function(){return"\\t"},"%u":function(e){return e.Ja||7},"%U":function(e){return s(Math.floor((e.Ma+7-e.Ja)/7),2)},"%V":function(e){var t=Math.floor((e.Ma+7-(e.Ja+6)%7)/7);if(2>=(e.Ja+371-e.Ma-2)%7&&t++,t)53==t&&(4==(n=(e.Ja+371-e.Ma)%7)||3==n&&Xe(e.Na)||(t=1));else{t=52;var n=(e.Ja+7-e.Ma-1)%7;(4==n||5==n&&Xe(e.Na%400-1))&&t++}return s(t,2)},"%w":function(e){return e.Ja},"%W":function(e){return s(Math.floor((e.Ma+7-(e.Ja+6)%7)/7),2)},"%y":function(e){return(e.Na+1900).toString().substring(2)},"%Y":function(e){return e.Na+1900},"%z":function(e){var t=0<=(e=e.rb);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.ub},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](o)));return p=function(e){var t=Array(N(e)+1);return B(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(e,n){t().set(e,n>>>0)}(p,e),p.length-1)}fe.Ua();var tt=[null,ce,de,ve,we,_e,Oe,Se,Te,Ae,Ee,Me,Re,xe,Ce,Pe,ke,Ue,Ie,je,Ne,Ge,qe,$e,Ve,Qe],nt={b:function(e){return at(e+24)+24},c:function(e,t,n){throw new ye(e).Ua(t,n),e},L:function(e){ot(e,!w,1,!b),fe.Za()},l:function(e){O?postMessage({cmd:"cleanupThread",thread:e}):se(e)},D:be,i:we,R:_e,z:Oe,B:Se,T:Te,P:Ae,I:Ee,O:Me,p:Re,A:xe,x:Ce,Q:Pe,y:ke,r:function(){},j:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},s:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},q:function(){return Date.now()},E:function(){return 2097152},V:function(){return!0},F:function(e,t,n,r){if(e==t)setTimeout((()=>De(r)));else if(O)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{if(!(e=fe.La[e]))return;e.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},K:function(){return-1},W:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getUTCSeconds(),a()[t+4>>2>>>0]=e.getUTCMinutes(),a()[t+8>>2>>>0]=e.getUTCHours(),a()[t+12>>2>>>0]=e.getUTCDate(),a()[t+16>>2>>>0]=e.getUTCMonth(),a()[t+20>>2>>>0]=e.getUTCFullYear()-1900,a()[t+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[t+28>>2>>>0]=e},X:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),a()[t+20>>2>>>0]=e.getFullYear()-1900,a()[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1),r=(e.getTime()-n.getTime())/864e5|0;a()[t+28>>2>>>0]=r,a()[t+36>>2>>>0]=-60*e.getTimezoneOffset(),r=new Date(e.getFullYear(),6,1).getTimezoneOffset(),e=0|(r!=(n=n.getTimezoneOffset())&&e.getTimezoneOffset()==Math.min(n,r)),a()[t+32>>2>>>0]=e},Y:function(e){var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),n=a()[e+32>>2>>>0],r=t.getTimezoneOffset(),o=new Date(t.getFullYear(),0,1),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),s=o.getTimezoneOffset(),u=Math.min(s,i);return 0>n?a()[e+32>>2>>>0]=Number(i!=s&&u==r):0<n!=(u==r)&&(i=Math.max(s,i),t.setTime(t.getTime()+6e4*((0<n?u:i)-r))),a()[e+24>>2>>>0]=t.getDay(),n=(t.getTime()-o.getTime())/864e5|0,a()[e+28>>2>>>0]=n,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},G:Ue,H:Ie,Z:function e(t,n,r){e.jb||(e.jb=!0,je(t,n,r))},d:function(){ne("")},m:function(){if(!_&&!w){var e="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";me||(me={}),me[e]||(me[e]=1,_&&(e="warning: "+e),x(e))}},w:function(){return 4294901760},f:ge,S:function(e,t,n){r().copyWithin(e>>>0,t>>>0,t+n>>>0)},g:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},J:function(e,t,n){Ye.length=t,n>>=3;for(var r=0;r<t;r++)Ye[r]=i()[n+r>>>0];return(0>e?oe[-e-1]:tt[e]).apply(null,Ye)},v:function(e){var t=r().length;if((e>>>=0)<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var a=t*(1+.2/n);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a),o=o.min.call(o,4294901760,a+(65536-a%65536)%65536);e:{try{P.grow(o-D.byteLength+65535>>>16),G(P.buffer);var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},U:function(){throw"unwind"},M:Ne,N:Ge,k:le,h:qe,o:$e,t:Ve,n:Qe,u:function e(r,a){e.Wa||(e.Wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(_)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>ne("randomDevice")}());for(var o=0;o<a;o++)t()[r+o>>0>>>0]=e.Wa();return 0},a:P||s.wasmMemory,C:et,e:function(e,t,n,r){return et(e,t,n,r)}};!function(){function e(e,t){s.asm=e.exports,fe.$a.push(s.asm.wa),$=s.asm.za,J.unshift(s.asm._),k=t,O||(Z--,s.monitorRunDependencies&&s.monitorRunDependencies(Z),0==Z&&(null!==ee&&(clearInterval(ee),ee=null),te&&(e=te,te=null,e())))}function t(t){e(t.instance,t.module)}function n(e){return function(){if(!M&&(b||w)){if("function"==typeof fetch&&!K.startsWith("file://"))return fetch(K,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+K+"\'";return e.arrayBuffer()})).catch((function(){return ae()}));if(f)return new Promise((function(e,t){f(K,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return ae()}))}().then((function(e){return WebAssembly.instantiate(e,r)})).then((function(e){return e})).then(e,(function(e){x("failed to asynchronously prepare wasm: "+e),ne(e)}))}var r={a:nt};if(O||(Z++,s.monitorRunDependencies&&s.monitorRunDependencies(Z)),s.instantiateWasm)try{return s.instantiateWasm(r,e)}catch(e){return x("Module.instantiateWasm callback failed with error: "+e),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||re()||K.startsWith("file://")||_||"function"!=typeof fetch?n(t):fetch(K,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,r).then(t,(function(e){return x("wasm streaming compile failed: "+e),x("falling back to ArrayBuffer instantiation"),n(t)}))}))).catch(c)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm._).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.$).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.aa).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.ba).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.ca).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm.da).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.ea).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.fa).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.ga).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.ha).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm.ia).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.ja).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.ka).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.la).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.ma).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.na).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.oa).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.pa).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.qa).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.ra).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.sa).apply(null,arguments)};var rt=s._pthread_self=function(){return(rt=s._pthread_self=s.asm.ta).apply(null,arguments)},at=s._malloc=function(){return(at=s._malloc=s.asm.ua).apply(null,arguments)};s._free=function(){return(s._free=s.asm.va).apply(null,arguments)},s.__emscripten_tls_init=function(){return(s.__emscripten_tls_init=s.asm.wa).apply(null,arguments)};var ot=s.__emscripten_thread_init=function(){return(ot=s.__emscripten_thread_init=s.asm.xa).apply(null,arguments)};s.__emscripten_thread_crashed=function(){return(s.__emscripten_thread_crashed=s.asm.ya).apply(null,arguments)};var it,st=s._emscripten_run_in_main_runtime_thread_js=function(){return(st=s._emscripten_run_in_main_runtime_thread_js=s.asm.Aa).apply(null,arguments)},ut=s.__emscripten_proxy_execute_task_queue=function(){return(ut=s.__emscripten_proxy_execute_task_queue=s.asm.Ba).apply(null,arguments)},ct=s.__emscripten_thread_free_data=function(){return(ct=s.__emscripten_thread_free_data=s.asm.Ca).apply(null,arguments)},lt=s.__emscripten_thread_exit=function(){return(lt=s.__emscripten_thread_exit=s.asm.Da).apply(null,arguments)},ft=s._emscripten_stack_set_limits=function(){return(ft=s._emscripten_stack_set_limits=s.asm.Ea).apply(null,arguments)},pt=s.stackSave=function(){return(pt=s.stackSave=s.asm.Fa).apply(null,arguments)},dt=s.stackRestore=function(){return(dt=s.stackRestore=s.asm.Ga).apply(null,arguments)},mt=s.stackAlloc=function(){return(mt=s.stackAlloc=s.asm.Ha).apply(null,arguments)};function gt(){function e(){if(!it&&(it=!0,s.calledRun=!0,!H)&&(O||pe(J),u(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!O)){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;){var e=s.postRun.shift();Q.unshift(e)}pe(Q)}}if(!(0<Z))if(O)u(s),O||pe(J),postMessage({cmd:"loaded"});else{if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)X();pe(V),0<Z||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),e()}),1)):e())}}if(s.___cxa_is_pointer_type=function(){return(s.___cxa_is_pointer_type=s.asm.Ia).apply(null,arguments)},s.UTF8ToString=z,s.stringToUTF8=function(e,t,n){return B(e,r(),t,n)},s.lengthBytesUTF8=N,s.keepRuntimeAlive=function(){return C},s.wasmMemory=P,s.stackSave=pt,s.stackRestore=dt,s.stackAlloc=mt,s.ExitStatus=ie,s.PThread=fe,te=function e(){it||gt(),it||(te=e)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return gt(),e.ready});e.exports=r},932:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){var t,r,a;e=e||{},t||(t=void 0!==e?e:{}),t.ready=new Promise((function(e,t){r=e,a=t}));var o,i,s,u,c,l,f=Object.assign({},t),p="./this.program",d=(e,t)=>{throw t},m="object"==typeof window,g="function"==typeof importScripts,h="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,y="";h?(y=g?n(908).dirname(y)+"/":"//",l=()=>{c||(u=n(384),c=n(908))},o=function(e,t){return l(),e=c.normalize(e),u.readFileSync(e,t?void 0:"utf8")},s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,n)=>{l(),e=c.normalize(e),u.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof $))throw e})),process.on("unhandledRejection",(function(e){throw e})),d=(e,t)=>{if(_)throw process.exitCode=e,t;t instanceof $||w("exiting due to exception: "+t),process.exit(e)},t.inspect=function(){return"[Emscripten Module object]"}):(m||g)&&(g?y=self.location.href:"undefined"!=typeof document&&document.currentScript&&(y=document.currentScript.src),_scriptDir&&(y=_scriptDir),y=0!==y.indexOf("blob:")?y.substr(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},g&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),i=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var v,b=t.print||console.log.bind(console),w=t.printErr||console.warn.bind(console);Object.assign(t,f),f=null,t.thisProgram&&(p=t.thisProgram),t.quit&&(d=t.quit),t.wasmBinary&&(v=t.wasmBinary);var _=t.noExitRuntime||!0;"object"!=typeof WebAssembly&&B("no native wasm support detected");var O,S,T,A,E,M,R=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function C(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&x)return x.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function P(e,t){return(e>>>=0)?C(A,e,t):""}function k(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function D(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function F(){var e=O.buffer;S=e,t.HEAP8=T=new Int8Array(e),t.HEAP16=new Int16Array(e),t.HEAP32=E=new Int32Array(e),t.HEAPU8=A=new Uint8Array(e),t.HEAPU16=new Uint16Array(e),t.HEAPU32=M=new Uint32Array(e),t.HEAPF32=new Float32Array(e),t.HEAPF64=new Float64Array(e)}var U=[],I=[],W=[];function j(){var e=t.preRun.shift();U.unshift(e)}var H,L=0,Y=null,z=null;function B(e){throw t.onAbort&&t.onAbort(e),w(e="Aborted("+e+")"),R=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),a(e),e}function N(){return H.startsWith("data:application/octet-stream;base64,")}if(H="ort-wasm.wasm",!N()){var G=H;H=t.locateFile?t.locateFile(G,y):y+G}function q(){var e=H;try{if(e==H&&v)return new Uint8Array(v);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}catch(e){B(e)}}function $(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function V(e){for(;0<e.length;)e.shift()(t)}function J(e){this.sa=e-24,this.Ia=function(e){M[this.sa+4>>2>>>0]=e},this.Ba=function(e){M[this.sa+8>>2>>>0]=e},this.Ga=function(){E[this.sa>>2>>>0]=0},this.Aa=function(){T[this.sa+12>>0>>>0]=0},this.Ha=function(){T[this.sa+13>>0>>>0]=0},this.ya=function(e,t){this.za(),this.Ia(e),this.Ba(t),this.Ga(),this.Aa(),this.Ha()},this.za=function(){M[this.sa+16>>2>>>0]=0}}function Q(e){var t=D(e)+1,n=ie(t);return n&&k(e,T,n,t),n}var X={};function K(){if(!Z){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(e in X)void 0===X[e]?delete t[e]:t[e]=X[e];var n=[];for(e in t)n.push(e+"="+t[e]);Z=n}return Z}var Z,ee=[null,[],[]];function te(e){return 0==e%4&&(0!=e%100||0==e%400)}var ne=[31,29,31,30,31,30,31,31,30,31,30,31],re=[31,28,31,30,31,30,31,31,30,31,30,31];function ae(e,t,n,r){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.qa;for(e=new Date(new Date(e.ra+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(te(e.getFullYear())?ne:re)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=i(t,e)?0>=i(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var c=E[r+40>>2>>>0];for(var l in r={Ea:E[r>>2>>>0],Da:E[r+4>>2>>>0],ta:E[r+8>>2>>>0],va:E[r+12>>2>>>0],ua:E[r+16>>2>>>0],ra:E[r+20>>2>>>0],la:E[r+24>>2>>>0],qa:E[r+28>>2>>>0],Ja:E[r+32>>2>>>0],Ca:E[r+36>>2>>>0],Fa:c?P(c):""},n=P(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),c[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in c={"%a":function(e){return f[e.la].substring(0,3)},"%A":function(e){return f[e.la]},"%b":function(e){return p[e.ua].substring(0,3)},"%B":function(e){return p[e.ua]},"%C":function(e){return o((e.ra+1900)/100|0,2)},"%d":function(e){return o(e.va,2)},"%e":function(e){return a(e.va,2," ")},"%g":function(e){return u(e).toString().substring(2)},"%G":function(e){return u(e)},"%H":function(e){return o(e.ta,2)},"%I":function(e){return 0==(e=e.ta)?e=12:12<e&&(e-=12),o(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.ua-1;t+=(te(e.ra+1900)?ne:re)[n++]);return o(e.va+t,3)},"%m":function(e){return o(e.ua+1,2)},"%M":function(e){return o(e.Da,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.ta&&12>e.ta?"AM":"PM"},"%S":function(e){return o(e.Ea,2)},"%t":function(){return"\\t"},"%u":function(e){return e.la||7},"%U":function(e){return o(Math.floor((e.qa+7-e.la)/7),2)},"%V":function(e){var t=Math.floor((e.qa+7-(e.la+6)%7)/7);if(2>=(e.la+371-e.qa-2)%7&&t++,t)53==t&&(4==(n=(e.la+371-e.qa)%7)||3==n&&te(e.ra)||(t=1));else{t=52;var n=(e.la+7-e.qa-1)%7;(4==n||5==n&&te(e.ra%400-1))&&t++}return o(t,2)},"%w":function(e){return e.la},"%W":function(e){return o(Math.floor((e.qa+7-(e.la+6)%7)/7),2)},"%y":function(e){return(e.ra+1900).toString().substring(2)},"%Y":function(e){return e.ra+1900},"%z":function(e){var t=0<=(e=e.Ca);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.Fa},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),c)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),c[l](r)));return l=function(e){var t=Array(D(e)+1);return k(e,t,0,t.length),t}(n=n.replace(/\\0\\0/g,"%")),l.length>t?0:(T.set(l,e>>>0),l.length-1)}var oe={a:function(e){return ie(e+24)+24},b:function(e,t,n){throw new J(e).ya(t,n),e},g:function(){return 0},I:function(){},w:function(){},y:function(){},K:function(){return 0},G:function(){},C:function(){},F:function(){},k:function(){},x:function(){},u:function(){},H:function(){},v:function(){},n:function(){},p:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},o:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},l:function(){return Date.now()},L:function(){return!0},M:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getUTCSeconds(),E[t+4>>2>>>0]=e.getUTCMinutes(),E[t+8>>2>>>0]=e.getUTCHours(),E[t+12>>2>>>0]=e.getUTCDate(),E[t+16>>2>>>0]=e.getUTCMonth(),E[t+20>>2>>>0]=e.getUTCFullYear()-1900,E[t+24>>2>>>0]=e.getUTCDay(),E[t+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},N:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),E[t+20>>2>>>0]=e.getFullYear()-1900,E[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1);E[t+28>>2>>>0]=(e.getTime()-n.getTime())/864e5|0,E[t+36>>2>>>0]=-60*e.getTimezoneOffset();var r=new Date(e.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[t+32>>2>>>0]=0|(r!=n&&e.getTimezoneOffset()==Math.min(n,r))},O:function(e){var t=new Date(E[e+20>>2>>>0]+1900,E[e+16>>2>>>0],E[e+12>>2>>>0],E[e+8>>2>>>0],E[e+4>>2>>>0],E[e>>2>>>0],0),n=E[e+32>>2>>>0],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),0,1),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=a.getTimezoneOffset(),s=Math.min(i,o);return 0>n?E[e+32>>2>>>0]=Number(o!=i&&s==r):0<n!=(s==r)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<n?s:o)-r))),E[e+24>>2>>>0]=t.getDay(),E[e+28>>2>>>0]=(t.getTime()-a.getTime())/864e5|0,E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},z:function(){return-52},B:function(){},m:function e(t,n,r){e.xa||(e.xa=!0,function(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();E[e>>2>>>0]=60*Math.max(a,s),E[t>>2>>>0]=Number(a!=s),e=r(o),t=r(i),e=Q(e),t=Q(t),s<a?(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t):(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e)}(t,n,r))},d:function(){B("")},t:function(){return 4294901760},h:h?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.now(),J:function(e,t,n){A.copyWithin(e>>>0,t>>>0,t+n>>>0)},f:function(e){var t=A.length;if(4294901760<(e>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math;r=Math.max(e,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);e:{try{O.grow(a-S.byteLength+65535>>>16),F();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){var n=0;return K().forEach((function(r,a){var o=t+n;for(a=M[e+4*a>>2>>>0]=o,o=0;o<r.length;++o)T[a++>>0>>>0]=r.charCodeAt(o);T[a>>0>>>0]=0,n+=r.length+1})),0},E:function(e,t){var n=K();M[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),M[t>>2>>>0]=r,0},r:function(e){_||(t.onExit&&t.onExit(e),R=!0),d(e,new $(e))},e:function(){return 52},j:function(){return 52},q:function(){return 70},i:function(e,t,n,r){for(var a=0,o=0;o<n;o++){var i=M[t>>2>>>0],s=M[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var c=A[i+u>>>0],l=ee[e];0===c||10===c?((1===e?b:w)(C(l,0)),l.length=0):l.push(c)}a+=s}return M[r>>2>>>0]=a,0},s:function e(t,r){e.wa||(e.wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(h)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>B("randomDevice")}());for(var a=0;a<r;a++)T[t+a>>0>>>0]=e.wa();return 0},A:ae,c:function(e,t,n,r){return ae(e,t,n,r)}};!function(){function e(e){t.asm=e.exports,O=t.asm.P,F(),I.unshift(t.asm.Q),L--,t.monitorRunDependencies&&t.monitorRunDependencies(L),0==L&&(null!==Y&&(clearInterval(Y),Y=null),z&&(e=z,z=null,e()))}function n(t){e(t.instance)}function r(e){return function(){if(!v&&(m||g)){if("function"==typeof fetch&&!H.startsWith("file://"))return fetch(H,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+H+"\'";return e.arrayBuffer()})).catch((function(){return q()}));if(i)return new Promise((function(e,t){i(H,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return q()}))}().then((function(e){return WebAssembly.instantiate(e,o)})).then((function(e){return e})).then(e,(function(e){w("failed to asynchronously prepare wasm: "+e),B(e)}))}var o={a:oe};if(L++,t.monitorRunDependencies&&t.monitorRunDependencies(L),t.instantiateWasm)try{return t.instantiateWasm(o,e)}catch(e){return w("Module.instantiateWasm callback failed with error: "+e),!1}(v||"function"!=typeof WebAssembly.instantiateStreaming||N()||H.startsWith("file://")||h||"function"!=typeof fetch?r(n):fetch(H,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,o).then(n,(function(e){return w("wasm streaming compile failed: "+e),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm.Q).apply(null,arguments)},t._OrtInit=function(){return(t._OrtInit=t.asm.R).apply(null,arguments)},t._OrtCreateSessionOptions=function(){return(t._OrtCreateSessionOptions=t.asm.S).apply(null,arguments)},t._OrtAppendExecutionProvider=function(){return(t._OrtAppendExecutionProvider=t.asm.T).apply(null,arguments)},t._OrtAddSessionConfigEntry=function(){return(t._OrtAddSessionConfigEntry=t.asm.U).apply(null,arguments)},t._OrtReleaseSessionOptions=function(){return(t._OrtReleaseSessionOptions=t.asm.V).apply(null,arguments)},t._OrtCreateSession=function(){return(t._OrtCreateSession=t.asm.W).apply(null,arguments)},t._OrtReleaseSession=function(){return(t._OrtReleaseSession=t.asm.X).apply(null,arguments)},t._OrtGetInputCount=function(){return(t._OrtGetInputCount=t.asm.Y).apply(null,arguments)},t._OrtGetOutputCount=function(){return(t._OrtGetOutputCount=t.asm.Z).apply(null,arguments)},t._OrtGetInputName=function(){return(t._OrtGetInputName=t.asm._).apply(null,arguments)},t._OrtGetOutputName=function(){return(t._OrtGetOutputName=t.asm.$).apply(null,arguments)},t._OrtFree=function(){return(t._OrtFree=t.asm.aa).apply(null,arguments)},t._OrtCreateTensor=function(){return(t._OrtCreateTensor=t.asm.ba).apply(null,arguments)},t._OrtGetTensorData=function(){return(t._OrtGetTensorData=t.asm.ca).apply(null,arguments)},t._OrtReleaseTensor=function(){return(t._OrtReleaseTensor=t.asm.da).apply(null,arguments)},t._OrtCreateRunOptions=function(){return(t._OrtCreateRunOptions=t.asm.ea).apply(null,arguments)},t._OrtAddRunConfigEntry=function(){return(t._OrtAddRunConfigEntry=t.asm.fa).apply(null,arguments)},t._OrtReleaseRunOptions=function(){return(t._OrtReleaseRunOptions=t.asm.ga).apply(null,arguments)},t._OrtRun=function(){return(t._OrtRun=t.asm.ha).apply(null,arguments)},t._OrtEndProfiling=function(){return(t._OrtEndProfiling=t.asm.ia).apply(null,arguments)};var ie=t._malloc=function(){return(ie=t._malloc=t.asm.ja).apply(null,arguments)};t._free=function(){return(t._free=t.asm.ka).apply(null,arguments)};var se,ue=t.stackSave=function(){return(ue=t.stackSave=t.asm.ma).apply(null,arguments)},ce=t.stackRestore=function(){return(ce=t.stackRestore=t.asm.na).apply(null,arguments)},le=t.stackAlloc=function(){return(le=t.stackAlloc=t.asm.oa).apply(null,arguments)};function fe(){function e(){if(!se&&(se=!0,t.calledRun=!0,!R)){if(V(I),r(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;){var e=t.postRun.shift();W.unshift(e)}V(W)}}if(!(0<L)){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)j();V(U),0<L||(t.setStatus?(t.setStatus("Running..."),setTimeout((function(){setTimeout((function(){t.setStatus("")}),1),e()}),1)):e())}}if(t.___cxa_is_pointer_type=function(){return(t.___cxa_is_pointer_type=t.asm.pa).apply(null,arguments)},t.UTF8ToString=P,t.stringToUTF8=function(e,t,n){return k(e,A,t,n)},t.lengthBytesUTF8=D,t.stackSave=ue,t.stackRestore=ce,t.stackAlloc=le,z=function e(){se||fe(),se||(z=e)},t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return fe(),e.ready});e.exports=r},154:e=>{"use strict";e.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},760:()=>{},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var o=t[r]={exports:{}};return e[r].call(o.exports,o,o.exports,n),o.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{"use strict";const e=n(259),t=n(263);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,t.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})));break;case"init-ort":try{const{numThreads:t,loggingLevel:r}=n.data.in;(0,e.initOrt)(t,r),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create_allocate":try{const{model:t}=n.data.in,r=(0,e.createSessionAllocate)(t);postMessage({type:"create_allocate",out:r})}catch(e){postMessage({type:"create_allocate",err:e})}break;case"create_finalize":try{const{modeldata:t,options:r}=n.data.in,a=(0,e.createSessionFinalize)(t,r);postMessage({type:"create_finalize",out:a})}catch(e){postMessage({type:"create_finalize",err:e})}break;case"create":try{const{model:t,options:r}=n.data.in,a=(0,e.createSession)(t,r);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=n.data.in;(0,e.releaseSession)(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:r,inputs:a,outputIndices:o,options:i}=n.data.in;(0,e.run)(t,r,a,o,i).then((t=>{postMessage({type:"run",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:"run",err:e})}))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=n.data.in;(0,e.endProfiling)(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n',"Worker",void 0,void 0)}},6614:e=>{"use strict";e.exports=function(e,t,n,r){var o=self||window;try{try{var i;try{i=new o.Blob([e])}catch(t){(i=new(o.BlobBuilder||o.WebKitBlobBuilder||o.MozBlobBuilder||o.MSBlobBuilder)).append(e),i=i.getBlob()}var a=o.URL||o.webkitURL,s=a.createObjectURL(i),u=new o[t](s,n);return a.revokeObjectURL(s),u}catch(r){return new o[t]("data:application/javascript,".concat(encodeURIComponent(e)),n)}}catch(e){if(!r)throw Error("Inline worker is not supported");return new o[t](r,n)}}},3474:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){function t(){return D.buffer!=C&&H(D.buffer),R}function r(){return D.buffer!=C&&H(D.buffer),M}function o(){return D.buffer!=C&&H(D.buffer),N}function i(){return D.buffer!=C&&H(D.buffer),F}function a(){return D.buffer!=C&&H(D.buffer),L}var s,u,l;e=e||{},s||(s=void 0!==e?e:{}),s.ready=new Promise((function(e,t){u=e,l=t}));var c,p,d,f,h,g,m=Object.assign({},s),b="./this.program",y=(e,t)=>{throw t},w="object"==typeof window,_="function"==typeof importScripts,v="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,x=s.ENVIRONMENT_IS_PTHREAD||!1,T="";function S(e){return s.locateFile?s.locateFile(e,T):T+e}if(v){let t;T=_?n(908).dirname(T)+"/":"//",g=()=>{h||(f=n(1384),h=n(908))},c=function(e,t){return g(),e=h.normalize(e),f.readFileSync(e,t?void 0:"utf8")},d=e=>((e=c(e,!0)).buffer||(e=new Uint8Array(e)),e),p=(e,t,n)=>{g(),e=h.normalize(e),f.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(b=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof ae))throw e})),process.on("unhandledRejection",(function(e){throw e})),y=(e,t)=>{if(P)throw process.exitCode=e,t;t instanceof ae||$("exiting due to exception: "+t),process.exit(e)},s.inspect=function(){return"[Emscripten Module object]"};try{t=n(9925)}catch(e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),e}n.g.Worker=t.Worker}else(w||_)&&(_?T=self.location.href:"undefined"!=typeof document&&document.currentScript&&(T=document.currentScript.src),_scriptDir&&(T=_scriptDir),T=0!==T.indexOf("blob:")?T.substr(0,T.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v||(c=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},_&&(d=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),p=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));v&&"undefined"==typeof performance&&(n.g.performance=n(6953).performance);var O=console.log.bind(console),A=console.warn.bind(console);v&&(g(),O=e=>f.writeSync(1,e+"\n"),A=e=>f.writeSync(2,e+"\n"));var E,I=s.print||O,$=s.printErr||A;Object.assign(s,m),m=null,s.thisProgram&&(b=s.thisProgram),s.quit&&(y=s.quit),s.wasmBinary&&(E=s.wasmBinary);var P=s.noExitRuntime||!0;"object"!=typeof WebAssembly&&ne("no native wasm support detected");var D,k,C,R,M,N,F,L,j=!1,U="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function B(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&U)return U.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var o=e[t++];if(128&o){var i=63&e[t++];if(192==(224&o))r+=String.fromCharCode((31&o)<<6|i);else{var a=63&e[t++];65536>(o=224==(240&o)?(15&o)<<12|i<<6|a:(7&o)<<18|i<<12|a<<6|63&e[t++])?r+=String.fromCharCode(o):(o-=65536,r+=String.fromCharCode(55296|o>>10,56320|1023&o))}}else r+=String.fromCharCode(o)}return r}function G(e,t){return(e>>>=0)?B(r(),e,t):""}function V(e,t,n,r){if(!(0<r))return 0;var o=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var a=e.charCodeAt(i);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&e.charCodeAt(++i)),127>=a){if(n>=r)break;t[n++>>>0]=a}else{if(2047>=a){if(n+1>=r)break;t[n++>>>0]=192|a>>6}else{if(65535>=a){if(n+2>=r)break;t[n++>>>0]=224|a>>12}else{if(n+3>=r)break;t[n++>>>0]=240|a>>18,t[n++>>>0]=128|a>>12&63}t[n++>>>0]=128|a>>6&63}t[n++>>>0]=128|63&a}}return t[n>>>0]=0,n-o}function z(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function H(e){C=e,s.HEAP8=R=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=N=new Int32Array(e),s.HEAPU8=M=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=F=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=L=new Float64Array(e)}x&&(C=s.buffer);var W=s.INITIAL_MEMORY||16777216;if(x)D=s.wasmMemory,C=s.buffer;else if(s.wasmMemory)D=s.wasmMemory;else if(!((D=new WebAssembly.Memory({initial:W/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw $("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");D&&(C=D.buffer),W=C.byteLength,H(C);var q,K=[],X=[],Y=[];function J(){var e=s.preRun.shift();K.unshift(e)}var Z,Q=0,ee=null,te=null;function ne(e){throw x?postMessage({cmd:"onAbort",arg:e}):s.onAbort&&s.onAbort(e),$(e="Aborted("+e+")"),j=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),l(e),e}function re(){return Z.startsWith("data:application/octet-stream;base64,")}function oe(){var e=Z;try{if(e==Z&&E)return new Uint8Array(E);if(d)return d(e);throw"both async and sync fetching of the wasm failed"}catch(e){ne(e)}}Z="ort-wasm-threaded.wasm",re()||(Z=S(Z));var ie={};function ae(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function se(e){(e=pe.La[e])||ne(),pe.Xa(e)}function ue(e){var t=pe.lb();if(!t)return 6;pe.Ra.push(t),pe.La[e.Ka]=t,t.Ka=e.Ka;var n={cmd:"run",start_routine:e.pb,arg:e.ib,pthread_ptr:e.Ka};return t.Qa=()=>{n.time=performance.now(),t.postMessage(n,e.vb)},t.loaded&&(t.Qa(),delete t.Qa),0}function le(e){if(x)return je(1,1,e);P||(pe.qb(),s.onExit&&s.onExit(e),j=!0),y(e,new ae(e))}function ce(e,t){if(!t&&x)throw fe(e),"unwind";le(e)}var pe={Oa:[],Ra:[],$a:[],La:{},Ua:function(){x&&pe.mb()},xb:function(){},mb:function(){pe.receiveObjectTransfer=pe.ob,pe.threadInitTLS=pe.Za,pe.setExitStatus=pe.Ya,P=!1},Ya:function(){},qb:function(){for(var e of Object.values(pe.La))pe.Xa(e);for(e of pe.Oa)e.terminate();pe.Oa=[]},Xa:function(e){var t=e.Ka;delete pe.La[t],pe.Oa.push(e),pe.Ra.splice(pe.Ra.indexOf(e),1),e.Ka=0,lt(t)},ob:function(){},Za:function(){pe.$a.forEach((e=>e()))},nb:function(e,t){e.onmessage=n=>{var r=(n=n.data).cmd;if(e.Ka&&(pe.kb=e.Ka),n.targetThread&&n.targetThread!=rt()){var o=pe.La[n.yb];o?o.postMessage(n,n.transferList):$('Internal error! Worker sent a message "'+r+'" to target pthread '+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?Ce(n.queue):"spawnThread"===r?ue(n):"cleanupThread"===r?se(n.thread):"killThread"===r?(n=n.thread,r=pe.La[n],delete pe.La[n],r.terminate(),lt(n),pe.Ra.splice(pe.Ra.indexOf(r),1),r.Ka=0):"cancelThread"===r?pe.La[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t&&t(e),e.Qa&&(e.Qa(),delete e.Qa)):"print"===r?I("Thread "+n.threadId+": "+n.text):"printErr"===r?$("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"onAbort"===r?s.onAbort&&s.onAbort(n.arg):r&&$("worker sent an unknown command "+r);pe.kb=void 0},e.onerror=e=>{throw $("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},v&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){}))),e.postMessage({cmd:"load",urlOrBlob:s.mainScriptUrlOrBlob||_scriptDir,wasmMemory:D,wasmModule:k})},hb:function(){var e=S("ort-wasm-threaded.worker.js");pe.Oa.push(new Worker(e))},lb:function(){return 0==pe.Oa.length&&(pe.hb(),pe.nb(pe.Oa[0])),pe.Oa.pop()}};function de(e){for(;0<e.length;)e.shift()(s)}function fe(e){if(x)return je(2,0,e);try{ce(e)}catch(e){e instanceof ae||"unwind"==e||y(1,e)}}s.PThread=pe,s.establishStackSpace=function(){var e=rt(),t=o()[e+44>>2>>>0];e=o()[e+48>>2>>>0],pt(t,t-e),ft(t)};var he,ge,me=[];function be(e){this.Pa=e-24,this.gb=function(e){i()[this.Pa+4>>2>>>0]=e},this.cb=function(e){i()[this.Pa+8>>2>>>0]=e},this.eb=function(){o()[this.Pa>>2>>>0]=0},this.bb=function(){t()[this.Pa+12>>0>>>0]=0},this.fb=function(){t()[this.Pa+13>>0>>>0]=0},this.Ua=function(e,t){this.ab(),this.gb(e),this.cb(t),this.eb(),this.bb(),this.fb()},this.ab=function(){i()[this.Pa+16>>2>>>0]=0}}function ye(e,t,n,r){return x?je(3,1,e,t,n,r):we(e,t,n,r)}function we(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return $("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var o=[];return x&&0===o.length?ye(e,t,n,r):(e={pb:n,Ka:e,ib:r,vb:o},x?(e.wb="spawnThread",postMessage(e,o),0):ue(e))}function _e(e,t,n){return x?je(4,1,e,t,n):0}function ve(e,t){if(x)return je(5,1,e,t)}function xe(e,t){if(x)return je(6,1,e,t)}function Te(e,t,n){if(x)return je(7,1,e,t,n)}function Se(e,t,n){return x?je(8,1,e,t,n):0}function Oe(e,t){if(x)return je(9,1,e,t)}function Ae(e,t,n){if(x)return je(10,1,e,t,n)}function Ee(e,t,n,r){if(x)return je(11,1,e,t,n,r)}function Ie(e,t,n,r){if(x)return je(12,1,e,t,n,r)}function $e(e,t,n,r){if(x)return je(13,1,e,t,n,r)}function Pe(e){if(x)return je(14,1,e)}function De(e,t){if(x)return je(15,1,e,t)}function ke(e,t,n){if(x)return je(16,1,e,t,n)}function Ce(e){Atomics.store(o(),e>>2,1),rt()&&ut(e),Atomics.compareExchange(o(),e>>2,1,0)}function Re(e){return i()[e>>>2]+4294967296*o()[e+4>>>2]}function Me(e,t,n,r,o,i){return x?je(17,1,e,t,n,r,o,i):-52}function Ne(e,t,n,r,o,i){if(x)return je(18,1,e,t,n,r,o,i)}function Fe(e){var n=z(e)+1,r=ot(n);return r&&V(e,t(),r,n),r}function Le(e,t,n){function r(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}if(x)return je(19,1,e,t,n);var a=(new Date).getFullYear(),s=new Date(a,0,1),u=new Date(a,6,1);a=s.getTimezoneOffset();var l=u.getTimezoneOffset(),c=Math.max(a,l);o()[e>>2>>>0]=60*c,o()[t>>2>>>0]=Number(a!=l),e=r(s),t=r(u),e=Fe(e),t=Fe(t),l<a?(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t):(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e)}function je(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=dt();return e=e(),ft(t),e}((()=>{for(var o=ht(8*n),i=o>>3,s=0;s<n;s++){var u=r[2+s];a()[i+s>>>0]=u}return st(e,n,o,t)}))}s.invokeEntryPoint=function(e,t){var n=me[e];n||(e>=me.length&&(me.length=e+1),me[e]=n=q.get(e)),e=n(t),P?pe.Ya(e):ct(e)},s.executeNotifiedProxyingQueue=Ce,ge=v?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:x?()=>performance.now()-s.__performance_now_clock_drift:()=>performance.now();var Ue,Be=[],Ge={};function Ve(){if(!Ue){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:b||"./this.program"};for(e in Ge)void 0===Ge[e]?delete t[e]:t[e]=Ge[e];var n=[];for(e in t)n.push(e+"="+t[e]);Ue=n}return Ue}function ze(e,n){if(x)return je(20,1,e,n);var r=0;return Ve().forEach((function(o,a){var s=n+r;for(a=i()[e+4*a>>2>>>0]=s,s=0;s<o.length;++s)t()[a++>>0>>>0]=o.charCodeAt(s);t()[a>>0>>>0]=0,r+=o.length+1})),0}function He(e,t){if(x)return je(21,1,e,t);var n=Ve();i()[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),i()[t>>2>>>0]=r,0}function We(e){return x?je(22,1,e):52}function qe(e,t,n,r){return x?je(23,1,e,t,n,r):52}function Ke(e,t,n,r,o){return x?je(24,1,e,t,n,r,o):70}var Xe=[null,[],[]];function Ye(e,t,n,o){if(x)return je(25,1,e,t,n,o);for(var a=0,s=0;s<n;s++){var u=i()[t>>2>>>0],l=i()[t+4>>2>>>0];t+=8;for(var c=0;c<l;c++){var p=r()[u+c>>>0],d=Xe[e];0===p||10===p?((1===e?I:$)(B(d,0)),d.length=0):d.push(p)}a+=l}return i()[o>>2>>>0]=a,0}function Je(e){return 0==e%4&&(0!=e%100||0==e%400)}var Ze=[31,29,31,30,31,30,31,31,30,31,30,31],Qe=[31,28,31,30,31,30,31,31,30,31,30,31];function et(e,n,r,i){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function s(e,t){return a(e,t,"0")}function u(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function l(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function c(e){var t=e.Ma;for(e=new Date(new Date(e.Na+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(Je(e.getFullYear())?Ze:Qe)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=l(new Date(e.getFullYear(),0,4)),n=l(n),0>=u(t,e)?0>=u(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var p=o()[i+40>>2>>>0];for(var d in i={tb:o()[i>>2>>>0],sb:o()[i+4>>2>>>0],Sa:o()[i+8>>2>>>0],Va:o()[i+12>>2>>>0],Ta:o()[i+16>>2>>>0],Na:o()[i+20>>2>>>0],Ja:o()[i+24>>2>>>0],Ma:o()[i+28>>2>>>0],zb:o()[i+32>>2>>>0],rb:o()[i+36>>2>>>0],ub:p?G(p):""},r=G(r),p={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(d,"g"),p[d]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),h="January February March April May June July August September October November December".split(" ");for(d in p={"%a":function(e){return f[e.Ja].substring(0,3)},"%A":function(e){return f[e.Ja]},"%b":function(e){return h[e.Ta].substring(0,3)},"%B":function(e){return h[e.Ta]},"%C":function(e){return s((e.Na+1900)/100|0,2)},"%d":function(e){return s(e.Va,2)},"%e":function(e){return a(e.Va,2," ")},"%g":function(e){return c(e).toString().substring(2)},"%G":function(e){return c(e)},"%H":function(e){return s(e.Sa,2)},"%I":function(e){return 0==(e=e.Sa)?e=12:12<e&&(e-=12),s(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.Ta-1;t+=(Je(e.Na+1900)?Ze:Qe)[n++]);return s(e.Va+t,3)},"%m":function(e){return s(e.Ta+1,2)},"%M":function(e){return s(e.sb,2)},"%n":function(){return"\n"},"%p":function(e){return 0<=e.Sa&&12>e.Sa?"AM":"PM"},"%S":function(e){return s(e.tb,2)},"%t":function(){return"\t"},"%u":function(e){return e.Ja||7},"%U":function(e){return s(Math.floor((e.Ma+7-e.Ja)/7),2)},"%V":function(e){var t=Math.floor((e.Ma+7-(e.Ja+6)%7)/7);if(2>=(e.Ja+371-e.Ma-2)%7&&t++,t)53==t&&(4==(n=(e.Ja+371-e.Ma)%7)||3==n&&Je(e.Na)||(t=1));else{t=52;var n=(e.Ja+7-e.Ma-1)%7;(4==n||5==n&&Je(e.Na%400-1))&&t++}return s(t,2)},"%w":function(e){return e.Ja},"%W":function(e){return s(Math.floor((e.Ma+7-(e.Ja+6)%7)/7),2)},"%y":function(e){return(e.Na+1900).toString().substring(2)},"%Y":function(e){return e.Na+1900},"%z":function(e){var t=0<=(e=e.rb);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.ub},"%%":function(){return"%"}},r=r.replace(/%%/g,"\0\0"),p)r.includes(d)&&(r=r.replace(new RegExp(d,"g"),p[d](i)));return d=function(e){var t=Array(z(e)+1);return V(e,t,0,t.length),t}(r=r.replace(/\0\0/g,"%")),d.length>n?0:(function(e,n){t().set(e,n>>>0)}(d,e),d.length-1)}pe.Ua();var tt=[null,le,fe,ye,_e,ve,xe,Te,Se,Oe,Ae,Ee,Ie,$e,Pe,De,ke,Me,Ne,Le,ze,He,We,qe,Ke,Ye],nt={b:function(e){return ot(e+24)+24},c:function(e,t,n){throw new be(e).Ua(t,n),e},L:function(e){it(e,!_,1,!w),pe.Za()},l:function(e){x?postMessage({cmd:"cleanupThread",thread:e}):se(e)},D:we,i:_e,R:ve,z:xe,B:Te,T:Se,P:Oe,I:Ae,O:Ee,p:Ie,A:$e,x:Pe,Q:De,y:ke,r:function(){},j:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},s:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},q:function(){return Date.now()},E:function(){return 2097152},V:function(){return!0},F:function(e,t,n,r){if(e==t)setTimeout((()=>Ce(r)));else if(x)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{if(!(e=pe.La[e]))return;e.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},K:function(){return-1},W:function(e,t){e=new Date(1e3*Re(e)),o()[t>>2>>>0]=e.getUTCSeconds(),o()[t+4>>2>>>0]=e.getUTCMinutes(),o()[t+8>>2>>>0]=e.getUTCHours(),o()[t+12>>2>>>0]=e.getUTCDate(),o()[t+16>>2>>>0]=e.getUTCMonth(),o()[t+20>>2>>>0]=e.getUTCFullYear()-1900,o()[t+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,o()[t+28>>2>>>0]=e},X:function(e,t){e=new Date(1e3*Re(e)),o()[t>>2>>>0]=e.getSeconds(),o()[t+4>>2>>>0]=e.getMinutes(),o()[t+8>>2>>>0]=e.getHours(),o()[t+12>>2>>>0]=e.getDate(),o()[t+16>>2>>>0]=e.getMonth(),o()[t+20>>2>>>0]=e.getFullYear()-1900,o()[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1),r=(e.getTime()-n.getTime())/864e5|0;o()[t+28>>2>>>0]=r,o()[t+36>>2>>>0]=-60*e.getTimezoneOffset(),r=new Date(e.getFullYear(),6,1).getTimezoneOffset(),e=0|(r!=(n=n.getTimezoneOffset())&&e.getTimezoneOffset()==Math.min(n,r)),o()[t+32>>2>>>0]=e},Y:function(e){var t=new Date(o()[e+20>>2>>>0]+1900,o()[e+16>>2>>>0],o()[e+12>>2>>>0],o()[e+8>>2>>>0],o()[e+4>>2>>>0],o()[e>>2>>>0],0),n=o()[e+32>>2>>>0],r=t.getTimezoneOffset(),i=new Date(t.getFullYear(),0,1),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),s=i.getTimezoneOffset(),u=Math.min(s,a);return 0>n?o()[e+32>>2>>>0]=Number(a!=s&&u==r):0<n!=(u==r)&&(a=Math.max(s,a),t.setTime(t.getTime()+6e4*((0<n?u:a)-r))),o()[e+24>>2>>>0]=t.getDay(),n=(t.getTime()-i.getTime())/864e5|0,o()[e+28>>2>>>0]=n,o()[e>>2>>>0]=t.getSeconds(),o()[e+4>>2>>>0]=t.getMinutes(),o()[e+8>>2>>>0]=t.getHours(),o()[e+12>>2>>>0]=t.getDate(),o()[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},G:Me,H:Ne,Z:function e(t,n,r){e.jb||(e.jb=!0,Le(t,n,r))},d:function(){ne("")},m:function(){if(!v&&!_){var e="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";he||(he={}),he[e]||(he[e]=1,v&&(e="warning: "+e),$(e))}},w:function(){return 4294901760},f:ge,S:function(e,t,n){r().copyWithin(e>>>0,t>>>0,t+n>>>0)},g:function(){return v?n(3993).cpus().length:navigator.hardwareConcurrency},J:function(e,t,n){Be.length=t,n>>=3;for(var r=0;r<t;r++)Be[r]=a()[n+r>>>0];return(0>e?ie[-e-1]:tt[e]).apply(null,Be)},v:function(e){var t=r().length;if((e>>>=0)<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var o=t*(1+.2/n);o=Math.min(o,e+100663296);var i=Math;o=Math.max(e,o),i=i.min.call(i,4294901760,o+(65536-o%65536)%65536);e:{try{D.grow(i-C.byteLength+65535>>>16),H(D.buffer);var a=1;break e}catch(e){}a=void 0}if(a)return!0}return!1},U:function(){throw"unwind"},M:ze,N:He,k:ce,h:We,o:qe,t:Ke,n:Ye,u:function e(r,o){e.Wa||(e.Wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(v)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>ne("randomDevice")}());for(var i=0;i<o;i++)t()[r+i>>0>>>0]=e.Wa();return 0},a:D||s.wasmMemory,C:et,e:function(e,t,n,r){return et(e,t,n,r)}};!function(){function e(e,t){s.asm=e.exports,pe.$a.push(s.asm.wa),q=s.asm.za,X.unshift(s.asm._),k=t,x||(Q--,s.monitorRunDependencies&&s.monitorRunDependencies(Q),0==Q&&(null!==ee&&(clearInterval(ee),ee=null),te&&(e=te,te=null,e())))}function t(t){e(t.instance,t.module)}function n(e){return function(){if(!E&&(w||_)){if("function"==typeof fetch&&!Z.startsWith("file://"))return fetch(Z,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+Z+"'";return e.arrayBuffer()})).catch((function(){return oe()}));if(p)return new Promise((function(e,t){p(Z,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return oe()}))}().then((function(e){return WebAssembly.instantiate(e,r)})).then((function(e){return e})).then(e,(function(e){$("failed to asynchronously prepare wasm: "+e),ne(e)}))}var r={a:nt};if(x||(Q++,s.monitorRunDependencies&&s.monitorRunDependencies(Q)),s.instantiateWasm)try{return s.instantiateWasm(r,e)}catch(e){return $("Module.instantiateWasm callback failed with error: "+e),!1}(E||"function"!=typeof WebAssembly.instantiateStreaming||re()||Z.startsWith("file://")||v||"function"!=typeof fetch?n(t):fetch(Z,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,r).then(t,(function(e){return $("wasm streaming compile failed: "+e),$("falling back to ArrayBuffer instantiation"),n(t)}))}))).catch(l)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm._).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.$).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.aa).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.ba).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.ca).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm.da).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.ea).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.fa).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.ga).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.ha).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm.ia).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.ja).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.ka).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.la).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.ma).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.na).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.oa).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.pa).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.qa).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.ra).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.sa).apply(null,arguments)};var rt=s._pthread_self=function(){return(rt=s._pthread_self=s.asm.ta).apply(null,arguments)},ot=s._malloc=function(){return(ot=s._malloc=s.asm.ua).apply(null,arguments)};s._free=function(){return(s._free=s.asm.va).apply(null,arguments)},s.__emscripten_tls_init=function(){return(s.__emscripten_tls_init=s.asm.wa).apply(null,arguments)};var it=s.__emscripten_thread_init=function(){return(it=s.__emscripten_thread_init=s.asm.xa).apply(null,arguments)};s.__emscripten_thread_crashed=function(){return(s.__emscripten_thread_crashed=s.asm.ya).apply(null,arguments)};var at,st=s._emscripten_run_in_main_runtime_thread_js=function(){return(st=s._emscripten_run_in_main_runtime_thread_js=s.asm.Aa).apply(null,arguments)},ut=s.__emscripten_proxy_execute_task_queue=function(){return(ut=s.__emscripten_proxy_execute_task_queue=s.asm.Ba).apply(null,arguments)},lt=s.__emscripten_thread_free_data=function(){return(lt=s.__emscripten_thread_free_data=s.asm.Ca).apply(null,arguments)},ct=s.__emscripten_thread_exit=function(){return(ct=s.__emscripten_thread_exit=s.asm.Da).apply(null,arguments)},pt=s._emscripten_stack_set_limits=function(){return(pt=s._emscripten_stack_set_limits=s.asm.Ea).apply(null,arguments)},dt=s.stackSave=function(){return(dt=s.stackSave=s.asm.Fa).apply(null,arguments)},ft=s.stackRestore=function(){return(ft=s.stackRestore=s.asm.Ga).apply(null,arguments)},ht=s.stackAlloc=function(){return(ht=s.stackAlloc=s.asm.Ha).apply(null,arguments)};function gt(){function e(){if(!at&&(at=!0,s.calledRun=!0,!j)&&(x||de(X),u(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!x)){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;){var e=s.postRun.shift();Y.unshift(e)}de(Y)}}if(!(0<Q))if(x)u(s),x||de(X),postMessage({cmd:"loaded"});else{if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)J();de(K),0<Q||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),e()}),1)):e())}}if(s.___cxa_is_pointer_type=function(){return(s.___cxa_is_pointer_type=s.asm.Ia).apply(null,arguments)},s.UTF8ToString=G,s.stringToUTF8=function(e,t,n){return V(e,r(),t,n)},s.lengthBytesUTF8=z,s.keepRuntimeAlive=function(){return P},s.wasmMemory=D,s.stackSave=dt,s.stackRestore=ft,s.stackAlloc=ht,s.ExitStatus=ae,s.PThread=pe,te=function e(){at||gt(),at||(te=e)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return gt(),e.ready});e.exports=r},932:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){var t,r,o;e=e||{},t||(t=void 0!==e?e:{}),t.ready=new Promise((function(e,t){r=e,o=t}));var i,a,s,u,l,c,p=Object.assign({},t),d="./this.program",f=(e,t)=>{throw t},h="object"==typeof window,g="function"==typeof importScripts,m="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,b="";m?(b=g?n(908).dirname(b)+"/":"//",c=()=>{l||(u=n(1384),l=n(908))},i=function(e,t){return c(),e=l.normalize(e),u.readFileSync(e,t?void 0:"utf8")},s=e=>((e=i(e,!0)).buffer||(e=new Uint8Array(e)),e),a=(e,t,n)=>{c(),e=l.normalize(e),u.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(d=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof q))throw e})),process.on("unhandledRejection",(function(e){throw e})),f=(e,t)=>{if(v)throw process.exitCode=e,t;t instanceof q||_("exiting due to exception: "+t),process.exit(e)},t.inspect=function(){return"[Emscripten Module object]"}):(h||g)&&(g?b=self.location.href:"undefined"!=typeof document&&document.currentScript&&(b=document.currentScript.src),_scriptDir&&(b=_scriptDir),b=0!==b.indexOf("blob:")?b.substr(0,b.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},g&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),a=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var y,w=t.print||console.log.bind(console),_=t.printErr||console.warn.bind(console);Object.assign(t,p),p=null,t.thisProgram&&(d=t.thisProgram),t.quit&&(f=t.quit),t.wasmBinary&&(y=t.wasmBinary);var v=t.noExitRuntime||!0;"object"!=typeof WebAssembly&&V("no native wasm support detected");var x,T,S,O,A,E,I=!1,$="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function P(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&$)return $.decode(e.subarray(t,n));for(r="";t<n;){var o=e[t++];if(128&o){var i=63&e[t++];if(192==(224&o))r+=String.fromCharCode((31&o)<<6|i);else{var a=63&e[t++];65536>(o=224==(240&o)?(15&o)<<12|i<<6|a:(7&o)<<18|i<<12|a<<6|63&e[t++])?r+=String.fromCharCode(o):(o-=65536,r+=String.fromCharCode(55296|o>>10,56320|1023&o))}}else r+=String.fromCharCode(o)}return r}function D(e,t){return(e>>>=0)?P(O,e,t):""}function k(e,t,n,r){if(!(0<r))return 0;var o=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var a=e.charCodeAt(i);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&e.charCodeAt(++i)),127>=a){if(n>=r)break;t[n++>>>0]=a}else{if(2047>=a){if(n+1>=r)break;t[n++>>>0]=192|a>>6}else{if(65535>=a){if(n+2>=r)break;t[n++>>>0]=224|a>>12}else{if(n+3>=r)break;t[n++>>>0]=240|a>>18,t[n++>>>0]=128|a>>12&63}t[n++>>>0]=128|a>>6&63}t[n++>>>0]=128|63&a}}return t[n>>>0]=0,n-o}function C(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function R(){var e=x.buffer;T=e,t.HEAP8=S=new Int8Array(e),t.HEAP16=new Int16Array(e),t.HEAP32=A=new Int32Array(e),t.HEAPU8=O=new Uint8Array(e),t.HEAPU16=new Uint16Array(e),t.HEAPU32=E=new Uint32Array(e),t.HEAPF32=new Float32Array(e),t.HEAPF64=new Float64Array(e)}var M=[],N=[],F=[];function L(){var e=t.preRun.shift();M.unshift(e)}var j,U=0,B=null,G=null;function V(e){throw t.onAbort&&t.onAbort(e),_(e="Aborted("+e+")"),I=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),o(e),e}function z(){return j.startsWith("data:application/octet-stream;base64,")}if(j="ort-wasm.wasm",!z()){var H=j;j=t.locateFile?t.locateFile(H,b):b+H}function W(){var e=j;try{if(e==j&&y)return new Uint8Array(y);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}catch(e){V(e)}}function q(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function K(e){for(;0<e.length;)e.shift()(t)}function X(e){this.sa=e-24,this.Ia=function(e){E[this.sa+4>>2>>>0]=e},this.Ba=function(e){E[this.sa+8>>2>>>0]=e},this.Ga=function(){A[this.sa>>2>>>0]=0},this.Aa=function(){S[this.sa+12>>0>>>0]=0},this.Ha=function(){S[this.sa+13>>0>>>0]=0},this.ya=function(e,t){this.za(),this.Ia(e),this.Ba(t),this.Ga(),this.Aa(),this.Ha()},this.za=function(){E[this.sa+16>>2>>>0]=0}}function Y(e){var t=C(e)+1,n=ae(t);return n&&k(e,S,n,t),n}var J={};function Z(){if(!Q){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:d||"./this.program"};for(e in J)void 0===J[e]?delete t[e]:t[e]=J[e];var n=[];for(e in t)n.push(e+"="+t[e]);Q=n}return Q}var Q,ee=[null,[],[]];function te(e){return 0==e%4&&(0!=e%100||0==e%400)}var ne=[31,29,31,30,31,30,31,31,30,31,30,31],re=[31,28,31,30,31,30,31,31,30,31,30,31];function oe(e,t,n,r){function o(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function i(e,t){return o(e,t,"0")}function a(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.qa;for(e=new Date(new Date(e.ra+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(te(e.getFullYear())?ne:re)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=a(t,e)?0>=a(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var l=A[r+40>>2>>>0];for(var c in r={Ea:A[r>>2>>>0],Da:A[r+4>>2>>>0],ta:A[r+8>>2>>>0],va:A[r+12>>2>>>0],ua:A[r+16>>2>>>0],ra:A[r+20>>2>>>0],la:A[r+24>>2>>>0],qa:A[r+28>>2>>>0],Ja:A[r+32>>2>>>0],Ca:A[r+36>>2>>>0],Fa:l?D(l):""},n=D(n),l={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(c,"g"),l[c]);var p="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(c in l={"%a":function(e){return p[e.la].substring(0,3)},"%A":function(e){return p[e.la]},"%b":function(e){return d[e.ua].substring(0,3)},"%B":function(e){return d[e.ua]},"%C":function(e){return i((e.ra+1900)/100|0,2)},"%d":function(e){return i(e.va,2)},"%e":function(e){return o(e.va,2," ")},"%g":function(e){return u(e).toString().substring(2)},"%G":function(e){return u(e)},"%H":function(e){return i(e.ta,2)},"%I":function(e){return 0==(e=e.ta)?e=12:12<e&&(e-=12),i(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.ua-1;t+=(te(e.ra+1900)?ne:re)[n++]);return i(e.va+t,3)},"%m":function(e){return i(e.ua+1,2)},"%M":function(e){return i(e.Da,2)},"%n":function(){return"\n"},"%p":function(e){return 0<=e.ta&&12>e.ta?"AM":"PM"},"%S":function(e){return i(e.Ea,2)},"%t":function(){return"\t"},"%u":function(e){return e.la||7},"%U":function(e){return i(Math.floor((e.qa+7-e.la)/7),2)},"%V":function(e){var t=Math.floor((e.qa+7-(e.la+6)%7)/7);if(2>=(e.la+371-e.qa-2)%7&&t++,t)53==t&&(4==(n=(e.la+371-e.qa)%7)||3==n&&te(e.ra)||(t=1));else{t=52;var n=(e.la+7-e.qa-1)%7;(4==n||5==n&&te(e.ra%400-1))&&t++}return i(t,2)},"%w":function(e){return e.la},"%W":function(e){return i(Math.floor((e.qa+7-(e.la+6)%7)/7),2)},"%y":function(e){return(e.ra+1900).toString().substring(2)},"%Y":function(e){return e.ra+1900},"%z":function(e){var t=0<=(e=e.Ca);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.Fa},"%%":function(){return"%"}},n=n.replace(/%%/g,"\0\0"),l)n.includes(c)&&(n=n.replace(new RegExp(c,"g"),l[c](r)));return c=function(e){var t=Array(C(e)+1);return k(e,t,0,t.length),t}(n=n.replace(/\0\0/g,"%")),c.length>t?0:(S.set(c,e>>>0),c.length-1)}var ie={a:function(e){return ae(e+24)+24},b:function(e,t,n){throw new X(e).ya(t,n),e},g:function(){return 0},I:function(){},w:function(){},y:function(){},K:function(){return 0},G:function(){},C:function(){},F:function(){},k:function(){},x:function(){},u:function(){},H:function(){},v:function(){},n:function(){},p:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},o:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},l:function(){return Date.now()},L:function(){return!0},M:function(e,t){e=new Date(1e3*(E[e>>>2]+4294967296*A[e+4>>>2])),A[t>>2>>>0]=e.getUTCSeconds(),A[t+4>>2>>>0]=e.getUTCMinutes(),A[t+8>>2>>>0]=e.getUTCHours(),A[t+12>>2>>>0]=e.getUTCDate(),A[t+16>>2>>>0]=e.getUTCMonth(),A[t+20>>2>>>0]=e.getUTCFullYear()-1900,A[t+24>>2>>>0]=e.getUTCDay(),A[t+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},N:function(e,t){e=new Date(1e3*(E[e>>>2]+4294967296*A[e+4>>>2])),A[t>>2>>>0]=e.getSeconds(),A[t+4>>2>>>0]=e.getMinutes(),A[t+8>>2>>>0]=e.getHours(),A[t+12>>2>>>0]=e.getDate(),A[t+16>>2>>>0]=e.getMonth(),A[t+20>>2>>>0]=e.getFullYear()-1900,A[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1);A[t+28>>2>>>0]=(e.getTime()-n.getTime())/864e5|0,A[t+36>>2>>>0]=-60*e.getTimezoneOffset();var r=new Date(e.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),A[t+32>>2>>>0]=0|(r!=n&&e.getTimezoneOffset()==Math.min(n,r))},O:function(e){var t=new Date(A[e+20>>2>>>0]+1900,A[e+16>>2>>>0],A[e+12>>2>>>0],A[e+8>>2>>>0],A[e+4>>2>>>0],A[e>>2>>>0],0),n=A[e+32>>2>>>0],r=t.getTimezoneOffset(),o=new Date(t.getFullYear(),0,1),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),a=o.getTimezoneOffset(),s=Math.min(a,i);return 0>n?A[e+32>>2>>>0]=Number(i!=a&&s==r):0<n!=(s==r)&&(i=Math.max(a,i),t.setTime(t.getTime()+6e4*((0<n?s:i)-r))),A[e+24>>2>>>0]=t.getDay(),A[e+28>>2>>>0]=(t.getTime()-o.getTime())/864e5|0,A[e>>2>>>0]=t.getSeconds(),A[e+4>>2>>>0]=t.getMinutes(),A[e+8>>2>>>0]=t.getHours(),A[e+12>>2>>>0]=t.getDate(),A[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},z:function(){return-52},B:function(){},m:function e(t,n,r){e.xa||(e.xa=!0,function(e,t,n){function r(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}var o=(new Date).getFullYear(),i=new Date(o,0,1),a=new Date(o,6,1);o=i.getTimezoneOffset();var s=a.getTimezoneOffset();A[e>>2>>>0]=60*Math.max(o,s),A[t>>2>>>0]=Number(o!=s),e=r(i),t=r(a),e=Y(e),t=Y(t),s<o?(E[n>>2>>>0]=e,E[n+4>>2>>>0]=t):(E[n>>2>>>0]=t,E[n+4>>2>>>0]=e)}(t,n,r))},d:function(){V("")},t:function(){return 4294901760},h:m?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.now(),J:function(e,t,n){O.copyWithin(e>>>0,t>>>0,t+n>>>0)},f:function(e){var t=O.length;if(4294901760<(e>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var o=Math;r=Math.max(e,r),o=o.min.call(o,4294901760,r+(65536-r%65536)%65536);e:{try{x.grow(o-T.byteLength+65535>>>16),R();var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},D:function(e,t){var n=0;return Z().forEach((function(r,o){var i=t+n;for(o=E[e+4*o>>2>>>0]=i,i=0;i<r.length;++i)S[o++>>0>>>0]=r.charCodeAt(i);S[o>>0>>>0]=0,n+=r.length+1})),0},E:function(e,t){var n=Z();E[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),E[t>>2>>>0]=r,0},r:function(e){v||(t.onExit&&t.onExit(e),I=!0),f(e,new q(e))},e:function(){return 52},j:function(){return 52},q:function(){return 70},i:function(e,t,n,r){for(var o=0,i=0;i<n;i++){var a=E[t>>2>>>0],s=E[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var l=O[a+u>>>0],c=ee[e];0===l||10===l?((1===e?w:_)(P(c,0)),c.length=0):c.push(l)}o+=s}return E[r>>2>>>0]=o,0},s:function e(t,r){e.wa||(e.wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(m)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>V("randomDevice")}());for(var o=0;o<r;o++)S[t+o>>0>>>0]=e.wa();return 0},A:oe,c:function(e,t,n,r){return oe(e,t,n,r)}};!function(){function e(e){t.asm=e.exports,x=t.asm.P,R(),N.unshift(t.asm.Q),U--,t.monitorRunDependencies&&t.monitorRunDependencies(U),0==U&&(null!==B&&(clearInterval(B),B=null),G&&(e=G,G=null,e()))}function n(t){e(t.instance)}function r(e){return function(){if(!y&&(h||g)){if("function"==typeof fetch&&!j.startsWith("file://"))return fetch(j,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+j+"'";return e.arrayBuffer()})).catch((function(){return W()}));if(a)return new Promise((function(e,t){a(j,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return W()}))}().then((function(e){return WebAssembly.instantiate(e,i)})).then((function(e){return e})).then(e,(function(e){_("failed to asynchronously prepare wasm: "+e),V(e)}))}var i={a:ie};if(U++,t.monitorRunDependencies&&t.monitorRunDependencies(U),t.instantiateWasm)try{return t.instantiateWasm(i,e)}catch(e){return _("Module.instantiateWasm callback failed with error: "+e),!1}(y||"function"!=typeof WebAssembly.instantiateStreaming||z()||j.startsWith("file://")||m||"function"!=typeof fetch?r(n):fetch(j,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,i).then(n,(function(e){return _("wasm streaming compile failed: "+e),_("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(o)}(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm.Q).apply(null,arguments)},t._OrtInit=function(){return(t._OrtInit=t.asm.R).apply(null,arguments)},t._OrtCreateSessionOptions=function(){return(t._OrtCreateSessionOptions=t.asm.S).apply(null,arguments)},t._OrtAppendExecutionProvider=function(){return(t._OrtAppendExecutionProvider=t.asm.T).apply(null,arguments)},t._OrtAddSessionConfigEntry=function(){return(t._OrtAddSessionConfigEntry=t.asm.U).apply(null,arguments)},t._OrtReleaseSessionOptions=function(){return(t._OrtReleaseSessionOptions=t.asm.V).apply(null,arguments)},t._OrtCreateSession=function(){return(t._OrtCreateSession=t.asm.W).apply(null,arguments)},t._OrtReleaseSession=function(){return(t._OrtReleaseSession=t.asm.X).apply(null,arguments)},t._OrtGetInputCount=function(){return(t._OrtGetInputCount=t.asm.Y).apply(null,arguments)},t._OrtGetOutputCount=function(){return(t._OrtGetOutputCount=t.asm.Z).apply(null,arguments)},t._OrtGetInputName=function(){return(t._OrtGetInputName=t.asm._).apply(null,arguments)},t._OrtGetOutputName=function(){return(t._OrtGetOutputName=t.asm.$).apply(null,arguments)},t._OrtFree=function(){return(t._OrtFree=t.asm.aa).apply(null,arguments)},t._OrtCreateTensor=function(){return(t._OrtCreateTensor=t.asm.ba).apply(null,arguments)},t._OrtGetTensorData=function(){return(t._OrtGetTensorData=t.asm.ca).apply(null,arguments)},t._OrtReleaseTensor=function(){return(t._OrtReleaseTensor=t.asm.da).apply(null,arguments)},t._OrtCreateRunOptions=function(){return(t._OrtCreateRunOptions=t.asm.ea).apply(null,arguments)},t._OrtAddRunConfigEntry=function(){return(t._OrtAddRunConfigEntry=t.asm.fa).apply(null,arguments)},t._OrtReleaseRunOptions=function(){return(t._OrtReleaseRunOptions=t.asm.ga).apply(null,arguments)},t._OrtRun=function(){return(t._OrtRun=t.asm.ha).apply(null,arguments)},t._OrtEndProfiling=function(){return(t._OrtEndProfiling=t.asm.ia).apply(null,arguments)};var ae=t._malloc=function(){return(ae=t._malloc=t.asm.ja).apply(null,arguments)};t._free=function(){return(t._free=t.asm.ka).apply(null,arguments)};var se,ue=t.stackSave=function(){return(ue=t.stackSave=t.asm.ma).apply(null,arguments)},le=t.stackRestore=function(){return(le=t.stackRestore=t.asm.na).apply(null,arguments)},ce=t.stackAlloc=function(){return(ce=t.stackAlloc=t.asm.oa).apply(null,arguments)};function pe(){function e(){if(!se&&(se=!0,t.calledRun=!0,!I)){if(K(N),r(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;){var e=t.postRun.shift();F.unshift(e)}K(F)}}if(!(0<U)){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)L();K(M),0<U||(t.setStatus?(t.setStatus("Running..."),setTimeout((function(){setTimeout((function(){t.setStatus("")}),1),e()}),1)):e())}}if(t.___cxa_is_pointer_type=function(){return(t.___cxa_is_pointer_type=t.asm.pa).apply(null,arguments)},t.UTF8ToString=D,t.stringToUTF8=function(e,t,n){return k(e,O,t,n)},t.lengthBytesUTF8=C,t.stackSave=ue,t.stackRestore=le,t.stackAlloc=ce,G=function e(){se||pe(),se||(G=e)},t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return pe(),e.ready});e.exports=r},4537:e=>{"use strict";e.exports=function(e,t){for(var n=new Array(arguments.length-1),r=0,o=2,i=!0;o<arguments.length;)n[r++]=arguments[o++];return new Promise((function(o,a){n[r]=function(e){if(i)if(i=!1,e)a(e);else{for(var t=new Array(arguments.length-1),n=0;n<t.length;)t[n++]=arguments[n];o.apply(null,t)}};try{e.apply(t||null,n)}catch(e){i&&(i=!1,a(e))}}))}},7419:(e,t)=>{"use strict";var n=t;n.length=function(e){var t=e.length;if(!t)return 0;for(var n=0;--t%4>1&&"="===e.charAt(t);)++n;return Math.ceil(3*e.length)/4-n};for(var r=new Array(64),o=new Array(123),i=0;i<64;)o[r[i]=i<26?i+65:i<52?i+71:i<62?i-4:i-59|43]=i++;n.encode=function(e,t,n){for(var o,i=null,a=[],s=0,u=0;t<n;){var l=e[t++];switch(u){case 0:a[s++]=r[l>>2],o=(3&l)<<4,u=1;break;case 1:a[s++]=r[o|l>>4],o=(15&l)<<2,u=2;break;case 2:a[s++]=r[o|l>>6],a[s++]=r[63&l],u=0}s>8191&&((i||(i=[])).push(String.fromCharCode.apply(String,a)),s=0)}return u&&(a[s++]=r[o],a[s++]=61,1===u&&(a[s++]=61)),i?(s&&i.push(String.fromCharCode.apply(String,a.slice(0,s))),i.join("")):String.fromCharCode.apply(String,a.slice(0,s))};var a="invalid encoding";n.decode=function(e,t,n){for(var r,i=n,s=0,u=0;u<e.length;){var l=e.charCodeAt(u++);if(61===l&&s>1)break;if(void 0===(l=o[l]))throw Error(a);switch(s){case 0:r=l,s=1;break;case 1:t[n++]=r<<2|(48&l)>>4,r=l,s=2;break;case 2:t[n++]=(15&r)<<4|(60&l)>>2,r=l,s=3;break;case 3:t[n++]=(3&r)<<6|l,s=0}}if(1===s)throw Error(a);return n-i},n.test=function(e){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)}},9211:e=>{"use strict";function t(){this._listeners={}}e.exports=t,t.prototype.on=function(e,t,n){return(this._listeners[e]||(this._listeners[e]=[])).push({fn:t,ctx:n||this}),this},t.prototype.off=function(e,t){if(void 0===e)this._listeners={};else if(void 0===t)this._listeners[e]=[];else for(var n=this._listeners[e],r=0;r<n.length;)n[r].fn===t?n.splice(r,1):++r;return this},t.prototype.emit=function(e){var t=this._listeners[e];if(t){for(var n=[],r=1;r<arguments.length;)n.push(arguments[r++]);for(r=0;r<t.length;)t[r].fn.apply(t[r++].ctx,n)}return this}},945:e=>{"use strict";function t(e){return"undefined"!=typeof Float32Array?function(){var t=new Float32Array([-0]),n=new Uint8Array(t.buffer),r=128===n[3];function o(e,r,o){t[0]=e,r[o]=n[0],r[o+1]=n[1],r[o+2]=n[2],r[o+3]=n[3]}function i(e,r,o){t[0]=e,r[o]=n[3],r[o+1]=n[2],r[o+2]=n[1],r[o+3]=n[0]}function a(e,r){return n[0]=e[r],n[1]=e[r+1],n[2]=e[r+2],n[3]=e[r+3],t[0]}function s(e,r){return n[3]=e[r],n[2]=e[r+1],n[1]=e[r+2],n[0]=e[r+3],t[0]}e.writeFloatLE=r?o:i,e.writeFloatBE=r?i:o,e.readFloatLE=r?a:s,e.readFloatBE=r?s:a}():function(){function t(e,t,n,r){var o=t<0?1:0;if(o&&(t=-t),0===t)e(1/t>0?0:2147483648,n,r);else if(isNaN(t))e(2143289344,n,r);else if(t>34028234663852886e22)e((o<<31|2139095040)>>>0,n,r);else if(t<11754943508222875e-54)e((o<<31|Math.round(t/1401298464324817e-60))>>>0,n,r);else{var i=Math.floor(Math.log(t)/Math.LN2);e((o<<31|i+127<<23|8388607&Math.round(t*Math.pow(2,-i)*8388608))>>>0,n,r)}}function a(e,t,n){var r=e(t,n),o=2*(r>>31)+1,i=r>>>23&255,a=8388607&r;return 255===i?a?NaN:o*(1/0):0===i?1401298464324817e-60*o*a:o*Math.pow(2,i-150)*(a+8388608)}e.writeFloatLE=t.bind(null,n),e.writeFloatBE=t.bind(null,r),e.readFloatLE=a.bind(null,o),e.readFloatBE=a.bind(null,i)}(),"undefined"!=typeof Float64Array?function(){var t=new Float64Array([-0]),n=new Uint8Array(t.buffer),r=128===n[7];function o(e,r,o){t[0]=e,r[o]=n[0],r[o+1]=n[1],r[o+2]=n[2],r[o+3]=n[3],r[o+4]=n[4],r[o+5]=n[5],r[o+6]=n[6],r[o+7]=n[7]}function i(e,r,o){t[0]=e,r[o]=n[7],r[o+1]=n[6],r[o+2]=n[5],r[o+3]=n[4],r[o+4]=n[3],r[o+5]=n[2],r[o+6]=n[1],r[o+7]=n[0]}function a(e,r){return n[0]=e[r],n[1]=e[r+1],n[2]=e[r+2],n[3]=e[r+3],n[4]=e[r+4],n[5]=e[r+5],n[6]=e[r+6],n[7]=e[r+7],t[0]}function s(e,r){return n[7]=e[r],n[6]=e[r+1],n[5]=e[r+2],n[4]=e[r+3],n[3]=e[r+4],n[2]=e[r+5],n[1]=e[r+6],n[0]=e[r+7],t[0]}e.writeDoubleLE=r?o:i,e.writeDoubleBE=r?i:o,e.readDoubleLE=r?a:s,e.readDoubleBE=r?s:a}():function(){function t(e,t,n,r,o,i){var a=r<0?1:0;if(a&&(r=-r),0===r)e(0,o,i+t),e(1/r>0?0:2147483648,o,i+n);else if(isNaN(r))e(0,o,i+t),e(2146959360,o,i+n);else if(r>17976931348623157e292)e(0,o,i+t),e((a<<31|2146435072)>>>0,o,i+n);else{var s;if(r<22250738585072014e-324)e((s=r/5e-324)>>>0,o,i+t),e((a<<31|s/4294967296)>>>0,o,i+n);else{var u=Math.floor(Math.log(r)/Math.LN2);1024===u&&(u=1023),e(4503599627370496*(s=r*Math.pow(2,-u))>>>0,o,i+t),e((a<<31|u+1023<<20|1048576*s&1048575)>>>0,o,i+n)}}}function a(e,t,n,r,o){var i=e(r,o+t),a=e(r,o+n),s=2*(a>>31)+1,u=a>>>20&2047,l=4294967296*(1048575&a)+i;return 2047===u?l?NaN:s*(1/0):0===u?5e-324*s*l:s*Math.pow(2,u-1075)*(l+4503599627370496)}e.writeDoubleLE=t.bind(null,n,0,4),e.writeDoubleBE=t.bind(null,r,4,0),e.readDoubleLE=a.bind(null,o,0,4),e.readDoubleBE=a.bind(null,i,4,0)}(),e}function n(e,t,n){t[n]=255&e,t[n+1]=e>>>8&255,t[n+2]=e>>>16&255,t[n+3]=e>>>24}function r(e,t,n){t[n]=e>>>24,t[n+1]=e>>>16&255,t[n+2]=e>>>8&255,t[n+3]=255&e}function o(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0}function i(e,t){return(e[t]<<24|e[t+1]<<16|e[t+2]<<8|e[t+3])>>>0}e.exports=t(t)},7199:module=>{"use strict";function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(e){}return null}module.exports=inquire},6662:e=>{"use strict";e.exports=function(e,t,n){var r=n||8192,o=r>>>1,i=null,a=r;return function(n){if(n<1||n>o)return e(n);a+n>r&&(i=e(r),a=0);var s=t.call(i,a,a+=n);return 7&a&&(a=1+(7|a)),s}}},4997:(e,t)=>{"use strict";var n=t;n.length=function(e){for(var t=0,n=0,r=0;r<e.length;++r)(n=e.charCodeAt(r))<128?t+=1:n<2048?t+=2:55296==(64512&n)&&56320==(64512&e.charCodeAt(r+1))?(++r,t+=4):t+=3;return t},n.read=function(e,t,n){if(n-t<1)return"";for(var r,o=null,i=[],a=0;t<n;)(r=e[t++])<128?i[a++]=r:r>191&&r<224?i[a++]=(31&r)<<6|63&e[t++]:r>239&&r<365?(r=((7&r)<<18|(63&e[t++])<<12|(63&e[t++])<<6|63&e[t++])-65536,i[a++]=55296+(r>>10),i[a++]=56320+(1023&r)):i[a++]=(15&r)<<12|(63&e[t++])<<6|63&e[t++],a>8191&&((o||(o=[])).push(String.fromCharCode.apply(String,i)),a=0);return o?(a&&o.push(String.fromCharCode.apply(String,i.slice(0,a))),o.join("")):String.fromCharCode.apply(String,i.slice(0,a))},n.write=function(e,t,n){for(var r,o,i=n,a=0;a<e.length;++a)(r=e.charCodeAt(a))<128?t[n++]=r:r<2048?(t[n++]=r>>6|192,t[n++]=63&r|128):55296==(64512&r)&&56320==(64512&(o=e.charCodeAt(a+1)))?(r=65536+((1023&r)<<10)+(1023&o),++a,t[n++]=r>>18|240,t[n++]=r>>12&63|128,t[n++]=r>>6&63|128,t[n++]=63&r|128):(t[n++]=r>>12|224,t[n++]=r>>6&63|128,t[n++]=63&r|128);return n-i}},3442:(e,t)=>{"use strict";t.__esModule=!0;var n=function(){function e(t){if(!t)throw new TypeError("Invalid argument; `value` has no value.");this.value=e.EMPTY,t&&e.isGuid(t)&&(this.value=t)}return e.isGuid=function(t){var n=t.toString();return t&&(t instanceof e||e.validator.test(n))},e.create=function(){return new e([e.gen(2),e.gen(1),e.gen(1),e.gen(1),e.gen(3)].join("-"))},e.createEmpty=function(){return new e("emptyguid")},e.parse=function(t){return new e(t)},e.raw=function(){return[e.gen(2),e.gen(1),e.gen(1),e.gen(1),e.gen(3)].join("-")},e.gen=function(e){for(var t="",n=0;n<e;n++)t+=(65536*(1+Math.random())|0).toString(16).substring(1);return t},e.prototype.equals=function(t){return e.isGuid(t)&&this.value===t.toString()},e.prototype.isEmpty=function(){return this.value===e.EMPTY},e.prototype.toString=function(){return this.value},e.prototype.toJSON=function(){return{value:this.value}},e.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),e.EMPTY="00000000-0000-0000-0000-000000000000",e}();t.Guid=n},3720:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var o={},i={};function a(e,t){var n,r,a;return t?(a=0<=(e>>>=0)&&e<256)&&(r=i[e])?r:(n=u(e,(0|e)<0?-1:0,!0),a&&(i[e]=n),n):(a=-128<=(e|=0)&&e<128)&&(r=o[e])?r:(n=u(e,e<0?-1:0,!1),a&&(o[e]=n),n)}function s(e,t){if(isNaN(e))return t?b:m;if(t){if(e<0)return b;if(e>=f)return x}else{if(e<=-h)return T;if(e+1>=h)return v}return e<0?s(-e,t).neg():u(e%d|0,e/d|0,t)}function u(e,t,r){return new n(e,t,r)}n.fromInt=a,n.fromNumber=s,n.fromBits=u;var l=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return m;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var o=s(l(n,8)),i=m,a=0;a<e.length;a+=8){var u=Math.min(8,e.length-a),p=parseInt(e.substring(a,a+u),n);if(u<8){var d=s(l(n,u));i=i.mul(d).add(s(p))}else i=(i=i.mul(o)).add(s(p))}return i.unsigned=t,i}function p(e,t){return"number"==typeof e?s(e,t):"string"==typeof e?c(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=p;var d=4294967296,f=d*d,h=f/2,g=a(1<<24),m=a(0);n.ZERO=m;var b=a(0,!0);n.UZERO=b;var y=a(1);n.ONE=y;var w=a(1,!0);n.UONE=w;var _=a(-1);n.NEG_ONE=_;var v=u(-1,2147483647,!1);n.MAX_VALUE=v;var x=u(-1,-1,!0);n.MAX_UNSIGNED_VALUE=x;var T=u(0,-2147483648,!1);n.MIN_VALUE=T;var S=n.prototype;S.toInt=function(){return this.unsigned?this.low>>>0:this.low},S.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},S.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(T)){var t=s(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var o=s(l(e,6),this.unsigned),i=this,a="";;){var u=i.div(o),c=(i.sub(u.mul(o)).toInt()>>>0).toString(e);if((i=u).isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}},S.getHighBits=function(){return this.high},S.getHighBitsUnsigned=function(){return this.high>>>0},S.getLowBits=function(){return this.low},S.getLowBitsUnsigned=function(){return this.low>>>0},S.getNumBitsAbs=function(){if(this.isNegative())return this.eq(T)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},S.isZero=function(){return 0===this.high&&0===this.low},S.eqz=S.isZero,S.isNegative=function(){return!this.unsigned&&this.high<0},S.isPositive=function(){return this.unsigned||this.high>=0},S.isOdd=function(){return 1==(1&this.low)},S.isEven=function(){return 0==(1&this.low)},S.equals=function(e){return r(e)||(e=p(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},S.eq=S.equals,S.notEquals=function(e){return!this.eq(e)},S.neq=S.notEquals,S.ne=S.notEquals,S.lessThan=function(e){return this.comp(e)<0},S.lt=S.lessThan,S.lessThanOrEqual=function(e){return this.comp(e)<=0},S.lte=S.lessThanOrEqual,S.le=S.lessThanOrEqual,S.greaterThan=function(e){return this.comp(e)>0},S.gt=S.greaterThan,S.greaterThanOrEqual=function(e){return this.comp(e)>=0},S.gte=S.greaterThanOrEqual,S.ge=S.greaterThanOrEqual,S.compare=function(e){if(r(e)||(e=p(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},S.comp=S.compare,S.negate=function(){return!this.unsigned&&this.eq(T)?T:this.not().add(y)},S.neg=S.negate,S.add=function(e){r(e)||(e=p(e));var t=this.high>>>16,n=65535&this.high,o=this.low>>>16,i=65535&this.low,a=e.high>>>16,s=65535&e.high,l=e.low>>>16,c=0,d=0,f=0,h=0;return f+=(h+=i+(65535&e.low))>>>16,d+=(f+=o+l)>>>16,c+=(d+=n+s)>>>16,c+=t+a,u((f&=65535)<<16|(h&=65535),(c&=65535)<<16|(d&=65535),this.unsigned)},S.subtract=function(e){return r(e)||(e=p(e)),this.add(e.neg())},S.sub=S.subtract,S.multiply=function(e){if(this.isZero())return m;if(r(e)||(e=p(e)),t)return u(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return m;if(this.eq(T))return e.isOdd()?T:m;if(e.eq(T))return this.isOdd()?T:m;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(g)&&e.lt(g))return s(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,o=65535&this.high,i=this.low>>>16,a=65535&this.low,l=e.high>>>16,c=65535&e.high,d=e.low>>>16,f=65535&e.low,h=0,b=0,y=0,w=0;return y+=(w+=a*f)>>>16,b+=(y+=i*f)>>>16,y&=65535,b+=(y+=a*d)>>>16,h+=(b+=o*f)>>>16,b&=65535,h+=(b+=i*d)>>>16,b&=65535,h+=(b+=a*c)>>>16,h+=n*f+o*d+i*c+a*l,u((y&=65535)<<16|(w&=65535),(h&=65535)<<16|(b&=65535),this.unsigned)},S.mul=S.multiply,S.divide=function(e){if(r(e)||(e=p(e)),e.isZero())throw Error("division by zero");var n,o,i;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:m;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return w;i=b}else{if(this.eq(T))return e.eq(y)||e.eq(_)?T:e.eq(T)?y:(n=this.shr(1).div(e).shl(1)).eq(m)?e.isNegative()?y:_:(o=this.sub(e.mul(n)),i=n.add(o.div(e)));if(e.eq(T))return this.unsigned?b:m;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=m}for(o=this;o.gte(e);){n=Math.max(1,Math.floor(o.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),c=a<=48?1:l(2,a-48),d=s(n),f=d.mul(e);f.isNegative()||f.gt(o);)f=(d=s(n-=c,this.unsigned)).mul(e);d.isZero()&&(d=y),i=i.add(d),o=o.sub(f)}return i},S.div=S.divide,S.modulo=function(e){return r(e)||(e=p(e)),t?u((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},S.mod=S.modulo,S.rem=S.modulo,S.not=function(){return u(~this.low,~this.high,this.unsigned)},S.and=function(e){return r(e)||(e=p(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},S.or=function(e){return r(e)||(e=p(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},S.xor=function(e){return r(e)||(e=p(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},S.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},S.shl=S.shiftLeft,S.shiftRight=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},S.shr=S.shiftRight,S.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},S.shru=S.shiftRightUnsigned,S.shr_u=S.shiftRightUnsigned,S.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},S.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},S.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},S.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},S.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},1446:(e,t,n)=>{"use strict";var r,o,i,a=n(2100),s=a.Reader,u=a.Writer,l=a.util,c=a.roots.default||(a.roots.default={});c.onnx=((i={}).Version=(r={},(o=Object.create(r))[r[0]="_START_VERSION"]=0,o[r[1]="IR_VERSION_2017_10_10"]=1,o[r[2]="IR_VERSION_2017_10_30"]=2,o[r[3]="IR_VERSION_2017_11_3"]=3,o[r[4]="IR_VERSION_2019_1_22"]=4,o[r[5]="IR_VERSION"]=5,o),i.AttributeProto=function(){function e(e){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.name="",e.prototype.refAttrName="",e.prototype.docString="",e.prototype.type=0,e.prototype.f=0,e.prototype.i=l.Long?l.Long.fromBits(0,0,!1):0,e.prototype.s=l.newBuffer([]),e.prototype.t=null,e.prototype.g=null,e.prototype.floats=l.emptyArray,e.prototype.ints=l.emptyArray,e.prototype.strings=l.emptyArray,e.prototype.tensors=l.emptyArray,e.prototype.graphs=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.name&&e.hasOwnProperty("name")&&t.uint32(10).string(e.name),null!=e.f&&e.hasOwnProperty("f")&&t.uint32(21).float(e.f),null!=e.i&&e.hasOwnProperty("i")&&t.uint32(24).int64(e.i),null!=e.s&&e.hasOwnProperty("s")&&t.uint32(34).bytes(e.s),null!=e.t&&e.hasOwnProperty("t")&&c.onnx.TensorProto.encode(e.t,t.uint32(42).fork()).ldelim(),null!=e.g&&e.hasOwnProperty("g")&&c.onnx.GraphProto.encode(e.g,t.uint32(50).fork()).ldelim(),null!=e.floats&&e.floats.length){t.uint32(58).fork();for(var n=0;n<e.floats.length;++n)t.float(e.floats[n]);t.ldelim()}if(null!=e.ints&&e.ints.length){for(t.uint32(66).fork(),n=0;n<e.ints.length;++n)t.int64(e.ints[n]);t.ldelim()}if(null!=e.strings&&e.strings.length)for(n=0;n<e.strings.length;++n)t.uint32(74).bytes(e.strings[n]);if(null!=e.tensors&&e.tensors.length)for(n=0;n<e.tensors.length;++n)c.onnx.TensorProto.encode(e.tensors[n],t.uint32(82).fork()).ldelim();if(null!=e.graphs&&e.graphs.length)for(n=0;n<e.graphs.length;++n)c.onnx.GraphProto.encode(e.graphs[n],t.uint32(90).fork()).ldelim();return null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(106).string(e.docString),null!=e.type&&e.hasOwnProperty("type")&&t.uint32(160).int32(e.type),null!=e.refAttrName&&e.hasOwnProperty("refAttrName")&&t.uint32(170).string(e.refAttrName),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.AttributeProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.name=e.string();break;case 21:r.refAttrName=e.string();break;case 13:r.docString=e.string();break;case 20:r.type=e.int32();break;case 2:r.f=e.float();break;case 3:r.i=e.int64();break;case 4:r.s=e.bytes();break;case 5:r.t=c.onnx.TensorProto.decode(e,e.uint32());break;case 6:r.g=c.onnx.GraphProto.decode(e,e.uint32());break;case 7:if(r.floats&&r.floats.length||(r.floats=[]),2==(7&o))for(var i=e.uint32()+e.pos;e.pos<i;)r.floats.push(e.float());else r.floats.push(e.float());break;case 8:if(r.ints&&r.ints.length||(r.ints=[]),2==(7&o))for(i=e.uint32()+e.pos;e.pos<i;)r.ints.push(e.int64());else r.ints.push(e.int64());break;case 9:r.strings&&r.strings.length||(r.strings=[]),r.strings.push(e.bytes());break;case 10:r.tensors&&r.tensors.length||(r.tensors=[]),r.tensors.push(c.onnx.TensorProto.decode(e,e.uint32()));break;case 11:r.graphs&&r.graphs.length||(r.graphs=[]),r.graphs.push(c.onnx.GraphProto.decode(e,e.uint32()));break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.name&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(null!=e.refAttrName&&e.hasOwnProperty("refAttrName")&&!l.isString(e.refAttrName))return"refAttrName: string expected";if(null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString))return"docString: string expected";if(null!=e.type&&e.hasOwnProperty("type"))switch(e.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(null!=e.f&&e.hasOwnProperty("f")&&"number"!=typeof e.f)return"f: number expected";if(null!=e.i&&e.hasOwnProperty("i")&&!(l.isInteger(e.i)||e.i&&l.isInteger(e.i.low)&&l.isInteger(e.i.high)))return"i: integer|Long expected";if(null!=e.s&&e.hasOwnProperty("s")&&!(e.s&&"number"==typeof e.s.length||l.isString(e.s)))return"s: buffer expected";if(null!=e.t&&e.hasOwnProperty("t")&&(n=c.onnx.TensorProto.verify(e.t)))return"t."+n;if(null!=e.g&&e.hasOwnProperty("g")&&(n=c.onnx.GraphProto.verify(e.g)))return"g."+n;if(null!=e.floats&&e.hasOwnProperty("floats")){if(!Array.isArray(e.floats))return"floats: array expected";for(var t=0;t<e.floats.length;++t)if("number"!=typeof e.floats[t])return"floats: number[] expected"}if(null!=e.ints&&e.hasOwnProperty("ints")){if(!Array.isArray(e.ints))return"ints: array expected";for(t=0;t<e.ints.length;++t)if(!(l.isInteger(e.ints[t])||e.ints[t]&&l.isInteger(e.ints[t].low)&&l.isInteger(e.ints[t].high)))return"ints: integer|Long[] expected"}if(null!=e.strings&&e.hasOwnProperty("strings")){if(!Array.isArray(e.strings))return"strings: array expected";for(t=0;t<e.strings.length;++t)if(!(e.strings[t]&&"number"==typeof e.strings[t].length||l.isString(e.strings[t])))return"strings: buffer[] expected"}if(null!=e.tensors&&e.hasOwnProperty("tensors")){if(!Array.isArray(e.tensors))return"tensors: array expected";for(t=0;t<e.tensors.length;++t)if(n=c.onnx.TensorProto.verify(e.tensors[t]))return"tensors."+n}if(null!=e.graphs&&e.hasOwnProperty("graphs")){if(!Array.isArray(e.graphs))return"graphs: array expected";for(t=0;t<e.graphs.length;++t){var n;if(n=c.onnx.GraphProto.verify(e.graphs[t]))return"graphs."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.AttributeProto)return e;var t=new c.onnx.AttributeProto;switch(null!=e.name&&(t.name=String(e.name)),null!=e.refAttrName&&(t.refAttrName=String(e.refAttrName)),null!=e.docString&&(t.docString=String(e.docString)),e.type){case"UNDEFINED":case 0:t.type=0;break;case"FLOAT":case 1:t.type=1;break;case"INT":case 2:t.type=2;break;case"STRING":case 3:t.type=3;break;case"TENSOR":case 4:t.type=4;break;case"GRAPH":case 5:t.type=5;break;case"FLOATS":case 6:t.type=6;break;case"INTS":case 7:t.type=7;break;case"STRINGS":case 8:t.type=8;break;case"TENSORS":case 9:t.type=9;break;case"GRAPHS":case 10:t.type=10}if(null!=e.f&&(t.f=Number(e.f)),null!=e.i&&(l.Long?(t.i=l.Long.fromValue(e.i)).unsigned=!1:"string"==typeof e.i?t.i=parseInt(e.i,10):"number"==typeof e.i?t.i=e.i:"object"==typeof e.i&&(t.i=new l.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber())),null!=e.s&&("string"==typeof e.s?l.base64.decode(e.s,t.s=l.newBuffer(l.base64.length(e.s)),0):e.s.length&&(t.s=e.s)),null!=e.t){if("object"!=typeof e.t)throw TypeError(".onnx.AttributeProto.t: object expected");t.t=c.onnx.TensorProto.fromObject(e.t)}if(null!=e.g){if("object"!=typeof e.g)throw TypeError(".onnx.AttributeProto.g: object expected");t.g=c.onnx.GraphProto.fromObject(e.g)}if(e.floats){if(!Array.isArray(e.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");t.floats=[];for(var n=0;n<e.floats.length;++n)t.floats[n]=Number(e.floats[n])}if(e.ints){if(!Array.isArray(e.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(t.ints=[],n=0;n<e.ints.length;++n)l.Long?(t.ints[n]=l.Long.fromValue(e.ints[n])).unsigned=!1:"string"==typeof e.ints[n]?t.ints[n]=parseInt(e.ints[n],10):"number"==typeof e.ints[n]?t.ints[n]=e.ints[n]:"object"==typeof e.ints[n]&&(t.ints[n]=new l.LongBits(e.ints[n].low>>>0,e.ints[n].high>>>0).toNumber())}if(e.strings){if(!Array.isArray(e.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(t.strings=[],n=0;n<e.strings.length;++n)"string"==typeof e.strings[n]?l.base64.decode(e.strings[n],t.strings[n]=l.newBuffer(l.base64.length(e.strings[n])),0):e.strings[n].length&&(t.strings[n]=e.strings[n])}if(e.tensors){if(!Array.isArray(e.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(t.tensors=[],n=0;n<e.tensors.length;++n){if("object"!=typeof e.tensors[n])throw TypeError(".onnx.AttributeProto.tensors: object expected");t.tensors[n]=c.onnx.TensorProto.fromObject(e.tensors[n])}}if(e.graphs){if(!Array.isArray(e.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(t.graphs=[],n=0;n<e.graphs.length;++n){if("object"!=typeof e.graphs[n])throw TypeError(".onnx.AttributeProto.graphs: object expected");t.graphs[n]=c.onnx.GraphProto.fromObject(e.graphs[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.floats=[],n.ints=[],n.strings=[],n.tensors=[],n.graphs=[]),t.defaults){if(n.name="",n.f=0,l.Long){var r=new l.Long(0,0,!1);n.i=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.i=t.longs===String?"0":0;t.bytes===String?n.s="":(n.s=[],t.bytes!==Array&&(n.s=l.newBuffer(n.s))),n.t=null,n.g=null,n.docString="",n.type=t.enums===String?"UNDEFINED":0,n.refAttrName=""}if(null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),null!=e.f&&e.hasOwnProperty("f")&&(n.f=t.json&&!isFinite(e.f)?String(e.f):e.f),null!=e.i&&e.hasOwnProperty("i")&&("number"==typeof e.i?n.i=t.longs===String?String(e.i):e.i:n.i=t.longs===String?l.Long.prototype.toString.call(e.i):t.longs===Number?new l.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber():e.i),null!=e.s&&e.hasOwnProperty("s")&&(n.s=t.bytes===String?l.base64.encode(e.s,0,e.s.length):t.bytes===Array?Array.prototype.slice.call(e.s):e.s),null!=e.t&&e.hasOwnProperty("t")&&(n.t=c.onnx.TensorProto.toObject(e.t,t)),null!=e.g&&e.hasOwnProperty("g")&&(n.g=c.onnx.GraphProto.toObject(e.g,t)),e.floats&&e.floats.length){n.floats=[];for(var o=0;o<e.floats.length;++o)n.floats[o]=t.json&&!isFinite(e.floats[o])?String(e.floats[o]):e.floats[o]}if(e.ints&&e.ints.length)for(n.ints=[],o=0;o<e.ints.length;++o)"number"==typeof e.ints[o]?n.ints[o]=t.longs===String?String(e.ints[o]):e.ints[o]:n.ints[o]=t.longs===String?l.Long.prototype.toString.call(e.ints[o]):t.longs===Number?new l.LongBits(e.ints[o].low>>>0,e.ints[o].high>>>0).toNumber():e.ints[o];if(e.strings&&e.strings.length)for(n.strings=[],o=0;o<e.strings.length;++o)n.strings[o]=t.bytes===String?l.base64.encode(e.strings[o],0,e.strings[o].length):t.bytes===Array?Array.prototype.slice.call(e.strings[o]):e.strings[o];if(e.tensors&&e.tensors.length)for(n.tensors=[],o=0;o<e.tensors.length;++o)n.tensors[o]=c.onnx.TensorProto.toObject(e.tensors[o],t);if(e.graphs&&e.graphs.length)for(n.graphs=[],o=0;o<e.graphs.length;++o)n.graphs[o]=c.onnx.GraphProto.toObject(e.graphs[o],t);return null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),null!=e.type&&e.hasOwnProperty("type")&&(n.type=t.enums===String?c.onnx.AttributeProto.AttributeType[e.type]:e.type),null!=e.refAttrName&&e.hasOwnProperty("refAttrName")&&(n.refAttrName=e.refAttrName),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e.AttributeType=function(){var e={},t=Object.create(e);return t[e[0]="UNDEFINED"]=0,t[e[1]="FLOAT"]=1,t[e[2]="INT"]=2,t[e[3]="STRING"]=3,t[e[4]="TENSOR"]=4,t[e[5]="GRAPH"]=5,t[e[6]="FLOATS"]=6,t[e[7]="INTS"]=7,t[e[8]="STRINGS"]=8,t[e[9]="TENSORS"]=9,t[e[10]="GRAPHS"]=10,t}(),e}(),i.ValueInfoProto=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.name="",e.prototype.type=null,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.name&&e.hasOwnProperty("name")&&t.uint32(10).string(e.name),null!=e.type&&e.hasOwnProperty("type")&&c.onnx.TypeProto.encode(e.type,t.uint32(18).fork()).ldelim(),null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(26).string(e.docString),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.ValueInfoProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.name=e.string();break;case 2:r.type=c.onnx.TypeProto.decode(e,e.uint32());break;case 3:r.docString=e.string();break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.name&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(null!=e.type&&e.hasOwnProperty("type")){var t=c.onnx.TypeProto.verify(e.type);if(t)return"type."+t}return null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString)?"docString: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.ValueInfoProto)return e;var t=new c.onnx.ValueInfoProto;if(null!=e.name&&(t.name=String(e.name)),null!=e.type){if("object"!=typeof e.type)throw TypeError(".onnx.ValueInfoProto.type: object expected");t.type=c.onnx.TypeProto.fromObject(e.type)}return null!=e.docString&&(t.docString=String(e.docString)),t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.name="",n.type=null,n.docString=""),null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),null!=e.type&&e.hasOwnProperty("type")&&(n.type=c.onnx.TypeProto.toObject(e.type,t)),null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),i.NodeProto=function(){function e(e){if(this.input=[],this.output=[],this.attribute=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.input=l.emptyArray,e.prototype.output=l.emptyArray,e.prototype.name="",e.prototype.opType="",e.prototype.domain="",e.prototype.attribute=l.emptyArray,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.input&&e.input.length)for(var n=0;n<e.input.length;++n)t.uint32(10).string(e.input[n]);if(null!=e.output&&e.output.length)for(n=0;n<e.output.length;++n)t.uint32(18).string(e.output[n]);if(null!=e.name&&e.hasOwnProperty("name")&&t.uint32(26).string(e.name),null!=e.opType&&e.hasOwnProperty("opType")&&t.uint32(34).string(e.opType),null!=e.attribute&&e.attribute.length)for(n=0;n<e.attribute.length;++n)c.onnx.AttributeProto.encode(e.attribute[n],t.uint32(42).fork()).ldelim();return null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(50).string(e.docString),null!=e.domain&&e.hasOwnProperty("domain")&&t.uint32(58).string(e.domain),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.NodeProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.input&&r.input.length||(r.input=[]),r.input.push(e.string());break;case 2:r.output&&r.output.length||(r.output=[]),r.output.push(e.string());break;case 3:r.name=e.string();break;case 4:r.opType=e.string();break;case 7:r.domain=e.string();break;case 5:r.attribute&&r.attribute.length||(r.attribute=[]),r.attribute.push(c.onnx.AttributeProto.decode(e,e.uint32()));break;case 6:r.docString=e.string();break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.input&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(var t=0;t<e.input.length;++t)if(!l.isString(e.input[t]))return"input: string[] expected"}if(null!=e.output&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(t=0;t<e.output.length;++t)if(!l.isString(e.output[t]))return"output: string[] expected"}if(null!=e.name&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(null!=e.opType&&e.hasOwnProperty("opType")&&!l.isString(e.opType))return"opType: string expected";if(null!=e.domain&&e.hasOwnProperty("domain")&&!l.isString(e.domain))return"domain: string expected";if(null!=e.attribute&&e.hasOwnProperty("attribute")){if(!Array.isArray(e.attribute))return"attribute: array expected";for(t=0;t<e.attribute.length;++t){var n=c.onnx.AttributeProto.verify(e.attribute[t]);if(n)return"attribute."+n}}return null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString)?"docString: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.NodeProto)return e;var t=new c.onnx.NodeProto;if(e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.NodeProto.input: array expected");t.input=[];for(var n=0;n<e.input.length;++n)t.input[n]=String(e.input[n])}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.NodeProto.output: array expected");for(t.output=[],n=0;n<e.output.length;++n)t.output[n]=String(e.output[n])}if(null!=e.name&&(t.name=String(e.name)),null!=e.opType&&(t.opType=String(e.opType)),null!=e.domain&&(t.domain=String(e.domain)),e.attribute){if(!Array.isArray(e.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(t.attribute=[],n=0;n<e.attribute.length;++n){if("object"!=typeof e.attribute[n])throw TypeError(".onnx.NodeProto.attribute: object expected");t.attribute[n]=c.onnx.AttributeProto.fromObject(e.attribute[n])}}return null!=e.docString&&(t.docString=String(e.docString)),t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.input=[],n.output=[],n.attribute=[]),t.defaults&&(n.name="",n.opType="",n.docString="",n.domain=""),e.input&&e.input.length){n.input=[];for(var r=0;r<e.input.length;++r)n.input[r]=e.input[r]}if(e.output&&e.output.length)for(n.output=[],r=0;r<e.output.length;++r)n.output[r]=e.output[r];if(null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),null!=e.opType&&e.hasOwnProperty("opType")&&(n.opType=e.opType),e.attribute&&e.attribute.length)for(n.attribute=[],r=0;r<e.attribute.length;++r)n.attribute[r]=c.onnx.AttributeProto.toObject(e.attribute[r],t);return null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),null!=e.domain&&e.hasOwnProperty("domain")&&(n.domain=e.domain),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),i.ModelProto=function(){function e(e){if(this.opsetImport=[],this.metadataProps=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.irVersion=l.Long?l.Long.fromBits(0,0,!1):0,e.prototype.opsetImport=l.emptyArray,e.prototype.producerName="",e.prototype.producerVersion="",e.prototype.domain="",e.prototype.modelVersion=l.Long?l.Long.fromBits(0,0,!1):0,e.prototype.docString="",e.prototype.graph=null,e.prototype.metadataProps=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.irVersion&&e.hasOwnProperty("irVersion")&&t.uint32(8).int64(e.irVersion),null!=e.producerName&&e.hasOwnProperty("producerName")&&t.uint32(18).string(e.producerName),null!=e.producerVersion&&e.hasOwnProperty("producerVersion")&&t.uint32(26).string(e.producerVersion),null!=e.domain&&e.hasOwnProperty("domain")&&t.uint32(34).string(e.domain),null!=e.modelVersion&&e.hasOwnProperty("modelVersion")&&t.uint32(40).int64(e.modelVersion),null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(50).string(e.docString),null!=e.graph&&e.hasOwnProperty("graph")&&c.onnx.GraphProto.encode(e.graph,t.uint32(58).fork()).ldelim(),null!=e.opsetImport&&e.opsetImport.length)for(var n=0;n<e.opsetImport.length;++n)c.onnx.OperatorSetIdProto.encode(e.opsetImport[n],t.uint32(66).fork()).ldelim();if(null!=e.metadataProps&&e.metadataProps.length)for(n=0;n<e.metadataProps.length;++n)c.onnx.StringStringEntryProto.encode(e.metadataProps[n],t.uint32(114).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.ModelProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.irVersion=e.int64();break;case 8:r.opsetImport&&r.opsetImport.length||(r.opsetImport=[]),r.opsetImport.push(c.onnx.OperatorSetIdProto.decode(e,e.uint32()));break;case 2:r.producerName=e.string();break;case 3:r.producerVersion=e.string();break;case 4:r.domain=e.string();break;case 5:r.modelVersion=e.int64();break;case 6:r.docString=e.string();break;case 7:r.graph=c.onnx.GraphProto.decode(e,e.uint32());break;case 14:r.metadataProps&&r.metadataProps.length||(r.metadataProps=[]),r.metadataProps.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.irVersion&&e.hasOwnProperty("irVersion")&&!(l.isInteger(e.irVersion)||e.irVersion&&l.isInteger(e.irVersion.low)&&l.isInteger(e.irVersion.high)))return"irVersion: integer|Long expected";if(null!=e.opsetImport&&e.hasOwnProperty("opsetImport")){if(!Array.isArray(e.opsetImport))return"opsetImport: array expected";for(var t=0;t<e.opsetImport.length;++t)if(n=c.onnx.OperatorSetIdProto.verify(e.opsetImport[t]))return"opsetImport."+n}if(null!=e.producerName&&e.hasOwnProperty("producerName")&&!l.isString(e.producerName))return"producerName: string expected";if(null!=e.producerVersion&&e.hasOwnProperty("producerVersion")&&!l.isString(e.producerVersion))return"producerVersion: string expected";if(null!=e.domain&&e.hasOwnProperty("domain")&&!l.isString(e.domain))return"domain: string expected";if(null!=e.modelVersion&&e.hasOwnProperty("modelVersion")&&!(l.isInteger(e.modelVersion)||e.modelVersion&&l.isInteger(e.modelVersion.low)&&l.isInteger(e.modelVersion.high)))return"modelVersion: integer|Long expected";if(null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString))return"docString: string expected";if(null!=e.graph&&e.hasOwnProperty("graph")&&(n=c.onnx.GraphProto.verify(e.graph)))return"graph."+n;if(null!=e.metadataProps&&e.hasOwnProperty("metadataProps")){if(!Array.isArray(e.metadataProps))return"metadataProps: array expected";for(t=0;t<e.metadataProps.length;++t){var n;if(n=c.onnx.StringStringEntryProto.verify(e.metadataProps[t]))return"metadataProps."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.ModelProto)return e;var t=new c.onnx.ModelProto;if(null!=e.irVersion&&(l.Long?(t.irVersion=l.Long.fromValue(e.irVersion)).unsigned=!1:"string"==typeof e.irVersion?t.irVersion=parseInt(e.irVersion,10):"number"==typeof e.irVersion?t.irVersion=e.irVersion:"object"==typeof e.irVersion&&(t.irVersion=new l.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber())),e.opsetImport){if(!Array.isArray(e.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");t.opsetImport=[];for(var n=0;n<e.opsetImport.length;++n){if("object"!=typeof e.opsetImport[n])throw TypeError(".onnx.ModelProto.opsetImport: object expected");t.opsetImport[n]=c.onnx.OperatorSetIdProto.fromObject(e.opsetImport[n])}}if(null!=e.producerName&&(t.producerName=String(e.producerName)),null!=e.producerVersion&&(t.producerVersion=String(e.producerVersion)),null!=e.domain&&(t.domain=String(e.domain)),null!=e.modelVersion&&(l.Long?(t.modelVersion=l.Long.fromValue(e.modelVersion)).unsigned=!1:"string"==typeof e.modelVersion?t.modelVersion=parseInt(e.modelVersion,10):"number"==typeof e.modelVersion?t.modelVersion=e.modelVersion:"object"==typeof e.modelVersion&&(t.modelVersion=new l.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber())),null!=e.docString&&(t.docString=String(e.docString)),null!=e.graph){if("object"!=typeof e.graph)throw TypeError(".onnx.ModelProto.graph: object expected");t.graph=c.onnx.GraphProto.fromObject(e.graph)}if(e.metadataProps){if(!Array.isArray(e.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(t.metadataProps=[],n=0;n<e.metadataProps.length;++n){if("object"!=typeof e.metadataProps[n])throw TypeError(".onnx.ModelProto.metadataProps: object expected");t.metadataProps[n]=c.onnx.StringStringEntryProto.fromObject(e.metadataProps[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.opsetImport=[],n.metadataProps=[]),t.defaults){if(l.Long){var r=new l.Long(0,0,!1);n.irVersion=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.irVersion=t.longs===String?"0":0;n.producerName="",n.producerVersion="",n.domain="",l.Long?(r=new l.Long(0,0,!1),n.modelVersion=t.longs===String?r.toString():t.longs===Number?r.toNumber():r):n.modelVersion=t.longs===String?"0":0,n.docString="",n.graph=null}if(null!=e.irVersion&&e.hasOwnProperty("irVersion")&&("number"==typeof e.irVersion?n.irVersion=t.longs===String?String(e.irVersion):e.irVersion:n.irVersion=t.longs===String?l.Long.prototype.toString.call(e.irVersion):t.longs===Number?new l.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber():e.irVersion),null!=e.producerName&&e.hasOwnProperty("producerName")&&(n.producerName=e.producerName),null!=e.producerVersion&&e.hasOwnProperty("producerVersion")&&(n.producerVersion=e.producerVersion),null!=e.domain&&e.hasOwnProperty("domain")&&(n.domain=e.domain),null!=e.modelVersion&&e.hasOwnProperty("modelVersion")&&("number"==typeof e.modelVersion?n.modelVersion=t.longs===String?String(e.modelVersion):e.modelVersion:n.modelVersion=t.longs===String?l.Long.prototype.toString.call(e.modelVersion):t.longs===Number?new l.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber():e.modelVersion),null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),null!=e.graph&&e.hasOwnProperty("graph")&&(n.graph=c.onnx.GraphProto.toObject(e.graph,t)),e.opsetImport&&e.opsetImport.length){n.opsetImport=[];for(var o=0;o<e.opsetImport.length;++o)n.opsetImport[o]=c.onnx.OperatorSetIdProto.toObject(e.opsetImport[o],t)}if(e.metadataProps&&e.metadataProps.length)for(n.metadataProps=[],o=0;o<e.metadataProps.length;++o)n.metadataProps[o]=c.onnx.StringStringEntryProto.toObject(e.metadataProps[o],t);return n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),i.StringStringEntryProto=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.key="",e.prototype.value="",e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.key&&e.hasOwnProperty("key")&&t.uint32(10).string(e.key),null!=e.value&&e.hasOwnProperty("value")&&t.uint32(18).string(e.value),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.StringStringEntryProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.key=e.string();break;case 2:r.value=e.string();break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){return"object"!=typeof e||null===e?"object expected":null!=e.key&&e.hasOwnProperty("key")&&!l.isString(e.key)?"key: string expected":null!=e.value&&e.hasOwnProperty("value")&&!l.isString(e.value)?"value: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.StringStringEntryProto)return e;var t=new c.onnx.StringStringEntryProto;return null!=e.key&&(t.key=String(e.key)),null!=e.value&&(t.value=String(e.value)),t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.key="",n.value=""),null!=e.key&&e.hasOwnProperty("key")&&(n.key=e.key),null!=e.value&&e.hasOwnProperty("value")&&(n.value=e.value),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),i.TensorAnnotation=function(){function e(e){if(this.quantParameterTensorNames=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.tensorName="",e.prototype.quantParameterTensorNames=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.tensorName&&e.hasOwnProperty("tensorName")&&t.uint32(10).string(e.tensorName),null!=e.quantParameterTensorNames&&e.quantParameterTensorNames.length)for(var n=0;n<e.quantParameterTensorNames.length;++n)c.onnx.StringStringEntryProto.encode(e.quantParameterTensorNames[n],t.uint32(18).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorAnnotation;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.tensorName=e.string();break;case 2:r.quantParameterTensorNames&&r.quantParameterTensorNames.length||(r.quantParameterTensorNames=[]),r.quantParameterTensorNames.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.tensorName&&e.hasOwnProperty("tensorName")&&!l.isString(e.tensorName))return"tensorName: string expected";if(null!=e.quantParameterTensorNames&&e.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(e.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var t=0;t<e.quantParameterTensorNames.length;++t){var n=c.onnx.StringStringEntryProto.verify(e.quantParameterTensorNames[t]);if(n)return"quantParameterTensorNames."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.TensorAnnotation)return e;var t=new c.onnx.TensorAnnotation;if(null!=e.tensorName&&(t.tensorName=String(e.tensorName)),e.quantParameterTensorNames){if(!Array.isArray(e.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");t.quantParameterTensorNames=[];for(var n=0;n<e.quantParameterTensorNames.length;++n){if("object"!=typeof e.quantParameterTensorNames[n])throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");t.quantParameterTensorNames[n]=c.onnx.StringStringEntryProto.fromObject(e.quantParameterTensorNames[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.quantParameterTensorNames=[]),t.defaults&&(n.tensorName=""),null!=e.tensorName&&e.hasOwnProperty("tensorName")&&(n.tensorName=e.tensorName),e.quantParameterTensorNames&&e.quantParameterTensorNames.length){n.quantParameterTensorNames=[];for(var r=0;r<e.quantParameterTensorNames.length;++r)n.quantParameterTensorNames[r]=c.onnx.StringStringEntryProto.toObject(e.quantParameterTensorNames[r],t)}return n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),i.GraphProto=function(){function e(e){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.node=l.emptyArray,e.prototype.name="",e.prototype.initializer=l.emptyArray,e.prototype.docString="",e.prototype.input=l.emptyArray,e.prototype.output=l.emptyArray,e.prototype.valueInfo=l.emptyArray,e.prototype.quantizationAnnotation=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.node&&e.node.length)for(var n=0;n<e.node.length;++n)c.onnx.NodeProto.encode(e.node[n],t.uint32(10).fork()).ldelim();if(null!=e.name&&e.hasOwnProperty("name")&&t.uint32(18).string(e.name),null!=e.initializer&&e.initializer.length)for(n=0;n<e.initializer.length;++n)c.onnx.TensorProto.encode(e.initializer[n],t.uint32(42).fork()).ldelim();if(null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(82).string(e.docString),null!=e.input&&e.input.length)for(n=0;n<e.input.length;++n)c.onnx.ValueInfoProto.encode(e.input[n],t.uint32(90).fork()).ldelim();if(null!=e.output&&e.output.length)for(n=0;n<e.output.length;++n)c.onnx.ValueInfoProto.encode(e.output[n],t.uint32(98).fork()).ldelim();if(null!=e.valueInfo&&e.valueInfo.length)for(n=0;n<e.valueInfo.length;++n)c.onnx.ValueInfoProto.encode(e.valueInfo[n],t.uint32(106).fork()).ldelim();if(null!=e.quantizationAnnotation&&e.quantizationAnnotation.length)for(n=0;n<e.quantizationAnnotation.length;++n)c.onnx.TensorAnnotation.encode(e.quantizationAnnotation[n],t.uint32(114).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.GraphProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.node&&r.node.length||(r.node=[]),r.node.push(c.onnx.NodeProto.decode(e,e.uint32()));break;case 2:r.name=e.string();break;case 5:r.initializer&&r.initializer.length||(r.initializer=[]),r.initializer.push(c.onnx.TensorProto.decode(e,e.uint32()));break;case 10:r.docString=e.string();break;case 11:r.input&&r.input.length||(r.input=[]),r.input.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 12:r.output&&r.output.length||(r.output=[]),r.output.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 13:r.valueInfo&&r.valueInfo.length||(r.valueInfo=[]),r.valueInfo.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 14:r.quantizationAnnotation&&r.quantizationAnnotation.length||(r.quantizationAnnotation=[]),r.quantizationAnnotation.push(c.onnx.TensorAnnotation.decode(e,e.uint32()));break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.node&&e.hasOwnProperty("node")){if(!Array.isArray(e.node))return"node: array expected";for(var t=0;t<e.node.length;++t)if(n=c.onnx.NodeProto.verify(e.node[t]))return"node."+n}if(null!=e.name&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(null!=e.initializer&&e.hasOwnProperty("initializer")){if(!Array.isArray(e.initializer))return"initializer: array expected";for(t=0;t<e.initializer.length;++t)if(n=c.onnx.TensorProto.verify(e.initializer[t]))return"initializer."+n}if(null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString))return"docString: string expected";if(null!=e.input&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(t=0;t<e.input.length;++t)if(n=c.onnx.ValueInfoProto.verify(e.input[t]))return"input."+n}if(null!=e.output&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(t=0;t<e.output.length;++t)if(n=c.onnx.ValueInfoProto.verify(e.output[t]))return"output."+n}if(null!=e.valueInfo&&e.hasOwnProperty("valueInfo")){if(!Array.isArray(e.valueInfo))return"valueInfo: array expected";for(t=0;t<e.valueInfo.length;++t)if(n=c.onnx.ValueInfoProto.verify(e.valueInfo[t]))return"valueInfo."+n}if(null!=e.quantizationAnnotation&&e.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(e.quantizationAnnotation))return"quantizationAnnotation: array expected";for(t=0;t<e.quantizationAnnotation.length;++t){var n;if(n=c.onnx.TensorAnnotation.verify(e.quantizationAnnotation[t]))return"quantizationAnnotation."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.GraphProto)return e;var t=new c.onnx.GraphProto;if(e.node){if(!Array.isArray(e.node))throw TypeError(".onnx.GraphProto.node: array expected");t.node=[];for(var n=0;n<e.node.length;++n){if("object"!=typeof e.node[n])throw TypeError(".onnx.GraphProto.node: object expected");t.node[n]=c.onnx.NodeProto.fromObject(e.node[n])}}if(null!=e.name&&(t.name=String(e.name)),e.initializer){if(!Array.isArray(e.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(t.initializer=[],n=0;n<e.initializer.length;++n){if("object"!=typeof e.initializer[n])throw TypeError(".onnx.GraphProto.initializer: object expected");t.initializer[n]=c.onnx.TensorProto.fromObject(e.initializer[n])}}if(null!=e.docString&&(t.docString=String(e.docString)),e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.GraphProto.input: array expected");for(t.input=[],n=0;n<e.input.length;++n){if("object"!=typeof e.input[n])throw TypeError(".onnx.GraphProto.input: object expected");t.input[n]=c.onnx.ValueInfoProto.fromObject(e.input[n])}}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.GraphProto.output: array expected");for(t.output=[],n=0;n<e.output.length;++n){if("object"!=typeof e.output[n])throw TypeError(".onnx.GraphProto.output: object expected");t.output[n]=c.onnx.ValueInfoProto.fromObject(e.output[n])}}if(e.valueInfo){if(!Array.isArray(e.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(t.valueInfo=[],n=0;n<e.valueInfo.length;++n){if("object"!=typeof e.valueInfo[n])throw TypeError(".onnx.GraphProto.valueInfo: object expected");t.valueInfo[n]=c.onnx.ValueInfoProto.fromObject(e.valueInfo[n])}}if(e.quantizationAnnotation){if(!Array.isArray(e.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(t.quantizationAnnotation=[],n=0;n<e.quantizationAnnotation.length;++n){if("object"!=typeof e.quantizationAnnotation[n])throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");t.quantizationAnnotation[n]=c.onnx.TensorAnnotation.fromObject(e.quantizationAnnotation[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.node=[],n.initializer=[],n.input=[],n.output=[],n.valueInfo=[],n.quantizationAnnotation=[]),t.defaults&&(n.name="",n.docString=""),e.node&&e.node.length){n.node=[];for(var r=0;r<e.node.length;++r)n.node[r]=c.onnx.NodeProto.toObject(e.node[r],t)}if(null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),e.initializer&&e.initializer.length)for(n.initializer=[],r=0;r<e.initializer.length;++r)n.initializer[r]=c.onnx.TensorProto.toObject(e.initializer[r],t);if(null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),e.input&&e.input.length)for(n.input=[],r=0;r<e.input.length;++r)n.input[r]=c.onnx.ValueInfoProto.toObject(e.input[r],t);if(e.output&&e.output.length)for(n.output=[],r=0;r<e.output.length;++r)n.output[r]=c.onnx.ValueInfoProto.toObject(e.output[r],t);if(e.valueInfo&&e.valueInfo.length)for(n.valueInfo=[],r=0;r<e.valueInfo.length;++r)n.valueInfo[r]=c.onnx.ValueInfoProto.toObject(e.valueInfo[r],t);if(e.quantizationAnnotation&&e.quantizationAnnotation.length)for(n.quantizationAnnotation=[],r=0;r<e.quantizationAnnotation.length;++r)n.quantizationAnnotation[r]=c.onnx.TensorAnnotation.toObject(e.quantizationAnnotation[r],t);return n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),i.TensorProto=function(){function e(e){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.dims=l.emptyArray,e.prototype.dataType=0,e.prototype.segment=null,e.prototype.floatData=l.emptyArray,e.prototype.int32Data=l.emptyArray,e.prototype.stringData=l.emptyArray,e.prototype.int64Data=l.emptyArray,e.prototype.name="",e.prototype.docString="",e.prototype.rawData=l.newBuffer([]),e.prototype.externalData=l.emptyArray,e.prototype.dataLocation=0,e.prototype.doubleData=l.emptyArray,e.prototype.uint64Data=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.dims&&e.dims.length){t.uint32(10).fork();for(var n=0;n<e.dims.length;++n)t.int64(e.dims[n]);t.ldelim()}if(null!=e.dataType&&e.hasOwnProperty("dataType")&&t.uint32(16).int32(e.dataType),null!=e.segment&&e.hasOwnProperty("segment")&&c.onnx.TensorProto.Segment.encode(e.segment,t.uint32(26).fork()).ldelim(),null!=e.floatData&&e.floatData.length){for(t.uint32(34).fork(),n=0;n<e.floatData.length;++n)t.float(e.floatData[n]);t.ldelim()}if(null!=e.int32Data&&e.int32Data.length){for(t.uint32(42).fork(),n=0;n<e.int32Data.length;++n)t.int32(e.int32Data[n]);t.ldelim()}if(null!=e.stringData&&e.stringData.length)for(n=0;n<e.stringData.length;++n)t.uint32(50).bytes(e.stringData[n]);if(null!=e.int64Data&&e.int64Data.length){for(t.uint32(58).fork(),n=0;n<e.int64Data.length;++n)t.int64(e.int64Data[n]);t.ldelim()}if(null!=e.name&&e.hasOwnProperty("name")&&t.uint32(66).string(e.name),null!=e.rawData&&e.hasOwnProperty("rawData")&&t.uint32(74).bytes(e.rawData),null!=e.doubleData&&e.doubleData.length){for(t.uint32(82).fork(),n=0;n<e.doubleData.length;++n)t.double(e.doubleData[n]);t.ldelim()}if(null!=e.uint64Data&&e.uint64Data.length){for(t.uint32(90).fork(),n=0;n<e.uint64Data.length;++n)t.uint64(e.uint64Data[n]);t.ldelim()}if(null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(98).string(e.docString),null!=e.externalData&&e.externalData.length)for(n=0;n<e.externalData.length;++n)c.onnx.StringStringEntryProto.encode(e.externalData[n],t.uint32(106).fork()).ldelim();return null!=e.dataLocation&&e.hasOwnProperty("dataLocation")&&t.uint32(112).int32(e.dataLocation),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:if(r.dims&&r.dims.length||(r.dims=[]),2==(7&o))for(var i=e.uint32()+e.pos;e.pos<i;)r.dims.push(e.int64());else r.dims.push(e.int64());break;case 2:r.dataType=e.int32();break;case 3:r.segment=c.onnx.TensorProto.Segment.decode(e,e.uint32());break;case 4:if(r.floatData&&r.floatData.length||(r.floatData=[]),2==(7&o))for(i=e.uint32()+e.pos;e.pos<i;)r.floatData.push(e.float());else r.floatData.push(e.float());break;case 5:if(r.int32Data&&r.int32Data.length||(r.int32Data=[]),2==(7&o))for(i=e.uint32()+e.pos;e.pos<i;)r.int32Data.push(e.int32());else r.int32Data.push(e.int32());break;case 6:r.stringData&&r.stringData.length||(r.stringData=[]),r.stringData.push(e.bytes());break;case 7:if(r.int64Data&&r.int64Data.length||(r.int64Data=[]),2==(7&o))for(i=e.uint32()+e.pos;e.pos<i;)r.int64Data.push(e.int64());else r.int64Data.push(e.int64());break;case 8:r.name=e.string();break;case 12:r.docString=e.string();break;case 9:r.rawData=e.bytes();break;case 13:r.externalData&&r.externalData.length||(r.externalData=[]),r.externalData.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break;case 14:r.dataLocation=e.int32();break;case 10:if(r.doubleData&&r.doubleData.length||(r.doubleData=[]),2==(7&o))for(i=e.uint32()+e.pos;e.pos<i;)r.doubleData.push(e.double());else r.doubleData.push(e.double());break;case 11:if(r.uint64Data&&r.uint64Data.length||(r.uint64Data=[]),2==(7&o))for(i=e.uint32()+e.pos;e.pos<i;)r.uint64Data.push(e.uint64());else r.uint64Data.push(e.uint64());break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.dims&&e.hasOwnProperty("dims")){if(!Array.isArray(e.dims))return"dims: array expected";for(var t=0;t<e.dims.length;++t)if(!(l.isInteger(e.dims[t])||e.dims[t]&&l.isInteger(e.dims[t].low)&&l.isInteger(e.dims[t].high)))return"dims: integer|Long[] expected"}if(null!=e.dataType&&e.hasOwnProperty("dataType")&&!l.isInteger(e.dataType))return"dataType: integer expected";if(null!=e.segment&&e.hasOwnProperty("segment")&&(n=c.onnx.TensorProto.Segment.verify(e.segment)))return"segment."+n;if(null!=e.floatData&&e.hasOwnProperty("floatData")){if(!Array.isArray(e.floatData))return"floatData: array expected";for(t=0;t<e.floatData.length;++t)if("number"!=typeof e.floatData[t])return"floatData: number[] expected"}if(null!=e.int32Data&&e.hasOwnProperty("int32Data")){if(!Array.isArray(e.int32Data))return"int32Data: array expected";for(t=0;t<e.int32Data.length;++t)if(!l.isInteger(e.int32Data[t]))return"int32Data: integer[] expected"}if(null!=e.stringData&&e.hasOwnProperty("stringData")){if(!Array.isArray(e.stringData))return"stringData: array expected";for(t=0;t<e.stringData.length;++t)if(!(e.stringData[t]&&"number"==typeof e.stringData[t].length||l.isString(e.stringData[t])))return"stringData: buffer[] expected"}if(null!=e.int64Data&&e.hasOwnProperty("int64Data")){if(!Array.isArray(e.int64Data))return"int64Data: array expected";for(t=0;t<e.int64Data.length;++t)if(!(l.isInteger(e.int64Data[t])||e.int64Data[t]&&l.isInteger(e.int64Data[t].low)&&l.isInteger(e.int64Data[t].high)))return"int64Data: integer|Long[] expected"}if(null!=e.name&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString))return"docString: string expected";if(null!=e.rawData&&e.hasOwnProperty("rawData")&&!(e.rawData&&"number"==typeof e.rawData.length||l.isString(e.rawData)))return"rawData: buffer expected";if(null!=e.externalData&&e.hasOwnProperty("externalData")){if(!Array.isArray(e.externalData))return"externalData: array expected";for(t=0;t<e.externalData.length;++t){var n;if(n=c.onnx.StringStringEntryProto.verify(e.externalData[t]))return"externalData."+n}}if(null!=e.dataLocation&&e.hasOwnProperty("dataLocation"))switch(e.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(null!=e.doubleData&&e.hasOwnProperty("doubleData")){if(!Array.isArray(e.doubleData))return"doubleData: array expected";for(t=0;t<e.doubleData.length;++t)if("number"!=typeof e.doubleData[t])return"doubleData: number[] expected"}if(null!=e.uint64Data&&e.hasOwnProperty("uint64Data")){if(!Array.isArray(e.uint64Data))return"uint64Data: array expected";for(t=0;t<e.uint64Data.length;++t)if(!(l.isInteger(e.uint64Data[t])||e.uint64Data[t]&&l.isInteger(e.uint64Data[t].low)&&l.isInteger(e.uint64Data[t].high)))return"uint64Data: integer|Long[] expected"}return null},e.fromObject=function(e){if(e instanceof c.onnx.TensorProto)return e;var t=new c.onnx.TensorProto;if(e.dims){if(!Array.isArray(e.dims))throw TypeError(".onnx.TensorProto.dims: array expected");t.dims=[];for(var n=0;n<e.dims.length;++n)l.Long?(t.dims[n]=l.Long.fromValue(e.dims[n])).unsigned=!1:"string"==typeof e.dims[n]?t.dims[n]=parseInt(e.dims[n],10):"number"==typeof e.dims[n]?t.dims[n]=e.dims[n]:"object"==typeof e.dims[n]&&(t.dims[n]=new l.LongBits(e.dims[n].low>>>0,e.dims[n].high>>>0).toNumber())}if(null!=e.dataType&&(t.dataType=0|e.dataType),null!=e.segment){if("object"!=typeof e.segment)throw TypeError(".onnx.TensorProto.segment: object expected");t.segment=c.onnx.TensorProto.Segment.fromObject(e.segment)}if(e.floatData){if(!Array.isArray(e.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(t.floatData=[],n=0;n<e.floatData.length;++n)t.floatData[n]=Number(e.floatData[n])}if(e.int32Data){if(!Array.isArray(e.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(t.int32Data=[],n=0;n<e.int32Data.length;++n)t.int32Data[n]=0|e.int32Data[n]}if(e.stringData){if(!Array.isArray(e.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(t.stringData=[],n=0;n<e.stringData.length;++n)"string"==typeof e.stringData[n]?l.base64.decode(e.stringData[n],t.stringData[n]=l.newBuffer(l.base64.length(e.stringData[n])),0):e.stringData[n].length&&(t.stringData[n]=e.stringData[n])}if(e.int64Data){if(!Array.isArray(e.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(t.int64Data=[],n=0;n<e.int64Data.length;++n)l.Long?(t.int64Data[n]=l.Long.fromValue(e.int64Data[n])).unsigned=!1:"string"==typeof e.int64Data[n]?t.int64Data[n]=parseInt(e.int64Data[n],10):"number"==typeof e.int64Data[n]?t.int64Data[n]=e.int64Data[n]:"object"==typeof e.int64Data[n]&&(t.int64Data[n]=new l.LongBits(e.int64Data[n].low>>>0,e.int64Data[n].high>>>0).toNumber())}if(null!=e.name&&(t.name=String(e.name)),null!=e.docString&&(t.docString=String(e.docString)),null!=e.rawData&&("string"==typeof e.rawData?l.base64.decode(e.rawData,t.rawData=l.newBuffer(l.base64.length(e.rawData)),0):e.rawData.length&&(t.rawData=e.rawData)),e.externalData){if(!Array.isArray(e.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(t.externalData=[],n=0;n<e.externalData.length;++n){if("object"!=typeof e.externalData[n])throw TypeError(".onnx.TensorProto.externalData: object expected");t.externalData[n]=c.onnx.StringStringEntryProto.fromObject(e.externalData[n])}}switch(e.dataLocation){case"DEFAULT":case 0:t.dataLocation=0;break;case"EXTERNAL":case 1:t.dataLocation=1}if(e.doubleData){if(!Array.isArray(e.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(t.doubleData=[],n=0;n<e.doubleData.length;++n)t.doubleData[n]=Number(e.doubleData[n])}if(e.uint64Data){if(!Array.isArray(e.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(t.uint64Data=[],n=0;n<e.uint64Data.length;++n)l.Long?(t.uint64Data[n]=l.Long.fromValue(e.uint64Data[n])).unsigned=!0:"string"==typeof e.uint64Data[n]?t.uint64Data[n]=parseInt(e.uint64Data[n],10):"number"==typeof e.uint64Data[n]?t.uint64Data[n]=e.uint64Data[n]:"object"==typeof e.uint64Data[n]&&(t.uint64Data[n]=new l.LongBits(e.uint64Data[n].low>>>0,e.uint64Data[n].high>>>0).toNumber(!0))}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.dims=[],n.floatData=[],n.int32Data=[],n.stringData=[],n.int64Data=[],n.doubleData=[],n.uint64Data=[],n.externalData=[]),t.defaults&&(n.dataType=0,n.segment=null,n.name="",t.bytes===String?n.rawData="":(n.rawData=[],t.bytes!==Array&&(n.rawData=l.newBuffer(n.rawData))),n.docString="",n.dataLocation=t.enums===String?"DEFAULT":0),e.dims&&e.dims.length){n.dims=[];for(var r=0;r<e.dims.length;++r)"number"==typeof e.dims[r]?n.dims[r]=t.longs===String?String(e.dims[r]):e.dims[r]:n.dims[r]=t.longs===String?l.Long.prototype.toString.call(e.dims[r]):t.longs===Number?new l.LongBits(e.dims[r].low>>>0,e.dims[r].high>>>0).toNumber():e.dims[r]}if(null!=e.dataType&&e.hasOwnProperty("dataType")&&(n.dataType=e.dataType),null!=e.segment&&e.hasOwnProperty("segment")&&(n.segment=c.onnx.TensorProto.Segment.toObject(e.segment,t)),e.floatData&&e.floatData.length)for(n.floatData=[],r=0;r<e.floatData.length;++r)n.floatData[r]=t.json&&!isFinite(e.floatData[r])?String(e.floatData[r]):e.floatData[r];if(e.int32Data&&e.int32Data.length)for(n.int32Data=[],r=0;r<e.int32Data.length;++r)n.int32Data[r]=e.int32Data[r];if(e.stringData&&e.stringData.length)for(n.stringData=[],r=0;r<e.stringData.length;++r)n.stringData[r]=t.bytes===String?l.base64.encode(e.stringData[r],0,e.stringData[r].length):t.bytes===Array?Array.prototype.slice.call(e.stringData[r]):e.stringData[r];if(e.int64Data&&e.int64Data.length)for(n.int64Data=[],r=0;r<e.int64Data.length;++r)"number"==typeof e.int64Data[r]?n.int64Data[r]=t.longs===String?String(e.int64Data[r]):e.int64Data[r]:n.int64Data[r]=t.longs===String?l.Long.prototype.toString.call(e.int64Data[r]):t.longs===Number?new l.LongBits(e.int64Data[r].low>>>0,e.int64Data[r].high>>>0).toNumber():e.int64Data[r];if(null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),null!=e.rawData&&e.hasOwnProperty("rawData")&&(n.rawData=t.bytes===String?l.base64.encode(e.rawData,0,e.rawData.length):t.bytes===Array?Array.prototype.slice.call(e.rawData):e.rawData),e.doubleData&&e.doubleData.length)for(n.doubleData=[],r=0;r<e.doubleData.length;++r)n.doubleData[r]=t.json&&!isFinite(e.doubleData[r])?String(e.doubleData[r]):e.doubleData[r];if(e.uint64Data&&e.uint64Data.length)for(n.uint64Data=[],r=0;r<e.uint64Data.length;++r)"number"==typeof e.uint64Data[r]?n.uint64Data[r]=t.longs===String?String(e.uint64Data[r]):e.uint64Data[r]:n.uint64Data[r]=t.longs===String?l.Long.prototype.toString.call(e.uint64Data[r]):t.longs===Number?new l.LongBits(e.uint64Data[r].low>>>0,e.uint64Data[r].high>>>0).toNumber(!0):e.uint64Data[r];if(null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),e.externalData&&e.externalData.length)for(n.externalData=[],r=0;r<e.externalData.length;++r)n.externalData[r]=c.onnx.StringStringEntryProto.toObject(e.externalData[r],t);return null!=e.dataLocation&&e.hasOwnProperty("dataLocation")&&(n.dataLocation=t.enums===String?c.onnx.TensorProto.DataLocation[e.dataLocation]:e.dataLocation),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e.DataType=function(){var e={},t=Object.create(e);return t[e[0]="UNDEFINED"]=0,t[e[1]="FLOAT"]=1,t[e[2]="UINT8"]=2,t[e[3]="INT8"]=3,t[e[4]="UINT16"]=4,t[e[5]="INT16"]=5,t[e[6]="INT32"]=6,t[e[7]="INT64"]=7,t[e[8]="STRING"]=8,t[e[9]="BOOL"]=9,t[e[10]="FLOAT16"]=10,t[e[11]="DOUBLE"]=11,t[e[12]="UINT32"]=12,t[e[13]="UINT64"]=13,t[e[14]="COMPLEX64"]=14,t[e[15]="COMPLEX128"]=15,t[e[16]="BFLOAT16"]=16,t}(),e.Segment=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.begin=l.Long?l.Long.fromBits(0,0,!1):0,e.prototype.end=l.Long?l.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.begin&&e.hasOwnProperty("begin")&&t.uint32(8).int64(e.begin),null!=e.end&&e.hasOwnProperty("end")&&t.uint32(16).int64(e.end),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorProto.Segment;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.begin=e.int64();break;case 2:r.end=e.int64();break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){return"object"!=typeof e||null===e?"object expected":null!=e.begin&&e.hasOwnProperty("begin")&&!(l.isInteger(e.begin)||e.begin&&l.isInteger(e.begin.low)&&l.isInteger(e.begin.high))?"begin: integer|Long expected":null!=e.end&&e.hasOwnProperty("end")&&!(l.isInteger(e.end)||e.end&&l.isInteger(e.end.low)&&l.isInteger(e.end.high))?"end: integer|Long expected":null},e.fromObject=function(e){if(e instanceof c.onnx.TensorProto.Segment)return e;var t=new c.onnx.TensorProto.Segment;return null!=e.begin&&(l.Long?(t.begin=l.Long.fromValue(e.begin)).unsigned=!1:"string"==typeof e.begin?t.begin=parseInt(e.begin,10):"number"==typeof e.begin?t.begin=e.begin:"object"==typeof e.begin&&(t.begin=new l.LongBits(e.begin.low>>>0,e.begin.high>>>0).toNumber())),null!=e.end&&(l.Long?(t.end=l.Long.fromValue(e.end)).unsigned=!1:"string"==typeof e.end?t.end=parseInt(e.end,10):"number"==typeof e.end?t.end=e.end:"object"==typeof e.end&&(t.end=new l.LongBits(e.end.low>>>0,e.end.high>>>0).toNumber())),t},e.toObject=function(e,t){t||(t={});var n={};if(t.defaults){if(l.Long){var r=new l.Long(0,0,!1);n.begin=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.begin=t.longs===String?"0":0;l.Long?(r=new l.Long(0,0,!1),n.end=t.longs===String?r.toString():t.longs===Number?r.toNumber():r):n.end=t.longs===String?"0":0}return null!=e.begin&&e.hasOwnProperty("begin")&&("number"==typeof e.begin?n.begin=t.longs===String?String(e.begin):e.begin:n.begin=t.longs===String?l.Long.prototype.toString.call(e.begin):t.longs===Number?new l.LongBits(e.begin.low>>>0,e.begin.high>>>0).toNumber():e.begin),null!=e.end&&e.hasOwnProperty("end")&&("number"==typeof e.end?n.end=t.longs===String?String(e.end):e.end:n.end=t.longs===String?l.Long.prototype.toString.call(e.end):t.longs===Number?new l.LongBits(e.end.low>>>0,e.end.high>>>0).toNumber():e.end),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),e.DataLocation=function(){var e={},t=Object.create(e);return t[e[0]="DEFAULT"]=0,t[e[1]="EXTERNAL"]=1,t}(),e}(),i.TensorShapeProto=function(){function e(e){if(this.dim=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.dim=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.dim&&e.dim.length)for(var n=0;n<e.dim.length;++n)c.onnx.TensorShapeProto.Dimension.encode(e.dim[n],t.uint32(10).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorShapeProto;e.pos<n;){var o=e.uint32();o>>>3==1?(r.dim&&r.dim.length||(r.dim=[]),r.dim.push(c.onnx.TensorShapeProto.Dimension.decode(e,e.uint32()))):e.skipType(7&o)}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.dim&&e.hasOwnProperty("dim")){if(!Array.isArray(e.dim))return"dim: array expected";for(var t=0;t<e.dim.length;++t){var n=c.onnx.TensorShapeProto.Dimension.verify(e.dim[t]);if(n)return"dim."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.TensorShapeProto)return e;var t=new c.onnx.TensorShapeProto;if(e.dim){if(!Array.isArray(e.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");t.dim=[];for(var n=0;n<e.dim.length;++n){if("object"!=typeof e.dim[n])throw TypeError(".onnx.TensorShapeProto.dim: object expected");t.dim[n]=c.onnx.TensorShapeProto.Dimension.fromObject(e.dim[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.dim=[]),e.dim&&e.dim.length){n.dim=[];for(var r=0;r<e.dim.length;++r)n.dim[r]=c.onnx.TensorShapeProto.Dimension.toObject(e.dim[r],t)}return n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e.Dimension=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}var t;return e.prototype.dimValue=l.Long?l.Long.fromBits(0,0,!1):0,e.prototype.dimParam="",e.prototype.denotation="",Object.defineProperty(e.prototype,"value",{get:l.oneOfGetter(t=["dimValue","dimParam"]),set:l.oneOfSetter(t)}),e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.dimValue&&e.hasOwnProperty("dimValue")&&t.uint32(8).int64(e.dimValue),null!=e.dimParam&&e.hasOwnProperty("dimParam")&&t.uint32(18).string(e.dimParam),null!=e.denotation&&e.hasOwnProperty("denotation")&&t.uint32(26).string(e.denotation),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorShapeProto.Dimension;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.dimValue=e.int64();break;case 2:r.dimParam=e.string();break;case 3:r.denotation=e.string();break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";var t={};if(null!=e.dimValue&&e.hasOwnProperty("dimValue")&&(t.value=1,!(l.isInteger(e.dimValue)||e.dimValue&&l.isInteger(e.dimValue.low)&&l.isInteger(e.dimValue.high))))return"dimValue: integer|Long expected";if(null!=e.dimParam&&e.hasOwnProperty("dimParam")){if(1===t.value)return"value: multiple values";if(t.value=1,!l.isString(e.dimParam))return"dimParam: string expected"}return null!=e.denotation&&e.hasOwnProperty("denotation")&&!l.isString(e.denotation)?"denotation: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.TensorShapeProto.Dimension)return e;var t=new c.onnx.TensorShapeProto.Dimension;return null!=e.dimValue&&(l.Long?(t.dimValue=l.Long.fromValue(e.dimValue)).unsigned=!1:"string"==typeof e.dimValue?t.dimValue=parseInt(e.dimValue,10):"number"==typeof e.dimValue?t.dimValue=e.dimValue:"object"==typeof e.dimValue&&(t.dimValue=new l.LongBits(e.dimValue.low>>>0,e.dimValue.high>>>0).toNumber())),null!=e.dimParam&&(t.dimParam=String(e.dimParam)),null!=e.denotation&&(t.denotation=String(e.denotation)),t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.denotation=""),null!=e.dimValue&&e.hasOwnProperty("dimValue")&&("number"==typeof e.dimValue?n.dimValue=t.longs===String?String(e.dimValue):e.dimValue:n.dimValue=t.longs===String?l.Long.prototype.toString.call(e.dimValue):t.longs===Number?new l.LongBits(e.dimValue.low>>>0,e.dimValue.high>>>0).toNumber():e.dimValue,t.oneofs&&(n.value="dimValue")),null!=e.dimParam&&e.hasOwnProperty("dimParam")&&(n.dimParam=e.dimParam,t.oneofs&&(n.value="dimParam")),null!=e.denotation&&e.hasOwnProperty("denotation")&&(n.denotation=e.denotation),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),e}(),i.TypeProto=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}var t;return e.prototype.tensorType=null,e.prototype.denotation="",Object.defineProperty(e.prototype,"value",{get:l.oneOfGetter(t=["tensorType"]),set:l.oneOfSetter(t)}),e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.tensorType&&e.hasOwnProperty("tensorType")&&c.onnx.TypeProto.Tensor.encode(e.tensorType,t.uint32(10).fork()).ldelim(),null!=e.denotation&&e.hasOwnProperty("denotation")&&t.uint32(50).string(e.denotation),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TypeProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.tensorType=c.onnx.TypeProto.Tensor.decode(e,e.uint32());break;case 6:r.denotation=e.string();break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.tensorType&&e.hasOwnProperty("tensorType")){var t=c.onnx.TypeProto.Tensor.verify(e.tensorType);if(t)return"tensorType."+t}return null!=e.denotation&&e.hasOwnProperty("denotation")&&!l.isString(e.denotation)?"denotation: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.TypeProto)return e;var t=new c.onnx.TypeProto;if(null!=e.tensorType){if("object"!=typeof e.tensorType)throw TypeError(".onnx.TypeProto.tensorType: object expected");t.tensorType=c.onnx.TypeProto.Tensor.fromObject(e.tensorType)}return null!=e.denotation&&(t.denotation=String(e.denotation)),t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.denotation=""),null!=e.tensorType&&e.hasOwnProperty("tensorType")&&(n.tensorType=c.onnx.TypeProto.Tensor.toObject(e.tensorType,t),t.oneofs&&(n.value="tensorType")),null!=e.denotation&&e.hasOwnProperty("denotation")&&(n.denotation=e.denotation),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e.Tensor=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.elemType=0,e.prototype.shape=null,e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.elemType&&e.hasOwnProperty("elemType")&&t.uint32(8).int32(e.elemType),null!=e.shape&&e.hasOwnProperty("shape")&&c.onnx.TensorShapeProto.encode(e.shape,t.uint32(18).fork()).ldelim(),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TypeProto.Tensor;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.elemType=e.int32();break;case 2:r.shape=c.onnx.TensorShapeProto.decode(e,e.uint32());break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.elemType&&e.hasOwnProperty("elemType")&&!l.isInteger(e.elemType))return"elemType: integer expected";if(null!=e.shape&&e.hasOwnProperty("shape")){var t=c.onnx.TensorShapeProto.verify(e.shape);if(t)return"shape."+t}return null},e.fromObject=function(e){if(e instanceof c.onnx.TypeProto.Tensor)return e;var t=new c.onnx.TypeProto.Tensor;if(null!=e.elemType&&(t.elemType=0|e.elemType),null!=e.shape){if("object"!=typeof e.shape)throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");t.shape=c.onnx.TensorShapeProto.fromObject(e.shape)}return t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.elemType=0,n.shape=null),null!=e.elemType&&e.hasOwnProperty("elemType")&&(n.elemType=e.elemType),null!=e.shape&&e.hasOwnProperty("shape")&&(n.shape=c.onnx.TensorShapeProto.toObject(e.shape,t)),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),e}(),i.OperatorSetIdProto=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.domain="",e.prototype.version=l.Long?l.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.domain&&e.hasOwnProperty("domain")&&t.uint32(10).string(e.domain),null!=e.version&&e.hasOwnProperty("version")&&t.uint32(16).int64(e.version),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.OperatorSetIdProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.domain=e.string();break;case 2:r.version=e.int64();break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){return"object"!=typeof e||null===e?"object expected":null!=e.domain&&e.hasOwnProperty("domain")&&!l.isString(e.domain)?"domain: string expected":null!=e.version&&e.hasOwnProperty("version")&&!(l.isInteger(e.version)||e.version&&l.isInteger(e.version.low)&&l.isInteger(e.version.high))?"version: integer|Long expected":null},e.fromObject=function(e){if(e instanceof c.onnx.OperatorSetIdProto)return e;var t=new c.onnx.OperatorSetIdProto;return null!=e.domain&&(t.domain=String(e.domain)),null!=e.version&&(l.Long?(t.version=l.Long.fromValue(e.version)).unsigned=!1:"string"==typeof e.version?t.version=parseInt(e.version,10):"number"==typeof e.version?t.version=e.version:"object"==typeof e.version&&(t.version=new l.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber())),t},e.toObject=function(e,t){t||(t={});var n={};if(t.defaults)if(n.domain="",l.Long){var r=new l.Long(0,0,!1);n.version=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.version=t.longs===String?"0":0;return null!=e.domain&&e.hasOwnProperty("domain")&&(n.domain=e.domain),null!=e.version&&e.hasOwnProperty("version")&&("number"==typeof e.version?n.version=t.longs===String?String(e.version):e.version:n.version=t.longs===String?l.Long.prototype.toString.call(e.version):t.longs===Number?new l.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber():e.version),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),i),e.exports=c},2100:(e,t,n)=>{"use strict";e.exports=n(9482)},9482:(e,t,n)=>{"use strict";var r=t;function o(){r.util._configure(),r.Writer._configure(r.BufferWriter),r.Reader._configure(r.BufferReader)}r.build="minimal",r.Writer=n(1173),r.BufferWriter=n(3155),r.Reader=n(1408),r.BufferReader=n(593),r.util=n(9693),r.rpc=n(5994),r.roots=n(5054),r.configure=o,o()},1408:(e,t,n)=>{"use strict";e.exports=u;var r,o=n(9693),i=o.LongBits,a=o.utf8;function s(e,t){return RangeError("index out of range: "+e.pos+" + "+(t||1)+" > "+e.len)}function u(e){this.buf=e,this.pos=0,this.len=e.length}var l,c="undefined"!=typeof Uint8Array?function(e){if(e instanceof Uint8Array||Array.isArray(e))return new u(e);throw Error("illegal buffer")}:function(e){if(Array.isArray(e))return new u(e);throw Error("illegal buffer")},p=function(){return o.Buffer?function(e){return(u.create=function(e){return o.Buffer.isBuffer(e)?new r(e):c(e)})(e)}:c};function d(){var e=new i(0,0),t=0;if(!(this.len-this.pos>4)){for(;t<3;++t){if(this.pos>=this.len)throw s(this);if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(127&this.buf[this.pos++])<<7*t)>>>0,e}for(;t<4;++t)if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(127&this.buf[this.pos])<<28)>>>0,e.hi=(e.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return e;if(t=0,this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw s(this);if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}function f(e,t){return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0}function h(){if(this.pos+8>this.len)throw s(this,8);return new i(f(this.buf,this.pos+=4),f(this.buf,this.pos+=4))}u.create=p(),u.prototype._slice=o.Array.prototype.subarray||o.Array.prototype.slice,u.prototype.uint32=(l=4294967295,function(){if(l=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return l;if(l=(l|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return l;if(l=(l|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return l;if(l=(l|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return l;if(l=(l|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return l;if((this.pos+=5)>this.len)throw this.pos=this.len,s(this,10);return l}),u.prototype.int32=function(){return 0|this.uint32()},u.prototype.sint32=function(){var e=this.uint32();return e>>>1^-(1&e)|0},u.prototype.bool=function(){return 0!==this.uint32()},u.prototype.fixed32=function(){if(this.pos+4>this.len)throw s(this,4);return f(this.buf,this.pos+=4)},u.prototype.sfixed32=function(){if(this.pos+4>this.len)throw s(this,4);return 0|f(this.buf,this.pos+=4)},u.prototype.float=function(){if(this.pos+4>this.len)throw s(this,4);var e=o.float.readFloatLE(this.buf,this.pos);return this.pos+=4,e},u.prototype.double=function(){if(this.pos+8>this.len)throw s(this,4);var e=o.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,e},u.prototype.bytes=function(){var e=this.uint32(),t=this.pos,n=this.pos+e;if(n>this.len)throw s(this,e);return this.pos+=e,Array.isArray(this.buf)?this.buf.slice(t,n):t===n?new this.buf.constructor(0):this._slice.call(this.buf,t,n)},u.prototype.string=function(){var e=this.bytes();return a.read(e,0,e.length)},u.prototype.skip=function(e){if("number"==typeof e){if(this.pos+e>this.len)throw s(this,e);this.pos+=e}else do{if(this.pos>=this.len)throw s(this)}while(128&this.buf[this.pos++]);return this},u.prototype.skipType=function(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(e=7&this.uint32());)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+e+" at offset "+this.pos)}return this},u._configure=function(e){r=e,u.create=p(),r._configure();var t=o.Long?"toLong":"toNumber";o.merge(u.prototype,{int64:function(){return d.call(this)[t](!1)},uint64:function(){return d.call(this)[t](!0)},sint64:function(){return d.call(this).zzDecode()[t](!1)},fixed64:function(){return h.call(this)[t](!0)},sfixed64:function(){return h.call(this)[t](!1)}})}},593:(e,t,n)=>{"use strict";e.exports=i;var r=n(1408);(i.prototype=Object.create(r.prototype)).constructor=i;var o=n(9693);function i(e){r.call(this,e)}i._configure=function(){o.Buffer&&(i.prototype._slice=o.Buffer.prototype.slice)},i.prototype.string=function(){var e=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+e,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+e,this.len))},i._configure()},5054:e=>{"use strict";e.exports={}},5994:(e,t,n)=>{"use strict";t.Service=n(7948)},7948:(e,t,n)=>{"use strict";e.exports=o;var r=n(9693);function o(e,t,n){if("function"!=typeof e)throw TypeError("rpcImpl must be a function");r.EventEmitter.call(this),this.rpcImpl=e,this.requestDelimited=Boolean(t),this.responseDelimited=Boolean(n)}(o.prototype=Object.create(r.EventEmitter.prototype)).constructor=o,o.prototype.rpcCall=function e(t,n,o,i,a){if(!i)throw TypeError("request must be specified");var s=this;if(!a)return r.asPromise(e,s,t,n,o,i);if(s.rpcImpl)try{return s.rpcImpl(t,n[s.requestDelimited?"encodeDelimited":"encode"](i).finish(),(function(e,n){if(e)return s.emit("error",e,t),a(e);if(null!==n){if(!(n instanceof o))try{n=o[s.responseDelimited?"decodeDelimited":"decode"](n)}catch(e){return s.emit("error",e,t),a(e)}return s.emit("data",n,t),a(null,n)}s.end(!0)}))}catch(e){return s.emit("error",e,t),void setTimeout((function(){a(e)}),0)}else setTimeout((function(){a(Error("already ended"))}),0)},o.prototype.end=function(e){return this.rpcImpl&&(e||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(e,t,n)=>{"use strict";e.exports=o;var r=n(9693);function o(e,t){this.lo=e>>>0,this.hi=t>>>0}var i=o.zero=new o(0,0);i.toNumber=function(){return 0},i.zzEncode=i.zzDecode=function(){return this},i.length=function(){return 1};var a=o.zeroHash="\0\0\0\0\0\0\0\0";o.fromNumber=function(e){if(0===e)return i;var t=e<0;t&&(e=-e);var n=e>>>0,r=(e-n)/4294967296>>>0;return t&&(r=~r>>>0,n=~n>>>0,++n>4294967295&&(n=0,++r>4294967295&&(r=0))),new o(n,r)},o.from=function(e){if("number"==typeof e)return o.fromNumber(e);if(r.isString(e)){if(!r.Long)return o.fromNumber(parseInt(e,10));e=r.Long.fromString(e)}return e.low||e.high?new o(e.low>>>0,e.high>>>0):i},o.prototype.toNumber=function(e){if(!e&&this.hi>>>31){var t=1+~this.lo>>>0,n=~this.hi>>>0;return t||(n=n+1>>>0),-(t+4294967296*n)}return this.lo+4294967296*this.hi},o.prototype.toLong=function(e){return r.Long?new r.Long(0|this.lo,0|this.hi,Boolean(e)):{low:0|this.lo,high:0|this.hi,unsigned:Boolean(e)}};var s=String.prototype.charCodeAt;o.fromHash=function(e){return e===a?i:new o((s.call(e,0)|s.call(e,1)<<8|s.call(e,2)<<16|s.call(e,3)<<24)>>>0,(s.call(e,4)|s.call(e,5)<<8|s.call(e,6)<<16|s.call(e,7)<<24)>>>0)},o.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},o.prototype.zzEncode=function(){var e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this},o.prototype.zzDecode=function(){var e=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this},o.prototype.length=function(){var e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return 0===n?0===t?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10}},9693:function(e,t,n){"use strict";var r=t;function o(e,t,n){for(var r=Object.keys(t),o=0;o<r.length;++o)void 0!==e[r[o]]&&n||(e[r[o]]=t[r[o]]);return e}function i(e){function t(e,n){if(!(this instanceof t))return new t(e,n);Object.defineProperty(this,"message",{get:function(){return e}}),Error.captureStackTrace?Error.captureStackTrace(this,t):Object.defineProperty(this,"stack",{value:(new Error).stack||""}),n&&o(this,n)}return(t.prototype=Object.create(Error.prototype)).constructor=t,Object.defineProperty(t.prototype,"name",{get:function(){return e}}),t.prototype.toString=function(){return this.name+": "+this.message},t}r.asPromise=n(4537),r.base64=n(7419),r.EventEmitter=n(9211),r.float=n(945),r.inquire=n(7199),r.utf8=n(4997),r.pool=n(6662),r.LongBits=n(1945),r.isNode=Boolean(void 0!==n.g&&n.g&&n.g.process&&n.g.process.versions&&n.g.process.versions.node),r.global=r.isNode&&n.g||"undefined"!=typeof window&&window||"undefined"!=typeof self&&self||this,r.emptyArray=Object.freeze?Object.freeze([]):[],r.emptyObject=Object.freeze?Object.freeze({}):{},r.isInteger=Number.isInteger||function(e){return"number"==typeof e&&isFinite(e)&&Math.floor(e)===e},r.isString=function(e){return"string"==typeof e||e instanceof String},r.isObject=function(e){return e&&"object"==typeof e},r.isset=r.isSet=function(e,t){var n=e[t];return!(null==n||!e.hasOwnProperty(t))&&("object"!=typeof n||(Array.isArray(n)?n.length:Object.keys(n).length)>0)},r.Buffer=function(){try{var e=r.inquire("buffer").Buffer;return e.prototype.utf8Write?e:null}catch(e){return null}}(),r._Buffer_from=null,r._Buffer_allocUnsafe=null,r.newBuffer=function(e){return"number"==typeof e?r.Buffer?r._Buffer_allocUnsafe(e):new r.Array(e):r.Buffer?r._Buffer_from(e):"undefined"==typeof Uint8Array?e:new Uint8Array(e)},r.Array="undefined"!=typeof Uint8Array?Uint8Array:Array,r.Long=r.global.dcodeIO&&r.global.dcodeIO.Long||r.global.Long||r.inquire("long"),r.key2Re=/^true|false|0|1$/,r.key32Re=/^-?(?:0|[1-9][0-9]*)$/,r.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,r.longToHash=function(e){return e?r.LongBits.from(e).toHash():r.LongBits.zeroHash},r.longFromHash=function(e,t){var n=r.LongBits.fromHash(e);return r.Long?r.Long.fromBits(n.lo,n.hi,t):n.toNumber(Boolean(t))},r.merge=o,r.lcFirst=function(e){return e.charAt(0).toLowerCase()+e.substring(1)},r.newError=i,r.ProtocolError=i("ProtocolError"),r.oneOfGetter=function(e){for(var t={},n=0;n<e.length;++n)t[e[n]]=1;return function(){for(var e=Object.keys(this),n=e.length-1;n>-1;--n)if(1===t[e[n]]&&void 0!==this[e[n]]&&null!==this[e[n]])return e[n]}},r.oneOfSetter=function(e){return function(t){for(var n=0;n<e.length;++n)e[n]!==t&&delete this[e[n]]}},r.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},r._configure=function(){var e=r.Buffer;e?(r._Buffer_from=e.from!==Uint8Array.from&&e.from||function(t,n){return new e(t,n)},r._Buffer_allocUnsafe=e.allocUnsafe||function(t){return new e(t)}):r._Buffer_from=r._Buffer_allocUnsafe=null}},1173:(e,t,n)=>{"use strict";e.exports=p;var r,o=n(9693),i=o.LongBits,a=o.base64,s=o.utf8;function u(e,t,n){this.fn=e,this.len=t,this.next=void 0,this.val=n}function l(){}function c(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}function p(){this.len=0,this.head=new u(l,0,0),this.tail=this.head,this.states=null}var d=function(){return o.Buffer?function(){return(p.create=function(){return new r})()}:function(){return new p}};function f(e,t,n){t[n]=255&e}function h(e,t){this.len=e,this.next=void 0,this.val=t}function g(e,t,n){for(;e.hi;)t[n++]=127&e.lo|128,e.lo=(e.lo>>>7|e.hi<<25)>>>0,e.hi>>>=7;for(;e.lo>127;)t[n++]=127&e.lo|128,e.lo=e.lo>>>7;t[n++]=e.lo}function m(e,t,n){t[n]=255&e,t[n+1]=e>>>8&255,t[n+2]=e>>>16&255,t[n+3]=e>>>24}p.create=d(),p.alloc=function(e){return new o.Array(e)},o.Array!==Array&&(p.alloc=o.pool(p.alloc,o.Array.prototype.subarray)),p.prototype._push=function(e,t,n){return this.tail=this.tail.next=new u(e,t,n),this.len+=t,this},h.prototype=Object.create(u.prototype),h.prototype.fn=function(e,t,n){for(;e>127;)t[n++]=127&e|128,e>>>=7;t[n]=e},p.prototype.uint32=function(e){return this.len+=(this.tail=this.tail.next=new h((e>>>=0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this},p.prototype.int32=function(e){return e<0?this._push(g,10,i.fromNumber(e)):this.uint32(e)},p.prototype.sint32=function(e){return this.uint32((e<<1^e>>31)>>>0)},p.prototype.uint64=function(e){var t=i.from(e);return this._push(g,t.length(),t)},p.prototype.int64=p.prototype.uint64,p.prototype.sint64=function(e){var t=i.from(e).zzEncode();return this._push(g,t.length(),t)},p.prototype.bool=function(e){return this._push(f,1,e?1:0)},p.prototype.fixed32=function(e){return this._push(m,4,e>>>0)},p.prototype.sfixed32=p.prototype.fixed32,p.prototype.fixed64=function(e){var t=i.from(e);return this._push(m,4,t.lo)._push(m,4,t.hi)},p.prototype.sfixed64=p.prototype.fixed64,p.prototype.float=function(e){return this._push(o.float.writeFloatLE,4,e)},p.prototype.double=function(e){return this._push(o.float.writeDoubleLE,8,e)};var b=o.Array.prototype.set?function(e,t,n){t.set(e,n)}:function(e,t,n){for(var r=0;r<e.length;++r)t[n+r]=e[r]};p.prototype.bytes=function(e){var t=e.length>>>0;if(!t)return this._push(f,1,0);if(o.isString(e)){var n=p.alloc(t=a.length(e));a.decode(e,n,0),e=n}return this.uint32(t)._push(b,t,e)},p.prototype.string=function(e){var t=s.length(e);return t?this.uint32(t)._push(s.write,t,e):this._push(f,1,0)},p.prototype.fork=function(){return this.states=new c(this),this.head=this.tail=new u(l,0,0),this.len=0,this},p.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new u(l,0,0),this.len=0),this},p.prototype.ldelim=function(){var e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),n&&(this.tail.next=e.next,this.tail=t,this.len+=n),this},p.prototype.finish=function(){for(var e=this.head.next,t=this.constructor.alloc(this.len),n=0;e;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t},p._configure=function(e){r=e,p.create=d(),r._configure()}},3155:(e,t,n)=>{"use strict";e.exports=i;var r=n(1173);(i.prototype=Object.create(r.prototype)).constructor=i;var o=n(9693);function i(){r.call(this)}function a(e,t,n){e.length<40?o.utf8.write(e,t,n):t.utf8Write?t.utf8Write(e,n):t.write(e,n)}i._configure=function(){i.alloc=o._Buffer_allocUnsafe,i.writeBytesBuffer=o.Buffer&&o.Buffer.prototype instanceof Uint8Array&&"set"===o.Buffer.prototype.set.name?function(e,t,n){t.set(e,n)}:function(e,t,n){if(e.copy)e.copy(t,n,0,e.length);else for(var r=0;r<e.length;)t[n++]=e[r++]}},i.prototype.bytes=function(e){o.isString(e)&&(e=o._Buffer_from(e,"base64"));var t=e.length>>>0;return this.uint32(t),t&&this._push(i.writeBytesBuffer,t,e),this},i.prototype.string=function(e){var t=o.Buffer.byteLength(e);return this.uint32(t),t&&this._push(a,t,e),this},i._configure()},4154:e=>{"use strict";e.exports='"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\n'},7067:()=>{},1296:()=>{},760:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(e,t,n)=>{"use strict";n.r(t),n.d(t,{flatbuffers:()=>r});var r={};r.Offset,r.Table,r.SIZEOF_SHORT=2,r.SIZEOF_INT=4,r.FILE_IDENTIFIER_LENGTH=4,r.SIZE_PREFIX_LENGTH=4,r.Encoding={UTF8_BYTES:1,UTF16_STRING:2},r.int32=new Int32Array(2),r.float32=new Float32Array(r.int32.buffer),r.float64=new Float64Array(r.int32.buffer),r.isLittleEndian=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0],r.Long=function(e,t){this.low=0|e,this.high=0|t},r.Long.create=function(e,t){return 0==e&&0==t?r.Long.ZERO:new r.Long(e,t)},r.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},r.Long.prototype.equals=function(e){return this.low==e.low&&this.high==e.high},r.Long.ZERO=new r.Long(0,0),r.Builder=function(e){if(e)t=e;else var t=1024;this.bb=r.ByteBuffer.allocate(t),this.space=t,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.forceDefaults=function(e){this.force_defaults=e},r.Builder.prototype.dataBuffer=function(){return this.bb},r.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},r.Builder.prototype.prep=function(e,t){e>this.minalign&&(this.minalign=e);for(var n=1+~(this.bb.capacity()-this.space+t)&e-1;this.space<n+e+t;){var o=this.bb.capacity();this.bb=r.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-o}this.pad(n)},r.Builder.prototype.pad=function(e){for(var t=0;t<e;t++)this.bb.writeInt8(--this.space,0)},r.Builder.prototype.writeInt8=function(e){this.bb.writeInt8(this.space-=1,e)},r.Builder.prototype.writeInt16=function(e){this.bb.writeInt16(this.space-=2,e)},r.Builder.prototype.writeInt32=function(e){this.bb.writeInt32(this.space-=4,e)},r.Builder.prototype.writeInt64=function(e){this.bb.writeInt64(this.space-=8,e)},r.Builder.prototype.writeFloat32=function(e){this.bb.writeFloat32(this.space-=4,e)},r.Builder.prototype.writeFloat64=function(e){this.bb.writeFloat64(this.space-=8,e)},r.Builder.prototype.addInt8=function(e){this.prep(1,0),this.writeInt8(e)},r.Builder.prototype.addInt16=function(e){this.prep(2,0),this.writeInt16(e)},r.Builder.prototype.addInt32=function(e){this.prep(4,0),this.writeInt32(e)},r.Builder.prototype.addInt64=function(e){this.prep(8,0),this.writeInt64(e)},r.Builder.prototype.addFloat32=function(e){this.prep(4,0),this.writeFloat32(e)},r.Builder.prototype.addFloat64=function(e){this.prep(8,0),this.writeFloat64(e)},r.Builder.prototype.addFieldInt8=function(e,t,n){(this.force_defaults||t!=n)&&(this.addInt8(t),this.slot(e))},r.Builder.prototype.addFieldInt16=function(e,t,n){(this.force_defaults||t!=n)&&(this.addInt16(t),this.slot(e))},r.Builder.prototype.addFieldInt32=function(e,t,n){(this.force_defaults||t!=n)&&(this.addInt32(t),this.slot(e))},r.Builder.prototype.addFieldInt64=function(e,t,n){!this.force_defaults&&t.equals(n)||(this.addInt64(t),this.slot(e))},r.Builder.prototype.addFieldFloat32=function(e,t,n){(this.force_defaults||t!=n)&&(this.addFloat32(t),this.slot(e))},r.Builder.prototype.addFieldFloat64=function(e,t,n){(this.force_defaults||t!=n)&&(this.addFloat64(t),this.slot(e))},r.Builder.prototype.addFieldOffset=function(e,t,n){(this.force_defaults||t!=n)&&(this.addOffset(t),this.slot(e))},r.Builder.prototype.addFieldStruct=function(e,t,n){t!=n&&(this.nested(t),this.slot(e))},r.Builder.prototype.nested=function(e){if(e!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},r.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},r.Builder.prototype.slot=function(e){this.vtable[e]=this.offset()},r.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},r.Builder.growByteBuffer=function(e){var t=e.capacity();if(3221225472&t)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var n=t<<1,o=r.ByteBuffer.allocate(n);return o.setPosition(n-t),o.bytes().set(e.bytes(),n-t),o},r.Builder.prototype.addOffset=function(e){this.prep(r.SIZEOF_INT,0),this.writeInt32(this.offset()-e+r.SIZEOF_INT)},r.Builder.prototype.startObject=function(e){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=e;for(var t=0;t<e;t++)this.vtable[t]=0;this.isNested=!0,this.object_start=this.offset()},r.Builder.prototype.endObject=function(){if(null==this.vtable||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var e=this.offset(),t=this.vtable_in_use-1;t>=0&&0==this.vtable[t];t--);for(var n=t+1;t>=0;t--)this.addInt16(0!=this.vtable[t]?e-this.vtable[t]:0);this.addInt16(e-this.object_start);var o=(n+2)*r.SIZEOF_SHORT;this.addInt16(o);var i=0,a=this.space;e:for(t=0;t<this.vtables.length;t++){var s=this.bb.capacity()-this.vtables[t];if(o==this.bb.readInt16(s)){for(var u=r.SIZEOF_SHORT;u<o;u+=r.SIZEOF_SHORT)if(this.bb.readInt16(a+u)!=this.bb.readInt16(s+u))continue e;i=this.vtables[t];break}}return i?(this.space=this.bb.capacity()-e,this.bb.writeInt32(this.space,i-e)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-e,this.offset()-e)),this.isNested=!1,e},r.Builder.prototype.finish=function(e,t,n){var o=n?r.SIZE_PREFIX_LENGTH:0;if(t){var i=t;if(this.prep(this.minalign,r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH+o),i.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+r.FILE_IDENTIFIER_LENGTH);for(var a=r.FILE_IDENTIFIER_LENGTH-1;a>=0;a--)this.writeInt8(i.charCodeAt(a))}this.prep(this.minalign,r.SIZEOF_INT+o),this.addOffset(e),o&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},r.Builder.prototype.finishSizePrefixed=function(e,t){this.finish(e,t,!0)},r.Builder.prototype.requiredField=function(e,t){var n=this.bb.capacity()-e,r=n-this.bb.readInt32(n);if(0==this.bb.readInt16(r+t))throw new Error("FlatBuffers: field "+t+" must be set")},r.Builder.prototype.startVector=function(e,t,n){this.notNested(),this.vector_num_elems=t,this.prep(r.SIZEOF_INT,e*t),this.prep(n,e*t)},r.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},r.Builder.prototype.createString=function(e){if(e instanceof Uint8Array)var t=e;else{t=[];for(var n=0;n<e.length;){var r,o=e.charCodeAt(n++);(r=o<55296||o>=56320?o:(o<<10)+e.charCodeAt(n++)+-56613888)<128?t.push(r):(r<2048?t.push(r>>6&31|192):(r<65536?t.push(r>>12&15|224):t.push(r>>18&7|240,r>>12&63|128),t.push(r>>6&63|128)),t.push(63&r|128))}}this.addInt8(0),this.startVector(1,t.length,1),this.bb.setPosition(this.space-=t.length),n=0;for(var i=this.space,a=this.bb.bytes();n<t.length;n++)a[i++]=t[n];return this.endVector()},r.Builder.prototype.createLong=function(e,t){return r.Long.create(e,t)},r.ByteBuffer=function(e){this.bytes_=e,this.position_=0},r.ByteBuffer.allocate=function(e){return new r.ByteBuffer(new Uint8Array(e))},r.ByteBuffer.prototype.clear=function(){this.position_=0},r.ByteBuffer.prototype.bytes=function(){return this.bytes_},r.ByteBuffer.prototype.position=function(){return this.position_},r.ByteBuffer.prototype.setPosition=function(e){this.position_=e},r.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},r.ByteBuffer.prototype.readInt8=function(e){return this.readUint8(e)<<24>>24},r.ByteBuffer.prototype.readUint8=function(e){return this.bytes_[e]},r.ByteBuffer.prototype.readInt16=function(e){return this.readUint16(e)<<16>>16},r.ByteBuffer.prototype.readUint16=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8},r.ByteBuffer.prototype.readInt32=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8|this.bytes_[e+2]<<16|this.bytes_[e+3]<<24},r.ByteBuffer.prototype.readUint32=function(e){return this.readInt32(e)>>>0},r.ByteBuffer.prototype.readInt64=function(e){return new r.Long(this.readInt32(e),this.readInt32(e+4))},r.ByteBuffer.prototype.readUint64=function(e){return new r.Long(this.readUint32(e),this.readUint32(e+4))},r.ByteBuffer.prototype.readFloat32=function(e){return r.int32[0]=this.readInt32(e),r.float32[0]},r.ByteBuffer.prototype.readFloat64=function(e){return r.int32[r.isLittleEndian?0:1]=this.readInt32(e),r.int32[r.isLittleEndian?1:0]=this.readInt32(e+4),r.float64[0]},r.ByteBuffer.prototype.writeInt8=function(e,t){this.bytes_[e]=t},r.ByteBuffer.prototype.writeUint8=function(e,t){this.bytes_[e]=t},r.ByteBuffer.prototype.writeInt16=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8},r.ByteBuffer.prototype.writeUint16=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8},r.ByteBuffer.prototype.writeInt32=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8,this.bytes_[e+2]=t>>16,this.bytes_[e+3]=t>>24},r.ByteBuffer.prototype.writeUint32=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8,this.bytes_[e+2]=t>>16,this.bytes_[e+3]=t>>24},r.ByteBuffer.prototype.writeInt64=function(e,t){this.writeInt32(e,t.low),this.writeInt32(e+4,t.high)},r.ByteBuffer.prototype.writeUint64=function(e,t){this.writeUint32(e,t.low),this.writeUint32(e+4,t.high)},r.ByteBuffer.prototype.writeFloat32=function(e,t){r.float32[0]=t,this.writeInt32(e,r.int32[0])},r.ByteBuffer.prototype.writeFloat64=function(e,t){r.float64[0]=t,this.writeInt32(e,r.int32[r.isLittleEndian?0:1]),this.writeInt32(e+4,r.int32[r.isLittleEndian?1:0])},r.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var e="",t=0;t<r.FILE_IDENTIFIER_LENGTH;t++)e+=String.fromCharCode(this.readInt8(this.position_+r.SIZEOF_INT+t));return e},r.ByteBuffer.prototype.__offset=function(e,t){var n=e-this.readInt32(e);return t<this.readInt16(n)?this.readInt16(n+t):0},r.ByteBuffer.prototype.__union=function(e,t){return e.bb_pos=t+this.readInt32(t),e.bb=this,e},r.ByteBuffer.prototype.__string=function(e,t){e+=this.readInt32(e);var n=this.readInt32(e),o="",i=0;if(e+=r.SIZEOF_INT,t===r.Encoding.UTF8_BYTES)return this.bytes_.subarray(e,e+n);for(;i<n;){var a,s=this.readUint8(e+i++);if(s<192)a=s;else{var u=this.readUint8(e+i++);if(s<224)a=(31&s)<<6|63&u;else{var l=this.readUint8(e+i++);a=s<240?(15&s)<<12|(63&u)<<6|63&l:(7&s)<<18|(63&u)<<12|(63&l)<<6|63&this.readUint8(e+i++)}}a<65536?o+=String.fromCharCode(a):(a-=65536,o+=String.fromCharCode(55296+(a>>10),56320+(1023&a)))}return o},r.ByteBuffer.prototype.__indirect=function(e){return e+this.readInt32(e)},r.ByteBuffer.prototype.__vector=function(e){return e+this.readInt32(e)+r.SIZEOF_INT},r.ByteBuffer.prototype.__vector_len=function(e){return this.readInt32(e+this.readInt32(e))},r.ByteBuffer.prototype.__has_identifier=function(e){if(e.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+r.FILE_IDENTIFIER_LENGTH);for(var t=0;t<r.FILE_IDENTIFIER_LENGTH;t++)if(e.charCodeAt(t)!=this.readInt8(this.position_+r.SIZEOF_INT+t))return!1;return!0},r.ByteBuffer.prototype.createLong=function(e,t){return r.Long.create(e,t)}}},__webpack_module_cache__={};function __nested_webpack_require_606622__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var n=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(n.exports,n,n.exports,__nested_webpack_require_606622__),n.exports}__nested_webpack_require_606622__.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return __nested_webpack_require_606622__.d(t,{a:t}),t},__nested_webpack_require_606622__.d=(e,t)=>{for(var n in t)__nested_webpack_require_606622__.o(t,n)&&!__nested_webpack_require_606622__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__nested_webpack_require_606622__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__nested_webpack_require_606622__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__nested_webpack_require_606622__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __nested_webpack_exports__=__nested_webpack_require_606622__(1057);return __nested_webpack_exports__})()));
//# sourceMappingURL=ort.min.js.map

/***/ }),

/***/ "./src/icons/call.svg":
/*!****************************!*\
  !*** ./src/icons/call.svg ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n    zoomAndPan=\"magnify\" viewBox=\"0 0 768 767.999994\"\n    preserveAspectRatio=\"xMidYMid meet\" version=\"1.0\">\n    <path class=\"circle\" fill=\"#418a2f\"\n        d=\"M 767.988281 383.984375 C 767.988281 596.058594 596.066406 767.980469 383.996094 767.980469 C 171.921875 767.980469 0 596.058594 0 383.984375 C 0 171.910156 171.921875 -0.0078125 383.996094 -0.0078125 C 596.066406 -0.0078125 767.988281 171.910156 767.988281 383.984375 \"\n        fill-opacity=\"1\" fill-rule=\"nonzero\" />\n    <path class=\"phone-receiver\" fill=\"#ffffff\"\n        d=\"M 215.726562 199.773438 C 219.746094 194.835938 230.023438 183.625 243.644531 183.769531 C 244.40625 183.777344 245.300781 183.808594 246.34375 183.914062 C 246.34375 183.914062 248.492188 184.144531 250.613281 184.703125 C 268.292969 189.410156 299.921875 224.304688 299.921875 224.304688 C 326.925781 254.09375 334.722656 255.53125 334.636719 266.5 C 334.550781 276.777344 328.140625 284.71875 316.253906 296.566406 C 284.566406 328.148438 277.808594 330.53125 275.351562 340.421875 C 273.902344 346.234375 269.539062 357.511719 289.105469 379.355469 C 318.289062 411.929688 388.1875 478.4375 394.300781 482.515625 C 400.402344 486.585938 422.121094 500.832031 451.300781 474.371094 C 471.226562 456.304688 480.714844 435.066406 494.875 433.785156 C 502.363281 433.089844 507.878906 437.613281 519.167969 447.222656 C 585.886719 503.976562 586.871094 513.933594 586.3125 519.824219 C 585.355469 530.011719 580.75 539.210938 565.316406 550.382812 C 525.953125 578.878906 508.3125 603.992188 428.234375 570.742188 C 348.152344 537.484375 263.996094 453.335938 240.242188 417.359375 C 216.488281 381.390625 179.160156 326.421875 181.878906 288.414062 C 183.769531 261.980469 191.867188 238.863281 191.867188 238.863281 C 199.097656 220.882812 208.71875 207.878906 215.726562 199.773438 \"\n        fill-opacity=\"1\" fill-rule=\"nonzero\" />\n</svg>");

/***/ }),

/***/ "./src/icons/exit.svg":
/*!****************************!*\
  !*** ./src/icons/exit.svg ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg id=\"Layer_1\" data-name=\"Layer 1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 64.06 64.33\">\n  <defs>\n    <style>\n      .inner {\n        fill: #24381b;\n      }\n\n      .inner, .outer {\n        stroke-width: 0px;\n      }\n\n      .outer {\n        fill: #dfd7c2;\n      }\n    </style>\n  </defs>\n  <path class=\"outer\" d=\"m31.71,64.32C14.77,64.46-.44,49.93,0,31.33.41,14.47,14.29-.32,32.7,0c16.91.3,31.8,14.32,31.36,33.14-.39,16.76-14.49,31.55-32.34,31.18Zm10.67-23.19c.06-.7-.41-1.12-.84-1.55-2-2-3.94-4.07-6.02-5.97-1.14-1.04-1.32-1.68-.06-2.82,2.13-1.93,4.07-4.08,6.1-6.12.78-.79,1.31-1.64.34-2.56-.92-.87-1.72-.28-2.43.45-2.17,2.21-4.39,4.39-6.52,6.65-.72.77-1.16.7-1.84-.02-2.06-2.17-4.19-4.28-6.29-6.41-.76-.77-1.59-1.68-2.66-.63-1.14,1.12-.19,1.98.62,2.79,2.07,2.09,4.09,4.22,6.2,6.26.77.75.82,1.2.02,1.97-2.21,2.1-4.33,4.3-6.49,6.45-.79.78-1.3,1.65-.32,2.56.92.85,1.71.26,2.43-.47,2.11-2.12,4.28-4.19,6.33-6.38.88-.94,1.37-.86,2.21.03,2.13,2.26,4.37,4.41,6.57,6.6.51.51,1.09.78,1.8.48.56-.24.85-.68.87-1.3Z\"/>\n  <path class=\"inner\" d=\"m42.47,41.27c-.02.62-.32,1.06-.87,1.3-.71.31-1.29.03-1.8-.48-2.2-2.2-4.44-4.35-6.57-6.6-.84-.89-1.33-.96-2.21-.03-2.04,2.19-4.22,4.25-6.33,6.38-.72.72-1.51,1.32-2.43.47-.98-.91-.47-1.78.32-2.56,2.16-2.15,4.28-4.35,6.49-6.45.81-.77.76-1.22-.02-1.97-2.11-2.04-4.13-4.17-6.2-6.26-.8-.81-1.75-1.67-.62-2.79,1.07-1.05,1.9-.14,2.66.63,2.1,2.13,4.23,4.24,6.29,6.41.69.73,1.12.79,1.84.02,2.13-2.26,4.35-4.43,6.52-6.65.72-.73,1.51-1.31,2.43-.45.97.92.44,1.78-.34,2.56-2.03,2.04-3.97,4.19-6.1,6.12-1.25,1.14-1.08,1.78.06,2.82,2.09,1.91,4.02,3.97,6.02,5.97.43.43.9.85.84,1.55Z\"/>\n</svg>");

/***/ }),

/***/ "./src/icons/hangup.svg":
/*!******************************!*\
  !*** ./src/icons/hangup.svg ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n    zoomAndPan=\"magnify\" viewBox=\"0 0 768 767.999994\"\n    preserveAspectRatio=\"xMidYMid meet\" version=\"1.0\">\n    <path fill=\"#776d6d\"\n        d=\"M 768 384 C 768 596.074219 596.074219 768 384 768 C 171.925781 768 0 596.074219 0 384 C 0 171.925781 171.925781 0 384 0 C 596.074219 0 768 171.925781 768 384 \"\n        fill-opacity=\"1\" fill-rule=\"nonzero\" />\n    <path fill=\"#ffffff\"\n        d=\"M 153.695312 418.96875 C 153.71875 418.972656 167.773438 455.105469 183.636719 464.507812 C 193.925781 470.585938 202.523438 467.320312 213.625 462.085938 C 235.234375 451.890625 257.347656 442.476562 280.480469 435.953125 C 286.855469 434.152344 290.832031 427.890625 289.265625 421.722656 C 286.402344 410.6875 283.480469 399.660156 280.507812 388.644531 C 278.808594 382.511719 283.523438 375.988281 291.148438 374.363281 C 320.28125 368.128906 350.152344 364.921875 380.039062 364.769531 C 381.359375 364.769531 386.640625 364.769531 387.960938 364.769531 C 417.847656 364.921875 447.714844 368.128906 476.851562 374.363281 C 484.476562 375.988281 489.191406 382.511719 487.492188 388.644531 C 484.519531 399.660156 481.597656 410.6875 478.734375 421.722656 C 477.167969 427.890625 481.144531 434.152344 487.519531 435.953125 C 510.652344 442.476562 532.765625 451.890625 554.375 462.085938 C 565.476562 467.320312 574.074219 470.585938 584.363281 464.507812 C 600.226562 455.105469 614.28125 418.972656 614.304688 418.96875 C 627.664062 390.730469 619.042969 359.117188 582.167969 342.550781 C 519.960938 314.839844 457.320312 300.640625 388.140625 300.203125 C 386.765625 300.203125 381.238281 300.203125 379.855469 300.203125 C 310.679688 300.640625 248.039062 314.839844 185.832031 342.550781 C 148.949219 359.117188 140.335938 390.730469 153.695312 418.96875 \"\n        fill-opacity=\"1\" fill-rule=\"nonzero\" />\n</svg>");

/***/ }),

/***/ "./src/icons/maximize.svg":
/*!********************************!*\
  !*** ./src/icons/maximize.svg ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n    zoomAndPan=\"magnify\" viewBox=\"0 0 768 767.999994\" preserveAspectRatio=\"xMidYMid meet\"\n    version=\"1.0\">\n    <path fill=\"#e4d8c1\" class=\"outer\"\n        d=\"M 768.132812 379.535156 C 768.132812 169.089844 597.523438 -1.496094 387.050781 -1.496094 C 176.609375 -1.496094 5.996094 169.089844 5.996094 379.535156 C 5.996094 589.949219 176.609375 760.539062 387.050781 760.539062 C 597.523438 760.539062 768.132812 589.949219 768.132812 379.535156 \"\n        fill-opacity=\"1\" fill-rule=\"nonzero\" />\n    <path fill=\"#776d6d\" class=\"inner\"\n        d=\"M 538.996094 223.152344 L 306.535156 229.855469 L 538.996094 455.695312 Z M 538.996094 223.152344 \"\n        fill-opacity=\"1\" fill-rule=\"nonzero\" />\n    <path fill=\"#776d6d\" class=\"inner\"\n        d=\"M 235.105469 535.890625 L 467.597656 529.1875 L 235.105469 303.34375 Z M 235.105469 535.890625 \"\n        fill-opacity=\"1\" fill-rule=\"nonzero\" />\n</svg>");

/***/ }),

/***/ "./src/icons/muted_microphone.svg":
/*!****************************************!*\
  !*** ./src/icons/muted_microphone.svg ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"500\" zoomAndPan=\"magnify\" viewBox=\"0 0 375 374.999991\" height=\"500\" preserveAspectRatio=\"xMidYMid meet\" version=\"1.0\"><path fill=\"#776d6d\" d=\"M 239.722656 126.441406 L 239.722656 122.300781 C 239.722656 93.507812 216.296875 70.078125 187.5 70.078125 C 158.703125 70.078125 135.277344 93.507812 135.277344 122.300781 L 135.277344 187.953125 C 135.277344 199.988281 139.410156 211.050781 146.273438 219.890625 Z M 239.722656 126.441406 \" fill-opacity=\"1\" fill-rule=\"nonzero\"/><path fill=\"#776d6d\" d=\"M 155.046875 228.792969 C 163.964844 235.898438 175.234375 240.175781 187.5 240.175781 C 216.296875 240.175781 239.722656 216.75 239.722656 187.953125 L 239.722656 144.113281 Z M 155.046875 228.792969 \" fill-opacity=\"1\" fill-rule=\"nonzero\"/><path fill=\"#776d6d\" d=\"M 187.5 0 C 83.945312 0 0 83.945312 0 187.5 C 0 291.054688 83.945312 375 187.5 375 C 291.054688 375 375 291.054688 375 187.5 C 375 83.945312 291.054688 0 187.5 0 Z M 287.484375 96.355469 L 254.640625 129.195312 L 254.640625 187.953125 C 254.640625 224.976562 224.523438 255.097656 187.5 255.097656 C 171.117188 255.097656 156.105469 249.183594 144.4375 239.402344 L 138.109375 245.730469 C 151.417969 257.121094 168.652344 264.046875 187.5 264.046875 C 229.457031 264.046875 263.59375 229.914062 263.59375 187.953125 C 263.59375 183.832031 266.933594 180.496094 271.054688 180.496094 C 275.175781 180.496094 278.515625 183.835938 278.515625 187.953125 C 278.515625 235.625 241.667969 274.828125 194.960938 278.640625 L 194.960938 304.921875 L 220.121094 304.921875 C 224.242188 304.921875 227.582031 308.261719 227.582031 312.382812 C 227.582031 316.5 224.242188 319.839844 220.121094 319.839844 L 154.875 319.839844 C 150.757812 319.839844 147.417969 316.5 147.417969 312.382812 C 147.417969 308.261719 150.757812 304.921875 154.875 304.921875 L 180.039062 304.921875 L 180.039062 278.636719 C 160.007812 277.003906 141.816406 268.824219 127.542969 256.296875 L 96.351562 287.484375 C 95.132812 288.703125 93.53125 289.316406 91.933594 289.316406 C 90.335938 289.316406 88.734375 288.703125 87.515625 287.484375 C 85.074219 285.042969 85.074219 281.085938 87.515625 278.644531 L 118.761719 247.398438 C 104.929688 231.4375 96.484375 210.6875 96.484375 187.953125 C 96.484375 183.832031 99.824219 180.496094 103.941406 180.496094 C 108.0625 180.496094 111.402344 183.835938 111.402344 187.953125 C 111.402344 206.574219 118.148438 223.628906 129.292969 236.867188 L 135.628906 230.53125 C 126.089844 218.9375 120.355469 204.105469 120.355469 187.953125 L 120.355469 122.300781 C 120.355469 85.28125 150.476562 55.160156 187.496094 55.160156 C 221.128906 55.160156 248.980469 80.039062 253.816406 112.34375 L 278.640625 87.515625 C 281.082031 85.078125 285.039062 85.078125 287.480469 87.515625 C 289.925781 89.957031 289.925781 93.914062 287.484375 96.355469 Z M 287.484375 96.355469 \" fill-opacity=\"1\" fill-rule=\"nonzero\"/></svg>");

/***/ }),

/***/ "./src/icons/rectangles.svg":
/*!**********************************!*\
  !*** ./src/icons/rectangles.svg ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg id=\"Layer_1\" data-name=\"Layer 1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 307 640\">\n  <defs>\n    <style>\n      .innermost, .second, .third, .fourth, .fifth, .outermost {\n        stroke-width: 0px;\n      }\n      \n      .outermost {\n        fill: #e4f2d1;\n      }\n\n      .second {\n        fill: #cce8b5;\n      }\n\n      .third {\n        fill: #b3db95;\n      }\n\n      .fourth {\n        fill: #9bd078;\n      }\n\n      .fifth {\n        fill: #83c55c;\n      }\n\n      .innermost {\n        fill: #428a2f;\n      }\n    </style>\n  </defs>\n  <path class=\"outermost\" d=\"m306.9,320c0,105.3-.02,210.6.1,315.91,0,3.42-.67,4.1-4.09,4.09-99.6-.12-199.21-.12-298.81,0C.67,640,0,639.33,0,635.91.11,425.3.11,214.7,0,4.09,0,.67.67,0,4.09,0,103.7.12,203.3.12,302.91,0c3.42,0,4.1.67,4.09,4.09-.12,105.3-.1,210.6-.1,315.91Z\"/>\n  <path class=\"second\" d=\"m275.92,323c0,87.63,0,175.27,0,262.9,0,7.24-.55,7.93-7.86,7.98-14.66.09-29.31.03-43.97.03-60.96,0-121.92,0-182.88,0q-7.13,0-7.14-7.24c0-176.1,0-352.21,0-528.31q0-7.26,7.12-7.26c75.78,0,151.56,0,227.35,0q7.38,0,7.38,7.5c0,88.13,0,176.27,0,264.4Z\"/>\n  <path class=\"third\" d=\"m68.06,322.24c0-69.47,0-138.94,0-208.41,0-8.99,1.33-10.13,10.49-9.12,1.98.22,3.98.32,5.97.32,46.13.02,92.26.02,138.39,0,3.48,0,6.92-.23,10.41-.67,5.5-.7,8.74.46,8.73,7.25-.18,138.94-.13,277.88-.13,416.81,0,.33,0,.67,0,1q-.14,10.51-10.39,10.51c-52.13,0-104.25,0-156.38,0q-7.09,0-7.09-7.28c0-70.14,0-140.27,0-210.41Z\"/>\n  <path class=\"fourth\" d=\"m103.02,322.5c0-52.46,0-104.91,0-157.37,0-6.68.36-7.06,7.07-7.06,30.3-.01,60.6.07,90.9-.09,4.54-.02,6.08,1.33,6.07,5.98-.1,105.58-.1,211.16,0,316.74,0,4.18-1.27,5.37-5.38,5.35-29.3-.15-58.6-.08-87.9-.08q-10.76,0-10.76-11.09c0-50.79,0-101.58,0-152.37Z\"/>\n  <path class=\"fifth\" d=\"m173,322.2c0,35.29,0,70.58,0,105.88q0,6.89-6.99,6.9c-8.15,0-16.31-.13-24.46.06-3.47.08-4.68-1.09-4.61-4.59.18-9.65.06-19.31.06-28.96,0-58.26-.01-116.53.02-174.79,0-4.76-1.12-9.46-.14-14.3.51-2.54,1.39-3.38,3.8-3.36,8.82.06,17.64.14,26.46-.02,4.59-.09,5.95,1.85,5.94,6.33-.14,35.62-.08,71.25-.08,106.87Z\"/>\n  <path class=\"innermost\" d=\"m151.04,322.01c0-9.99.07-19.97-.05-29.96-.04-2.93.83-4.18,3.95-4.18,3.06,0,4.03,1.12,4.02,4.11-.09,19.97-.08,39.94.01,59.91.01,2.96-.84,4.16-3.96,4.14-3.03-.01-4.08-1.04-4.03-4.08.14-9.98.05-19.97.05-29.96Z\"/>\n</svg>");

/***/ }),

/***/ "./src/icons/waveform.svg":
/*!********************************!*\
  !*** ./src/icons/waveform.svg ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.0\" viewBox=\"0 0 56.25 30\" class=\"waveform\">\n    <defs>\n        <clipPath id=\"a\">\n            <path d=\"M.54 12H3v5H.54Zm0 0\"/>\n        </clipPath>\n        <clipPath id=\"b\">\n            <path d=\"M25 2.2h2v24.68h-2Zm0 0\"/>\n        </clipPath>\n        <clipPath id=\"c\">\n            <path d=\"M53 12h1.98v5H53Zm0 0\"/>\n        </clipPath>\n    </defs>\n    <g clip-path=\"url(#a)\">\n        <path d=\"M1.48 12.71c-.5 0-.9.4-.9.9v1.85a.9.9 0 0 0 1.8 0v-1.84c0-.5-.4-.9-.9-.9Zm0 0\"/>\n    </g>\n    <path d=\"M4.98 6.63c-.5 0-.9.4-.9.9v14.01a.9.9 0 0 0 1.81 0v-14c0-.5-.4-.92-.9-.92Zm3.51 3.1a.9.9 0 0 0-.9.91v7.79a.9.9 0 0 0 1.8 0v-7.79c0-.5-.4-.9-.9-.9ZM12 3.83a.9.9 0 0 0-.91.9v19.6a.9.9 0 0 0 1.8 0V4.74c0-.5-.4-.9-.9-.9Zm3.5 8.29a.9.9 0 0 0-.91.9v3.03a.9.9 0 0 0 1.81 0v-3.03c0-.5-.4-.9-.9-.9ZM19 6.8c-.5 0-.9.4-.9.9v13.68a.9.9 0 0 0 1.8 0V7.7c0-.5-.4-.9-.9-.9Zm3.58-2.97h-.01c-.5 0-.9.4-.9.9l-.13 19.6c0 .5.4.9.9.91.5 0 .9-.4.9-.9l.14-19.6a.9.9 0 0 0-.9-.9Zm0 0\"/>\n    <g clip-path=\"url(#b)\">\n        <path d=\"M26 2.2c-.5 0-.9.4-.9.9v22.86a.9.9 0 1 0 1.81 0V3.11a.9.9 0 0 0-.9-.91Zm0 0\"/>\n    </g>\n    <path d=\"M29.52 7.71a.9.9 0 0 0-.91.9v11.85a.9.9 0 0 0 1.81 0V8.62c0-.5-.4-.9-.9-.9Zm3.5 2.93a.9.9 0 0 0-.9.91v5.97a.9.9 0 0 0 1.8 0v-5.97c0-.5-.4-.9-.9-.9Zm3.5-5.78c-.5 0-.9.4-.9.9v17.55a.9.9 0 0 0 1.81 0V5.76c0-.5-.4-.9-.9-.9Zm3.51 3.34c-.5 0-.9.4-.9.9v10.87a.9.9 0 0 0 1.8 0V9.1a.9.9 0 0 0-.9-.91Zm3.5 3.08c-.5 0-.9.4-.9.91v4.7a.9.9 0 1 0 1.8 0v-4.7a.9.9 0 0 0-.9-.9Zm3.51-7.45a.9.9 0 0 0-.91.9v19.6a.9.9 0 0 0 1.81 0V4.74c0-.5-.4-.9-.9-.9Zm3.5 5.57a.9.9 0 0 0-.9.91v8.45a.9.9 0 0 0 1.8 0v-8.45c0-.5-.4-.9-.9-.9Zm0 0\"/>\n    <g clip-path=\"url(#c)\">\n        <path d=\"M54.04 12.96a.9.9 0 0 0-.9.91v1.33a.9.9 0 1 0 1.8 0v-1.32a.9.9 0 0 0-.9-.92Zm0 0\"/>\n    </g>\n</svg>");

/***/ }),

/***/ "./src/styles/rectangles.css":
/*!***********************************!*\
  !*** ./src/styles/rectangles.css ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_rectangles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./rectangles.css */ "./node_modules/css-loader/dist/cjs.js!./src/styles/rectangles.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_rectangles_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_rectangles_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_rectangles_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_rectangles_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/styles/common.scss":
/*!********************************!*\
  !*** ./src/styles/common.scss ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_3_use_2_common_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!../../node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./common.scss */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./src/styles/common.scss");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_3_use_2_common_scss__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_3_use_2_common_scss__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_3_use_2_common_scss__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_3_use_2_common_scss__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/styles/desktop.scss":
/*!*********************************!*\
  !*** ./src/styles/desktop.scss ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_3_use_2_desktop_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!../../node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./desktop.scss */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./src/styles/desktop.scss");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_3_use_2_desktop_scss__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_3_use_2_desktop_scss__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_3_use_2_desktop_scss__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_3_use_2_desktop_scss__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/styles/mobile.scss":
/*!********************************!*\
  !*** ./src/styles/mobile.scss ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_3_use_2_mobile_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!../../node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./mobile.scss */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./src/styles/mobile.scss");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_3_use_2_mobile_scss__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_3_use_2_mobile_scss__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_3_use_2_mobile_scss__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_3_use_1_node_modules_sass_loader_dist_cjs_js_ruleSet_1_rules_3_use_2_mobile_scss__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./src/AudioEncoder.ts":
/*!*****************************!*\
  !*** ./src/AudioEncoder.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertToWavBlob = exports.convertToWavBuffer = void 0;
const WavEncoder_1 = __webpack_require__(/*! ./WavEncoder */ "./src/WavEncoder.ts");
/**
 * Convert a Float32Array of audio samples to a WAV array buffer
 * @param audioData - The audio samples
 * @returns - The audio in WAV format as an ArrayBuffer
 */
function convertToWavBuffer(audioData) {
    const arrayBuffer = (0, WavEncoder_1.encodeWAV)(audioData);
    return arrayBuffer;
}
exports.convertToWavBuffer = convertToWavBuffer;
/**
 * Convert a Float32Array of audio samples to a WAV Blob
 * @param audioData - The audio samples
 * @returns - The audio in WAV format
 */
function convertToWavBlob(audioData) {
    const arrayBuffer = convertToWavBuffer(audioData);
    return new Blob([arrayBuffer], { type: "audio/wav" });
}
exports.convertToWavBlob = convertToWavBlob;


/***/ }),

/***/ "./src/DOMModule.ts":
/*!**************************!*\
  !*** ./src/DOMModule.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.appendChild = void 0;
function appendChild(parent, child, position = 0) {
    // Check if a container is provided.
    if (parent) {
        // If position is 0, simply append the button as the last child.
        if (position === 0) {
            parent.appendChild(child);
        }
        else {
            // Calculate the index of the reference node for insertBefore().
            const referenceIndex = parent.children.length + position;
            const referenceNode = parent.children[referenceIndex];
            // If a reference node exists, insert the button before it.
            if (referenceNode) {
                parent.insertBefore(child, referenceNode);
            }
            else {
                // If not, append the button as the last child.
                parent.appendChild(child);
            }
        }
    }
    else {
        // If no container is provided, append the button to the body.
        document.body.appendChild(child);
    }
}
exports.appendChild = appendChild;


/***/ }),

/***/ "./src/SubmitErrorHandler.ts":
/*!***********************************!*\
  !*** ./src/SubmitErrorHandler.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.submitErrorHandler = void 0;
const TranscriptionModule_1 = __webpack_require__(/*! ./TranscriptionModule */ "./src/TranscriptionModule.ts");
class SubmitErrorHandler {
    constructor() {
        this.audioOutputStatus = false;
        // Initialise properties if needed
        this.restorePointKey = "restorePoint";
    }
    initAudioOutputListener() {
        const audioOutputButton = document.getElementById("saypi-audio-output-button");
        if (audioOutputButton) {
            audioOutputButton.addEventListener("click", this.handleAudioOutputClick.bind(this));
        }
    }
    // Event handler
    handleAudioOutputClick() {
        this.audioOutputStatus = !this.audioOutputStatus; // Toggle the state
    }
    // 1. Detect when a submit error occurs
    detectSubmitError() {
        const submitButton = document.getElementById("saypi-submitButton");
        const textarea = document.getElementById("saypi-prompt");
        if (submitButton && textarea) {
            if (submitButton.disabled && textarea.value.length > 0) {
                return true;
            }
        }
        return false;
    }
    // 2. Create a "restore point" capturing application state
    createRestorePoint({ prompt: message, audioInputEnabled: audioInputStatus, audioOutputEnabled: audioOutputStatus, }) {
        const restorePoint = {
            prompt: message,
            audioInputEnabled: audioInputStatus,
            audioOutputEnabled: audioOutputStatus,
            creationTime: new Date().toISOString(),
        };
        localStorage.setItem(this.restorePointKey, JSON.stringify(restorePoint));
    }
    // 3. Programmatically reload the page
    reloadPage() {
        window.location.reload();
    }
    handleSubmitError() {
        const textarea = document.getElementById("saypi-prompt");
        const prompt = textarea ? textarea.value : "";
        let audioInputStatus = true;
        const callButton = document.getElementById("saypi-callButton");
        if (callButton) {
            audioInputStatus = callButton.classList.contains("active");
        }
        console.log("Creating restore point");
        this.createRestorePoint({
            prompt: prompt,
            audioInputEnabled: audioInputStatus,
            audioOutputEnabled: this.audioOutputStatus,
        });
        console.log("Reloading page");
        this.reloadPage();
    }
    // 4. On load, check for a restore point
    checkForRestorePoint() {
        const storedData = localStorage.getItem(this.restorePointKey);
        if (storedData) {
            const restorePoint = JSON.parse(storedData);
            const currentTime = new Date();
            const restoreTime = new Date(restorePoint.creationTime);
            const timeDifference = (currentTime.getTime() - restoreTime.getTime()) / (1000 * 60); // in minutes
            if (timeDifference <= 5) {
                console.log("Restoring application state", restorePoint);
                (0, TranscriptionModule_1.setPromptText)(restorePoint.prompt);
                this.activateAudioInput(restorePoint.audioInputEnabled);
                this.activateAudioOutput(restorePoint.audioOutputEnabled);
                // Delete the executed restore point
                localStorage.removeItem(this.restorePointKey);
            }
        }
    }
    activateAudioInput(enable) {
        if (enable) {
            const callButton = document.getElementById("saypi-callButton");
            if (callButton) {
                callButton.click();
            }
        }
    }
    activateAudioOutput(enable) {
        if (enable) {
            const audioOutputButton = document.getElementById("saypi-audio-output-button");
            if (audioOutputButton) {
                audioOutputButton.click();
            }
        }
    }
}
exports["default"] = SubmitErrorHandler;
// Singleton
exports.submitErrorHandler = new SubmitErrorHandler();


/***/ }),

/***/ "./src/TranscriptionModule.ts":
/*!************************************!*\
  !*** ./src/TranscriptionModule.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mergeTranscripts = exports.setPromptText = exports.uploadAudioWithRetry = exports.clearPendingTranscriptions = exports.isTranscriptionPending = void 0;
const ConfigModule_js_1 = __webpack_require__(/*! ./ConfigModule.js */ "./src/ConfigModule.js");
const StateMachineService_js_1 = __importDefault(__webpack_require__(/*! ./StateMachineService.js */ "./src/StateMachineService.js"));
const UserAgentModule_js_1 = __webpack_require__(/*! ./UserAgentModule.js */ "./src/UserAgentModule.js");
const EventBus_js_1 = __importDefault(__webpack_require__(/*! ./EventBus.js */ "./src/EventBus.js"));
const EventModule_js_1 = __importDefault(__webpack_require__(/*! ./EventModule.js */ "./src/EventModule.js"));
const LoggingModule_js_1 = __webpack_require__(/*! ./LoggingModule.js */ "./src/LoggingModule.js");
const knownNetworkErrorMessages = [
    "Failed to fetch",
    "Load failed",
    "NetworkError when attempting to fetch resource.", // Firefox
    // Add more known error messages here
];
// timeout for transcription requests
const TIMEOUT_MS = 30000; // 30 seconds
// track sequence numbers for in-flight transcription requests
let sequenceNum = 0;
const sequenceNumsPendingTranscription = new Set();
function checkForExpiredEntries() {
    const now = Date.now();
    sequenceNumsPendingTranscription.forEach((entry) => {
        if (now - entry.timestamp > TIMEOUT_MS) {
            sequenceNumsPendingTranscription.delete(entry);
            LoggingModule_js_1.logger.info(`Transcription request ${entry.seq} timed out`);
        }
    });
}
function transcriptionSent() {
    sequenceNum++;
    sequenceNumsPendingTranscription.add({
        seq: sequenceNum,
        timestamp: Date.now(),
    });
}
function transcriptionReceived(seq) {
    // delete entry with matching sequence number
    sequenceNumsPendingTranscription.forEach((entry) => {
        if (entry.seq === seq) {
            sequenceNumsPendingTranscription.delete(entry);
            LoggingModule_js_1.logger.debug(`Transcription response ${seq} received after ${(Date.now() - entry.timestamp) / 1000}s`);
            return;
        }
    });
}
function isTranscriptionPending() {
    checkForExpiredEntries();
    return sequenceNumsPendingTranscription.size > 0;
}
exports.isTranscriptionPending = isTranscriptionPending;
// call after completed user input is submitted
function clearPendingTranscriptions() {
    sequenceNumsPendingTranscription.clear();
}
exports.clearPendingTranscriptions = clearPendingTranscriptions;
function uploadAudioWithRetry(audioBlob, audioDurationMillis, precedingTranscripts = {}, maxRetries = 3) {
    return __awaiter(this, void 0, void 0, function* () {
        let retryCount = 0;
        let delay = 1000; // initial delay of 1 second
        const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
        while (retryCount < maxRetries) {
            try {
                transcriptionSent();
                yield uploadAudio(audioBlob, audioDurationMillis, precedingTranscripts);
                return;
            }
            catch (error) {
                // check for timeout errors (30s on Heroku)
                if (error instanceof TypeError &&
                    knownNetworkErrorMessages.includes(error.message)) {
                    LoggingModule_js_1.logger.info(`Attempt ${retryCount + 1}/${maxRetries} failed. Retrying in ${delay / 1000} seconds...`);
                    yield sleep(delay);
                    // Exponential backoff
                    delay *= 2;
                    retryCount++;
                }
                else {
                    console.error("Unexpected error: ", error);
                    StateMachineService_js_1.default.actor.send("saypi:transcribeFailed", {
                        detail: error,
                    });
                    return;
                }
            }
        }
        console.error("Max retries reached. Giving up.");
        StateMachineService_js_1.default.actor.send("saypi:transcribeFailed", {
            detail: new Error("Max retries reached"),
        });
    });
}
exports.uploadAudioWithRetry = uploadAudioWithRetry;
function uploadAudio(audioBlob, audioDurationMillis, precedingTranscripts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const messages = Object.entries(precedingTranscripts).map(([seq, content]) => {
                return {
                    role: "user",
                    content: content,
                    sequenceNumber: Number(seq), // Convert the string to a number
                };
            });
            const formData = constructTranscriptionFormData(audioBlob, audioDurationMillis / 1000, messages);
            const language = navigator.language;
            const controller = new AbortController();
            const { signal } = controller;
            setTimeout(() => controller.abort(), TIMEOUT_MS);
            const startTime = new Date().getTime();
            const response = yield fetch(`${ConfigModule_js_1.config.apiServerUrl}/transcribe?language=${language}`, {
                method: "POST",
                body: formData,
                signal,
            });
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            const responseJson = yield response.json();
            const seq = responseJson.sequenceNumber;
            if (seq !== undefined) {
                transcriptionReceived(seq);
            }
            const endTime = new Date().getTime();
            const transcriptionDurationMillis = endTime - startTime;
            const transcript = responseJson.text;
            const wc = transcript.split(" ").length;
            const payload = {
                text: transcript,
                sequenceNumber: seq,
            };
            if (responseJson.hasOwnProperty("pFinishedSpeaking")) {
                payload.pFinishedSpeaking = responseJson.pFinishedSpeaking;
            }
            if (responseJson.hasOwnProperty("tempo")) {
                payload.tempo = responseJson.tempo;
            }
            LoggingModule_js_1.logger.info(`Transcribed ${Math.round(audioDurationMillis / 1000)}s of audio into ${wc} words in ${Math.round(transcriptionDurationMillis / 1000)}s`);
            if (responseJson.text.length === 0) {
                StateMachineService_js_1.default.actor.send("saypi:transcribedEmpty");
            }
            else {
                StateMachineService_js_1.default.actor.send("saypi:transcribed", payload);
            }
        }
        catch (error) {
            if (error instanceof Error) {
                if (error.name === "AbortError") {
                    console.error("Fetch aborted due to timeout", error);
                }
                else {
                    console.error("An unexpected error occurred:", error);
                }
            }
            else {
                console.error("Something thrown that is not an Error object:", error);
            }
            // re-throw the error if your logic requires it
            throw error;
        }
    });
}
function constructTranscriptionFormData(audioBlob, audioDurationSeconds, messages) {
    const formData = new FormData();
    let audioFilename = "audio.webm";
    if (audioBlob.type === "audio/mp4") {
        audioFilename = "audio.mp4";
    }
    else if (audioBlob.type === "audio/wav") {
        audioFilename = "audio.wav";
    }
    LoggingModule_js_1.logger.info(`Transcribing audio Blob with MIME type: ${audioBlob.type}, size: ${(audioBlob.size / 1024).toFixed(2)}kb`);
    // Add the audio blob to the FormData object
    formData.append("audio", audioBlob, audioFilename);
    formData.append("duration", audioDurationSeconds.toString());
    formData.append("sequenceNumber", sequenceNum.toString());
    formData.append("messages", JSON.stringify(messages));
    return formData;
}
function setPromptText(transcript) {
    LoggingModule_js_1.logger.info(`Merged transcript: ${transcript}`);
    const textarea = document.getElementById("saypi-prompt");
    if ((0, UserAgentModule_js_1.isMobileView)()) {
        // if transcript is > 1000 characters, truncate it to 999 characters plus an ellipsis
        if (transcript.length > 1000) {
            transcript = `${transcript.substring(0, 999)}…`;
            console.warn(`Transcript was too long for Pi. Truncated to 999 characters, losing the following text: ... ${transcript.substring(999)}`);
        }
        EventModule_js_1.default.setNativeValue(textarea, transcript);
        EventBus_js_1.default.emit("saypi:autoSubmit");
    }
    else {
        EventModule_js_1.default.simulateTyping(textarea, `${transcript} `);
    }
}
exports.setPromptText = setPromptText;
function mergeTranscripts(transcripts) {
    const sortedKeys = Object.keys(transcripts)
        .map(Number)
        .sort((a, b) => a - b);
    const sortedTranscripts = [];
    for (const key of sortedKeys) {
        sortedTranscripts.push(transcripts[key].trim());
    }
    return sortedTranscripts.join(" ");
}
exports.mergeTranscripts = mergeTranscripts;


/***/ }),

/***/ "./src/WavEncoder.ts":
/*!***************************!*\
  !*** ./src/WavEncoder.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Most of the code here come from ricky0123/vad-web
// Who in turn copied it from linto-ai/WebVoiceSDK
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeWAV = exports.arrayBufferToBase64 = exports.minFramesForTargetMS = void 0;
function minFramesForTargetMS(targetDuration, frameSamples, sr = 16000) {
    return Math.ceil((targetDuration * sr) / 1000 / frameSamples);
}
exports.minFramesForTargetMS = minFramesForTargetMS;
function arrayBufferToBase64(buffer) {
    var binary = "";
    var bytes = new Uint8Array(buffer);
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}
exports.arrayBufferToBase64 = arrayBufferToBase64;
/*
  This rest of this was mostly copied from https://github.com/linto-ai/WebVoiceSDK
  */
// this function is used to encode the Float32Array audio data produced from a MicVAD
// as a WAV file audio buffer
function encodeWAV(samples, format = 3, sampleRate = 16000, numChannels = 1, bitDepth = 32) {
    var bytesPerSample = bitDepth / 8;
    var blockAlign = numChannels * bytesPerSample;
    var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
    var view = new DataView(buffer);
    /* RIFF identifier */
    writeString(view, 0, "RIFF");
    /* RIFF chunk length */
    view.setUint32(4, 36 + samples.length * bytesPerSample, true);
    /* RIFF type */
    writeString(view, 8, "WAVE");
    /* format chunk identifier */
    writeString(view, 12, "fmt ");
    /* format chunk length */
    view.setUint32(16, 16, true);
    /* sample format (raw) */
    view.setUint16(20, format, true);
    /* channel count */
    view.setUint16(22, numChannels, true);
    /* sample rate */
    view.setUint32(24, sampleRate, true);
    /* byte rate (sample rate * block align) */
    view.setUint32(28, sampleRate * blockAlign, true);
    /* block align (channel count * bytes per sample) */
    view.setUint16(32, blockAlign, true);
    /* bits per sample */
    view.setUint16(34, bitDepth, true);
    /* data chunk identifier */
    writeString(view, 36, "data");
    /* data chunk length */
    view.setUint32(40, samples.length * bytesPerSample, true);
    if (format === 1) {
        // Raw PCM
        floatTo16BitPCM(view, 44, samples);
    }
    else {
        writeFloat32(view, 44, samples);
    }
    return buffer;
}
exports.encodeWAV = encodeWAV;
function interleave(inputL, inputR) {
    var length = inputL.length + inputR.length;
    var result = new Float32Array(length);
    var index = 0;
    var inputIndex = 0;
    while (index < length) {
        result[index++] = inputL[inputIndex];
        result[index++] = inputR[inputIndex];
        inputIndex++;
    }
    return result;
}
function writeFloat32(output, offset, input) {
    for (var i = 0; i < input.length; i++, offset += 4) {
        output.setFloat32(offset, input[i], true);
    }
}
function floatTo16BitPCM(output, offset, input) {
    for (var i = 0; i < input.length; i++, offset += 2) {
        var s = Math.max(-1, Math.min(1, input[i]));
        output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
    }
}
function writeString(view, offset, string) {
    for (var i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}


/***/ }),

/***/ "./src/state-machines/AudioInputMachine.ts":
/*!*************************************************!*\
  !*** ./src/state-machines/AudioInputMachine.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.audioInputMachine = void 0;
const vad_web_1 = __webpack_require__(/*! @ricky0123/vad-web */ "./node_modules/@ricky0123/vad-web/dist/index.js");
const ConfigModule_1 = __webpack_require__(/*! ../ConfigModule */ "./src/ConfigModule.js");
const RequestInterceptor_1 = __webpack_require__(/*! ../RequestInterceptor */ "./src/RequestInterceptor.js");
const AudioEncoder_1 = __webpack_require__(/*! ../AudioEncoder */ "./src/AudioEncoder.ts");
const xstate_1 = __webpack_require__(/*! xstate */ "./node_modules/xstate/es/index.js");
const EventBus_js_1 = __importDefault(__webpack_require__(/*! ../EventBus.js */ "./src/EventBus.js"));
// Assuming config.appServerUrl is of type string.
const fullWorkletURL = `${ConfigModule_1.config.appServerUrl}/vad.worklet.bundle.min.js`;
let audioMimeType = "audio/wav";
let speechStartTime = 0;
const threshold = 1000; // 1000 ms = 1 second, about the length of "Hey, Pi"
(0, RequestInterceptor_1.setupInterceptors)();
// Variable to hold the microphone instance. Now has a specific type.
let microphone = null;
// Options for MicVAD
const micVADOptions = {
    workletURL: fullWorkletURL,
    positiveSpeechThreshold: 0.8,
    minSpeechFrames: 5,
    preSpeechPadFrames: 10,
    onSpeechStart: () => {
        console.log("Speech started");
        speechStartTime = Date.now();
        EventBus_js_1.default.emit("saypi:userSpeaking");
    },
    onSpeechEnd: (rawAudioData) => {
        console.log("Speech ended");
        const speechStopTime = Date.now();
        const speechDuration = speechStopTime - speechStartTime;
        const audioBlob = (0, AudioEncoder_1.convertToWavBlob)(rawAudioData);
        EventBus_js_1.default.emit("audio:dataavailable", {
            blob: audioBlob,
            duration: speechDuration,
        });
    },
    onVADMisfire: () => {
        console.log("Cancelled. Audio was not speech.");
        EventBus_js_1.default.emit("saypi:userStoppedSpeaking", { duration: 0 });
    },
};
// The callback type can be more specific based on your usage
function setupRecording(callback) {
    return __awaiter(this, void 0, void 0, function* () {
        if (microphone) {
            return;
        }
        try {
            const stream = yield navigator.mediaDevices.getUserMedia({
                audio: {
                    channelCount: 1,
                    echoCancellation: true,
                    autoGainControl: true,
                    noiseSuppression: true,
                },
            });
            microphone = yield vad_web_1.MicVAD.new(Object.assign(Object.assign({}, micVADOptions), { stream }));
            if (typeof callback === "function") {
                callback();
            }
        }
        catch (err) {
            console.error("VAD failed to load", err);
            console.error(`Application server at ${ConfigModule_1.config.appServerUrl} may be unavailable. Please make sure it is running.`);
        }
    });
}
function tearDownRecording() {
    if (microphone) {
        microphone.pause();
    }
    microphone = null;
}
exports.audioInputMachine = (0, xstate_1.createMachine)({
    /** @xstate-layout N4IgpgJg5mDOIC5QEMCuECWB7AkgOwAdUAXAOgCcwAbMZWSAYmQGMBHVDSgbQAYBdRKAJZYGYtjyCQAD0QBGAGwBmUgFYeG1UoCc2gCxKA7HJ4KANCACeiJXIAcpBYe0K7bpasMHtqgL6+LNExcQhJSFnZODDwoBggsPDBSaIA3LABrJKDsfCIyCI5yaKgEVKxmZHEE3j4aqWFRKskkGURVACYLawQ7PVVSRVMeOyU9bSVlbX9A9BzQ-LZC4oYwcnIsclICKkqAMw2AW3DZkLzwxaiY0rw0iqaaupaGsQkpWQQ5QxV1TR19IxM5isiHa7X6oIUqlUCn0Ll0X2mIGypzCBU4jEoNDoYEeQhELwSb3kXzUGh4Wl0BmMpi6iDsclIY102h4RnaPG0inaiORuVRF0oEGSEBoDFgxGQ5GIuJAzyaRI+7U+Ax4clUIyhhlZI1pPV6pCUoPGekMhjsTjVPJOfIWkUFFDAzA2mBiYuIWAIACUwOw4MRIDK5a8Wu85O1tIYDXZ2nYOcNFM5dVr+p84WbVLp2n0rcEbec7ZAHU7yC7YhBKsgAIIpZAYHYAIxogfx8pD8j0kNIGrsLjcYbkSl1sYcvWUCnHenspqmASR1vm+cKhYIYDwpYAyu6CG6Pc3GsHQO9jA4FBzw5ytXYvtpddpQVGY4bPAZ2gpubPeQu0faV2vipuPTiCtq1rBsm34eoWwPVoEGPRwz10T5hmvIcwVIO84X0ORORMOQczmM5v0LcUPRXCAGD3AlmkPeRtTUNVVHsOQ9A0dpDCBboWQcZwfA0AxFFjPDETwLAIDgKRPzySD90JNsEAAWg4xBFPwlEyExWh6AgaSqIVPROmBD5mPghiFCQwEfFUvNv2KHTWxohA-nQ88eGMJwOWcVRdSNAZsNNJQhjVewrK-AVIDs6D3lfBl2KhP5OUhYZdU8FRUxhbDVEnS0P3nQiwqFDARTACLZIcuQBxUU9mIUPpXK0Nxb1c0geKZZwtSwkK8oLIVKGLUsSuomDmPpZz7HZFiJjYvRbxMUhz1aiMOUnTr+W6rZVw3LcBoVALtGayEKUQxK7CHLQBkNNrVR4I09BW20lyFEiCDI7a5KvPboXaCY7EYmNMoM7o3D0ObdHUAKs3VWx-H8IA */
    id: "audioInput",
    initial: "released",
    context: {
        waitingToStop: false,
        waitingToStart: false,
        recordingStartTime: 0,
    },
    states: {
        released: {
            on: {
                acquire: {
                    target: "acquiring",
                },
            },
        },
        acquiring: {
            description: "Acquiring the microphone. Waits until asynchronous call has completed.",
            invoke: {
                src: "acquireMicrophone",
                onDone: {
                    target: "acquired",
                },
                onError: {
                    target: "released",
                    actions: {
                        type: "logError",
                    },
                },
            },
            on: {
                start: {
                    actions: (0, xstate_1.assign)({ waitingToStart: true }),
                    internal: true,
                },
            },
        },
        acquired: {
            description: "Microphone acquired and ready to start recording.",
            initial: "idle",
            states: {
                idle: {
                    on: {
                        start: {
                            target: "recording",
                            cond: "microphoneAcquired",
                        },
                    },
                    always: {
                        target: "recording",
                        cond: "pendingStart",
                    },
                },
                recording: {
                    entry: ["startRecording", (0, xstate_1.assign)({ waitingToStart: false })],
                    on: {
                        stopRequested: {
                            target: "pendingStop",
                        },
                        dataAvailable: {
                            actions: {
                                type: "sendData",
                            },
                            internal: true,
                        },
                    },
                },
                pendingStop: {
                    description: "Waiting for the media recording device to stop recording.",
                    entry: {
                        type: "prepareStop",
                    },
                    after: {
                        "5000": [
                            {
                                target: "#audioInput.acquired.stopped",
                                actions: ["stopIfWaiting"],
                                description: "Stop eventually",
                            },
                            {
                                internal: false,
                            },
                        ],
                    },
                    on: {
                        stop: {
                            target: "stopped",
                            description: "Stop immediately",
                        },
                        dataAvailable: {
                            target: "stopped",
                            actions: ["stopIfWaiting", "sendData"],
                            description: "Stop after final audio data collected",
                        },
                    },
                },
                stopped: {
                    entry: (0, xstate_1.assign)({ waitingToStop: false }),
                    always: {
                        target: "idle",
                    },
                },
            },
            on: {
                release: {
                    target: "released",
                    actions: {
                        type: "releaseMicrophone",
                    },
                },
            },
        },
    },
    predictableActionArguments: true,
    preserveActionOrder: true,
}, {
    actions: {
        startRecording: (context, event) => {
            context.recordingStartTime = Date.now();
            // Start recording
            if (microphone && microphone.listening === false) {
                microphone.start();
            }
        },
        prepareStop: (context, event) => {
            if (microphone && microphone.listening === true) {
                context.waitingToStop = true;
            }
        },
        sendData: (context, event) => {
            const { blob, duration } = event;
            const sizeInKb = (blob.size / 1024).toFixed(2); // Convert to kilobytes and keep 2 decimal places
            console.log(`Uploading ${sizeInKb}kb of audio data`);
            // Use the duration directly from the event
            const speechDuration = duration;
            if (Number(sizeInKb) > 0) {
                // Upload the audio to the server for transcription
                EventBus_js_1.default.emit("saypi:userStoppedSpeaking", {
                    duration: speechDuration,
                    blob,
                });
            }
        },
        stopIfWaiting: (SayPiContext) => {
            if (SayPiContext.waitingToStop === true) {
                microphone === null || microphone === void 0 ? void 0 : microphone.pause();
            }
        },
        releaseMicrophone: (context, event) => {
            tearDownRecording();
        },
        logError: (context, event) => {
            console.error("Error acquiring microphone: ", event.data);
        },
    },
    services: {
        acquireMicrophone: (context, event) => {
            return new Promise((resolve, reject) => {
                setupRecording(() => {
                    if (microphone) {
                        resolve();
                    }
                    else {
                        reject(new Error("Failed to acquire microphone resource."));
                    }
                });
            });
        },
    },
    guards: {
        microphoneAcquired: (context, event) => {
            return microphone !== null;
        },
        pendingStart: (context, event) => {
            return context.waitingToStart === true;
        },
    },
    delays: {},
});


/***/ }),

/***/ "./src/state-machines/SayPiMachine.ts":
/*!********************************************!*\
  !*** ./src/state-machines/SayPiMachine.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.machine = exports.calculateDelay = void 0;
const ButtonModule_js_1 = __webpack_require__(/*! ../ButtonModule.js */ "./src/ButtonModule.js");
const xstate_1 = __webpack_require__(/*! xstate */ "./node_modules/xstate/es/index.js");
const AnimationModule_js_1 = __importDefault(__webpack_require__(/*! ../AnimationModule.js */ "./src/AnimationModule.js"));
const UserAgentModule_js_1 = __webpack_require__(/*! ../UserAgentModule.js */ "./src/UserAgentModule.js");
const TranscriptionModule_1 = __webpack_require__(/*! ../TranscriptionModule */ "./src/TranscriptionModule.ts");
const EventBus_1 = __importDefault(__webpack_require__(/*! ../EventBus */ "./src/EventBus.js"));
/* helper functions */
function calculateDelay(timeUserStoppedSpeaking, probabilityFinished, tempo, maxDelay) {
    // Get the current time (in milliseconds)
    const currentTime = new Date().getTime();
    // Calculate the time elapsed since the user stopped speaking (in milliseconds)
    const timeElapsed = currentTime - timeUserStoppedSpeaking;
    // We invert the tempo because a faster speech (tempo approaching 1) should reduce the delay
    let tempoFactor = 1 - tempo;
    // Calculate the combined probability factor
    let combinedProbability = probabilityFinished * tempoFactor;
    // The combined factor influences the initial delay
    const initialDelay = combinedProbability * maxDelay;
    // Calculate the final delay after accounting for the time already elapsed
    const finalDelay = Math.max(initialDelay - timeElapsed, 0);
    return finalDelay;
}
exports.calculateDelay = calculateDelay;
/* external actions */
const clearTranscripts = (0, xstate_1.assign)({
    transcriptions: () => ({}),
});
exports.machine = (0, xstate_1.createMachine)({
    context: {
        transcriptions: {},
        lastState: "inactive",
        timeUserStoppedSpeaking: 0,
    },
    id: "sayPi",
    initial: "inactive",
    states: {
        inactive: {
            description: "Idle state, not listening or speaking. Privacy mode.",
            exit: (0, xstate_1.assign)({ lastState: "inactive" }),
            on: {
                "saypi:call": {
                    target: "#sayPi.listening.recording",
                    actions: [
                        {
                            type: "callStarted",
                        },
                        {
                            type: "startRecording",
                        },
                    ],
                    description: 'Enable the VAD microphone.\nAka "call" Pi.\nStarts active listening.',
                },
                "saypi:piSpeaking": {
                    target: "#sayPi.responding.piSpeaking",
                },
            },
        },
        errors: {
            description: "Error parent state.",
            after: {
                "10000": [
                    {
                        target: "#sayPi.listening",
                        actions: [],
                        description: "Reset to the idle state and clear errors.",
                    },
                    {
                        internal: false,
                    },
                ],
            },
            initial: "transcribeFailed",
            states: {
                transcribeFailed: {
                    description: "The /transcribe API responded with an error.",
                    entry: {
                        type: "startAnimation",
                        params: {
                            animation: "error",
                        },
                    },
                    exit: {
                        type: "stopAnimation",
                        params: {
                            animation: "error",
                        },
                    },
                    type: "final",
                },
                micError: {
                    description: "No audio input detected",
                    entry: {
                        type: "showNotification",
                        params: {
                            icon: "muted-microphone",
                        },
                    },
                    exit: {
                        type: "dismissNotification",
                    },
                    type: "final",
                },
            },
        },
        listening: {
            description: "Actively listening for user input. Simultaneously recording and transcribing user speech. Gentle pulsing animation.",
            entry: [
                {
                    type: "stopAllAnimations",
                },
                {
                    type: "acquireMicrophone",
                },
            ],
            exit: (0, xstate_1.assign)({ lastState: "listening" }),
            states: {
                recording: {
                    description: "Microphone is on and VAD is actively listening for user speech.",
                    initial: "notSpeaking",
                    states: {
                        notSpeaking: {
                            description: "Microphone is recording but no speech is detected.",
                            on: {
                                "saypi:userFinishedSpeaking": {
                                    target: "#sayPi.inactive",
                                },
                                "saypi:userSpeaking": {
                                    target: "userSpeaking",
                                },
                            },
                        },
                        userSpeaking: {
                            description: "User is speaking and being recorded by the microphone.\nWaveform animation.",
                            entry: {
                                type: "startAnimation",
                                params: {
                                    animation: "userSpeaking",
                                },
                            },
                            exit: {
                                type: "stopAnimation",
                                params: {
                                    animation: "userSpeaking",
                                },
                            },
                            on: {
                                "saypi:userStoppedSpeaking": [
                                    {
                                        target: [
                                            "notSpeaking",
                                            "#sayPi.listening.converting.transcribing",
                                        ],
                                        cond: "hasAudio",
                                        actions: [
                                            (0, xstate_1.assign)({
                                                timeUserStoppedSpeaking: () => new Date().getTime(),
                                            }),
                                            {
                                                type: "transcribeAudio",
                                            },
                                        ],
                                    },
                                    {
                                        target: "notSpeaking",
                                        cond: "hasNoAudio",
                                    },
                                ],
                            },
                        },
                    },
                    on: {
                        "saypi:hangup": {
                            target: "#sayPi.inactive",
                            actions: [
                                {
                                    type: "stopRecording",
                                },
                                {
                                    type: "releaseMicrophone",
                                },
                                {
                                    type: "callEnded",
                                },
                            ],
                            description: 'Disable the VAD microphone.\n    Aka "call" Pi.\n    Stops active listening.',
                        },
                    },
                },
                converting: {
                    initial: "accumulating",
                    states: {
                        accumulating: {
                            description: "Accumulating and assembling audio transcriptions into a cohesive prompt.\nSubmits a prompt when a threshold is reached.",
                            after: {
                                submissionDelay: {
                                    target: "submitting",
                                    cond: "submissionConditionsMet",
                                    description: "Submit combined transcript to Pi.",
                                },
                            },
                            on: {
                                "saypi:transcribed": {
                                    target: "accumulating",
                                    actions: {
                                        type: "handleTranscriptionResponse",
                                    },
                                    description: "Transcribed speech to text (out of sequence response).",
                                },
                                "saypi:transcribeFailed": {
                                    target: "#sayPi.errors.transcribeFailed",
                                    description: "Out of sequence error response from the /transcribe API",
                                },
                                "saypi:transcribedEmpty": {
                                    target: "#sayPi.errors.micError",
                                    description: "Out of sequence empty response from the /transcribe API",
                                },
                            },
                        },
                        submitting: {
                            description: "Submitting prompt to Pi.",
                            entry: {
                                type: "mergeAndSubmitTranscript",
                            },
                            exit: [clearTranscripts, TranscriptionModule_1.clearPendingTranscriptions],
                            always: {
                                target: "accumulating",
                            },
                        },
                        transcribing: {
                            description: "Transcribing audio to text.\nCard flip animation.",
                            entry: {
                                type: "startAnimation",
                                params: {
                                    animation: "transcribing",
                                },
                            },
                            exit: {
                                type: "stopAnimation",
                                params: {
                                    animation: "transcribing",
                                },
                            },
                            on: {
                                "saypi:transcribed": {
                                    target: "accumulating",
                                    actions: {
                                        type: "handleTranscriptionResponse",
                                    },
                                    description: "Successfully transcribed user audio to text.",
                                },
                                "saypi:transcribeFailed": {
                                    target: "#sayPi.errors.transcribeFailed",
                                    description: "Received an error response from the /transcribe API",
                                },
                                "saypi:transcribedEmpty": {
                                    target: "#sayPi.errors.micError",
                                    description: "Received an empty response from the /transcribe API (no speech detected)",
                                },
                            },
                        },
                    },
                },
            },
            on: {
                "saypi:piSpeaking": {
                    target: "#sayPi.responding.piSpeaking",
                },
            },
            type: "parallel",
        },
        responding: {
            description: "Pi is responding. Synthesised speech is playing or waiting to play.",
            entry: {
                type: "disableCallButton",
            },
            exit: {
                type: "enableCallButton",
            },
            initial: "piSpeaking",
            states: {
                piSpeaking: {
                    description: "Pi's synthesised speech audio is playing.\nPlayful animation.",
                    entry: {
                        type: "startAnimation",
                        params: {
                            animation: "piSpeaking",
                        },
                    },
                    exit: {
                        type: "stopAnimation",
                        params: {
                            animation: "piSpeaking",
                        },
                    },
                    on: {
                        "saypi:piStoppedSpeaking": [
                            {
                                target: "#sayPi.listening",
                                cond: "wasListening",
                            },
                            {
                                target: "#sayPi.inactive",
                                cond: "wasInactive",
                            },
                        ],
                        "saypi:userSpeaking": {
                            target: "#sayPi.listening.recording.userSpeaking",
                        },
                        "saypi:piFinishedSpeaking": {
                            target: "#sayPi.listening",
                        },
                    },
                },
            },
        },
    },
    predictableActionArguments: true,
    preserveActionOrder: true,
}, {
    actions: {
        stopAllAnimations: (context, event) => {
            AnimationModule_js_1.default.stopAllAnimations();
        },
        startAnimation: (context, event, { action }) => {
            AnimationModule_js_1.default.startAnimation(action.params.animation);
        },
        stopAnimation: (context, event, { action }) => {
            AnimationModule_js_1.default.stopAnimation(action.params.animation);
        },
        transcribeAudio: (context, event) => {
            const audioBlob = event.blob;
            if (audioBlob) {
                (0, TranscriptionModule_1.uploadAudioWithRetry)(audioBlob, event.duration, context.transcriptions);
            }
        },
        handleTranscriptionResponse: (SayPiContext, event) => {
            console.log("handleTranscriptionResponse", event);
            const transcription = event.text;
            const sequenceNumber = event.sequenceNumber;
            SayPiContext.transcriptions[sequenceNumber] = transcription;
        },
        acquireMicrophone: (context, event) => {
            // warmup the microphone on idle in mobile view,
            // since there's no mouseover event to trigger it
            if ((0, UserAgentModule_js_1.isMobileView)()) {
                EventBus_1.default.emit("audio:setupRecording");
            }
        },
        startRecording: (context, event) => {
            EventBus_1.default.emit("audio:startRecording");
        },
        stopRecording: (context, event) => {
            EventBus_1.default.emit("audio:stopRecording");
        },
        showNotification: (context, event, { action }) => {
            const icon = action.params.icon;
            const message = action.params.message;
            ButtonModule_js_1.buttonModule.showNotification({ icon, message });
        },
        dismissNotification: () => {
            ButtonModule_js_1.buttonModule.dismissNotification();
        },
        mergeAndSubmitTranscript: (context) => {
            const prompt = (0, TranscriptionModule_1.mergeTranscripts)(context.transcriptions).trim();
            if (prompt)
                (0, TranscriptionModule_1.setPromptText)(prompt);
        },
        callStarted: () => {
            ButtonModule_js_1.buttonModule.callActive();
        },
        callEnded: () => {
            ButtonModule_js_1.buttonModule.callInactive();
        },
        disableCallButton: () => {
            ButtonModule_js_1.buttonModule.disableCallButton();
        },
        enableCallButton: () => {
            ButtonModule_js_1.buttonModule.enableCallButton();
        },
    },
    services: {},
    guards: {
        hasAudio: (context, event) => {
            if (event.type === "saypi:userStoppedSpeaking") {
                event = event;
                return event.blob !== undefined && event.duration > 0;
            }
            return false;
        },
        hasNoAudio: (context, event) => {
            if (event.type === "saypi:userStoppedSpeaking") {
                event = event;
                return (event.blob === undefined ||
                    event.blob.size === 0 ||
                    event.duration === 0);
            }
            return false;
        },
        submissionConditionsMet: (context, event, meta) => {
            const { state } = meta;
            const allowedState = !(state.matches("listening.recording.userSpeaking") ||
                state.matches("listening.converting.transcribing"));
            const empty = Object.keys(context.transcriptions).length === 0;
            const pending = (0, TranscriptionModule_1.isTranscriptionPending)();
            const ready = allowedState && !empty && !pending;
            return ready;
        },
        wasListening: (context) => {
            return context.lastState === "listening";
        },
        wasInactive: (context) => {
            return context.lastState === "inactive";
        },
    },
    delays: {
        submissionDelay: (context, event) => {
            // check if the event is a transcription event
            if (event.type !== "saypi:transcribed") {
                return 0;
            }
            else {
                event = event;
            }
            const maxDelay = 10000; // 10 seconds in milliseconds
            // Calculate the initial delay based on pFinishedSpeaking
            let probabilityFinished = 1;
            if (event.pFinishedSpeaking !== undefined) {
                probabilityFinished = event.pFinishedSpeaking;
            }
            // Incorporate the tempo into the delay, defaulting to 0.5 (average tempo) if undefined
            let tempo = event.tempo !== undefined ? event.tempo : 0.5;
            const finalDelay = calculateDelay(context.timeUserStoppedSpeaking, probabilityFinished, tempo, maxDelay);
            console.log("Waiting for", (finalDelay / 1000).toFixed(1), "seconds before submitting");
            return finalDelay;
        },
    },
});


/***/ }),

/***/ "./node_modules/xstate/es/Actor.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/Actor.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createDeferredActor: () => (/* binding */ createDeferredActor),
/* harmony export */   createInvocableActor: () => (/* binding */ createInvocableActor),
/* harmony export */   createNullActor: () => (/* binding */ createNullActor),
/* harmony export */   isActor: () => (/* binding */ isActor),
/* harmony export */   isSpawnedActor: () => (/* binding */ isSpawnedActor),
/* harmony export */   toActorRef: () => (/* binding */ toActorRef)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");
/* harmony import */ var _serviceScope_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serviceScope.js */ "./node_modules/xstate/es/serviceScope.js");




function createNullActor(id) {
  var _a;

  return _a = {
    id: id,
    send: function () {
      return void 0;
    },
    subscribe: function () {
      return {
        unsubscribe: function () {
          return void 0;
        }
      };
    },
    getSnapshot: function () {
      return undefined;
    },
    toJSON: function () {
      return {
        id: id
      };
    }
  }, _a[_utils_js__WEBPACK_IMPORTED_MODULE_0__.symbolObservable] = function () {
    return this;
  }, _a;
}
/**
 * Creates a deferred actor that is able to be invoked given the provided
 * invocation information in its `.meta` value.
 *
 * @param invokeDefinition The meta information needed to invoke the actor.
 */

function createInvocableActor(invokeDefinition, machine, context, _event) {
  var _a;

  var invokeSrc = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toInvokeSource)(invokeDefinition.src);
  var serviceCreator = (_a = machine === null || machine === void 0 ? void 0 : machine.options.services) === null || _a === void 0 ? void 0 : _a[invokeSrc.type];
  var resolvedData = invokeDefinition.data ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapContext)(invokeDefinition.data, context, _event) : undefined;
  var tempActor = serviceCreator ? createDeferredActor(serviceCreator, invokeDefinition.id, resolvedData) : createNullActor(invokeDefinition.id); // @ts-ignore

  tempActor.meta = invokeDefinition;
  return tempActor;
}
function createDeferredActor(entity, id, data) {
  var tempActor = createNullActor(id); // @ts-ignore

  tempActor.deferred = true;

  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isMachine)(entity)) {
    // "mute" the existing service scope so potential spawned actors within the `.initialState` stay deferred here
    var initialState_1 = tempActor.state = (0,_serviceScope_js__WEBPACK_IMPORTED_MODULE_1__.provide)(undefined, function () {
      return (data ? entity.withContext(data) : entity).initialState;
    });

    tempActor.getSnapshot = function () {
      return initialState_1;
    };
  }

  return tempActor;
}
function isActor(item) {
  try {
    return typeof item.send === 'function';
  } catch (e) {
    return false;
  }
}
function isSpawnedActor(item) {
  return isActor(item) && 'id' in item;
} // TODO: refactor the return type, this could be written in a better way but it's best to avoid unneccessary breaking changes now

function toActorRef(actorRefLike) {
  var _a;

  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((_a = {
    subscribe: function () {
      return {
        unsubscribe: function () {
          return void 0;
        }
      };
    },
    id: 'anonymous',
    getSnapshot: function () {
      return undefined;
    }
  }, _a[_utils_js__WEBPACK_IMPORTED_MODULE_0__.symbolObservable] = function () {
    return this;
  }, _a), actorRefLike);
}




/***/ }),

/***/ "./node_modules/xstate/es/Machine.js":
/*!*******************************************!*\
  !*** ./node_modules/xstate/es/Machine.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Machine: () => (/* binding */ Machine),
/* harmony export */   createMachine: () => (/* binding */ createMachine)
/* harmony export */ });
/* harmony import */ var _StateNode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StateNode.js */ "./node_modules/xstate/es/StateNode.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./environment.js */ "./node_modules/xstate/es/environment.js");



var warned = false;
function Machine(config, options, initialContext) {
  if (initialContext === void 0) {
    initialContext = config.context;
  }

  return new _StateNode_js__WEBPACK_IMPORTED_MODULE_0__.StateNode(config, options, initialContext);
}
function createMachine(config, options) {
  if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION && !('predictableActionArguments' in config) && !warned) {
    warned = true;
    console.warn('It is highly recommended to set `predictableActionArguments` to `true` when using `createMachine`. https://xstate.js.org/docs/guides/actions.html');
  }

  return new _StateNode_js__WEBPACK_IMPORTED_MODULE_0__.StateNode(config, options);
}




/***/ }),

/***/ "./node_modules/xstate/es/State.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/State.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   State: () => (/* binding */ State),
/* harmony export */   bindActionToState: () => (/* binding */ bindActionToState),
/* harmony export */   isState: () => (/* binding */ isState),
/* harmony export */   isStateConfig: () => (/* binding */ isStateConfig),
/* harmony export */   stateValuesEqual: () => (/* binding */ stateValuesEqual)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ "./node_modules/xstate/es/constants.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");
/* harmony import */ var _stateUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stateUtils.js */ "./node_modules/xstate/es/stateUtils.js");
/* harmony import */ var _actions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./actions.js */ "./node_modules/xstate/es/actions.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./environment.js */ "./node_modules/xstate/es/environment.js");







function stateValuesEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (a === undefined || b === undefined) {
    return false;
  }

  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(a) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(b)) {
    return a === b;
  }

  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  return aKeys.length === bKeys.length && aKeys.every(function (key) {
    return stateValuesEqual(a[key], b[key]);
  });
}
function isStateConfig(state) {
  if (typeof state !== 'object' || state === null) {
    return false;
  }

  return 'value' in state && '_event' in state;
}
/**
 * @deprecated Use `isStateConfig(object)` or `state instanceof State` instead.
 */

var isState = isStateConfig;
function bindActionToState(action, state) {
  var exec = action.exec;

  var boundAction = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, action), {
    exec: exec !== undefined ? function () {
      return exec(state.context, state.event, {
        action: action,
        state: state,
        _event: state._event
      });
    } : undefined
  });

  return boundAction;
}

var State =
/*#__PURE__*/

/** @class */
function () {
  /**
   * Creates a new State instance.
   * @param value The state value
   * @param context The extended state
   * @param historyValue The tree representing historical values of the state nodes
   * @param history The previous state
   * @param actions An array of action objects to execute as side-effects
   * @param activities A mapping of activities and whether they are started (`true`) or stopped (`false`).
   * @param meta
   * @param events Internal event queue. Should be empty with run-to-completion semantics.
   * @param configuration
   */
  function State(config) {
    var _this = this;

    var _a;

    this.actions = [];
    this.activities = _constants_js__WEBPACK_IMPORTED_MODULE_2__.EMPTY_ACTIVITY_MAP;
    this.meta = {};
    this.events = [];
    this.value = config.value;
    this.context = config.context;
    this._event = config._event;
    this._sessionid = config._sessionid;
    this.event = this._event.data;
    this.historyValue = config.historyValue;
    this.history = config.history;
    this.actions = config.actions || [];
    this.activities = config.activities || _constants_js__WEBPACK_IMPORTED_MODULE_2__.EMPTY_ACTIVITY_MAP;
    this.meta = (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_3__.getMeta)(config.configuration);
    this.events = config.events || [];
    this.matches = this.matches.bind(this);
    this.toStrings = this.toStrings.bind(this);
    this.configuration = config.configuration;
    this.transitions = config.transitions;
    this.children = config.children;
    this.done = !!config.done;
    this.tags = (_a = Array.isArray(config.tags) ? new Set(config.tags) : config.tags) !== null && _a !== void 0 ? _a : new Set();
    this.machine = config.machine;
    Object.defineProperty(this, 'nextEvents', {
      get: function () {
        return (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_3__.nextEvents)(_this.configuration);
      }
    });
  }
  /**
   * Creates a new State instance for the given `stateValue` and `context`.
   * @param stateValue
   * @param context
   */


  State.from = function (stateValue, context) {
    if (stateValue instanceof State) {
      if (stateValue.context !== context) {
        return new State({
          value: stateValue.value,
          context: context,
          _event: stateValue._event,
          _sessionid: null,
          historyValue: stateValue.historyValue,
          history: stateValue.history,
          actions: [],
          activities: stateValue.activities,
          meta: {},
          events: [],
          configuration: [],
          transitions: [],
          children: {}
        });
      }

      return stateValue;
    }

    var _event = _actions_js__WEBPACK_IMPORTED_MODULE_4__.initEvent;
    return new State({
      value: stateValue,
      context: context,
      _event: _event,
      _sessionid: null,
      historyValue: undefined,
      history: undefined,
      actions: [],
      activities: undefined,
      meta: undefined,
      events: [],
      configuration: [],
      transitions: [],
      children: {}
    });
  };
  /**
   * Creates a new State instance for the given `config`.
   * @param config The state config
   */


  State.create = function (config) {
    return new State(config);
  };
  /**
   * Creates a new `State` instance for the given `stateValue` and `context` with no actions (side-effects).
   * @param stateValue
   * @param context
   */


  State.inert = function (stateValue, context) {
    if (stateValue instanceof State) {
      if (!stateValue.actions.length) {
        return stateValue;
      }

      var _event = _actions_js__WEBPACK_IMPORTED_MODULE_4__.initEvent;
      return new State({
        value: stateValue.value,
        context: context,
        _event: _event,
        _sessionid: null,
        historyValue: stateValue.historyValue,
        history: stateValue.history,
        activities: stateValue.activities,
        configuration: stateValue.configuration,
        transitions: [],
        children: {}
      });
    }

    return State.from(stateValue, context);
  };
  /**
   * Returns an array of all the string leaf state node paths.
   * @param stateValue
   * @param delimiter The character(s) that separate each subpath in the string state node path.
   */


  State.prototype.toStrings = function (stateValue, delimiter) {
    var _this = this;

    if (stateValue === void 0) {
      stateValue = this.value;
    }

    if (delimiter === void 0) {
      delimiter = '.';
    }

    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(stateValue)) {
      return [stateValue];
    }

    var valueKeys = Object.keys(stateValue);
    return valueKeys.concat.apply(valueKeys, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__read)(valueKeys.map(function (key) {
      return _this.toStrings(stateValue[key], delimiter).map(function (s) {
        return key + delimiter + s;
      });
    })), false));
  };

  State.prototype.toJSON = function () {
    var _a = this;
        _a.configuration;
        _a.transitions;
        var tags = _a.tags;
        _a.machine;
        var jsonValues = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__rest)(_a, ["configuration", "transitions", "tags", "machine"]);

    return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, jsonValues), {
      tags: Array.from(tags)
    });
  };

  State.prototype.matches = function (parentStateValue) {
    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.matchesState)(parentStateValue, this.value);
  };
  /**
   * Whether the current state configuration has a state node with the specified `tag`.
   * @param tag
   */


  State.prototype.hasTag = function (tag) {
    return this.tags.has(tag);
  };
  /**
   * Determines whether sending the `event` will cause a non-forbidden transition
   * to be selected, even if the transitions have no actions nor
   * change the state value.
   *
   * @param event The event to test
   * @returns Whether the event will cause a transition
   */


  State.prototype.can = function (event) {
    var _a;

    if (_environment_js__WEBPACK_IMPORTED_MODULE_5__.IS_PRODUCTION) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(!!this.machine, "state.can(...) used outside of a machine-created State object; this will always return false.");
    }

    var transitionData = (_a = this.machine) === null || _a === void 0 ? void 0 : _a.getTransitionData(this, event);
    return !!(transitionData === null || transitionData === void 0 ? void 0 : transitionData.transitions.length) && // Check that at least one transition is not forbidden
    transitionData.transitions.some(function (t) {
      return t.target !== undefined || t.actions.length;
    });
  };

  return State;
}();




/***/ }),

/***/ "./node_modules/xstate/es/StateNode.js":
/*!*********************************************!*\
  !*** ./node_modules/xstate/es/StateNode.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StateNode: () => (/* binding */ StateNode)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./State.js */ "./node_modules/xstate/es/State.js");
/* harmony import */ var _actionTypes_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./actionTypes.js */ "./node_modules/xstate/es/actionTypes.js");
/* harmony import */ var _actions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./actions.js */ "./node_modules/xstate/es/actions.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./environment.js */ "./node_modules/xstate/es/environment.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ "./node_modules/xstate/es/constants.js");
/* harmony import */ var _stateUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stateUtils.js */ "./node_modules/xstate/es/stateUtils.js");
/* harmony import */ var _Actor_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Actor.js */ "./node_modules/xstate/es/Actor.js");
/* harmony import */ var _invokeUtils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./invokeUtils.js */ "./node_modules/xstate/es/invokeUtils.js");











var NULL_EVENT = '';
var STATE_IDENTIFIER = '#';
var WILDCARD = '*';
var EMPTY_OBJECT = {};

var isStateId = function (str) {
  return str[0] === STATE_IDENTIFIER;
};

var createDefaultOptions = function () {
  return {
    actions: {},
    guards: {},
    services: {},
    activities: {},
    delays: {}
  };
};

var validateArrayifiedTransitions = function (stateNode, event, transitions) {
  var hasNonLastUnguardedTarget = transitions.slice(0, -1).some(function (transition) {
    return !('cond' in transition) && !('in' in transition) && ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(transition.target) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isMachine)(transition.target));
  });
  var eventText = event === NULL_EVENT ? 'the transient event' : "event '".concat(event, "'");
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(!hasNonLastUnguardedTarget, "One or more transitions for ".concat(eventText, " on state '").concat(stateNode.id, "' are unreachable. ") + "Make sure that the default transition is the last one defined.");
};

var StateNode =
/*#__PURE__*/

/** @class */
function () {
  function StateNode(
  /**
   * The raw config used to create the machine.
   */
  config, options,
  /**
   * The initial extended state
   */
  _context, // TODO: this is unsafe, but we're removing it in v5 anyway
  _stateInfo) {
    if (_context === void 0) {
      _context = 'context' in config ? config.context : undefined;
    }

    var _this = this;

    var _a;

    this.config = config;
    this._context = _context;
    /**
     * The order this state node appears. Corresponds to the implicit SCXML document order.
     */

    this.order = -1;
    this.__xstatenode = true;
    this.__cache = {
      events: undefined,
      relativeValue: new Map(),
      initialStateValue: undefined,
      initialState: undefined,
      on: undefined,
      transitions: undefined,
      candidates: {},
      delayedTransitions: undefined
    };
    this.idMap = {};
    this.tags = [];
    this.options = Object.assign(createDefaultOptions(), options);
    this.parent = _stateInfo === null || _stateInfo === void 0 ? void 0 : _stateInfo.parent;
    this.key = this.config.key || (_stateInfo === null || _stateInfo === void 0 ? void 0 : _stateInfo.key) || this.config.id || '(machine)';
    this.machine = this.parent ? this.parent.machine : this;
    this.path = this.parent ? this.parent.path.concat(this.key) : [];
    this.delimiter = this.config.delimiter || (this.parent ? this.parent.delimiter : _constants_js__WEBPACK_IMPORTED_MODULE_1__.STATE_DELIMITER);
    this.id = this.config.id || (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([this.machine.key], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(this.path), false).join(this.delimiter);
    this.version = this.parent ? this.parent.version : this.config.version;
    this.type = this.config.type || (this.config.parallel ? 'parallel' : this.config.states && Object.keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');
    this.schema = this.parent ? this.machine.schema : (_a = this.config.schema) !== null && _a !== void 0 ? _a : {};
    this.description = this.config.description;

    if (!_environment_js__WEBPACK_IMPORTED_MODULE_3__.IS_PRODUCTION) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(!('parallel' in this.config), "The \"parallel\" property is deprecated and will be removed in version 4.1. ".concat(this.config.parallel ? "Replace with `type: 'parallel'`" : "Use `type: '".concat(this.type, "'`"), " in the config for state node '").concat(this.id, "' instead."));
    }

    this.initial = this.config.initial;
    this.states = this.config.states ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValues)(this.config.states, function (stateConfig, key) {
      var _a;

      var stateNode = new StateNode(stateConfig, {}, undefined, {
        parent: _this,
        key: key
      });
      Object.assign(_this.idMap, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((_a = {}, _a[stateNode.id] = stateNode, _a), stateNode.idMap));
      return stateNode;
    }) : EMPTY_OBJECT; // Document order

    var order = 0;

    function dfs(stateNode) {
      var e_1, _a;

      stateNode.order = order++;

      try {
        for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)((0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getAllChildren)(stateNode)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var child = _c.value;
          dfs(child);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }

    dfs(this); // History config

    this.history = this.config.history === true ? 'shallow' : this.config.history || false;
    this._transient = !!this.config.always || (!this.config.on ? false : Array.isArray(this.config.on) ? this.config.on.some(function (_a) {
      var event = _a.event;
      return event === NULL_EVENT;
    }) : NULL_EVENT in this.config.on);
    this.strict = !!this.config.strict; // TODO: deprecate (entry)

    this.onEntry = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(this.config.entry || this.config.onEntry).map(function (action) {
      return (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.toActionObject)(action);
    }); // TODO: deprecate (exit)

    this.onExit = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(this.config.exit || this.config.onExit).map(function (action) {
      return (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.toActionObject)(action);
    });
    this.meta = this.config.meta;
    this.doneData = this.type === 'final' ? this.config.data : undefined;
    this.invoke = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(this.config.invoke).map(function (invokeConfig, i) {
      var _a, _b;

      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isMachine)(invokeConfig)) {
        var invokeId = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createInvokeId)(_this.id, i);
        _this.machine.options.services = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((_a = {}, _a[invokeId] = invokeConfig, _a), _this.machine.options.services);
        return (0,_invokeUtils_js__WEBPACK_IMPORTED_MODULE_6__.toInvokeDefinition)({
          src: invokeId,
          id: invokeId
        });
      } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(invokeConfig.src)) {
        var invokeId = invokeConfig.id || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createInvokeId)(_this.id, i);
        return (0,_invokeUtils_js__WEBPACK_IMPORTED_MODULE_6__.toInvokeDefinition)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, invokeConfig), {
          id: invokeId,
          src: invokeConfig.src
        }));
      } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isMachine)(invokeConfig.src) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(invokeConfig.src)) {
        var invokeId = invokeConfig.id || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createInvokeId)(_this.id, i);
        _this.machine.options.services = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((_b = {}, _b[invokeId] = invokeConfig.src, _b), _this.machine.options.services);
        return (0,_invokeUtils_js__WEBPACK_IMPORTED_MODULE_6__.toInvokeDefinition)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({
          id: invokeId
        }, invokeConfig), {
          src: invokeId
        }));
      } else {
        var invokeSource = invokeConfig.src;
        return (0,_invokeUtils_js__WEBPACK_IMPORTED_MODULE_6__.toInvokeDefinition)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({
          id: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createInvokeId)(_this.id, i)
        }, invokeConfig), {
          src: invokeSource
        }));
      }
    });
    this.activities = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(this.config.activities).concat(this.invoke).map(function (activity) {
      return (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.toActivityDefinition)(activity);
    });
    this.transition = this.transition.bind(this);
    this.tags = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(this.config.tags); // TODO: this is the real fix for initialization once
    // state node getters are deprecated
    // if (!this.parent) {
    //   this._init();
    // }
  }

  StateNode.prototype._init = function () {
    if (this.__cache.transitions) {
      return;
    }

    (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getAllStateNodes)(this).forEach(function (stateNode) {
      return stateNode.on;
    });
  };
  /**
   * Clones this state machine with custom options and context.
   *
   * @param options Options (actions, guards, activities, services) to recursively merge with the existing options.
   * @param context Custom context (will override predefined context)
   */


  StateNode.prototype.withConfig = function (options, context) {
    var _a = this.options,
        actions = _a.actions,
        activities = _a.activities,
        guards = _a.guards,
        services = _a.services,
        delays = _a.delays;
    return new StateNode(this.config, {
      actions: (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, actions), options.actions),
      activities: (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, activities), options.activities),
      guards: (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, guards), options.guards),
      services: (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, services), options.services),
      delays: (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, delays), options.delays)
    }, context !== null && context !== void 0 ? context : this.context);
  };
  /**
   * Clones this state machine with custom context.
   *
   * @param context Custom context (will override predefined context, not recursive)
   */


  StateNode.prototype.withContext = function (context) {
    return new StateNode(this.config, this.options, context);
  };

  Object.defineProperty(StateNode.prototype, "context", {
    get: function () {
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(this._context) ? this._context() : this._context;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "definition", {
    /**
     * The well-structured state node definition.
     */
    get: function () {
      return {
        id: this.id,
        key: this.key,
        version: this.version,
        context: this.context,
        type: this.type,
        initial: this.initial,
        history: this.history,
        states: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValues)(this.states, function (state) {
          return state.definition;
        }),
        on: this.on,
        transitions: this.transitions,
        entry: this.onEntry,
        exit: this.onExit,
        activities: this.activities || [],
        meta: this.meta,
        order: this.order || -1,
        data: this.doneData,
        invoke: this.invoke,
        description: this.description,
        tags: this.tags
      };
    },
    enumerable: false,
    configurable: true
  });

  StateNode.prototype.toJSON = function () {
    return this.definition;
  };

  Object.defineProperty(StateNode.prototype, "on", {
    /**
     * The mapping of events to transitions.
     */
    get: function () {
      if (this.__cache.on) {
        return this.__cache.on;
      }

      var transitions = this.transitions;
      return this.__cache.on = transitions.reduce(function (map, transition) {
        map[transition.eventType] = map[transition.eventType] || [];
        map[transition.eventType].push(transition);
        return map;
      }, {});
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "after", {
    get: function () {
      return this.__cache.delayedTransitions || (this.__cache.delayedTransitions = this.getDelayedTransitions(), this.__cache.delayedTransitions);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "transitions", {
    /**
     * All the transitions that can be taken from this state node.
     */
    get: function () {
      return this.__cache.transitions || (this.__cache.transitions = this.formatTransitions(), this.__cache.transitions);
    },
    enumerable: false,
    configurable: true
  });

  StateNode.prototype.getCandidates = function (eventName) {
    if (this.__cache.candidates[eventName]) {
      return this.__cache.candidates[eventName];
    }

    var transient = eventName === NULL_EVENT;
    var candidates = this.transitions.filter(function (transition) {
      var sameEventType = transition.eventType === eventName; // null events should only match against eventless transitions

      return transient ? sameEventType : sameEventType || transition.eventType === WILDCARD;
    });
    this.__cache.candidates[eventName] = candidates;
    return candidates;
  };
  /**
   * All delayed transitions from the config.
   */


  StateNode.prototype.getDelayedTransitions = function () {
    var _this = this;

    var afterConfig = this.config.after;

    if (!afterConfig) {
      return [];
    }

    var mutateEntryExit = function (delay, i) {
      var delayRef = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(delay) ? "".concat(_this.id, ":delay[").concat(i, "]") : delay;
      var eventType = (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.after)(delayRef, _this.id);

      _this.onEntry.push((0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.send)(eventType, {
        delay: delay
      }));

      _this.onExit.push((0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.cancel)(eventType));

      return eventType;
    };

    var delayedTransitions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(afterConfig) ? afterConfig.map(function (transition, i) {
      var eventType = mutateEntryExit(transition.delay, i);
      return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, transition), {
        event: eventType
      });
    }) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(Object.keys(afterConfig).map(function (delay, i) {
      var configTransition = afterConfig[delay];
      var resolvedTransition = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(configTransition) ? {
        target: configTransition
      } : configTransition;
      var resolvedDelay = !isNaN(+delay) ? +delay : delay;
      var eventType = mutateEntryExit(resolvedDelay, i);
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(resolvedTransition).map(function (transition) {
        return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, transition), {
          event: eventType,
          delay: resolvedDelay
        });
      });
    }));
    return delayedTransitions.map(function (delayedTransition) {
      var delay = delayedTransition.delay;
      return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, _this.formatTransition(delayedTransition)), {
        delay: delay
      });
    });
  };
  /**
   * Returns the state nodes represented by the current state value.
   *
   * @param state The state value or State instance
   */


  StateNode.prototype.getStateNodes = function (state) {
    var _a;

    var _this = this;

    if (!state) {
      return [];
    }

    var stateValue = state instanceof _State_js__WEBPACK_IMPORTED_MODULE_7__.State ? state.value : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toStateValue)(state, this.delimiter);

    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(stateValue)) {
      var initialStateValue = this.getStateNode(stateValue).initial;
      return initialStateValue !== undefined ? this.getStateNodes((_a = {}, _a[stateValue] = initialStateValue, _a)) : [this, this.states[stateValue]];
    }

    var subStateKeys = Object.keys(stateValue);
    var subStateNodes = [this];
    subStateNodes.push.apply(subStateNodes, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(subStateKeys.map(function (subStateKey) {
      return _this.getStateNode(subStateKey).getStateNodes(stateValue[subStateKey]);
    }))), false));
    return subStateNodes;
  };
  /**
   * Returns `true` if this state node explicitly handles the given event.
   *
   * @param event The event in question
   */


  StateNode.prototype.handles = function (event) {
    var eventType = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getEventType)(event);
    return this.events.includes(eventType);
  };
  /**
   * Resolves the given `state` to a new `State` instance relative to this machine.
   *
   * This ensures that `.events` and `.nextEvents` represent the correct values.
   *
   * @param state The state to resolve
   */


  StateNode.prototype.resolveState = function (state) {
    var stateFromConfig = state instanceof _State_js__WEBPACK_IMPORTED_MODULE_7__.State ? state : _State_js__WEBPACK_IMPORTED_MODULE_7__.State.create(state);
    var configuration = Array.from((0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getConfiguration)([], this.getStateNodes(stateFromConfig.value)));
    return new _State_js__WEBPACK_IMPORTED_MODULE_7__.State((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, stateFromConfig), {
      value: this.resolve(stateFromConfig.value),
      configuration: configuration,
      done: (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.isInFinalState)(configuration, this),
      tags: (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getTagsFromConfiguration)(configuration),
      machine: this.machine
    }));
  };

  StateNode.prototype.transitionLeafNode = function (stateValue, state, _event) {
    var stateNode = this.getStateNode(stateValue);
    var next = stateNode.next(state, _event);

    if (!next || !next.transitions.length) {
      return this.next(state, _event);
    }

    return next;
  };

  StateNode.prototype.transitionCompoundNode = function (stateValue, state, _event) {
    var subStateKeys = Object.keys(stateValue);
    var stateNode = this.getStateNode(subStateKeys[0]);

    var next = stateNode._transition(stateValue[subStateKeys[0]], state, _event);

    if (!next || !next.transitions.length) {
      return this.next(state, _event);
    }

    return next;
  };

  StateNode.prototype.transitionParallelNode = function (stateValue, state, _event) {
    var e_2, _a;

    var transitionMap = {};

    try {
      for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(Object.keys(stateValue)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var subStateKey = _c.value;
        var subStateValue = stateValue[subStateKey];

        if (!subStateValue) {
          continue;
        }

        var subStateNode = this.getStateNode(subStateKey);

        var next = subStateNode._transition(subStateValue, state, _event);

        if (next) {
          transitionMap[subStateKey] = next;
        }
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    var stateTransitions = Object.keys(transitionMap).map(function (key) {
      return transitionMap[key];
    });
    var enabledTransitions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(stateTransitions.map(function (st) {
      return st.transitions;
    }));
    var willTransition = stateTransitions.some(function (st) {
      return st.transitions.length > 0;
    });

    if (!willTransition) {
      return this.next(state, _event);
    }

    var configuration = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(Object.keys(transitionMap).map(function (key) {
      return transitionMap[key].configuration;
    }));
    return {
      transitions: enabledTransitions,
      exitSet: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(stateTransitions.map(function (t) {
        return t.exitSet;
      })),
      configuration: configuration,
      source: state,
      actions: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(Object.keys(transitionMap).map(function (key) {
        return transitionMap[key].actions;
      }))
    };
  };

  StateNode.prototype._transition = function (stateValue, state, _event) {
    // leaf node
    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(stateValue)) {
      return this.transitionLeafNode(stateValue, state, _event);
    } // hierarchical node


    if (Object.keys(stateValue).length === 1) {
      return this.transitionCompoundNode(stateValue, state, _event);
    } // orthogonal node


    return this.transitionParallelNode(stateValue, state, _event);
  };

  StateNode.prototype.getTransitionData = function (state, event) {
    return this._transition(state.value, state, (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(event));
  };

  StateNode.prototype.next = function (state, _event) {
    var e_3, _a;

    var _this = this;

    var eventName = _event.name;
    var actions = [];
    var nextStateNodes = [];
    var selectedTransition;

    try {
      for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(this.getCandidates(eventName)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var candidate = _c.value;
        var cond = candidate.cond,
            stateIn = candidate.in;
        var resolvedContext = state.context;
        var isInState = stateIn ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(stateIn) && isStateId(stateIn) ? // Check if in state by ID
        state.matches((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toStateValue)(this.getStateNodeById(stateIn).path, this.delimiter)) : // Check if in state by relative grandparent
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.matchesState)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toStateValue)(stateIn, this.delimiter), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.path)(this.path.slice(0, -2))(state.value)) : true;
        var guardPassed = false;

        try {
          guardPassed = !cond || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.evaluateGuard)(this.machine, cond, resolvedContext, _event, state);
        } catch (err) {
          throw new Error("Unable to evaluate guard '".concat(cond.name || cond.type, "' in transition for event '").concat(eventName, "' in state node '").concat(this.id, "':\n").concat(err.message));
        }

        if (guardPassed && isInState) {
          if (candidate.target !== undefined) {
            nextStateNodes = candidate.target;
          }

          actions.push.apply(actions, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(candidate.actions), false));
          selectedTransition = candidate;
          break;
        }
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    if (!selectedTransition) {
      return undefined;
    }

    if (!nextStateNodes.length) {
      return {
        transitions: [selectedTransition],
        exitSet: [],
        configuration: state.value ? [this] : [],
        source: state,
        actions: actions
      };
    }

    var allNextStateNodes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(nextStateNodes.map(function (stateNode) {
      return _this.getRelativeStateNodes(stateNode, state.historyValue);
    }));
    var isInternal = !!selectedTransition.internal;
    return {
      transitions: [selectedTransition],
      exitSet: isInternal ? [] : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(nextStateNodes.map(function (targetNode) {
        return _this.getPotentiallyReenteringNodes(targetNode);
      })),
      configuration: allNextStateNodes,
      source: state,
      actions: actions
    };
  }; // even though the name of this function mentions reentry nodes
  // we are pushing its result into `exitSet`
  // that's because what we exit might be reentered (it's an invariant of reentrancy)


  StateNode.prototype.getPotentiallyReenteringNodes = function (targetNode) {
    if (this.order < targetNode.order) {
      return [this];
    }

    var nodes = [];
    var marker = this;
    var possibleAncestor = targetNode;

    while (marker && marker !== possibleAncestor) {
      nodes.push(marker);
      marker = marker.parent;
    }

    if (marker !== possibleAncestor) {
      // we never got to `possibleAncestor`, therefore the initial `marker` "escapes" it
      // it's in a different part of the tree so no states will be reentered for such an external transition
      return [];
    }

    nodes.push(possibleAncestor);
    return nodes;
  };

  StateNode.prototype.getActions = function (resolvedConfig, isDone, transition, currentContext, _event, prevState, predictableExec) {
    var e_4, _a, e_5, _b;

    var _this = this;

    var prevConfig = prevState ? (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getConfiguration)([], this.getStateNodes(prevState.value)) : [];
    var entrySet = new Set();

    try {
      for (var _c = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(Array.from(resolvedConfig).sort(function (a, b) {
        return a.order - b.order;
      })), _d = _c.next(); !_d.done; _d = _c.next()) {
        var sn = _d.value;

        if (!(0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.has)(prevConfig, sn) || (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.has)(transition.exitSet, sn) || sn.parent && entrySet.has(sn.parent)) {
          entrySet.add(sn);
        }
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
      } finally {
        if (e_4) throw e_4.error;
      }
    }

    try {
      for (var prevConfig_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(prevConfig), prevConfig_1_1 = prevConfig_1.next(); !prevConfig_1_1.done; prevConfig_1_1 = prevConfig_1.next()) {
        var sn = prevConfig_1_1.value;

        if (!(0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.has)(resolvedConfig, sn) || (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.has)(transition.exitSet, sn.parent)) {
          transition.exitSet.push(sn);
        }
      }
    } catch (e_5_1) {
      e_5 = {
        error: e_5_1
      };
    } finally {
      try {
        if (prevConfig_1_1 && !prevConfig_1_1.done && (_b = prevConfig_1.return)) _b.call(prevConfig_1);
      } finally {
        if (e_5) throw e_5.error;
      }
    }

    transition.exitSet.sort(function (a, b) {
      return b.order - a.order;
    });
    var entryStates = Array.from(entrySet).sort(function (a, b) {
      return a.order - b.order;
    });
    var exitStates = new Set(transition.exitSet);
    var doneEvents = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(entryStates.map(function (sn) {
      var events = [];

      if (sn.type !== 'final') {
        return events;
      }

      var parent = sn.parent;

      if (!parent.parent) {
        return events;
      }

      events.push((0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.done)(sn.id, sn.doneData), // TODO: deprecate - final states should not emit done events for their own state.
      (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.done)(parent.id, sn.doneData ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapContext)(sn.doneData, currentContext, _event) : undefined));
      var grandparent = parent.parent;

      if (grandparent.type === 'parallel') {
        if ((0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getChildren)(grandparent).every(function (parentNode) {
          return (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.isInFinalState)(transition.configuration, parentNode);
        })) {
          events.push((0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.done)(grandparent.id));
        }
      }

      return events;
    }));
    var entryActions = entryStates.map(function (stateNode) {
      var entryActions = stateNode.onEntry;
      var invokeActions = stateNode.activities.map(function (activity) {
        return (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.start)(activity);
      });
      return {
        type: 'entry',
        actions: (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.toActionObjects)(predictableExec ? (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(entryActions), false), (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(invokeActions), false) : (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(invokeActions), false), (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(entryActions), false), _this.machine.options.actions)
      };
    }).concat({
      type: 'state_done',
      actions: doneEvents.map(function (event) {
        return (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.raise)(event);
      })
    });
    var exitActions = Array.from(exitStates).map(function (stateNode) {
      return {
        type: 'exit',
        actions: (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.toActionObjects)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(stateNode.onExit), false), (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(stateNode.activities.map(function (activity) {
          return (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.stop)(activity);
        })), false), _this.machine.options.actions)
      };
    });
    var actions = exitActions.concat({
      type: 'transition',
      actions: (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.toActionObjects)(transition.actions, this.machine.options.actions)
    }).concat(entryActions);

    if (isDone) {
      var stopActions = (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.toActionObjects)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(resolvedConfig), false).sort(function (a, b) {
        return b.order - a.order;
      }).map(function (stateNode) {
        return stateNode.onExit;
      })), this.machine.options.actions).filter(function (action) {
        return !(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isRaisableAction)(action);
      });
      return actions.concat({
        type: 'stop',
        actions: stopActions
      });
    }

    return actions;
  };
  /**
   * Determines the next state given the current `state` and sent `event`.
   *
   * @param state The current State instance or state value
   * @param event The event that was sent at the current state
   * @param context The current context (extended state) of the current state
   */


  StateNode.prototype.transition = function (state, event, context, exec) {
    if (state === void 0) {
      state = this.initialState;
    }

    var _event = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(event);

    var currentState;

    if (state instanceof _State_js__WEBPACK_IMPORTED_MODULE_7__.State) {
      currentState = context === undefined ? state : this.resolveState(_State_js__WEBPACK_IMPORTED_MODULE_7__.State.from(state, context));
    } else {
      var resolvedStateValue = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(state) ? this.resolve((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.pathToStateValue)(this.getResolvedPath(state))) : this.resolve(state);
      var resolvedContext = context !== null && context !== void 0 ? context : this.machine.context;
      currentState = this.resolveState(_State_js__WEBPACK_IMPORTED_MODULE_7__.State.from(resolvedStateValue, resolvedContext));
    }

    if (!_environment_js__WEBPACK_IMPORTED_MODULE_3__.IS_PRODUCTION && _event.name === WILDCARD) {
      throw new Error("An event cannot have the wildcard type ('".concat(WILDCARD, "')"));
    }

    if (this.strict) {
      if (!this.events.includes(_event.name) && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBuiltInEvent)(_event.name)) {
        throw new Error("Machine '".concat(this.id, "' does not accept event '").concat(_event.name, "'"));
      }
    }

    var stateTransition = this._transition(currentState.value, currentState, _event) || {
      transitions: [],
      configuration: [],
      exitSet: [],
      source: currentState,
      actions: []
    };
    var prevConfig = (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getConfiguration)([], this.getStateNodes(currentState.value));
    var resolvedConfig = stateTransition.configuration.length ? (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getConfiguration)(prevConfig, stateTransition.configuration) : prevConfig;
    stateTransition.configuration = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(resolvedConfig), false);
    return this.resolveTransition(stateTransition, currentState, currentState.context, exec, _event);
  };

  StateNode.prototype.resolveRaisedTransition = function (state, _event, originalEvent, predictableExec) {
    var _a;

    var currentActions = state.actions;
    state = this.transition(state, _event, undefined, predictableExec); // Save original event to state
    // TODO: this should be the raised event! Delete in V5 (breaking)

    state._event = originalEvent;
    state.event = originalEvent.data;

    (_a = state.actions).unshift.apply(_a, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(currentActions), false));

    return state;
  };

  StateNode.prototype.resolveTransition = function (stateTransition, currentState, context, predictableExec, _event) {
    var e_6, _a, e_7, _b;

    var _this = this;

    if (_event === void 0) {
      _event = _actions_js__WEBPACK_IMPORTED_MODULE_5__.initEvent;
    }

    var configuration = stateTransition.configuration; // Transition will "apply" if:
    // - this is the initial state (there is no current state)
    // - OR there are transitions

    var willTransition = !currentState || stateTransition.transitions.length > 0;
    var resolvedConfiguration = willTransition ? stateTransition.configuration : currentState ? currentState.configuration : [];
    var isDone = (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.isInFinalState)(resolvedConfiguration, this);
    var resolvedStateValue = willTransition ? (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getValue)(this.machine, configuration) : undefined;
    var historyValue = currentState ? currentState.historyValue ? currentState.historyValue : stateTransition.source ? this.machine.historyValue(currentState.value) : undefined : undefined;
    var actionBlocks = this.getActions(new Set(resolvedConfiguration), isDone, stateTransition, context, _event, currentState, predictableExec);
    var activities = currentState ? (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, currentState.activities) : {};

    try {
      for (var actionBlocks_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(actionBlocks), actionBlocks_1_1 = actionBlocks_1.next(); !actionBlocks_1_1.done; actionBlocks_1_1 = actionBlocks_1.next()) {
        var block = actionBlocks_1_1.value;

        try {
          for (var _c = (e_7 = void 0, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(block.actions)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var action = _d.value;

            if (action.type === _actionTypes_js__WEBPACK_IMPORTED_MODULE_8__.start) {
              activities[action.activity.id || action.activity.type] = action;
            } else if (action.type === _actionTypes_js__WEBPACK_IMPORTED_MODULE_8__.stop) {
              activities[action.activity.id || action.activity.type] = false;
            }
          }
        } catch (e_7_1) {
          e_7 = {
            error: e_7_1
          };
        } finally {
          try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
          } finally {
            if (e_7) throw e_7.error;
          }
        }
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (actionBlocks_1_1 && !actionBlocks_1_1.done && (_a = actionBlocks_1.return)) _a.call(actionBlocks_1);
      } finally {
        if (e_6) throw e_6.error;
      }
    }

    var _e = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)((0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.resolveActions)(this, currentState, context, _event, actionBlocks, predictableExec, this.machine.config.predictableActionArguments || this.machine.config.preserveActionOrder), 2),
        resolvedActions = _e[0],
        updatedContext = _e[1];

    var _f = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.partition)(resolvedActions, _utils_js__WEBPACK_IMPORTED_MODULE_0__.isRaisableAction), 2),
        raisedEvents = _f[0],
        nonRaisedActions = _f[1];

    var invokeActions = resolvedActions.filter(function (action) {
      var _a;

      return action.type === _actionTypes_js__WEBPACK_IMPORTED_MODULE_8__.start && ((_a = action.activity) === null || _a === void 0 ? void 0 : _a.type) === _actionTypes_js__WEBPACK_IMPORTED_MODULE_8__.invoke;
    });
    var children = invokeActions.reduce(function (acc, action) {
      acc[action.activity.id] = (0,_Actor_js__WEBPACK_IMPORTED_MODULE_9__.createInvocableActor)(action.activity, _this.machine, updatedContext, _event);
      return acc;
    }, currentState ? (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, currentState.children) : {});
    var nextState = new _State_js__WEBPACK_IMPORTED_MODULE_7__.State({
      value: resolvedStateValue || currentState.value,
      context: updatedContext,
      _event: _event,
      // Persist _sessionid between states
      _sessionid: currentState ? currentState._sessionid : null,
      historyValue: resolvedStateValue ? historyValue ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateHistoryValue)(historyValue, resolvedStateValue) : undefined : currentState ? currentState.historyValue : undefined,
      history: !resolvedStateValue || stateTransition.source ? currentState : undefined,
      actions: resolvedStateValue ? nonRaisedActions : [],
      activities: resolvedStateValue ? activities : currentState ? currentState.activities : {},
      events: [],
      configuration: resolvedConfiguration,
      transitions: stateTransition.transitions,
      children: children,
      done: isDone,
      tags: (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getTagsFromConfiguration)(resolvedConfiguration),
      machine: this
    });
    var didUpdateContext = context !== updatedContext;
    nextState.changed = _event.name === _actionTypes_js__WEBPACK_IMPORTED_MODULE_8__.update || didUpdateContext; // Dispose of penultimate histories to prevent memory leaks

    var history = nextState.history;

    if (history) {
      delete history.history;
    } // There are transient transitions if the machine is not in a final state
    // and if some of the state nodes have transient ("always") transitions.


    var hasAlwaysTransitions = !isDone && (this._transient || configuration.some(function (stateNode) {
      return stateNode._transient;
    })); // If there are no enabled transitions, check if there are transient transitions.
    // If there are transient transitions, continue checking for more transitions
    // because an transient transition should be triggered even if there are no
    // enabled transitions.
    //
    // If we're already working on an transient transition then stop to prevent an infinite loop.
    //
    // Otherwise, if there are no enabled nor transient transitions, we are done.

    if (!willTransition && (!hasAlwaysTransitions || _event.name === NULL_EVENT)) {
      return nextState;
    }

    var maybeNextState = nextState;

    if (!isDone) {
      if (hasAlwaysTransitions) {
        maybeNextState = this.resolveRaisedTransition(maybeNextState, {
          type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_8__.nullEvent
        }, _event, predictableExec);
      }

      while (raisedEvents.length) {
        var raisedEvent = raisedEvents.shift();
        maybeNextState = this.resolveRaisedTransition(maybeNextState, raisedEvent._event, _event, predictableExec);
      }
    } // Detect if state changed


    var changed = maybeNextState.changed || (history ? !!maybeNextState.actions.length || didUpdateContext || typeof history.value !== typeof maybeNextState.value || !(0,_State_js__WEBPACK_IMPORTED_MODULE_7__.stateValuesEqual)(maybeNextState.value, history.value) : undefined);
    maybeNextState.changed = changed; // Preserve original history after raised events

    maybeNextState.history = history;
    return maybeNextState;
  };
  /**
   * Returns the child state node from its relative `stateKey`, or throws.
   */


  StateNode.prototype.getStateNode = function (stateKey) {
    if (isStateId(stateKey)) {
      return this.machine.getStateNodeById(stateKey);
    }

    if (!this.states) {
      throw new Error("Unable to retrieve child state '".concat(stateKey, "' from '").concat(this.id, "'; no child states exist."));
    }

    var result = this.states[stateKey];

    if (!result) {
      throw new Error("Child state '".concat(stateKey, "' does not exist on '").concat(this.id, "'"));
    }

    return result;
  };
  /**
   * Returns the state node with the given `stateId`, or throws.
   *
   * @param stateId The state ID. The prefix "#" is removed.
   */


  StateNode.prototype.getStateNodeById = function (stateId) {
    var resolvedStateId = isStateId(stateId) ? stateId.slice(STATE_IDENTIFIER.length) : stateId;

    if (resolvedStateId === this.id) {
      return this;
    }

    var stateNode = this.machine.idMap[resolvedStateId];

    if (!stateNode) {
      throw new Error("Child state node '#".concat(resolvedStateId, "' does not exist on machine '").concat(this.id, "'"));
    }

    return stateNode;
  };
  /**
   * Returns the relative state node from the given `statePath`, or throws.
   *
   * @param statePath The string or string array relative path to the state node.
   */


  StateNode.prototype.getStateNodeByPath = function (statePath) {
    if (typeof statePath === 'string' && isStateId(statePath)) {
      try {
        return this.getStateNodeById(statePath.slice(1));
      } catch (e) {// try individual paths
        // throw e;
      }
    }

    var arrayStatePath = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toStatePath)(statePath, this.delimiter).slice();
    var currentStateNode = this;

    while (arrayStatePath.length) {
      var key = arrayStatePath.shift();

      if (!key.length) {
        break;
      }

      currentStateNode = currentStateNode.getStateNode(key);
    }

    return currentStateNode;
  };
  /**
   * Resolves a partial state value with its full representation in this machine.
   *
   * @param stateValue The partial state value to resolve.
   */


  StateNode.prototype.resolve = function (stateValue) {
    var _a;

    var _this = this;

    if (!stateValue) {
      return this.initialStateValue || EMPTY_OBJECT; // TODO: type-specific properties
    }

    switch (this.type) {
      case 'parallel':
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValues)(this.initialStateValue, function (subStateValue, subStateKey) {
          return subStateValue ? _this.getStateNode(subStateKey).resolve(stateValue[subStateKey] || subStateValue) : EMPTY_OBJECT;
        });

      case 'compound':
        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(stateValue)) {
          var subStateNode = this.getStateNode(stateValue);

          if (subStateNode.type === 'parallel' || subStateNode.type === 'compound') {
            return _a = {}, _a[stateValue] = subStateNode.initialStateValue, _a;
          }

          return stateValue;
        }

        if (!Object.keys(stateValue).length) {
          return this.initialStateValue || {};
        }

        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValues)(stateValue, function (subStateValue, subStateKey) {
          return subStateValue ? _this.getStateNode(subStateKey).resolve(subStateValue) : EMPTY_OBJECT;
        });

      default:
        return stateValue || EMPTY_OBJECT;
    }
  };

  StateNode.prototype.getResolvedPath = function (stateIdentifier) {
    if (isStateId(stateIdentifier)) {
      var stateNode = this.machine.idMap[stateIdentifier.slice(STATE_IDENTIFIER.length)];

      if (!stateNode) {
        throw new Error("Unable to find state node '".concat(stateIdentifier, "'"));
      }

      return stateNode.path;
    }

    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toStatePath)(stateIdentifier, this.delimiter);
  };

  Object.defineProperty(StateNode.prototype, "initialStateValue", {
    get: function () {
      var _a;

      if (this.__cache.initialStateValue) {
        return this.__cache.initialStateValue;
      }

      var initialStateValue;

      if (this.type === 'parallel') {
        initialStateValue = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapFilterValues)(this.states, function (state) {
          return state.initialStateValue || EMPTY_OBJECT;
        }, function (stateNode) {
          return !(stateNode.type === 'history');
        });
      } else if (this.initial !== undefined) {
        if (!this.states[this.initial]) {
          throw new Error("Initial state '".concat(this.initial, "' not found on '").concat(this.key, "'"));
        }

        initialStateValue = (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.isLeafNode)(this.states[this.initial]) ? this.initial : (_a = {}, _a[this.initial] = this.states[this.initial].initialStateValue, _a);
      } else {
        // The finite state value of a machine without child states is just an empty object
        initialStateValue = {};
      }

      this.__cache.initialStateValue = initialStateValue;
      return this.__cache.initialStateValue;
    },
    enumerable: false,
    configurable: true
  });

  StateNode.prototype.getInitialState = function (stateValue, context) {
    this._init(); // TODO: this should be in the constructor (see note in constructor)


    var configuration = this.getStateNodes(stateValue);
    return this.resolveTransition({
      configuration: configuration,
      exitSet: [],
      transitions: [],
      source: undefined,
      actions: []
    }, undefined, context !== null && context !== void 0 ? context : this.machine.context, undefined);
  };

  Object.defineProperty(StateNode.prototype, "initialState", {
    /**
     * The initial State instance, which includes all actions to be executed from
     * entering the initial state.
     */
    get: function () {
      var initialStateValue = this.initialStateValue;

      if (!initialStateValue) {
        throw new Error("Cannot retrieve initial state from simple state '".concat(this.id, "'."));
      }

      return this.getInitialState(initialStateValue);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "target", {
    /**
     * The target state value of the history state node, if it exists. This represents the
     * default state value to transition to if no history value exists yet.
     */
    get: function () {
      var target;

      if (this.type === 'history') {
        var historyConfig = this.config;

        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(historyConfig.target)) {
          target = isStateId(historyConfig.target) ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.pathToStateValue)(this.machine.getStateNodeById(historyConfig.target).path.slice(this.path.length - 1)) : historyConfig.target;
        } else {
          target = historyConfig.target;
        }
      }

      return target;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Returns the leaf nodes from a state path relative to this state node.
   *
   * @param relativeStateId The relative state path to retrieve the state nodes
   * @param history The previous state to retrieve history
   * @param resolve Whether state nodes should resolve to initial child state nodes
   */

  StateNode.prototype.getRelativeStateNodes = function (relativeStateId, historyValue, resolve) {
    if (resolve === void 0) {
      resolve = true;
    }

    return resolve ? relativeStateId.type === 'history' ? relativeStateId.resolveHistory(historyValue) : relativeStateId.initialStateNodes : [relativeStateId];
  };

  Object.defineProperty(StateNode.prototype, "initialStateNodes", {
    get: function () {
      var _this = this;

      if ((0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.isLeafNode)(this)) {
        return [this];
      } // Case when state node is compound but no initial state is defined


      if (this.type === 'compound' && !this.initial) {
        if (!_environment_js__WEBPACK_IMPORTED_MODULE_3__.IS_PRODUCTION) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(false, "Compound state node '".concat(this.id, "' has no initial state."));
        }

        return [this];
      }

      var initialStateNodePaths = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toStatePaths)(this.initialStateValue);
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(initialStateNodePaths.map(function (initialPath) {
        return _this.getFromRelativePath(initialPath);
      }));
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Retrieves state nodes from a relative path to this state node.
   *
   * @param relativePath The relative path from this state node
   * @param historyValue
   */

  StateNode.prototype.getFromRelativePath = function (relativePath) {
    if (!relativePath.length) {
      return [this];
    }

    var _a = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(relativePath),
        stateKey = _a[0],
        childStatePath = _a.slice(1);

    if (!this.states) {
      throw new Error("Cannot retrieve subPath '".concat(stateKey, "' from node with no states"));
    }

    var childStateNode = this.getStateNode(stateKey);

    if (childStateNode.type === 'history') {
      return childStateNode.resolveHistory();
    }

    if (!this.states[stateKey]) {
      throw new Error("Child state '".concat(stateKey, "' does not exist on '").concat(this.id, "'"));
    }

    return this.states[stateKey].getFromRelativePath(childStatePath);
  };

  StateNode.prototype.historyValue = function (relativeStateValue) {
    if (!Object.keys(this.states).length) {
      return undefined;
    }

    return {
      current: relativeStateValue || this.initialStateValue,
      states: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapFilterValues)(this.states, function (stateNode, key) {
        if (!relativeStateValue) {
          return stateNode.historyValue();
        }

        var subStateValue = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(relativeStateValue) ? undefined : relativeStateValue[key];
        return stateNode.historyValue(subStateValue || stateNode.initialStateValue);
      }, function (stateNode) {
        return !stateNode.history;
      })
    };
  };
  /**
   * Resolves to the historical value(s) of the parent state node,
   * represented by state nodes.
   *
   * @param historyValue
   */


  StateNode.prototype.resolveHistory = function (historyValue) {
    var _this = this;

    if (this.type !== 'history') {
      return [this];
    }

    var parent = this.parent;

    if (!historyValue) {
      var historyTarget = this.target;
      return historyTarget ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toStatePaths)(historyTarget).map(function (relativeChildPath) {
        return parent.getFromRelativePath(relativeChildPath);
      })) : parent.initialStateNodes;
    }

    var subHistoryValue = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.nestedPath)(parent.path, 'states')(historyValue).current;

    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(subHistoryValue)) {
      return [parent.getStateNode(subHistoryValue)];
    }

    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toStatePaths)(subHistoryValue).map(function (subStatePath) {
      return _this.history === 'deep' ? parent.getFromRelativePath(subStatePath) : [parent.states[subStatePath[0]]];
    }));
  };

  Object.defineProperty(StateNode.prototype, "stateIds", {
    /**
     * All the state node IDs of this state node and its descendant state nodes.
     */
    get: function () {
      var _this = this;

      var childStateIds = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(Object.keys(this.states).map(function (stateKey) {
        return _this.states[stateKey].stateIds;
      }));
      return [this.id].concat(childStateIds);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "events", {
    /**
     * All the event types accepted by this state node and its descendants.
     */
    get: function () {
      var e_8, _a, e_9, _b;

      if (this.__cache.events) {
        return this.__cache.events;
      }

      var states = this.states;
      var events = new Set(this.ownEvents);

      if (states) {
        try {
          for (var _c = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(Object.keys(states)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var stateId = _d.value;
            var state = states[stateId];

            if (state.states) {
              try {
                for (var _e = (e_9 = void 0, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(state.events)), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var event_1 = _f.value;
                  events.add("".concat(event_1));
                }
              } catch (e_9_1) {
                e_9 = {
                  error: e_9_1
                };
              } finally {
                try {
                  if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                } finally {
                  if (e_9) throw e_9.error;
                }
              }
            }
          }
        } catch (e_8_1) {
          e_8 = {
            error: e_8_1
          };
        } finally {
          try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
          } finally {
            if (e_8) throw e_8.error;
          }
        }
      }

      return this.__cache.events = Array.from(events);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "ownEvents", {
    /**
     * All the events that have transitions directly from this state node.
     *
     * Excludes any inert events.
     */
    get: function () {
      var events = new Set(this.transitions.filter(function (transition) {
        return !(!transition.target && !transition.actions.length && transition.internal);
      }).map(function (transition) {
        return transition.eventType;
      }));
      return Array.from(events);
    },
    enumerable: false,
    configurable: true
  });

  StateNode.prototype.resolveTarget = function (_target) {
    var _this = this;

    if (_target === undefined) {
      // an undefined target signals that the state node should not transition from that state when receiving that event
      return undefined;
    }

    return _target.map(function (target) {
      if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(target)) {
        return target;
      }

      var isInternalTarget = target[0] === _this.delimiter; // If internal target is defined on machine,
      // do not include machine key on target

      if (isInternalTarget && !_this.parent) {
        return _this.getStateNodeByPath(target.slice(1));
      }

      var resolvedTarget = isInternalTarget ? _this.key + target : target;

      if (_this.parent) {
        try {
          var targetStateNode = _this.parent.getStateNodeByPath(resolvedTarget);

          return targetStateNode;
        } catch (err) {
          throw new Error("Invalid transition definition for state node '".concat(_this.id, "':\n").concat(err.message));
        }
      } else {
        return _this.getStateNodeByPath(resolvedTarget);
      }
    });
  };

  StateNode.prototype.formatTransition = function (transitionConfig) {
    var _this = this;

    var normalizedTarget = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalizeTarget)(transitionConfig.target);
    var internal = 'internal' in transitionConfig ? transitionConfig.internal : normalizedTarget ? normalizedTarget.some(function (_target) {
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(_target) && _target[0] === _this.delimiter;
    }) : true;
    var guards = this.machine.options.guards;
    var target = this.resolveTarget(normalizedTarget);

    var transition = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, transitionConfig), {
      actions: (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.toActionObjects)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(transitionConfig.actions)),
      cond: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toGuard)(transitionConfig.cond, guards),
      target: target,
      source: this,
      internal: internal,
      eventType: transitionConfig.event,
      toJSON: function () {
        return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, transition), {
          target: transition.target ? transition.target.map(function (t) {
            return "#".concat(t.id);
          }) : undefined,
          source: "#".concat(_this.id)
        });
      }
    });

    return transition;
  };

  StateNode.prototype.formatTransitions = function () {
    var e_10, _a;

    var _this = this;

    var onConfig;

    if (!this.config.on) {
      onConfig = [];
    } else if (Array.isArray(this.config.on)) {
      onConfig = this.config.on;
    } else {
      var _b = this.config.on,
          _c = WILDCARD,
          _d = _b[_c],
          wildcardConfigs = _d === void 0 ? [] : _d,
          strictTransitionConfigs_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__rest)(_b, [typeof _c === "symbol" ? _c : _c + ""]);

      onConfig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(Object.keys(strictTransitionConfigs_1).map(function (key) {
        if (!_environment_js__WEBPACK_IMPORTED_MODULE_3__.IS_PRODUCTION && key === NULL_EVENT) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(false, "Empty string transition configs (e.g., `{ on: { '': ... }}`) for transient transitions are deprecated. Specify the transition in the `{ always: ... }` property instead. " + "Please check the `on` configuration for \"#".concat(_this.id, "\"."));
        }

        var transitionConfigArray = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toTransitionConfigArray)(key, strictTransitionConfigs_1[key]);

        if (!_environment_js__WEBPACK_IMPORTED_MODULE_3__.IS_PRODUCTION) {
          validateArrayifiedTransitions(_this, key, transitionConfigArray);
        }

        return transitionConfigArray;
      }).concat((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toTransitionConfigArray)(WILDCARD, wildcardConfigs)));
    }

    var eventlessConfig = this.config.always ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toTransitionConfigArray)('', this.config.always) : [];
    var doneConfig = this.config.onDone ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toTransitionConfigArray)(String((0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.done)(this.id)), this.config.onDone) : [];

    if (!_environment_js__WEBPACK_IMPORTED_MODULE_3__.IS_PRODUCTION) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(!(this.config.onDone && !this.parent), "Root nodes cannot have an \".onDone\" transition. Please check the config of \"".concat(this.id, "\"."));
    }

    var invokeConfig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(this.invoke.map(function (invokeDef) {
      var settleTransitions = [];

      if (invokeDef.onDone) {
        settleTransitions.push.apply(settleTransitions, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toTransitionConfigArray)(String((0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.doneInvoke)(invokeDef.id)), invokeDef.onDone)), false));
      }

      if (invokeDef.onError) {
        settleTransitions.push.apply(settleTransitions, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toTransitionConfigArray)(String((0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.error)(invokeDef.id)), invokeDef.onError)), false));
      }

      return settleTransitions;
    }));
    var delayedTransitions = this.after;
    var formattedTransitions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(doneConfig), false), (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(invokeConfig), false), (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(onConfig), false), (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(eventlessConfig), false).map(function (transitionConfig) {
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(transitionConfig).map(function (transition) {
        return _this.formatTransition(transition);
      });
    }));

    try {
      for (var delayedTransitions_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(delayedTransitions), delayedTransitions_1_1 = delayedTransitions_1.next(); !delayedTransitions_1_1.done; delayedTransitions_1_1 = delayedTransitions_1.next()) {
        var delayedTransition = delayedTransitions_1_1.value;
        formattedTransitions.push(delayedTransition);
      }
    } catch (e_10_1) {
      e_10 = {
        error: e_10_1
      };
    } finally {
      try {
        if (delayedTransitions_1_1 && !delayedTransitions_1_1.done && (_a = delayedTransitions_1.return)) _a.call(delayedTransitions_1);
      } finally {
        if (e_10) throw e_10.error;
      }
    }

    return formattedTransitions;
  };

  return StateNode;
}();




/***/ }),

/***/ "./node_modules/xstate/es/_virtual/_tslib.js":
/*!***************************************************!*\
  !*** ./node_modules/xstate/es/_virtual/_tslib.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __assign: () => (/* binding */ __assign),
/* harmony export */   __read: () => (/* binding */ __read),
/* harmony export */   __rest: () => (/* binding */ __rest),
/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),
/* harmony export */   __values: () => (/* binding */ __values)
/* harmony export */ });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}




/***/ }),

/***/ "./node_modules/xstate/es/actionTypes.js":
/*!***********************************************!*\
  !*** ./node_modules/xstate/es/actionTypes.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   after: () => (/* binding */ after),
/* harmony export */   assign: () => (/* binding */ assign),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   choose: () => (/* binding */ choose),
/* harmony export */   doneState: () => (/* binding */ doneState),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   errorExecution: () => (/* binding */ errorExecution),
/* harmony export */   errorPlatform: () => (/* binding */ errorPlatform),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   invoke: () => (/* binding */ invoke),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   nullEvent: () => (/* binding */ nullEvent),
/* harmony export */   pure: () => (/* binding */ pure),
/* harmony export */   raise: () => (/* binding */ raise),
/* harmony export */   send: () => (/* binding */ send),
/* harmony export */   start: () => (/* binding */ start),
/* harmony export */   stop: () => (/* binding */ stop),
/* harmony export */   update: () => (/* binding */ update)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "./node_modules/xstate/es/types.js");


var start = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Start;
var stop = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Stop;
var raise = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Raise;
var send = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Send;
var cancel = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Cancel;
var nullEvent = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.NullEvent;
var assign = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Assign;
var after = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.After;
var doneState = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.DoneState;
var log = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Log;
var init = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Init;
var invoke = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Invoke;
var errorExecution = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.ErrorExecution;
var errorPlatform = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.ErrorPlatform;
var error = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.ErrorCustom;
var update = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Update;
var choose = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Choose;
var pure = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Pure;




/***/ }),

/***/ "./node_modules/xstate/es/actions.js":
/*!*******************************************!*\
  !*** ./node_modules/xstate/es/actions.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   actionTypes: () => (/* reexport module object */ _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   after: () => (/* binding */ after),
/* harmony export */   assign: () => (/* binding */ assign),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   choose: () => (/* binding */ choose),
/* harmony export */   done: () => (/* binding */ done),
/* harmony export */   doneInvoke: () => (/* binding */ doneInvoke),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   escalate: () => (/* binding */ escalate),
/* harmony export */   forwardTo: () => (/* binding */ forwardTo),
/* harmony export */   getActionFunction: () => (/* binding */ getActionFunction),
/* harmony export */   initEvent: () => (/* binding */ initEvent),
/* harmony export */   isActionObject: () => (/* binding */ isActionObject),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   pure: () => (/* binding */ pure),
/* harmony export */   raise: () => (/* binding */ raise),
/* harmony export */   resolveActions: () => (/* binding */ resolveActions),
/* harmony export */   resolveLog: () => (/* binding */ resolveLog),
/* harmony export */   resolveRaise: () => (/* binding */ resolveRaise),
/* harmony export */   resolveSend: () => (/* binding */ resolveSend),
/* harmony export */   resolveStop: () => (/* binding */ resolveStop),
/* harmony export */   respond: () => (/* binding */ respond),
/* harmony export */   send: () => (/* binding */ send),
/* harmony export */   sendParent: () => (/* binding */ sendParent),
/* harmony export */   sendTo: () => (/* binding */ sendTo),
/* harmony export */   sendUpdate: () => (/* binding */ sendUpdate),
/* harmony export */   start: () => (/* binding */ start),
/* harmony export */   stop: () => (/* binding */ stop),
/* harmony export */   toActionObject: () => (/* binding */ toActionObject),
/* harmony export */   toActionObjects: () => (/* binding */ toActionObjects),
/* harmony export */   toActivityDefinition: () => (/* binding */ toActivityDefinition)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.js */ "./node_modules/xstate/es/types.js");
/* harmony import */ var _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actionTypes.js */ "./node_modules/xstate/es/actionTypes.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./environment.js */ "./node_modules/xstate/es/environment.js");








var initEvent = /*#__PURE__*/(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toSCXMLEvent)({
  type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.init
});
function getActionFunction(actionType, actionFunctionMap) {
  return actionFunctionMap ? actionFunctionMap[actionType] || undefined : undefined;
}
function toActionObject(action, actionFunctionMap) {
  var actionObject;

  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(action) || typeof action === 'number') {
    var exec = getActionFunction(action, actionFunctionMap);

    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(exec)) {
      actionObject = {
        type: action,
        exec: exec
      };
    } else if (exec) {
      actionObject = exec;
    } else {
      actionObject = {
        type: action,
        exec: undefined
      };
    }
  } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(action)) {
    actionObject = {
      // Convert action to string if unnamed
      type: action.name || action.toString(),
      exec: action
    };
  } else {
    var exec = getActionFunction(action.type, actionFunctionMap);

    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(exec)) {
      actionObject = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, action), {
        exec: exec
      });
    } else if (exec) {
      var actionType = exec.type || action.type;
      actionObject = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, exec), action), {
        type: actionType
      });
    } else {
      actionObject = action;
    }
  }

  return actionObject;
}
var toActionObjects = function (action, actionFunctionMap) {
  if (!action) {
    return [];
  }

  var actions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(action) ? action : [action];
  return actions.map(function (subAction) {
    return toActionObject(subAction, actionFunctionMap);
  });
};
function toActivityDefinition(action) {
  var actionObject = toActionObject(action);
  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({
    id: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(action) ? action : actionObject.id
  }, actionObject), {
    type: actionObject.type
  });
}
/**
 * Raises an event. This places the event in the internal event queue, so that
 * the event is immediately consumed by the machine in the current step.
 *
 * @param eventType The event to raise.
 */

function raise(event, options) {
  return {
    type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.raise,
    event: typeof event === 'function' ? event : (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toEventObject)(event),
    delay: options ? options.delay : undefined,
    id: options === null || options === void 0 ? void 0 : options.id
  };
}
function resolveRaise(action, ctx, _event, delaysMap) {
  var meta = {
    _event: _event
  };
  var resolvedEvent = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toSCXMLEvent)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(action.event) ? action.event(ctx, _event.data, meta) : action.event);
  var resolvedDelay;

  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(action.delay)) {
    var configDelay = delaysMap && delaysMap[action.delay];
    resolvedDelay = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;
  } else {
    resolvedDelay = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;
  }

  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, action), {
    type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.raise,
    _event: resolvedEvent,
    delay: resolvedDelay
  });
}
/**
 * Sends an event. This returns an action that will be read by an interpreter to
 * send the event in the next step, after the current step is finished executing.
 *
 * @deprecated Use the `sendTo(...)` action creator instead.
 *
 * @param event The event to send.
 * @param options Options to pass into the send event:
 *  - `id` - The unique send event identifier (used with `cancel()`).
 *  - `delay` - The number of milliseconds to delay the sending of the event.
 *  - `to` - The target of this event (by default, the machine the event was sent from).
 */

function send(event, options) {
  return {
    to: options ? options.to : undefined,
    type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.send,
    event: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(event) ? event : (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toEventObject)(event),
    delay: options ? options.delay : undefined,
    // TODO: don't auto-generate IDs here like that
    // there is too big chance of the ID collision
    id: options && options.id !== undefined ? options.id : (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(event) ? event.name : (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getEventType)(event)
  };
}
function resolveSend(action, ctx, _event, delaysMap) {
  var meta = {
    _event: _event
  }; // TODO: helper function for resolving Expr

  var resolvedEvent = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toSCXMLEvent)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(action.event) ? action.event(ctx, _event.data, meta) : action.event);
  var resolvedDelay;

  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(action.delay)) {
    var configDelay = delaysMap && delaysMap[action.delay];
    resolvedDelay = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;
  } else {
    resolvedDelay = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;
  }

  var resolvedTarget = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(action.to) ? action.to(ctx, _event.data, meta) : action.to;
  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, action), {
    to: resolvedTarget,
    _event: resolvedEvent,
    event: resolvedEvent.data,
    delay: resolvedDelay
  });
}
/**
 * Sends an event to this machine's parent.
 *
 * @param event The event to send to the parent machine.
 * @param options Options to pass into the send event.
 */

function sendParent(event, options) {
  return send(event, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options), {
    to: _types_js__WEBPACK_IMPORTED_MODULE_3__.SpecialTargets.Parent
  }));
}
/**
 * Sends an event to an actor.
 *
 * @param actor The `ActorRef` to send the event to.
 * @param event The event to send, or an expression that evaluates to the event to send
 * @param options Send action options
 * @returns An XState send action object
 */

function sendTo(actor, event, options) {
  return send(event, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options), {
    to: actor
  }));
}
/**
 * Sends an update event to this machine's parent.
 */

function sendUpdate() {
  return sendParent(_actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.update);
}
/**
 * Sends an event back to the sender of the original event.
 *
 * @param event The event to send back to the sender
 * @param options Options to pass into the send event
 */

function respond(event, options) {
  return send(event, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options), {
    to: function (_, __, _a) {
      var _event = _a._event;
      return _event.origin; // TODO: handle when _event.origin is undefined
    }
  }));
}

var defaultLogExpr = function (context, event) {
  return {
    context: context,
    event: event
  };
};
/**
 *
 * @param expr The expression function to evaluate which will be logged.
 *  Takes in 2 arguments:
 *  - `ctx` - the current state context
 *  - `event` - the event that caused this action to be executed.
 * @param label The label to give to the logged expression.
 */


function log(expr, label) {
  if (expr === void 0) {
    expr = defaultLogExpr;
  }

  return {
    type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.log,
    label: label,
    expr: expr
  };
}
var resolveLog = function (action, ctx, _event) {
  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, action), {
    value: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(action.expr) ? action.expr : action.expr(ctx, _event.data, {
      _event: _event
    })
  });
};
/**
 * Cancels an in-flight `send(...)` action. A canceled sent action will not
 * be executed, nor will its event be sent, unless it has already been sent
 * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).
 *
 * @param sendId The `id` of the `send(...)` action to cancel.
 */

var cancel = function (sendId) {
  return {
    type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.cancel,
    sendId: sendId
  };
};
/**
 * Starts an activity.
 *
 * @param activity The activity to start.
 */

function start(activity) {
  var activityDef = toActivityDefinition(activity);
  return {
    type: _types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.Start,
    activity: activityDef,
    exec: undefined
  };
}
/**
 * Stops an activity.
 *
 * @param actorRef The activity to stop.
 */

function stop(actorRef) {
  var activity = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(actorRef) ? actorRef : toActivityDefinition(actorRef);
  return {
    type: _types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.Stop,
    activity: activity,
    exec: undefined
  };
}
function resolveStop(action, context, _event) {
  var actorRefOrString = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(action.activity) ? action.activity(context, _event.data) : action.activity;
  var resolvedActorRef = typeof actorRefOrString === 'string' ? {
    id: actorRefOrString
  } : actorRefOrString;
  var actionObject = {
    type: _types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.Stop,
    activity: resolvedActorRef
  };
  return actionObject;
}
/**
 * Updates the current context of the machine.
 *
 * @param assignment An object that represents the partial context to update.
 */

var assign = function (assignment) {
  return {
    type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.assign,
    assignment: assignment
  };
};
function isActionObject(action) {
  return typeof action === 'object' && 'type' in action;
}
/**
 * Returns an event type that represents an implicit event that
 * is sent after the specified `delay`.
 *
 * @param delayRef The delay in milliseconds
 * @param id The state node ID where this event is handled
 */

function after(delayRef, id) {
  var idSuffix = id ? "#".concat(id) : '';
  return "".concat(_types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.After, "(").concat(delayRef, ")").concat(idSuffix);
}
/**
 * Returns an event that represents that a final state node
 * has been reached in the parent state node.
 *
 * @param id The final state node's parent state node `id`
 * @param data The data to pass into the event
 */

function done(id, data) {
  var type = "".concat(_types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.DoneState, ".").concat(id);
  var eventObject = {
    type: type,
    data: data
  };

  eventObject.toString = function () {
    return type;
  };

  return eventObject;
}
/**
 * Returns an event that represents that an invoked service has terminated.
 *
 * An invoked service is terminated when it has reached a top-level final state node,
 * but not when it is canceled.
 *
 * @param id The final state node ID
 * @param data The data to pass into the event
 */

function doneInvoke(id, data) {
  var type = "".concat(_types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.DoneInvoke, ".").concat(id);
  var eventObject = {
    type: type,
    data: data
  };

  eventObject.toString = function () {
    return type;
  };

  return eventObject;
}
function error(id, data) {
  var type = "".concat(_types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.ErrorPlatform, ".").concat(id);
  var eventObject = {
    type: type,
    data: data
  };

  eventObject.toString = function () {
    return type;
  };

  return eventObject;
}
function pure(getActions) {
  return {
    type: _types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.Pure,
    get: getActions
  };
}
/**
 * Forwards (sends) an event to a specified service.
 *
 * @param target The target service to forward the event to.
 * @param options Options to pass into the send action creator.
 */

function forwardTo(target, options) {
  if (!_environment_js__WEBPACK_IMPORTED_MODULE_4__.IS_PRODUCTION && (!target || typeof target === 'function')) {
    var originalTarget_1 = target;

    target = function () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      var resolvedTarget = typeof originalTarget_1 === 'function' ? originalTarget_1.apply(void 0, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(args), false)) : originalTarget_1;

      if (!resolvedTarget) {
        throw new Error("Attempted to forward event to undefined actor. This risks an infinite loop in the sender.");
      }

      return resolvedTarget;
    };
  }

  return send(function (_, event) {
    return event;
  }, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options), {
    to: target
  }));
}
/**
 * Escalates an error by sending it as an event to this machine's parent.
 *
 * @param errorData The error data to send, or the expression function that
 * takes in the `context`, `event`, and `meta`, and returns the error data to send.
 * @param options Options to pass into the send action creator.
 */

function escalate(errorData, options) {
  return sendParent(function (context, event, meta) {
    return {
      type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.error,
      data: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(errorData) ? errorData(context, event, meta) : errorData
    };
  }, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options), {
    to: _types_js__WEBPACK_IMPORTED_MODULE_3__.SpecialTargets.Parent
  }));
}
function choose(conds) {
  return {
    type: _types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.Choose,
    conds: conds
  };
}

var pluckAssigns = function (actionBlocks) {
  var e_1, _a;

  var assignActions = [];

  try {
    for (var actionBlocks_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(actionBlocks), actionBlocks_1_1 = actionBlocks_1.next(); !actionBlocks_1_1.done; actionBlocks_1_1 = actionBlocks_1.next()) {
      var block = actionBlocks_1_1.value;
      var i = 0;

      while (i < block.actions.length) {
        if (block.actions[i].type === _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.assign) {
          assignActions.push(block.actions[i]);
          block.actions.splice(i, 1);
          continue;
        }

        i++;
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (actionBlocks_1_1 && !actionBlocks_1_1.done && (_a = actionBlocks_1.return)) _a.call(actionBlocks_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  return assignActions;
};

function resolveActions(machine, currentState, currentContext, _event, actionBlocks, predictableExec, preserveActionOrder) {
  if (preserveActionOrder === void 0) {
    preserveActionOrder = false;
  }

  var assignActions = preserveActionOrder ? [] : pluckAssigns(actionBlocks);
  var updatedContext = assignActions.length ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.updateContext)(currentContext, _event, assignActions, currentState) : currentContext;
  var preservedContexts = preserveActionOrder ? [currentContext] : undefined;
  var deferredToBlockEnd = [];

  function handleAction(blockType, actionObject) {
    var _a;

    switch (actionObject.type) {
      case _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.raise:
        {
          var raisedAction = resolveRaise(actionObject, updatedContext, _event, machine.options.delays);

          if (predictableExec && typeof raisedAction.delay === 'number') {
            predictableExec(raisedAction, updatedContext, _event);
          }

          return raisedAction;
        }

      case _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.send:
        var sendAction = resolveSend(actionObject, updatedContext, _event, machine.options.delays); // TODO: fix ActionTypes.Init

        if (!_environment_js__WEBPACK_IMPORTED_MODULE_4__.IS_PRODUCTION) {
          var configuredDelay = actionObject.delay; // warn after resolving as we can create better contextual message here

          (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.warn)(!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(configuredDelay) || typeof sendAction.delay === 'number', // tslint:disable-next-line:max-line-length
          "No delay reference for delay expression '".concat(configuredDelay, "' was found on machine '").concat(machine.id, "'"));
        }

        if (predictableExec && sendAction.to !== _types_js__WEBPACK_IMPORTED_MODULE_3__.SpecialTargets.Internal) {
          if (blockType === 'entry') {
            deferredToBlockEnd.push(sendAction);
          } else {
            predictableExec(sendAction, updatedContext, _event);
          }
        }

        return sendAction;

      case _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.log:
        {
          var resolved = resolveLog(actionObject, updatedContext, _event);
          predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(resolved, updatedContext, _event);
          return resolved;
        }

      case _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.choose:
        {
          var chooseAction = actionObject;
          var matchedActions = (_a = chooseAction.conds.find(function (condition) {
            var guard = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toGuard)(condition.cond, machine.options.guards);
            return !guard || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.evaluateGuard)(machine, guard, updatedContext, _event, !predictableExec ? currentState : undefined);
          })) === null || _a === void 0 ? void 0 : _a.actions;

          if (!matchedActions) {
            return [];
          }

          var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(resolveActions(machine, currentState, updatedContext, _event, [{
            type: blockType,
            actions: toActionObjects((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray)(matchedActions), machine.options.actions)
          }], predictableExec, preserveActionOrder), 2),
              resolvedActionsFromChoose = _b[0],
              resolvedContextFromChoose = _b[1];

          updatedContext = resolvedContextFromChoose;
          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);
          return resolvedActionsFromChoose;
        }

      case _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.pure:
        {
          var matchedActions = actionObject.get(updatedContext, _event.data);

          if (!matchedActions) {
            return [];
          }

          var _c = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(resolveActions(machine, currentState, updatedContext, _event, [{
            type: blockType,
            actions: toActionObjects((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray)(matchedActions), machine.options.actions)
          }], predictableExec, preserveActionOrder), 2),
              resolvedActionsFromPure = _c[0],
              resolvedContext = _c[1];

          updatedContext = resolvedContext;
          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);
          return resolvedActionsFromPure;
        }

      case _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.stop:
        {
          var resolved = resolveStop(actionObject, updatedContext, _event);
          predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(resolved, currentContext, _event);
          return resolved;
        }

      case _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.assign:
        {
          updatedContext = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.updateContext)(updatedContext, _event, [actionObject], !predictableExec ? currentState : undefined);
          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);
          break;
        }

      default:
        var resolvedActionObject = toActionObject(actionObject, machine.options.actions);
        var exec_1 = resolvedActionObject.exec;

        if (predictableExec) {
          predictableExec(resolvedActionObject, updatedContext, _event);
        } else if (exec_1 && preservedContexts) {
          var contextIndex_1 = preservedContexts.length - 1;

          var wrapped = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, resolvedActionObject), {
            exec: function (_ctx) {
              var args = [];

              for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
              }

              exec_1.apply(void 0, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([preservedContexts[contextIndex_1]], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(args), false));
            }
          });

          resolvedActionObject = wrapped;
        }

        return resolvedActionObject;
    }
  }

  function processBlock(block) {
    var e_2, _a;

    var resolvedActions = [];

    try {
      for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(block.actions), _c = _b.next(); !_c.done; _c = _b.next()) {
        var action = _c.value;
        var resolved = handleAction(block.type, action);

        if (resolved) {
          resolvedActions = resolvedActions.concat(resolved);
        }
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    deferredToBlockEnd.forEach(function (action) {
      predictableExec(action, updatedContext, _event);
    });
    deferredToBlockEnd.length = 0;
    return resolvedActions;
  }

  var resolvedActions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.flatten)(actionBlocks.map(processBlock));
  return [resolvedActions, updatedContext];
}




/***/ }),

/***/ "./node_modules/xstate/es/behaviors.js":
/*!*********************************************!*\
  !*** ./node_modules/xstate/es/behaviors.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fromPromise: () => (/* binding */ fromPromise),
/* harmony export */   fromReducer: () => (/* binding */ fromReducer),
/* harmony export */   spawnBehavior: () => (/* binding */ spawnBehavior)
/* harmony export */ });
/* harmony import */ var _actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actions.js */ "./node_modules/xstate/es/actions.js");
/* harmony import */ var _Actor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Actor.js */ "./node_modules/xstate/es/Actor.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");




/**
 * Returns an actor behavior from a reducer and its initial state.
 *
 * @param transition The pure reducer that returns the next state given the current state and event.
 * @param initialState The initial state of the reducer.
 * @returns An actor behavior
 */

function fromReducer(transition, initialState) {
  return {
    transition: transition,
    initialState: initialState
  };
}
function fromPromise(promiseFn) {
  var initialState = {
    error: undefined,
    data: undefined,
    status: 'pending'
  };
  return {
    transition: function (state, event, _a) {
      var parent = _a.parent,
          id = _a.id,
          observers = _a.observers;

      switch (event.type) {
        case 'fulfill':
          parent === null || parent === void 0 ? void 0 : parent.send((0,_actions_js__WEBPACK_IMPORTED_MODULE_0__.doneInvoke)(id, event.data));
          return {
            error: undefined,
            data: event.data,
            status: 'fulfilled'
          };

        case 'reject':
          parent === null || parent === void 0 ? void 0 : parent.send((0,_actions_js__WEBPACK_IMPORTED_MODULE_0__.error)(id, event.error));
          observers.forEach(function (observer) {
            observer.error(event.error);
          });
          return {
            error: event.error,
            data: undefined,
            status: 'rejected'
          };

        default:
          return state;
      }
    },
    initialState: initialState,
    start: function (_a) {
      var self = _a.self;
      promiseFn().then(function (data) {
        self.send({
          type: 'fulfill',
          data: data
        });
      }, function (reason) {
        self.send({
          type: 'reject',
          error: reason
        });
      });
      return initialState;
    }
  };
}
function spawnBehavior(behavior, options) {
  if (options === void 0) {
    options = {};
  }

  var state = behavior.initialState;
  var observers = new Set();
  var mailbox = [];
  var flushing = false;

  var flush = function () {
    if (flushing) {
      return;
    }

    flushing = true;

    while (mailbox.length > 0) {
      var event_1 = mailbox.shift();
      state = behavior.transition(state, event_1, actorCtx);
      observers.forEach(function (observer) {
        return observer.next(state);
      });
    }

    flushing = false;
  };

  var actor = (0,_Actor_js__WEBPACK_IMPORTED_MODULE_1__.toActorRef)({
    id: options.id,
    send: function (event) {
      mailbox.push(event);
      flush();
    },
    getSnapshot: function () {
      return state;
    },
    subscribe: function (next, handleError, complete) {
      var observer = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toObserver)(next, handleError, complete);
      observers.add(observer);
      observer.next(state);
      return {
        unsubscribe: function () {
          observers.delete(observer);
        }
      };
    }
  });
  var actorCtx = {
    parent: options.parent,
    self: actor,
    id: options.id || 'anonymous',
    observers: observers
  };
  state = behavior.start ? behavior.start(actorCtx) : state;
  return actor;
}




/***/ }),

/***/ "./node_modules/xstate/es/constants.js":
/*!*********************************************!*\
  !*** ./node_modules/xstate/es/constants.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_GUARD_TYPE: () => (/* binding */ DEFAULT_GUARD_TYPE),
/* harmony export */   EMPTY_ACTIVITY_MAP: () => (/* binding */ EMPTY_ACTIVITY_MAP),
/* harmony export */   STATE_DELIMITER: () => (/* binding */ STATE_DELIMITER),
/* harmony export */   TARGETLESS_KEY: () => (/* binding */ TARGETLESS_KEY)
/* harmony export */ });
var STATE_DELIMITER = '.';
var EMPTY_ACTIVITY_MAP = {};
var DEFAULT_GUARD_TYPE = 'xstate.guard';
var TARGETLESS_KEY = '';




/***/ }),

/***/ "./node_modules/xstate/es/devTools.js":
/*!********************************************!*\
  !*** ./node_modules/xstate/es/devTools.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getGlobal: () => (/* binding */ getGlobal),
/* harmony export */   registerService: () => (/* binding */ registerService)
/* harmony export */ });
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./environment.js */ "./node_modules/xstate/es/environment.js");


function getGlobal() {
  if (typeof globalThis !== 'undefined') {
    return globalThis;
  }

  if (typeof self !== 'undefined') {
    return self;
  }

  if (typeof window !== 'undefined') {
    return window;
  }

  if (typeof __webpack_require__.g !== 'undefined') {
    return __webpack_require__.g;
  }

  if (!_environment_js__WEBPACK_IMPORTED_MODULE_0__.IS_PRODUCTION) {
    console.warn('XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues');
  }
}

function getDevTools() {
  var global = getGlobal();

  if (global && '__xstate__' in global) {
    return global.__xstate__;
  }

  return undefined;
}

function registerService(service) {
  if (!getGlobal()) {
    return;
  }

  var devTools = getDevTools();

  if (devTools) {
    devTools.register(service);
  }
}




/***/ }),

/***/ "./node_modules/xstate/es/environment.js":
/*!***********************************************!*\
  !*** ./node_modules/xstate/es/environment.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IS_PRODUCTION: () => (/* binding */ IS_PRODUCTION)
/* harmony export */ });
var IS_PRODUCTION = "development" === 'production';




/***/ }),

/***/ "./node_modules/xstate/es/index.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActionTypes: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_10__.ActionTypes),
/* harmony export */   Interpreter: () => (/* reexport safe */ _interpreter_js__WEBPACK_IMPORTED_MODULE_2__.Interpreter),
/* harmony export */   InterpreterStatus: () => (/* reexport safe */ _interpreter_js__WEBPACK_IMPORTED_MODULE_2__.InterpreterStatus),
/* harmony export */   Machine: () => (/* reexport safe */ _Machine_js__WEBPACK_IMPORTED_MODULE_3__.Machine),
/* harmony export */   SpecialTargets: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_10__.SpecialTargets),
/* harmony export */   State: () => (/* reexport safe */ _State_js__WEBPACK_IMPORTED_MODULE_7__.State),
/* harmony export */   StateNode: () => (/* reexport safe */ _StateNode_js__WEBPACK_IMPORTED_MODULE_8__.StateNode),
/* harmony export */   actions: () => (/* reexport module object */ _actions_js__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   assign: () => (/* binding */ assign),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   choose: () => (/* binding */ choose),
/* harmony export */   createMachine: () => (/* reexport safe */ _Machine_js__WEBPACK_IMPORTED_MODULE_3__.createMachine),
/* harmony export */   createSchema: () => (/* reexport safe */ _schema_js__WEBPACK_IMPORTED_MODULE_6__.createSchema),
/* harmony export */   doneInvoke: () => (/* binding */ doneInvoke),
/* harmony export */   forwardTo: () => (/* binding */ forwardTo),
/* harmony export */   interpret: () => (/* reexport safe */ _interpreter_js__WEBPACK_IMPORTED_MODULE_2__.interpret),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   mapState: () => (/* reexport safe */ _mapState_js__WEBPACK_IMPORTED_MODULE_4__.mapState),
/* harmony export */   matchState: () => (/* reexport safe */ _match_js__WEBPACK_IMPORTED_MODULE_5__.matchState),
/* harmony export */   matchesState: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_11__.matchesState),
/* harmony export */   pure: () => (/* binding */ pure),
/* harmony export */   raise: () => (/* binding */ raise),
/* harmony export */   send: () => (/* binding */ send),
/* harmony export */   sendParent: () => (/* binding */ sendParent),
/* harmony export */   sendTo: () => (/* binding */ sendTo),
/* harmony export */   sendUpdate: () => (/* binding */ sendUpdate),
/* harmony export */   spawn: () => (/* reexport safe */ _interpreter_js__WEBPACK_IMPORTED_MODULE_2__.spawn),
/* harmony export */   spawnBehavior: () => (/* reexport safe */ _behaviors_js__WEBPACK_IMPORTED_MODULE_9__.spawnBehavior),
/* harmony export */   stop: () => (/* binding */ stop),
/* harmony export */   t: () => (/* reexport safe */ _schema_js__WEBPACK_IMPORTED_MODULE_6__.t),
/* harmony export */   toActorRef: () => (/* reexport safe */ _Actor_js__WEBPACK_IMPORTED_MODULE_1__.toActorRef),
/* harmony export */   toEventObject: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_11__.toEventObject),
/* harmony export */   toObserver: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_11__.toObserver),
/* harmony export */   toSCXMLEvent: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_11__.toSCXMLEvent)
/* harmony export */ });
/* harmony import */ var _actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actions.js */ "./node_modules/xstate/es/actions.js");
/* harmony import */ var _Actor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Actor.js */ "./node_modules/xstate/es/Actor.js");
/* harmony import */ var _interpreter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interpreter.js */ "./node_modules/xstate/es/interpreter.js");
/* harmony import */ var _Machine_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Machine.js */ "./node_modules/xstate/es/Machine.js");
/* harmony import */ var _mapState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mapState.js */ "./node_modules/xstate/es/mapState.js");
/* harmony import */ var _match_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./match.js */ "./node_modules/xstate/es/match.js");
/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./schema.js */ "./node_modules/xstate/es/schema.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./State.js */ "./node_modules/xstate/es/State.js");
/* harmony import */ var _StateNode_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./StateNode.js */ "./node_modules/xstate/es/StateNode.js");
/* harmony import */ var _behaviors_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./behaviors.js */ "./node_modules/xstate/es/behaviors.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./types.js */ "./node_modules/xstate/es/types.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");















var assign = _actions_js__WEBPACK_IMPORTED_MODULE_0__.assign,
    cancel = _actions_js__WEBPACK_IMPORTED_MODULE_0__.cancel,
    send = _actions_js__WEBPACK_IMPORTED_MODULE_0__.send,
    sendTo = _actions_js__WEBPACK_IMPORTED_MODULE_0__.sendTo,
    sendParent = _actions_js__WEBPACK_IMPORTED_MODULE_0__.sendParent,
    sendUpdate = _actions_js__WEBPACK_IMPORTED_MODULE_0__.sendUpdate,
    forwardTo = _actions_js__WEBPACK_IMPORTED_MODULE_0__.forwardTo,
    doneInvoke = _actions_js__WEBPACK_IMPORTED_MODULE_0__.doneInvoke,
    raise = _actions_js__WEBPACK_IMPORTED_MODULE_0__.raise,
    log = _actions_js__WEBPACK_IMPORTED_MODULE_0__.log,
    pure = _actions_js__WEBPACK_IMPORTED_MODULE_0__.pure,
    choose = _actions_js__WEBPACK_IMPORTED_MODULE_0__.choose,
    stop = _actions_js__WEBPACK_IMPORTED_MODULE_0__.stop;




/***/ }),

/***/ "./node_modules/xstate/es/interpreter.js":
/*!***********************************************!*\
  !*** ./node_modules/xstate/es/interpreter.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Interpreter: () => (/* binding */ Interpreter),
/* harmony export */   InterpreterStatus: () => (/* binding */ InterpreterStatus),
/* harmony export */   interpret: () => (/* binding */ interpret),
/* harmony export */   spawn: () => (/* binding */ spawn)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.js */ "./node_modules/xstate/es/types.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./State.js */ "./node_modules/xstate/es/State.js");
/* harmony import */ var _actionTypes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./actionTypes.js */ "./node_modules/xstate/es/actionTypes.js");
/* harmony import */ var _actions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./actions.js */ "./node_modules/xstate/es/actions.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./environment.js */ "./node_modules/xstate/es/environment.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");
/* harmony import */ var _scheduler_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scheduler.js */ "./node_modules/xstate/es/scheduler.js");
/* harmony import */ var _Actor_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Actor.js */ "./node_modules/xstate/es/Actor.js");
/* harmony import */ var _registry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./registry.js */ "./node_modules/xstate/es/registry.js");
/* harmony import */ var _devTools_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./devTools.js */ "./node_modules/xstate/es/devTools.js");
/* harmony import */ var _serviceScope_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./serviceScope.js */ "./node_modules/xstate/es/serviceScope.js");
/* harmony import */ var _behaviors_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./behaviors.js */ "./node_modules/xstate/es/behaviors.js");














var DEFAULT_SPAWN_OPTIONS = {
  sync: false,
  autoForward: false
};
var InterpreterStatus;

(function (InterpreterStatus) {
  InterpreterStatus[InterpreterStatus["NotStarted"] = 0] = "NotStarted";
  InterpreterStatus[InterpreterStatus["Running"] = 1] = "Running";
  InterpreterStatus[InterpreterStatus["Stopped"] = 2] = "Stopped";
})(InterpreterStatus || (InterpreterStatus = {}));

var Interpreter =
/*#__PURE__*/

/** @class */
function () {
  /**
   * Creates a new Interpreter instance (i.e., service) for the given machine with the provided options, if any.
   *
   * @param machine The machine to be interpreted
   * @param options Interpreter options
   */
  function Interpreter(machine, options) {
    if (options === void 0) {
      options = Interpreter.defaultOptions;
    }

    var _this = this;

    this.machine = machine;
    this.delayedEventsMap = {};
    this.listeners = new Set();
    this.contextListeners = new Set();
    this.stopListeners = new Set();
    this.doneListeners = new Set();
    this.eventListeners = new Set();
    this.sendListeners = new Set();
    /**
     * Whether the service is started.
     */

    this.initialized = false;
    this.status = InterpreterStatus.NotStarted;
    this.children = new Map();
    this.forwardTo = new Set();
    this._outgoingQueue = [];
    /**
     * Alias for Interpreter.prototype.start
     */

    this.init = this.start;
    /**
     * Sends an event to the running interpreter to trigger a transition.
     *
     * An array of events (batched) can be sent as well, which will send all
     * batched events to the running interpreter. The listeners will be
     * notified only **once** when all events are processed.
     *
     * @param event The event(s) to send
     */

    this.send = function (event, payload) {
      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(event)) {
        _this.batch(event);

        return _this.state;
      }

      var _event = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toEventObject)(event, payload));

      if (_this.status === InterpreterStatus.Stopped) {
        // do nothing
        if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(false, "Event \"".concat(_event.name, "\" was sent to stopped service \"").concat(_this.machine.id, "\". This service has already reached its final state, and will not transition.\nEvent: ").concat(JSON.stringify(_event.data)));
        }

        return _this.state;
      }

      if (_this.status !== InterpreterStatus.Running && !_this.options.deferEvents) {
        throw new Error("Event \"".concat(_event.name, "\" was sent to uninitialized service \"").concat(_this.machine.id // tslint:disable-next-line:max-line-length
        , "\". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.\nEvent: ").concat(JSON.stringify(_event.data)));
      }

      _this.scheduler.schedule(function () {
        // Forward copy of event to child actors
        _this.forward(_event);

        var nextState = _this._nextState(_event);

        _this.update(nextState, _event);
      });

      return _this._state; // TODO: deprecate (should return void)
      // tslint:disable-next-line:semicolon
    };

    this.sendTo = function (event, to, immediate) {
      var isParent = _this.parent && (to === _types_js__WEBPACK_IMPORTED_MODULE_2__.SpecialTargets.Parent || _this.parent.id === to);
      var target = isParent ? _this.parent : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(to) ? to === _types_js__WEBPACK_IMPORTED_MODULE_2__.SpecialTargets.Internal ? _this : _this.children.get(to) || _registry_js__WEBPACK_IMPORTED_MODULE_3__.registry.get(to) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isActor)(to) ? to : undefined;

      if (!target) {
        if (!isParent) {
          throw new Error("Unable to send event to child '".concat(to, "' from service '").concat(_this.id, "'."));
        } // tslint:disable-next-line:no-console


        if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(false, "Service '".concat(_this.id, "' has no parent: unable to send event ").concat(event.type));
        }

        return;
      }

      if ('machine' in target) {
        // perhaps those events should be rejected in the parent
        // but atm it doesn't have easy access to all of the information that is required to do it reliably
        if (_this.status !== InterpreterStatus.Stopped || _this.parent !== target || // we need to send events to the parent from exit handlers of a machine that reached its final state
        _this.state.done) {
          // Send SCXML events to machines
          var scxmlEvent = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, event), {
            name: event.name === _actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.error ? "".concat((0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.error)(_this.id)) : event.name,
            origin: _this.sessionId
          });

          if (!immediate && _this.machine.config.predictableActionArguments) {
            _this._outgoingQueue.push([target, scxmlEvent]);
          } else {
            target.send(scxmlEvent);
          }
        }
      } else {
        // Send normal events to other targets
        if (!immediate && _this.machine.config.predictableActionArguments) {
          _this._outgoingQueue.push([target, event.data]);
        } else {
          target.send(event.data);
        }
      }
    };

    this._exec = function (action, context, _event, actionFunctionMap) {
      if (actionFunctionMap === void 0) {
        actionFunctionMap = _this.machine.options.actions;
      }

      var actionOrExec = action.exec || (0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.getActionFunction)(action.type, actionFunctionMap);
      var exec = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(actionOrExec) ? actionOrExec : actionOrExec ? actionOrExec.exec : action.exec;

      if (exec) {
        try {
          return exec(context, _event.data, !_this.machine.config.predictableActionArguments ? {
            action: action,
            state: _this.state,
            _event: _event
          } : {
            action: action,
            _event: _event
          });
        } catch (err) {
          if (_this.parent) {
            _this.parent.send({
              type: 'xstate.error',
              data: err
            });
          }

          throw err;
        }
      }

      switch (action.type) {
        case _actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.raise:
          {
            // if raise action reached the interpreter then it's a delayed one
            var sendAction_1 = action;

            _this.defer(sendAction_1);

            break;
          }

        case _actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.send:
          var sendAction = action;

          if (typeof sendAction.delay === 'number') {
            _this.defer(sendAction);

            return;
          } else {
            if (sendAction.to) {
              _this.sendTo(sendAction._event, sendAction.to, _event === _actions_js__WEBPACK_IMPORTED_MODULE_6__.initEvent);
            } else {
              _this.send(sendAction._event);
            }
          }

          break;

        case _actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.cancel:
          _this.cancel(action.sendId);

          break;

        case _actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.start:
          {
            if (_this.status !== InterpreterStatus.Running) {
              return;
            }

            var activity = action.activity; // If the activity will be stopped right after it's started
            // (such as in transient states)
            // don't bother starting the activity.

            if ( // in v4 with `predictableActionArguments` invokes are called eagerly when the `this.state` still points to the previous state
            !_this.machine.config.predictableActionArguments && !_this.state.activities[activity.id || activity.type]) {
              break;
            } // Invoked services


            if (activity.type === _types_js__WEBPACK_IMPORTED_MODULE_2__.ActionTypes.Invoke) {
              var invokeSource = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toInvokeSource)(activity.src);
              var serviceCreator = _this.machine.options.services ? _this.machine.options.services[invokeSource.type] : undefined;
              var id = activity.id,
                  data = activity.data;

              if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(!('forward' in activity), // tslint:disable-next-line:max-line-length
                "`forward` property is deprecated (found in invocation of '".concat(activity.src, "' in in machine '").concat(_this.machine.id, "'). ") + "Please use `autoForward` instead.");
              }

              var autoForward = 'autoForward' in activity ? activity.autoForward : !!activity.forward;

              if (!serviceCreator) {
                // tslint:disable-next-line:no-console
                if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
                  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(false, "No service found for invocation '".concat(activity.src, "' in machine '").concat(_this.machine.id, "'."));
                }

                return;
              }

              var resolvedData = data ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapContext)(data, context, _event) : undefined;

              if (typeof serviceCreator === 'string') {
                // TODO: warn
                return;
              }

              var source = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(serviceCreator) ? serviceCreator(context, _event.data, {
                data: resolvedData,
                src: invokeSource,
                meta: activity.meta
              }) : serviceCreator;

              if (!source) {
                // TODO: warn?
                return;
              }

              var options = void 0;

              if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isMachine)(source)) {
                source = resolvedData ? source.withContext(resolvedData) : source;
                options = {
                  autoForward: autoForward
                };
              }

              _this.spawn(source, id, options);
            } else {
              _this.spawnActivity(activity);
            }

            break;
          }

        case _actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.stop:
          {
            _this.stopChild(action.activity.id);

            break;
          }

        case _actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.log:
          var _a = action,
              label = _a.label,
              value = _a.value;

          if (label) {
            _this.logger(label, value);
          } else {
            _this.logger(value);
          }

          break;

        default:
          if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(false, "No implementation found for action type '".concat(action.type, "'"));
          }

          break;
      }
    };

    var resolvedOptions = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, Interpreter.defaultOptions), options);

    var clock = resolvedOptions.clock,
        logger = resolvedOptions.logger,
        parent = resolvedOptions.parent,
        id = resolvedOptions.id;
    var resolvedId = id !== undefined ? id : machine.id;
    this.id = resolvedId;
    this.logger = logger;
    this.clock = clock;
    this.parent = parent;
    this.options = resolvedOptions;
    this.scheduler = new _scheduler_js__WEBPACK_IMPORTED_MODULE_7__.Scheduler({
      deferEvents: this.options.deferEvents
    });
    this.sessionId = _registry_js__WEBPACK_IMPORTED_MODULE_3__.registry.bookId();
  }

  Object.defineProperty(Interpreter.prototype, "initialState", {
    get: function () {
      var _this = this;

      if (this._initialState) {
        return this._initialState;
      }

      return (0,_serviceScope_js__WEBPACK_IMPORTED_MODULE_8__.provide)(this, function () {
        _this._initialState = _this.machine.initialState;
        return _this._initialState;
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Interpreter.prototype, "state", {
    /**
     * @deprecated Use `.getSnapshot()` instead.
     */
    get: function () {
      if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(this.status !== InterpreterStatus.NotStarted, "Attempted to read state from uninitialized service '".concat(this.id, "'. Make sure the service is started first."));
      }

      return this._state;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Executes the actions of the given state, with that state's `context` and `event`.
   *
   * @param state The state whose actions will be executed
   * @param actionsConfig The action implementations to use
   */

  Interpreter.prototype.execute = function (state, actionsConfig) {
    var e_1, _a;

    try {
      for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(state.actions), _c = _b.next(); !_c.done; _c = _b.next()) {
        var action = _c.value;
        this.exec(action, state, actionsConfig);
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  };

  Interpreter.prototype.update = function (state, _event) {
    var e_2, _a, e_3, _b, e_4, _c, e_5, _d;

    var _this = this; // Attach session ID to state


    state._sessionid = this.sessionId; // Update state

    this._state = state; // Execute actions

    if ((!this.machine.config.predictableActionArguments || // this is currently required to execute initial actions as the `initialState` gets cached
    // we can't just recompute it (and execute actions while doing so) because we try to preserve identity of actors created within initial assigns
    _event === _actions_js__WEBPACK_IMPORTED_MODULE_6__.initEvent) && this.options.execute) {
      this.execute(this.state);
    } else {
      var item = void 0;

      while (item = this._outgoingQueue.shift()) {
        item[0].send(item[1]);
      }
    } // Update children


    this.children.forEach(function (child) {
      _this.state.children[child.id] = child;
    }); // Dev tools

    if (this.devTools) {
      this.devTools.send(_event.data, state);
    } // Execute listeners


    if (state.event) {
      try {
        for (var _e = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.eventListeners), _f = _e.next(); !_f.done; _f = _e.next()) {
          var listener = _f.value;
          listener(state.event);
        }
      } catch (e_2_1) {
        e_2 = {
          error: e_2_1
        };
      } finally {
        try {
          if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
    }

    try {
      for (var _g = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.listeners), _h = _g.next(); !_h.done; _h = _g.next()) {
        var listener = _h.value;
        listener(state, state.event);
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    try {
      for (var _j = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.contextListeners), _k = _j.next(); !_k.done; _k = _j.next()) {
        var contextListener = _k.value;
        contextListener(this.state.context, this.state.history ? this.state.history.context : undefined);
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
      } finally {
        if (e_4) throw e_4.error;
      }
    }

    if (this.state.done) {
      // get final child state node
      var finalChildStateNode = state.configuration.find(function (sn) {
        return sn.type === 'final' && sn.parent === _this.machine;
      });
      var doneData = finalChildStateNode && finalChildStateNode.doneData ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapContext)(finalChildStateNode.doneData, state.context, _event) : undefined;
      this._doneEvent = (0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.doneInvoke)(this.id, doneData);

      try {
        for (var _l = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.doneListeners), _m = _l.next(); !_m.done; _m = _l.next()) {
          var listener = _m.value;
          listener(this._doneEvent);
        }
      } catch (e_5_1) {
        e_5 = {
          error: e_5_1
        };
      } finally {
        try {
          if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
        } finally {
          if (e_5) throw e_5.error;
        }
      }

      this._stop();

      this._stopChildren();

      _registry_js__WEBPACK_IMPORTED_MODULE_3__.registry.free(this.sessionId);
    }
  };
  /*
   * Adds a listener that is notified whenever a state transition happens. The listener is called with
   * the next state and the event object that caused the state transition.
   *
   * @param listener The state listener
   */


  Interpreter.prototype.onTransition = function (listener) {
    this.listeners.add(listener); // Send current state to listener

    if (this.status === InterpreterStatus.Running) {
      listener(this.state, this.state.event);
    }

    return this;
  };

  Interpreter.prototype.subscribe = function (nextListenerOrObserver, _, // TODO: error listener
  completeListener) {
    var _this = this;

    var observer = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toObserver)(nextListenerOrObserver, _, completeListener);
    this.listeners.add(observer.next); // Send current state to listener

    if (this.status !== InterpreterStatus.NotStarted) {
      observer.next(this.state);
    }

    var completeOnce = function () {
      _this.doneListeners.delete(completeOnce);

      _this.stopListeners.delete(completeOnce);

      observer.complete();
    };

    if (this.status === InterpreterStatus.Stopped) {
      observer.complete();
    } else {
      this.onDone(completeOnce);
      this.onStop(completeOnce);
    }

    return {
      unsubscribe: function () {
        _this.listeners.delete(observer.next);

        _this.doneListeners.delete(completeOnce);

        _this.stopListeners.delete(completeOnce);
      }
    };
  };
  /**
   * Adds an event listener that is notified whenever an event is sent to the running interpreter.
   * @param listener The event listener
   */


  Interpreter.prototype.onEvent = function (listener) {
    this.eventListeners.add(listener);
    return this;
  };
  /**
   * Adds an event listener that is notified whenever a `send` event occurs.
   * @param listener The event listener
   */


  Interpreter.prototype.onSend = function (listener) {
    this.sendListeners.add(listener);
    return this;
  };
  /**
   * Adds a context listener that is notified whenever the state context changes.
   * @param listener The context listener
   */


  Interpreter.prototype.onChange = function (listener) {
    this.contextListeners.add(listener);
    return this;
  };
  /**
   * Adds a listener that is notified when the machine is stopped.
   * @param listener The listener
   */


  Interpreter.prototype.onStop = function (listener) {
    this.stopListeners.add(listener);
    return this;
  };
  /**
   * Adds a state listener that is notified when the statechart has reached its final state.
   * @param listener The state listener
   */


  Interpreter.prototype.onDone = function (listener) {
    if (this.status === InterpreterStatus.Stopped && this._doneEvent) {
      listener(this._doneEvent);
    } else {
      this.doneListeners.add(listener);
    }

    return this;
  };
  /**
   * Removes a listener.
   * @param listener The listener to remove
   */


  Interpreter.prototype.off = function (listener) {
    this.listeners.delete(listener);
    this.eventListeners.delete(listener);
    this.sendListeners.delete(listener);
    this.stopListeners.delete(listener);
    this.doneListeners.delete(listener);
    this.contextListeners.delete(listener);
    return this;
  };
  /**
   * Starts the interpreter from the given state, or the initial state.
   * @param initialState The state to start the statechart from
   */


  Interpreter.prototype.start = function (initialState) {
    var _this = this;

    if (this.status === InterpreterStatus.Running) {
      // Do not restart the service if it is already started
      return this;
    } // yes, it's a hack but we need the related cache to be populated for some things to work (like delayed transitions)
    // this is usually called by `machine.getInitialState` but if we rehydrate from a state we might bypass this call
    // we also don't want to call this method here as it resolves the full initial state which might involve calling assign actions
    // and that could potentially lead to some unwanted side-effects (even such as creating some rogue actors)


    this.machine._init();

    _registry_js__WEBPACK_IMPORTED_MODULE_3__.registry.register(this.sessionId, this);
    this.initialized = true;
    this.status = InterpreterStatus.Running;
    var resolvedState = initialState === undefined ? this.initialState : (0,_serviceScope_js__WEBPACK_IMPORTED_MODULE_8__.provide)(this, function () {
      return (0,_State_js__WEBPACK_IMPORTED_MODULE_9__.isStateConfig)(initialState) ? _this.machine.resolveState(initialState) : _this.machine.resolveState(_State_js__WEBPACK_IMPORTED_MODULE_9__.State.from(initialState, _this.machine.context));
    });

    if (this.options.devTools) {
      this.attachDev();
    }

    this.scheduler.initialize(function () {
      _this.update(resolvedState, _actions_js__WEBPACK_IMPORTED_MODULE_6__.initEvent);
    });
    return this;
  };

  Interpreter.prototype._stopChildren = function () {
    // TODO: think about converting those to actions
    this.children.forEach(function (child) {
      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(child.stop)) {
        child.stop();
      }
    });
    this.children.clear();
  };

  Interpreter.prototype._stop = function () {
    var e_6, _a, e_7, _b, e_8, _c, e_9, _d, e_10, _e;

    try {
      for (var _f = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.listeners), _g = _f.next(); !_g.done; _g = _f.next()) {
        var listener = _g.value;
        this.listeners.delete(listener);
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
      } finally {
        if (e_6) throw e_6.error;
      }
    }

    try {
      for (var _h = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.stopListeners), _j = _h.next(); !_j.done; _j = _h.next()) {
        var listener = _j.value; // call listener, then remove

        listener();
        this.stopListeners.delete(listener);
      }
    } catch (e_7_1) {
      e_7 = {
        error: e_7_1
      };
    } finally {
      try {
        if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
      } finally {
        if (e_7) throw e_7.error;
      }
    }

    try {
      for (var _k = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.contextListeners), _l = _k.next(); !_l.done; _l = _k.next()) {
        var listener = _l.value;
        this.contextListeners.delete(listener);
      }
    } catch (e_8_1) {
      e_8 = {
        error: e_8_1
      };
    } finally {
      try {
        if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
      } finally {
        if (e_8) throw e_8.error;
      }
    }

    try {
      for (var _m = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.doneListeners), _o = _m.next(); !_o.done; _o = _m.next()) {
        var listener = _o.value;
        this.doneListeners.delete(listener);
      }
    } catch (e_9_1) {
      e_9 = {
        error: e_9_1
      };
    } finally {
      try {
        if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
      } finally {
        if (e_9) throw e_9.error;
      }
    }

    if (!this.initialized) {
      // Interpreter already stopped; do nothing
      return this;
    }

    this.initialized = false;
    this.status = InterpreterStatus.Stopped;
    this._initialState = undefined;

    try {
      // we are going to stop within the current sync frame
      // so we can safely just cancel this here as nothing async should be fired anyway
      for (var _p = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(Object.keys(this.delayedEventsMap)), _q = _p.next(); !_q.done; _q = _p.next()) {
        var key = _q.value;
        this.clock.clearTimeout(this.delayedEventsMap[key]);
      }
    } catch (e_10_1) {
      e_10 = {
        error: e_10_1
      };
    } finally {
      try {
        if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
      } finally {
        if (e_10) throw e_10.error;
      }
    } // clear everything that might be enqueued


    this.scheduler.clear();
    this.scheduler = new _scheduler_js__WEBPACK_IMPORTED_MODULE_7__.Scheduler({
      deferEvents: this.options.deferEvents
    });
  };
  /**
   * Stops the interpreter and unsubscribe all listeners.
   *
   * This will also notify the `onStop` listeners.
   */


  Interpreter.prototype.stop = function () {
    // TODO: add warning for stopping non-root interpreters
    var _this = this; // grab the current scheduler as it will be replaced in _stop


    var scheduler = this.scheduler;

    this._stop(); // let what is currently processed to be finished


    scheduler.schedule(function () {
      // it feels weird to handle this here but we need to handle this even slightly "out of band"
      var _event = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)({
        type: 'xstate.stop'
      });

      var nextState = (0,_serviceScope_js__WEBPACK_IMPORTED_MODULE_8__.provide)(_this, function () {
        var exitActions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__read)(_this.state.configuration), false).sort(function (a, b) {
          return b.order - a.order;
        }).map(function (stateNode) {
          return (0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.toActionObjects)(stateNode.onExit, _this.machine.options.actions);
        }));

        var _a = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__read)((0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.resolveActions)(_this.machine, _this.state, _this.state.context, _event, [{
          type: 'exit',
          actions: exitActions
        }], _this.machine.config.predictableActionArguments ? _this._exec : undefined, _this.machine.config.predictableActionArguments || _this.machine.config.preserveActionOrder), 2),
            resolvedActions = _a[0],
            updatedContext = _a[1];

        var newState = new _State_js__WEBPACK_IMPORTED_MODULE_9__.State({
          value: _this.state.value,
          context: updatedContext,
          _event: _event,
          _sessionid: _this.sessionId,
          historyValue: undefined,
          history: _this.state,
          actions: resolvedActions.filter(function (action) {
            return !(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isRaisableAction)(action);
          }),
          activities: {},
          events: [],
          configuration: [],
          transitions: [],
          children: {},
          done: _this.state.done,
          tags: _this.state.tags,
          machine: _this.machine
        });
        newState.changed = true;
        return newState;
      });

      _this.update(nextState, _event);

      _this._stopChildren();

      _registry_js__WEBPACK_IMPORTED_MODULE_3__.registry.free(_this.sessionId);
    });
    return this;
  };

  Interpreter.prototype.batch = function (events) {
    var _this = this;

    if (this.status === InterpreterStatus.NotStarted && this.options.deferEvents) {
      // tslint:disable-next-line:no-console
      if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(false, "".concat(events.length, " event(s) were sent to uninitialized service \"").concat(this.machine.id, "\" and are deferred. Make sure .start() is called for this service.\nEvent: ").concat(JSON.stringify(event)));
      }
    } else if (this.status !== InterpreterStatus.Running) {
      throw new Error( // tslint:disable-next-line:max-line-length
      "".concat(events.length, " event(s) were sent to uninitialized service \"").concat(this.machine.id, "\". Make sure .start() is called for this service, or set { deferEvents: true } in the service options."));
    }

    if (!events.length) {
      return;
    }

    var exec = !!this.machine.config.predictableActionArguments && this._exec;
    this.scheduler.schedule(function () {
      var e_11, _a;

      var nextState = _this.state;
      var batchChanged = false;
      var batchedActions = [];

      var _loop_1 = function (event_1) {
        var _event = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(event_1);

        _this.forward(_event);

        nextState = (0,_serviceScope_js__WEBPACK_IMPORTED_MODULE_8__.provide)(_this, function () {
          return _this.machine.transition(nextState, _event, undefined, exec || undefined);
        });
        batchedActions.push.apply(batchedActions, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__read)(_this.machine.config.predictableActionArguments ? nextState.actions : nextState.actions.map(function (a) {
          return (0,_State_js__WEBPACK_IMPORTED_MODULE_9__.bindActionToState)(a, nextState);
        })), false));
        batchChanged = batchChanged || !!nextState.changed;
      };

      try {
        for (var events_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
          var event_1 = events_1_1.value;

          _loop_1(event_1);
        }
      } catch (e_11_1) {
        e_11 = {
          error: e_11_1
        };
      } finally {
        try {
          if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);
        } finally {
          if (e_11) throw e_11.error;
        }
      }

      nextState.changed = batchChanged;
      nextState.actions = batchedActions;

      _this.update(nextState, (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(events[events.length - 1]));
    });
  };
  /**
   * Returns a send function bound to this interpreter instance.
   *
   * @param event The event to be sent by the sender.
   */


  Interpreter.prototype.sender = function (event) {
    return this.send.bind(this, event);
  };

  Interpreter.prototype._nextState = function (event, exec) {
    var _this = this;

    if (exec === void 0) {
      exec = !!this.machine.config.predictableActionArguments && this._exec;
    }

    var _event = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(event);

    if (_event.name.indexOf(_actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.errorPlatform) === 0 && !this.state.nextEvents.some(function (nextEvent) {
      return nextEvent.indexOf(_actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.errorPlatform) === 0;
    })) {
      throw _event.data.data;
    }

    var nextState = (0,_serviceScope_js__WEBPACK_IMPORTED_MODULE_8__.provide)(this, function () {
      return _this.machine.transition(_this.state, _event, undefined, exec || undefined);
    });
    return nextState;
  };
  /**
   * Returns the next state given the interpreter's current state and the event.
   *
   * This is a pure method that does _not_ update the interpreter's state.
   *
   * @param event The event to determine the next state
   */


  Interpreter.prototype.nextState = function (event) {
    return this._nextState(event, false);
  };

  Interpreter.prototype.forward = function (event) {
    var e_12, _a;

    try {
      for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.forwardTo), _c = _b.next(); !_c.done; _c = _b.next()) {
        var id = _c.value;
        var child = this.children.get(id);

        if (!child) {
          throw new Error("Unable to forward event '".concat(event, "' from interpreter '").concat(this.id, "' to nonexistant child '").concat(id, "'."));
        }

        child.send(event);
      }
    } catch (e_12_1) {
      e_12 = {
        error: e_12_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_12) throw e_12.error;
      }
    }
  };

  Interpreter.prototype.defer = function (sendAction) {
    var _this = this;

    var timerId = this.clock.setTimeout(function () {
      if ('to' in sendAction && sendAction.to) {
        _this.sendTo(sendAction._event, sendAction.to, true);
      } else {
        _this.send(sendAction._event);
      }
    }, sendAction.delay);

    if (sendAction.id) {
      this.delayedEventsMap[sendAction.id] = timerId;
    }
  };

  Interpreter.prototype.cancel = function (sendId) {
    this.clock.clearTimeout(this.delayedEventsMap[sendId]);
    delete this.delayedEventsMap[sendId];
  };

  Interpreter.prototype.exec = function (action, state, actionFunctionMap) {
    if (actionFunctionMap === void 0) {
      actionFunctionMap = this.machine.options.actions;
    }

    this._exec(action, state.context, state._event, actionFunctionMap);
  };

  Interpreter.prototype.removeChild = function (childId) {
    var _a;

    this.children.delete(childId);
    this.forwardTo.delete(childId); // this.state might not exist at the time this is called,
    // such as when a child is added then removed while initializing the state

    (_a = this.state) === null || _a === void 0 ? true : delete _a.children[childId];
  };

  Interpreter.prototype.stopChild = function (childId) {
    var child = this.children.get(childId);

    if (!child) {
      return;
    }

    this.removeChild(childId);

    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(child.stop)) {
      child.stop();
    }
  };

  Interpreter.prototype.spawn = function (entity, name, options) {
    if (this.status !== InterpreterStatus.Running) {
      return (0,_Actor_js__WEBPACK_IMPORTED_MODULE_10__.createDeferredActor)(entity, name);
    }

    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(entity)) {
      return this.spawnPromise(Promise.resolve(entity), name);
    } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(entity)) {
      return this.spawnCallback(entity, name);
    } else if ((0,_Actor_js__WEBPACK_IMPORTED_MODULE_10__.isSpawnedActor)(entity)) {
      return this.spawnActor(entity, name);
    } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isObservable)(entity)) {
      return this.spawnObservable(entity, name);
    } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isMachine)(entity)) {
      return this.spawnMachine(entity, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, options), {
        id: name
      }));
    } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBehavior)(entity)) {
      return this.spawnBehavior(entity, name);
    } else {
      throw new Error("Unable to spawn entity \"".concat(name, "\" of type \"").concat(typeof entity, "\"."));
    }
  };

  Interpreter.prototype.spawnMachine = function (machine, options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    var childService = new Interpreter(machine, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, this.options), {
      parent: this,
      id: options.id || machine.id
    }));

    var resolvedOptions = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, DEFAULT_SPAWN_OPTIONS), options);

    if (resolvedOptions.sync) {
      childService.onTransition(function (state) {
        _this.send(_actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.update, {
          state: state,
          id: childService.id
        });
      });
    }

    var actor = childService;
    this.children.set(childService.id, actor);

    if (resolvedOptions.autoForward) {
      this.forwardTo.add(childService.id);
    }

    childService.onDone(function (doneEvent) {
      _this.removeChild(childService.id);

      _this.send((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(doneEvent, {
        origin: childService.id
      }));
    }).start();
    return actor;
  };

  Interpreter.prototype.spawnBehavior = function (behavior, id) {
    var actorRef = (0,_behaviors_js__WEBPACK_IMPORTED_MODULE_11__.spawnBehavior)(behavior, {
      id: id,
      parent: this
    });
    this.children.set(id, actorRef);
    return actorRef;
  };

  Interpreter.prototype.spawnPromise = function (promise, id) {
    var _a;

    var _this = this;

    var canceled = false;
    var resolvedData;
    promise.then(function (response) {
      if (!canceled) {
        resolvedData = response;

        _this.removeChild(id);

        _this.send((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)((0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.doneInvoke)(id, response), {
          origin: id
        }));
      }
    }, function (errorData) {
      if (!canceled) {
        _this.removeChild(id);

        var errorEvent = (0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.error)(id, errorData);

        try {
          // Send "error.platform.id" to this (parent).
          _this.send((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(errorEvent, {
            origin: id
          }));
        } catch (error) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.reportUnhandledExceptionOnInvocation)(errorData, error, id);

          if (_this.devTools) {
            _this.devTools.send(errorEvent, _this.state);
          }

          if (_this.machine.strict) {
            // it would be better to always stop the state machine if unhandled
            // exception/promise rejection happens but because we don't want to
            // break existing code so enforce it on strict mode only especially so
            // because documentation says that onError is optional
            _this.stop();
          }
        }
      }
    });
    var actor = (_a = {
      id: id,
      send: function () {
        return void 0;
      },
      subscribe: function (next, handleError, complete) {
        var observer = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toObserver)(next, handleError, complete);
        var unsubscribed = false;
        promise.then(function (response) {
          if (unsubscribed) {
            return;
          }

          observer.next(response);

          if (unsubscribed) {
            return;
          }

          observer.complete();
        }, function (err) {
          if (unsubscribed) {
            return;
          }

          observer.error(err);
        });
        return {
          unsubscribe: function () {
            return unsubscribed = true;
          }
        };
      },
      stop: function () {
        canceled = true;
      },
      toJSON: function () {
        return {
          id: id
        };
      },
      getSnapshot: function () {
        return resolvedData;
      }
    }, _a[_utils_js__WEBPACK_IMPORTED_MODULE_0__.symbolObservable] = function () {
      return this;
    }, _a);
    this.children.set(id, actor);
    return actor;
  };

  Interpreter.prototype.spawnCallback = function (callback, id) {
    var _a;

    var _this = this;

    var canceled = false;
    var receivers = new Set();
    var listeners = new Set();
    var emitted;

    var receive = function (e) {
      emitted = e;
      listeners.forEach(function (listener) {
        return listener(e);
      });

      if (canceled) {
        return;
      }

      _this.send((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(e, {
        origin: id
      }));
    };

    var callbackStop;

    try {
      callbackStop = callback(receive, function (newListener) {
        receivers.add(newListener);
      });
    } catch (err) {
      this.send((0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.error)(id, err));
    }

    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(callbackStop)) {
      // it turned out to be an async function, can't reliably check this before calling `callback`
      // because transpiled async functions are not recognizable
      return this.spawnPromise(callbackStop, id);
    }

    var actor = (_a = {
      id: id,
      send: function (event) {
        return receivers.forEach(function (receiver) {
          return receiver(event);
        });
      },
      subscribe: function (next) {
        var observer = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toObserver)(next);
        listeners.add(observer.next);
        return {
          unsubscribe: function () {
            listeners.delete(observer.next);
          }
        };
      },
      stop: function () {
        canceled = true;

        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(callbackStop)) {
          callbackStop();
        }
      },
      toJSON: function () {
        return {
          id: id
        };
      },
      getSnapshot: function () {
        return emitted;
      }
    }, _a[_utils_js__WEBPACK_IMPORTED_MODULE_0__.symbolObservable] = function () {
      return this;
    }, _a);
    this.children.set(id, actor);
    return actor;
  };

  Interpreter.prototype.spawnObservable = function (source, id) {
    var _a;

    var _this = this;

    var emitted;
    var subscription = source.subscribe(function (value) {
      emitted = value;

      _this.send((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(value, {
        origin: id
      }));
    }, function (err) {
      _this.removeChild(id);

      _this.send((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)((0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.error)(id, err), {
        origin: id
      }));
    }, function () {
      _this.removeChild(id);

      _this.send((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)((0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.doneInvoke)(id), {
        origin: id
      }));
    });
    var actor = (_a = {
      id: id,
      send: function () {
        return void 0;
      },
      subscribe: function (next, handleError, complete) {
        return source.subscribe(next, handleError, complete);
      },
      stop: function () {
        return subscription.unsubscribe();
      },
      getSnapshot: function () {
        return emitted;
      },
      toJSON: function () {
        return {
          id: id
        };
      }
    }, _a[_utils_js__WEBPACK_IMPORTED_MODULE_0__.symbolObservable] = function () {
      return this;
    }, _a);
    this.children.set(id, actor);
    return actor;
  };

  Interpreter.prototype.spawnActor = function (actor, name) {
    this.children.set(name, actor);
    return actor;
  };

  Interpreter.prototype.spawnActivity = function (activity) {
    var implementation = this.machine.options && this.machine.options.activities ? this.machine.options.activities[activity.type] : undefined;

    if (!implementation) {
      if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(false, "No implementation found for activity '".concat(activity.type, "'"));
      } // tslint:disable-next-line:no-console


      return;
    } // Start implementation


    var dispose = implementation(this.state.context, activity);
    this.spawnEffect(activity.id, dispose);
  };

  Interpreter.prototype.spawnEffect = function (id, dispose) {
    var _a;

    this.children.set(id, (_a = {
      id: id,
      send: function () {
        return void 0;
      },
      subscribe: function () {
        return {
          unsubscribe: function () {
            return void 0;
          }
        };
      },
      stop: dispose || undefined,
      getSnapshot: function () {
        return undefined;
      },
      toJSON: function () {
        return {
          id: id
        };
      }
    }, _a[_utils_js__WEBPACK_IMPORTED_MODULE_0__.symbolObservable] = function () {
      return this;
    }, _a));
  };

  Interpreter.prototype.attachDev = function () {
    var global = (0,_devTools_js__WEBPACK_IMPORTED_MODULE_12__.getGlobal)();

    if (this.options.devTools && global) {
      if (global.__REDUX_DEVTOOLS_EXTENSION__) {
        var devToolsOptions = typeof this.options.devTools === 'object' ? this.options.devTools : undefined;
        this.devTools = global.__REDUX_DEVTOOLS_EXTENSION__.connect((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({
          name: this.id,
          autoPause: true,
          stateSanitizer: function (state) {
            return {
              value: state.value,
              context: state.context,
              actions: state.actions
            };
          }
        }, devToolsOptions), {
          features: (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({
            jump: false,
            skip: false
          }, devToolsOptions ? devToolsOptions.features : undefined)
        }), this.machine);
        this.devTools.init(this.state);
      } // add XState-specific dev tooling hook


      (0,_devTools_js__WEBPACK_IMPORTED_MODULE_12__.registerService)(this);
    }
  };

  Interpreter.prototype.toJSON = function () {
    return {
      id: this.id
    };
  };

  Interpreter.prototype[_utils_js__WEBPACK_IMPORTED_MODULE_0__.symbolObservable] = function () {
    return this;
  };

  Interpreter.prototype.getSnapshot = function () {
    if (this.status === InterpreterStatus.NotStarted) {
      return this.initialState;
    }

    return this._state;
  };
  /**
   * The default interpreter options:
   *
   * - `clock` uses the global `setTimeout` and `clearTimeout` functions
   * - `logger` uses the global `console.log()` method
   */


  Interpreter.defaultOptions = {
    execute: true,
    deferEvents: true,
    clock: {
      setTimeout: function (fn, ms) {
        return setTimeout(fn, ms);
      },
      clearTimeout: function (id) {
        return clearTimeout(id);
      }
    },
    logger: /*#__PURE__*/console.log.bind(console),
    devTools: false
  };
  Interpreter.interpret = interpret;
  return Interpreter;
}();

var resolveSpawnOptions = function (nameOrOptions) {
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(nameOrOptions)) {
    return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, DEFAULT_SPAWN_OPTIONS), {
      name: nameOrOptions
    });
  }

  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, DEFAULT_SPAWN_OPTIONS), {
    name: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.uniqueId)()
  }), nameOrOptions);
};

function spawn(entity, nameOrOptions) {
  var resolvedOptions = resolveSpawnOptions(nameOrOptions);
  return (0,_serviceScope_js__WEBPACK_IMPORTED_MODULE_8__.consume)(function (service) {
    if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
      var isLazyEntity = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isMachine)(entity) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(entity);
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(!!service || isLazyEntity, "Attempted to spawn an Actor (ID: \"".concat((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isMachine)(entity) ? entity.id : 'undefined', "\") outside of a service. This will have no effect."));
    }

    if (service) {
      return service.spawn(entity, resolvedOptions.name, resolvedOptions);
    } else {
      return (0,_Actor_js__WEBPACK_IMPORTED_MODULE_10__.createDeferredActor)(entity, resolvedOptions.name);
    }
  });
}
/**
 * Creates a new Interpreter instance for the given machine with the provided options, if any.
 *
 * @param machine The machine to interpret
 * @param options Interpreter options
 */

function interpret(machine, options) {
  var interpreter = new Interpreter(machine, options);
  return interpreter;
}




/***/ }),

/***/ "./node_modules/xstate/es/invokeUtils.js":
/*!***********************************************!*\
  !*** ./node_modules/xstate/es/invokeUtils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toInvokeDefinition: () => (/* binding */ toInvokeDefinition),
/* harmony export */   toInvokeSource: () => (/* binding */ toInvokeSource)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _actionTypes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./actionTypes.js */ "./node_modules/xstate/es/actionTypes.js");






function toInvokeSource(src) {
  if (typeof src === 'string') {
    var simpleSrc = {
      type: src
    };

    simpleSrc.toString = function () {
      return src;
    }; // v4 compat - TODO: remove in v5


    return simpleSrc;
  }

  return src;
}
function toInvokeDefinition(invokeConfig) {
  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__.__assign)({
    type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_1__.invoke
  }, invokeConfig), {
    toJSON: function () {
      invokeConfig.onDone;
          invokeConfig.onError;
          var invokeDef = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__.__rest)(invokeConfig, ["onDone", "onError"]);

      return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, invokeDef), {
        type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_1__.invoke,
        src: toInvokeSource(invokeConfig.src)
      });
    }
  });
}




/***/ }),

/***/ "./node_modules/xstate/es/mapState.js":
/*!********************************************!*\
  !*** ./node_modules/xstate/es/mapState.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapState: () => (/* binding */ mapState)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");



function mapState(stateMap, stateId) {
  var e_1, _a;

  var foundStateId;

  try {
    for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__.__values)(Object.keys(stateMap)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var mappedStateId = _c.value;

      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.matchesState)(mappedStateId, stateId) && (!foundStateId || stateId.length > foundStateId.length)) {
        foundStateId = mappedStateId;
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  return stateMap[foundStateId];
}




/***/ }),

/***/ "./node_modules/xstate/es/match.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/match.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   matchState: () => (/* binding */ matchState)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./State.js */ "./node_modules/xstate/es/State.js");



function matchState(state, patterns, defaultValue) {
  var e_1, _a;

  var resolvedState = _State_js__WEBPACK_IMPORTED_MODULE_0__.State.from(state, state instanceof _State_js__WEBPACK_IMPORTED_MODULE_0__.State ? state.context : undefined);

  try {
    for (var patterns_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(patterns), patterns_1_1 = patterns_1.next(); !patterns_1_1.done; patterns_1_1 = patterns_1.next()) {
      var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__read)(patterns_1_1.value, 2),
          stateValue = _b[0],
          getValue = _b[1];

      if (resolvedState.matches(stateValue)) {
        return getValue(resolvedState);
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (patterns_1_1 && !patterns_1_1.done && (_a = patterns_1.return)) _a.call(patterns_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  return defaultValue(resolvedState);
}




/***/ }),

/***/ "./node_modules/xstate/es/registry.js":
/*!********************************************!*\
  !*** ./node_modules/xstate/es/registry.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registry: () => (/* binding */ registry)
/* harmony export */ });
var children = /*#__PURE__*/new Map();
var sessionIdIndex = 0;
var registry = {
  bookId: function () {
    return "x:".concat(sessionIdIndex++);
  },
  register: function (id, actor) {
    children.set(id, actor);
    return id;
  },
  get: function (id) {
    return children.get(id);
  },
  free: function (id) {
    children.delete(id);
  }
};




/***/ }),

/***/ "./node_modules/xstate/es/scheduler.js":
/*!*********************************************!*\
  !*** ./node_modules/xstate/es/scheduler.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Scheduler: () => (/* binding */ Scheduler)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");


var defaultOptions = {
  deferEvents: false
};

var Scheduler =
/*#__PURE__*/

/** @class */
function () {
  function Scheduler(options) {
    this.processingEvent = false;
    this.queue = [];
    this.initialized = false;
    this.options = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, defaultOptions), options);
  }

  Scheduler.prototype.initialize = function (callback) {
    this.initialized = true;

    if (callback) {
      if (!this.options.deferEvents) {
        this.schedule(callback);
        return;
      }

      this.process(callback);
    }

    this.flushEvents();
  };

  Scheduler.prototype.schedule = function (task) {
    if (!this.initialized || this.processingEvent) {
      this.queue.push(task);
      return;
    }

    if (this.queue.length !== 0) {
      throw new Error('Event queue should be empty when it is not processing events');
    }

    this.process(task);
    this.flushEvents();
  };

  Scheduler.prototype.clear = function () {
    this.queue = [];
  };

  Scheduler.prototype.flushEvents = function () {
    var nextCallback = this.queue.shift();

    while (nextCallback) {
      this.process(nextCallback);
      nextCallback = this.queue.shift();
    }
  };

  Scheduler.prototype.process = function (callback) {
    this.processingEvent = true;

    try {
      callback();
    } catch (e) {
      // there is no use to keep the future events
      // as the situation is not anymore the same
      this.clear();
      throw e;
    } finally {
      this.processingEvent = false;
    }
  };

  return Scheduler;
}();




/***/ }),

/***/ "./node_modules/xstate/es/schema.js":
/*!******************************************!*\
  !*** ./node_modules/xstate/es/schema.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSchema: () => (/* binding */ createSchema),
/* harmony export */   t: () => (/* binding */ t)
/* harmony export */ });
function createSchema(schema) {
  return schema;
}
var t = createSchema;




/***/ }),

/***/ "./node_modules/xstate/es/serviceScope.js":
/*!************************************************!*\
  !*** ./node_modules/xstate/es/serviceScope.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   consume: () => (/* binding */ consume),
/* harmony export */   provide: () => (/* binding */ provide)
/* harmony export */ });
/**
 * Maintains a stack of the current service in scope.
 * This is used to provide the correct service to spawn().
 */
var serviceStack = [];
var provide = function (service, fn) {
  serviceStack.push(service);
  var result = fn(service);
  serviceStack.pop();
  return result;
};
var consume = function (fn) {
  return fn(serviceStack[serviceStack.length - 1]);
};




/***/ }),

/***/ "./node_modules/xstate/es/stateUtils.js":
/*!**********************************************!*\
  !*** ./node_modules/xstate/es/stateUtils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getAdjList: () => (/* binding */ getAdjList),
/* harmony export */   getAllChildren: () => (/* binding */ getAllChildren),
/* harmony export */   getAllStateNodes: () => (/* binding */ getAllStateNodes),
/* harmony export */   getChildren: () => (/* binding */ getChildren),
/* harmony export */   getConfiguration: () => (/* binding */ getConfiguration),
/* harmony export */   getMeta: () => (/* binding */ getMeta),
/* harmony export */   getTagsFromConfiguration: () => (/* binding */ getTagsFromConfiguration),
/* harmony export */   getValue: () => (/* binding */ getValue),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   isInFinalState: () => (/* binding */ isInFinalState),
/* harmony export */   isLeafNode: () => (/* binding */ isLeafNode),
/* harmony export */   nextEvents: () => (/* binding */ nextEvents)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");



var isLeafNode = function (stateNode) {
  return stateNode.type === 'atomic' || stateNode.type === 'final';
};
function getAllChildren(stateNode) {
  return Object.keys(stateNode.states).map(function (key) {
    return stateNode.states[key];
  });
}
function getChildren(stateNode) {
  return getAllChildren(stateNode).filter(function (sn) {
    return sn.type !== 'history';
  });
}
function getAllStateNodes(stateNode) {
  var stateNodes = [stateNode];

  if (isLeafNode(stateNode)) {
    return stateNodes;
  }

  return stateNodes.concat((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(getChildren(stateNode).map(getAllStateNodes)));
}
function getConfiguration(prevStateNodes, stateNodes) {
  var e_1, _a, e_2, _b, e_3, _c, e_4, _d;

  var prevConfiguration = new Set(prevStateNodes);
  var prevAdjList = getAdjList(prevConfiguration);
  var configuration = new Set(stateNodes);

  try {
    // add all ancestors
    for (var configuration_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(configuration), configuration_1_1 = configuration_1.next(); !configuration_1_1.done; configuration_1_1 = configuration_1.next()) {
      var s = configuration_1_1.value;
      var m = s.parent;

      while (m && !configuration.has(m)) {
        configuration.add(m);
        m = m.parent;
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (configuration_1_1 && !configuration_1_1.done && (_a = configuration_1.return)) _a.call(configuration_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  var adjList = getAdjList(configuration);

  try {
    // add descendants
    for (var configuration_2 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(configuration), configuration_2_1 = configuration_2.next(); !configuration_2_1.done; configuration_2_1 = configuration_2.next()) {
      var s = configuration_2_1.value; // if previously active, add existing child nodes

      if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s).length)) {
        if (prevAdjList.get(s)) {
          prevAdjList.get(s).forEach(function (sn) {
            return configuration.add(sn);
          });
        } else {
          s.initialStateNodes.forEach(function (sn) {
            return configuration.add(sn);
          });
        }
      } else {
        if (s.type === 'parallel') {
          try {
            for (var _e = (e_3 = void 0, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(getChildren(s))), _f = _e.next(); !_f.done; _f = _e.next()) {
              var child = _f.value;

              if (!configuration.has(child)) {
                configuration.add(child);

                if (prevAdjList.get(child)) {
                  prevAdjList.get(child).forEach(function (sn) {
                    return configuration.add(sn);
                  });
                } else {
                  child.initialStateNodes.forEach(function (sn) {
                    return configuration.add(sn);
                  });
                }
              }
            }
          } catch (e_3_1) {
            e_3 = {
              error: e_3_1
            };
          } finally {
            try {
              if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
            } finally {
              if (e_3) throw e_3.error;
            }
          }
        }
      }
    }
  } catch (e_2_1) {
    e_2 = {
      error: e_2_1
    };
  } finally {
    try {
      if (configuration_2_1 && !configuration_2_1.done && (_b = configuration_2.return)) _b.call(configuration_2);
    } finally {
      if (e_2) throw e_2.error;
    }
  }

  try {
    // add all ancestors
    for (var configuration_3 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(configuration), configuration_3_1 = configuration_3.next(); !configuration_3_1.done; configuration_3_1 = configuration_3.next()) {
      var s = configuration_3_1.value;
      var m = s.parent;

      while (m && !configuration.has(m)) {
        configuration.add(m);
        m = m.parent;
      }
    }
  } catch (e_4_1) {
    e_4 = {
      error: e_4_1
    };
  } finally {
    try {
      if (configuration_3_1 && !configuration_3_1.done && (_d = configuration_3.return)) _d.call(configuration_3);
    } finally {
      if (e_4) throw e_4.error;
    }
  }

  return configuration;
}

function getValueFromAdj(baseNode, adjList) {
  var childStateNodes = adjList.get(baseNode);

  if (!childStateNodes) {
    return {}; // todo: fix?
  }

  if (baseNode.type === 'compound') {
    var childStateNode = childStateNodes[0];

    if (childStateNode) {
      if (isLeafNode(childStateNode)) {
        return childStateNode.key;
      }
    } else {
      return {};
    }
  }

  var stateValue = {};
  childStateNodes.forEach(function (csn) {
    stateValue[csn.key] = getValueFromAdj(csn, adjList);
  });
  return stateValue;
}

function getAdjList(configuration) {
  var e_5, _a;

  var adjList = new Map();

  try {
    for (var configuration_4 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(configuration), configuration_4_1 = configuration_4.next(); !configuration_4_1.done; configuration_4_1 = configuration_4.next()) {
      var s = configuration_4_1.value;

      if (!adjList.has(s)) {
        adjList.set(s, []);
      }

      if (s.parent) {
        if (!adjList.has(s.parent)) {
          adjList.set(s.parent, []);
        }

        adjList.get(s.parent).push(s);
      }
    }
  } catch (e_5_1) {
    e_5 = {
      error: e_5_1
    };
  } finally {
    try {
      if (configuration_4_1 && !configuration_4_1.done && (_a = configuration_4.return)) _a.call(configuration_4);
    } finally {
      if (e_5) throw e_5.error;
    }
  }

  return adjList;
}
function getValue(rootNode, configuration) {
  var config = getConfiguration([rootNode], configuration);
  return getValueFromAdj(rootNode, getAdjList(config));
}
function has(iterable, item) {
  if (Array.isArray(iterable)) {
    return iterable.some(function (member) {
      return member === item;
    });
  }

  if (iterable instanceof Set) {
    return iterable.has(item);
  }

  return false; // TODO: fix
}
function nextEvents(configuration) {
  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__read)(new Set((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__read)(configuration.map(function (sn) {
    return sn.ownEvents;
  })), false)))), false);
}
function isInFinalState(configuration, stateNode) {
  if (stateNode.type === 'compound') {
    return getChildren(stateNode).some(function (s) {
      return s.type === 'final' && has(configuration, s);
    });
  }

  if (stateNode.type === 'parallel') {
    return getChildren(stateNode).every(function (sn) {
      return isInFinalState(configuration, sn);
    });
  }

  return false;
}
function getMeta(configuration) {
  if (configuration === void 0) {
    configuration = [];
  }

  return configuration.reduce(function (acc, stateNode) {
    if (stateNode.meta !== undefined) {
      acc[stateNode.id] = stateNode.meta;
    }

    return acc;
  }, {});
}
function getTagsFromConfiguration(configuration) {
  return new Set((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(configuration.map(function (sn) {
    return sn.tags;
  })));
}




/***/ }),

/***/ "./node_modules/xstate/es/types.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/types.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActionTypes: () => (/* binding */ ActionTypes),
/* harmony export */   SpecialTargets: () => (/* binding */ SpecialTargets)
/* harmony export */ });
var ActionTypes;

(function (ActionTypes) {
  ActionTypes["Start"] = "xstate.start";
  ActionTypes["Stop"] = "xstate.stop";
  ActionTypes["Raise"] = "xstate.raise";
  ActionTypes["Send"] = "xstate.send";
  ActionTypes["Cancel"] = "xstate.cancel";
  ActionTypes["NullEvent"] = "";
  ActionTypes["Assign"] = "xstate.assign";
  ActionTypes["After"] = "xstate.after";
  ActionTypes["DoneState"] = "done.state";
  ActionTypes["DoneInvoke"] = "done.invoke";
  ActionTypes["Log"] = "xstate.log";
  ActionTypes["Init"] = "xstate.init";
  ActionTypes["Invoke"] = "xstate.invoke";
  ActionTypes["ErrorExecution"] = "error.execution";
  ActionTypes["ErrorCommunication"] = "error.communication";
  ActionTypes["ErrorPlatform"] = "error.platform";
  ActionTypes["ErrorCustom"] = "xstate.error";
  ActionTypes["Update"] = "xstate.update";
  ActionTypes["Pure"] = "xstate.pure";
  ActionTypes["Choose"] = "xstate.choose";
})(ActionTypes || (ActionTypes = {}));

var SpecialTargets;

(function (SpecialTargets) {
  SpecialTargets["Parent"] = "#_parent";
  SpecialTargets["Internal"] = "#_internal";
})(SpecialTargets || (SpecialTargets = {}));




/***/ }),

/***/ "./node_modules/xstate/es/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/utils.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createInvokeId: () => (/* binding */ createInvokeId),
/* harmony export */   evaluateGuard: () => (/* binding */ evaluateGuard),
/* harmony export */   flatten: () => (/* binding */ flatten),
/* harmony export */   getActionType: () => (/* binding */ getActionType),
/* harmony export */   getEventType: () => (/* binding */ getEventType),
/* harmony export */   interopSymbols: () => (/* binding */ interopSymbols),
/* harmony export */   isActor: () => (/* binding */ isActor),
/* harmony export */   isArray: () => (/* binding */ isArray),
/* harmony export */   isBehavior: () => (/* binding */ isBehavior),
/* harmony export */   isBuiltInEvent: () => (/* binding */ isBuiltInEvent),
/* harmony export */   isFunction: () => (/* binding */ isFunction),
/* harmony export */   isMachine: () => (/* binding */ isMachine),
/* harmony export */   isObservable: () => (/* binding */ isObservable),
/* harmony export */   isPromiseLike: () => (/* binding */ isPromiseLike),
/* harmony export */   isRaisableAction: () => (/* binding */ isRaisableAction),
/* harmony export */   isStateLike: () => (/* binding */ isStateLike),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   keys: () => (/* binding */ keys),
/* harmony export */   mapContext: () => (/* binding */ mapContext),
/* harmony export */   mapFilterValues: () => (/* binding */ mapFilterValues),
/* harmony export */   mapValues: () => (/* binding */ mapValues),
/* harmony export */   matchesState: () => (/* binding */ matchesState),
/* harmony export */   nestedPath: () => (/* binding */ nestedPath),
/* harmony export */   normalizeTarget: () => (/* binding */ normalizeTarget),
/* harmony export */   partition: () => (/* binding */ partition),
/* harmony export */   path: () => (/* binding */ path),
/* harmony export */   pathToStateValue: () => (/* binding */ pathToStateValue),
/* harmony export */   pathsToStateValue: () => (/* binding */ pathsToStateValue),
/* harmony export */   reportUnhandledExceptionOnInvocation: () => (/* binding */ reportUnhandledExceptionOnInvocation),
/* harmony export */   symbolObservable: () => (/* binding */ symbolObservable),
/* harmony export */   toArray: () => (/* binding */ toArray),
/* harmony export */   toArrayStrict: () => (/* binding */ toArrayStrict),
/* harmony export */   toEventObject: () => (/* binding */ toEventObject),
/* harmony export */   toGuard: () => (/* binding */ toGuard),
/* harmony export */   toInvokeSource: () => (/* binding */ toInvokeSource),
/* harmony export */   toObserver: () => (/* binding */ toObserver),
/* harmony export */   toSCXMLEvent: () => (/* binding */ toSCXMLEvent),
/* harmony export */   toStatePath: () => (/* binding */ toStatePath),
/* harmony export */   toStatePaths: () => (/* binding */ toStatePaths),
/* harmony export */   toStateValue: () => (/* binding */ toStateValue),
/* harmony export */   toTransitionConfigArray: () => (/* binding */ toTransitionConfigArray),
/* harmony export */   uniqueId: () => (/* binding */ uniqueId),
/* harmony export */   updateContext: () => (/* binding */ updateContext),
/* harmony export */   updateHistoryStates: () => (/* binding */ updateHistoryStates),
/* harmony export */   updateHistoryValue: () => (/* binding */ updateHistoryValue),
/* harmony export */   warn: () => (/* binding */ warn)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types.js */ "./node_modules/xstate/es/types.js");
/* harmony import */ var _actionTypes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actionTypes.js */ "./node_modules/xstate/es/actionTypes.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./node_modules/xstate/es/constants.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./environment.js */ "./node_modules/xstate/es/environment.js");






var _a;
function keys(value) {
  return Object.keys(value);
}
function matchesState(parentStateId, childStateId, delimiter) {
  if (delimiter === void 0) {
    delimiter = _constants_js__WEBPACK_IMPORTED_MODULE_0__.STATE_DELIMITER;
  }

  var parentStateValue = toStateValue(parentStateId, delimiter);
  var childStateValue = toStateValue(childStateId, delimiter);

  if (isString(childStateValue)) {
    if (isString(parentStateValue)) {
      return childStateValue === parentStateValue;
    } // Parent more specific than child


    return false;
  }

  if (isString(parentStateValue)) {
    return parentStateValue in childStateValue;
  }

  return Object.keys(parentStateValue).every(function (key) {
    if (!(key in childStateValue)) {
      return false;
    }

    return matchesState(parentStateValue[key], childStateValue[key]);
  });
}
function getEventType(event) {
  try {
    return isString(event) || typeof event === 'number' ? "".concat(event) : event.type;
  } catch (e) {
    throw new Error('Events must be strings or objects with a string event.type property.');
  }
}
function getActionType(action) {
  try {
    return isString(action) || typeof action === 'number' ? "".concat(action) : isFunction(action) ? action.name : action.type;
  } catch (e) {
    throw new Error('Actions must be strings or objects with a string action.type property.');
  }
}
function toStatePath(stateId, delimiter) {
  try {
    if (isArray(stateId)) {
      return stateId;
    }

    return stateId.toString().split(delimiter);
  } catch (e) {
    throw new Error("'".concat(stateId, "' is not a valid state path."));
  }
}
function isStateLike(state) {
  return typeof state === 'object' && 'value' in state && 'context' in state && 'event' in state && '_event' in state;
}
function toStateValue(stateValue, delimiter) {
  if (isStateLike(stateValue)) {
    return stateValue.value;
  }

  if (isArray(stateValue)) {
    return pathToStateValue(stateValue);
  }

  if (typeof stateValue !== 'string') {
    return stateValue;
  }

  var statePath = toStatePath(stateValue, delimiter);
  return pathToStateValue(statePath);
}
function pathToStateValue(statePath) {
  if (statePath.length === 1) {
    return statePath[0];
  }

  var value = {};
  var marker = value;

  for (var i = 0; i < statePath.length - 1; i++) {
    if (i === statePath.length - 2) {
      marker[statePath[i]] = statePath[i + 1];
    } else {
      marker[statePath[i]] = {};
      marker = marker[statePath[i]];
    }
  }

  return value;
}
function mapValues(collection, iteratee) {
  var result = {};
  var collectionKeys = Object.keys(collection);

  for (var i = 0; i < collectionKeys.length; i++) {
    var key = collectionKeys[i];
    result[key] = iteratee(collection[key], key, collection, i);
  }

  return result;
}
function mapFilterValues(collection, iteratee, predicate) {
  var e_1, _a;

  var result = {};

  try {
    for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(Object.keys(collection)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var key = _c.value;
      var item = collection[key];

      if (!predicate(item)) {
        continue;
      }

      result[key] = iteratee(item, key, collection);
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  return result;
}
/**
 * Retrieves a value at the given path.
 * @param props The deep path to the prop of the desired value
 */

var path = function (props) {
  return function (object) {
    var e_2, _a;

    var result = object;

    try {
      for (var props_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
        var prop = props_1_1.value;
        result = result[prop];
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    return result;
  };
};
/**
 * Retrieves a value at the given path via the nested accessor prop.
 * @param props The deep path to the prop of the desired value
 */

function nestedPath(props, accessorProp) {
  return function (object) {
    var e_3, _a;

    var result = object;

    try {
      for (var props_2 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(props), props_2_1 = props_2.next(); !props_2_1.done; props_2_1 = props_2.next()) {
        var prop = props_2_1.value;
        result = result[accessorProp][prop];
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (props_2_1 && !props_2_1.done && (_a = props_2.return)) _a.call(props_2);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    return result;
  };
}
function toStatePaths(stateValue) {
  if (!stateValue) {
    return [[]];
  }

  if (isString(stateValue)) {
    return [[stateValue]];
  }

  var result = flatten(Object.keys(stateValue).map(function (key) {
    var subStateValue = stateValue[key];

    if (typeof subStateValue !== 'string' && (!subStateValue || !Object.keys(subStateValue).length)) {
      return [[key]];
    }

    return toStatePaths(stateValue[key]).map(function (subPath) {
      return [key].concat(subPath);
    });
  }));
  return result;
}
function pathsToStateValue(paths) {
  var e_4, _a;

  var result = {};

  if (paths && paths.length === 1 && paths[0].length === 1) {
    return paths[0][0];
  }

  try {
    for (var paths_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(paths), paths_1_1 = paths_1.next(); !paths_1_1.done; paths_1_1 = paths_1.next()) {
      var currentPath = paths_1_1.value;
      var marker = result; // tslint:disable-next-line:prefer-for-of

      for (var i = 0; i < currentPath.length; i++) {
        var subPath = currentPath[i];

        if (i === currentPath.length - 2) {
          marker[subPath] = currentPath[i + 1];
          break;
        }

        marker[subPath] = marker[subPath] || {};
        marker = marker[subPath];
      }
    }
  } catch (e_4_1) {
    e_4 = {
      error: e_4_1
    };
  } finally {
    try {
      if (paths_1_1 && !paths_1_1.done && (_a = paths_1.return)) _a.call(paths_1);
    } finally {
      if (e_4) throw e_4.error;
    }
  }

  return result;
}
function flatten(array) {
  var _a;

  return (_a = []).concat.apply(_a, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__read)(array), false));
}
function toArrayStrict(value) {
  if (isArray(value)) {
    return value;
  }

  return [value];
}
function toArray(value) {
  if (value === undefined) {
    return [];
  }

  return toArrayStrict(value);
}
function mapContext(mapper, context, _event) {
  var e_5, _a;

  if (isFunction(mapper)) {
    return mapper(context, _event.data);
  }

  var result = {};

  try {
    for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(Object.keys(mapper)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var key = _c.value;
      var subMapper = mapper[key];

      if (isFunction(subMapper)) {
        result[key] = subMapper(context, _event.data);
      } else {
        result[key] = subMapper;
      }
    }
  } catch (e_5_1) {
    e_5 = {
      error: e_5_1
    };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
    } finally {
      if (e_5) throw e_5.error;
    }
  }

  return result;
}
function isBuiltInEvent(eventType) {
  return /^(done|error)\./.test(eventType);
}
function isPromiseLike(value) {
  if (value instanceof Promise) {
    return true;
  } // Check if shape matches the Promise/A+ specification for a "thenable".


  if (value !== null && (isFunction(value) || typeof value === 'object') && isFunction(value.then)) {
    return true;
  }

  return false;
}
function isBehavior(value) {
  return value !== null && typeof value === 'object' && 'transition' in value && typeof value.transition === 'function';
}
function partition(items, predicate) {
  var e_6, _a;

  var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__read)([[], []], 2),
      truthy = _b[0],
      falsy = _b[1];

  try {
    for (var items_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
      var item = items_1_1.value;

      if (predicate(item)) {
        truthy.push(item);
      } else {
        falsy.push(item);
      }
    }
  } catch (e_6_1) {
    e_6 = {
      error: e_6_1
    };
  } finally {
    try {
      if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
    } finally {
      if (e_6) throw e_6.error;
    }
  }

  return [truthy, falsy];
}
function updateHistoryStates(hist, stateValue) {
  return mapValues(hist.states, function (subHist, key) {
    if (!subHist) {
      return undefined;
    }

    var subStateValue = (isString(stateValue) ? undefined : stateValue[key]) || (subHist ? subHist.current : undefined);

    if (!subStateValue) {
      return undefined;
    }

    return {
      current: subStateValue,
      states: updateHistoryStates(subHist, subStateValue)
    };
  });
}
function updateHistoryValue(hist, stateValue) {
  return {
    current: stateValue,
    states: updateHistoryStates(hist, stateValue)
  };
}
function updateContext(context, _event, assignActions, state) {
  if (!_environment_js__WEBPACK_IMPORTED_MODULE_2__.IS_PRODUCTION) {
    warn(!!context, 'Attempting to update undefined context');
  }

  var updatedContext = context ? assignActions.reduce(function (acc, assignAction) {
    var e_7, _a;

    var assignment = assignAction.assignment;
    var meta = {
      state: state,
      action: assignAction,
      _event: _event
    };
    var partialUpdate = {};

    if (isFunction(assignment)) {
      partialUpdate = assignment(acc, _event.data, meta);
    } else {
      try {
        for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(Object.keys(assignment)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          var propAssignment = assignment[key];
          partialUpdate[key] = isFunction(propAssignment) ? propAssignment(acc, _event.data, meta) : propAssignment;
        }
      } catch (e_7_1) {
        e_7 = {
          error: e_7_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_7) throw e_7.error;
        }
      }
    }

    return Object.assign({}, acc, partialUpdate);
  }, context) : context;
  return updatedContext;
} // tslint:disable-next-line:no-empty

var warn = function () {};

if (!_environment_js__WEBPACK_IMPORTED_MODULE_2__.IS_PRODUCTION) {
  warn = function (condition, message) {
    var error = condition instanceof Error ? condition : undefined;

    if (!error && condition) {
      return;
    }

    if (console !== undefined) {
      var args = ["Warning: ".concat(message)];

      if (error) {
        args.push(error);
      } // tslint:disable-next-line:no-console


      console.warn.apply(console, args);
    }
  };
}
function isArray(value) {
  return Array.isArray(value);
} // tslint:disable-next-line:ban-types

function isFunction(value) {
  return typeof value === 'function';
}
function isString(value) {
  return typeof value === 'string';
}
function toGuard(condition, guardMap) {
  if (!condition) {
    return undefined;
  }

  if (isString(condition)) {
    return {
      type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_GUARD_TYPE,
      name: condition,
      predicate: guardMap ? guardMap[condition] : undefined
    };
  }

  if (isFunction(condition)) {
    return {
      type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_GUARD_TYPE,
      name: condition.name,
      predicate: condition
    };
  }

  return condition;
}
function isObservable(value) {
  try {
    return 'subscribe' in value && isFunction(value.subscribe);
  } catch (e) {
    return false;
  }
}
var symbolObservable = /*#__PURE__*/function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
}(); // TODO: to be removed in v5, left it out just to minimize the scope of the change and maintain compatibility with older versions of integration paackages

var interopSymbols = (_a = {}, _a[symbolObservable] = function () {
  return this;
}, _a[Symbol.observable] = function () {
  return this;
}, _a);
function isMachine(value) {
  return !!value && '__xstatenode' in value;
}
function isActor(value) {
  return !!value && typeof value.send === 'function';
}
var uniqueId = /*#__PURE__*/function () {
  var currentId = 0;
  return function () {
    currentId++;
    return currentId.toString(16);
  };
}();
function toEventObject(event, payload // id?: TEvent['type']
) {
  if (isString(event) || typeof event === 'number') {
    return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__assign)({
      type: event
    }, payload);
  }

  return event;
}
function toSCXMLEvent(event, scxmlEvent) {
  if (!isString(event) && '$$type' in event && event.$$type === 'scxml') {
    return event;
  }

  var eventObject = toEventObject(event);
  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__assign)({
    name: eventObject.type,
    data: eventObject,
    $$type: 'scxml',
    type: 'external'
  }, scxmlEvent);
}
function toTransitionConfigArray(event, configLike) {
  var transitions = toArrayStrict(configLike).map(function (transitionLike) {
    if (typeof transitionLike === 'undefined' || typeof transitionLike === 'string' || isMachine(transitionLike)) {
      return {
        target: transitionLike,
        event: event
      };
    }

    return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, transitionLike), {
      event: event
    });
  });
  return transitions;
}
function normalizeTarget(target) {
  if (target === undefined || target === _constants_js__WEBPACK_IMPORTED_MODULE_0__.TARGETLESS_KEY) {
    return undefined;
  }

  return toArray(target);
}
function reportUnhandledExceptionOnInvocation(originalError, currentError, id) {
  if (!_environment_js__WEBPACK_IMPORTED_MODULE_2__.IS_PRODUCTION) {
    var originalStackTrace = originalError.stack ? " Stacktrace was '".concat(originalError.stack, "'") : '';

    if (originalError === currentError) {
      // tslint:disable-next-line:no-console
      console.error("Missing onError handler for invocation '".concat(id, "', error was '").concat(originalError, "'.").concat(originalStackTrace));
    } else {
      var stackTrace = currentError.stack ? " Stacktrace was '".concat(currentError.stack, "'") : ''; // tslint:disable-next-line:no-console

      console.error("Missing onError handler and/or unhandled exception/promise rejection for invocation '".concat(id, "'. ") + "Original error: '".concat(originalError, "'. ").concat(originalStackTrace, " Current error is '").concat(currentError, "'.").concat(stackTrace));
    }
  }
}
function evaluateGuard(machine, guard, context, _event, state) {
  var guards = machine.options.guards;
  var guardMeta = {
    state: state,
    cond: guard,
    _event: _event
  }; // TODO: do not hardcode!

  if (guard.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_GUARD_TYPE) {
    return ((guards === null || guards === void 0 ? void 0 : guards[guard.name]) || guard.predicate)(context, _event.data, guardMeta);
  }

  var condFn = guards === null || guards === void 0 ? void 0 : guards[guard.type];

  if (!condFn) {
    throw new Error("Guard '".concat(guard.type, "' is not implemented on machine '").concat(machine.id, "'."));
  }

  return condFn(context, _event.data, guardMeta);
}
function toInvokeSource(src) {
  if (typeof src === 'string') {
    return {
      type: src
    };
  }

  return src;
}
function toObserver(nextHandler, errorHandler, completionHandler) {
  var noop = function () {};

  var isObserver = typeof nextHandler === 'object';
  var self = isObserver ? nextHandler : null;
  return {
    next: ((isObserver ? nextHandler.next : nextHandler) || noop).bind(self),
    error: ((isObserver ? nextHandler.error : errorHandler) || noop).bind(self),
    complete: ((isObserver ? nextHandler.complete : completionHandler) || noop).bind(self)
  };
}
function createInvokeId(stateNodeId, index) {
  return "".concat(stateNodeId, ":invocation[").concat(index, "]");
}
function isRaisableAction(action) {
  return (action.type === _actionTypes_js__WEBPACK_IMPORTED_MODULE_3__.raise || action.type === _actionTypes_js__WEBPACK_IMPORTED_MODULE_3__.send && action.to === _types_js__WEBPACK_IMPORTED_MODULE_4__.SpecialTargets.Internal) && typeof action.delay !== 'number';
}




/***/ }),

/***/ "./src/AnimationModule.js":
/*!********************************!*\
  !*** ./src/AnimationModule.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AnimationModule)
/* harmony export */ });
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var AnimationModule = /*#__PURE__*/function () {
  function AnimationModule() {
    _classCallCheck(this, AnimationModule);
  }
  _createClass(AnimationModule, null, [{
    key: "startAnimation",
    value: function startAnimation(animation) {
      this.stopOtherAnimations(animation);
      var rectangles = document.querySelectorAll(this.rectanglesSelector);
      rectangles.forEach(function (rect) {
        return rect.classList.add(animation);
      });
    }
  }, {
    key: "stopAnimation",
    value: function stopAnimation(animation) {
      var rectangles = document.querySelectorAll(this.rectanglesSelector);
      rectangles.forEach(function (rect) {
        return rect.classList.remove(animation);
      });
    }
  }, {
    key: "stopAllAnimations",
    value: function stopAllAnimations() {
      var _this = this;
      this.talkButtonAnimations.forEach(function (animation) {
        return _this.stopAnimation(animation);
      });
    }
  }, {
    key: "stopOtherAnimations",
    value: function stopOtherAnimations(keepAnimation) {
      var _this2 = this;
      this.talkButtonAnimations.forEach(function (animation) {
        if (animation !== keepAnimation) {
          _this2.stopAnimation(animation);
        }
      });
    }
  }]);
  return AnimationModule;
}();
_defineProperty(AnimationModule, "rectanglesSelector", ".outermost, .second, .third, .fourth, .fifth, .innermost");
_defineProperty(AnimationModule, "talkButtonAnimations", ["piSpeaking", "userSpeaking", "transcribing"]);


/***/ }),

/***/ "./src/AudioModule.js":
/*!****************************!*\
  !*** ./src/AudioModule.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioModule)
/* harmony export */ });
/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! xstate */ "./node_modules/xstate/es/interpreter.js");
/* harmony import */ var _state_machines_AudioInputMachine_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./state-machines/AudioInputMachine.ts */ "./src/state-machines/AudioInputMachine.ts");
/* harmony import */ var _state_machines_AudioOutputMachine_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./state-machines/AudioOutputMachine.js */ "./src/state-machines/AudioOutputMachine.js");
/* harmony import */ var _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LoggingModule.js */ "./src/LoggingModule.js");
/* harmony import */ var _EventBus_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventBus.js */ "./src/EventBus.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// import state machines for audio input and output





var AudioModule = /*#__PURE__*/function () {
  function AudioModule() {
    _classCallCheck(this, AudioModule);
    this.audioElement = document.querySelector("audio");
    if (!this.audioElement) {
      console.error("Audio element not found!");
    } else {
      this.audioElement.preload = "auto"; // enable aggressive preloading of audio
    }

    this.audioOutputActor = (0,xstate__WEBPACK_IMPORTED_MODULE_4__.interpret)(_state_machines_AudioOutputMachine_js__WEBPACK_IMPORTED_MODULE_1__.audioOutputMachine);
    this.audioOutputActor.onTransition(function (state) {
      if (state.changed) {
        var fromState = state.history ? (0,_LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.serializeStateValue)(state.history.value) : "N/A";
        var toState = (0,_LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.serializeStateValue)(state.value);
        _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.debug("Audio Output Machine transitioned from ".concat(fromState, " to ").concat(toState, " with ").concat(state.event.type));
      }
    });
    this.audioInputActor = (0,xstate__WEBPACK_IMPORTED_MODULE_4__.interpret)(_state_machines_AudioInputMachine_ts__WEBPACK_IMPORTED_MODULE_0__.audioInputMachine);
    this.audioInputActor.onTransition(function (state) {
      if (state.changed) {
        var fromState = state.history ? (0,_LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.serializeStateValue)(state.history.value) : "N/A";
        var toState = (0,_LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.serializeStateValue)(state.value);
        _LoggingModule_js__WEBPACK_IMPORTED_MODULE_2__.logger.debug("Audio Input Machine transitioned from ".concat(fromState, " to ").concat(toState, " with ").concat(state.event.type));
      }
    });
  }
  _createClass(AudioModule, [{
    key: "start",
    value: function start() {
      // audio output (Pi)
      this.audioOutputActor.start();
      this.registerAudioPlaybackEvents(this.audioElement, this.audioOutputActor);

      // audio input (user)
      this.audioInputActor.start();
      this.registerAudioCommands(this.audioInputActor, this.audioOutputActor);
    }
  }, {
    key: "registerAudioPlaybackEvents",
    value: function registerAudioPlaybackEvents(audio, actor) {
      var events = ["loadstart", "loadedmetadata", "canplaythrough", "play", "pause", "ended", "seeked", "emptied"];
      events.forEach(function (event) {
        audio.addEventListener(event, function () {
          return actor.send(event);
        });
      });
      audio.addEventListener("playing", function () {
        actor.send("play");
      });
    }

    /* These events are used to control/pass requests to the audio module from other modules */
  }, {
    key: "registerAudioCommands",
    value: function registerAudioCommands(inputActor, outputActor) {
      // audio input (recording) commands
      _EventBus_js__WEBPACK_IMPORTED_MODULE_3__["default"].on("audio:setupRecording", function (e) {
        inputActor.send("acquire");
      });
      _EventBus_js__WEBPACK_IMPORTED_MODULE_3__["default"].on("audio:tearDownRecording", function (e) {
        inputActor.send("release");
      });
      _EventBus_js__WEBPACK_IMPORTED_MODULE_3__["default"].on("audio:startRecording", function (e) {
        // Check if Pi is currently speaking and stop her audio
        outputActor.send("pause");

        // Check if the microphone is acquired before starting?
        inputActor.send(["acquire", "start"]);
      });
      _EventBus_js__WEBPACK_IMPORTED_MODULE_3__["default"].on("audio:stopRecording", function (e) {
        inputActor.send("stopRequested");
        /* resume or cancel Pi's audio */
        /* TODO: reassess how to handle interruptions
        outputActor.send("play"); // resume Pi's audio
        outputActor.send("stop"); // cancel Pi's audio
        */
      });
      // audio input (recording) events (pass media recorder events -> audio input machine actor)
      _EventBus_js__WEBPACK_IMPORTED_MODULE_3__["default"].on("audio:dataavailable", function (detail) {
        inputActor.send(_objectSpread({
          type: "dataAvailable"
        }, detail));
      });
      _EventBus_js__WEBPACK_IMPORTED_MODULE_3__["default"].on("audio:input:stop", function (e) {
        inputActor.send("stop");
      });

      // audio output (playback) commands
      _EventBus_js__WEBPACK_IMPORTED_MODULE_3__["default"].on("audio:reload", function (e) {
        outputActor.send("reload");
      });
    }
  }]);
  return AudioModule;
}();


/***/ }),

/***/ "./src/ButtonModule.js":
/*!*****************************!*\
  !*** ./src/ButtonModule.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buttonModule: () => (/* binding */ buttonModule),
/* harmony export */   "default": () => (/* binding */ ButtonModule)
/* harmony export */ });
/* harmony import */ var _UserAgentModule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UserAgentModule.js */ "./src/UserAgentModule.js");
/* harmony import */ var _DOMModule_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DOMModule.ts */ "./src/DOMModule.ts");
/* harmony import */ var _EventBus_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventBus.js */ "./src/EventBus.js");
/* harmony import */ var _StateMachineService_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./StateMachineService.js */ "./src/StateMachineService.js");
/* harmony import */ var _SubmitErrorHandler_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SubmitErrorHandler.ts */ "./src/SubmitErrorHandler.ts");
/* harmony import */ var _icons_exit_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./icons/exit.svg */ "./src/icons/exit.svg");
/* harmony import */ var _icons_maximize_svg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./icons/maximize.svg */ "./src/icons/maximize.svg");
/* harmony import */ var _icons_rectangles_svg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./icons/rectangles.svg */ "./src/icons/rectangles.svg");
/* harmony import */ var _icons_waveform_svg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./icons/waveform.svg */ "./src/icons/waveform.svg");
/* harmony import */ var _icons_muted_microphone_svg__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./icons/muted_microphone.svg */ "./src/icons/muted_microphone.svg");
/* harmony import */ var _icons_call_svg__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./icons/call.svg */ "./src/icons/call.svg");
/* harmony import */ var _icons_hangup_svg__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./icons/hangup.svg */ "./src/icons/hangup.svg");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }












var ButtonModule = /*#__PURE__*/function () {
  function ButtonModule() {
    _classCallCheck(this, ButtonModule);
    this.actor = _StateMachineService_js__WEBPACK_IMPORTED_MODULE_3__["default"].actor;
    // Binding methods to the current instance
    this.registerOtherEvents();

    // track the frequency of bug #26
    this.submissionsWithoutAnError = 0;
  }
  _createClass(ButtonModule, [{
    key: "registerOtherEvents",
    value: function registerOtherEvents() {
      var _this = this;
      _EventBus_js__WEBPACK_IMPORTED_MODULE_2__["default"].on("saypi:autoSubmit", function () {
        _this.handleAutoSubmit();
      });
    }

    // Function to create a new button
  }, {
    key: "createButton",
    value: function createButton(label, callback) {
      var button = document.createElement("button");
      if (label) {
        button.textContent = label;
      }
      if (callback) {
        button.onclick = callback;
      }
      return button;
    }

    // Function to style a given button
  }, {
    key: "styleButton",
    value: function styleButton(button, styles) {
      for (var key in styles) {
        if (styles.hasOwnProperty(key)) {
          button.style[key] = styles[key];
        }
      }
    }
  }, {
    key: "addTalkIcon",
    value: function addTalkIcon(button) {
      var _this2 = this;
      this.updateIconContent(button);
      window.matchMedia("(max-width: 768px)").addListener(function () {
        _this2.updateIconContent(button);
      });
      this.setupClassObserver(button);
    }
  }, {
    key: "updateIconContent",
    value: function updateIconContent(iconContainer) {
      if ((0,_UserAgentModule_js__WEBPACK_IMPORTED_MODULE_0__.isMobileView)()) {
        iconContainer.innerHTML = _icons_rectangles_svg__WEBPACK_IMPORTED_MODULE_7__["default"];
      } else {
        iconContainer.innerHTML = _icons_waveform_svg__WEBPACK_IMPORTED_MODULE_8__["default"];
      }
    }
  }, {
    key: "setupClassObserver",
    value: function setupClassObserver(button) {
      var _this3 = this;
      var targetNode = document.documentElement; // The <html> element

      var config = {
        attributes: true,
        attributeFilter: ["class"]
      };
      var callback = function callback(mutationsList, observer) {
        var _iterator = _createForOfIteratorHelper(mutationsList),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var mutation = _step.value;
            if (mutation.type === "attributes") {
              if (mutation.attributeName === "class") {
                if (document.documentElement.classList.contains("mobile-view")) {
                  // 'mobile-view' class was added
                  _this3.updateIconContent(button);
                } else {
                  // 'mobile-view' class was removed
                  _this3.updateIconContent(button);
                }
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      };
      var observer = new MutationObserver(callback);

      // Start observing the target node for configured mutations
      observer.observe(targetNode, config);

      // Later, you can stop observing by calling:
      // observer.disconnect();
    }

    // Simulate an "Enter" keypress event on a form
  }, {
    key: "simulateFormSubmit",
    value: function simulateFormSubmit() {
      var submitButton = document.getElementById("saypi-submitButton");
      if (submitButton) {
        if (_SubmitErrorHandler_ts__WEBPACK_IMPORTED_MODULE_4__.submitErrorHandler.detectSubmitError()) {
          // track how often this happens
          console.error("Autosubmit failed after ".concat(this.submissionsWithoutAnError, " turns."));
          this.submissionsWithoutAnError = 0;
          _SubmitErrorHandler_ts__WEBPACK_IMPORTED_MODULE_4__.submitErrorHandler.handleSubmitError();
        } else {
          this.submissionsWithoutAnError++;
          submitButton.click();
        }
      } else {
        /* hit enter key in the prompt textarea, might not work as expected on "new ui layout" */
        var textarea = document.getElementById("saypi-prompt");
        var enterEvent = new KeyboardEvent("keydown", {
          bubbles: true,
          key: "Enter",
          keyCode: 13,
          which: 13
        });
        textarea.dispatchEvent(enterEvent);
      }
    }

    // Function to handle auto-submit based on the button's data attribute
  }, {
    key: "handleAutoSubmit",
    value: function handleAutoSubmit() {
      var talkButton = document.getElementById("saypi-talkButton");
      if (talkButton.dataset.autosubmit === "false") {
        console.log("Autosubmit is off");
      } else {
        this.simulateFormSubmit();
      }
    }
  }, {
    key: "createExitButton",
    value: function createExitButton() {
      var label = "Exit Voice-Controlled Mobile Mode";
      var button = this.createButton("", function () {
        (0,_UserAgentModule_js__WEBPACK_IMPORTED_MODULE_0__.exitMobileMode)();
      });
      button.id = "saypi-exitButton";
      button.type = "button";
      button.className = "exit-button fixed rounded-full bg-cream-550 enabled:hover:bg-cream-650";
      button.setAttribute("aria-label", label);
      button.setAttribute("title", label);
      button.innerHTML = _icons_exit_svg__WEBPACK_IMPORTED_MODULE_5__["default"];
      document.body.appendChild(button);
      return button;
    }
  }, {
    key: "createEnterButton",
    value: function createEnterButton() {
      var label = "Enter Voice-Controlled Mobile Mode";
      var button = this.createButton("", function () {
        (0,_UserAgentModule_js__WEBPACK_IMPORTED_MODULE_0__.enterMobileMode)();
      });
      button.id = "saypi-enterButton";
      button.type = "button";
      button.className = "enter-button fixed rounded-full bg-cream-550 enabled:hover:bg-cream-650";
      button.setAttribute("aria-label", label);
      button.setAttribute("title", label);
      button.innerHTML = _icons_maximize_svg__WEBPACK_IMPORTED_MODULE_6__["default"];
      document.body.appendChild(button);
      return button;
    }
  }, {
    key: "showNotification",
    value: function showNotification(details) {
      var icon = details.icon;
      var iconSVG;
      if (icon === "muted-microphone") {
        iconSVG = _icons_muted_microphone_svg__WEBPACK_IMPORTED_MODULE_9__["default"];
      }
      var notification = document.getElementById("saypi-notification");
      if (notification) {
        notification.classList.remove("hidden");
        notification.innerHTML = iconSVG;
      } else {
        var _notification = document.createElement("div");
        _notification.id = "saypi-notification";
        _notification.className = "notification";
        _notification.innerHTML = iconSVG;
        document.body.appendChild(_notification);
      }
    }
  }, {
    key: "dismissNotification",
    value: function dismissNotification() {
      var notification = document.getElementById("saypi-notification");
      if (notification) {
        notification.classList.add("hidden");
      }
    }
  }, {
    key: "createCallButton",
    value: function createCallButton(container) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var button = this.createButton();
      button.id = "saypi-callButton";
      button.type = "button";
      button.className = "call-button fixed rounded-full bg-cream-550 enabled:hover:bg-cream-650";
      this.callInactive(button); // mic is off by default

      (0,_DOMModule_ts__WEBPACK_IMPORTED_MODULE_1__.appendChild)(container, button, position);
      return button;
    }
  }, {
    key: "callActive",
    value: function callActive(callButton) {
      var _this4 = this;
      if (!callButton) {
        callButton = document.getElementById("saypi-callButton");
      }
      if (callButton) {
        var label = "Active continuous listening. Click to stop.";
        callButton.innerHTML = _icons_hangup_svg__WEBPACK_IMPORTED_MODULE_11__["default"];
        callButton.setAttribute("aria-label", label);
        callButton.setAttribute("title", label);
        callButton.onclick = function () {
          _this4.actor.send("saypi:hangup");
        };
        callButton.classList.add("active");
      }
    }
  }, {
    key: "callInactive",
    value: function callInactive(callButton) {
      var _this5 = this;
      if (!callButton) {
        callButton = document.getElementById("saypi-callButton");
      }
      if (callButton) {
        callButton.innerHTML = _icons_call_svg__WEBPACK_IMPORTED_MODULE_10__["default"];
        callButton.setAttribute("aria-label", "Click to start continuous listening.");
        callButton.setAttribute("title", "Not listening. Click to start.");
        callButton.onclick = function () {
          _this5.actor.send("saypi:call");
        };
        callButton.classList.remove("active");
      }
    }
  }, {
    key: "disableCallButton",
    value: function disableCallButton() {
      var callButton = document.getElementById("saypi-callButton");
      if (callButton) {
        callButton.classList.add("disabled");
        // disable the call action, but always allow hangup
        if (!callButton.classList.contains("active")) {
          callButton.disabled = true;
        }
      }
    }
  }, {
    key: "enableCallButton",
    value: function enableCallButton() {
      var callButton = document.getElementById("saypi-callButton");
      if (callButton) {
        callButton.classList.remove("disabled");
        callButton.disabled = false;
      }
    }
  }]);
  return ButtonModule;
}(); // Singleton

var buttonModule = new ButtonModule();

/***/ }),

/***/ "./src/ConfigModule.js":
/*!*****************************!*\
  !*** ./src/ConfigModule.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   config: () => (/* binding */ config)
/* harmony export */ });
var config = {
  appServerUrl: "http://127.0.0.1:8080",
  apiServerUrl: "http://127.0.0.1:5001"
};

/***/ }),

/***/ "./src/EventBus.js":
/*!*************************!*\
  !*** ./src/EventBus.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new events__WEBPACK_IMPORTED_MODULE_0__());

/***/ }),

/***/ "./src/EventModule.js":
/*!****************************!*\
  !*** ./src/EventModule.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EventModule)
/* harmony export */ });
/* harmony import */ var _EventBus_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventBus.js */ "./src/EventBus.js");
/* harmony import */ var _StateMachineService_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StateMachineService.js */ "./src/StateMachineService.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }


var USER_SPEAKING = "saypi:userSpeaking";
var USER_STOPPED_SPEAKING = "saypi:userStoppedSpeaking";
var USER_FINISHED_SPEAKING = "saypi:userFinishedSpeaking";
var PI_SPEAKING = "saypi:piSpeaking";
var PI_STOPPED_SPEAKING = "saypi:piStoppedSpeaking";
var PI_FINISHED_SPEAKING = "saypi:piFinishedSpeaking";
var EventModule = /*#__PURE__*/function () {
  function EventModule() {
    _classCallCheck(this, EventModule);
  }
  _createClass(EventModule, null, [{
    key: "init",
    value: function init() {
      // All the event listeners can be added here
      this.registerStateMachineEvents(_StateMachineService_js__WEBPACK_IMPORTED_MODULE_1__["default"].actor);
      // Any other initializations...
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      // Remove event listeners if needed, or any other cleanup operations
      window.removeEventListener("saypi:transcribed", this.handleTranscriptionResponse);
    }
  }, {
    key: "simulateTyping",
    value: function simulateTyping(element, text) {
      element.focus();

      // Define a regular expression to match sentence terminators, capturing them
      var sentenceRegex = /([.!?。？！]+)/g;
      var tokens = text.split(sentenceRegex).filter(Boolean);

      // Reassemble sentences with their terminators
      var sentences = [];
      for (var _i = 0; _i < tokens.length; _i += 2) {
        var sentence = tokens[_i] + (tokens[_i + 1] || "");
        sentences.push(sentence);
      }
      var i = 0;
      var typeSentence = function typeSentence() {
        if (i < sentences.length) {
          // Type the sentence and its immediate following terminator
          EventModule.setNativeValue(element, element.value + sentences[i++]);
          requestAnimationFrame(typeSentence);
        } else {
          _EventBus_js__WEBPACK_IMPORTED_MODULE_0__["default"].emit("saypi:autoSubmit");
        }
      };
      if (sentences.length > 1) {
        // If there are multiple sentences, proceed with sentence-wise typing
        typeSentence();
      } else {
        // If text does not contain recognisable sentence terminators, type it all at once
        EventModule.setNativeValue(element, text);
        _EventBus_js__WEBPACK_IMPORTED_MODULE_0__["default"].emit("saypi:autoSubmit");
      }
    }
  }, {
    key: "setNativeValue",
    value: function setNativeValue(element, value) {
      var lastValue = element.value;
      element.value = value;
      var event = new Event("input", {
        target: element,
        bubbles: true
      });
      // React 15
      event.simulated = true;
      // React 16-17
      var tracker = element._valueTracker;
      if (tracker) {
        tracker.setValue(lastValue);
      }
      element.dispatchEvent(event);
    }
  }, {
    key: "registerStateMachineEvents",
    value: function registerStateMachineEvents(actor) {
      _EventBus_js__WEBPACK_IMPORTED_MODULE_0__["default"].on(USER_SPEAKING, function () {
        actor.send(USER_SPEAKING);
      });
      [USER_STOPPED_SPEAKING, USER_FINISHED_SPEAKING].forEach(function (eventName) {
        _EventBus_js__WEBPACK_IMPORTED_MODULE_0__["default"].on(eventName, function (detail) {
          if (detail) {
            actor.send(_objectSpread({
              type: eventName
            }, detail));
          } else {
            console.warn("Received ".concat(eventName, " without details."));
          }
        });
      });
      [PI_SPEAKING, PI_STOPPED_SPEAKING, PI_FINISHED_SPEAKING].forEach(function (eventName) {
        _EventBus_js__WEBPACK_IMPORTED_MODULE_0__["default"].on(eventName, function () {
          actor.send(eventName);
        });
      });
    }
  }]);
  return EventModule;
}();


/***/ }),

/***/ "./src/LoggingModule.js":
/*!******************************!*\
  !*** ./src/LoggingModule.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   logger: () => (/* binding */ logger),
/* harmony export */   serializeStateValue: () => (/* binding */ serializeStateValue)
/* harmony export */ });
function serializeStateValue(stateValue) {
  if (typeof stateValue === "string") {
    return stateValue;
  }
  return Object.keys(stateValue).map(function (key) {
    return "".concat(key, ":").concat(serializeStateValue(stateValue[key]));
  }).join(",");
}
var DEBUG = false; // Consider using config and .env to set the DEBUG flag

var logger = {
  debug: function debug() {
    if (DEBUG) {
      var _console;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_console = console).log.apply(_console, ["DEBUG:"].concat(args));
    }
  },
  info: function info() {
    var _console2;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    (_console2 = console).log.apply(_console2, ["INFO:"].concat(args));
  },
  error: function error() {
    var _console3;
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    (_console3 = console).error.apply(_console3, ["ERROR:"].concat(args));
  }
};

/***/ }),

/***/ "./src/RequestInterceptor.js":
/*!***********************************!*\
  !*** ./src/RequestInterceptor.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setupInterceptors: () => (/* binding */ setupInterceptors)
/* harmony export */ });
/* harmony import */ var _ConfigModule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConfigModule.js */ "./src/ConfigModule.js");

var filesToRedirect = ["silero_vad.onnx", "ort-wasm-simd.wasm", "ort.min.js.map", "vad.worklet.bundle.min.js"];

// Function to construct the URL for local extension resources
function getExtensionResourceUrl(filename) {
  var web_accessible_resources_dir = "public";
  var filepath = web_accessible_resources_dir + "/" + filename;
  return chrome.runtime.getURL(filepath);
}

// Function to redirect specific XMLHttpRequests
function redirectXMLHttpRequest(open) {
  XMLHttpRequest.prototype.open = function (method, url, async, user, password) {
    var filename = url.split("/").pop();
    if (filename && filesToRedirect.includes(filename)) {
      // Check if running as a Chrome extension
      if (chrome.runtime && chrome.runtime.id) {
        arguments[1] = getExtensionResourceUrl(filename);
      } else {
        arguments[1] = "".concat(_ConfigModule_js__WEBPACK_IMPORTED_MODULE_0__.config.appServerUrl, "/").concat(filename);
      }
    }
    open.apply(this, arguments);
  };
}

// Function to redirect specific fetch requests
function redirectFetch(_fetch) {
  window.fetch = function (url, opts) {
    var filename = url.split("/").pop();
    if (filename && filesToRedirect.includes(filename)) {
      // Check if running as a Chrome extension
      if (chrome.runtime && chrome.runtime.id) {
        arguments[0] = getExtensionResourceUrl(filename);
      } else {
        arguments[0] = "".concat(_ConfigModule_js__WEBPACK_IMPORTED_MODULE_0__.config.appServerUrl, "/").concat(filename);
      }
    }
    return _fetch.apply(this, arguments);
  };
}

// Function to set up the interceptors
function setupInterceptors() {
  redirectXMLHttpRequest(XMLHttpRequest.prototype.open);
  redirectFetch(window.fetch);
}

/***/ }),

/***/ "./src/StateMachineService.js":
/*!************************************!*\
  !*** ./src/StateMachineService.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! xstate */ "./node_modules/xstate/es/interpreter.js");
/* harmony import */ var _state_machines_SayPiMachine_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./state-machines/SayPiMachine.ts */ "./src/state-machines/SayPiMachine.ts");
/* harmony import */ var _LoggingModule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LoggingModule.js */ "./src/LoggingModule.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }




/**
 * A singleton service that manages the state machine.
 */
var StateMachineService = /*#__PURE__*/_createClass(function StateMachineService() {
  _classCallCheck(this, StateMachineService);
  this.actor = (0,xstate__WEBPACK_IMPORTED_MODULE_2__.interpret)(_state_machines_SayPiMachine_ts__WEBPACK_IMPORTED_MODULE_0__.machine).onTransition(function (state) {
    if (state.changed) {
      var fromState = state.history ? (0,_LoggingModule_js__WEBPACK_IMPORTED_MODULE_1__.serializeStateValue)(state.history.value) : "N/A";
      var toState = (0,_LoggingModule_js__WEBPACK_IMPORTED_MODULE_1__.serializeStateValue)(state.value);
      _LoggingModule_js__WEBPACK_IMPORTED_MODULE_1__.logger.debug("Say, Pi Machine transitioned from ".concat(fromState, " to ").concat(toState, " with ").concat(state.event.type));
    }
  });
  this.actor.start();
}); // Singleton
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new StateMachineService());

/***/ }),

/***/ "./src/UserAgentModule.js":
/*!********************************!*\
  !*** ./src/UserAgentModule.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addDeviceFlags: () => (/* binding */ addDeviceFlags),
/* harmony export */   addUserAgentFlags: () => (/* binding */ addUserAgentFlags),
/* harmony export */   addViewFlags: () => (/* binding */ addViewFlags),
/* harmony export */   enterMobileMode: () => (/* binding */ enterMobileMode),
/* harmony export */   exitMobileMode: () => (/* binding */ exitMobileMode),
/* harmony export */   initMode: () => (/* binding */ initMode),
/* harmony export */   isMobileDevice: () => (/* binding */ isMobileDevice),
/* harmony export */   isMobileView: () => (/* binding */ isMobileView)
/* harmony export */ });
/* harmony import */ var _DOMModule_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DOMModule.ts */ "./src/DOMModule.ts");

function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.matchMedia("(max-width: 768px)").matches;
}

// this function determines whether to show the mobile view or not
function isMobileView() {
  var userViewPreference = null;
  try {
    userViewPreference = localStorage.getItem("userViewPreference");
  } catch (e) {
    console.warn("Could not access localStorage: ", e);
  }
  var prefersMobile = false;
  if (userViewPreference) {
    prefersMobile = userViewPreference === "mobile";
  }

  // Make sure isMobileDevice is defined or imported
  return isMobileDevice() && prefersMobile;
}
function exitMobileMode() {
  localStorage.setItem("userViewPreference", "desktop"); // Save preference

  var element = document.documentElement;
  element.classList.remove("mobile-view");
  element.classList.add("desktop-view");
  attachCallButton();
}
function enterMobileMode() {
  localStorage.setItem("userViewPreference", "mobile"); // Save preference

  var element = document.documentElement;
  element.classList.remove("desktop-view");
  element.classList.add("mobile-view");
  detachCallButton();
}
function attachCallButton() {
  // move the call button back into the text prompt container for desktop view
  var container = document.getElementById("saypi-prompt-controls-container");
  var callButton = document.getElementById("saypi-callButton");
  if (container && callButton) {
    (0,_DOMModule_ts__WEBPACK_IMPORTED_MODULE_0__.appendChild)(container, callButton, -1);
  }
}
function detachCallButton() {
  // remove the call button from the text prompt container while in mobile view
  var callButton = document.getElementById("saypi-callButton");
  if (callButton) {
    (0,_DOMModule_ts__WEBPACK_IMPORTED_MODULE_0__.appendChild)(document.body, callButton);
  }
}
function addUserAgentFlags() {
  var isFirefoxAndroid = /Firefox/.test(navigator.userAgent) && /Android/.test(navigator.userAgent);
  var element = document.documentElement;
  if (isFirefoxAndroid) {
    element.classList.add("firefox-android");
  }
  addDeviceFlags(element);
  addViewFlags(element);
}
function addDeviceFlags(element) {
  if (isMobileDevice()) {
    element.classList.add("mobile-device");
  }
}
function addViewFlags(element) {
  if (isMobileView()) {
    element.classList.remove("desktop-view");
    element.classList.add("mobile-view");
  } else {
    element.classList.remove("mobile-view");
    element.classList.add("desktop-view");
  }
}

/**
 * Perform initial setup of the UI based on the user's device and view preferences
 */
function initMode() {
  if (isMobileView()) {
    enterMobileMode();
  } else {
    exitMobileMode();
  }
}

/***/ }),

/***/ "./src/state-machines/AudioOutputMachine.js":
/*!**************************************************!*\
  !*** ./src/state-machines/AudioOutputMachine.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   audioOutputMachine: () => (/* binding */ audioOutputMachine)
/* harmony export */ });
/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xstate */ "./node_modules/xstate/es/Machine.js");
/* harmony import */ var _EventBus_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EventBus.js */ "./src/EventBus.js");


var audioOutputMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_1__.createMachine)({
  context: {
    autoplay: false
  },
  id: "audioOutput",
  initial: "idle",
  states: {
    idle: {
      on: {
        loadstart: {
          target: "loading"
        }
      }
    },
    loading: {
      on: {
        loadedmetadata: {
          target: "loaded"
        }
      }
    },
    loaded: {
      initial: "ready",
      states: {
        ready: {
          description: "Audio has loaded and is ready to start playing (further buffering may be required to reach the end).",
          entry: {
            type: "emitEvent",
            params: {
              eventName: "saypi:ready"
            }
          },
          on: {
            play: {
              target: "playing"
            }
          }
        },
        playing: {
          entry: {
            type: "emitEvent",
            params: {
              eventName: "saypi:piSpeaking"
            }
          },
          exit: [{
            type: "emitEvent",
            params: {
              eventName: "saypi:piStoppedSpeaking"
            }
          }],
          on: {
            pause: {
              target: "paused"
            },
            ended: {
              target: "ended"
            },
            canplaythrough: {
              internal: true
            }
          }
        },
        paused: {
          on: {
            play: {
              target: "playing"
            }
          }
        },
        ended: {
          entry: {
            type: "emitEvent",
            params: {
              eventName: "saypi:piFinishedSpeaking"
            }
          },
          on: {
            seeked: {
              target: "ready",
              description: "An ended track is seeked back to earlier in the track."
            }
          }
        }
      },
      on: {
        emptied: {
          target: "idle"
        }
      }
    }
  },
  predictableActionArguments: true,
  preserveActionOrder: true
}, {
  actions: {
    emitEvent: function emitEvent(context, event, _ref) {
      var action = _ref.action;
      _EventBus_js__WEBPACK_IMPORTED_MODULE_0__["default"].emit(action.params.eventName);
    }
  },
  guards: {},
  services: {},
  delays: {}
});

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!****************************!*\
  !*** ./src/saypi.index.js ***!
  \****************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _AudioModule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AudioModule.js */ "./src/AudioModule.js");
/* harmony import */ var _ButtonModule_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ButtonModule.js */ "./src/ButtonModule.js");
/* harmony import */ var _EventModule_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventModule.js */ "./src/EventModule.js");
/* harmony import */ var _UserAgentModule_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UserAgentModule.js */ "./src/UserAgentModule.js");
/* harmony import */ var _SubmitErrorHandler_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SubmitErrorHandler.ts */ "./src/SubmitErrorHandler.ts");
/* harmony import */ var _ConfigModule_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ConfigModule.js */ "./src/ConfigModule.js");
/* harmony import */ var _styles_common_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./styles/common.scss */ "./src/styles/common.scss");
/* harmony import */ var _styles_desktop_scss__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./styles/desktop.scss */ "./src/styles/desktop.scss");
/* harmony import */ var _styles_mobile_scss__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./styles/mobile.scss */ "./src/styles/mobile.scss");
/* harmony import */ var _styles_rectangles_css__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./styles/rectangles.css */ "./src/styles/rectangles.css");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return { value: void 0, done: !0 }; } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable || "" === iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } throw new TypeError(_typeof(iterable) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }










_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
  "use strict";

  var startAudioModule, callback, config, observer, annotateDOM, addIdPromptAncestor, addIdSubmitButton, addIdFooter, addIdAudioControls, addIdAudioOutputButton, addTalkButton;
  return _regeneratorRuntime().wrap(function _callee$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        addTalkButton = function _addTalkButton(container) {
          // Create a containing div
          var panel = document.createElement("div");
          panel.id = "saypi-panel";
          if (container) {
            container.appendChild(panel);
          } else {
            document.body.appendChild(panel);
          }

          // talk "button" is no longer a button, but a div
          var button = document.createElement("div");
          button.id = "saypi-talkButton";
          var classNames = "relative flex mt-1 mb-1 rounded-full px-2 py-3 text-center bg-cream-550 hover:bg-cream-650 hover:text-brand-green-700 text-muted";
          button.classList.add(classNames.split(" "));

          // Enable autosubmit by default
          button.dataset.autosubmit = "true";
          button.classList.add("autoSubmit");
          panel.appendChild(button);
          _ButtonModule_js__WEBPACK_IMPORTED_MODULE_1__.buttonModule.addTalkIcon(button);

          // Call the function to inject the script after the button has been added
          startAudioModule();
        };
        addIdAudioOutputButton = function _addIdAudioOutputButt() {
          // audio button is the last button element in the audio controls container
          var audioButton = document.querySelector("#saypi-audio-controls > div > div.relative.flex.items-center.justify-end.self-end.p-2 > button");
          if (!audioButton) {
            return false;
          } else {
            audioButton.id = "saypi-audio-output-button";
          }
          return true;
        };
        addIdAudioControls = function _addIdAudioControls() {
          // Find all audio elements on the page
          var audioElements = document.querySelectorAll("audio");
          var found = false; // default to not found

          audioElements.forEach(function (audio) {
            var nextDiv = audio.nextElementSibling;

            // If we've already found a div, we can skip further iterations
            if (found) return;

            // Check if the preceding element is a div
            if (nextDiv && nextDiv.tagName.toLowerCase() === "div") {
              // Assign an ID to the div
              nextDiv.id = "saypi-audio-controls";
              found = true; // set to found
            }
          });

          return found;
        };
        addIdFooter = function _addIdFooter() {
          // Find all audio elements on the page
          var audioElements = document.querySelectorAll("audio");
          var found = false; // default to not found

          audioElements.forEach(function (audio) {
            var precedingDiv = audio.previousElementSibling;

            // If we've already found a div, we can skip further iterations
            if (found) return;

            // Check if the preceding element is a div
            if (precedingDiv && precedingDiv.tagName.toLowerCase() === "div") {
              // Assign an ID to the div
              precedingDiv.lastElementChild.id = "saypi-footer";
              found = true; // set to found
            }
          });

          return found;
        };
        addIdSubmitButton = function _addIdSubmitButton(container) {
          var submitButtons = container.querySelectorAll("button[type=button]");
          if (submitButtons.length > 0) {
            var lastSubmitButton = submitButtons[submitButtons.length - 1];
            lastSubmitButton.id = "saypi-submitButton";
          }
        };
        addIdPromptAncestor = function _addIdPromptAncestor(container) {
          // climb up the DOM tree until we find a div with class 'w-full'
          var parent = container.parentElement;
          while (parent) {
            if (parent.classList.contains("w-full")) {
              parent.id = "saypi-prompt-ancestor";
              return true;
            }
            parent = parent.parentElement;
          }
          return false;
        };
        annotateDOM = function _annotateDOM(prompt) {
          // Add id attributes to important elements
          prompt.id = "saypi-prompt";
          prompt.parentElement.classList.add("saypi-prompt-container");
          var foundFooter = addIdFooter();
          var foundAudioControls = addIdAudioControls();
          var promptControlsContainer = prompt.parentElement.parentElement;
          promptControlsContainer.id = "saypi-prompt-controls-container";
          var foundPromptAncestor = addIdPromptAncestor(promptControlsContainer);
          var foundAudioOutputButton = addIdAudioOutputButton();
          addIdSubmitButton(promptControlsContainer);
          addTalkButton(document.body);
          _ButtonModule_js__WEBPACK_IMPORTED_MODULE_1__.buttonModule.createCallButton(promptControlsContainer, -1);
          _ButtonModule_js__WEBPACK_IMPORTED_MODULE_1__.buttonModule.createEnterButton();
          _ButtonModule_js__WEBPACK_IMPORTED_MODULE_1__.buttonModule.createExitButton();
          (0,_UserAgentModule_js__WEBPACK_IMPORTED_MODULE_3__.initMode)();
        };
        startAudioModule = function _startAudioModule() {
          var audioModule = new _AudioModule_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
          audioModule.start();
        };
        (0,_UserAgentModule_js__WEBPACK_IMPORTED_MODULE_3__.addUserAgentFlags)();
        _EventModule_js__WEBPACK_IMPORTED_MODULE_2__["default"].init();

        // Create a MutationObserver to listen for changes to the DOM
        // textareas are added to the DOM after the page loads
        callback = function callback(mutationsList, observer) {
          var _iterator = _createForOfIteratorHelper(mutationsList),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var mutation = _step.value;
              if (mutation.type === "childList") {
                // Iterate through added nodes
                mutation.addedNodes.forEach(function (node) {
                  // Check if added node is a textarea with 'enterkeyhint' attribute
                  if (node.nodeName === "TEXTAREA" && node.hasAttribute("enterkeyhint")) {
                    // Stop observing to avoid any potential infinite loops
                    observer.disconnect();

                    // Do something with the textarea, like add an event listener
                    annotateDOM(node);
                    return;
                  }

                  // Check if added node contains a textarea with 'enterkeyhint' attribute
                  if (node.querySelectorAll) {
                    var textareas = node.querySelectorAll("textarea[enterkeyhint]");
                    if (textareas.length > 0) {
                      // Stop observing
                      observer.disconnect();

                      // Do something with the first textarea that has 'enterkeyhint'
                      annotateDOM(textareas[0]);
                      _SubmitErrorHandler_ts__WEBPACK_IMPORTED_MODULE_4__.submitErrorHandler.initAudioOutputListener();
                      _SubmitErrorHandler_ts__WEBPACK_IMPORTED_MODULE_4__.submitErrorHandler.checkForRestorePoint();
                      return;
                    }
                  }
                });
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }; // Options for the observer (which mutations to observe)
        config = {
          attributes: false,
          childList: true,
          subtree: true
        }; // Create an observer instance linked to the callback function
        observer = new MutationObserver(callback); // Start observing the target node for configured mutations
        observer.observe(document.body, config);
        // Start observing the entire document for changes to child nodes and subtree
        observer.observe(document, {
          childList: true,
          subtree: true
        });
      case 15:
      case "end":
        return _context.stop();
    }
  }, _callee);
}))();
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDRGQUE0RixNQUFNLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxNQUFNLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxNQUFNLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxNQUFNLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxNQUFNLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxNQUFNLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLEtBQUssWUFBWSxhQUFhLE9BQU8sWUFBWSxNQUFNLE1BQU0sWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssS0FBSyxZQUFZLGFBQWEsT0FBTyxZQUFZLE1BQU0sS0FBSyxLQUFLLE9BQU8sTUFBTSxLQUFLLEtBQUssT0FBTyxN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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx1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QUFVLENBQUMsQ0FBQzs7c0JBRXJCO3NCQUNBNUMsV0FBVyxDQUFDNkMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO3NCQUN6QnphLHNFQUFrQixDQUFDMGEsdUJBQXVCLENBQUMsQ0FBQztzQkFDNUMxYSxzRUFBa0IsQ0FBQzJhLG9CQUFvQixDQUFDLENBQUM7c0JBQ3pDO29CQUNGO2tCQUNGO2dCQUNGLENBQUMsQ0FBQztjQUNKO1lBQ0Y7VUFBQyxTQUFBM1gsR0FBQTtZQUFBVCxTQUFBLENBQUEvQyxDQUFBLENBQUF3RCxHQUFBO1VBQUE7WUFBQVQsU0FBQSxDQUFBVSxDQUFBO1VBQUE7UUFDSCxDQUFDLEVBRUQ7UUFDTWYsTUFBTSxHQUFHO1VBQUVDLFVBQVUsRUFBRSxLQUFLO1VBQUV5WSxTQUFTLEVBQUUsSUFBSTtVQUFFQyxPQUFPLEVBQUU7UUFBSyxDQUFDLEVBRXBFO1FBQ012WSxRQUFRLEdBQUcsSUFBSVksZ0JBQWdCLENBQUNwQyxRQUFRLENBQUMsRUFFL0M7UUFDQXdCLFFBQVEsQ0FBQ2EsT0FBTyxDQUFDOUcsUUFBUSxDQUFDb0ksSUFBSSxFQUFFdkMsTUFBTSxDQUFDO1FBZ0l2QztRQUNBSSxRQUFRLENBQUNhLE9BQU8sQ0FBQzlHLFFBQVEsRUFBRTtVQUFFdWUsU0FBUyxFQUFFLElBQUk7VUFBRUMsT0FBTyxFQUFFO1FBQUssQ0FBQyxDQUFDO01BQUM7TUFBQTtRQUFBLE9BQUF6QyxRQUFBLENBQUFqRCxJQUFBO0lBQUE7RUFBQSxHQUFBdUMsT0FBQTtBQUFBLENBQ2hFLEdBQUUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvQHJpY2t5MDEyMy92YWQtd2ViL2Rpc3QvX2NvbW1vbi9mcmFtZS1wcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvZGlzdC9fY29tbW9uL2luZGV4LmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvQHJpY2t5MDEyMy92YWQtd2ViL2Rpc3QvX2NvbW1vbi9sb2dnaW5nLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvQHJpY2t5MDEyMy92YWQtd2ViL2Rpc3QvX2NvbW1vbi9tZXNzYWdlcy5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL0ByaWNreTAxMjMvdmFkLXdlYi9kaXN0L19jb21tb24vbW9kZWxzLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvQHJpY2t5MDEyMy92YWQtd2ViL2Rpc3QvX2NvbW1vbi9ub24tcmVhbC10aW1lLXZhZC5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL0ByaWNreTAxMjMvdmFkLXdlYi9kaXN0L19jb21tb24vcmVzYW1wbGVyLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvQHJpY2t5MDEyMy92YWQtd2ViL2Rpc3QvX2NvbW1vbi91dGlscy5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL0ByaWNreTAxMjMvdmFkLXdlYi9kaXN0L2Fzc2V0LXBhdGguanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL0ByaWNreTAxMjMvdmFkLXdlYi9kaXN0L21vZGVsLWZldGNoZXIuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvZGlzdC9yZWFsLXRpbWUtdmFkLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvQHJpY2t5MDEyMy92YWQtd2ViL2Rpc3QvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL3NyYy9zdHlsZXMvcmVjdGFuZ2xlcy5jc3MiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL3NyYy9zdHlsZXMvY29tbW9uLnNjc3MiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL3NyYy9zdHlsZXMvZGVza3RvcC5zY3NzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9zcmMvc3R5bGVzL21vYmlsZS5zY3NzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9vcnQubWluLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9zcmMvaWNvbnMvY2FsbC5zdmciLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL3NyYy9pY29ucy9leGl0LnN2ZyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vc3JjL2ljb25zL2hhbmd1cC5zdmciLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL3NyYy9pY29ucy9tYXhpbWl6ZS5zdmciLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL3NyYy9pY29ucy9tdXRlZF9taWNyb3Bob25lLnN2ZyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vc3JjL2ljb25zL3JlY3RhbmdsZXMuc3ZnIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9zcmMvaWNvbnMvd2F2ZWZvcm0uc3ZnIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9zcmMvc3R5bGVzL3JlY3RhbmdsZXMuY3NzPzk3NDUiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL3NyYy9zdHlsZXMvY29tbW9uLnNjc3M/MDRjMyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vc3JjL3N0eWxlcy9kZXNrdG9wLnNjc3M/ZGFkNyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vc3JjL3N0eWxlcy9tb2JpbGUuc2Nzcz8xYzgzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL3NyYy9BdWRpb0VuY29kZXIudHMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL3NyYy9ET01Nb2R1bGUudHMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL3NyYy9TdWJtaXRFcnJvckhhbmRsZXIudHMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL3NyYy9UcmFuc2NyaXB0aW9uTW9kdWxlLnRzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9zcmMvV2F2RW5jb2Rlci50cyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vc3JjL3N0YXRlLW1hY2hpbmVzL0F1ZGlvSW5wdXRNYWNoaW5lLnRzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9zcmMvc3RhdGUtbWFjaGluZXMvU2F5UGlNYWNoaW5lLnRzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMveHN0YXRlL2VzL0FjdG9yLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMveHN0YXRlL2VzL01hY2hpbmUuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZXMvU3RhdGUuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZXMvU3RhdGVOb2RlLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMveHN0YXRlL2VzL192aXJ0dWFsL190c2xpYi5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy9hY3Rpb25UeXBlcy5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy9hY3Rpb25zLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMveHN0YXRlL2VzL2JlaGF2aW9ycy5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZXMvZGV2VG9vbHMuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZXMvZW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZXMvaW50ZXJwcmV0ZXIuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZXMvaW52b2tlVXRpbHMuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZXMvbWFwU3RhdGUuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZXMvbWF0Y2guanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZXMvcmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZXMvc2NoZWR1bGVyLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMveHN0YXRlL2VzL3NjaGVtYS5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy9zZXJ2aWNlU2NvcGUuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZXMvc3RhdGVVdGlscy5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy90eXBlcy5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy91dGlscy5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vc3JjL0FuaW1hdGlvbk1vZHVsZS5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vc3JjL0F1ZGlvTW9kdWxlLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9zcmMvQnV0dG9uTW9kdWxlLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9zcmMvQ29uZmlnTW9kdWxlLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9zcmMvRXZlbnRCdXMuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL3NyYy9FdmVudE1vZHVsZS5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vc3JjL0xvZ2dpbmdNb2R1bGUuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL3NyYy9SZXF1ZXN0SW50ZXJjZXB0b3IuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL3NyYy9TdGF0ZU1hY2hpbmVTZXJ2aWNlLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9zcmMvVXNlckFnZW50TW9kdWxlLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9zcmMvc3RhdGUtbWFjaGluZXMvQXVkaW9PdXRwdXRNYWNoaW5lLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0L3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0L3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0L3dlYnBhY2svcnVudGltZS9ub25jZSIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vc3JjL3NheXBpLmluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcblNvbWUgb2YgdGhpcyBjb2RlLCB0b2dldGhlciB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMgZm91bmQgaW4gaW5kZXgudHMsXG53ZXJlIHRha2VuIChvciB0b29rIGluc3BpcmF0aW9uKSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zbmFrZXJzNC9zaWxlcm8tdmFkXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GcmFtZVByb2Nlc3NvciA9IGV4cG9ydHMudmFsaWRhdGVPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0RnJhbWVQcm9jZXNzb3JPcHRpb25zID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzXCIpO1xuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IFJFQ09NTUVOREVEX0ZSQU1FX1NBTVBMRVMgPSBbNTEyLCAxMDI0LCAxNTM2XTtcbmV4cG9ydHMuZGVmYXVsdEZyYW1lUHJvY2Vzc29yT3B0aW9ucyA9IHtcbiAgICBwb3NpdGl2ZVNwZWVjaFRocmVzaG9sZDogMC41LFxuICAgIG5lZ2F0aXZlU3BlZWNoVGhyZXNob2xkOiAwLjUgLSAwLjE1LFxuICAgIHByZVNwZWVjaFBhZEZyYW1lczogMSxcbiAgICByZWRlbXB0aW9uRnJhbWVzOiA4LFxuICAgIGZyYW1lU2FtcGxlczogMTUzNixcbiAgICBtaW5TcGVlY2hGcmFtZXM6IDMsXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIVJFQ09NTUVOREVEX0ZSQU1FX1NBTVBMRVMuaW5jbHVkZXMob3B0aW9ucy5mcmFtZVNhbXBsZXMpKSB7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2cud2FybihcIllvdSBhcmUgdXNpbmcgYW4gdW51c3VhbCBmcmFtZSBzaXplXCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wb3NpdGl2ZVNwZWVjaFRocmVzaG9sZCA8IDAgfHxcbiAgICAgICAgb3B0aW9ucy5uZWdhdGl2ZVNwZWVjaFRocmVzaG9sZCA+IDEpIHtcbiAgICAgICAgbG9nZ2luZ18xLmxvZy5lcnJvcihcInBvc3RpdmVTcGVlY2hUaHJlc2hvbGQgc2hvdWxkIGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVwiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubmVnYXRpdmVTcGVlY2hUaHJlc2hvbGQgPCAwIHx8XG4gICAgICAgIG9wdGlvbnMubmVnYXRpdmVTcGVlY2hUaHJlc2hvbGQgPiBvcHRpb25zLnBvc2l0aXZlU3BlZWNoVGhyZXNob2xkKSB7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2cuZXJyb3IoXCJuZWdhdGl2ZVNwZWVjaFRocmVzaG9sZCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCBwb3N0aXZlU3BlZWNoVGhyZXNob2xkXCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wcmVTcGVlY2hQYWRGcmFtZXMgPCAwKSB7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2cuZXJyb3IoXCJwcmVTcGVlY2hQYWRGcmFtZXMgc2hvdWxkIGJlIHBvc2l0aXZlXCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZWRlbXB0aW9uRnJhbWVzIDwgMCkge1xuICAgICAgICBsb2dnaW5nXzEubG9nLmVycm9yKFwicHJlU3BlZWNoUGFkRnJhbWVzIHNob3VsZCBiZSBwb3NpdGl2ZVwiKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlT3B0aW9ucyA9IHZhbGlkYXRlT3B0aW9ucztcbmNvbnN0IGNvbmNhdEFycmF5cyA9IChhcnJheXMpID0+IHtcbiAgICBjb25zdCBzaXplcyA9IGFycmF5cy5yZWR1Y2UoKG91dCwgbmV4dCkgPT4ge1xuICAgICAgICBvdXQucHVzaChvdXQuYXQoLTEpICsgbmV4dC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0sIFswXSk7XG4gICAgY29uc3Qgb3V0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHNpemVzLmF0KC0xKSk7XG4gICAgYXJyYXlzLmZvckVhY2goKGFyciwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcGxhY2UgPSBzaXplc1tpbmRleF07XG4gICAgICAgIG91dEFycmF5LnNldChhcnIsIHBsYWNlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0QXJyYXk7XG59O1xuY2xhc3MgRnJhbWVQcm9jZXNzb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsUHJvY2Vzc0Z1bmMsIG1vZGVsUmVzZXRGdW5jLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubW9kZWxQcm9jZXNzRnVuYyA9IG1vZGVsUHJvY2Vzc0Z1bmM7XG4gICAgICAgIHRoaXMubW9kZWxSZXNldEZ1bmMgPSBtb2RlbFJlc2V0RnVuYztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5zcGVha2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlZGVtcHRpb25Db3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXNldCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3BlYWtpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9CdWZmZXIgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubW9kZWxSZXNldEZ1bmMoKTtcbiAgICAgICAgICAgIHRoaXMucmVkZW1wdGlvbkNvdW50ZXIgPSAwO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBhdXNlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXN1bWUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5kU2VnbWVudCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvQnVmZmVyID0gdGhpcy5hdWRpb0J1ZmZlcjtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9CdWZmZXIgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHNwZWFraW5nID0gdGhpcy5zcGVha2luZztcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IHNwZWVjaEZyYW1lQ291bnQgPSBhdWRpb0J1ZmZlci5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyAraXRlbS5pc1NwZWVjaDtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgaWYgKHNwZWFraW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWVjaEZyYW1lQ291bnQgPj0gdGhpcy5vcHRpb25zLm1pblNwZWVjaEZyYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdWRpbyA9IGNvbmNhdEFycmF5cyhhdWRpb0J1ZmZlci5tYXAoKGl0ZW0pID0+IGl0ZW0uZnJhbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbXNnOiBtZXNzYWdlc18xLk1lc3NhZ2UuU3BlZWNoRW5kLCBhdWRpbyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbXNnOiBtZXNzYWdlc18xLk1lc3NhZ2UuVkFETWlzZmlyZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9jZXNzID0gYXN5bmMgKGZyYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvYnMgPSBhd2FpdCB0aGlzLm1vZGVsUHJvY2Vzc0Z1bmMoZnJhbWUpO1xuICAgICAgICAgICAgdGhpcy5hdWRpb0J1ZmZlci5wdXNoKHtcbiAgICAgICAgICAgICAgICBmcmFtZSxcbiAgICAgICAgICAgICAgICBpc1NwZWVjaDogcHJvYnMuaXNTcGVlY2ggPj0gdGhpcy5vcHRpb25zLnBvc2l0aXZlU3BlZWNoVGhyZXNob2xkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocHJvYnMuaXNTcGVlY2ggPj0gdGhpcy5vcHRpb25zLnBvc2l0aXZlU3BlZWNoVGhyZXNob2xkICYmXG4gICAgICAgICAgICAgICAgdGhpcy5yZWRlbXB0aW9uQ291bnRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVkZW1wdGlvbkNvdW50ZXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2JzLmlzU3BlZWNoID49IHRoaXMub3B0aW9ucy5wb3NpdGl2ZVNwZWVjaFRocmVzaG9sZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLnNwZWFraW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVha2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcHJvYnMsIG1zZzogbWVzc2FnZXNfMS5NZXNzYWdlLlNwZWVjaFN0YXJ0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvYnMuaXNTcGVlY2ggPCB0aGlzLm9wdGlvbnMubmVnYXRpdmVTcGVlY2hUaHJlc2hvbGQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWFraW5nICYmXG4gICAgICAgICAgICAgICAgKyt0aGlzLnJlZGVtcHRpb25Db3VudGVyID49IHRoaXMub3B0aW9ucy5yZWRlbXB0aW9uRnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRlbXB0aW9uQ291bnRlciA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVha2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF1ZGlvQnVmZmVyID0gdGhpcy5hdWRpb0J1ZmZlcjtcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvQnVmZmVyID0gW107XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BlZWNoRnJhbWVDb3VudCA9IGF1ZGlvQnVmZmVyLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyAraXRlbS5pc1NwZWVjaDtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoc3BlZWNoRnJhbWVDb3VudCA+PSB0aGlzLm9wdGlvbnMubWluU3BlZWNoRnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF1ZGlvID0gY29uY2F0QXJyYXlzKGF1ZGlvQnVmZmVyLm1hcCgoaXRlbSkgPT4gaXRlbS5mcmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBwcm9icywgbXNnOiBtZXNzYWdlc18xLk1lc3NhZ2UuU3BlZWNoRW5kLCBhdWRpbyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcHJvYnMsIG1zZzogbWVzc2FnZXNfMS5NZXNzYWdlLlZBRE1pc2ZpcmUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3BlYWtpbmcpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5hdWRpb0J1ZmZlci5sZW5ndGggPiB0aGlzLm9wdGlvbnMucHJlU3BlZWNoUGFkRnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9CdWZmZXIuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBwcm9icyB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmF1ZGlvQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG59XG5leHBvcnRzLkZyYW1lUHJvY2Vzc29yID0gRnJhbWVQcm9jZXNzb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcmFtZS1wcm9jZXNzb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnV0aWxzID0gdm9pZCAwO1xuY29uc3QgX3V0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmV4cG9ydHMudXRpbHMgPSB7XG4gICAgbWluRnJhbWVzRm9yVGFyZ2V0TVM6IF91dGlscy5taW5GcmFtZXNGb3JUYXJnZXRNUyxcbiAgICBhcnJheUJ1ZmZlclRvQmFzZTY0OiBfdXRpbHMuYXJyYXlCdWZmZXJUb0Jhc2U2NCxcbiAgICBlbmNvZGVXQVY6IF91dGlscy5lbmNvZGVXQVYsXG59O1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL25vbi1yZWFsLXRpbWUtdmFkXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mcmFtZS1wcm9jZXNzb3JcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21lc3NhZ2VzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9sb2dnaW5nXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Jlc2FtcGxlclwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9nID0gZXhwb3J0cy5MT0dfUFJFRklYID0gdm9pZCAwO1xuZXhwb3J0cy5MT0dfUFJFRklYID0gXCJbVkFEXVwiO1xuY29uc3QgbGV2ZWxzID0gW1wiZXJyb3JcIiwgXCJkZWJ1Z1wiLCBcIndhcm5cIl07XG5mdW5jdGlvbiBnZXRMb2cobGV2ZWwpIHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc29sZVtsZXZlbF0oZXhwb3J0cy5MT0dfUFJFRklYLCAuLi5hcmdzKTtcbiAgICB9O1xufVxuY29uc3QgX2xvZyA9IGxldmVscy5yZWR1Y2UoKGFjYywgbGV2ZWwpID0+IHtcbiAgICBhY2NbbGV2ZWxdID0gZ2V0TG9nKGxldmVsKTtcbiAgICByZXR1cm4gYWNjO1xufSwge30pO1xuZXhwb3J0cy5sb2cgPSBfbG9nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVzc2FnZSA9IHZvaWQgMDtcbnZhciBNZXNzYWdlO1xuKGZ1bmN0aW9uIChNZXNzYWdlKSB7XG4gICAgTWVzc2FnZVtcIkF1ZGlvRnJhbWVcIl0gPSBcIkFVRElPX0ZSQU1FXCI7XG4gICAgTWVzc2FnZVtcIlNwZWVjaFN0YXJ0XCJdID0gXCJTUEVFQ0hfU1RBUlRcIjtcbiAgICBNZXNzYWdlW1wiVkFETWlzZmlyZVwiXSA9IFwiVkFEX01JU0ZJUkVcIjtcbiAgICBNZXNzYWdlW1wiU3BlZWNoRW5kXCJdID0gXCJTUEVFQ0hfRU5EXCI7XG59KShNZXNzYWdlID0gZXhwb3J0cy5NZXNzYWdlIHx8IChleHBvcnRzLk1lc3NhZ2UgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpbGVybyA9IHZvaWQgMDtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jbGFzcyBTaWxlcm8ge1xuICAgIGNvbnN0cnVjdG9yKG9ydCwgbW9kZWxGZXRjaGVyKSB7XG4gICAgICAgIHRoaXMub3J0ID0gb3J0O1xuICAgICAgICB0aGlzLm1vZGVsRmV0Y2hlciA9IG1vZGVsRmV0Y2hlcjtcbiAgICAgICAgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZy5kZWJ1ZyhcImluaXRpYWxpemluZyB2YWRcIik7XG4gICAgICAgICAgICBjb25zdCBtb2RlbEFycmF5QnVmZmVyID0gYXdhaXQgdGhpcy5tb2RlbEZldGNoZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3Nlc3Npb24gPSBhd2FpdCB0aGlzLm9ydC5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZShtb2RlbEFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3NyID0gbmV3IHRoaXMub3J0LlRlbnNvcihcImludDY0XCIsIFsxNjAwMG5dKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRfc3RhdGUoKTtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2cuZGVidWcoXCJ2YWQgaXMgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVzZXRfc3RhdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB6ZXJvZXMgPSBBcnJheSgyICogNjQpLmZpbGwoMCk7XG4gICAgICAgICAgICB0aGlzLl9oID0gbmV3IHRoaXMub3J0LlRlbnNvcihcImZsb2F0MzJcIiwgemVyb2VzLCBbMiwgMSwgNjRdKTtcbiAgICAgICAgICAgIHRoaXMuX2MgPSBuZXcgdGhpcy5vcnQuVGVuc29yKFwiZmxvYXQzMlwiLCB6ZXJvZXMsIFsyLCAxLCA2NF0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb2Nlc3MgPSBhc3luYyAoYXVkaW9GcmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdCA9IG5ldyB0aGlzLm9ydC5UZW5zb3IoXCJmbG9hdDMyXCIsIGF1ZGlvRnJhbWUsIFsxLCBhdWRpb0ZyYW1lLmxlbmd0aF0pO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0ge1xuICAgICAgICAgICAgICAgIGlucHV0OiB0LFxuICAgICAgICAgICAgICAgIGg6IHRoaXMuX2gsXG4gICAgICAgICAgICAgICAgYzogdGhpcy5fYyxcbiAgICAgICAgICAgICAgICBzcjogdGhpcy5fc3IsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0gYXdhaXQgdGhpcy5fc2Vzc2lvbi5ydW4oaW5wdXRzKTtcbiAgICAgICAgICAgIHRoaXMuX2ggPSBvdXQuaG47XG4gICAgICAgICAgICB0aGlzLl9jID0gb3V0LmNuO1xuICAgICAgICAgICAgY29uc3QgW2lzU3BlZWNoXSA9IG91dC5vdXRwdXQuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IG5vdFNwZWVjaCA9IDEgLSBpc1NwZWVjaDtcbiAgICAgICAgICAgIHJldHVybiB7IG5vdFNwZWVjaCwgaXNTcGVlY2ggfTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlNpbGVybyA9IFNpbGVybztcbl9hID0gU2lsZXJvO1xuU2lsZXJvLm5ldyA9IGFzeW5jIChvcnQsIG1vZGVsRmV0Y2hlcikgPT4ge1xuICAgIGNvbnN0IG1vZGVsID0gbmV3IFNpbGVybyhvcnQsIG1vZGVsRmV0Y2hlcik7XG4gICAgYXdhaXQgbW9kZWwuaW5pdCgpO1xuICAgIHJldHVybiBtb2RlbDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBsYXRmb3JtQWdub3N0aWNOb25SZWFsVGltZVZBRCA9IGV4cG9ydHMuZGVmYXVsdE5vblJlYWxUaW1lVkFET3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IGZyYW1lX3Byb2Nlc3Nvcl8xID0gcmVxdWlyZShcIi4vZnJhbWUtcHJvY2Vzc29yXCIpO1xuY29uc3QgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzXCIpO1xuY29uc3QgbW9kZWxzXzEgPSByZXF1aXJlKFwiLi9tb2RlbHNcIik7XG5jb25zdCByZXNhbXBsZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc2FtcGxlclwiKTtcbmV4cG9ydHMuZGVmYXVsdE5vblJlYWxUaW1lVkFET3B0aW9ucyA9IHtcbiAgICAuLi5mcmFtZV9wcm9jZXNzb3JfMS5kZWZhdWx0RnJhbWVQcm9jZXNzb3JPcHRpb25zLFxufTtcbmNsYXNzIFBsYXRmb3JtQWdub3N0aWNOb25SZWFsVGltZVZBRCB7XG4gICAgc3RhdGljIGFzeW5jIF9uZXcobW9kZWxGZXRjaGVyLCBvcnQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB2YWQgPSBuZXcgdGhpcyhtb2RlbEZldGNoZXIsIG9ydCwge1xuICAgICAgICAgICAgLi4uZXhwb3J0cy5kZWZhdWx0Tm9uUmVhbFRpbWVWQURPcHRpb25zLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHZhZC5pbml0KCk7XG4gICAgICAgIHJldHVybiB2YWQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1vZGVsRmV0Y2hlciwgb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubW9kZWxGZXRjaGVyID0gbW9kZWxGZXRjaGVyO1xuICAgICAgICB0aGlzLm9ydCA9IG9ydDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBhd2FpdCBtb2RlbHNfMS5TaWxlcm8ubmV3KHRoaXMub3J0LCB0aGlzLm1vZGVsRmV0Y2hlcik7XG4gICAgICAgICAgICB0aGlzLmZyYW1lUHJvY2Vzc29yID0gbmV3IGZyYW1lX3Byb2Nlc3Nvcl8xLkZyYW1lUHJvY2Vzc29yKG1vZGVsLnByb2Nlc3MsIG1vZGVsLnJlc2V0X3N0YXRlLCB7XG4gICAgICAgICAgICAgICAgZnJhbWVTYW1wbGVzOiB0aGlzLm9wdGlvbnMuZnJhbWVTYW1wbGVzLFxuICAgICAgICAgICAgICAgIHBvc2l0aXZlU3BlZWNoVGhyZXNob2xkOiB0aGlzLm9wdGlvbnMucG9zaXRpdmVTcGVlY2hUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgbmVnYXRpdmVTcGVlY2hUaHJlc2hvbGQ6IHRoaXMub3B0aW9ucy5uZWdhdGl2ZVNwZWVjaFRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICByZWRlbXB0aW9uRnJhbWVzOiB0aGlzLm9wdGlvbnMucmVkZW1wdGlvbkZyYW1lcyxcbiAgICAgICAgICAgICAgICBwcmVTcGVlY2hQYWRGcmFtZXM6IHRoaXMub3B0aW9ucy5wcmVTcGVlY2hQYWRGcmFtZXMsXG4gICAgICAgICAgICAgICAgbWluU3BlZWNoRnJhbWVzOiB0aGlzLm9wdGlvbnMubWluU3BlZWNoRnJhbWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmZyYW1lUHJvY2Vzc29yLnJlc3VtZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1biA9IGFzeW5jIGZ1bmN0aW9uKiAoaW5wdXRBdWRpbywgc2FtcGxlUmF0ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzYW1wbGVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBuYXRpdmVTYW1wbGVSYXRlOiBzYW1wbGVSYXRlLFxuICAgICAgICAgICAgICAgIHRhcmdldFNhbXBsZVJhdGU6IDE2MDAwLFxuICAgICAgICAgICAgICAgIHRhcmdldEZyYW1lU2l6ZTogdGhpcy5vcHRpb25zLmZyYW1lU2FtcGxlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXNhbXBsZXIgPSBuZXcgcmVzYW1wbGVyXzEuUmVzYW1wbGVyKHJlc2FtcGxlck9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgZnJhbWVzID0gcmVzYW1wbGVyLnByb2Nlc3MoaW5wdXRBdWRpbyk7XG4gICAgICAgICAgICBsZXQgc3RhcnQsIGVuZDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBbLi4uQXJyYXkoZnJhbWVzLmxlbmd0aCldLmtleXMoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGYgPSBmcmFtZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgeyBtc2csIGF1ZGlvIH0gPSBhd2FpdCB0aGlzLmZyYW1lUHJvY2Vzc29yLnByb2Nlc3MoZik7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChtc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLk1lc3NhZ2UuU3BlZWNoU3RhcnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IChpICogdGhpcy5vcHRpb25zLmZyYW1lU2FtcGxlcykgLyAxNjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuTWVzc2FnZS5TcGVlY2hFbmQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSAoKGkgKyAxKSAqIHRoaXMub3B0aW9ucy5mcmFtZVNhbXBsZXMpIC8gMTY7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB7IGF1ZGlvLCBzdGFydCwgZW5kIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgbXNnLCBhdWRpbyB9ID0gdGhpcy5mcmFtZVByb2Nlc3Nvci5lbmRTZWdtZW50KCk7XG4gICAgICAgICAgICBpZiAobXNnID09IG1lc3NhZ2VzXzEuTWVzc2FnZS5TcGVlY2hFbmQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvLFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IChmcmFtZXMubGVuZ3RoICogdGhpcy5vcHRpb25zLmZyYW1lU2FtcGxlcykgLyAxNixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAoMCwgZnJhbWVfcHJvY2Vzc29yXzEudmFsaWRhdGVPcHRpb25zKShvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLlBsYXRmb3JtQWdub3N0aWNOb25SZWFsVGltZVZBRCA9IFBsYXRmb3JtQWdub3N0aWNOb25SZWFsVGltZVZBRDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vbi1yZWFsLXRpbWUtdmFkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXNhbXBsZXIgPSB2b2lkIDA7XG5jb25zdCBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY2xhc3MgUmVzYW1wbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucHJvY2VzcyA9IChhdWRpb0ZyYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRGcmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2FtcGxlIG9mIGF1ZGlvRnJhbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0QnVmZmVyLnB1c2goc2FtcGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICgodGhpcy5pbnB1dEJ1ZmZlci5sZW5ndGggKiB0aGlzLm9wdGlvbnMudGFyZ2V0U2FtcGxlUmF0ZSkgL1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5uYXRpdmVTYW1wbGVSYXRlID5cbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGFyZ2V0RnJhbWVTaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0RnJhbWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMub3B0aW9ucy50YXJnZXRGcmFtZVNpemUpO1xuICAgICAgICAgICAgICAgIGxldCBvdXRwdXRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGlucHV0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChvdXRwdXRJbmRleCA8IHRoaXMub3B0aW9ucy50YXJnZXRGcmFtZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBudW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5wdXRJbmRleCA8XG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbih0aGlzLmlucHV0QnVmZmVyLmxlbmd0aCwgKChvdXRwdXRJbmRleCArIDEpICogdGhpcy5vcHRpb25zLm5hdGl2ZVNhbXBsZVJhdGUpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGFyZ2V0U2FtcGxlUmF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSB0aGlzLmlucHV0QnVmZmVyW2lucHV0SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0RnJhbWVbb3V0cHV0SW5kZXhdID0gc3VtIC8gbnVtO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0QnVmZmVyID0gdGhpcy5pbnB1dEJ1ZmZlci5zbGljZShpbnB1dEluZGV4KTtcbiAgICAgICAgICAgICAgICBvdXRwdXRGcmFtZXMucHVzaChvdXRwdXRGcmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0RnJhbWVzO1xuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5uYXRpdmVTYW1wbGVSYXRlIDwgMTYwMDApIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2cuZXJyb3IoXCJuYXRpdmVTYW1wbGVSYXRlIGlzIHRvbyBsb3cuIFNob3VsZCBoYXZlIDE2MDAwID0gdGFyZ2V0U2FtcGxlUmF0ZSA8PSBuYXRpdmVTYW1wbGVSYXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXRCdWZmZXIgPSBbXTtcbiAgICB9XG59XG5leHBvcnRzLlJlc2FtcGxlciA9IFJlc2FtcGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc2FtcGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlV0FWID0gZXhwb3J0cy5hcnJheUJ1ZmZlclRvQmFzZTY0ID0gZXhwb3J0cy5taW5GcmFtZXNGb3JUYXJnZXRNUyA9IHZvaWQgMDtcbmZ1bmN0aW9uIG1pbkZyYW1lc0ZvclRhcmdldE1TKHRhcmdldER1cmF0aW9uLCBmcmFtZVNhbXBsZXMsIHNyID0gMTYwMDApIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKCh0YXJnZXREdXJhdGlvbiAqIHNyKSAvIDEwMDAgLyBmcmFtZVNhbXBsZXMpO1xufVxuZXhwb3J0cy5taW5GcmFtZXNGb3JUYXJnZXRNUyA9IG1pbkZyYW1lc0ZvclRhcmdldE1TO1xuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NChidWZmZXIpIHtcbiAgICB2YXIgYmluYXJ5ID0gXCJcIjtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIHZhciBsZW4gPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYShiaW5hcnkpO1xufVxuZXhwb3J0cy5hcnJheUJ1ZmZlclRvQmFzZTY0ID0gYXJyYXlCdWZmZXJUb0Jhc2U2NDtcbi8qXG5UaGlzIHJlc3Qgb2YgdGhpcyB3YXMgbW9zdGx5IGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9saW50by1haS9XZWJWb2ljZVNES1xuKi9cbmZ1bmN0aW9uIGVuY29kZVdBVihzYW1wbGVzLCBmb3JtYXQgPSAzLCBzYW1wbGVSYXRlID0gMTYwMDAsIG51bUNoYW5uZWxzID0gMSwgYml0RGVwdGggPSAzMikge1xuICAgIHZhciBieXRlc1BlclNhbXBsZSA9IGJpdERlcHRoIC8gODtcbiAgICB2YXIgYmxvY2tBbGlnbiA9IG51bUNoYW5uZWxzICogYnl0ZXNQZXJTYW1wbGU7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig0NCArIHNhbXBsZXMubGVuZ3RoICogYnl0ZXNQZXJTYW1wbGUpO1xuICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgLyogUklGRiBpZGVudGlmaWVyICovXG4gICAgd3JpdGVTdHJpbmcodmlldywgMCwgXCJSSUZGXCIpO1xuICAgIC8qIFJJRkYgY2h1bmsgbGVuZ3RoICovXG4gICAgdmlldy5zZXRVaW50MzIoNCwgMzYgKyBzYW1wbGVzLmxlbmd0aCAqIGJ5dGVzUGVyU2FtcGxlLCB0cnVlKTtcbiAgICAvKiBSSUZGIHR5cGUgKi9cbiAgICB3cml0ZVN0cmluZyh2aWV3LCA4LCBcIldBVkVcIik7XG4gICAgLyogZm9ybWF0IGNodW5rIGlkZW50aWZpZXIgKi9cbiAgICB3cml0ZVN0cmluZyh2aWV3LCAxMiwgXCJmbXQgXCIpO1xuICAgIC8qIGZvcm1hdCBjaHVuayBsZW5ndGggKi9cbiAgICB2aWV3LnNldFVpbnQzMigxNiwgMTYsIHRydWUpO1xuICAgIC8qIHNhbXBsZSBmb3JtYXQgKHJhdykgKi9cbiAgICB2aWV3LnNldFVpbnQxNigyMCwgZm9ybWF0LCB0cnVlKTtcbiAgICAvKiBjaGFubmVsIGNvdW50ICovXG4gICAgdmlldy5zZXRVaW50MTYoMjIsIG51bUNoYW5uZWxzLCB0cnVlKTtcbiAgICAvKiBzYW1wbGUgcmF0ZSAqL1xuICAgIHZpZXcuc2V0VWludDMyKDI0LCBzYW1wbGVSYXRlLCB0cnVlKTtcbiAgICAvKiBieXRlIHJhdGUgKHNhbXBsZSByYXRlICogYmxvY2sgYWxpZ24pICovXG4gICAgdmlldy5zZXRVaW50MzIoMjgsIHNhbXBsZVJhdGUgKiBibG9ja0FsaWduLCB0cnVlKTtcbiAgICAvKiBibG9jayBhbGlnbiAoY2hhbm5lbCBjb3VudCAqIGJ5dGVzIHBlciBzYW1wbGUpICovXG4gICAgdmlldy5zZXRVaW50MTYoMzIsIGJsb2NrQWxpZ24sIHRydWUpO1xuICAgIC8qIGJpdHMgcGVyIHNhbXBsZSAqL1xuICAgIHZpZXcuc2V0VWludDE2KDM0LCBiaXREZXB0aCwgdHJ1ZSk7XG4gICAgLyogZGF0YSBjaHVuayBpZGVudGlmaWVyICovXG4gICAgd3JpdGVTdHJpbmcodmlldywgMzYsIFwiZGF0YVwiKTtcbiAgICAvKiBkYXRhIGNodW5rIGxlbmd0aCAqL1xuICAgIHZpZXcuc2V0VWludDMyKDQwLCBzYW1wbGVzLmxlbmd0aCAqIGJ5dGVzUGVyU2FtcGxlLCB0cnVlKTtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIC8vIFJhdyBQQ01cbiAgICAgICAgZmxvYXRUbzE2Qml0UENNKHZpZXcsIDQ0LCBzYW1wbGVzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvYXQzMih2aWV3LCA0NCwgc2FtcGxlcyk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLmVuY29kZVdBViA9IGVuY29kZVdBVjtcbmZ1bmN0aW9uIGludGVybGVhdmUoaW5wdXRMLCBpbnB1dFIpIHtcbiAgICB2YXIgbGVuZ3RoID0gaW5wdXRMLmxlbmd0aCArIGlucHV0Ui5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkobGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpbnB1dEluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4KytdID0gaW5wdXRMW2lucHV0SW5kZXhdO1xuICAgICAgICByZXN1bHRbaW5kZXgrK10gPSBpbnB1dFJbaW5wdXRJbmRleF07XG4gICAgICAgIGlucHV0SW5kZXgrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHdyaXRlRmxvYXQzMihvdXRwdXQsIG9mZnNldCwgaW5wdXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICBvdXRwdXQuc2V0RmxvYXQzMihvZmZzZXQsIGlucHV0W2ldLCB0cnVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmbG9hdFRvMTZCaXRQQ00ob3V0cHV0LCBvZmZzZXQsIGlucHV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKywgb2Zmc2V0ICs9IDIpIHtcbiAgICAgICAgdmFyIHMgPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgaW5wdXRbaV0pKTtcbiAgICAgICAgb3V0cHV0LnNldEludDE2KG9mZnNldCwgcyA8IDAgPyBzICogMHg4MDAwIDogcyAqIDB4N2ZmZiwgdHJ1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JpdGVTdHJpbmcodmlldywgb2Zmc2V0LCBzdHJpbmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIGksIHN0cmluZy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzZXRQYXRoID0gdm9pZCAwO1xuY29uc3QgY3VycmVudFNjcmlwdCA9IHdpbmRvdy5kb2N1bWVudC5jdXJyZW50U2NyaXB0O1xubGV0IGJhc2VQYXRoID0gXCJcIjtcbmlmIChjdXJyZW50U2NyaXB0KSB7XG4gICAgYmFzZVBhdGggPSBjdXJyZW50U2NyaXB0LnNyY1xuICAgICAgICAucmVwbGFjZSgvIy4qJC8sIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKVxuICAgICAgICAucmVwbGFjZSgvXFwvW15cXC9dKyQvLCBcIi9cIik7XG59XG5jb25zdCBhc3NldFBhdGggPSAoZmlsZSkgPT4ge1xuICAgIHJldHVybiBiYXNlUGF0aCArIGZpbGU7XG59O1xuZXhwb3J0cy5hc3NldFBhdGggPSBhc3NldFBhdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NldC1wYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHRSZWFsVGltZVZBRE9wdGlvbnMgPSBleHBvcnRzLkF1ZGlvTm9kZVZBRCA9IGV4cG9ydHMuTWljVkFEID0gZXhwb3J0cy5Ob25SZWFsVGltZVZBRCA9IGV4cG9ydHMuTWVzc2FnZSA9IGV4cG9ydHMuRnJhbWVQcm9jZXNzb3IgPSBleHBvcnRzLnV0aWxzID0gdm9pZCAwO1xuY29uc3Qgb3J0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJvbm54cnVudGltZS13ZWJcIikpO1xuY29uc3QgX2NvbW1vbl8xID0gcmVxdWlyZShcIi4vX2NvbW1vblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZyYW1lUHJvY2Vzc29yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfY29tbW9uXzEuRnJhbWVQcm9jZXNzb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfY29tbW9uXzEuTWVzc2FnZTsgfSB9KTtcbmNvbnN0IG1vZGVsX2ZldGNoZXJfMSA9IHJlcXVpcmUoXCIuL21vZGVsLWZldGNoZXJcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jbGFzcyBOb25SZWFsVGltZVZBRCBleHRlbmRzIF9jb21tb25fMS5QbGF0Zm9ybUFnbm9zdGljTm9uUmVhbFRpbWVWQUQge1xuICAgIHN0YXRpYyBhc3luYyBuZXcob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9uZXcobW9kZWxfZmV0Y2hlcl8xLm1vZGVsRmV0Y2hlciwgb3J0LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLk5vblJlYWxUaW1lVkFEID0gTm9uUmVhbFRpbWVWQUQ7XG5leHBvcnRzLnV0aWxzID0geyBhdWRpb0ZpbGVUb0FycmF5OiB1dGlsc18xLmF1ZGlvRmlsZVRvQXJyYXksIC4uLl9jb21tb25fMS51dGlscyB9O1xudmFyIHJlYWxfdGltZV92YWRfMSA9IHJlcXVpcmUoXCIuL3JlYWwtdGltZS12YWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaWNWQURcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWxfdGltZV92YWRfMS5NaWNWQUQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBdWRpb05vZGVWQURcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWxfdGltZV92YWRfMS5BdWRpb05vZGVWQUQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0UmVhbFRpbWVWQURPcHRpb25zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFsX3RpbWVfdmFkXzEuZGVmYXVsdFJlYWxUaW1lVkFET3B0aW9uczsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tb2RlbEZldGNoZXIgPSB2b2lkIDA7XG5jb25zdCBhc3NldF9wYXRoXzEgPSByZXF1aXJlKFwiLi9hc3NldC1wYXRoXCIpO1xuY29uc3QgbW9kZWxGZXRjaGVyID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1vZGVsVVJMID0gKDAsIGFzc2V0X3BhdGhfMS5hc3NldFBhdGgpKFwic2lsZXJvX3ZhZC5vbm54XCIpO1xuICAgIHJldHVybiBhd2FpdCBmZXRjaChtb2RlbFVSTCkudGhlbigocikgPT4gci5hcnJheUJ1ZmZlcigpKTtcbn07XG5leHBvcnRzLm1vZGVsRmV0Y2hlciA9IG1vZGVsRmV0Y2hlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVsLWZldGNoZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXVkaW9Ob2RlVkFEID0gZXhwb3J0cy5NaWNWQUQgPSBleHBvcnRzLmRlZmF1bHRSZWFsVGltZVZBRE9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBvcnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIm9ubnhydW50aW1lLXdlYlwiKSk7XG5jb25zdCBfY29tbW9uXzEgPSByZXF1aXJlKFwiLi9fY29tbW9uXCIpO1xuY29uc3QgbW9kZWxfZmV0Y2hlcl8xID0gcmVxdWlyZShcIi4vbW9kZWwtZmV0Y2hlclwiKTtcbmNvbnN0IGFzc2V0X3BhdGhfMSA9IHJlcXVpcmUoXCIuL2Fzc2V0LXBhdGhcIik7XG5jb25zdCBfZ2V0V29ya2xldFVSTCA9ICgpID0+IHtcbiAgICByZXR1cm4gKDAsIGFzc2V0X3BhdGhfMS5hc3NldFBhdGgpKFwidmFkLndvcmtsZXQuYnVuZGxlLm1pbi5qc1wiKTtcbn07XG5leHBvcnRzLmRlZmF1bHRSZWFsVGltZVZBRE9wdGlvbnMgPSB7XG4gICAgLi4uX2NvbW1vbl8xLmRlZmF1bHRGcmFtZVByb2Nlc3Nvck9wdGlvbnMsXG4gICAgb25GcmFtZVByb2Nlc3NlZDogKHByb2JhYmlsaXRpZXMpID0+IHsgfSxcbiAgICBvblZBRE1pc2ZpcmU6ICgpID0+IHtcbiAgICAgICAgX2NvbW1vbl8xLmxvZy5kZWJ1ZyhcIlZBRCBtaXNmaXJlXCIpO1xuICAgIH0sXG4gICAgb25TcGVlY2hTdGFydDogKCkgPT4ge1xuICAgICAgICBfY29tbW9uXzEubG9nLmRlYnVnKFwiRGV0ZWN0ZWQgc3BlZWNoIHN0YXJ0XCIpO1xuICAgIH0sXG4gICAgb25TcGVlY2hFbmQ6ICgpID0+IHtcbiAgICAgICAgX2NvbW1vbl8xLmxvZy5kZWJ1ZyhcIkRldGVjdGVkIHNwZWVjaCBlbmRcIik7XG4gICAgfSxcbiAgICB3b3JrbGV0VVJMOiBfZ2V0V29ya2xldFVSTCgpLFxuICAgIHN0cmVhbTogdW5kZWZpbmVkLFxufTtcbmNsYXNzIE1pY1ZBRCB7XG4gICAgc3RhdGljIGFzeW5jIG5ldyhvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgdmFkID0gbmV3IE1pY1ZBRCh7IC4uLmV4cG9ydHMuZGVmYXVsdFJlYWxUaW1lVkFET3B0aW9ucywgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgYXdhaXQgdmFkLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHZhZDtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmxpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xuICAgICAgICAgICAgICAgICAgICBhdWRpbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLmFkZGl0aW9uYWxBdWRpb0NvbnN0cmFpbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWNob0NhbmNlbGxhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9HYWluQ29udHJvbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vaXNlU3VwcHJlc3Npb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSB0aGlzLm9wdGlvbnMuc3RyZWFtO1xuICAgICAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBuZXcgTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGUodGhpcy5hdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgICAgICBtZWRpYVN0cmVhbTogdGhpcy5zdHJlYW0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9Ob2RlVkFEID0gYXdhaXQgQXVkaW9Ob2RlVkFELm5ldyh0aGlzLmF1ZGlvQ29udGV4dCwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9Ob2RlVkFELnJlY2VpdmUoc291cmNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wYXVzZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9Ob2RlVkFELnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hdWRpb05vZGVWQUQuc3RhcnQoKTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgKDAsIF9jb21tb25fMS52YWxpZGF0ZU9wdGlvbnMpKG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWljVkFEID0gTWljVkFEO1xuY2xhc3MgQXVkaW9Ob2RlVkFEIHtcbiAgICBzdGF0aWMgYXN5bmMgbmV3KGN0eCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHZhZCA9IG5ldyBBdWRpb05vZGVWQUQoY3R4LCB7XG4gICAgICAgICAgICAuLi5leHBvcnRzLmRlZmF1bHRSZWFsVGltZVZBRE9wdGlvbnMsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdmFkLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHZhZDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY3R4LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnBhdXNlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5mcmFtZVByb2Nlc3Nvci5wYXVzZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5mcmFtZVByb2Nlc3Nvci5yZXN1bWUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWNlaXZlID0gKG5vZGUpID0+IHtcbiAgICAgICAgICAgIG5vZGUuY29ubmVjdCh0aGlzLmVudHJ5Tm9kZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvY2Vzc0ZyYW1lID0gYXN5bmMgKGZyYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHByb2JzLCBtc2csIGF1ZGlvIH0gPSBhd2FpdCB0aGlzLmZyYW1lUHJvY2Vzc29yLnByb2Nlc3MoZnJhbWUpO1xuICAgICAgICAgICAgaWYgKHByb2JzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25GcmFtZVByb2Nlc3NlZChwcm9icyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKG1zZykge1xuICAgICAgICAgICAgICAgIGNhc2UgX2NvbW1vbl8xLk1lc3NhZ2UuU3BlZWNoU3RhcnQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vblNwZWVjaFN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgX2NvbW1vbl8xLk1lc3NhZ2UuVkFETWlzZmlyZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uVkFETWlzZmlyZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIF9jb21tb25fMS5NZXNzYWdlLlNwZWVjaEVuZDpcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25TcGVlY2hFbmQoYXVkaW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jdHguYXVkaW9Xb3JrbGV0LmFkZE1vZHVsZSh0aGlzLm9wdGlvbnMud29ya2xldFVSTCk7XG4gICAgICAgICAgICBjb25zdCB2YWROb2RlID0gbmV3IEF1ZGlvV29ya2xldE5vZGUodGhpcy5jdHgsIFwidmFkLWhlbHBlci13b3JrbGV0XCIsIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzb3JPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lU2FtcGxlczogdGhpcy5vcHRpb25zLmZyYW1lU2FtcGxlcyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVudHJ5Tm9kZSA9IHZhZE5vZGU7XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IGF3YWl0IF9jb21tb25fMS5TaWxlcm8ubmV3KG9ydCwgbW9kZWxfZmV0Y2hlcl8xLm1vZGVsRmV0Y2hlcik7XG4gICAgICAgICAgICB0aGlzLmZyYW1lUHJvY2Vzc29yID0gbmV3IF9jb21tb25fMS5GcmFtZVByb2Nlc3Nvcihtb2RlbC5wcm9jZXNzLCBtb2RlbC5yZXNldF9zdGF0ZSwge1xuICAgICAgICAgICAgICAgIGZyYW1lU2FtcGxlczogdGhpcy5vcHRpb25zLmZyYW1lU2FtcGxlcyxcbiAgICAgICAgICAgICAgICBwb3NpdGl2ZVNwZWVjaFRocmVzaG9sZDogdGhpcy5vcHRpb25zLnBvc2l0aXZlU3BlZWNoVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgIG5lZ2F0aXZlU3BlZWNoVGhyZXNob2xkOiB0aGlzLm9wdGlvbnMubmVnYXRpdmVTcGVlY2hUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgcmVkZW1wdGlvbkZyYW1lczogdGhpcy5vcHRpb25zLnJlZGVtcHRpb25GcmFtZXMsXG4gICAgICAgICAgICAgICAgcHJlU3BlZWNoUGFkRnJhbWVzOiB0aGlzLm9wdGlvbnMucHJlU3BlZWNoUGFkRnJhbWVzLFxuICAgICAgICAgICAgICAgIG1pblNwZWVjaEZyYW1lczogdGhpcy5vcHRpb25zLm1pblNwZWVjaEZyYW1lcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFkTm9kZS5wb3J0Lm9ubWVzc2FnZSA9IGFzeW5jIChldikgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXYuZGF0YT8ubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIF9jb21tb25fMS5NZXNzYWdlLkF1ZGlvRnJhbWU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBldi5kYXRhLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmFtZSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0ZyYW1lKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgKDAsIF9jb21tb25fMS52YWxpZGF0ZU9wdGlvbnMpKG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXVkaW9Ob2RlVkFEID0gQXVkaW9Ob2RlVkFEO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhbC10aW1lLXZhZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXVkaW9GaWxlVG9BcnJheSA9IHZvaWQgMDtcbmFzeW5jIGZ1bmN0aW9uIGF1ZGlvRmlsZVRvQXJyYXkoYXVkaW9GaWxlRGF0YSkge1xuICAgIGNvbnN0IGN0eCA9IG5ldyBPZmZsaW5lQXVkaW9Db250ZXh0KDEsIDEsIDQ0MTAwKTtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGxldCBhdWRpb0J1ZmZlciA9IG51bGw7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlbmRcIiwgKGV2KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdWRpb0RhdGEgPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgY3R4LmRlY29kZUF1ZGlvRGF0YShhdWRpb0RhdGEsIChidWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICBhdWRpb0J1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICBjdHhcbiAgICAgICAgICAgICAgICAgICAgLnN0YXJ0UmVuZGVyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHJlbmRlcmVkQnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVuZGVyaW5nIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICAgICAgICAgICAgICAgIHJlcygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFJlbmRlcmluZyBmYWlsZWQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3Igd2l0aCBkZWNvZGluZyBhdWRpbyBkYXRhOiAke2V9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihhdWRpb0ZpbGVEYXRhKTtcbiAgICB9KTtcbiAgICBpZiAoYXVkaW9CdWZmZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJzb21lIHNoaXRcIik7XG4gICAgfVxuICAgIGxldCBfYXVkaW9CdWZmZXIgPSBhdWRpb0J1ZmZlcjtcbiAgICBsZXQgb3V0ID0gbmV3IEZsb2F0MzJBcnJheShfYXVkaW9CdWZmZXIubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9hdWRpb0J1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IF9hdWRpb0J1ZmZlci5udW1iZXJPZkNoYW5uZWxzOyBqKyspIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIG91dFtpXSArPSBfYXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoailbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYXVkaW86IG91dCwgc2FtcGxlUmF0ZTogX2F1ZGlvQnVmZmVyLnNhbXBsZVJhdGUgfTtcbn1cbmV4cG9ydHMuYXVkaW9GaWxlVG9BcnJheSA9IGF1ZGlvRmlsZVRvQXJyYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgQGtleWZyYW1lcyBwdWxzZV9vdXRlcm1vc3Qge1xuICAwJSxcbiAgMTAwJSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcbiAgfVxuICA1MCUge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMC45Mik7XG4gIH1cbn1cbi5vdXRlcm1vc3Qge1xuICBhbmltYXRpb246IHB1bHNlX291dGVybW9zdCA1cyBpbmZpbml0ZTtcbiAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xufVxuXG5Aa2V5ZnJhbWVzIHB1bHNlX3NlY29uZCB7XG4gIDAlLFxuICAxMDAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xuICB9XG4gIDUwJSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjg1Nik7XG4gIH1cbn1cbi5zZWNvbmQge1xuICBhbmltYXRpb246IHB1bHNlX3NlY29uZCA1cyBpbmZpbml0ZTtcbiAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xufVxuXG5Aa2V5ZnJhbWVzIHB1bHNlX3RoaXJkIHtcbiAgMCUsXG4gIDEwMCUge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XG4gIH1cbiAgNTAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNzkyKTtcbiAgfVxufVxuLnRoaXJkIHtcbiAgYW5pbWF0aW9uOiBwdWxzZV90aGlyZCA1cyBpbmZpbml0ZTtcbiAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xufVxuXG5Aa2V5ZnJhbWVzIHB1bHNlX2ZvdXJ0aCB7XG4gIDAlLFxuICAxMDAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xuICB9XG4gIDUwJSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjcyOCk7XG4gIH1cbn1cbi5mb3VydGgge1xuICBhbmltYXRpb246IHB1bHNlX2ZvdXJ0aCA1cyBpbmZpbml0ZTtcbiAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xufVxuXG5Aa2V5ZnJhbWVzIHB1bHNlX2ZpZnRoIHtcbiAgMCUsXG4gIDEwMCUge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XG4gIH1cbiAgNTAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNjY0KTtcbiAgfVxufVxuLmZpZnRoIHtcbiAgYW5pbWF0aW9uOiBwdWxzZV9maWZ0aCA1cyBpbmZpbml0ZTtcbiAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xufVxuXG5Aa2V5ZnJhbWVzIHB1bHNlX2lubmVybW9zdCB7XG4gIDAlLFxuICAxMDAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xuICB9XG4gIDUwJSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjYpO1xuICB9XG59XG4uaW5uZXJtb3N0IHtcbiAgYW5pbWF0aW9uOiBwdWxzZV9pbm5lcm1vc3QgNXMgaW5maW5pdGU7XG4gIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlcjtcbn1cblxuLyogcGxheWZ1bCBhbmltYXRpb24gdG8gaW5kaWNhdGUgUGkgaXMgc3BlYWtpbmcgKi9cbkBrZXlmcmFtZXMgc3BlYWtpbmdfb3V0ZXJtb3N0IHtcbiAgMCUsXG4gIDEwMCUge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMSkgcm90YXRlKDBkZWcpO1xuICB9XG4gIDI1JSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjk5NSk7XG4gIH1cbiAgNTAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOSk7XG4gIH1cbiAgNzUlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuODk1KTtcbiAgfVxufVxuLm91dGVybW9zdC5waVNwZWFraW5nIHtcbiAgYW5pbWF0aW9uOiBzcGVha2luZ19vdXRlcm1vc3QgMnMgaW5maW5pdGU7XG4gIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlcjtcbn1cblxuQGtleWZyYW1lcyBzcGVha2luZ19zZWNvbmQge1xuICAwJSxcbiAgMTAwJSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxKSByb3RhdGUoMGRlZyk7XG4gIH1cbiAgMjUlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOTgpIHJvdGF0ZSgtMWRlZyk7XG4gIH1cbiAgNTAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuODcpIHJvdGF0ZSgwZGVnKTtcbiAgfVxuICA3NSUge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMC44NjUpIHJvdGF0ZSgxZGVnKTtcbiAgfVxufVxuLnNlY29uZC5waVNwZWFraW5nIHtcbiAgYW5pbWF0aW9uOiBzcGVha2luZ19zZWNvbmQgMnMgaW5maW5pdGU7XG4gIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlcjtcbn1cblxuQGtleWZyYW1lcyBzcGVha2luZ190aGlyZCB7XG4gIDAlLFxuICAxMDAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpIHJvdGF0ZSgwZGVnKTtcbiAgfVxuICAyNSUge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMC45NjUpIHJvdGF0ZSgtMmRlZyk7XG4gIH1cbiAgNTAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuODQpIHJvdGF0ZSgwZGVnKTtcbiAgfVxuICA3NSUge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMC44MzUpIHJvdGF0ZSgyZGVnKTtcbiAgfVxufVxuLnRoaXJkLnBpU3BlYWtpbmcge1xuICBhbmltYXRpb246IHNwZWFraW5nX3RoaXJkIDJzIGluZmluaXRlO1xuICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7XG59XG5cbkBrZXlmcmFtZXMgc3BlYWtpbmdfZm91cnRoIHtcbiAgMCUsXG4gIDEwMCUge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMSkgcm90YXRlKDBkZWcpO1xuICB9XG4gIDI1JSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjk1KSByb3RhdGUoLTNkZWcpO1xuICB9XG4gIDUwJSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjgxKSByb3RhdGUoMGRlZyk7XG4gIH1cbiAgNzUlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuODA1KSByb3RhdGUoM2RlZyk7XG4gIH1cbn1cbi5mb3VydGgucGlTcGVha2luZyB7XG4gIGFuaW1hdGlvbjogc3BlYWtpbmdfZm91cnRoIDJzIGluZmluaXRlO1xuICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7XG59XG5cbkBrZXlmcmFtZXMgc3BlYWtpbmdfZmlmdGgge1xuICAwJSxcbiAgMTAwJSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxKSByb3RhdGUoMGRlZyk7XG4gIH1cbiAgMjUlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOTM1KSByb3RhdGUoLTRkZWcpO1xuICB9XG4gIDUwJSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjc4KSByb3RhdGUoMGRlZyk7XG4gIH1cbiAgNzUlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNzc1KSByb3RhdGUoNGRlZyk7XG4gIH1cbn1cbi5maWZ0aC5waVNwZWFraW5nIHtcbiAgYW5pbWF0aW9uOiBzcGVha2luZ19maWZ0aCAycyBpbmZpbml0ZTtcbiAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xufVxuXG5Aa2V5ZnJhbWVzIHNwZWFraW5nX2lubmVybW9zdCB7XG4gIDAlLFxuICAxMDAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpIHJvdGF0ZSgwZGVnKTtcbiAgfVxuICAyNSUge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMC45Mikgcm90YXRlKC01ZGVnKTtcbiAgfVxuICA1MCUge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMC43NSkgcm90YXRlKDBkZWcpO1xuICB9XG4gIDc1JSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjc0NSkgcm90YXRlKDVkZWcpO1xuICB9XG59XG4uaW5uZXJtb3N0LnBpU3BlYWtpbmcge1xuICBhbmltYXRpb246IHNwZWFraW5nX2lubmVybW9zdCAycyBpbmZpbml0ZTtcbiAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xufVxuXG4vKiB3YXZlIGFuaW1hdGlvbiB0byBpbmRpY2F0ZSB1c2VyIGlzIHNwZWFraW5nICovXG5Aa2V5ZnJhbWVzIHVzZXJTcGVha2luZ0FuaW1hdGlvbiB7XG4gIDUwJSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC4wNSkgc2NhbGVYKHZhcigtLXdpZHRoLWZhY3RvcikpXG4gICAgICB0cmFuc2xhdGVYKGNhbGMoLTUwJSArIHZhcigtLXNwcmVhZC1hbW91bnQpKSk7XG4gIH1cbiAgMTAwJSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMSkgc2NhbGVYKHZhcigtLXdpZHRoLWZhY3RvcikpXG4gICAgICB0cmFuc2xhdGVYKGNhbGMoLTUwJSArIHZhcigtLXNwcmVhZC1hbW91bnQpKSk7XG4gIH1cbn1cbi8qIHVzZXIgc3BlYWtpbmcgb3NjaWxsYXRpb24gYW5pbWF0aW9uICovXG5Aa2V5ZnJhbWVzIHdhdmVmb3JtX291dGVybW9zdCB7XG4gIDAlLFxuICAxMDAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgxKSBzY2FsZVgoMSk7XG4gIH1cbiAgMjUlLFxuICA3NSUge1xuICAgIHRyYW5zZm9ybTogc2NhbGVZKDAuOSkgc2NhbGVYKDAuOSk7XG4gIH1cbn1cblxuQGtleWZyYW1lcyB3YXZlZm9ybV9zZWNvbmQge1xuICAwJSxcbiAgMTAwJSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC45KSBzY2FsZVgoMC45KTtcbiAgfVxuICAyNSUsXG4gIDc1JSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC44KSBzY2FsZVgoMC44KTtcbiAgfVxufVxuXG5Aa2V5ZnJhbWVzIHdhdmVmb3JtX3RoaXJkIHtcbiAgMCUsXG4gIDEwMCUge1xuICAgIHRyYW5zZm9ybTogc2NhbGVZKDAuOCkgc2NhbGVYKDAuOCk7XG4gIH1cbiAgMjUlLFxuICA3NSUge1xuICAgIHRyYW5zZm9ybTogc2NhbGVZKDAuNykgc2NhbGVYKDAuNyk7XG4gIH1cbn1cblxuQGtleWZyYW1lcyB3YXZlZm9ybV9mb3VydGgge1xuICAwJSxcbiAgMTAwJSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC43KSBzY2FsZVgoMC43KTtcbiAgfVxuICAyNSUsXG4gIDc1JSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC42KSBzY2FsZVgoMC42KTtcbiAgfVxufVxuXG5Aa2V5ZnJhbWVzIHdhdmVmb3JtX2ZpZnRoIHtcbiAgMCUsXG4gIDEwMCUge1xuICAgIHRyYW5zZm9ybTogc2NhbGVZKDAuNikgc2NhbGVYKDAuNik7XG4gIH1cbiAgMjUlLFxuICA3NSUge1xuICAgIHRyYW5zZm9ybTogc2NhbGVZKDAuNSkgc2NhbGVYKDAuNSk7XG4gIH1cbn1cblxuQGtleWZyYW1lcyB3YXZlZm9ybV9pbm5lcm1vc3Qge1xuICAwJSxcbiAgMTAwJSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC41KSBzY2FsZVgoMC41KTtcbiAgfVxuICAyNSUsXG4gIDc1JSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC40KSBzY2FsZVgoMC40KTtcbiAgfVxufVxuXG4ub3V0ZXJtb3N0LnVzZXJTcGVha2luZyB7XG4gIGFuaW1hdGlvbjogd2F2ZWZvcm1fb3V0ZXJtb3N0IDAuN3MgaW5maW5pdGUgYWx0ZXJuYXRlO1xufVxuXG4uc2Vjb25kLnVzZXJTcGVha2luZyB7XG4gIGFuaW1hdGlvbjogd2F2ZWZvcm1fc2Vjb25kIDAuNjVzIGluZmluaXRlIGFsdGVybmF0ZTtcbn1cblxuLnRoaXJkLnVzZXJTcGVha2luZyB7XG4gIGFuaW1hdGlvbjogd2F2ZWZvcm1fdGhpcmQgMC42cyBpbmZpbml0ZSBhbHRlcm5hdGU7XG59XG5cbi5mb3VydGgudXNlclNwZWFraW5nIHtcbiAgYW5pbWF0aW9uOiB3YXZlZm9ybV9mb3VydGggMC41NXMgaW5maW5pdGUgYWx0ZXJuYXRlO1xufVxuXG4uZmlmdGgudXNlclNwZWFraW5nIHtcbiAgYW5pbWF0aW9uOiB3YXZlZm9ybV9maWZ0aCAwLjVzIGluZmluaXRlIGFsdGVybmF0ZTtcbn1cblxuLmlubmVybW9zdC51c2VyU3BlYWtpbmcge1xuICBhbmltYXRpb246IHdhdmVmb3JtX2lubmVybW9zdCAwLjQ1cyBpbmZpbml0ZSBhbHRlcm5hdGU7XG59XG5cbi8qIGZsaXBjYXJkIGFuaW1hdGlvbiB0byBpbmRpY2F0ZSBTYXksIFBpIGlzIHRyYW5zY3JpYmluZyBhdWRpbyB0byB0ZXh0ICovXG5Aa2V5ZnJhbWVzIHRyYW5zY3JpYmluZ0ZsaXAge1xuICAwJSxcbiAgMTAwJSB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGVZKDBkZWcpO1xuICAgIGZpbGw6IHZhcigtLW9yaWdpbmFsLWNvbG9yKTtcbiAgfVxuICA1MCUge1xuICAgIHRyYW5zZm9ybTogcm90YXRlWSgxODBkZWcpO1xuICAgIGZpbGw6IHZhcigtLXRyYW5zY3JpYmluZy1jb2xvcik7XG4gIH1cbn1cblxuLm91dGVybW9zdC50cmFuc2NyaWJpbmcge1xuICAtLW9yaWdpbmFsLWNvbG9yOiAjZTRmMmQxO1xuICAtLXRyYW5zY3JpYmluZy1jb2xvcjogI2IzZTBmZTtcbiAgYW5pbWF0aW9uOiB0cmFuc2NyaWJpbmdGbGlwIDEuNXMgaW5maW5pdGU7XG59XG5cbi5zZWNvbmQudHJhbnNjcmliaW5nIHtcbiAgLS1vcmlnaW5hbC1jb2xvcjogI2NjZThiNTtcbiAgLS10cmFuc2NyaWJpbmctY29sb3I6ICM4OWMyZmY7XG4gIGFuaW1hdGlvbjogdHJhbnNjcmliaW5nRmxpcCAxLjZzIGluZmluaXRlO1xufVxuXG4udGhpcmQudHJhbnNjcmliaW5nIHtcbiAgLS1vcmlnaW5hbC1jb2xvcjogI2IzZGI5NTtcbiAgLS10cmFuc2NyaWJpbmctY29sb3I6ICM1ZmE0ZmY7XG4gIGFuaW1hdGlvbjogdHJhbnNjcmliaW5nRmxpcCAxLjdzIGluZmluaXRlO1xufVxuXG4uZm91cnRoLnRyYW5zY3JpYmluZyB7XG4gIC0tb3JpZ2luYWwtY29sb3I6ICM5YmQwNzg7XG4gIC0tdHJhbnNjcmliaW5nLWNvbG9yOiAjMzU4NmZmO1xuICBhbmltYXRpb246IHRyYW5zY3JpYmluZ0ZsaXAgMS44cyBpbmZpbml0ZTtcbn1cblxuLmZpZnRoLnRyYW5zY3JpYmluZyB7XG4gIC0tb3JpZ2luYWwtY29sb3I6ICM4M2M1NWM7XG4gIC0tdHJhbnNjcmliaW5nLWNvbG9yOiAjMGI2OWUzO1xuICBhbmltYXRpb246IHRyYW5zY3JpYmluZ0ZsaXAgMS45cyBpbmZpbml0ZTtcbn1cblxuLmlubmVybW9zdC50cmFuc2NyaWJpbmcge1xuICAtLW9yaWdpbmFsLWNvbG9yOiAjNDI4YTJmO1xuICAtLXRyYW5zY3JpYmluZy1jb2xvcjogIzAwNTNiZjtcbiAgYW5pbWF0aW9uOiB0cmFuc2NyaWJpbmdGbGlwIDJzIGluZmluaXRlO1xufVxuXG4vKiBoZWFydGJlYXQgYW5pbWF0aW9uIHRvIGluZGljYXRlIFBpIGlzIHByZXBhcmluZyB0byBzcGVhayAqL1xuQGtleWZyYW1lcyBoZWFydGJlYXQge1xuICAwJSxcbiAgMTAwJSB7XG4gICAgb3BhY2l0eTogMTtcbiAgICBmaWxsOiB2YXIoLS1vcmlnaW5hbC1jb2xvcik7XG4gIH1cbiAgNTAlIHtcbiAgICBvcGFjaXR5OiAwLjU7XG4gICAgZmlsbDogcmdiKDI0NSAyMzggMjIzKTsgLyogYmctY3JlYW0tNTUwICovXG4gIH1cbn1cblxuLyogdG9uZWQtZG93biBkaXNzYXJ5IGFuaW1hdGlvbiB0byBpbmRpY2F0ZSBhbiBlcnJvciAqL1xuLyogdG9uZWQtZG93biBlcnJvciBhbmltYXRpb24gd2l0aCByZWR1Y2VkIG9wYWNpdHkgKi9cbkBrZXlmcmFtZXMgZXJyb3JBbmltYXRpb24ge1xuICAwJSB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZykgdHJhbnNsYXRlKDAlLCAwJSk7XG4gIH1cbiAgMjUlIHtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtNWRlZykgdHJhbnNsYXRlKC01JSwgNSUpO1xuICB9XG4gIDUwJSB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoNWRlZykgdHJhbnNsYXRlKDUlLCAtNSUpO1xuICB9XG4gIDc1JSB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoLTVkZWcpIHRyYW5zbGF0ZSgtNSUsIDUlKTtcbiAgfVxuICAxMDAlIHtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKSB0cmFuc2xhdGUoMCUsIDAlKTtcbiAgfVxufVxuXG4ub3V0ZXJtb3N0LmVycm9yIHtcbiAgYW5pbWF0aW9uOiBlcnJvckFuaW1hdGlvbiAyNXMgMTtcbiAgZmlsbDogI2ZmMDAwMDtcbiAgZmlsbC1vcGFjaXR5OiAwLjc7XG59XG5cbi5zZWNvbmQuZXJyb3Ige1xuICBhbmltYXRpb246IGVycm9yQW5pbWF0aW9uIDI1cyAxO1xuICBmaWxsOiAjZmYzMzAwO1xuICBmaWxsLW9wYWNpdHk6IDAuNztcbn1cblxuLnRoaXJkLmVycm9yIHtcbiAgYW5pbWF0aW9uOiBlcnJvckFuaW1hdGlvbiAyNXMgMTtcbiAgZmlsbDogI2ZmNjYwMDtcbiAgZmlsbC1vcGFjaXR5OiAwLjc7XG59XG5cbi5mb3VydGguZXJyb3Ige1xuICBhbmltYXRpb246IGVycm9yQW5pbWF0aW9uIDI1cyAxO1xuICBmaWxsOiAjZmY5OTAwO1xuICBmaWxsLW9wYWNpdHk6IDAuNztcbn1cblxuLmZpZnRoLmVycm9yIHtcbiAgYW5pbWF0aW9uOiBlcnJvckFuaW1hdGlvbiAyNXMgMTtcbiAgZmlsbDogI2ZmY2MwMDtcbiAgZmlsbC1vcGFjaXR5OiAwLjc7XG59XG5cbi5pbm5lcm1vc3QuZXJyb3Ige1xuICBhbmltYXRpb246IGVycm9yQW5pbWF0aW9uIDI1cyAxO1xuICBmaWxsOiAjZmZmZjAwO1xuICBmaWxsLW9wYWNpdHk6IDAuNztcbn1cbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL3N0eWxlcy9yZWN0YW5nbGVzLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFOztJQUVFLG1CQUFtQjtFQUNyQjtFQUNBO0lBQ0Usc0JBQXNC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RUE7RUFDRSwrQkFBK0I7RUFDL0IsYUFBYTtFQUNiLGlCQUFpQjtBQUNuQjs7QUFFQTtFQUNFLCtCQUErQjtFQUMvQixhQUFhO0VBQ2IsaUJBQWlCO0FBQ25COztBQUVBO0VBQ0UsK0JBQStCO0VBQy9CLGFBQWE7RUFDYixpQkFBaUI7QUFDbkI7O0FBRUE7RUFDRSwrQkFBK0I7RUFDL0IsYUFBYTtFQUNiLGlCQUFpQjtBQUNuQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAa2V5ZnJhbWVzIHB1bHNlX291dGVybW9zdCB7XFxuICAwJSxcXG4gIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgfVxcbiAgNTAlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjkyKTtcXG4gIH1cXG59XFxuLm91dGVybW9zdCB7XFxuICBhbmltYXRpb246IHB1bHNlX291dGVybW9zdCA1cyBpbmZpbml0ZTtcXG4gIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlcjtcXG59XFxuXFxuQGtleWZyYW1lcyBwdWxzZV9zZWNvbmQge1xcbiAgMCUsXFxuICAxMDAlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gIH1cXG4gIDUwJSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMC44NTYpO1xcbiAgfVxcbn1cXG4uc2Vjb25kIHtcXG4gIGFuaW1hdGlvbjogcHVsc2Vfc2Vjb25kIDVzIGluZmluaXRlO1xcbiAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xcbn1cXG5cXG5Aa2V5ZnJhbWVzIHB1bHNlX3RoaXJkIHtcXG4gIDAlLFxcbiAgMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICB9XFxuICA1MCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNzkyKTtcXG4gIH1cXG59XFxuLnRoaXJkIHtcXG4gIGFuaW1hdGlvbjogcHVsc2VfdGhpcmQgNXMgaW5maW5pdGU7XFxuICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7XFxufVxcblxcbkBrZXlmcmFtZXMgcHVsc2VfZm91cnRoIHtcXG4gIDAlLFxcbiAgMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICB9XFxuICA1MCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNzI4KTtcXG4gIH1cXG59XFxuLmZvdXJ0aCB7XFxuICBhbmltYXRpb246IHB1bHNlX2ZvdXJ0aCA1cyBpbmZpbml0ZTtcXG4gIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlcjtcXG59XFxuXFxuQGtleWZyYW1lcyBwdWxzZV9maWZ0aCB7XFxuICAwJSxcXG4gIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgfVxcbiAgNTAlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjY2NCk7XFxuICB9XFxufVxcbi5maWZ0aCB7XFxuICBhbmltYXRpb246IHB1bHNlX2ZpZnRoIDVzIGluZmluaXRlO1xcbiAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xcbn1cXG5cXG5Aa2V5ZnJhbWVzIHB1bHNlX2lubmVybW9zdCB7XFxuICAwJSxcXG4gIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgfVxcbiAgNTAlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjYpO1xcbiAgfVxcbn1cXG4uaW5uZXJtb3N0IHtcXG4gIGFuaW1hdGlvbjogcHVsc2VfaW5uZXJtb3N0IDVzIGluZmluaXRlO1xcbiAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xcbn1cXG5cXG4vKiBwbGF5ZnVsIGFuaW1hdGlvbiB0byBpbmRpY2F0ZSBQaSBpcyBzcGVha2luZyAqL1xcbkBrZXlmcmFtZXMgc3BlYWtpbmdfb3V0ZXJtb3N0IHtcXG4gIDAlLFxcbiAgMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMSkgcm90YXRlKDBkZWcpO1xcbiAgfVxcbiAgMjUlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjk5NSk7XFxuICB9XFxuICA1MCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOSk7XFxuICB9XFxuICA3NSUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuODk1KTtcXG4gIH1cXG59XFxuLm91dGVybW9zdC5waVNwZWFraW5nIHtcXG4gIGFuaW1hdGlvbjogc3BlYWtpbmdfb3V0ZXJtb3N0IDJzIGluZmluaXRlO1xcbiAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xcbn1cXG5cXG5Aa2V5ZnJhbWVzIHNwZWFraW5nX3NlY29uZCB7XFxuICAwJSxcXG4gIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpIHJvdGF0ZSgwZGVnKTtcXG4gIH1cXG4gIDI1JSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMC45OCkgcm90YXRlKC0xZGVnKTtcXG4gIH1cXG4gIDUwJSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMC44Nykgcm90YXRlKDBkZWcpO1xcbiAgfVxcbiAgNzUlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjg2NSkgcm90YXRlKDFkZWcpO1xcbiAgfVxcbn1cXG4uc2Vjb25kLnBpU3BlYWtpbmcge1xcbiAgYW5pbWF0aW9uOiBzcGVha2luZ19zZWNvbmQgMnMgaW5maW5pdGU7XFxuICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7XFxufVxcblxcbkBrZXlmcmFtZXMgc3BlYWtpbmdfdGhpcmQge1xcbiAgMCUsXFxuICAxMDAlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxKSByb3RhdGUoMGRlZyk7XFxuICB9XFxuICAyNSUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOTY1KSByb3RhdGUoLTJkZWcpO1xcbiAgfVxcbiAgNTAlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjg0KSByb3RhdGUoMGRlZyk7XFxuICB9XFxuICA3NSUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuODM1KSByb3RhdGUoMmRlZyk7XFxuICB9XFxufVxcbi50aGlyZC5waVNwZWFraW5nIHtcXG4gIGFuaW1hdGlvbjogc3BlYWtpbmdfdGhpcmQgMnMgaW5maW5pdGU7XFxuICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7XFxufVxcblxcbkBrZXlmcmFtZXMgc3BlYWtpbmdfZm91cnRoIHtcXG4gIDAlLFxcbiAgMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMSkgcm90YXRlKDBkZWcpO1xcbiAgfVxcbiAgMjUlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjk1KSByb3RhdGUoLTNkZWcpO1xcbiAgfVxcbiAgNTAlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjgxKSByb3RhdGUoMGRlZyk7XFxuICB9XFxuICA3NSUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuODA1KSByb3RhdGUoM2RlZyk7XFxuICB9XFxufVxcbi5mb3VydGgucGlTcGVha2luZyB7XFxuICBhbmltYXRpb246IHNwZWFraW5nX2ZvdXJ0aCAycyBpbmZpbml0ZTtcXG4gIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlcjtcXG59XFxuXFxuQGtleWZyYW1lcyBzcGVha2luZ19maWZ0aCB7XFxuICAwJSxcXG4gIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEpIHJvdGF0ZSgwZGVnKTtcXG4gIH1cXG4gIDI1JSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMC45MzUpIHJvdGF0ZSgtNGRlZyk7XFxuICB9XFxuICA1MCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNzgpIHJvdGF0ZSgwZGVnKTtcXG4gIH1cXG4gIDc1JSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMC43NzUpIHJvdGF0ZSg0ZGVnKTtcXG4gIH1cXG59XFxuLmZpZnRoLnBpU3BlYWtpbmcge1xcbiAgYW5pbWF0aW9uOiBzcGVha2luZ19maWZ0aCAycyBpbmZpbml0ZTtcXG4gIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlcjtcXG59XFxuXFxuQGtleWZyYW1lcyBzcGVha2luZ19pbm5lcm1vc3Qge1xcbiAgMCUsXFxuICAxMDAlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxKSByb3RhdGUoMGRlZyk7XFxuICB9XFxuICAyNSUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOTIpIHJvdGF0ZSgtNWRlZyk7XFxuICB9XFxuICA1MCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNzUpIHJvdGF0ZSgwZGVnKTtcXG4gIH1cXG4gIDc1JSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMC43NDUpIHJvdGF0ZSg1ZGVnKTtcXG4gIH1cXG59XFxuLmlubmVybW9zdC5waVNwZWFraW5nIHtcXG4gIGFuaW1hdGlvbjogc3BlYWtpbmdfaW5uZXJtb3N0IDJzIGluZmluaXRlO1xcbiAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xcbn1cXG5cXG4vKiB3YXZlIGFuaW1hdGlvbiB0byBpbmRpY2F0ZSB1c2VyIGlzIHNwZWFraW5nICovXFxuQGtleWZyYW1lcyB1c2VyU3BlYWtpbmdBbmltYXRpb24ge1xcbiAgNTAlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC4wNSkgc2NhbGVYKHZhcigtLXdpZHRoLWZhY3RvcikpXFxuICAgICAgdHJhbnNsYXRlWChjYWxjKC01MCUgKyB2YXIoLS1zcHJlYWQtYW1vdW50KSkpO1xcbiAgfVxcbiAgMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDEpIHNjYWxlWCh2YXIoLS13aWR0aC1mYWN0b3IpKVxcbiAgICAgIHRyYW5zbGF0ZVgoY2FsYygtNTAlICsgdmFyKC0tc3ByZWFkLWFtb3VudCkpKTtcXG4gIH1cXG59XFxuLyogdXNlciBzcGVha2luZyBvc2NpbGxhdGlvbiBhbmltYXRpb24gKi9cXG5Aa2V5ZnJhbWVzIHdhdmVmb3JtX291dGVybW9zdCB7XFxuICAwJSxcXG4gIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgxKSBzY2FsZVgoMSk7XFxuICB9XFxuICAyNSUsXFxuICA3NSUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgwLjkpIHNjYWxlWCgwLjkpO1xcbiAgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIHdhdmVmb3JtX3NlY29uZCB7XFxuICAwJSxcXG4gIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgwLjkpIHNjYWxlWCgwLjkpO1xcbiAgfVxcbiAgMjUlLFxcbiAgNzUlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC44KSBzY2FsZVgoMC44KTtcXG4gIH1cXG59XFxuXFxuQGtleWZyYW1lcyB3YXZlZm9ybV90aGlyZCB7XFxuICAwJSxcXG4gIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgwLjgpIHNjYWxlWCgwLjgpO1xcbiAgfVxcbiAgMjUlLFxcbiAgNzUlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC43KSBzY2FsZVgoMC43KTtcXG4gIH1cXG59XFxuXFxuQGtleWZyYW1lcyB3YXZlZm9ybV9mb3VydGgge1xcbiAgMCUsXFxuICAxMDAlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC43KSBzY2FsZVgoMC43KTtcXG4gIH1cXG4gIDI1JSxcXG4gIDc1JSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDAuNikgc2NhbGVYKDAuNik7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgd2F2ZWZvcm1fZmlmdGgge1xcbiAgMCUsXFxuICAxMDAlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZVkoMC42KSBzY2FsZVgoMC42KTtcXG4gIH1cXG4gIDI1JSxcXG4gIDc1JSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDAuNSkgc2NhbGVYKDAuNSk7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgd2F2ZWZvcm1faW5uZXJtb3N0IHtcXG4gIDAlLFxcbiAgMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGVZKDAuNSkgc2NhbGVYKDAuNSk7XFxuICB9XFxuICAyNSUsXFxuICA3NSUge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlWSgwLjQpIHNjYWxlWCgwLjQpO1xcbiAgfVxcbn1cXG5cXG4ub3V0ZXJtb3N0LnVzZXJTcGVha2luZyB7XFxuICBhbmltYXRpb246IHdhdmVmb3JtX291dGVybW9zdCAwLjdzIGluZmluaXRlIGFsdGVybmF0ZTtcXG59XFxuXFxuLnNlY29uZC51c2VyU3BlYWtpbmcge1xcbiAgYW5pbWF0aW9uOiB3YXZlZm9ybV9zZWNvbmQgMC42NXMgaW5maW5pdGUgYWx0ZXJuYXRlO1xcbn1cXG5cXG4udGhpcmQudXNlclNwZWFraW5nIHtcXG4gIGFuaW1hdGlvbjogd2F2ZWZvcm1fdGhpcmQgMC42cyBpbmZpbml0ZSBhbHRlcm5hdGU7XFxufVxcblxcbi5mb3VydGgudXNlclNwZWFraW5nIHtcXG4gIGFuaW1hdGlvbjogd2F2ZWZvcm1fZm91cnRoIDAuNTVzIGluZmluaXRlIGFsdGVybmF0ZTtcXG59XFxuXFxuLmZpZnRoLnVzZXJTcGVha2luZyB7XFxuICBhbmltYXRpb246IHdhdmVmb3JtX2ZpZnRoIDAuNXMgaW5maW5pdGUgYWx0ZXJuYXRlO1xcbn1cXG5cXG4uaW5uZXJtb3N0LnVzZXJTcGVha2luZyB7XFxuICBhbmltYXRpb246IHdhdmVmb3JtX2lubmVybW9zdCAwLjQ1cyBpbmZpbml0ZSBhbHRlcm5hdGU7XFxufVxcblxcbi8qIGZsaXBjYXJkIGFuaW1hdGlvbiB0byBpbmRpY2F0ZSBTYXksIFBpIGlzIHRyYW5zY3JpYmluZyBhdWRpbyB0byB0ZXh0ICovXFxuQGtleWZyYW1lcyB0cmFuc2NyaWJpbmdGbGlwIHtcXG4gIDAlLFxcbiAgMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlWSgwZGVnKTtcXG4gICAgZmlsbDogdmFyKC0tb3JpZ2luYWwtY29sb3IpO1xcbiAgfVxcbiAgNTAlIHtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGVZKDE4MGRlZyk7XFxuICAgIGZpbGw6IHZhcigtLXRyYW5zY3JpYmluZy1jb2xvcik7XFxuICB9XFxufVxcblxcbi5vdXRlcm1vc3QudHJhbnNjcmliaW5nIHtcXG4gIC0tb3JpZ2luYWwtY29sb3I6ICNlNGYyZDE7XFxuICAtLXRyYW5zY3JpYmluZy1jb2xvcjogI2IzZTBmZTtcXG4gIGFuaW1hdGlvbjogdHJhbnNjcmliaW5nRmxpcCAxLjVzIGluZmluaXRlO1xcbn1cXG5cXG4uc2Vjb25kLnRyYW5zY3JpYmluZyB7XFxuICAtLW9yaWdpbmFsLWNvbG9yOiAjY2NlOGI1O1xcbiAgLS10cmFuc2NyaWJpbmctY29sb3I6ICM4OWMyZmY7XFxuICBhbmltYXRpb246IHRyYW5zY3JpYmluZ0ZsaXAgMS42cyBpbmZpbml0ZTtcXG59XFxuXFxuLnRoaXJkLnRyYW5zY3JpYmluZyB7XFxuICAtLW9yaWdpbmFsLWNvbG9yOiAjYjNkYjk1O1xcbiAgLS10cmFuc2NyaWJpbmctY29sb3I6ICM1ZmE0ZmY7XFxuICBhbmltYXRpb246IHRyYW5zY3JpYmluZ0ZsaXAgMS43cyBpbmZpbml0ZTtcXG59XFxuXFxuLmZvdXJ0aC50cmFuc2NyaWJpbmcge1xcbiAgLS1vcmlnaW5hbC1jb2xvcjogIzliZDA3ODtcXG4gIC0tdHJhbnNjcmliaW5nLWNvbG9yOiAjMzU4NmZmO1xcbiAgYW5pbWF0aW9uOiB0cmFuc2NyaWJpbmdGbGlwIDEuOHMgaW5maW5pdGU7XFxufVxcblxcbi5maWZ0aC50cmFuc2NyaWJpbmcge1xcbiAgLS1vcmlnaW5hbC1jb2xvcjogIzgzYzU1YztcXG4gIC0tdHJhbnNjcmliaW5nLWNvbG9yOiAjMGI2OWUzO1xcbiAgYW5pbWF0aW9uOiB0cmFuc2NyaWJpbmdGbGlwIDEuOXMgaW5maW5pdGU7XFxufVxcblxcbi5pbm5lcm1vc3QudHJhbnNjcmliaW5nIHtcXG4gIC0tb3JpZ2luYWwtY29sb3I6ICM0MjhhMmY7XFxuICAtLXRyYW5zY3JpYmluZy1jb2xvcjogIzAwNTNiZjtcXG4gIGFuaW1hdGlvbjogdHJhbnNjcmliaW5nRmxpcCAycyBpbmZpbml0ZTtcXG59XFxuXFxuLyogaGVhcnRiZWF0IGFuaW1hdGlvbiB0byBpbmRpY2F0ZSBQaSBpcyBwcmVwYXJpbmcgdG8gc3BlYWsgKi9cXG5Aa2V5ZnJhbWVzIGhlYXJ0YmVhdCB7XFxuICAwJSxcXG4gIDEwMCUge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICBmaWxsOiB2YXIoLS1vcmlnaW5hbC1jb2xvcik7XFxuICB9XFxuICA1MCUge1xcbiAgICBvcGFjaXR5OiAwLjU7XFxuICAgIGZpbGw6IHJnYigyNDUgMjM4IDIyMyk7IC8qIGJnLWNyZWFtLTU1MCAqL1xcbiAgfVxcbn1cXG5cXG4vKiB0b25lZC1kb3duIGRpc3NhcnkgYW5pbWF0aW9uIHRvIGluZGljYXRlIGFuIGVycm9yICovXFxuLyogdG9uZWQtZG93biBlcnJvciBhbmltYXRpb24gd2l0aCByZWR1Y2VkIG9wYWNpdHkgKi9cXG5Aa2V5ZnJhbWVzIGVycm9yQW5pbWF0aW9uIHtcXG4gIDAlIHtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZykgdHJhbnNsYXRlKDAlLCAwJSk7XFxuICB9XFxuICAyNSUge1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtNWRlZykgdHJhbnNsYXRlKC01JSwgNSUpO1xcbiAgfVxcbiAgNTAlIHtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoNWRlZykgdHJhbnNsYXRlKDUlLCAtNSUpO1xcbiAgfVxcbiAgNzUlIHtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoLTVkZWcpIHRyYW5zbGF0ZSgtNSUsIDUlKTtcXG4gIH1cXG4gIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKSB0cmFuc2xhdGUoMCUsIDAlKTtcXG4gIH1cXG59XFxuXFxuLm91dGVybW9zdC5lcnJvciB7XFxuICBhbmltYXRpb246IGVycm9yQW5pbWF0aW9uIDI1cyAxO1xcbiAgZmlsbDogI2ZmMDAwMDtcXG4gIGZpbGwtb3BhY2l0eTogMC43O1xcbn1cXG5cXG4uc2Vjb25kLmVycm9yIHtcXG4gIGFuaW1hdGlvbjogZXJyb3JBbmltYXRpb24gMjVzIDE7XFxuICBmaWxsOiAjZmYzMzAwO1xcbiAgZmlsbC1vcGFjaXR5OiAwLjc7XFxufVxcblxcbi50aGlyZC5lcnJvciB7XFxuICBhbmltYXRpb246IGVycm9yQW5pbWF0aW9uIDI1cyAxO1xcbiAgZmlsbDogI2ZmNjYwMDtcXG4gIGZpbGwtb3BhY2l0eTogMC43O1xcbn1cXG5cXG4uZm91cnRoLmVycm9yIHtcXG4gIGFuaW1hdGlvbjogZXJyb3JBbmltYXRpb24gMjVzIDE7XFxuICBmaWxsOiAjZmY5OTAwO1xcbiAgZmlsbC1vcGFjaXR5OiAwLjc7XFxufVxcblxcbi5maWZ0aC5lcnJvciB7XFxuICBhbmltYXRpb246IGVycm9yQW5pbWF0aW9uIDI1cyAxO1xcbiAgZmlsbDogI2ZmY2MwMDtcXG4gIGZpbGwtb3BhY2l0eTogMC43O1xcbn1cXG5cXG4uaW5uZXJtb3N0LmVycm9yIHtcXG4gIGFuaW1hdGlvbjogZXJyb3JBbmltYXRpb24gMjVzIDE7XFxuICBmaWxsOiAjZmZmZjAwO1xcbiAgZmlsbC1vcGFjaXR5OiAwLjc7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgLmhpZGRlbiB7XG4gIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbn1cblxuI3NheXBpLWNhbGxCdXR0b24uZGlzYWJsZWQgc3ZnIHBhdGguY2lyY2xlIHtcbiAgZmlsbDogcmdiKDI0NSwgMjM4LCAyMjMpOyAvKiBiZy1jcmVhbS01NTAgKi9cbn1cblxuLm1vYmlsZS1kZXZpY2Uge1xuICAvKiBtYXhpbWl6ZSAobW9iaWxlIHZpZXcpIGJ1dHRvbiBpcyBvbmx5IGRpc3BsYXllZCBvbiBjb21wYXRpYmxlIGRldmljZXMgKi9cbn1cbi5tb2JpbGUtZGV2aWNlICNzYXlwaS1lbnRlckJ1dHRvbixcbi5tb2JpbGUtZGV2aWNlICNzYXlwaS1leGl0QnV0dG9uIHtcbiAgcG9zaXRpb246IGZpeGVkO1xuICB0b3A6IDRyZW07XG4gIGxlZnQ6IDEwcHg7XG4gIHdpZHRoOiAzcmVtO1xuICBoZWlnaHQ6IDNyZW07XG4gIHBhZGRpbmc6IDZweDtcbiAgYm9yZGVyOiAwO1xuICB6LWluZGV4OiA2MDtcbn1cbi5tb2JpbGUtZGV2aWNlICNzYXlwaS1lbnRlckJ1dHRvbiBzdmcgcGF0aC5pbm5lcixcbi5tb2JpbGUtZGV2aWNlICNzYXlwaS1leGl0QnV0dG9uIHN2ZyBwYXRoLmlubmVyIHtcbiAgY29sb3I6IHJnYigxMywgNjAsIDM4KTsgLyogdGV4dC1wcmltYXJ5LTcwMCAqL1xufWAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL3N0eWxlcy9jb21tb24uc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLHdCQUFBO0FBQ0Y7O0FBRUE7RUFDRSx3QkFBQSxFQUFBLGlCQUFBO0FBQ0Y7O0FBRUE7RUFDRSwwRUFBQTtBQUNGO0FBQUU7O0VBRUUsZUFBQTtFQUNBLFNBQUE7RUFDQSxVQUFBO0VBQ0EsV0FBQTtFQUNBLFlBQUE7RUFDQSxZQUFBO0VBQ0EsU0FBQTtFQUNBLFdBQUE7QUFFSjtBQURJOztFQUNFLHNCQUFBLEVBQUEscUJBQUE7QUFJTlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuaGlkZGVuIHtcXG4gIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuXFxuI3NheXBpLWNhbGxCdXR0b24uZGlzYWJsZWQgc3ZnIHBhdGguY2lyY2xlIHtcXG4gIGZpbGw6IHJnYigyNDUgMjM4IDIyMyk7IC8qIGJnLWNyZWFtLTU1MCAqL1xcbn1cXG5cXG4ubW9iaWxlLWRldmljZSB7XFxuICAvKiBtYXhpbWl6ZSAobW9iaWxlIHZpZXcpIGJ1dHRvbiBpcyBvbmx5IGRpc3BsYXllZCBvbiBjb21wYXRpYmxlIGRldmljZXMgKi9cXG4gICNzYXlwaS1lbnRlckJ1dHRvbixcXG4gICNzYXlwaS1leGl0QnV0dG9uIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB0b3A6IDRyZW07XFxuICAgIGxlZnQ6IDEwcHg7XFxuICAgIHdpZHRoOiAzcmVtO1xcbiAgICBoZWlnaHQ6IDNyZW07XFxuICAgIHBhZGRpbmc6IDZweDtcXG4gICAgYm9yZGVyOiAwO1xcbiAgICB6LWluZGV4OiA2MDtcXG4gICAgc3ZnIHBhdGguaW5uZXIge1xcbiAgICAgIGNvbG9yOiByZ2IoMTMgNjAgMzgpOyAvKiB0ZXh0LXByaW1hcnktNzAwICovXFxuICAgIH1cXG4gIH1cXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGBAa2V5ZnJhbWVzIHB1bHNlIHtcbiAgMCUge1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XG4gIH1cbiAgNTAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOSk7XG4gIH1cbiAgMTAwJSB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcbiAgfVxufVxuaHRtbC5kZXNrdG9wLXZpZXcgI3NheXBpLXRhbGtCdXR0b24ge1xuICAvKiBub3QgbmVlZGVkIG9uIGRlc2t0b3Agd2l0aCBjYWxsIGJ1dHRvbiAqL1xuICBkaXNwbGF5OiBub25lO1xufVxuaHRtbC5kZXNrdG9wLXZpZXcgI3NheXBpLWNhbGxCdXR0b24ge1xuICBoZWlnaHQ6IDIuMjVyZW07XG4gIHdpZHRoOiAyLjI1cmVtO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIG1hcmdpbjogMC41cmVtIDAgMC41cmVtIDA7XG59XG5odG1sLmRlc2t0b3AtdmlldyAuc2F5cGktcHJvbXB0LWNvbnRhaW5lciB7XG4gIC8qIG1ha2Ugcm9vbSBpbiB0aGUgcHJvbXB0IHRleHQgYXJlYSBmb3IgdGhlIGNhbGwgYnV0dG9uICovXG4gIHBhZGRpbmctcmlnaHQ6IDA7XG59XG5odG1sLmRlc2t0b3AtdmlldyAjc2F5cGktbm90aWZpY2F0aW9uID4gc3ZnIHtcbiAgd2lkdGg6IDNyZW07XG4gIGhlaWdodDogM3JlbTtcbiAgYm90dG9tOiA0cmVtO1xuICByaWdodDogMTJyZW07XG4gIHBvc2l0aW9uOiBmaXhlZDtcbn1cbmh0bWwuZGVza3RvcC12aWV3ICNzYXlwaS1leGl0QnV0dG9uIHtcbiAgZGlzcGxheTogbm9uZTtcbn1gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZXMvZGVza3RvcC5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUNFO0VBQ0U7SUFDRSxtQkFBQTtFQUFKO0VBRUU7SUFDRSxxQkFBQTtFQUFKO0VBRUU7SUFDRSxtQkFBQTtFQUFKO0FBQ0Y7QUFHRTtFQUNFLDJDQUFBO0VBQ0EsYUFBQTtBQURKO0FBSUU7RUFDRSxlQUFBO0VBQ0EsY0FBQTtFQUNBLGtCQUFBO0VBQ0EseUJBQUE7QUFGSjtBQUtFO0VBQ0UsMERBQUE7RUFDQSxnQkFBQTtBQUhKO0FBTUU7RUFDRSxXQUFBO0VBQ0EsWUFBQTtFQUNBLFlBQUE7RUFDQSxZQUFBO0VBQ0EsZUFBQTtBQUpKO0FBT0U7RUFDRSxhQUFBO0FBTEpcIixcInNvdXJjZXNDb250ZW50XCI6W1wiaHRtbC5kZXNrdG9wLXZpZXcge1xcbiAgQGtleWZyYW1lcyBwdWxzZSB7XFxuICAgIDAlIHtcXG4gICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICB9XFxuICAgIDUwJSB7XFxuICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjkpO1xcbiAgICB9XFxuICAgIDEwMCUge1xcbiAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gICNzYXlwaS10YWxrQnV0dG9uIHtcXG4gICAgLyogbm90IG5lZWRlZCBvbiBkZXNrdG9wIHdpdGggY2FsbCBidXR0b24gKi9cXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG5cXG4gICNzYXlwaS1jYWxsQnV0dG9uIHtcXG4gICAgaGVpZ2h0OiAyLjI1cmVtO1xcbiAgICB3aWR0aDogMi4yNXJlbTtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBtYXJnaW46IDAuNXJlbSAwIDAuNXJlbSAwO1xcbiAgfVxcblxcbiAgLnNheXBpLXByb21wdC1jb250YWluZXIge1xcbiAgICAvKiBtYWtlIHJvb20gaW4gdGhlIHByb21wdCB0ZXh0IGFyZWEgZm9yIHRoZSBjYWxsIGJ1dHRvbiAqL1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAwO1xcbiAgfVxcblxcbiAgI3NheXBpLW5vdGlmaWNhdGlvbiA+IHN2ZyB7XFxuICAgIHdpZHRoOiAzcmVtO1xcbiAgICBoZWlnaHQ6IDNyZW07XFxuICAgIGJvdHRvbTogNHJlbTtcXG4gICAgcmlnaHQ6IDEycmVtO1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICB9XFxuXFxuICAjc2F5cGktZXhpdEJ1dHRvbiB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICB9XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgaHRtbC5tb2JpbGUtdmlldyB7XG4gIC8qIFBpIGNvbnRyb2xzOiBlbGxpcHNpcywgZXhwZXJpZW5jZXMgKi9cbiAgLyogaGlkZSBhbiB1Z2x5IGFydGlmYWN0ICovXG4gIC8qIFBpIGNvbnRyb2xzOiBtdXRlL3VubXV0ZSAqL1xuICAvKiBmaXggYW4gYWxpZ25tZW50IGlzc3VlIHdpdGggdGhlIFwibmV3IHVpIGxheW91dFwiICovXG59XG5odG1sLm1vYmlsZS12aWV3ICNzYXlwaS1wYW5lbCxcbmh0bWwubW9iaWxlLXZpZXcgLm5vdGlmaWNhdGlvbiB7XG4gIHdpZHRoOiAxMDAlO1xuICBwb3NpdGlvbjogZml4ZWQ7XG4gIGxlZnQ6IDA7XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQ1LCAyMzgsIDIyMywgMC45OCk7XG4gIGhlaWdodDogMTAwc3ZoO1xuICB0b3A6IDA7XG59XG5odG1sLm1vYmlsZS12aWV3ICNzYXlwaS10YWxrQnV0dG9uIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gIGJvcmRlci1yYWRpdXM6IDA7XG4gIG1hcmdpbjogMDtcbn1cbmh0bWwubW9iaWxlLXZpZXcgI3NheXBpLXRhbGtCdXR0b24gc3ZnIHtcbiAgd2lkdGg6IDEwMHZ3O1xuICBoZWlnaHQ6IDEwMHN2aDtcbn1cbmh0bWwubW9iaWxlLXZpZXcgI3NheXBpLW5vdGlmaWNhdGlvbiB7XG4gIHotaW5kZXg6IDEwMDtcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG59XG5odG1sLm1vYmlsZS12aWV3ICNzYXlwaS1ub3RpZmljYXRpb24gc3ZnIHtcbiAgd2lkdGg6IDc1JTtcbiAgaGVpZ2h0OiAxMDAlO1xuICBtYXJnaW46IGF1dG87XG59XG5odG1sLm1vYmlsZS12aWV3ICNfX25leHQgPiBtYWluID4gZGl2ID4gZGl2ID4gZGl2LmZpeGVkLnRvcC00LnJpZ2h0LTYgPiBidXR0b24sXG5odG1sLm1vYmlsZS12aWV3ICNzYXlwaS1leHBlcmllbmNlcy1idXR0b24ge1xuICB0cmFuc2Zvcm06IHNjYWxlKDEuNSk7XG59XG5odG1sLm1vYmlsZS12aWV3IGRpdi5iZy1ncmFkaWVudC10by1iIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cbmh0bWwubW9iaWxlLXZpZXcgI3NheXBpLWF1ZGlvLWNvbnRyb2xzIHtcbiAgLyogaGlkZSB0aGUgdm9pY2Ugb3B0aW9ucyAqL1xuICAvKiBzY2FsZSB0aGUgbXV0ZSBidXR0b24gKi9cbn1cbmh0bWwubW9iaWxlLXZpZXcgI3NheXBpLWF1ZGlvLWNvbnRyb2xzIGRpdi5wLTEge1xuICBkaXNwbGF5OiBub25lO1xufVxuaHRtbC5tb2JpbGUtdmlldyAjc2F5cGktYXVkaW8tY29udHJvbHMgYnV0dG9uLmdyb3VwIHtcbiAgdHJhbnNmb3JtOiBzY2FsZSgyKSAhaW1wb3J0YW50O1xuICB6LWluZGV4OiA1MDtcbiAgLyogaGlkZSB0aGUgdm9pY2Ugc2VsZWN0b3IgdHdpc3R5ICovXG59XG5odG1sLm1vYmlsZS12aWV3ICNzYXlwaS1hdWRpby1jb250cm9scyBidXR0b24uZ3JvdXAgKyBidXR0b24ge1xuICBkaXNwbGF5OiBub25lO1xufVxuaHRtbC5tb2JpbGUtdmlldyAudGV4dC1ib2R5LWNoYXQtbSB7XG4gIHBhZGRpbmctdG9wOiAwO1xufVxuaHRtbC5tb2JpbGUtdmlldyAjc2F5cGktZW50ZXJCdXR0b24ge1xuICBkaXNwbGF5OiBub25lO1xufVxuaHRtbC5tb2JpbGUtdmlldyAjc2F5cGktZm9vdGVyIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cbmh0bWwubW9iaWxlLXZpZXcgI3NheXBpLXByb21wdC1hbmNlc3RvciB7XG4gIC8qIGhpZGVzIHRoZSByb3cgY29udGFpbmluZyB0aGUgdGV4dCBhcmVhIGNvbnRyb2wgKi9cbiAgLyogaW1wb3J0YW50OiBoaWRlcyB2aXJ0dWFsIGtleWJvYXJkIG9uIGFuZHJvaWQgKi9cbiAgZGlzcGxheTogbm9uZTtcbiAgLyogdGhlIGNhbGwgYnV0dG9uLCB1c3VhbGx5IG5lc3RlZCBpbiB0aGUgcHJvbXB0LCBpcyBkZXRhY2hlZCB3aGlsZSBpbiBtb2JpbGUgdmlldyAqL1xufVxuaHRtbC5tb2JpbGUtdmlldyAjc2F5cGktc3VibWl0QnV0dG9uIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cbmh0bWwubW9iaWxlLXZpZXcgI3NheXBpLWNhbGxCdXR0b24ge1xuICBwb3NpdGlvbjogZml4ZWQ7XG4gIGJvdHRvbTogNHJlbTtcbiAgbGVmdDogMDtcbiAgcmlnaHQ6IDA7XG4gIG1hcmdpbjogYXV0bztcbiAgd2lkdGg6IDQuNXJlbTtcbiAgaGVpZ2h0OiA0LjVyZW07XG4gIHBhZGRpbmc6IDZweDtcbiAgYm9yZGVyOiAwO1xuICB6LWluZGV4OiA4MDtcbn1gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZXMvbW9iaWxlLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFnQ0UsdUNBQUE7RUFNQSwwQkFBQTtFQUtBLDZCQUFBO0VBaUJBLG9EQUFBO0FBdkRGO0FBSkU7O0VBRUUsV0FBQTtFQUNBLGVBQUE7RUFDQSxPQUFBO0VBQ0EsMkNBQUE7RUFFQSxjQUFBO0VBQ0EsTUFBQTtBQUtKO0FBRkU7RUFDRSw2QkFBQTtFQUNBLGdCQUFBO0VBQ0EsU0FBQTtBQUlKO0FBSEk7RUFDRSxZQUFBO0VBQ0EsY0FBQTtBQUtOO0FBREU7RUFDRSxZQUFBO0VBQ0EsNkJBQUE7QUFHSjtBQUZJO0VBQ0UsVUFBQTtFQUNBLFlBQUE7RUFDQSxZQUFBO0FBSU47QUFDRTs7RUFFRSxxQkFBQTtBQUNKO0FBR0U7RUFDRSxhQUFBO0FBREo7QUFLRTtFQUNFLDJCQUFBO0VBSUEsMEJBQUE7QUFOSjtBQUdJO0VBQ0UsYUFBQTtBQUROO0FBSUk7RUFDRSw4QkFBQTtFQUNBLFdBQUE7RUFDQSxtQ0FBQTtBQUZOO0FBR007RUFDRSxhQUFBO0FBRFI7QUFPRTtFQUNFLGNBQUE7QUFMSjtBQVFFO0VBQ0UsYUFBQTtBQU5KO0FBU0U7RUFDRSxhQUFBO0FBUEo7QUFVRTtFQUNFLG1EQUFBO0VBQ0EsaURBQUE7RUFDQSxhQUFBO0VBQ0Esb0ZBQUE7QUFSSjtBQVdFO0VBQ0UsYUFBQTtBQVRKO0FBWUU7RUFDRSxlQUFBO0VBQ0EsWUFBQTtFQUNBLE9BQUE7RUFDQSxRQUFBO0VBQ0EsWUFBQTtFQUNBLGFBQUE7RUFDQSxjQUFBO0VBQ0EsWUFBQTtFQUNBLFNBQUE7RUFDQSxXQUFBO0FBVkpcIixcInNvdXJjZXNDb250ZW50XCI6W1wiaHRtbC5tb2JpbGUtdmlldyB7XFxuICAjc2F5cGktcGFuZWwsXFxuICAubm90aWZpY2F0aW9uIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgbGVmdDogMDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNDUsIDIzOCwgMjIzLCAwLjk4KTtcXG5cXG4gICAgaGVpZ2h0OiAxMDBzdmg7XFxuICAgIHRvcDogMDtcXG4gIH1cXG5cXG4gICNzYXlwaS10YWxrQnV0dG9uIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgc3ZnIHtcXG4gICAgICB3aWR0aDogMTAwdnc7XFxuICAgICAgaGVpZ2h0OiAxMDBzdmg7XFxuICAgIH1cXG4gIH1cXG5cXG4gICNzYXlwaS1ub3RpZmljYXRpb24ge1xcbiAgICB6LWluZGV4OiAxMDA7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBzdmcge1xcbiAgICAgIHdpZHRoOiA3NSU7XFxuICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAgIG1hcmdpbjogYXV0bztcXG4gICAgfVxcbiAgfVxcblxcbiAgLyogUGkgY29udHJvbHM6IGVsbGlwc2lzLCBleHBlcmllbmNlcyAqL1xcbiAgI19fbmV4dCA+IG1haW4gPiBkaXYgPiBkaXYgPiBkaXYuZml4ZWQudG9wLTQucmlnaHQtNiA+IGJ1dHRvbixcXG4gICNzYXlwaS1leHBlcmllbmNlcy1idXR0b24ge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEuNSk7XFxuICB9XFxuXFxuICAvKiBoaWRlIGFuIHVnbHkgYXJ0aWZhY3QgKi9cXG4gIGRpdi5iZy1ncmFkaWVudC10by1iIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG5cXG4gIC8qIFBpIGNvbnRyb2xzOiBtdXRlL3VubXV0ZSAqL1xcbiAgI3NheXBpLWF1ZGlvLWNvbnRyb2xzIHtcXG4gICAgLyogaGlkZSB0aGUgdm9pY2Ugb3B0aW9ucyAqL1xcbiAgICBkaXYucC0xIHtcXG4gICAgICBkaXNwbGF5OiBub25lO1xcbiAgICB9XFxuICAgIC8qIHNjYWxlIHRoZSBtdXRlIGJ1dHRvbiAqL1xcbiAgICBidXR0b24uZ3JvdXAge1xcbiAgICAgIHRyYW5zZm9ybTogc2NhbGUoMikgIWltcG9ydGFudDtcXG4gICAgICB6LWluZGV4OiA1MDtcXG4gICAgICAvKiBoaWRlIHRoZSB2b2ljZSBzZWxlY3RvciB0d2lzdHkgKi9cXG4gICAgICArIGJ1dHRvbiB7XFxuICAgICAgICBkaXNwbGF5OiBub25lO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgLyogZml4IGFuIGFsaWdubWVudCBpc3N1ZSB3aXRoIHRoZSBcXFwibmV3IHVpIGxheW91dFxcXCIgKi9cXG4gIC50ZXh0LWJvZHktY2hhdC1tIHtcXG4gICAgcGFkZGluZy10b3A6IDA7XFxuICB9XFxuXFxuICAjc2F5cGktZW50ZXJCdXR0b24ge1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcblxcbiAgI3NheXBpLWZvb3RlciB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICB9XFxuXFxuICAjc2F5cGktcHJvbXB0LWFuY2VzdG9yIHtcXG4gICAgLyogaGlkZXMgdGhlIHJvdyBjb250YWluaW5nIHRoZSB0ZXh0IGFyZWEgY29udHJvbCAqL1xcbiAgICAvKiBpbXBvcnRhbnQ6IGhpZGVzIHZpcnR1YWwga2V5Ym9hcmQgb24gYW5kcm9pZCAqL1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgICAvKiB0aGUgY2FsbCBidXR0b24sIHVzdWFsbHkgbmVzdGVkIGluIHRoZSBwcm9tcHQsIGlzIGRldGFjaGVkIHdoaWxlIGluIG1vYmlsZSB2aWV3ICovXFxuICB9XFxuXFxuICAjc2F5cGktc3VibWl0QnV0dG9uIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG5cXG4gICNzYXlwaS1jYWxsQnV0dG9uIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBib3R0b206IDRyZW07XFxuICAgIGxlZnQ6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBtYXJnaW46IGF1dG87XFxuICAgIHdpZHRoOiA0LjVyZW07XFxuICAgIGhlaWdodDogNC41cmVtO1xcbiAgICBwYWRkaW5nOiA2cHg7XFxuICAgIGJvcmRlcjogMDtcXG4gICAgei1pbmRleDogODA7XFxuICB9XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcpIHtcbiAgdmFyIGxpc3QgPSBbXTtcblxuICAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2YgaXRlbVs1XSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIik7XG4gICAgICB9XG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnRlbnQgKz0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTtcblxuICAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICBsaXN0LmkgPSBmdW5jdGlvbiBpKG1vZHVsZXMsIG1lZGlhLCBkZWR1cGUsIHN1cHBvcnRzLCBsYXllcikge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgdW5kZWZpbmVkXV07XG4gICAgfVxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXNba11bMF07XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBtb2R1bGVzLmxlbmd0aDsgX2srKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfa10pO1xuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsYXllciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW1bNV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3VwcG9ydHMpIHtcbiAgICAgICAgaWYgKCFpdGVtWzRdKSB7XG4gICAgICAgICAgaXRlbVs0XSA9IFwiXCIuY29uY2F0KHN1cHBvcnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNF0gPSBzdXBwb3J0cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiIsIi8qIVxuKiBPTk5YIFJ1bnRpbWUgV2ViIHYxLjE1LjFcbiogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiovXG4hZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLm9ydD10KCk6ZS5vcnQ9dCgpfShzZWxmLCgoKT0+KCgpPT57dmFyIF9fd2VicGFja19tb2R1bGVzX189ezg0NTM6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO24ucih0KSxuLmQodCx7SW5mZXJlbmNlU2Vzc2lvbjooKT0+ZixUZW5zb3I6KCk9PnAsZW52OigpPT5hLHJlZ2lzdGVyQmFja2VuZDooKT0+aX0pO2NvbnN0IHI9e30sbz1bXSxpPShlLHQsbik9PntpZighdHx8XCJmdW5jdGlvblwiIT10eXBlb2YgdC5pbml0fHxcImZ1bmN0aW9uXCIhPXR5cGVvZiB0LmNyZWF0ZVNlc3Npb25IYW5kbGVyKXRocm93IG5ldyBUeXBlRXJyb3IoXCJub3QgYSB2YWxpZCBiYWNrZW5kXCIpO3tjb25zdCBpPXJbZV07aWYodm9pZCAwPT09aSlyW2VdPXtiYWNrZW5kOnQscHJpb3JpdHk6bn07ZWxzZXtpZihpLnByaW9yaXR5Pm4pcmV0dXJuO2lmKGkucHJpb3JpdHk9PT1uJiZpLmJhY2tlbmQhPT10KXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlZ2lzdGVyIGJhY2tlbmQgXCIke2V9XCIgdXNpbmcgcHJpb3JpdHkgJHtufWApfWlmKG4+PTApe2NvbnN0IHQ9by5pbmRleE9mKGUpOy0xIT09dCYmby5zcGxpY2UodCwxKTtmb3IobGV0IHQ9MDt0PG8ubGVuZ3RoO3QrKylpZihyW29bdF1dLnByaW9yaXR5PD1uKXJldHVybiB2b2lkIG8uc3BsaWNlKHQsMCxlKTtvLnB1c2goZSl9fX0sYT1uZXcgY2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLndhc209e30sdGhpcy53ZWJnbD17fSx0aGlzLndlYmdwdT17fSx0aGlzLmxvZ0xldmVsSW50ZXJuYWw9XCJ3YXJuaW5nXCJ9c2V0IGxvZ0xldmVsKGUpe2lmKHZvaWQgMCE9PWUpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlfHwtMT09PVtcInZlcmJvc2VcIixcImluZm9cIixcIndhcm5pbmdcIixcImVycm9yXCIsXCJmYXRhbFwiXS5pbmRleE9mKGUpKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApO3RoaXMubG9nTGV2ZWxJbnRlcm5hbD1lfX1nZXQgbG9nTGV2ZWwoKXtyZXR1cm4gdGhpcy5sb2dMZXZlbEludGVybmFsfX0scz1uZXcgTWFwKFtbXCJmbG9hdDMyXCIsRmxvYXQzMkFycmF5XSxbXCJ1aW50OFwiLFVpbnQ4QXJyYXldLFtcImludDhcIixJbnQ4QXJyYXldLFtcInVpbnQxNlwiLFVpbnQxNkFycmF5XSxbXCJpbnQxNlwiLEludDE2QXJyYXldLFtcImludDMyXCIsSW50MzJBcnJheV0sW1wiYm9vbFwiLFVpbnQ4QXJyYXldLFtcImZsb2F0NjRcIixGbG9hdDY0QXJyYXldLFtcInVpbnQzMlwiLFVpbnQzMkFycmF5XV0pLHU9bmV3IE1hcChbW0Zsb2F0MzJBcnJheSxcImZsb2F0MzJcIl0sW1VpbnQ4QXJyYXksXCJ1aW50OFwiXSxbSW50OEFycmF5LFwiaW50OFwiXSxbVWludDE2QXJyYXksXCJ1aW50MTZcIl0sW0ludDE2QXJyYXksXCJpbnQxNlwiXSxbSW50MzJBcnJheSxcImludDMyXCJdLFtGbG9hdDY0QXJyYXksXCJmbG9hdDY0XCJdLFtVaW50MzJBcnJheSxcInVpbnQzMlwiXV0pO2xldCBsPSExO2NsYXNzIGN7Y29uc3RydWN0b3IoZSx0LG4pe2xldCByLG8saTtpZigoKCk9PntpZighbCl7bD0hMDtjb25zdCBlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBCaWdJbnQ2NEFycmF5JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBCaWdJbnQ2NEFycmF5LmZyb20sdD1cInVuZGVmaW5lZFwiIT10eXBlb2YgQmlnVWludDY0QXJyYXkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIEJpZ1VpbnQ2NEFycmF5LmZyb207ZSYmKHMuc2V0KFwiaW50NjRcIixCaWdJbnQ2NEFycmF5KSx1LnNldChCaWdJbnQ2NEFycmF5LFwiaW50NjRcIikpLHQmJihzLnNldChcInVpbnQ2NFwiLEJpZ1VpbnQ2NEFycmF5KSx1LnNldChCaWdVaW50NjRBcnJheSxcInVpbnQ2NFwiKSl9fSkoKSxcInN0cmluZ1wiPT10eXBlb2YgZSlpZihyPWUsaT1uLFwic3RyaW5nXCI9PT1lKXtpZighQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBzdHJpbmcgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGFycmF5LlwiKTtvPXR9ZWxzZXtjb25zdCBuPXMuZ2V0KGUpO2lmKHZvaWQgMD09PW4pdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdGVuc29yIHR5cGU6ICR7ZX0uYCk7aWYoQXJyYXkuaXNBcnJheSh0KSlvPW4uZnJvbSh0KTtlbHNle2lmKCEodCBpbnN0YW5jZW9mIG4pKXRocm93IG5ldyBUeXBlRXJyb3IoYEEgJHtyfSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiAke259YCk7bz10fX1lbHNlIGlmKGk9dCxBcnJheS5pc0FycmF5KGUpKXtpZigwPT09ZS5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRlbnNvciB0eXBlIGNhbm5vdCBiZSBpbmZlcnJlZCBmcm9tIGFuIGVtcHR5IGFycmF5LlwiKTtjb25zdCB0PXR5cGVvZiBlWzBdO2lmKFwic3RyaW5nXCI9PT10KXI9XCJzdHJpbmdcIixvPWU7ZWxzZXtpZihcImJvb2xlYW5cIiE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBlbGVtZW50IHR5cGUgb2YgZGF0YSBhcnJheTogJHt0fS5gKTtyPVwiYm9vbFwiLG89VWludDhBcnJheS5mcm9tKGUpfX1lbHNle2NvbnN0IHQ9dS5nZXQoZS5jb25zdHJ1Y3Rvcik7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIGZvciB0ZW5zb3IgZGF0YTogJHtlLmNvbnN0cnVjdG9yfS5gKTtyPXQsbz1lfWlmKHZvaWQgMD09PWkpaT1bby5sZW5ndGhdO2Vsc2UgaWYoIUFycmF5LmlzQXJyYXkoaSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgdGVuc29yJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5XCIpO2NvbnN0IGE9KGU9PntsZXQgdD0xO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtjb25zdCByPWVbbl07aWYoXCJudW1iZXJcIiE9dHlwZW9mIHJ8fCFOdW1iZXIuaXNTYWZlSW50ZWdlcihyKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBkaW1zWyR7bn1dIG11c3QgYmUgYW4gaW50ZWdlciwgZ290OiAke3J9YCk7aWYocjwwKXRocm93IG5ldyBSYW5nZUVycm9yKGBkaW1zWyR7bn1dIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290OiAke3J9YCk7dCo9cn1yZXR1cm4gdH0pKGkpO2lmKGEhPT1vLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvcidzIHNpemUoJHthfSkgZG9lcyBub3QgbWF0Y2ggZGF0YSBsZW5ndGgoJHtvLmxlbmd0aH0pLmApO3RoaXMuZGltcz1pLHRoaXMudHlwZT1yLHRoaXMuZGF0YT1vLHRoaXMuc2l6ZT1hfXN0YXRpYyBidWZmZXJUb1RlbnNvcihlLHQpe2lmKHZvaWQgMD09PWUpdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgYnVmZmVyIG11c3QgYmUgZGVmaW5lZFwiKTtpZih2b2lkIDA9PT10LmhlaWdodHx8dm9pZCAwPT09dC53aWR0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBoZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgZGVmaW5lZFwiKTtpZihcIk5IV0NcIj09PXQudGVuc29yTGF5b3V0KXRocm93IG5ldyBFcnJvcihcIk5IV0MgVGVuc29yIGxheW91dCBpcyBub3Qgc3VwcG9ydGVkIHlldFwiKTtjb25zdHtoZWlnaHQ6bix3aWR0aDpyfT10LG89dC5ub3JtPz97bWVhbjoyNTUsYmlhczowfTtsZXQgaSxhO2k9XCJudW1iZXJcIj09dHlwZW9mIG8ubWVhbj9bby5tZWFuLG8ubWVhbixvLm1lYW4sby5tZWFuXTpbby5tZWFuWzBdLG8ubWVhblsxXSxvLm1lYW5bMl0sby5tZWFuWzNdPz8yNTVdLGE9XCJudW1iZXJcIj09dHlwZW9mIG8uYmlhcz9bby5iaWFzLG8uYmlhcyxvLmJpYXMsby5iaWFzXTpbby5iaWFzWzBdLG8uYmlhc1sxXSxvLmJpYXNbMl0sby5iaWFzWzNdPz8wXTtjb25zdCBzPXZvaWQgMCE9PXQuYml0bWFwRm9ybWF0P3QuYml0bWFwRm9ybWF0OlwiUkdCQVwiLHU9dm9pZCAwIT09dC50ZW5zb3JGb3JtYXQmJnZvaWQgMCE9PXQudGVuc29yRm9ybWF0P3QudGVuc29yRm9ybWF0OlwiUkdCXCIsbD1uKnIscD1cIlJHQkFcIj09PXU/bmV3IEZsb2F0MzJBcnJheSg0KmwpOm5ldyBGbG9hdDMyQXJyYXkoMypsKTtsZXQgZD00LGY9MCxoPTEsZz0yLG09MyxiPTAseT1sLHc9MipsLF89LTE7XCJSR0JcIj09PXMmJihkPTMsZj0wLGg9MSxnPTIsbT0tMSksXCJSR0JBXCI9PT11P189MypsOlwiUkJHXCI9PT11PyhiPTAsdz1sLHk9MipsKTpcIkJHUlwiPT09dSYmKHc9MCx5PWwsYj0yKmwpO2ZvcihsZXQgdD0wO3Q8bDt0KyssZis9ZCxnKz1kLGgrPWQsbSs9ZClwW2IrK109KGVbZl0rYVswXSkvaVswXSxwW3krK109KGVbaF0rYVsxXSkvaVsxXSxwW3crK109KGVbZ10rYVsyXSkvaVsyXSwtMSE9PV8mJi0xIT09bSYmKHBbXysrXT0oZVttXSthWzNdKS9pWzNdKTtyZXR1cm4gbmV3IGMoXCJmbG9hdDMyXCIscCxcIlJHQkFcIj09PXU/WzEsNCxuLHJdOlsxLDMsbixyXSl9c3RhdGljIGFzeW5jIGZyb21JbWFnZShlLHQpe2NvbnN0IG49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQmJmUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50LHI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEltYWdlRGF0YSYmZSBpbnN0YW5jZW9mIEltYWdlRGF0YSxvPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBJbWFnZUJpdG1hcCYmZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwLGk9XCJzdHJpbmdcIj09dHlwZW9mIGU7bGV0IGEscz10Pz97fTtpZihuKXtjb25zdCBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7bi53aWR0aD1lLndpZHRoLG4uaGVpZ2h0PWUuaGVpZ2h0O2NvbnN0IHI9bi5nZXRDb250ZXh0KFwiMmRcIik7aWYobnVsbD09cil0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpO3tsZXQgbj1lLmhlaWdodCxvPWUud2lkdGg7aWYodm9pZCAwIT09dCYmdm9pZCAwIT09dC5yZXNpemVkSGVpZ2h0JiZ2b2lkIDAhPT10LnJlc2l6ZWRXaWR0aCYmKG49dC5yZXNpemVkSGVpZ2h0LG89dC5yZXNpemVkV2lkdGgpLHZvaWQgMCE9PXQpe2lmKHM9dCx2b2lkIDAhPT10LnRlbnNvckZvcm1hdCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgUkdCQSBmb3IgSFRNTEltYWdlRWxlbWVudFwiKTtpZihzLnRlbnNvckZvcm1hdD1cIlJHQkFcIix2b2lkIDAhPT10LmhlaWdodCYmdC5oZWlnaHQhPT1uKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyBoZWlnaHQgZG9lc24ndCBtYXRjaCBIVE1MSW1hZ2VFbGVtZW50IGhlaWdodFwiKTtpZihzLmhlaWdodD1uLHZvaWQgMCE9PXQud2lkdGgmJnQud2lkdGghPT1vKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyB3aWR0aCBkb2Vzbid0IG1hdGNoIEhUTUxJbWFnZUVsZW1lbnQgd2lkdGhcIik7cy53aWR0aD1vfWVsc2Ugcy50ZW5zb3JGb3JtYXQ9XCJSR0JBXCIscy5oZWlnaHQ9bixzLndpZHRoPW87ci5kcmF3SW1hZ2UoZSwwLDApLGE9ci5nZXRJbWFnZURhdGEoMCwwLG8sbikuZGF0YX19ZWxzZXtpZighcil7aWYobyl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBpbWFnZSBjb25maWcgd2l0aCBmb3JtYXQgZm9yIEltYWdlYml0bWFwXCIpO2lmKHZvaWQgMCE9PXQuYml0bWFwRm9ybWF0KXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBkZWZpbmVkIGZvciBJbWFnZUJpdG1hcFwiKTtjb25zdCBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpO2lmKG51bGwhPW4pe2NvbnN0IHI9ZS5oZWlnaHQsbz1lLndpZHRoO2lmKG4uZHJhd0ltYWdlKGUsMCwwLG8sciksYT1uLmdldEltYWdlRGF0YSgwLDAsbyxyKS5kYXRhLHZvaWQgMCE9PXQpe2lmKHZvaWQgMCE9PXQuaGVpZ2h0JiZ0LmhlaWdodCE9PXIpdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaW5wdXQgY29uZmlnIGhlaWdodCBkb2Vzbid0IG1hdGNoIEltYWdlQml0bWFwIGhlaWdodFwiKTtpZihzLmhlaWdodD1yLHZvaWQgMCE9PXQud2lkdGgmJnQud2lkdGghPT1vKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyB3aWR0aCBkb2Vzbid0IG1hdGNoIEltYWdlQml0bWFwIHdpZHRoXCIpO3Mud2lkdGg9b31lbHNlIHMuaGVpZ2h0PXIscy53aWR0aD1vO3JldHVybiBjLmJ1ZmZlclRvVGVuc29yKGEscyl9dGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1pZihpKXJldHVybiBuZXcgUHJvbWlzZSgoKG4scik9Pntjb25zdCBvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksaT1vLmdldENvbnRleHQoXCIyZFwiKTtpZighZXx8IWkpcmV0dXJuIHIoKTtjb25zdCBhPW5ldyBJbWFnZTthLmNyb3NzT3JpZ2luPVwiQW5vbnltb3VzXCIsYS5zcmM9ZSxhLm9ubG9hZD0oKT0+e28ud2lkdGg9YS53aWR0aCxvLmhlaWdodD1hLmhlaWdodCxpLmRyYXdJbWFnZShhLDAsMCxvLndpZHRoLG8uaGVpZ2h0KTtjb25zdCBlPWkuZ2V0SW1hZ2VEYXRhKDAsMCxvLndpZHRoLG8uaGVpZ2h0KTtpZih2b2lkIDAhPT10KXtpZih2b2lkIDAhPT10LmhlaWdodCYmdC5oZWlnaHQhPT1vLmhlaWdodCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBpbnB1dCBjb25maWcgaGVpZ2h0IGRvZXNuJ3QgbWF0Y2ggaGVpZ2h0XCIpO2lmKHMuaGVpZ2h0PW8uaGVpZ2h0LHZvaWQgMCE9PXQud2lkdGgmJnQud2lkdGghPT1vLndpZHRoKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyB3aWR0aCBkb2Vzbid0IG1hdGNoIHdpZHRoXCIpO3Mud2lkdGg9by53aWR0aH1lbHNlIHMuaGVpZ2h0PW8uaGVpZ2h0LHMud2lkdGg9by53aWR0aDtuKGMuYnVmZmVyVG9UZW5zb3IoZS5kYXRhLHMpKX19KSk7dGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb25cIil9e2NvbnN0IG49XCJSR0JBXCI7bGV0IHIsbztpZih2b2lkIDAhPT10JiZ2b2lkIDAhPT10LnJlc2l6ZWRXaWR0aCYmdm9pZCAwIT09dC5yZXNpemVkSGVpZ2h0PyhyPXQucmVzaXplZEhlaWdodCxvPXQucmVzaXplZFdpZHRoKToocj1lLmhlaWdodCxvPWUud2lkdGgpLHZvaWQgMCE9PXQpe2lmKHM9dCx2b2lkIDAhPT10LmJpdG1hcEZvcm1hdCYmdC5iaXRtYXBGb3JtYXQhPT1uKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBSR0JBIGZvciBJbWFnZURhdGFcIik7cy5iaXRtYXBGb3JtYXQ9XCJSR0JBXCJ9ZWxzZSBzLmJpdG1hcEZvcm1hdD1cIlJHQkFcIjtpZihzLmhlaWdodD1yLHMud2lkdGg9byx2b2lkIDAhPT10KXtjb25zdCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7dC53aWR0aD1vLHQuaGVpZ2h0PXI7Y29uc3Qgbj10LmdldENvbnRleHQoXCIyZFwiKTtpZihudWxsPT1uKXRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIik7bi5wdXRJbWFnZURhdGEoZSwwLDApLGE9bi5nZXRJbWFnZURhdGEoMCwwLG8scikuZGF0YX1lbHNlIGE9ZS5kYXRhfX1pZih2b2lkIDAhPT1hKXJldHVybiBjLmJ1ZmZlclRvVGVuc29yKGEscyk7dGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb25cIil9dG9EYXRhVVJMKGUpe2NvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTt0LndpZHRoPXRoaXMuZGltc1szXSx0LmhlaWdodD10aGlzLmRpbXNbMl07Y29uc3Qgbj10LmdldENvbnRleHQoXCIyZFwiKTtpZihudWxsIT1uKXtsZXQgcixvO3ZvaWQgMCE9PWU/LnRlbnNvckxheW91dCYmXCJOSFdDXCI9PT1lLnRlbnNvckxheW91dD8ocj10aGlzLmRpbXNbMl0sbz10aGlzLmRpbXNbM10pOihyPXRoaXMuZGltc1szXSxvPXRoaXMuZGltc1syXSk7Y29uc3QgaT12b2lkIDAhPT1lPy5mb3JtYXQ/ZS5mb3JtYXQ6XCJSR0JcIixhPWU/Lm5vcm07bGV0IHMsdTt2b2lkIDA9PT1hfHx2b2lkIDA9PT1hLm1lYW4/cz1bMjU1LDI1NSwyNTUsMjU1XTpcIm51bWJlclwiPT10eXBlb2YgYS5tZWFuP3M9W2EubWVhbixhLm1lYW4sYS5tZWFuLGEubWVhbl06KHM9W2EubWVhblswXSxhLm1lYW5bMV0sYS5tZWFuWzJdLDBdLHZvaWQgMCE9PWEubWVhblszXSYmKHNbM109YS5tZWFuWzNdKSksdm9pZCAwPT09YXx8dm9pZCAwPT09YS5iaWFzP3U9WzAsMCwwLDBdOlwibnVtYmVyXCI9PXR5cGVvZiBhLmJpYXM/dT1bYS5iaWFzLGEuYmlhcyxhLmJpYXMsYS5iaWFzXToodT1bYS5iaWFzWzBdLGEuYmlhc1sxXSxhLmJpYXNbMl0sMF0sdm9pZCAwIT09YS5iaWFzWzNdJiYodVszXT1hLmJpYXNbM10pKTtjb25zdCBsPW8qcjtsZXQgYz0wLHA9bCxkPTIqbCxmPS0xO1wiUkdCQVwiPT09aT8oYz0wLHA9bCxkPTIqbCxmPTMqbCk6XCJSR0JcIj09PWk/KGM9MCxwPWwsZD0yKmwpOlwiUkJHXCI9PT1pJiYoYz0wLGQ9bCxwPTIqbCk7Zm9yKGxldCBlPTA7ZTxvO2UrKylmb3IobGV0IHQ9MDt0PHI7dCsrKXtjb25zdCByPSh0aGlzLmRhdGFbYysrXS11WzBdKSpzWzBdLG89KHRoaXMuZGF0YVtwKytdLXVbMV0pKnNbMV0saT0odGhpcy5kYXRhW2QrK10tdVsyXSkqc1syXSxhPS0xPT09Zj8yNTU6KHRoaXMuZGF0YVtmKytdLXVbM10pKnNbM107bi5maWxsU3R5bGU9XCJyZ2JhKFwiK3IrXCIsXCIrbytcIixcIitpK1wiLFwiK2ErXCIpXCIsbi5maWxsUmVjdCh0LGUsMSwxKX1yZXR1cm4gdC50b0RhdGFVUkwoKX10aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfXRvSW1hZ2VEYXRhKGUpe2NvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIik7bGV0IG47aWYobnVsbD09dCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpO3tsZXQgcixvLGk7dm9pZCAwIT09ZT8udGVuc29yTGF5b3V0JiZcIk5IV0NcIj09PWUudGVuc29yTGF5b3V0PyhyPXRoaXMuZGltc1syXSxvPXRoaXMuZGltc1sxXSxpPXRoaXMuZGltc1szXSk6KHI9dGhpcy5kaW1zWzNdLG89dGhpcy5kaW1zWzJdLGk9dGhpcy5kaW1zWzFdKTtjb25zdCBhPXZvaWQgMCE9PWUmJnZvaWQgMCE9PWUuZm9ybWF0P2UuZm9ybWF0OlwiUkdCXCIscz1lPy5ub3JtO2xldCB1LGw7dm9pZCAwPT09c3x8dm9pZCAwPT09cy5tZWFuP3U9WzI1NSwyNTUsMjU1LDI1NV06XCJudW1iZXJcIj09dHlwZW9mIHMubWVhbj91PVtzLm1lYW4scy5tZWFuLHMubWVhbixzLm1lYW5dOih1PVtzLm1lYW5bMF0scy5tZWFuWzFdLHMubWVhblsyXSwyNTVdLHZvaWQgMCE9PXMubWVhblszXSYmKHVbM109cy5tZWFuWzNdKSksdm9pZCAwPT09c3x8dm9pZCAwPT09cy5iaWFzP2w9WzAsMCwwLDBdOlwibnVtYmVyXCI9PXR5cGVvZiBzLmJpYXM/bD1bcy5iaWFzLHMuYmlhcyxzLmJpYXMscy5iaWFzXToobD1bcy5iaWFzWzBdLHMuYmlhc1sxXSxzLmJpYXNbMl0sMF0sdm9pZCAwIT09cy5iaWFzWzNdJiYobFszXT1zLmJpYXNbM10pKTtjb25zdCBjPW8qcjtpZih2b2lkIDAhPT1lKXtpZih2b2lkIDAhPT1lLmhlaWdodCYmZS5oZWlnaHQhPT1vKXRocm93IG5ldyBFcnJvcihcIkltYWdlIG91dHB1dCBjb25maWcgaGVpZ2h0IGRvZXNuJ3QgbWF0Y2ggdGVuc29yIGhlaWdodFwiKTtpZih2b2lkIDAhPT1lLndpZHRoJiZlLndpZHRoIT09cil0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBvdXRwdXQgY29uZmlnIHdpZHRoIGRvZXNuJ3QgbWF0Y2ggdGVuc29yIHdpZHRoXCIpO2lmKHZvaWQgMCE9PWUuZm9ybWF0JiY0PT09aSYmXCJSR0JBXCIhPT1lLmZvcm1hdHx8Mz09PWkmJlwiUkdCXCIhPT1lLmZvcm1hdCYmXCJCR1JcIiE9PWUuZm9ybWF0KXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBmb3JtYXQgZG9lc24ndCBtYXRjaCBpbnB1dCB0ZW5zb3IgZGltc1wiKX1jb25zdCBwPTQ7bGV0IGQ9MCxmPTEsaD0yLGc9MyxtPTAsYj1jLHk9MipjLHc9LTE7XCJSR0JBXCI9PT1hPyhtPTAsYj1jLHk9MipjLHc9MypjKTpcIlJHQlwiPT09YT8obT0wLGI9Yyx5PTIqYyk6XCJSQkdcIj09PWEmJihtPTAseT1jLGI9MipjKSxuPXQuY3JlYXRlSW1hZ2VEYXRhKHIsbyk7Zm9yKGxldCBlPTA7ZTxvKnI7ZCs9cCxmKz1wLGgrPXAsZys9cCxlKyspbi5kYXRhW2RdPSh0aGlzLmRhdGFbbSsrXS1sWzBdKSp1WzBdLG4uZGF0YVtmXT0odGhpcy5kYXRhW2IrK10tbFsxXSkqdVsxXSxuLmRhdGFbaF09KHRoaXMuZGF0YVt5KytdLWxbMl0pKnVbMl0sbi5kYXRhW2ddPS0xPT09dz8yNTU6KHRoaXMuZGF0YVt3KytdLWxbM10pKnVbM119cmV0dXJuIG59cmVzaGFwZShlKXtyZXR1cm4gbmV3IGModGhpcy50eXBlLHRoaXMuZGF0YSxlKX19Y29uc3QgcD1jO2NsYXNzIGR7Y29uc3RydWN0b3IoZSl7dGhpcy5oYW5kbGVyPWV9YXN5bmMgcnVuKGUsdCxuKXtjb25zdCByPXt9O2xldCBvPXt9O2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZXx8ZSBpbnN0YW5jZW9mIHB8fEFycmF5LmlzQXJyYXkoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZWVkcycgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlwiKTtsZXQgaT0hMDtpZihcIm9iamVjdFwiPT10eXBlb2YgdCl7aWYobnVsbD09PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMV06IGNhbm5vdCBiZSBudWxsLlwiKTtpZih0IGluc3RhbmNlb2YgcCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhIFRlbnNvclwiKTtpZihBcnJheS5pc0FycmF5KHQpKXtpZigwPT09dC5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuXCIpO2k9ITE7Zm9yKGNvbnN0IGUgb2YgdCl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7aWYoLTE9PT10aGlzLm91dHB1dE5hbWVzLmluZGV4T2YoZSkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke2V9LmApO3JbZV09bnVsbH1pZihcIm9iamVjdFwiPT10eXBlb2YgbiYmbnVsbCE9PW4pbz1uO2Vsc2UgaWYodm9pZCAwIT09bil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNle2xldCBlPSExO2NvbnN0IGE9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCk7Zm9yKGNvbnN0IG4gb2YgdGhpcy5vdXRwdXROYW1lcylpZigtMSE9PWEuaW5kZXhPZihuKSl7Y29uc3Qgbz10W25dOyhudWxsPT09b3x8byBpbnN0YW5jZW9mIHApJiYoZT0hMCxpPSExLHJbbl09byl9aWYoZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIG4mJm51bGwhPT1uKW89bjtlbHNlIGlmKHZvaWQgMCE9PW4pdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBvPXR9fWVsc2UgaWYodm9pZCAwIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtmb3IoY29uc3QgdCBvZiB0aGlzLmlucHV0TmFtZXMpaWYodm9pZCAwPT09ZVt0XSl0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke3R9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7aWYoaSlmb3IoY29uc3QgZSBvZiB0aGlzLm91dHB1dE5hbWVzKXJbZV09bnVsbDtjb25zdCBhPWF3YWl0IHRoaXMuaGFuZGxlci5ydW4oZSxyLG8pLHM9e307Zm9yKGNvbnN0IGUgaW4gYSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChhLGUpJiYoc1tlXT1uZXcgcChhW2VdLnR5cGUsYVtlXS5kYXRhLGFbZV0uZGltcykpO3JldHVybiBzfXN0YXRpYyBhc3luYyBjcmVhdGUoZSx0LG4saSl7bGV0IGEscz17fTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7aWYoYT1lLFwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT09dClzPXQ7ZWxzZSBpZih2b2lkIDAhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpe2lmKGE9ZSxcIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXQpcz10O2Vsc2UgaWYodm9pZCAwIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNle2lmKCEoZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXImJmUgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMF06IG11c3QgYmUgJ3BhdGgnIG9yICdidWZmZXInLlwiKTt7Y29uc3Qgcj1lO2xldCBvPTAsdT1lLmJ5dGVMZW5ndGg7aWYoXCJvYmplY3RcIj09dHlwZW9mIHQmJm51bGwhPT10KXM9dDtlbHNlIGlmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXtpZihvPXQsIU51bWJlci5pc1NhZmVJbnRlZ2VyKG8pKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2J5dGVPZmZzZXQnIG11c3QgYmUgYW4gaW50ZWdlci5cIik7aWYobzwwfHxvPj1yLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlT2Zmc2V0JyBpcyBvdXQgb2YgcmFuZ2UgWzAsICR7ci5ieXRlTGVuZ3RofSkuYCk7aWYodT1lLmJ5dGVMZW5ndGgtbyxcIm51bWJlclwiPT10eXBlb2Ygbil7aWYodT1uLCFOdW1iZXIuaXNTYWZlSW50ZWdlcih1KSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO2lmKHU8PTB8fG8rdT5yLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlTGVuZ3RoJyBpcyBvdXQgb2YgcmFuZ2UgKDAsICR7ci5ieXRlTGVuZ3RoLW99XS5gKTtpZihcIm9iamVjdFwiPT10eXBlb2YgaSYmbnVsbCE9PWkpcz1pO2Vsc2UgaWYodm9pZCAwIT09aSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHZvaWQgMCE9PW4pdGhyb3cgbmV3IFR5cGVFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGEgbnVtYmVyLlwiKX1lbHNlIGlmKHZvaWQgMCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7YT1uZXcgVWludDhBcnJheShyLG8sdSl9fWNvbnN0IHU9KHMuZXhlY3V0aW9uUHJvdmlkZXJzfHxbXSkubWFwKChlPT5cInN0cmluZ1wiPT10eXBlb2YgZT9lOmUubmFtZSkpLGw9YXdhaXQoYXN5bmMgZT0+e2NvbnN0IHQ9MD09PWUubGVuZ3RoP286ZSxuPVtdO2Zvcihjb25zdCBlIG9mIHQpe2NvbnN0IHQ9cltlXTtpZih0KXtpZih0LmluaXRpYWxpemVkKXJldHVybiB0LmJhY2tlbmQ7aWYodC5hYm9ydGVkKWNvbnRpbnVlO2NvbnN0IHI9ISF0LmluaXRQcm9taXNlO3RyeXtyZXR1cm4gcnx8KHQuaW5pdFByb21pc2U9dC5iYWNrZW5kLmluaXQoKSksYXdhaXQgdC5pbml0UHJvbWlzZSx0LmluaXRpYWxpemVkPSEwLHQuYmFja2VuZH1jYXRjaChvKXtyfHxuLnB1c2goe25hbWU6ZSxlcnI6b30pLHQuYWJvcnRlZD0hMH1maW5hbGx5e2RlbGV0ZSB0LmluaXRQcm9taXNlfX19dGhyb3cgbmV3IEVycm9yKGBubyBhdmFpbGFibGUgYmFja2VuZCBmb3VuZC4gRVJSOiAke24ubWFwKChlPT5gWyR7ZS5uYW1lfV0gJHtlLmVycn1gKSkuam9pbihcIiwgXCIpfWApfSkodSksYz1hd2FpdCBsLmNyZWF0ZVNlc3Npb25IYW5kbGVyKGEscyk7cmV0dXJuIG5ldyBkKGMpfXN0YXJ0UHJvZmlsaW5nKCl7dGhpcy5oYW5kbGVyLnN0YXJ0UHJvZmlsaW5nKCl9ZW5kUHJvZmlsaW5nKCl7dGhpcy5oYW5kbGVyLmVuZFByb2ZpbGluZygpfWdldCBpbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5pbnB1dE5hbWVzfWdldCBvdXRwdXROYW1lcygpe3JldHVybiB0aGlzLmhhbmRsZXIub3V0cHV0TmFtZXN9fWNvbnN0IGY9ZH0sNTcxNjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7dC5SPXZvaWQgMDtjb25zdCByPW4oNjAyNyksbz1uKDE3MjMpO3QuUj1uZXcgY2xhc3N7YXN5bmMgaW5pdCgpe31hc3luYyBjcmVhdGVTZXNzaW9uSGFuZGxlcihlLHQpe2NvbnN0IG49bmV3IHIuU2Vzc2lvbih0KTtyZXR1cm4gYXdhaXQgbi5sb2FkTW9kZWwoZSksbmV3IG8uT25ueGpzU2Vzc2lvbkhhbmRsZXIobil9fX0sMjgxODooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7dC5jOD10LnJYPXZvaWQgMDtjb25zdCByPW4oODQ1Myksbz1uKDUzODEpLGk9big5NTQ0KSxhPW4oNjY0MCk7dC5yWD0oKT0+e2lmKChcIm51bWJlclwiIT10eXBlb2Ygci5lbnYud2FzbS5pbml0VGltZW91dHx8ci5lbnYud2FzbS5pbml0VGltZW91dDwwKSYmKHIuZW52Lndhc20uaW5pdFRpbWVvdXQ9MCksXCJib29sZWFuXCIhPXR5cGVvZiByLmVudi53YXNtLnNpbWQmJihyLmVudi53YXNtLnNpbWQ9ITApLFwiYm9vbGVhblwiIT10eXBlb2Ygci5lbnYud2FzbS5wcm94eSYmKHIuZW52Lndhc20ucHJveHk9ITEpLFwibnVtYmVyXCIhPXR5cGVvZiByLmVudi53YXNtLm51bVRocmVhZHN8fCFOdW1iZXIuaXNJbnRlZ2VyKHIuZW52Lndhc20ubnVtVGhyZWFkcyl8fHIuZW52Lndhc20ubnVtVGhyZWFkczw9MCl7Y29uc3QgZT1cInVuZGVmaW5lZFwiPT10eXBlb2YgbmF2aWdhdG9yPygwLG8uY3B1cykoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7ci5lbnYud2FzbS5udW1UaHJlYWRzPU1hdGgubWluKDQsTWF0aC5jZWlsKChlfHwxKS8yKSl9fSx0LmM4PW5ldyBjbGFzc3thc3luYyBpbml0KCl7KDAsdC5yWCkoKSxhd2FpdCgwLGkuaW5pdFdhc20pKCl9YXN5bmMgY3JlYXRlU2Vzc2lvbkhhbmRsZXIoZSx0KXtjb25zdCBuPW5ldyBhLk9ubnhydW50aW1lV2ViQXNzZW1ibHlTZXNzaW9uSGFuZGxlcjtyZXR1cm4gYXdhaXQgbi5sb2FkTW9kZWwoZSx0KSxQcm9taXNlLnJlc29sdmUobil9fX0sMTA1NzpmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCxuLHIpe3ZvaWQgMD09PXImJihyPW4pO3ZhciBvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxuKTtvJiYhKFwiZ2V0XCJpbiBvPyF0Ll9fZXNNb2R1bGU6by53cml0YWJsZXx8by5jb25maWd1cmFibGUpfHwobz17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtuXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLG8pfTpmdW5jdGlvbihlLHQsbixyKXt2b2lkIDA9PT1yJiYocj1uKSxlW3JdPXRbbl19KSxvPXRoaXMmJnRoaXMuX19leHBvcnRTdGFyfHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgbiBpbiBlKVwiZGVmYXVsdFwiPT09bnx8T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbil8fHIodCxlLG4pfTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxvKG4oODQ1MyksdCk7Y29uc3QgaT1uKDg0NTMpO3tjb25zdCBlPW4oNTcxNikuUjsoMCxpLnJlZ2lzdGVyQmFja2VuZCkoXCJ3ZWJnbFwiLGUsLTEwKX17Y29uc3QgZT1uKDI4MTgpLmM4OygwLGkucmVnaXN0ZXJCYWNrZW5kKShcImNwdVwiLGUsMTApLCgwLGkucmVnaXN0ZXJCYWNrZW5kKShcIndhc21cIixlLDEwKSwoMCxpLnJlZ2lzdGVyQmFja2VuZCkoXCJ4bm5wYWNrXCIsZSw5KX19LDQ5MTA6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleT12b2lkIDA7Y2xhc3Mgbntjb25zdHJ1Y3RvcihlKXtPYmplY3QuYXNzaWduKHRoaXMsZSl9Z2V0IGNhY2hlS2V5KCl7cmV0dXJuIHRoaXMuX2NhY2hlS2V5fHwodGhpcy5fY2FjaGVLZXk9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuc29ydCgpLm1hcCgoZT0+YCR7dGhpc1tlXX1gKSkuam9pbihcIjtcIikpLHRoaXMuX2NhY2hlS2V5fX10LmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleT1lPT5uZXcgbihlKX0sNjg3NDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5BdHRyaWJ1dGU9dm9pZCAwO2NvbnN0IHI9bigxNDQ2KSxvPW4oMTI4NyksaT1uKDkyNDApLGE9big3MjczKTt2YXIgcz1vLm9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnM7Y2xhc3MgdXtjb25zdHJ1Y3RvcihlKXtpZih0aGlzLl9hdHRyaWJ1dGVzPW5ldyBNYXAsbnVsbCE9ZSl7Zm9yKGNvbnN0IHQgb2YgZSl0IGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP3RoaXMuX2F0dHJpYnV0ZXMuc2V0KHQubmFtZSxbdS5nZXRWYWx1ZSh0KSx1LmdldFR5cGUodCldKTp0IGluc3RhbmNlb2Ygcy5BdHRyaWJ1dGUmJnRoaXMuX2F0dHJpYnV0ZXMuc2V0KHQubmFtZSgpLFt1LmdldFZhbHVlKHQpLHUuZ2V0VHlwZSh0KV0pO2lmKHRoaXMuX2F0dHJpYnV0ZXMuc2l6ZTxlLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJkdXBsaWNhdGVkIGF0dHJpYnV0ZSBuYW1lc1wiKX19c2V0KGUsdCxuKXt0aGlzLl9hdHRyaWJ1dGVzLnNldChlLFtuLHRdKX1kZWxldGUoZSl7dGhpcy5fYXR0cmlidXRlcy5kZWxldGUoZSl9Z2V0RmxvYXQoZSx0KXtyZXR1cm4gdGhpcy5nZXQoZSxcImZsb2F0XCIsdCl9Z2V0SW50KGUsdCl7cmV0dXJuIHRoaXMuZ2V0KGUsXCJpbnRcIix0KX1nZXRTdHJpbmcoZSx0KXtyZXR1cm4gdGhpcy5nZXQoZSxcInN0cmluZ1wiLHQpfWdldFRlbnNvcihlLHQpe3JldHVybiB0aGlzLmdldChlLFwidGVuc29yXCIsdCl9Z2V0RmxvYXRzKGUsdCl7cmV0dXJuIHRoaXMuZ2V0KGUsXCJmbG9hdHNcIix0KX1nZXRJbnRzKGUsdCl7cmV0dXJuIHRoaXMuZ2V0KGUsXCJpbnRzXCIsdCl9Z2V0U3RyaW5ncyhlLHQpe3JldHVybiB0aGlzLmdldChlLFwic3RyaW5nc1wiLHQpfWdldFRlbnNvcnMoZSx0KXtyZXR1cm4gdGhpcy5nZXQoZSxcInRlbnNvcnNcIix0KX1nZXQoZSx0LG4pe2NvbnN0IHI9dGhpcy5fYXR0cmlidXRlcy5nZXQoZSk7aWYodm9pZCAwPT09cil7aWYodm9pZCAwIT09bilyZXR1cm4gbjt0aHJvdyBuZXcgRXJyb3IoYHJlcXVpcmVkIGF0dHJpYnV0ZSBub3QgZm91bmQ6ICR7ZX1gKX1pZihyWzFdIT09dCl0aHJvdyBuZXcgRXJyb3IoYHR5cGUgbWlzbWF0Y2g6IGV4cGVjdGVkICR7dH0gYnV0IGdvdCAke3JbMV19YCk7cmV0dXJuIHJbMF19c3RhdGljIGdldFR5cGUoZSl7Y29uc3QgdD1lIGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP2UudHlwZTplLnR5cGUoKTtzd2l0Y2godCl7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVDpyZXR1cm5cImZsb2F0XCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlQ6cmV0dXJuXCJpbnRcIjtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORzpyZXR1cm5cInN0cmluZ1wiO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SOnJldHVyblwidGVuc29yXCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVFM6cmV0dXJuXCJmbG9hdHNcIjtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFM6cmV0dXJuXCJpbnRzXCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTOnJldHVyblwic3RyaW5nc1wiO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzpyZXR1cm5cInRlbnNvcnNcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgYXR0cmlidXRlIHR5cGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQ6ICR7ci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGVbdF19YCl9fXN0YXRpYyBnZXRWYWx1ZShlKXtjb25zdCB0PWUgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8/ZS50eXBlOmUudHlwZSgpO2lmKHQ9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSHx8dD09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUyl0aHJvdyBuZXcgRXJyb3IoXCJncmFwaCBhdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7Y29uc3Qgbj10aGlzLmdldFZhbHVlTm9DaGVjayhlKTtpZih0PT09ci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UJiZhLkxvbmdVdGlsLmlzTG9uZyhuKSlyZXR1cm4gYS5Mb25nVXRpbC5sb25nVG9OdW1iZXIobik7aWYodD09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFMpe2NvbnN0IGU9bix0PW5ldyBBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspe2NvbnN0IHI9ZVtuXTt0W25dPWEuTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHIpfXJldHVybiB0fWlmKHQ9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1IpcmV0dXJuIGUgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8/aS5UZW5zb3IuZnJvbVByb3RvKG4pOmkuVGVuc29yLmZyb21PcnRUZW5zb3Iobik7aWYodD09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlMpe2lmKGUgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8pcmV0dXJuIG4ubWFwKChlPT5pLlRlbnNvci5mcm9tUHJvdG8oZSkpKTtpZihlIGluc3RhbmNlb2Ygcy5BdHRyaWJ1dGUpcmV0dXJuIG4ubWFwKChlPT5pLlRlbnNvci5mcm9tT3J0VGVuc29yKGUpKSl9aWYodD09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORyYmZSBpbnN0YW5jZW9mIHIub25ueC5BdHRyaWJ1dGVQcm90byl7Y29uc3QgZT1uO3JldHVybigwLGEuZGVjb2RlVXRmOFN0cmluZykoZSl9cmV0dXJuIHQ9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTJiZlIGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP24ubWFwKGEuZGVjb2RlVXRmOFN0cmluZyk6bn1zdGF0aWMgZ2V0VmFsdWVOb0NoZWNrKGUpe3JldHVybiBlIGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP3RoaXMuZ2V0VmFsdWVOb0NoZWNrRnJvbU9ubnhGb3JtYXQoZSk6dGhpcy5nZXRWYWx1ZU5vQ2hlY2tGcm9tT3J0Rm9ybWF0KGUpfXN0YXRpYyBnZXRWYWx1ZU5vQ2hlY2tGcm9tT25ueEZvcm1hdChlKXtzd2l0Y2goZS50eXBlKXtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkZMT0FUOnJldHVybiBlLmY7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlQ6cmV0dXJuIGUuaTtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORzpyZXR1cm4gZS5zO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SOnJldHVybiBlLnQ7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSDpyZXR1cm4gZS5nO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOnJldHVybiBlLmZsb2F0cztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFM6cmV0dXJuIGUuaW50cztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6cmV0dXJuIGUuc3RyaW5ncztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6cmV0dXJuIGUudGVuc29ycztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUzpyZXR1cm4gZS5ncmFwaHM7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGF0dHJpYnV0ZSB0eXBlOiAke3Iub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW2UudHlwZV19YCl9fXN0YXRpYyBnZXRWYWx1ZU5vQ2hlY2tGcm9tT3J0Rm9ybWF0KGUpe3N3aXRjaChlLnR5cGUoKSl7Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuRkxPQVQ6cmV0dXJuIGUuZigpO2Nhc2Ugcy5BdHRyaWJ1dGVUeXBlLklOVDpyZXR1cm4gZS5pKCk7Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuU1RSSU5HOnJldHVybiBlLnMoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5URU5TT1I6cmV0dXJuIGUudCgpO2Nhc2Ugcy5BdHRyaWJ1dGVUeXBlLkdSQVBIOnJldHVybiBlLmcoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5GTE9BVFM6cmV0dXJuIGUuZmxvYXRzQXJyYXkoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5JTlRTOntjb25zdCB0PVtdO2ZvcihsZXQgbj0wO248ZS5pbnRzTGVuZ3RoKCk7bisrKXQucHVzaChlLmludHMobikpO3JldHVybiB0fWNhc2Ugcy5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6e2NvbnN0IHQ9W107Zm9yKGxldCBuPTA7bjxlLnN0cmluZ3NMZW5ndGgoKTtuKyspdC5wdXNoKGUuc3RyaW5ncyhuKSk7cmV0dXJuIHR9Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzp7Y29uc3QgdD1bXTtmb3IobGV0IG49MDtuPGUudGVuc29yc0xlbmd0aCgpO24rKyl0LnB1c2goZS50ZW5zb3JzKG4pKTtyZXR1cm4gdH1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgYXR0cmlidXRlIHR5cGU6ICR7cy5BdHRyaWJ1dGVUeXBlW2UudHlwZSgpXX1gKX19fXQuQXR0cmlidXRlPXV9LDE5NzU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucmVzb2x2ZUJhY2tlbmQ9dC5iYWNrZW5kPXZvaWQgMDtjb25zdCByPW4oNDQxOCksbz1uZXcgTWFwO2FzeW5jIGZ1bmN0aW9uIGkoZSl7Y29uc3Qgbj10LmJhY2tlbmQ7aWYodm9pZCAwIT09bltlXSYmZnVuY3Rpb24oZSl7Y29uc3QgdD1lO3JldHVyblwiaW5pdGlhbGl6ZVwiaW4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC5pbml0aWFsaXplJiZcImNyZWF0ZVNlc3Npb25IYW5kbGVyXCJpbiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmNyZWF0ZVNlc3Npb25IYW5kbGVyJiZcImRpc3Bvc2VcImluIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZGlzcG9zZX0obltlXSkpe2NvbnN0IHQ9bltlXTtsZXQgcj10LmluaXRpYWxpemUoKTtpZihcIm9iamVjdFwiPT10eXBlb2YgciYmXCJ0aGVuXCJpbiByJiYocj1hd2FpdCByKSxyKXJldHVybiBvLnNldChlLHQpLHR9fXQuYmFja2VuZD17d2ViZ2w6bmV3IHIuV2ViR0xCYWNrZW5kfSx0LnJlc29sdmVCYWNrZW5kPWFzeW5jIGZ1bmN0aW9uIGUodCl7aWYoIXQpcmV0dXJuIGUoW1wid2ViZ2xcIl0pO3tjb25zdCBlPVwic3RyaW5nXCI9PXR5cGVvZiB0P1t0XTp0O2Zvcihjb25zdCB0IG9mIGUpe2NvbnN0IGU9by5nZXQodCk7aWYoZSlyZXR1cm4gZTtjb25zdCBuPWF3YWl0IGkodCk7aWYobilyZXR1cm4gbn19dGhyb3cgbmV3IEVycm9yKFwibm8gYXZhaWxhYmxlIGJhY2tlbmQgdG8gdXNlXCIpfX0sNDQxODooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5XZWJHTEJhY2tlbmQ9dm9pZCAwO2NvbnN0IHI9big4NDUzKSxvPW4oMTMxNSksaT1uKDIxNzEpLGE9bigzMzg5KTt0LldlYkdMQmFja2VuZD1jbGFzc3tnZXQgY29udGV4dElkKCl7cmV0dXJuIHIuZW52LndlYmdsLmNvbnRleHRJZH1zZXQgY29udGV4dElkKGUpe3IuZW52LndlYmdsLmNvbnRleHRJZD1lfWdldCBtYXRtdWxNYXhCYXRjaFNpemUoKXtyZXR1cm4gci5lbnYud2ViZ2wubWF0bXVsTWF4QmF0Y2hTaXplfXNldCBtYXRtdWxNYXhCYXRjaFNpemUoZSl7ci5lbnYud2ViZ2wubWF0bXVsTWF4QmF0Y2hTaXplPWV9Z2V0IHRleHR1cmVDYWNoZU1vZGUoKXtyZXR1cm4gci5lbnYud2ViZ2wudGV4dHVyZUNhY2hlTW9kZX1zZXQgdGV4dHVyZUNhY2hlTW9kZShlKXtyLmVudi53ZWJnbC50ZXh0dXJlQ2FjaGVNb2RlPWV9Z2V0IHBhY2soKXtyZXR1cm4gci5lbnYud2ViZ2wucGFja31zZXQgcGFjayhlKXtyLmVudi53ZWJnbC5wYWNrPWV9Z2V0IGFzeW5jKCl7cmV0dXJuIHIuZW52LndlYmdsLmFzeW5jfXNldCBhc3luYyhlKXtyLmVudi53ZWJnbC5hc3luYz1lfWluaXRpYWxpemUoKXt0cnl7cmV0dXJuIHRoaXMuZ2xDb250ZXh0PSgwLGEuY3JlYXRlV2ViR0xDb250ZXh0KSh0aGlzLmNvbnRleHRJZCksXCJudW1iZXJcIiE9dHlwZW9mIHRoaXMubWF0bXVsTWF4QmF0Y2hTaXplJiYodGhpcy5tYXRtdWxNYXhCYXRjaFNpemU9MTYpLFwic3RyaW5nXCIhPXR5cGVvZiB0aGlzLnRleHR1cmVDYWNoZU1vZGUmJih0aGlzLnRleHR1cmVDYWNoZU1vZGU9XCJmdWxsXCIpLFwiYm9vbGVhblwiIT10eXBlb2YgdGhpcy5wYWNrJiYodGhpcy5wYWNrPSExKSxcImJvb2xlYW5cIiE9dHlwZW9mIHRoaXMuYXN5bmMmJih0aGlzLmFzeW5jPSExKSxvLkxvZ2dlci5zZXRXaXRoRW52KHIuZW52KSxvLkxvZ2dlci52ZXJib3NlKFwiV2ViR0xCYWNrZW5kXCIsYENyZWF0ZWQgV2ViR0xDb250ZXh0OiAke3R5cGVvZiB0aGlzLmdsQ29udGV4dH0gd2l0aCBtYXRtdWxNYXhCYXRjaFNpemU6ICR7dGhpcy5tYXRtdWxNYXhCYXRjaFNpemV9OyB0ZXh0dXJlQ2FjaGVNb2RlOiAke3RoaXMudGV4dHVyZUNhY2hlTW9kZX07IHBhY2s6ICR7dGhpcy5wYWNrfTsgYXN5bmM6ICR7dGhpcy5hc3luY30uYCksITB9Y2F0Y2goZSl7cmV0dXJuIG8uTG9nZ2VyLndhcm5pbmcoXCJXZWJHTEJhY2tlbmRcIixgVW5hYmxlIHRvIGluaXRpYWxpemUgV2ViR0xCYWNrZW5kLiAke2V9YCksITF9fWNyZWF0ZVNlc3Npb25IYW5kbGVyKGUpe3JldHVybiBuZXcgaS5XZWJHTFNlc3Npb25IYW5kbGVyKHRoaXMsZSl9ZGlzcG9zZSgpe3RoaXMuZ2xDb250ZXh0LmRpc3Bvc2UoKX19fSw2ODU5OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkNvb3Jkc0dsc2xMaWI9dm9pZCAwO2NvbnN0IHI9big3MjczKSxvPW4oMTk5NyksaT1uKDY3NTcpLGE9big3NjE4KSxzPW4oNDMyKTtjbGFzcyB1IGV4dGVuZHMgby5HbHNsTGlie2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpfWdldEZ1bmN0aW9ucygpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHRoaXMub2Zmc2V0VG9Db29yZHMoKSksdGhpcy5jb29yZHNUb09mZnNldCgpKSx0aGlzLnRvVmVjKCkpLHRoaXMudmFsdWVGcm9tKCkpLHRoaXMuZ2V0Q29tbW9uVXRpbEZ1bmNzKCkpLHRoaXMuZ2V0SW5wdXRzU2FtcGxpbmdTbmlwcGV0cygpKSx0aGlzLmdldE91dHB1dFNhbXBsaW5nU25pcHBldCgpKX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fW9mZnNldFRvQ29vcmRzKCl7cmV0dXJue29mZnNldFRvQ29vcmRzOm5ldyBvLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgdmVjMiBvZmZzZXRUb0Nvb3JkcyhpbnQgb2Zmc2V0LCBpbnQgd2lkdGgsIGludCBoZWlnaHQpIHtcXG4gICAgICAgIGludCB0ID0gb2Zmc2V0IC8gd2lkdGg7XFxuICAgICAgICBpbnQgcyA9IG9mZnNldCAtIHQqd2lkdGg7XFxuICAgICAgICB2ZWMyIGNvb3JkcyA9ICh2ZWMyKHMsdCkgKyB2ZWMyKDAuNSwwLjUpKSAvIHZlYzIod2lkdGgsIGhlaWdodCk7XFxuICAgICAgICByZXR1cm4gY29vcmRzO1xcbiAgICAgIH1cXG4gICAgICBcIil9fWNvb3Jkc1RvT2Zmc2V0KCl7cmV0dXJue2Nvb3Jkc1RvT2Zmc2V0Om5ldyBvLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgaW50IGNvb3Jkc1RvT2Zmc2V0KHZlYzIgY29vcmRzLCBpbnQgd2lkdGgsIGludCBoZWlnaHQpIHtcXG4gICAgICAgIGZsb2F0IHMgPSBjb29yZHMucyAqIGZsb2F0KHdpZHRoKTtcXG4gICAgICAgIGZsb2F0IHQgPSBjb29yZHMudCAqIGZsb2F0KGhlaWdodCk7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gaW50KHQpICogd2lkdGggKyBpbnQocyk7XFxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xcbiAgICAgIH1cXG4gICAgICBcIil9fWdldE91dHB1dFNhbXBsaW5nU25pcHBldCgpe2NvbnN0IGU9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQ7cmV0dXJuIGUuaXNQYWNrZWQ/dGhpcy5nZXRQYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoZSk6dGhpcy5nZXRVbnBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChlKX1nZXRQYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoZSl7Y29uc3QgdD1lLnVucGFja2VkU2hhcGUsbj1bZS53aWR0aCxlLmhlaWdodF0scj17fSxhPVwiZ2V0T3V0cHV0Q29vcmRzXCI7c3dpdGNoKHQubGVuZ3RoKXtjYXNlIDA6clthXT10aGlzLmdldE91dHB1dFNjYWxhckNvb3JkcygpO2JyZWFrO2Nhc2UgMTpyW2FdPXRoaXMuZ2V0T3V0cHV0UGFja2VkMURDb29yZHModCxuKTticmVhaztjYXNlIDI6clthXT10aGlzLmdldE91dHB1dFBhY2tlZDJEQ29vcmRzKHQsbik7YnJlYWs7Y2FzZSAzOnJbYV09dGhpcy5nZXRPdXRwdXRQYWNrZWQzRENvb3Jkcyh0LG4pO2JyZWFrO2RlZmF1bHQ6clthXT10aGlzLmdldE91dHB1dFBhY2tlZE5EQ29vcmRzKHQsbil9Y29uc3Qgcz1gXFxuICAgICAgdm9pZCBzZXRPdXRwdXQodmVjNCB2YWwpIHtcXG4gICAgICAgICR7KDAsaS5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pLm91dHB1dH0gPSB2YWw7XFxuICAgICAgfVxcbiAgICBgO3JldHVybiByLmZsb2F0VGV4dHVyZVNldFJHQkE9bmV3IG8uR2xzbExpYlJvdXRpbmUocykscn1nZXRVbnBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChlKXtjb25zdCB0PWUudW5wYWNrZWRTaGFwZSxuPVtlLndpZHRoLGUuaGVpZ2h0XSxyPXt9LGE9XCJnZXRPdXRwdXRDb29yZHNcIjtzd2l0Y2godC5sZW5ndGgpe2Nhc2UgMDpyW2FdPXRoaXMuZ2V0T3V0cHV0U2NhbGFyQ29vcmRzKCk7YnJlYWs7Y2FzZSAxOnJbYV09dGhpcy5nZXRPdXRwdXRVbnBhY2tlZDFEQ29vcmRzKHQsbik7YnJlYWs7Y2FzZSAyOnJbYV09dGhpcy5nZXRPdXRwdXRVbnBhY2tlZDJEQ29vcmRzKHQsbik7YnJlYWs7Y2FzZSAzOnJbYV09dGhpcy5nZXRPdXRwdXRVbnBhY2tlZDNEQ29vcmRzKHQsbik7YnJlYWs7Y2FzZSA0OnJbYV09dGhpcy5nZXRPdXRwdXRVbnBhY2tlZDREQ29vcmRzKHQsbik7YnJlYWs7Y2FzZSA1OnJbYV09dGhpcy5nZXRPdXRwdXRVbnBhY2tlZDVEQ29vcmRzKHQsbik7YnJlYWs7Y2FzZSA2OnJbYV09dGhpcy5nZXRPdXRwdXRVbnBhY2tlZDZEQ29vcmRzKHQsbik7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG91dHB1dCBkaW1lbnNpb25hbGl0eTogJHt0Lmxlbmd0aH1gKX1jb25zdCBzPWBcXG4gICAgICAgIHZvaWQgc2V0T3V0cHV0KGZsb2F0IHZhbCkge1xcbiAgICAgICAgICAkeygwLGkuZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKS5vdXRwdXR9ID0gdmVjNCh2YWwsIDAsIDAsIDApO1xcbiAgICAgICAgfVxcbiAgICBgO3JldHVybiByLmZsb2F0VGV4dHVyZVNldFI9bmV3IG8uR2xzbExpYlJvdXRpbmUocykscn1nZXRPdXRwdXRTY2FsYXJDb29yZHMoKXtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUoXCJcXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgfVxcbiAgICBcIil9Z2V0T3V0cHV0UGFja2VkMURDb29yZHMoZSx0KXtjb25zdCBuPXQ7bGV0IHI9XCJcIjtyZXR1cm4gMT09PW5bMF0/KHI9YFxcbiAgICAgICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgICAgIHJldHVybiAyICogaW50KFRleENvb3Jkcy55ICogJHtuWzFdfS4wKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYCxuZXcgby5HbHNsTGliUm91dGluZShyKSk6MT09PW5bMV0/KHI9YFxcbiAgICAgICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgICAgIHJldHVybiAyICogaW50KFRleENvb3Jkcy54ICogJHtuWzBdfS4wKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYCxuZXcgby5HbHNsTGliUm91dGluZShyKSk6KHI9YFxcbiAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtuWzBdfSwgJHtuWzFdfSkpO1xcbiAgICAgICAgICByZXR1cm4gMiAqIChyZXNUZXhSQy55ICogJHtuWzBdfSArIHJlc1RleFJDLngpO1xcbiAgICAgICAgfVxcbiAgICAgIGAsbmV3IG8uR2xzbExpYlJvdXRpbmUocikpfWdldE91dHB1dFBhY2tlZDJEQ29vcmRzKGUsdCl7bGV0IG49XCJcIjtpZihyLkFycmF5VXRpbC5hcnJheXNFcXVhbChlLHQpKXJldHVybiBuPWBcXG4gICAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgcmV0dXJuIDIgKiBpdmVjMihUZXhDb29yZHMueHkgKiB2ZWMyKCR7dFswXX0sICR7dFsxXX0pKTtcXG4gICAgICAgIH1cXG4gICAgICBgLG5ldyBvLkdsc2xMaWJSb3V0aW5lKG4pO2NvbnN0IGk9dCxhPU1hdGguY2VpbChlWzFdLzIpO3JldHVybiBuPWBcXG4gICAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2lbMF19LCAke2lbMV19KSk7XFxuXFxuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke2lbMF19ICsgcmVzVGV4UkMueDtcXG5cXG4gICAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxcbiAgICAgICAgICBpbnQgciA9IGltb2QoaW5kZXgsICR7YX0pICogMjtcXG4gICAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHthfSk7XFxuXFxuICAgICAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcXG4gICAgICAgIH1cXG4gICAgICBgLG5ldyBvLkdsc2xMaWJSb3V0aW5lKG4pfWdldE91dHB1dFBhY2tlZDNEQ29vcmRzKGUsdCl7Y29uc3Qgbj1bdFswXSx0WzFdXSxyPU1hdGguY2VpbChlWzJdLzIpLGk9cipNYXRoLmNlaWwoZVsxXS8yKSxhPWBcXG4gICAgICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke25bMF19LCAke25bMV19KSk7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke25bMF19ICsgcmVzVGV4UkMueDtcXG5cXG4gICAgICAgICAgaW50IGIgPSBpbmRleCAvICR7aX07XFxuICAgICAgICAgIGluZGV4IC09IGIgKiAke2l9O1xcblxcbiAgICAgICAgICAvLyByZXZlcnNlIHIgYW5kIGMgb3JkZXIgZm9yIHBhY2tlZCB0ZXh0dXJlXFxuICAgICAgICAgIGludCByID0gaW1vZChpbmRleCwgJHtyfSkgKiAyO1xcbiAgICAgICAgICBpbnQgYyA9IDIgKiAoaW5kZXggLyAke3J9KTtcXG5cXG4gICAgICAgICAgcmV0dXJuIGl2ZWMzKGIsIHIsIGMpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKGEpfWdldE91dHB1dFBhY2tlZE5EQ29vcmRzKGUsdCl7Y29uc3Qgbj1bdFswXSx0WzFdXSxyPU1hdGguY2VpbChlW2UubGVuZ3RoLTFdLzIpLGk9cipNYXRoLmNlaWwoZVtlLmxlbmd0aC0yXS8yKTtsZXQgYT1pLHM9XCJcIix1PVwiYiwgciwgY1wiO2ZvcihsZXQgdD0yO3Q8ZS5sZW5ndGgtMTt0KyspYSo9ZVtlLmxlbmd0aC10LTFdLHM9YFxcbiAgICAgIGludCBiJHt0fSA9IGluZGV4IC8gJHthfTtcXG4gICAgICBpbmRleCAtPSBiJHt0fSAqICR7YX07XFxuICAgIGArcyx1PWBiJHt0fSwgYCt1O2NvbnN0IGw9YFxcbiAgICAgIGl2ZWMke2UubGVuZ3RofSBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke25bMF19LCAke25bMV19KSk7XFxuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtuWzBdfSArIHJlc1RleFJDLng7XFxuXFxuICAgICAgICAke3N9XFxuXFxuICAgICAgICBpbnQgYiA9IGluZGV4IC8gJHtpfTtcXG4gICAgICAgIGluZGV4IC09IGIgKiAke2l9O1xcblxcbiAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxcbiAgICAgICAgaW50IHIgPSBpbW9kKGluZGV4LCAke3J9KSAqIDI7XFxuICAgICAgICBpbnQgYyA9IDIgKiAoaW5kZXggLyAke3J9KTtcXG5cXG4gICAgICAgIHJldHVybiBpdmVjJHtlLmxlbmd0aH0oJHt1fSk7XFxuICAgICAgfVxcbiAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShsKX1nZXRPdXRwdXRVbnBhY2tlZDFEQ29vcmRzKGUsdCl7Y29uc3Qgbj1gXFxuICAgICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7dFswXX0sICR7dFsxXX0pKTtcXG4gICAgICAgICAgcmV0dXJuIHJlc1RleFJDLnkgKiAke3RbMF19ICsgcmVzVGV4UkMueDtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRVbnBhY2tlZDJEQ29vcmRzKGUsdCl7Y29uc3Qgbj1gXFxuICAgICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0WzBdfSwgJHt0WzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHt0WzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICAgIGludCByID0gaW5kZXggLyAke2VbMV19O1xcbiAgICAgICAgICBpbnQgYyA9IGluZGV4IC0gciAqICR7ZVsxXX07XFxuICAgICAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRVbnBhY2tlZDNEQ29vcmRzKGUsdCl7bGV0IG49XCJcIjtjb25zdCByPWUubGVuZ3RoO2xldCBpPW51bGw7cjwyJiYoaT1bXSksaT1uZXcgQXJyYXkoci0xKSxpW3ItMl09ZVtyLTFdO2ZvcihsZXQgdD1yLTM7dD49MDstLXQpaVt0XT1pW3QrMV0qZVt0KzFdO2NvbnN0IGE9W1wiclwiLFwiY1wiLFwiZFwiXSxzPWkubWFwKCgoZSx0KT0+YGludCAke2FbdF19ID0gaW5kZXggLyAke2V9OyAke3Q9PT1pLmxlbmd0aC0xP2BpbnQgJHthW3QrMV19ID0gaW5kZXggLSAke2FbdF19ICogJHtlfWA6YGluZGV4IC09ICR7YVt0XX0gKiAke2V9YH07YCkpLmpvaW4oXCJcIik7cmV0dXJuIG49YFxcbiAgICAgICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7dFswXX0sICR7dFsxXX0pKTtcXG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dFswXX0gKyByZXNUZXhSQy54O1xcbiAgICAgICAgICAke3N9XFxuICAgICAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcXG4gICAgICAgIH1cXG4gICAgICBgLG5ldyBvLkdsc2xMaWJSb3V0aW5lKG4pfWdldE91dHB1dFVucGFja2VkNERDb29yZHMoZSx0KXtsZXQgbj1cIlwiO2NvbnN0IHI9ZS5sZW5ndGg7bGV0IGk9bnVsbDtyPDImJihpPVtdKSxpPW5ldyBBcnJheShyLTEpLGlbci0yXT1lW3ItMV07Zm9yKGxldCB0PXItMzt0Pj0wOy0tdClpW3RdPWlbdCsxXSplW3QrMV07Y29uc3QgYT1bXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiXSxzPWkubWFwKCgoZSx0KT0+YGludCAke2FbdF19ID0gaW5kZXggLyAke2V9OyAke3Q9PT1pLmxlbmd0aC0xP2BpbnQgJHthW3QrMV19ID0gaW5kZXggLSAke2FbdF19ICogJHtlfWA6YGluZGV4IC09ICR7YVt0XX0gKiAke2V9YH07YCkpLmpvaW4oXCJcIik7cmV0dXJuIG49YFxcbiAgICAgIGl2ZWM0IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RbMF19LCAke3RbMV19KSk7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke3RbMF19ICsgcmVzVGV4UkMueDtcXG4gICAgICAgICAgJHtzfVxcbiAgICAgICAgICByZXR1cm4gaXZlYzQociwgYywgZCwgZDIpO1xcbiAgICAgICAgfVxcbiAgICAgIGAsbmV3IG8uR2xzbExpYlJvdXRpbmUobil9Z2V0T3V0cHV0VW5wYWNrZWQ1RENvb3JkcyhlLHQpe2xldCBuPVwiXCI7Y29uc3Qgcj1lLmxlbmd0aDtsZXQgaT1udWxsO3I8MiYmKGk9W10pLGk9bmV3IEFycmF5KHItMSksaVtyLTJdPWVbci0xXTtmb3IobGV0IHQ9ci0zO3Q+PTA7LS10KWlbdF09aVt0KzFdKmVbdCsxXTtjb25zdCBhPVtcInJcIixcImNcIixcImRcIixcImQyXCIsXCJkM1wiXSxzPWkubWFwKCgoZSx0KT0+YGludCAke2FbdF19ID0gaW5kZXggLyAke2V9OyAke3Q9PT1pLmxlbmd0aC0xP2BpbnQgJHthW3QrMV19ID0gaW5kZXggLSAke2FbdF19ICogJHtlfWA6YGluZGV4IC09ICR7YVt0XX0gKiAke2V9YH07YCkpLmpvaW4oXCJcIik7cmV0dXJuIG49YFxcbiAgICAgIGl2ZWM1IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RbMF19LCAke3RbMV19KSk7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke3RbMF19ICsgcmVzVGV4UkMueDtcXG4gICAgICAgICAgJHtzfVxcbiAgICAgICAgICByZXR1cm4gaXZlYzUociwgYywgZCwgZDIsIGQzKTtcXG4gICAgICAgIH1cXG4gICAgICBgLG5ldyBvLkdsc2xMaWJSb3V0aW5lKG4pfWdldE91dHB1dFVucGFja2VkNkRDb29yZHMoZSx0KXtsZXQgbj1cIlwiO2NvbnN0IHI9ZS5sZW5ndGg7bGV0IGk9bnVsbDtyPDImJihpPVtdKSxpPW5ldyBBcnJheShyLTEpLGlbci0yXT1lW3ItMV07Zm9yKGxldCB0PXItMzt0Pj0wOy0tdClpW3RdPWlbdCsxXSplW3QrMV07Y29uc3QgYT1bXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiLFwiZDNcIixcImQ0XCJdLHM9aS5tYXAoKChlLHQpPT5gaW50ICR7YVt0XX0gPSBpbmRleCAvICR7ZX07ICR7dD09PWkubGVuZ3RoLTE/YGludCAke2FbdCsxXX0gPSBpbmRleCAtICR7YVt0XX0gKiAke2V9YDpgaW5kZXggLT0gJHthW3RdfSAqICR7ZX1gfTtgKSkuam9pbihcIlwiKTtyZXR1cm4gbj1gXFxuICAgICBpdmVjNiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7dFswXX0sICR7dFsxXX0pKTtcXG4gICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHt0WzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICAgJHtzfVxcbiAgICAgICAgIHJldHVybiBpdmVjNihyLCBjLCBkLCBkMiwgZDMsIGQ0KTtcXG4gICAgICAgfVxcbiAgICAgYCxuZXcgby5HbHNsTGliUm91dGluZShuKX1nZXRDb21tb25VdGlsRnVuY3MoKXtjb25zdCBlPXt9O2xldCB0PVwidXZGcm9tRmxhdFwiO2VbdF09bmV3IG8uR2xzbExpYlJvdXRpbmUoXCJcXG4gICAgdmVjMiB1dkZyb21GbGF0KGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XFxuICAgICAgaW50IHRleEMgPSBpbmRleCAvIHRleE51bVI7XFxuICAgICAgaW50IHRleFIgPSBpbmRleCAtIHRleEMgKiB0ZXhOdW1SO1xcbiAgICAgIC8vIFRPRE86IHN3YXAgdGV4UiwgdGV4QyBvcmRlciBpbiBmb2xsb3dpbmcgZnVuY3Rpb24gc28gcm93IGlzIGNvcnJlc3BvbmRpbmcgdG8gdSBhbmQgY29sdW1uIGlzIGNvcnJlc3BvbmRpbmcgdG9cXG4gICAgICAvLyAgICAgICB2LlxcbiAgICAgIHJldHVybiAodmVjMih0ZXhSLCB0ZXhDKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bVIsIHRleE51bUMpO1xcbiAgICB9XFxuICAgIFwiKSx0PVwicGFja2VkVVZmcm9tMURcIixlW3RdPW5ldyBvLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20xRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgICAgICAgaW50IHRleGVsSW5kZXggPSBpbmRleCAvIDI7XFxuICAgICAgICBpbnQgdGV4UiA9IHRleGVsSW5kZXggLyB0ZXhOdW1DO1xcbiAgICAgICAgaW50IHRleEMgPSB0ZXhlbEluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICAgICAgICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG4gICAgICB9XFxuICAgICAgXCIpLHQ9XCJwYWNrZWRVVmZyb20yRFwiLGVbdF09bmV3IG8uR2xzbExpYlJvdXRpbmUoXCJcXG4gICAgICB2ZWMyIHBhY2tlZFVWZnJvbTJEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IHRleGVsc0luTG9naWNhbFJvdywgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgaW50IHRleGVsSW5kZXggPSAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XFxuICAgICAgICBpbnQgdGV4UiA9IHRleGVsSW5kZXggLyB0ZXhOdW1DO1xcbiAgICAgICAgaW50IHRleEMgPSB0ZXhlbEluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICAgICAgICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG4gICAgICB9XFxuICAgICAgXCIpLHQ9XCJwYWNrZWRVVmZyb20zRFwiLGVbdF09bmV3IG8uR2xzbExpYlJvdXRpbmUoXCJcXG4gICAgICB2ZWMyIHBhY2tlZFVWZnJvbTNEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQyxcXG4gICAgICAgICAgaW50IHRleGVsc0luQmF0Y2gsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCBiLFxcbiAgICAgICAgICBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICBpbnQgaW5kZXggPSBiICogdGV4ZWxzSW5CYXRjaCArIChyb3cgLyAyKSAqIHRleGVsc0luTG9naWNhbFJvdyArIChjb2wgLyAyKTtcXG4gICAgICAgIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxuICAgICAgfVxcbiAgICAgIFwiKSx0PVwic2FtcGxlVGV4dHVyZVwiO2NvbnN0IG49KDAsaS5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO3JldHVybiBlW3RdPW5ldyBvLkdsc2xMaWJSb3V0aW5lKGBcXG4gICAgICAgIGZsb2F0IHNhbXBsZVRleHR1cmUoc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyLCB2ZWMyIHV2KSB7XFxuICAgICAgICAgICAgcmV0dXJuICR7bi50ZXh0dXJlMkR9KHRleHR1cmVTYW1wbGVyLCB1dikucjtcXG4gICAgICAgIH1gKSxlfWdldElucHV0c1NhbXBsaW5nU25pcHBldHMoKXtjb25zdCBlPXt9LHQ9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQ7cmV0dXJuIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKChuLHIpPT57Y29uc3Qgbz10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tyXSxpPSgwLHMuZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lKShuKTtvLmlzUGFja2VkP2VbaV09dGhpcy5nZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KGksbixvKTplW2ldPXRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGksbixvKTtjb25zdCBhPSgwLHMuZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHMpKG4pO28udW5wYWNrZWRTaGFwZS5sZW5ndGg8PXQudW5wYWNrZWRTaGFwZS5sZW5ndGgmJihvLmlzUGFja2VkP2VbYV09dGhpcy5nZXRQYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHMoYSxvLHQsbik6ZVthXT10aGlzLmdldFVucGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKGEsbyx0LG4pKX0pKSxlfWdldFBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhlLHQsbixpKXtjb25zdCBhPXQudW5wYWNrZWRTaGFwZSx1PW4udW5wYWNrZWRTaGFwZSxsPWksYz0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSkobCkscD1hLmxlbmd0aCxkPXUubGVuZ3RoLGY9ci5Ccm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXMoYSx1KSxoPSgwLHMuZ2V0Q29vcmRzRGF0YVR5cGUpKGQpLGc9ZC1wO2xldCBtO2NvbnN0IGI9KDAscy5nZXRHbENoYW5uZWxzKSgpO209MD09PXA/XCJcIjpkPDImJmYubGVuZ3RoPj0xP1wiY29vcmRzID0gMDtcIjpmLm1hcCgoZT0+YGNvb3Jkcy4ke2JbZStnXX0gPSAwO2ApKS5qb2luKFwiXFxuXCIpO2xldCB5PVwiXCI7eT1kPDImJnA+MD9cImNvb3Jkc1wiOmEubWFwKCgoZSx0KT0+YGNvb3Jkcy4ke2JbdCtnXX1gKSkuam9pbihcIiwgXCIpO2xldCB3PVwicmV0dXJuIG91dHB1dFZhbHVlO1wiO2NvbnN0IF89MT09PXIuU2hhcGVVdGlsLnNpemUoYSksdj0xPT09ci5TaGFwZVV0aWwuc2l6ZSh1KTtpZigxIT09cHx8X3x8dil7aWYoXyYmIXYpdz0xPT09ZD9cIlxcbiAgICAgICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54LCBvdXRwdXRWYWx1ZS54LCAwLiwgMC4pO1xcbiAgICAgICAgXCI6XCJcXG4gICAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCk7XFxuICAgICAgICBcIjtlbHNlIGlmKGYubGVuZ3RoKXtjb25zdCBlPXAtMix0PXAtMTtmLmluZGV4T2YoZSk+LTEmJmYuaW5kZXhPZih0KT4tMT93PVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCk7XCI6Zi5pbmRleE9mKGUpPi0xP3c9XCJyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54LCBvdXRwdXRWYWx1ZS55LCBvdXRwdXRWYWx1ZS54LCBvdXRwdXRWYWx1ZS55KTtcIjpmLmluZGV4T2YodCk+LTEmJih3PVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueHgsIG91dHB1dFZhbHVlLnp6KTtcIil9fWVsc2Ugdz1cIlxcbiAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueHksIG91dHB1dFZhbHVlLnh5KTtcXG4gICAgICBcIjtjb25zdCB4PWBcXG4gICAgICB2ZWM0ICR7ZX0oKSB7XFxuICAgICAgICAke2h9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgXFxuICAgICAgICBpbnQgbGFzdERpbSA9IGNvb3Jkcy4ke2JbZC0xXX07XFxuICAgICAgICBjb29yZHMuJHtiW2QtMV19ID0gY29vcmRzLiR7YltkLTJdfTtcXG4gICAgICAgIGNvb3Jkcy4ke2JbZC0yXX0gPSBsYXN0RGltO1xcbiAgICAgIFxcbiAgICAgICAgJHttfVxcbiAgICAgICAgdmVjNCBvdXRwdXRWYWx1ZSA9ICR7Y30oJHt5fSk7XFxuICAgICAgICAke3d9XFxuICAgICAgfVxcbiAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZSh4LFtcImNvb3JkaW5hdGVzLmdldE91dHB1dENvb3Jkc1wiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHMoZSx0LG4saSl7Y29uc3QgYT1bbi53aWR0aCxuLmhlaWdodF0sdT1bdC53aWR0aCx0LmhlaWdodF0sbD10LnVucGFja2VkU2hhcGUubGVuZ3RoLGM9bi51bnBhY2tlZFNoYXBlLmxlbmd0aCxwPXQudW5wYWNrZWRTaGFwZSxkPW4udW5wYWNrZWRTaGFwZSxmPSgwLHMuZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lKShpKTtpZihsPT09YyYmci5BcnJheVV0aWwuYXJyYXlzRXF1YWwodSxhKSl7Y29uc3QgdD1gXFxuICAgICAgICAgIGZsb2F0ICR7ZX0oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtpfSwgVGV4Q29vcmRzKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUodCxbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBoPSgwLHMuZ2V0Q29vcmRzRGF0YVR5cGUpKGMpLGc9ci5Ccm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXMocCxkKSxtPWMtbDtsZXQgYjtjb25zdCB5PSgwLHMuZ2V0R2xDaGFubmVscykoKTtiPTA9PT1sP1wiXCI6YzwyJiZnLmxlbmd0aD49MT9cImNvb3JkcyA9IDA7XCI6Zy5tYXAoKGU9PmBjb29yZHMuJHt5W2UrbV19ID0gMDtgKSkuam9pbihcIlxcblwiKTtsZXQgdz1cIlwiO3c9YzwyJiZsPjA/XCJjb29yZHNcIjp0LnVucGFja2VkU2hhcGUubWFwKCgoZSx0KT0+YGNvb3Jkcy4ke3lbdCttXX1gKSkuam9pbihcIiwgXCIpO2NvbnN0IF89YFxcbiAgICAgICAgZmxvYXQgJHtlfSgpIHtcXG4gICAgICAgICAgJHtofSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgJHtifVxcbiAgICAgICAgICByZXR1cm4gJHtmfSgke3d9KTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShfLFtcImNvb3JkaW5hdGVzLmdldE91dHB1dENvb3Jkc1wiXSl9Z2V0UGFja2VkU2FtcGxlckZyb21JbnB1dChlLHQsbil7c3dpdGNoKG4udW5wYWNrZWRTaGFwZS5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyU2NhbGFyKGUsdCk7Y2FzZSAxOnJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXIxRChlLHQsbik7Y2FzZSAyOnJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXIyRChlLHQsbik7Y2FzZSAzOnJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXIzRChlLHQsbik7ZGVmYXVsdDpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyTkQoZSx0LG4pfX1nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZSx0LG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlO3N3aXRjaChyLmxlbmd0aCl7Y2FzZSAwOnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlclNjYWxhcihlLHQsbik7Y2FzZSAxOnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjFEKGUsdCxuKTtjYXNlIDI6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyMkQoZSx0LG4pO2Nhc2UgMzpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIzRChlLHQsbik7Y2FzZSA0OnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjREKGUsdCxuKTtjYXNlIDU6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyNUQoZSx0LG4pO2Nhc2UgNjpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI2RChlLHQsbik7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRpbWVuc2lvbiAke3IubGVuZ3RofS1EYCl9fWdldFBhY2tlZFNhbXBsZXJTY2FsYXIoZSx0KXtjb25zdCBuPWBcXG4gICAgICAgICAgdmVjNCAke2V9KCkge1xcbiAgICAgICAgICAgIHJldHVybiAkeygwLGkuZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKS50ZXh0dXJlMkR9KCR7dH0sIGhhbGZDUik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKG4pfWdldFBhY2tlZFNhbXBsZXIxRChlLHQsbil7Y29uc3Qgcj1bbi53aWR0aCxuLmhlaWdodF0sYT1bclsxXSxyWzBdXSxzPSgwLGkuZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKSx1PWB2ZWM0ICR7ZX0oaW50IGluZGV4KSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTFEKFxcbiAgICAgICR7YVswXX0sICR7YVsxXX0sIGluZGV4KTtcXG4gICAgICByZXR1cm4gJHtzLnRleHR1cmUyRH0oJHt0fSwgdXYpO1xcbiAgICB9YDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUodSxbXCJjb29yZGluYXRlcy5wYWNrZWRVVmZyb20xRFwiXSl9Z2V0UGFja2VkU2FtcGxlcjJEKGUsdCxuKXtjb25zdCBhPW4udW5wYWNrZWRTaGFwZSxzPVtuLndpZHRoLG4uaGVpZ2h0XSx1PSgwLGkuZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKSxsPXNbMF0sYz1zWzFdO2lmKG51bGwhPXMmJnIuQXJyYXlVdGlsLmFycmF5c0VxdWFsKGEscykpe2NvbnN0IG49YHZlYzQgJHtlfShpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIoY29sLCByb3cpICsgaGFsZkNSKSAvIHZlYzIoJHtjfS4wLCAke2x9LjApO1xcbiAgICAgICAgcmV0dXJuICR7dS50ZXh0dXJlMkR9KCR7dH0sIHV2KTtcXG4gICAgICB9YDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUobil9Y29uc3QgcD1zLGQ9TWF0aC5jZWlsKGFbMV0vMiksZj1gdmVjNCAke2V9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tMkQoJHtwWzFdfSwgJHtwWzBdfSwgJHtkfSwgcm93LCBjb2wpO1xcbiAgICAgIHJldHVybiAke3UudGV4dHVyZTJEfSgke3R9LCB1dik7XFxuICAgIH1gO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShmLFtcImNvb3JkaW5hdGVzLnBhY2tlZFVWZnJvbTJEXCJdKX1nZXRQYWNrZWRTYW1wbGVyM0QoZSx0LG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLGE9W24ud2lkdGgsbi5oZWlnaHRdLHU9W2FbMF0sYVsxXV0sbD0oMCxpLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7aWYoMT09PXJbMF0pe2NvbnN0IGk9ci5zbGljZSgxKSxhPVsxLDJdLHU9KDAscy5zcXVlZXplSW5wdXRTaGFwZSkocixpKSxsPVtcImJcIixcInJvd1wiLFwiY29sXCJdLGM9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShuKSk7Yy51bnBhY2tlZFNoYXBlPXU7Y29uc3QgcD10aGlzLmdldFBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZSx0LGMpLGQ9YCR7cC5yb3V0aW5lQm9keX1cXG4gICAgICB2ZWM0ICR7ZX0oaW50IGIsIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIHJldHVybiAke2V9KCR7KDAscy5nZXRTcXVlZXplZFBhcmFtcykobCxhKX0pO1xcbiAgICAgIH0gYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUoZCxwLmRlcGVuZGVuY2llcyl9Y29uc3QgYz11WzBdLHA9dVsxXSxkPU1hdGguY2VpbChyWzJdLzIpLGY9YHZlYzQgJHtlfShpbnQgYiwgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20zRChcXG4gICAgICAgICR7cH0sICR7Y30sICR7ZCpNYXRoLmNlaWwoclsxXS8yKX0sICR7ZH0sIGIsIHJvdywgY29sKTtcXG4gICAgICByZXR1cm4gJHtsLnRleHR1cmUyRH0oJHt0fSwgdXYpO31gO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShmLFtcImNvb3JkaW5hdGVzLnBhY2tlZFVWZnJvbTNEXCJdKX1nZXRQYWNrZWRTYW1wbGVyTkQoZSx0LG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLGE9ci5sZW5ndGgscz1bbi53aWR0aCxuLmhlaWdodF0sdT0oMCxpLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbiksbD1bc1swXSxzWzFdXSxjPWxbMV0scD1sWzBdLGQ9TWF0aC5jZWlsKHJbYS0xXS8yKTtsZXQgZj1kKk1hdGguY2VpbChyW2EtMl0vMiksaD1cImludCBiLCBpbnQgcm93LCBpbnQgY29sXCIsZz1gYiAqICR7Zn0gKyAocm93IC8gMikgKiAke2R9ICsgKGNvbCAvIDIpYDtmb3IobGV0IGU9MjtlPGEtMTtlKyspaD1gaW50IGIke2V9LCBgK2gsZio9clthLWUtMV0sZz1gYiR7ZX0gKiAke2Z9ICsgYCtnO2NvbnN0IG09YHZlYzQgJHtlfSgke2h9KSB7XFxuICAgICAgaW50IGluZGV4ID0gJHtnfTtcXG4gICAgICBpbnQgdGV4UiA9IGluZGV4IC8gJHtwfTtcXG4gICAgICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqICR7cH07XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoJHtwfSwgJHtjfSk7XFxuICAgICAgcmV0dXJuICR7dS50ZXh0dXJlMkR9KCR7dH0sIHV2KTtcXG4gICAgfWA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKG0pfWdldFVucGFja2VkU2FtcGxlclNjYWxhcihlLHQsbil7Y29uc3RbcixpXT1bbi53aWR0aCxuLmhlaWdodF07aWYoMT09PXImJjE9PT1pKXtjb25zdCBuPWBcXG4gICAgICAgICAgZmxvYXQgJHtlfSgpIHtcXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke3R9LCBoYWxmQ1IpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShuLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWNvbnN0IGE9YFxcbiAgICAgICAgZmxvYXQgJHtlfSgpIHtcXG4gICAgICAgICAgaW50IG9mZnNldF8ke3R9ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke3J9LCAke2l9KTtcXG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtyfSwgJHtpfSwgb2Zmc2V0XyR7dH0pO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke3R9LCB1dik7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUoYSxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyMUQoZSx0LG4pe2NvbnN0IHI9bi53aWR0aCxpPW4uaGVpZ2h0O2lmKDE9PT1pJiYxPT09cil7Y29uc3Qgbj1gXFxuICAgICAgICBmbG9hdCAke2V9KGludCBpbmRleCkge1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke3R9LCBoYWxmQ1IpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKG4sW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9aWYoMT09PWkpe2NvbnN0IG49YFxcbiAgICAgICAgICBmbG9hdCAke2V9KGludCBpbmRleCkge1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKChmbG9hdChpbmRleCkgKyAwLjUpIC8gJHtyfS4wLCAwLjUpO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7dH0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1pZigxPT09cil7Y29uc3Qgbj1gXFxuICAgICAgICAgIGZsb2F0ICR7ZX0oaW50IGluZGV4KSB7XFxuICAgICAgICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoZmxvYXQoaW5kZXgpICsgMC41KSAvICR7aX0uMCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHt0fSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShuLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWNvbnN0IGE9YFxcbiAgICAgICAgZmxvYXQgJHtlfShpbnQgaW5kZXgpIHtcXG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtyfSwgJHtpfSwgaW5kZXgpO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke3R9LCB1dik7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUoYSxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1nZXRVbnBhY2tlZFNhbXBsZXIyRChlLHQsbil7Y29uc3QgaT1uLnVucGFja2VkU2hhcGUsdT1bbi5oZWlnaHQsbi53aWR0aF07aWYobnVsbCE9dSYmci5BcnJheVV0aWwuYXJyYXlzRXF1YWwoaSx1KSl7Y29uc3Qgbj1gXFxuICAgICAgICAgIGZsb2F0ICR7ZX0oaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSAodmVjMihyb3csIGNvbCkgKyBoYWxmQ1IpIC8gdmVjMigke3VbMV19LjAsICR7dVswXX0uMCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHt0fSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShuLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWNvbnN0e25ld1NoYXBlOmwsa2VwdERpbXM6Y309KDAsYS5zcXVlZXplU2hhcGUpKGkpLHA9bDtpZihwLmxlbmd0aDxpLmxlbmd0aCl7Y29uc3Qgcj0oMCxzLnNxdWVlemVJbnB1dFNoYXBlKShpLHApLGE9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShuKSk7YS51bnBhY2tlZFNoYXBlPXI7Y29uc3QgdT1bXCJjb2xcIixcInJvd1wiXSxsPWBcXG4gICAgICAgICAgJHt0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChlLHQsYSkucm91dGluZUJvZHl9XFxuICAgICAgICAgIGZsb2F0ICR7ZX0oaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICAgIHJldHVybiAke2V9KCR7KDAscy5nZXRTcXVlZXplZFBhcmFtcykodSxjKX0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShsLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWNvbnN0IGQ9dVsxXSxmPXVbMF07aWYoMT09PWYpe2NvbnN0IG49YFxcbiAgICAgICAgICBmbG9hdCAke2V9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgICBpbnQgb2Zmc2V0XyR7dH0gPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7ZH0sICR7Zn0pO1xcbiAgICAgICAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzMocm93LCBjb2wsIG9mZnNldF8ke3R9KSwgdmVjMygke2lbMV19LCAxLCAxKSk7XFxuICAgICAgICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoaW5kZXggKyAwLjUpIC8gJHtkfS4wKTtcXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke3R9LCB1dik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKG4sW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXRcIl0pfWlmKDE9PT1kKXtjb25zdCBuPWBcXG4gICAgICAgICAgZmxvYXQgJHtlfShpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgICAgaW50IG9mZnNldF8ke3R9ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke2R9LCAke2Z9KTtcXG4gICAgICAgICAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMzKHJvdywgY29sLCBvZmZzZXRfJHt0fSksIHZlYzMoJHtpWzFdfSwgMSwgMSkpO1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKChpbmRleCArIDAuNSkgLyAke2Z9LjAsIDAuNSk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHt0fSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShuLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX1jb25zdCBoPWBcXG4gICAgICAgIGZsb2F0ICR7ZX0oaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICBpbnQgaW5kZXggPSBjb2wgKiAke2lbMV19ICsgcm93O1xcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke2R9LCAke2Z9LCBpbmRleCk7XFxuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7dH0sIHV2KTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShoLFtcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIixcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX1nZXRVbnBhY2tlZFNhbXBsZXIzRChlLHQsbil7Y29uc3Qgcj1uLnVucGFja2VkU2hhcGUsaT1yWzFdKnJbMl0sdT1yWzJdLHtuZXdTaGFwZTpsLGtlcHREaW1zOmN9PSgwLGEuc3F1ZWV6ZVNoYXBlKShyKSxwPWw7aWYocC5sZW5ndGg8ci5sZW5ndGgpe2NvbnN0IGk9KDAscy5zcXVlZXplSW5wdXRTaGFwZSkocixwKSxhPVtcImJhdGNoXCIsXCJjb2xcIixcInJvd1wiXSx1PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO3UudW5wYWNrZWRTaGFwZT1pO2NvbnN0IGw9dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZSx0LHUpLGQ9Yy5yZXZlcnNlKCksZj1gXFxuICAgICAgICAgICR7bC5yb3V0aW5lQm9keX1cXG4gICAgICAgICAgZmxvYXQgJHtlfShpbnQgYmF0Y2gsIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHtlfSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKGEsZCl9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUoZixsLmRlcGVuZGVuY2llcyl9Y29uc3QgZD1gXFxuICAgICAgICAgIGZsb2F0ICR7ZX0oaW50IGRlcHRoLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgICAgICAgICAgIGludCBpbmRleCA9IGRlcHRoICogJHtpfSArIGNvbCAqICR7dX0gKyByb3c7XFxuICAgICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtuLndpZHRofSwgJHtuLmhlaWdodH0sIGluZGV4KTtcXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke3R9LCB1dik7XFxuICAgICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShkLFtcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIixcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX1nZXRVbnBhY2tlZFNhbXBsZXI0RChlLHQsbil7Y29uc3Qgcj1uLnVucGFja2VkU2hhcGUsaT1yWzNdLGE9clsyXSppLHM9YFxcbiAgICAgICAgZmxvYXQgJHtlfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgICAgaW50IGluZGV4ID0gcm93ICogJHtyWzFdKmF9ICsgY29sICogJHthfSArXFxuICAgICAgICAgICAgICBkZXB0aDIgKiAke2l9ICsgZGVwdGg7XFxuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7bi53aWR0aH0sICR7bi5oZWlnaHR9LCBpbmRleCk7XFxuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7dH0sIHV2KTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShzLFtcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIixcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWdldFVucGFja2VkU2FtcGxlcjVEKGUsdCxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZSxpPXJbNF0sdT1yWzNdKmksbD1yWzJdKnUsYz1yWzFdKmwse25ld1NoYXBlOnAsa2VwdERpbXM6ZH09KDAsYS5zcXVlZXplU2hhcGUpKHIpO2lmKHAubGVuZ3RoPHIubGVuZ3RoKXtjb25zdCBpPSgwLHMuc3F1ZWV6ZUlucHV0U2hhcGUpKHIscCksYT1bXCJyb3dcIixcImNvbFwiLFwiZGVwdGhcIixcImRlcHRoMlwiLFwiZGVwdGgzXCJdLHU9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShuKSk7dS51bnBhY2tlZFNoYXBlPWk7Y29uc3QgbD1gXFxuICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZSx0LHUpLnJvdXRpbmVCb2R5fVxcbiAgICAgICAgICBmbG9hdCAke2V9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgICAgICAgIHJldHVybiAke2V9KCR7KDAscy5nZXRTcXVlZXplZFBhcmFtcykoYSxkKX0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShsLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIl0pfWNvbnN0IGY9YFxcbiAgICAgICAgZmxvYXQgJHtlfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgICAgaW50IGluZGV4ID0gcm93ICogJHtjfSArIGNvbCAqICR7bH0gKyBkZXB0aCAqICR7dX0gK1xcbiAgICAgICAgICBkZXB0aDMgKiAke2l9ICsgZGVwdGgyO1xcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke24ud2lkdGh9LCAke24uaGVpZ2h0fSwgaW5kZXgpO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke3R9LCB1dik7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUoZixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCJdKX1nZXRVbnBhY2tlZFNhbXBsZXI2RChlLHQsbil7Y29uc3Qgcj1uLnVucGFja2VkU2hhcGUsaT1yWzVdLHU9cls0XSppLGw9clszXSp1LGM9clsyXSpsLHA9clsxXSpjLHtuZXdTaGFwZTpkLGtlcHREaW1zOmZ9PSgwLGEuc3F1ZWV6ZVNoYXBlKShyKTtpZihkLmxlbmd0aDxyLmxlbmd0aCl7Y29uc3QgaT0oMCxzLnNxdWVlemVJbnB1dFNoYXBlKShyLGQpLGE9W1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIixcImRlcHRoM1wiLFwiZGVwdGg0XCJdLHU9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShuKSk7dS51bnBhY2tlZFNoYXBlPWk7Y29uc3QgbD1gXFxuICAgICAgICAgICAgJHt0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChlLHQsdSkucm91dGluZUJvZHl9XFxuICAgICAgICAgICAgZmxvYXQgJHtlfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICAgICAgICByZXR1cm4gJHtlfSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKGEsZil9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKGwsW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiXSl9Y29uc3QgaD1gXFxuICAgICAgICAgIGZsb2F0ICR7ZX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcXG4gICAgICAgICAgICBpbnQgaW5kZXggPSByb3cgKiAke3B9ICsgY29sICogJHtjfSArIGRlcHRoICogJHtsfSArXFxuICAgICAgICAgICAgZGVwdGgyICogJHt1fSArIGRlcHRoMyAqICR7aX0gKyBkZXB0aDQ7XFxuICAgICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtuLndpZHRofSwgJHtuLmhlaWdodH0sIGluZGV4KTtcXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke3R9LCB1dik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKGgsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXRcIl0pfXRvVmVjKCl7Y29uc3QgZT10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dCx0PWUuc2hhcGUubGVuZ3RoLG49ZS5zdHJpZGVzLHI9ZS53aWR0aCxpPWUuaGVpZ2h0LGE9W107Zm9yKGxldCBlPTA7ZTx0LTE7KytlKWEucHVzaChgXFxuICAgICAgICBjWyR7ZX1dID0gb2Zmc2V0IC8gJHtuW2VdfTtgKSxhLnB1c2goYFxcbiAgICAgICAgb2Zmc2V0IC09IGNbJHtlfV0gKiAke25bZV19O2ApO2EucHVzaChgXFxuICAgICAgICBjWyR7dC0xfV0gPSBvZmZzZXQ7YCk7Y29uc3Qgcz1gXFxuICAgICAgdm9pZCB0b1ZlYyh2ZWMyIHRleENvb3Jkcywgb3V0IGludCBjWyR7dH1dKSB7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gY29vcmRzVG9PZmZzZXQodGV4Q29vcmRzLCAke3J9LCAke2l9KTtcXG4gICAgICAgICR7YS5qb2luKFwiXCIpfVxcbiAgICAgIH1cXG4gICAgICB2b2lkIHRvVmVjKGludCBvZmZzZXQsIG91dCBpbnQgY1ske3R9XSkge1xcbiAgICAgICAgJHthLmpvaW4oXCJcIil9XFxuICAgICAgfVxcbiAgICBgO3JldHVybnt0b1ZlYzpuZXcgby5HbHNsTGliUm91dGluZShzLFtcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX19dmFsdWVGcm9tKCl7Y29uc3QgZT17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKHQsbik9Pntjb25zdCByPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW25dLGk9KHIudW5wYWNrZWRTaGFwZS5sZW5ndGg+MD9yLnVucGFja2VkU2hhcGU6ci5zaGFwZSkubGVuZ3RoO2xldCBhPWBfJHt0fWA7ZVthXT1uZXcgby5HbHNsTGliUm91dGluZSh0aGlzLmdldFZhbHVlRnJvbVNpbmdsZSh0LGksci53aWR0aCxyLmhlaWdodCwhMSksW2BzaGFwZVV0aWxzLmluZGljZXNUb09mZnNldCR7YX1gLFwiY29vcmRpbmF0ZXMub2Zmc2V0VG9Db29yZHNcIixcImZyYWdjb2xvci5nZXRDb2xvckFzRmxvYXRcIl0pLGErPVwiX1RcIixlW2FdPW5ldyBvLkdsc2xMaWJSb3V0aW5lKHRoaXMuZ2V0VmFsdWVGcm9tU2luZ2xlKHQsaSxyLndpZHRoLHIuaGVpZ2h0LCEwKSxbYHNoYXBlVXRpbHMuaW5kaWNlc1RvT2Zmc2V0JHthfWAsXCJjb29yZGluYXRlcy5vZmZzZXRUb0Nvb3Jkc1wiLFwiZnJhZ2NvbG9yLmdldENvbG9yQXNGbG9hdFwiXSl9KSksZX1nZXRWYWx1ZUZyb21TaW5nbGUoZSx0LG4scixvKXtsZXQgYT1gXyR7ZX1gO3JldHVybiBvJiYoYSs9XCJfVFwiKSxgXFxuICAgICAgICBmbG9hdCAke2F9KGludCBtWyR7dH1dKSB7XFxuICAgICAgICAgIGludCBvZmZzZXQgPSBpbmRpY2VzVG9PZmZzZXQke2F9KG0pO1xcbiAgICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHtufSwgJHtyfSk7XFxuICAgICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7KDAsaS5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pLnRleHR1cmUyRH0oJHtlfSwgY29vcmRzKSk7XFxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGB9Z2V0UGFja2VkVmFsdWVGcm9tKGUsdCxuLHIsbyl7bGV0IGE9YF8ke2V9X1BhY2tgO3JldHVybiBvJiYoYSs9XCJfVFwiKSxgXFxuICAgICAgICB2ZWM0ICR7YX0oaW50IG1bJHt0fV0pIHtcXG4gICAgICAgICAgaW50IG9mZnNldCA9IGluZGljZXNUb09mZnNldF8ke2V9KG0pO1xcbiAgICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHtufSwgJHtyfSk7XFxuICAgICAgICAgIHJldHVybiAkeygwLGkuZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKS50ZXh0dXJlMkR9KCR7ZX0sIGNvb3Jkcyk7XFxuICAgICAgICB9XFxuICAgICAgICBgfX10LkNvb3Jkc0dsc2xMaWI9dX0sMTk5NzooZSx0KT0+e1widXNlIHN0cmljdFwiO3ZhciBuO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuVG9wb2xvZ2ljYWxTb3J0R2xzbFJvdXRpbmVzPXQuR2xzbExpYlJvdXRpbmVOb2RlPXQuR2xzbExpYlJvdXRpbmU9dC5HbHNsTGliPXQuR2xzbENvbnRleHQ9dC5GdW5jdGlvblR5cGU9dm9pZCAwLChuPXQuRnVuY3Rpb25UeXBlfHwodC5GdW5jdGlvblR5cGU9e30pKVtuLlZhbHVlQmFzZWQ9MF09XCJWYWx1ZUJhc2VkXCIsbltuLlBvc2l0aW9uYWw9MV09XCJQb3NpdGlvbmFsXCIsdC5HbHNsQ29udGV4dD1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixyKXt0aGlzLmdsQ29udGV4dD1lLHRoaXMucHJvZ3JhbUluZm89dCx0aGlzLmlucHV0VGV4dHVyZUxheW91dHM9bix0aGlzLm91dHB1dFRleHR1cmVMYXlvdXQ9cn19LHQuR2xzbExpYj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLmNvbnRleHQ9ZX19LHQuR2xzbExpYlJvdXRpbmU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLnJvdXRpbmVCb2R5PWUsdGhpcy5kZXBlbmRlbmNpZXM9dH19LHQuR2xzbExpYlJvdXRpbmVOb2RlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuKXt0aGlzLm5hbWU9ZSx0aGlzLmRlcGVuZGVuY2llcz1ufHxbXSx0JiYodGhpcy5yb3V0aW5lQm9keT10KX1hZGREZXBlbmRlbmN5KGUpe2UmJnRoaXMuZGVwZW5kZW5jaWVzLnB1c2goZSl9fSx0LlRvcG9sb2dpY2FsU29ydEdsc2xSb3V0aW5lcz1jbGFzc3tzdGF0aWMgcmV0dXJuT3JkZXJlZE5vZGVzKGUpe2lmKCFlfHwwPT09ZS5sZW5ndGgpcmV0dXJuW107aWYoMT09PWUubGVuZ3RoKXJldHVybiBlO2NvbnN0IHQ9bmV3IFNldCxuPW5ldyBTZXQscj1uZXcgQXJyYXk7cmV0dXJuIHRoaXMuY3JlYXRlT3JkZXJlZE5vZGVzKGUsdCxuLHIpLHJ9c3RhdGljIGNyZWF0ZU9yZGVyZWROb2RlcyhlLHQsbixyKXtmb3IobGV0IG89MDtvPGUubGVuZ3RoOysrbyl0aGlzLmRmc1RyYXZlcnNlKGVbb10sdCxuLHIpfXN0YXRpYyBkZnNUcmF2ZXJzZShlLHQsbixyKXtpZighZXx8bi5oYXMoZS5uYW1lKSlyZXR1cm47aWYodC5oYXMoZS5uYW1lKSl0aHJvdyBuZXcgRXJyb3IoXCJDeWNsaWMgZGVwZW5kZW5jeSBkZXRlY3RlZC4gQ2FuJ3QgdG9wb2xvZ2ljYWxseSBzb3J0IHJvdXRpbmVzIG5lZWRlZCBmb3Igc2hhZGVyLlwiKTt0LmFkZChlLm5hbWUpO2NvbnN0IG89ZS5kZXBlbmRlbmNpZXM7aWYobyYmby5sZW5ndGg+MClmb3IobGV0IGU9MDtlPG8ubGVuZ3RoOysrZSl0aGlzLmRmc1RyYXZlcnNlKG9bZV0sdCxuLHIpO3IucHVzaChlKSxuLmFkZChlLm5hbWUpLHQuZGVsZXRlKGUubmFtZSl9fX0sMTM3MTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5FbmNvZGluZ0dsc2xMaWI9dm9pZCAwO2NvbnN0IHI9bigxOTk3KTtjbGFzcyBvIGV4dGVuZHMgci5HbHNsTGlie2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpfWdldEZ1bmN0aW9ucygpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdGhpcy5lbmNvZGVGbG9hdDMyKCkpLHRoaXMuZGVjb2RlRmxvYXQzMigpKX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fWVuY29kZUZsb2F0MzIoKXtyZXR1cm57ZW5jb2RlOm5ldyByLkdsc2xMaWJSb3V0aW5lKFwiaGlnaHAgdmVjNCBlbmNvZGUoaGlnaHAgZmxvYXQgZikge1xcbiAgICAgICAgcmV0dXJuIHZlYzQoZiwgMC4wLCAwLjAsIDAuMCk7XFxuICAgICAgfVxcbiAgICAgICAgXCIpfX1kZWNvZGVGbG9hdDMyKCl7cmV0dXJue2RlY29kZTpuZXcgci5HbHNsTGliUm91dGluZShcImhpZ2hwIGZsb2F0IGRlY29kZShoaWdocCB2ZWM0IHJnYmEpIHtcXG4gICAgICAgIHJldHVybiByZ2JhLnI7XFxuICAgICAgfVxcbiAgICAgICAgXCIpfX1lbmNvZGVVaW50OCgpe2NvbnN0IGU9by5pc0xpdHRsZUVuZGlhbigpP1wicmdiYS5yZ2JhPXJnYmEuYWJncjtcIjpcIlwiO3JldHVybntlbmNvZGU6bmV3IHIuR2xzbExpYlJvdXRpbmUoYFxcbiAgICAgIGhpZ2hwIHZlYzQgZW5jb2RlKGhpZ2hwIGZsb2F0IGYpIHtcXG4gICAgICAgIGhpZ2hwIGZsb2F0IEYgPSBhYnMoZik7XFxuICAgICAgICBoaWdocCBmbG9hdCBTaWduID0gc3RlcCgwLjAsLWYpO1xcbiAgICAgICAgaGlnaHAgZmxvYXQgRXhwb25lbnQgPSBmbG9vcihsb2cyKEYpKTtcXG4gICAgICAgIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gKGV4cDIoLSBFeHBvbmVudCkgKiBGKTtcXG4gICAgICAgIEV4cG9uZW50ID0gZmxvb3IobG9nMihGKSArIDEyNy4wKSArIGZsb29yKGxvZzIoTWFudGlzc2EpKTtcXG4gICAgICAgIGhpZ2hwIHZlYzQgcmdiYTtcXG4gICAgICAgIHJnYmFbMF0gPSAxMjguMCAqIFNpZ24gICsgZmxvb3IoRXhwb25lbnQqZXhwMigtMS4wKSk7XFxuICAgICAgICByZ2JhWzFdID0gMTI4LjAgKiBtb2QoRXhwb25lbnQsMi4wKSArIG1vZChmbG9vcihNYW50aXNzYSoxMjguMCksMTI4LjApO1xcbiAgICAgICAgcmdiYVsyXSA9IGZsb29yKG1vZChmbG9vcihNYW50aXNzYSpleHAyKDIzLjAgLTguMCkpLGV4cDIoOC4wKSkpO1xcbiAgICAgICAgcmdiYVszXSA9IGZsb29yKGV4cDIoMjMuMCkqbW9kKE1hbnRpc3NhLGV4cDIoLTE1LjApKSk7XFxuICAgICAgICAke2V9XFxuICAgICAgICByZ2JhID0gcmdiYSAvIDI1NS4wOyAvLyB2YWx1ZXMgbmVlZCB0byBiZSBub3JtYWxpemVkIHRvIFswLDFdXFxuICAgICAgICByZXR1cm4gcmdiYTtcXG4gICAgfVxcbiAgICAgICAgYCl9fWRlY29kZVVpbnQ4KCl7Y29uc3QgZT1vLmlzTGl0dGxlRW5kaWFuKCk/XCJyZ2JhLnJnYmE9cmdiYS5hYmdyO1wiOlwiXCI7cmV0dXJue2RlY29kZTpuZXcgci5HbHNsTGliUm91dGluZShgXFxuICAgICAgICBoaWdocCBmbG9hdCBkZWNvZGUoaGlnaHAgdmVjNCByZ2JhKSB7XFxuICAgICAgICAgIHJnYmEgPSByZ2JhICogMjU1LjA7IC8vIHZhbHVlcyBuZWVkIHRvIGJlIGRlLW5vcm1hbGl6ZWQgZnJvbSBbMCwxXSB0byBbMCwyNTVdXFxuICAgICAgICAgICR7ZX1cXG4gICAgICAgICAgaGlnaHAgZmxvYXQgU2lnbiA9IDEuMCAtIHN0ZXAoMTI4LjAscmdiYVswXSkqMi4wO1xcbiAgICAgICAgICBoaWdocCBmbG9hdCBFeHBvbmVudCA9IDIuMCAqIG1vZChyZ2JhWzBdLDEyOC4wKSArIHN0ZXAoMTI4LjAscmdiYVsxXSkgLSAxMjcuMDtcXG4gICAgICAgICAgaGlnaHAgZmxvYXQgTWFudGlzc2EgPSBtb2QocmdiYVsxXSwxMjguMCkqNjU1MzYuMCArIHJnYmFbMl0qMjU2LjAgK3JnYmFbM10gKyBmbG9hdCgweDgwMDAwMCk7XFxuICAgICAgICAgIGhpZ2hwIGZsb2F0IFJlc3VsdCA9ICBTaWduICogZXhwMihFeHBvbmVudCkgKiAoTWFudGlzc2EgKiBleHAyKC0yMy4wICkpO1xcbiAgICAgICAgICByZXR1cm4gUmVzdWx0O1xcbiAgICAgIH1cXG4gICAgICAgIGApfX1zdGF0aWMgaXNMaXR0bGVFbmRpYW4oKXtjb25zdCBlPW5ldyBBcnJheUJ1ZmZlcig0KSx0PW5ldyBVaW50MzJBcnJheShlKSxuPW5ldyBVaW50OEFycmF5KGUpO2lmKHRbMF09MzczNTkyODU1OSwyMzk9PT1uWzBdKXJldHVybiEwO2lmKDIyMj09PW5bMF0pcmV0dXJuITE7dGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBlbmRpYW5uZXNzXCIpfX10LkVuY29kaW5nR2xzbExpYj1vfSwyNjkxOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkZyYWdDb2xvckdsc2xMaWI9dm9pZCAwO2NvbnN0IHI9bigxOTk3KSxvPW4oNjc1Nyk7Y2xhc3MgaSBleHRlbmRzIHIuR2xzbExpYntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKX1nZXRGdW5jdGlvbnMoKXtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHRoaXMuc2V0RnJhZ0NvbG9yKCkpLHRoaXMuZ2V0Q29sb3JBc0Zsb2F0KCkpfWdldEN1c3RvbVR5cGVzKCl7cmV0dXJue319c2V0RnJhZ0NvbG9yKCl7Y29uc3QgZT0oMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7cmV0dXJue3NldEZyYWdDb2xvcjpuZXcgci5HbHNsTGliUm91dGluZShgXFxuICAgICAgICB2b2lkIHNldEZyYWdDb2xvcihmbG9hdCB2YWx1ZSkge1xcbiAgICAgICAgICAgICR7ZS5vdXRwdXR9ID0gZW5jb2RlKHZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGAsW1wiZW5jb2RpbmcuZW5jb2RlXCJdKX19Z2V0Q29sb3JBc0Zsb2F0KCl7cmV0dXJue2dldENvbG9yQXNGbG9hdDpuZXcgci5HbHNsTGliUm91dGluZShcIlxcbiAgICAgICAgZmxvYXQgZ2V0Q29sb3JBc0Zsb2F0KHZlYzQgY29sb3IpIHtcXG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlKGNvbG9yKTtcXG4gICAgICAgIH1cXG4gICAgICAgIFwiLFtcImVuY29kaW5nLmRlY29kZVwiXSl9fX10LkZyYWdDb2xvckdsc2xMaWI9aX0sMzg3ODooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucmVwbGFjZUlubGluZXM9dm9pZCAwO2NvbnN0IG49L0BpbmxpbmVbXFxzXFxuXFxyXSsoXFx3KylbXFxzXFxuXFxyXSsoWzAtOWEtekEtWl9dKylcXHMqXFwoKFteKV0qKVxcKVxccyp7KChbXn1dfFtcXG5cXHJdKSopfS9nbTt0LnJlcGxhY2VJbmxpbmVzPWZ1bmN0aW9uKGUpe2NvbnN0IHQ9e307bGV0IHI7Zm9yKDtudWxsIT09KHI9bi5leGVjKGUpKTspe2NvbnN0IGU9clszXS5zcGxpdChcIixcIikubWFwKChlPT57Y29uc3QgdD1lLnRyaW0oKS5zcGxpdChcIiBcIik7cmV0dXJuIHQmJjI9PT10Lmxlbmd0aD97dHlwZTp0WzBdLG5hbWU6dFsxXX06bnVsbH0pKS5maWx0ZXIoKGU9Pm51bGwhPT1lKSk7dFtyWzJdXT17cGFyYW1zOmUsYm9keTpyWzRdfX1mb3IoY29uc3QgbiBpbiB0KXtjb25zdCBvPVwiKFxcXFx3Kyk/XFxcXHMrKFtfMC05YS16QS1aXSspXFxcXHMrPVxcXFxzK19fRlVOQ19fXFxcXCgoLiopXFxcXClcXFxccyo7XCIucmVwbGFjZShcIl9fRlVOQ19fXCIsbiksaT1uZXcgUmVnRXhwKG8sXCJnbVwiKTtmb3IoO251bGwhPT0ocj1pLmV4ZWMoZSkpOyl7Y29uc3Qgbz1yWzFdLGk9clsyXSxhPXJbM10uc3BsaXQoXCIsXCIpLHM9bz9gJHtvfSAke2l9O2A6XCJcIjtsZXQgdT10W25dLmJvZHksbD1cIlwiO3Rbbl0ucGFyYW1zLmZvckVhY2goKChlLHQpPT57ZSYmKGwrPWAke2UudHlwZX0gJHtlLm5hbWV9ID0gJHthW3RdfTtcXG5gKX0pKSx1PWAke2x9XFxuICR7dX1gLHU9dS5yZXBsYWNlKFwicmV0dXJuXCIsYCR7aX0gPSBgKTtjb25zdCBjPWBcXG4gICAgICAke3N9XFxuICAgICAge1xcbiAgICAgICAgJHt1fVxcbiAgICAgIH1cXG4gICAgICBgO2U9ZS5yZXBsYWNlKHJbMF0sYyl9fXJldHVybiBlLnJlcGxhY2UobixcIlwiKX19LDg4OTc6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuR2xzbFByZXByb2Nlc3Nvcj12b2lkIDA7Y29uc3Qgcj1uKDE5OTcpLG89bigzODc4KSxpPW4oMTI0OCksYT1uKDY3NTcpO3QuR2xzbFByZXByb2Nlc3Nvcj1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixvKXt0aGlzLmxpYnM9e30sdGhpcy5nbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaD17fSx0aGlzLmNvbnRleHQ9bmV3IHIuR2xzbENvbnRleHQoZSx0LG4sbyksT2JqZWN0LmtleXMoaS5nbHNsUmVnaXN0cnkpLmZvckVhY2goKGU9Pntjb25zdCB0PW5ldyBpLmdsc2xSZWdpc3RyeVtlXSh0aGlzLmNvbnRleHQpO3RoaXMubGlic1tlXT10fSkpO2NvbnN0IGE9dGhpcy5nbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaDtmb3IoY29uc3QgZSBpbiB0aGlzLmxpYnMpe2NvbnN0IHQ9dGhpcy5saWJzW2VdLmdldEZ1bmN0aW9ucygpO2Zvcihjb25zdCBuIGluIHQpe2NvbnN0IG89ZStcIi5cIituO2xldCBpO2Fbb10/KGk9YVtvXSxpLnJvdXRpbmVCb2R5PXRbbl0ucm91dGluZUJvZHkpOihpPW5ldyByLkdsc2xMaWJSb3V0aW5lTm9kZShvLHRbbl0ucm91dGluZUJvZHkpLGFbb109aSk7Y29uc3Qgcz10W25dLmRlcGVuZGVuY2llcztpZihzKWZvcihsZXQgZT0wO2U8cy5sZW5ndGg7KytlKWlmKGFbc1tlXV0paS5hZGREZXBlbmRlbmN5KGFbc1tlXV0pO2Vsc2V7Y29uc3QgdD1uZXcgci5HbHNsTGliUm91dGluZU5vZGUoc1tlXSk7YVtzW2VdXT10LGkuYWRkRGVwZW5kZW5jeSh0KX19fX1wcmVwcm9jZXNzKCl7Y29uc3QgZT10aGlzLmNvbnRleHQucHJvZ3JhbUluZm87bGV0IHQ9ZS5zaGFkZXJTb3VyY2U7cmV0dXJuIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5oYXNNYWlufHwodD1gJHt0fVxcbiAgICAgICR7KDAsYS5nZXREZWZhdWx0RnJhZ1NoYWRlck1haW4pKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbix0aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGgpfWApLHQ9KDAsby5yZXBsYWNlSW5saW5lcykodCksYCR7KDAsYS5nZXRGcmFnU2hhZGVyUHJlYW1ibGUpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbil9XFxuICAgICR7dGhpcy5nZXRVbmlmb3JtcyhlLmlucHV0TmFtZXMsZS52YXJpYWJsZXMpfVxcbiAgICAke3RoaXMuZ2V0SW1wb3J0cyh0KX1cXG4gICAgJHt0fWB9Z2V0SW1wb3J0cyhlKXtjb25zdCB0PXRoaXMuc2VsZWN0R2xzbExpYlJvdXRpbmVzVG9CZUluY2x1ZGVkKGUpO2lmKDA9PT10Lmxlbmd0aClyZXR1cm5cIlwiO2xldCBuPVwiXCI7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDsrK2Upe2lmKCF0W2VdLnJvdXRpbmVCb2R5KXRocm93IG5ldyBFcnJvcihgTWlzc2luZyBib2R5IGZvciB0aGUgR2xzbCBMaWJyYXJ5IHJvdXRpbmU6ICR7dFtlXS5uYW1lfWApO24rPXRbZV0ucm91dGluZUJvZHkrXCJcXG5cIn1yZXR1cm4gbn1zZWxlY3RHbHNsTGliUm91dGluZXNUb0JlSW5jbHVkZWQoZSl7Y29uc3QgdD1bXTtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5nbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaCkuZm9yRWFjaCgobj0+e2NvbnN0IHI9bi5zcGxpdChcIi5cIilbMV07LTEhPT1lLmluZGV4T2YocikmJnQucHVzaCh0aGlzLmdsc2xMaWJSb3V0aW5lRGVwZW5kZW5jeUdyYXBoW25dKX0pKSxyLlRvcG9sb2dpY2FsU29ydEdsc2xSb3V0aW5lcy5yZXR1cm5PcmRlcmVkTm9kZXModCl9Z2V0VW5pZm9ybXMoZSx0KXtjb25zdCBuPVtdO2lmKGUpZm9yKGNvbnN0IHQgb2YgZSluLnB1c2goYHVuaWZvcm0gc2FtcGxlcjJEICR7dH07YCk7aWYodClmb3IoY29uc3QgZSBvZiB0KW4ucHVzaChgdW5pZm9ybSAke2UudHlwZX0gJHtlLm5hbWV9JHtlLmFycmF5TGVuZ3RoP2BbJHtlLmFycmF5TGVuZ3RofV1gOlwiXCJ9O2ApO3JldHVybiBuLmpvaW4oXCJcXG5cIil9fX0sMTI0ODooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nbHNsUmVnaXN0cnk9dm9pZCAwO2NvbnN0IHI9big2ODU5KSxvPW4oMTM3MSksaT1uKDI2OTEpLGE9big5MTgzKSxzPW4oOTMxNCk7dC5nbHNsUmVnaXN0cnk9e2VuY29kaW5nOm8uRW5jb2RpbmdHbHNsTGliLGZyYWdjb2xvcjppLkZyYWdDb2xvckdsc2xMaWIsdmVjOnMuVmVjR2xzbExpYixzaGFwZVV0aWxzOmEuU2hhcGVVdGlsc0dsc2xMaWIsY29vcmRpbmF0ZXM6ci5Db29yZHNHbHNsTGlifX0sOTE4MzooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5TaGFwZVV0aWxzR2xzbExpYj12b2lkIDA7Y29uc3Qgcj1uKDE5OTcpO2NsYXNzIG8gZXh0ZW5kcyByLkdsc2xMaWJ7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSl9Z2V0RnVuY3Rpb25zKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLmJjYXN0SW5kZXgoKSksdGhpcy5iY2FzdE1hdG11bEluZGV4KCkpLHRoaXMub2Zmc2V0VG9JbmRpY2VzKCkpLHRoaXMuaW5kaWNlc1RvT2Zmc2V0KCkpLHRoaXMuaW5jcmVtZW50SW5kaWNlcygpKX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fWJjYXN0SW5kZXgoKXtjb25zdCBlPXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aCx0PXt9O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgobixvKT0+e2NvbnN0IGk9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbb10udW5wYWNrZWRTaGFwZTtpZihpLmxlbmd0aDw9ZSl7Y29uc3Qgbz1pLmxlbmd0aCxhPWUtbyxzPWBiY2FzdEluZGljZXNfJHtufWA7bGV0IHU9XCJcIjtmb3IobGV0IGU9MDtlPG87KytlKXUrPWBcXG4gICAgICAgICAgcmVhbEluZGljZXNbJHtlfV0gPSBpbnQoIG1vZChmbG9hdChiY2FzdGVkSW5kaWNlc1ske2ErZX1dKSwgJHtpW2VdfS4wKSApO1xcbiAgICAgICAgICBgO2NvbnN0IGw9YFxcbiAgICAgICAgdm9pZCAke3N9IChpbnQgYmNhc3RlZEluZGljZXNbJHtlfV0sIG91dCBpbnQgcmVhbEluZGljZXNbJHtvfV0pIHtcXG4gICAgICAgICAgJHt1fVxcbiAgICAgICAgfVxcbiAgICAgICAgYDt0W3NdPW5ldyByLkdsc2xMaWJSb3V0aW5lKGwpfX0pKSx0fWJjYXN0TWF0bXVsSW5kZXgoKXtjb25zdCBlPXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aCx0PXt9O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgobixvKT0+e2NvbnN0IGk9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbb10uc2hhcGU7aWYoIShpLmxlbmd0aDwyfHxpLmxlbmd0aD5lKSl7Y29uc3Qgbz1pLmxlbmd0aCxhPWUtbyxzPWBiY2FzdE1hdG11bEluZGljZXNfJHtufWA7bGV0IHU9XCJcIjtmb3IobGV0IGU9MDtlPG8tMjsrK2UpdSs9YFxcbiAgICAgICAgICByZWFsSW5kaWNlc1ske2V9XSA9IGludCggbW9kKGZsb2F0KGJjYXN0ZWRJbmRpY2VzWyR7YStlfV0pLCAke2lbZV19LjApICk7XFxuICAgICAgICAgIGA7Y29uc3QgbD1gXFxuICAgICAgICB2b2lkICR7c30oaW50IGJjYXN0ZWRJbmRpY2VzWyR7ZX1dLCBvdXQgaW50IHJlYWxJbmRpY2VzWyR7b31dKSB7XFxuICAgICAgICAgICR7dX1cXG4gICAgICAgICAgcmVhbEluZGljZXNbJHtvLTF9XSA9IGJjYXN0ZWRJbmRpY2VzWyR7ZS0xfV07XFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7by0yfV0gPSBiY2FzdGVkSW5kaWNlc1ske2UtMn1dO1xcbiAgICAgICAgfVxcbiAgICAgICAgYDt0W3NdPW5ldyByLkdsc2xMaWJSb3V0aW5lKGwpfX0pKSx0fWluZGljZXNUb09mZnNldCgpe2NvbnN0IGU9e307cmV0dXJuIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKCh0LG4pPT57Y29uc3QgaT10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tuXS5zaGFwZSxhPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW25dLnN0cmlkZXMscz1pLmxlbmd0aDtsZXQgdT1gaW5kaWNlc1RvT2Zmc2V0XyR7dH1gO2VbdV09bmV3IHIuR2xzbExpYlJvdXRpbmUoby5pbmRleFRvT2Zmc2V0U2luZ2xlKHUscyxhKSksdT1gaW5kaWNlc1RvT2Zmc2V0XyR7dH1fVGAsZVt1XT1uZXcgci5HbHNsTGliUm91dGluZShvLmluZGV4VG9PZmZzZXRTaW5nbGUodSxzLGEuc2xpY2UoKS5yZXZlcnNlKCkpKX0pKSxlfXN0YXRpYyBpbmRleFRvT2Zmc2V0U2luZ2xlKGUsdCxuKXtsZXQgcj1cIlwiO2ZvcihsZXQgZT10LTE7ZT49MDstLWUpcis9YFxcbiAgICAgICAgb2Zmc2V0ICs9IGluZGljZXNbJHtlfV0gKiAke25bZV19O1xcbiAgICAgICAgYDtyZXR1cm5gXFxuICAgICAgaW50ICR7ZX0oaW50IGluZGljZXNbJHt0fV0pIHtcXG4gICAgICAgIGludCBvZmZzZXQgPSAwO1xcbiAgICAgICAgJHtyfVxcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcXG4gICAgICB9XFxuICAgICAgYH1vZmZzZXRUb0luZGljZXMoKXtjb25zdCBlPXt9O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgodCxuKT0+e2NvbnN0IGk9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc2hhcGUsYT10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tuXS5zdHJpZGVzLHM9aS5sZW5ndGg7bGV0IHU9YG9mZnNldFRvSW5kaWNlc18ke3R9YDtlW3VdPW5ldyByLkdsc2xMaWJSb3V0aW5lKG8ub2Zmc2V0VG9JbmRpY2VzU2luZ2xlKHUscyxhKSksdT1gb2Zmc2V0VG9JbmRpY2VzXyR7dH1fVGAsZVt1XT1uZXcgci5HbHNsTGliUm91dGluZShvLm9mZnNldFRvSW5kaWNlc1NpbmdsZSh1LHMsYS5zbGljZSgpLnJldmVyc2UoKSkpfSkpLGV9c3RhdGljIG9mZnNldFRvSW5kaWNlc1NpbmdsZShlLHQsbil7Y29uc3Qgcj1bXTtmb3IobGV0IGU9MDtlPHQtMTsrK2Upci5wdXNoKGBcXG4gICAgICBpbmRpY2VzWyR7ZX1dID0gb2Zmc2V0IC8gJHtuW2VdfTtgKSxyLnB1c2goYFxcbiAgICAgICAgb2Zmc2V0IC09IGluZGljZXNbJHtlfV0gKiAke25bZV19O2ApO3JldHVybiByLnB1c2goYFxcbiAgICAgIGluZGljZXNbJHt0LTF9XSA9IG9mZnNldDtgKSxgXFxuICAgICAgdm9pZCAke2V9KGludCBvZmZzZXQsIG91dCBpbnQgaW5kaWNlc1ske3R9XSkge1xcbiAgICAgICAgJHtyLmpvaW4oXCJcIil9XFxuICAgICAgfVxcbiAgICAgIGB9aW5jcmVtZW50SW5kaWNlcygpe2NvbnN0IGU9e307cmV0dXJuIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKCh0LG4pPT57Y29uc3Qgbz10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tuXS5zaGFwZSxpPW8ubGVuZ3RoLGE9YGluY3JlbWVudEluZGljZXNfJHt0fWA7bGV0IHM9XCJcIjtmb3IobGV0IGU9MDtlPGk7KytlKXMrPWBcXG4gICAgICAgIHNoYXBlWyR7ZX1dID0gJHtvW2VdfTtgO2NvbnN0IHU9YFxcbiAgICAgICAgdm9pZCAke2F9KGludCBheGlzLCBvdXQgaW50IGluZGljZXNbJHtpfV0pIHtcXG4gICAgICAgICAgaW50IHNoYXBlWyR7aX1dO1xcbiAgICAgICAgICAke3N9O1xcbiAgICAgICAgICBmb3IoaW50IGkgPSAke2l9IC0xIDsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgICAgICBpZihpID4gYXhpcykgY29udGludWU7XFxuICAgICAgICAgICAgaW5kaWNlc1tpXSArPSAxO1xcbiAgICAgICAgICAgIGlmKGluZGljZXNbaV0gPCBzaGFwZVtpXSkge1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGluZGljZXNbaV0gPSAwO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBgO2VbYV09bmV3IHIuR2xzbExpYlJvdXRpbmUodSl9KSksZX19dC5TaGFwZVV0aWxzR2xzbExpYj1vfSw2NzU3OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXREZWZhdWx0RnJhZ1NoYWRlck1haW49dC5nZXRGcmFnU2hhZGVyUHJlYW1ibGU9dC5nZXRWZXJ0ZXhTaGFkZXJTb3VyY2U9dC5nZXRHbHNsPXZvaWQgMDtjb25zdCBuPXt2ZXJzaW9uOlwiXCIsYXR0cmlidXRlOlwiYXR0cmlidXRlXCIsdmFyeWluZ1ZlcnRleDpcInZhcnlpbmdcIix2YXJ5aW5nRnJhZzpcInZhcnlpbmdcIix0ZXh0dXJlMkQ6XCJ0ZXh0dXJlMkRcIixvdXRwdXQ6XCJnbF9GcmFnQ29sb3JcIixvdXRwdXREZWNsYXJhdGlvbjpcIlwifSxyPXt2ZXJzaW9uOlwiI3ZlcnNpb24gMzAwIGVzXCIsYXR0cmlidXRlOlwiaW5cIix2YXJ5aW5nVmVydGV4Olwib3V0XCIsdmFyeWluZ0ZyYWc6XCJpblwiLHRleHR1cmUyRDpcInRleHR1cmVcIixvdXRwdXQ6XCJvdXRwdXRDb2xvclwiLG91dHB1dERlY2xhcmF0aW9uOlwib3V0IHZlYzQgb3V0cHV0Q29sb3I7XCJ9O2Z1bmN0aW9uIG8oZSl7cmV0dXJuIDE9PT1lP246cn10LmdldEdsc2w9byx0LmdldFZlcnRleFNoYWRlclNvdXJjZT1mdW5jdGlvbihlKXtjb25zdCB0PW8oZSk7cmV0dXJuYCR7dC52ZXJzaW9ufVxcbiAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gICAgICAke3QuYXR0cmlidXRlfSB2ZWMzIHBvc2l0aW9uO1xcbiAgICAgICR7dC5hdHRyaWJ1dGV9IHZlYzIgdGV4dHVyZUNvb3JkO1xcblxcbiAgICAgICR7dC52YXJ5aW5nVmVydGV4fSB2ZWMyIFRleENvb3JkcztcXG5cXG4gICAgICB2b2lkIG1haW4oKVxcbiAgICAgIHtcXG4gICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcbiAgICAgICAgICBUZXhDb29yZHMgPSB0ZXh0dXJlQ29vcmQ7XFxuICAgICAgfWB9LHQuZ2V0RnJhZ1NoYWRlclByZWFtYmxlPWZ1bmN0aW9uKGUpe2NvbnN0IHQ9byhlKTtyZXR1cm5gJHt0LnZlcnNpb259XFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGludDtcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcXG4gICAgJHt0LnZhcnlpbmdGcmFnfSB2ZWMyIFRleENvb3JkcztcXG4gICAgJHt0Lm91dHB1dERlY2xhcmF0aW9ufVxcbiAgICBjb25zdCB2ZWMyIGhhbGZDUiA9IHZlYzIoMC41LCAwLjUpO1xcblxcbiAgICAvLyBDdXN0b20gdmVjdG9yIHR5cGVzIHRvIGhhbmRsZSBoaWdoZXIgZGltZW5hbGl0aWVzLlxcbiAgICBzdHJ1Y3QgaXZlYzVcXG4gICAge1xcbiAgICAgIGludCB4O1xcbiAgICAgIGludCB5O1xcbiAgICAgIGludCB6O1xcbiAgICAgIGludCB3O1xcbiAgICAgIGludCB1O1xcbiAgICB9O1xcblxcbiAgICBzdHJ1Y3QgaXZlYzZcXG4gICAge1xcbiAgICAgIGludCB4O1xcbiAgICAgIGludCB5O1xcbiAgICAgIGludCB6O1xcbiAgICAgIGludCB3O1xcbiAgICAgIGludCB1O1xcbiAgICAgIGludCB2O1xcbiAgICB9O1xcblxcbiAgICBpbnQgaW1vZChpbnQgeCwgaW50IHkpIHtcXG4gICAgICByZXR1cm4geCAtIHkgKiAoeCAvIHkpO1xcbiAgICB9XFxuXFxuICAgIGB9LHQuZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluPWZ1bmN0aW9uKGUsdCl7cmV0dXJuYFxcbiAgdm9pZCBtYWluKCkge1xcbiAgICBpbnQgaW5kaWNlc1ske3R9XTtcXG4gICAgdG9WZWMoVGV4Q29vcmRzLCBpbmRpY2VzKTtcXG4gICAgdmVjNCByZXN1bHQgPSB2ZWM0KHByb2Nlc3MoaW5kaWNlcykpO1xcbiAgICAke28oZSkub3V0cHV0fSA9IHJlc3VsdDtcXG4gIH1cXG4gIGB9fSw5MzE0OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlZlY0dsc2xMaWI9dm9pZCAwO2NvbnN0IHI9bigxOTk3KTtjbGFzcyBvIGV4dGVuZHMgci5HbHNsTGlie2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpfWdldEN1c3RvbVR5cGVzKCl7cmV0dXJue319Z2V0RnVuY3Rpb25zKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdGhpcy5iaW5hcnlWZWNGdW5jdGlvbnMoKSksdGhpcy5jb3B5VmVjKCkpLHRoaXMuc2V0VmVjSXRlbSgpKSx0aGlzLmdldFZlY0l0ZW0oKSl9YmluYXJ5VmVjRnVuY3Rpb25zKCl7Y29uc3QgZT10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGgsdD17YWRkOlwiKz1cIixzdWI6XCItPVwiLG11bDpcIio9XCIsZGl2OlwiLz1cIn0sbj17fTtmb3IoY29uc3QgbyBpbiB0KXtjb25zdCBpPWAke299VmVjYDtsZXQgYT1cIlwiO2ZvcihsZXQgbj0wO248ZTsrK24pYSs9YFxcbiAgICAgICAgICBkZXN0WyR7bn1dICR7dFtvXX0gc3JjWyR7bn1dO1xcbiAgICAgICAgICBgO2NvbnN0IHM9YFxcbiAgICAgICAgdm9pZCAke2l9KGludCBzcmNbJHtlfV0sIG91dCBpbnQgZGVzdFske2V9XSkge1xcbiAgICAgICAgICAke2F9XFxuICAgICAgICB9XFxuICAgICAgICBgO25baV09bmV3IHIuR2xzbExpYlJvdXRpbmUocyl9cmV0dXJuIG59Y29weVZlYygpe2NvbnN0IGU9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoO2xldCB0PVwiXCI7Zm9yKGxldCBuPTA7bjxlOysrbil0Kz1gXFxuICAgICAgICBkZXN0WyR7bn1dID0gc3JjWyR7bn1dO1xcbiAgICAgICAgYDtjb25zdCBuPWBcXG4gICAgICB2b2lkIGNvcHlWZWMoaW50IHNyY1ske2V9XSwgb3V0IGludCBkZXN0WyR7ZX1dKSB7XFxuICAgICAgICAke3R9XFxuICAgICAgfVxcbiAgICAgIGA7cmV0dXJue2NvcHlWZWM6bmV3IHIuR2xzbExpYlJvdXRpbmUobil9fXNldFZlY0l0ZW0oKXtjb25zdCBlPXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aDtsZXQgdD1gXFxuICAgICAgICBpZihpbmRleCA8IDApXFxuICAgICAgICAgICAgaW5kZXggPSR7ZX0gKyBpbmRleDtcXG4gICAgICAgIGlmIChpbmRleCA9PSAwKVxcbiAgICAgICAgICAgIG1bMF0gPSB2YWx1ZTtcXG4gICAgICAgIGA7Zm9yKGxldCBuPTE7bjxlLTE7KytuKXQrPWBcXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09ICR7bn0pXFxuICAgICAgICAgICAgbVske259XSA9IHZhbHVlO1xcbiAgICAgICAgICAgIGA7dCs9YFxcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICAgIG1bJHtlLTF9XSA9IHZhbHVlO1xcbiAgICAgICAgYDtjb25zdCBuPWBcXG4gICAgICB2b2lkIHNldFZlY0l0ZW0ob3V0IGludCBtWyR7ZX1dLCBpbnQgaW5kZXgsIGludCB2YWx1ZSkge1xcbiAgICAgICAgJHt0fVxcbiAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJue3NldFZlY0l0ZW06bmV3IHIuR2xzbExpYlJvdXRpbmUobil9fWdldFZlY0l0ZW0oKXtjb25zdCBlPXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aDtsZXQgdD1gXFxuICAgICAgICBpZihpbmRleCA8IDApXFxuICAgICAgICAgICAgaW5kZXggPSAke2V9ICsgaW5kZXg7XFxuICAgICAgICBpZiAoaW5kZXggPT0gMClcXG4gICAgICAgICAgICByZXR1cm4gbVswXTtcXG4gICAgICBgO2ZvcihsZXQgbj0xO248ZS0xOysrbil0Kz1gXFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAke259KVxcbiAgICAgICAgICAgIHJldHVybiBtWyR7bn1dO1xcbiAgICAgIGA7dCs9YFxcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICAgIHJldHVybiBtWyR7ZS0xfV07XFxuICAgICAgICBgO2NvbnN0IG49YFxcbiAgICAgIGludCBnZXRWZWNJdGVtKGludCBtWyR7ZX1dLCBpbnQgaW5kZXgpIHtcXG4gICAgICAgICR7dH1cXG4gICAgICB9XFxuICAgIGA7cmV0dXJue2dldFZlY0l0ZW06bmV3IHIuR2xzbExpYlJvdXRpbmUobil9fX10LlZlY0dsc2xMaWI9b30sNzg2MDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5XZWJHTEluZmVyZW5jZUhhbmRsZXI9dm9pZCAwO2NvbnN0IHI9bigxMzE1KSxvPW4oOTI0MCksaT1uKDcyNzMpLGE9big5KSxzPW4oNzM3OSksdT1uKDI0ODgpLGw9big1NDApLGM9bigzMzE0KSxwPW4oNTYzOSk7dC5XZWJHTEluZmVyZW5jZUhhbmRsZXI9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5zZXNzaW9uPWUsdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXAsdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcH1jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoZSx0KXtyZXR1cm4oMCxjLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCkodGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LGUsdCl9ZXhlY3V0ZVByb2dyYW0oZSx0KXtpZih0Lmxlbmd0aDxlLmlucHV0TmFtZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgSW5wdXQgc2l6ZSBtdXN0bid0IGJlIGxlc3MgdGhhbiAke2UuaW5wdXROYW1lcy5sZW5ndGh9LmApO2lmKGUuaW5wdXROYW1lcy5sZW5ndGghPT1lLmlucHV0VHlwZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImlucHV0IG5hbWVzIHNpemUgZG9lcyBub3QgbWF0Y2ggaW5wdXQgdHlwZXNcIik7Y29uc3Qgbj1bXTtmb3IobGV0IHI9MDtyPGUuaW5wdXROYW1lcy5sZW5ndGg7KytyKW5bcl09dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHRbcl0sZS5pbnB1dFR5cGVzW3JdKTtjb25zdCByPSgoZSx0KT0+e2NvbnN0IG49dC5tYXAoKGU9PmAke2UudW5wYWNrZWRTaGFwZS5qb2luKFwiLFwiKX07JHtlLndpZHRofXgke2UuaGVpZ2h0fWApKS5qb2luKFwiX1wiKTtsZXQgcj1lLm5hbWU7cmV0dXJuIGUuY2FjaGVIaW50JiYocis9XCJbXCIrZS5jYWNoZUhpbnQrXCJdXCIpLHIrPVwiOlwiK24scn0pKGUsbik7bGV0IG89dGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLmdldEFydGlmYWN0KHIpO2NvbnN0IGk9bz9vLnByb2dyYW1JbmZvOlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZ2V0P2UuZ2V0KCk6ZSxhPSgwLGMuY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZSkodGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LGkub3V0cHV0LmRpbXMsaS5vdXRwdXQudGV4dHVyZVR5cGUpLHM9dGhpcy5jcmVhdGVUZXh0dXJlRGF0YShhLGkub3V0cHV0LnR5cGUpO3JldHVybiBvfHwobz10aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuYnVpbGQoaSxuLHMpLHRoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5zZXRBcnRpZmFjdChyLG8pKSx0aGlzLnJ1blByb2dyYW0obyxuLHMpLHN9cnVuKGUsdCl7cmV0dXJuIHRoaXMuZXhlY3V0ZVByb2dyYW0oZSx0KS50ZW5zb3J9cnVuUHJvZ3JhbShlLHQsbil7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDsrK24paWYoISF0W25dLmlzUGFja2VkIT0oZS5wcm9ncmFtSW5mby5pbnB1dFR5cGVzW25dPT09cC5UZXh0dXJlVHlwZS5wYWNrZWQpKXRocm93IG5ldyBFcnJvcihgaW5wdXRbJHtufV0gcHJvcGVydHkgcGFja2VkIGluY29uc2lzdGVudGApO2lmKCEhbi5pc1BhY2tlZCE9KGUucHJvZ3JhbUluZm8ub3V0cHV0LnRleHR1cmVUeXBlPT09cC5UZXh0dXJlVHlwZS5wYWNrZWQpKXRocm93IG5ldyBFcnJvcihcIm91dHB1dCBwcm9wZXJ0eSBwYWNrZWQgaW5jb25zaXN0ZW50XCIpO3RoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5ydW4oZSx0LG4pfWdldE9yQ3JlYXRlVGV4dHVyZURhdGEoZSx0KXtsZXQgbj10aGlzLmdldFRleHR1cmVEYXRhKGUuZGF0YUlkLHQ9PT1wLlRleHR1cmVUeXBlLnBhY2tlZCk7aWYoIW4mJihuPXRoaXMuZ2V0VGV4dHVyZURhdGEoZS5kYXRhSWQsdCE9PXAuVGV4dHVyZVR5cGUucGFja2VkKSxuKSlyZXR1cm4gdD09PXAuVGV4dHVyZVR5cGUucGFja2VkP3RoaXMucGFjayhuKTp0aGlzLnVucGFjayhuKTtpZighbil7Y29uc3Qgcj0oMCxjLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tVGV4dHVyZVR5cGUpKHRoaXMuc2Vzc2lvbi5sYXlvdXRTdHJhdGVneSxlLmRpbXMsdCk7aWYodD09PXAuVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbil7Y29uc3Qgbj0xLHI9NCxvPWUuZGltcztpZig0PT09by5sZW5ndGgpe2NvbnN0IGk9W29bMF0sTWF0aC5jZWlsKG9bMV0qb1syXSpvWzNdL3IpXSxhPSgwLGMuY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZSkodGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LGksdCk7bGV0IHM9ZS5udW1iZXJEYXRhO2lmKG9bMV0qb1syXSpvWzNdJXIhPTApe2NvbnN0IHQ9b1swXSxpPW9bMV0qb1syXSpvWzNdLGE9TWF0aC5jZWlsKGkqbi9yKSpyO3M9bmV3IEZsb2F0MzJBcnJheSh0KmEpO2ZvcihsZXQgcj0wO3I8dDsrK3Ipe2NvbnN0IHQ9cippLG89ciphK3IlbippO3Muc2V0KGUubnVtYmVyRGF0YS5zdWJhcnJheSh0LHQraSksbyl9fXJldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhKGEsZS50eXBlLHMsZSwxKX19aWYodD09PXAuVGV4dHVyZVR5cGUucGFja2VkKXtjb25zdCB0PSgwLGMuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZSkodGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LGUuZGltcywxLFtdLHtyZXZlcnNlV0g6ITB9KSxyPXRoaXMuY3JlYXRlVGV4dHVyZURhdGEodCxlLnR5cGUsZS5udW1iZXJEYXRhLGUsMSk7bj10aGlzLnBhY2socil9ZWxzZSBuPXRoaXMuY3JlYXRlVGV4dHVyZURhdGEocixlLnR5cGUsZS5udW1iZXJEYXRhLGUsMSl9cmV0dXJuIG59Y3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0QmluZFRlbnNvcihlLHQsbixyKXtyZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YShlLHQsbixyLDEpfWNyZWF0ZVRleHR1cmVEYXRhKGUsdCxuLG8saSl7ci5Mb2dnZXIudmVyYm9zZShcIkluZmVyZW5jZUhhbmRsZXJcIixgQ3JlYXRpbmcgVGV4dHVyZURhdGE6IGxheW91dDpbJHtKU09OLnN0cmluZ2lmeShlKX1dYCk7Y29uc3QgYT10aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIuY3JlYXRlVGV4dHVyZUZyb21MYXlvdXQodCxlLG4saSk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZShlLHQsYSxvKX1yZXNoYXBlVW5wYWNrZWQoZSx0KXtjb25zdCBuPXRoaXMuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShlLHAuVGV4dHVyZVR5cGUudW5wYWNrZWQpLHI9e2NoYW5uZWxzOm4uY2hhbm5lbHMsaGVpZ2h0Om4uaGVpZ2h0LHdpZHRoOm4ud2lkdGgsc2hhcGU6MCE9PXQubGVuZ3RoP3Q6WzFdLHN0cmlkZXM6aS5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXModCksdW5wYWNrZWRTaGFwZTp0fTtyZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKHIsZS50eXBlLG4udGV4dHVyZSkudGVuc29yfXJlc2hhcGVQYWNrZWQoZSx0KXtjb25zdCBuPXRoaXMuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShlLHAuVGV4dHVyZVR5cGUucGFja2VkKTtpZigoMCxzLmlzUmVzaGFwZUNoZWFwKShlLmRpbXMsdCkpe2NvbnN0IHI9e2NoYW5uZWxzOm4uY2hhbm5lbHMsaGVpZ2h0Om4uaGVpZ2h0LHdpZHRoOm4ud2lkdGgsc2hhcGU6MCE9PXQubGVuZ3RoP3Q6WzFdLHN0cmlkZXM6aS5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXModCksdW5wYWNrZWRTaGFwZTp0LGlzUGFja2VkOiEwfTtyZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKHIsZS50eXBlLG4udGV4dHVyZSkudGVuc29yfWNvbnN0IHI9KDAscy5wcm9jZXNzRGltczNEKShlLmRpbXMpLG89KDAscy5wcm9jZXNzRGltczNEKSh0KSxhPXRoaXMucmVzaGFwZVBhY2tlZChlLHIpLHU9dGhpcy5ydW4oKDAscy5jcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtSW5mb0xvYWRlcikodGhpcyxhLG8pLFthXSk7cmV0dXJuIHRoaXMucmVzaGFwZVBhY2tlZCh1LHQpfWNhc3QoZSx0KXtjb25zdCBuPXRoaXMuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShlLHAuVGV4dHVyZVR5cGUudW5wYWNrZWQpO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUobix0LG4udGV4dHVyZSkudGVuc29yfWNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUoZSx0LG4scixpKXtjb25zdCBhPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7dGVuc29yOnJ8fG5ldyBvLlRlbnNvcihlLnVucGFja2VkU2hhcGUsdCwoZT0+dGhpcy5yZWFkVGV4dHVyZShhKSksKGFzeW5jIGU9PnRoaXMucmVhZFRleHR1cmVBc3luYyhhKSksdm9pZCAwLGkpLHRleHR1cmU6bn0pO3JldHVybiB0aGlzLnNldFRleHR1cmVEYXRhKGEudGVuc29yLmRhdGFJZCxhLGUuaXNQYWNrZWQpLGF9Z2V0VGV4dHVyZURhdGEoZSx0PSExKXtyZXR1cm4gdGhpcy5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoZSk/dGhpcy5zZXNzaW9uLmdldFRleHR1cmVEYXRhKGUsdCk6dD90aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KGUpOnRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldChlKX1zZXRUZXh0dXJlRGF0YShlLHQsbj0hMSl7dGhpcy5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoZSk/dGhpcy5zZXNzaW9uLnNldFRleHR1cmVEYXRhKGUsdCxuKToobj90aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU6dGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUpLnNldChlLHQpfWlzVGV4dHVyZUxheW91dENhY2hlZChlLHQ9ITEpe3JldHVybiEhdGhpcy5nZXRUZXh0dXJlRGF0YShlLmRhdGFJZCx0KX1kaXNwb3NlKCl7dGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLmNsZWFyQWN0aXZlVGV4dHVyZXMoKSx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCgoZT0+dGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKGUpKSksdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXAsdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCgoZT0+dGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKGUpKSksdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcH1yZWFkVGV4dHVyZShlKXtyZXR1cm4gZS5pc1BhY2tlZD90aGlzLnJlYWRUZXh0dXJlKHRoaXMudW5wYWNrKGUpKTp0aGlzLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQuaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQ/dGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlYWRUZXh0dXJlKGUsZS50ZW5zb3IudHlwZSxlLmNoYW5uZWxzKTp0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVhZFVpbnQ4VGV4dHVyZUFzRmxvYXQoKDAsdS5lbmNvZGVBc1VpbnQ4KSh0aGlzLGUpKX1hc3luYyByZWFkVGV4dHVyZUFzeW5jKGUpe3JldHVybiBlLmlzUGFja2VkP3RoaXMucmVhZFRleHR1cmVBc3luYyh0aGlzLnVucGFjayhlKSk6dGhpcy5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LmlzRmxvYXQzMkRvd25sb2FkU3VwcG9ydGVkP3RoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVGV4dHVyZUFzeW5jKGUsZS50ZW5zb3IudHlwZSxlLmNoYW5uZWxzKTp0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVhZFVpbnQ4VGV4dHVyZUFzRmxvYXQoKDAsdS5lbmNvZGVBc1VpbnQ4KSh0aGlzLGUpKX1wYWNrKGUpe3JldHVybiB0aGlzLmV4ZWN1dGVQcm9ncmFtKCgwLGEuY3JlYXRlUGFja1Byb2dyYW1JbmZvTG9hZGVyKSh0aGlzLGUudGVuc29yKSxbZS50ZW5zb3JdKX11bnBhY2soZSl7cmV0dXJuIHRoaXMuZXhlY3V0ZVByb2dyYW0oKDAsbC5jcmVhdGVVbnBhY2tQcm9ncmFtSW5mb0xvYWRlcikodGhpcyxlLnRlbnNvciksW2UudGVuc29yXSl9fX0sNDExMDpmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCxuLHIpe3ZvaWQgMD09PXImJihyPW4pO3ZhciBvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxuKTtvJiYhKFwiZ2V0XCJpbiBvPyF0Ll9fZXNNb2R1bGU6by53cml0YWJsZXx8by5jb25maWd1cmFibGUpfHwobz17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtuXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLG8pfTpmdW5jdGlvbihlLHQsbixyKXt2b2lkIDA9PT1yJiYocj1uKSxlW3JdPXRbbl19KSxvPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOnR9KX06ZnVuY3Rpb24oZSx0KXtlLmRlZmF1bHQ9dH0pLGk9dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgbiBpbiBlKVwiZGVmYXVsdFwiIT09biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbikmJnIodCxlLG4pO3JldHVybiBvKHQsZSksdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5XRUJHTF9PUF9SRVNPTFZFX1JVTEVTPXZvaWQgMDtjb25zdCBhPW4oODgxNykscz1pKG4oNTE5NCkpLHU9big0NzUyKSxsPW4oNjY2OCksYz1uKDk3NTQpLHA9big1MDQyKSxkPW4oNjc0MiksZj1uKDQxMjUpLGg9big2MTQ5KSxnPW4oNTM3OCksbT1uKDY5ODEpLGI9big3NDEzKSx5PW4oNzAwNiksdz1uKDgyNzYpLF89big1NTY1KSx2PW4oMjgzNCkseD1uKDEwMTApLFQ9big4MTI2KSxTPW4oMjgwMSksTz1uKDU2NSksQT1uKDI0NDQpLEU9big4MTUpLEk9big1NjQpLCQ9big1NDE2KSxQPW4oMTI0MCksRD1uKDU5NDQpLGs9big1NzA3KSxDPWkobig5MDg3KSksUj1uKDc4NjIpLE09bigzOTgwKTt0LldFQkdMX09QX1JFU09MVkVfUlVMRVM9W1tcIkFic1wiLFwiXCIsXCI2K1wiLEMuYWJzXSxbXCJBY29zXCIsXCJcIixcIjcrXCIsQy5hY29zXSxbXCJBZGRcIixcIlwiLFwiNytcIixzLmFkZF0sW1wiQW5kXCIsXCJcIixcIjcrXCIscy5hbmRdLFtcIkFzaW5cIixcIlwiLFwiNytcIixDLmFzaW5dLFtcIkF0YW5cIixcIlwiLFwiNytcIixDLmF0YW5dLFtcIkF2ZXJhZ2VQb29sXCIsXCJcIixcIjcrXCIsdi5hdmVyYWdlUG9vbCx2LnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXSxbXCJCYXRjaE5vcm1hbGl6YXRpb25cIixcIlwiLFwiNytcIixhLmJhdGNoTm9ybWFsaXphdGlvbixhLnBhcnNlQmF0Y2hOb3JtYWxpemF0aW9uQXR0cmlidXRlc10sW1wiQ2FzdFwiLFwiXCIsXCI2K1wiLHUuY2FzdCx1LnBhcnNlQ2FzdEF0dHJpYnV0ZXNdLFtcIkNlaWxcIixcIlwiLFwiNitcIixDLmNlaWxdLFtcIkNsaXBcIixcIlwiLFwiNi0xMFwiLEMuY2xpcCxDLnBhcnNlQ2xpcEF0dHJpYnV0ZXNdLFtcIkNsaXBcIixcIlwiLFwiMTErXCIsQy5jbGlwVjExXSxbXCJDb25jYXRcIixcIlwiLFwiNCtcIixsLmNvbmNhdCxsLnBhcnNlQ29uY2F0QXR0cmlidXRlc10sW1wiQ29udlwiLFwiXCIsXCIxK1wiLGMuY29udixjLnBhcnNlQ29udkF0dHJpYnV0ZXNdLFtcIkNvbnZUcmFuc3Bvc2VcIixcIlwiLFwiMStcIixwLmNvbnZUcmFuc3Bvc2UscC5wYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzXSxbXCJDb3NcIixcIlwiLFwiNytcIixDLmNvc10sW1wiRGl2XCIsXCJcIixcIjcrXCIscy5kaXZdLFtcIkRyb3BvdXRcIixcIlwiLFwiNytcIixDLmlkZW50aXR5XSxbXCJEZXB0aFRvU3BhY2VcIixcIlwiLFwiMStcIixkLmRlcHRoVG9TcGFjZSxkLnBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlc10sW1wiRXF1YWxcIixcIlwiLFwiNytcIixzLmVxdWFsXSxbXCJFbHVcIixcIlwiLFwiNitcIixDLmVsdSxDLnBhcnNlRWx1QXR0cmlidXRlc10sW1wiRXhwXCIsXCJcIixcIjYrXCIsQy5leHBdLFtcIkZsYXR0ZW5cIixcIlwiLFwiMStcIixmLmZsYXR0ZW4sZi5wYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzXSxbXCJGbG9vclwiLFwiXCIsXCI2K1wiLEMuZmxvb3JdLFtcIkZ1c2VkQ29udlwiLFwiY29tLm1pY3Jvc29mdFwiLFwiMStcIixjLmNvbnYsYy5wYXJzZUNvbnZBdHRyaWJ1dGVzXSxbXCJHYXRoZXJcIixcIlwiLFwiMStcIixoLmdhdGhlcixoLnBhcnNlR2F0aGVyQXR0cmlidXRlc10sW1wiR2VtbVwiLFwiXCIsXCI3LTEwXCIsZy5nZW1tLGcucGFyc2VHZW1tQXR0cmlidXRlc1Y3XSxbXCJHZW1tXCIsXCJcIixcIjExK1wiLGcuZ2VtbSxnLnBhcnNlR2VtbUF0dHJpYnV0ZXNWMTFdLFtcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsXCJcIixcIjErXCIsdi5nbG9iYWxBdmVyYWdlUG9vbCx2LnBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXSxbXCJHbG9iYWxNYXhQb29sXCIsXCJcIixcIjErXCIsdi5nbG9iYWxNYXhQb29sXSxbXCJHcmVhdGVyXCIsXCJcIixcIjcrXCIscy5ncmVhdGVyXSxbXCJJZGVudGl0eVwiLFwiXCIsXCIxK1wiLEMuaWRlbnRpdHldLFtcIkltYWdlU2NhbGVyXCIsXCJcIixcIjErXCIsbS5pbWFnZVNjYWxlcixtLnBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzXSxbXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixcIlwiLFwiNitcIixiLmluc3RhbmNlTm9ybWFsaXphdGlvbixiLnBhcnNlSW5zdGFuY2VOb3JtYWxpemF0aW9uQXR0cmlidXRlc10sW1wiTGVha3lSZWx1XCIsXCJcIixcIjYrXCIsQy5sZWFreVJlbHUsQy5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXNdLFtcIkxlc3NcIixcIlwiLFwiNytcIixzLmxlc3NdLFtcIkxSTlwiLFwiXCIsXCIxK1wiLHkubHJuLHkucGFyc2VMcm5BdHRyaWJ1dGVzXSxbXCJMb2dcIixcIlwiLFwiNitcIixDLmxvZ10sW1wiTWF0TXVsXCIsXCJcIixcIjErXCIsdy5tYXRNdWwsdy5wYXJzZU1hdE11bEF0dHJpYnV0ZXNdLFtcIk1heFBvb2xcIixcIlwiLFwiMStcIix2Lm1heFBvb2wsdi5wYXJzZU1heFBvb2xBdHRyaWJ1dGVzXSxbXCJNdWxcIixcIlwiLFwiNytcIixzLm11bF0sW1wiTmVnXCIsXCJcIixcIjYrXCIsQy5uZWddLFtcIk5vdFwiLFwiXCIsXCIxK1wiLEMubm90XSxbXCJPclwiLFwiXCIsXCI3K1wiLHMub3JdLFtcIlBhZFwiLFwiXCIsXCIyLTEwXCIsXy5wYWRWMixfLnBhcnNlUGFkQXR0cmlidXRlc1YyXSxbXCJQYWRcIixcIlwiLFwiMTErXCIsXy5wYWRWMTEsXy5wYXJzZVBhZEF0dHJpYnV0ZXNWMTFdLFtcIlBvd1wiLFwiXCIsXCI3K1wiLHMucG93XSxbXCJQUmVsdVwiLFwiXCIsXCI3K1wiLHMucFJlbHVdLFtcIlJlZHVjZUxvZ1N1bVwiLFwiXCIsXCIxK1wiLHgucmVkdWNlTG9nU3VtLHgucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxbXCJSZWR1Y2VNYXhcIixcIlwiLFwiMStcIix4LnJlZHVjZU1heCx4LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlTWVhblwiLFwiXCIsXCIxK1wiLHgucmVkdWNlTWVhbix4LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlTWluXCIsXCJcIixcIjErXCIseC5yZWR1Y2VNaW4seC5wYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFtcIlJlZHVjZVByb2RcIixcIlwiLFwiMStcIix4LnJlZHVjZVByb2QseC5wYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFtcIlJlZHVjZVN1bVwiLFwiXCIsXCIxLTEyXCIseC5yZWR1Y2VTdW0seC5wYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFtcIlJlZHVjZVN1bVNxdWFyZVwiLFwiXCIsXCIxK1wiLHgucmVkdWNlTG9nU3VtU3F1YXJlLHgucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxbXCJSZWx1XCIsXCJcIixcIjYrXCIsQy5yZWx1XSxbXCJSZXNoYXBlXCIsXCJcIixcIjUrXCIsVC5yZXNoYXBlXSxbXCJSZXNpemVcIixcIlwiLFwiMTBcIixTLnJlc2l6ZSxTLnBhcnNlUmVzaXplQXR0cmlidXRlc1YxMF0sW1wiUmVzaXplXCIsXCJcIixcIjExK1wiLFMucmVzaXplLFMucGFyc2VSZXNpemVBdHRyaWJ1dGVzVjExXSxbXCJTaGFwZVwiLFwiXCIsXCIxK1wiLE8uc2hhcGVdLFtcIlNpZ21vaWRcIixcIlwiLFwiNitcIixDLnNpZ21vaWRdLFtcIlNpblwiLFwiXCIsXCI3K1wiLEMuc2luXSxbXCJTbGljZVwiLFwiXCIsXCIxMCtcIixBLnNsaWNlVjEwXSxbXCJTbGljZVwiLFwiXCIsXCIxLTlcIixBLnNsaWNlLEEucGFyc2VTbGljZUF0dHJpYnV0ZXNdLFtcIlNvZnRtYXhcIixcIlwiLFwiMS0xMlwiLEUuc29mdG1heCxFLnBhcnNlU29mdG1heEF0dHJpYnV0ZXNdLFtcIlNvZnRtYXhcIixcIlwiLFwiMTMrXCIsRS5zb2Z0bWF4VjEzLEUucGFyc2VTb2Z0bWF4QXR0cmlidXRlc1YxM10sW1wiU3BsaXRcIixcIlwiLFwiMi0xMlwiLEkuc3BsaXQsSS5wYXJzZVNwbGl0QXR0cmlidXRlc10sW1wiU3FydFwiLFwiXCIsXCI2K1wiLEMuc3FydF0sW1wiU3F1ZWV6ZVwiLFwiXCIsXCIxLTEyXCIsJC5zcXVlZXplLCQucGFyc2VTcXVlZXplQXR0cmlidXRlc10sW1wiU3F1ZWV6ZVwiLFwiXCIsXCIxMytcIiwkLnNxdWVlemVWMTNdLFtcIlN1YlwiLFwiXCIsXCI3K1wiLHMuc3ViXSxbXCJTdW1cIixcIlwiLFwiNitcIixQLnN1bV0sW1wiVGFuXCIsXCJcIixcIjcrXCIsQy50YW5dLFtcIlRhbmhcIixcIlwiLFwiNitcIixDLnRhbmhdLFtcIlRpbGVcIixcIlwiLFwiNitcIixELnRpbGVdLFtcIlRyYW5zcG9zZVwiLFwiXCIsXCIxK1wiLGsudHJhbnNwb3NlLGsucGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzXSxbXCJVcHNhbXBsZVwiLFwiXCIsXCI3LThcIixNLnVwc2FtcGxlLE0ucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWN10sW1wiVXBzYW1wbGVcIixcIlwiLFwiOVwiLE0udXBzYW1wbGUsTS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y5XSxbXCJVbnNxdWVlemVcIixcIlwiLFwiMS0xMlwiLFIudW5zcXVlZXplLFIucGFyc2VVbnNxdWVlemVBdHRyaWJ1dGVzXSxbXCJVbnNxdWVlemVcIixcIlwiLFwiMTMrXCIsUi51bnNxdWVlemVWMTNdLFtcIlhvclwiLFwiXCIsXCI3K1wiLHMueG9yXV19LDg4MTc6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzPXQuYmF0Y2hOb3JtYWxpemF0aW9uPXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDY3NTcpLGk9big1NjM5KSxhPXtuYW1lOlwiQmF0Y2hOb3JtYWxpemF0aW9uXCIsaW5wdXROYW1lczpbXCJBXCIsXCJTY2FsZVwiLFwiQlwiLFwiTWVhblwiLFwiVmFyaWFuY2VcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkXX07dC5iYXRjaE5vcm1hbGl6YXRpb249KGUsdCxuKT0+KHUodCksW2UucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT5zKGUsdCxuKX0pLHQpXSksdC5wYXJzZUJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiZXBzaWxvblwiLDFlLTUpLG49ZS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibW9tZW50dW1cIiwuOSksbz1lLmF0dHJpYnV0ZXMuZ2V0SW50KFwic3BhdGlhbFwiLDEpO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7ZXBzaWxvbjp0LG1vbWVudHVtOm4sc3BhdGlhbDpvfSl9O2NvbnN0IHM9KGUsdCxuKT0+e2NvbnN0IHI9KDAsby5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbikscz10WzBdLmRpbXMubGVuZ3RoLFt1LGxdPWUuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KHRbMV0uZGltcyxpLlRleHR1cmVUeXBlLnVucGFja2VkKSxjPWBcXG4gIGZsb2F0IHByb2Nlc3MoaW50WyR7c31dIGluZGljZXMpIHtcXG4gICAgdmVjMiBwb3NpdGlvbiA9IG9mZnNldFRvQ29vcmRzKGluZGljZXNbMV0sICR7dX0sICR7bH0pO1xcbiAgICBmbG9hdCBzY2FsZSA9IGdldENvbG9yQXNGbG9hdCgke3IudGV4dHVyZTJEfShTY2FsZSwgcG9zaXRpb24pKTtcXG4gICAgZmxvYXQgbWVhbiA9IGdldENvbG9yQXNGbG9hdCgke3IudGV4dHVyZTJEfShNZWFuLCBwb3NpdGlvbikpO1xcbiAgICBmbG9hdCB2YXJpYW5jZSA9IGdldENvbG9yQXNGbG9hdCgke3IudGV4dHVyZTJEfShWYXJpYW5jZSwgcG9zaXRpb24pKTtcXG4gICAgZmxvYXQgYiA9IGdldENvbG9yQXNGbG9hdCgke3IudGV4dHVyZTJEfShCLCBwb3NpdGlvbikpO1xcblxcbiAgICByZXR1cm4gc2NhbGUgKiAoIChfQShpbmRpY2VzKSAtIG1lYW4pIC8gc3FydCh2YXJpYW5jZSArIGZsb2F0KCR7bi5lcHNpbG9ufSkpICkgKyBiO1xcbiAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx7b3V0cHV0OntkaW1zOnRbMF0uZGltcyx0eXBlOnRbMF0udHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6Y30pfSx1PWU9PntpZighZXx8NSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkJhdGNoTm9ybWFsaXphdGlvbiByZXF1aXJlcyA1IGlucHV0cy5cIik7Y29uc3QgdD1lWzBdLG49ZVsxXSxyPWVbMl0sbz1lWzNdLGk9ZVs0XTtpZih0LmRpbXMubGVuZ3RoPDN8fDEhPT1uLmRpbXMubGVuZ3RofHwxIT09ci5kaW1zLmxlbmd0aHx8MSE9PW8uZGltcy5sZW5ndGh8fDEhPT1pLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKG4uZGltc1swXSE9PXQuZGltc1sxXXx8ci5kaW1zWzBdIT09dC5kaW1zWzFdfHxvLmRpbXNbMF0hPT10LmRpbXNbMV18fGkuZGltc1swXSE9PXQuZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHNoYXBlLlwiKTtpZihcImZsb2F0MzJcIiE9PXQudHlwZSYmXCJmbG9hdDY0XCIhPT10LnR5cGV8fFwiZmxvYXQzMlwiIT09bi50eXBlJiZcImZsb2F0NjRcIiE9PW4udHlwZXx8XCJmbG9hdDMyXCIhPT1yLnR5cGUmJlwiZmxvYXQ2NFwiIT09ci50eXBlfHxcImZsb2F0MzJcIiE9PW8udHlwZSYmXCJmbG9hdDY0XCIhPT1vLnR5cGV8fFwiZmxvYXQzMlwiIT09aS50eXBlJiZcImZsb2F0NjRcIiE9PWkudHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHRlbnNvciB0eXBlcy5cIil9fSw1MTk0OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lnhvcj10LnN1Yj10LnBSZWx1PXQucG93PXQub3I9dC5tdWw9dC5sZXNzPXQuZ3JlYXRlcj10LmVxdWFsPXQuZGl2PXQuYW5kPXQuYWRkPXQuZ2xzbFBSZWx1PXQuZ2xzbFBvdz10Lmdsc2xYb3I9dC5nbHNsT3I9dC5nbHNsQW5kPXQuZ2xzbExlc3M9dC5nbHNsR3JlYXRlcj10Lmdsc2xFcXVhbD10Lmdsc2xTdWI9dC5nbHNsTXVsPXQuZ2xzbERpdj10Lmdsc2xBZGQ9dm9pZCAwO2NvbnN0IHI9big3MjczKSxvPW4oMTk5NyksaT1uKDY3NTcpLGE9big1NjM5KTtmdW5jdGlvbiBzKCl7Y29uc3QgZT1cImFkZF9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGEgKyBiO1xcbiAgfVxcbiAgdmVjNCAke2V9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgcmV0dXJuIHYxICsgdjI7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIHUoKXtjb25zdCBlPVwiZGl2X1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gYSAvIGI7XFxuICB9XFxuICB2ZWM0ICR7ZX0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdjEgLyB2MjtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gbCgpe2NvbnN0IGU9XCJtdWxfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBhICogYjtcXG4gIH1cXG4gIHZlYzQgJHtlfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2MSAqIHYyO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBjKCl7Y29uc3QgZT1cInN1Yl9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGEgLSBiO1xcbiAgfVxcbiAgdmVjNCAke2V9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgcmV0dXJuIHYxIC0gdjI7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIHAoKXtjb25zdCBlPVwiZXF1YWxfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdChhID09IGIpO1xcbiAgfVxcbiAgdmVjNCAke2V9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgcmV0dXJuIHZlYzQoZXF1YWwodjEsIHYyKSk7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGQoKXtjb25zdCBlPVwiZ3JlYXRlcl9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGZsb2F0KGEgPiBiKTtcXG4gIH1cXG4gIHZlYzQgJHtlfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KCB2MS5yID4gdjIuciAsXFxuICAgICAgdjEuZyA+IHYyLmcsXFxuICAgICAgdjEuYiA+IHYyLmIsXFxuICAgICAgdjEuYSA+IHYyLmEgKTtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gZigpe2NvbnN0IGU9XCJsZXNzX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gZmxvYXQoYSA8IGIpO1xcbiAgfVxcbiAgdmVjNCAke2V9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgcmV0dXJuIHZlYzQoIHYxLnIgPCB2Mi5yICxcXG4gICAgICAgICAgICAgICAgdjEuZyA8IHYyLmcsXFxuICAgICAgICAgICAgICAgIHYxLmIgPCB2Mi5iLFxcbiAgICAgICAgICAgICAgICB2MS5hIDwgdjIuYSApO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBoKCl7Y29uc3QgZT1cImFuZF9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGZsb2F0KCBib29sKGEpICYmIGJvb2woYikgKTtcXG4gIH1cXG4gIHZlYzQgJHtlfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIGJ2ZWM0IGIxID0gYnZlYzQodjEpO1xcbiAgICBidmVjNCBiMiA9IGJ2ZWM0KHYyKTtcXG4gICAgcmV0dXJuIHZlYzQoIGIxLnIgJiYgYjIuciAsXFxuICAgICAgICAgICAgICAgIGIxLmcgJiYgYjIuZyxcXG4gICAgICAgICAgICAgICAgYjEuYiAmJiBiMi5iLFxcbiAgICAgICAgICAgICAgICBiMS5hICYmIGIyLmEgKTtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gZygpe2NvbnN0IGU9XCJvcl9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGZsb2F0KCBib29sKGEpIHx8IGJvb2woYikgKTtcXG4gIH1cXG4gIHZlYzQgJHtlfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIGJ2ZWM0IGIxID0gYnZlYzQodjEpO1xcbiAgICBidmVjNCBiMiA9IGJ2ZWM0KHYyKTtcXG4gICAgcmV0dXJuIHZlYzQoIGIxLnIgfHwgYjIuciAsXFxuICAgICAgICAgICAgICAgIGIxLmcgfHwgYjIuZyxcXG4gICAgICAgICAgICAgICAgYjEuYiB8fCBiMi5iLFxcbiAgICAgICAgICAgICAgICBiMS5hIHx8IGIyLmEgKTtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gbSgpe2NvbnN0IGU9XCJ4b3JfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSBeXiBib29sKGIpICk7XFxuICB9XFxuICB2ZWM0ICR7ZX0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcXG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XFxuICAgIHJldHVybiB2ZWM0KCBiMS5yIF5eIGIyLnIgLFxcbiAgICAgICAgICAgICAgICBiMS5nIF5eIGIyLmcsXFxuICAgICAgICAgICAgICAgIGIxLmIgXl4gYjIuYixcXG4gICAgICAgICAgICAgICAgYjEuYSBeXiBiMi5hICk7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGIoKXtyZXR1cm4gZnVuY3Rpb24oZSl7Y29uc3QgdD1gJHtlfV9gO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gJHtlfShhLCBiKTtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiAke2V9KHYxLCB2Mik7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fShcInBvd1wiKX1mdW5jdGlvbiB5KCl7Y29uc3QgZT1cInByZWx1X1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gYSA8IDAuMCA/IGEgKiBiOiBhO1xcbiAgfVxcbiAgdmVjNCAke2V9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgcmV0dXJuIHZlYzQoXFxuICAgICAgdjEuciA8IDAuMCA/IHYxLnIgKiB2Mi5yOiB2MS5yLFxcbiAgICAgIHYxLmcgPCAwLjAgPyB2MS5nICogdjIuZzogdjEuZyxcXG4gICAgICB2MS5iIDwgMC4wID8gdjEuYiAqIHYyLmI6IHYxLmIsXFxuICAgICAgdjEuYSA8IDAuMCA/IHYxLmEgKiB2Mi5hOiB2MS5hXFxuICAgICAgKTtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19dC5nbHNsQWRkPXMsdC5nbHNsRGl2PXUsdC5nbHNsTXVsPWwsdC5nbHNsU3ViPWMsdC5nbHNsRXF1YWw9cCx0Lmdsc2xHcmVhdGVyPWQsdC5nbHNsTGVzcz1mLHQuZ2xzbEFuZD1oLHQuZ2xzbE9yPWcsdC5nbHNsWG9yPW0sdC5nbHNsUG93PWIsdC5nbHNsUFJlbHU9eTtjb25zdCB3PShlLHQsbixyPXRbMF0udHlwZSxvKT0+e2NvbnN0IGk9ZS5zZXNzaW9uLnBhY2s/YS5UZXh0dXJlVHlwZS5wYWNrZWQ6YS5UZXh0dXJlVHlwZS51bnBhY2tlZDtyZXR1cm57bmFtZTpuLm5hbWUsaW5wdXROYW1lczpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6W2ksaV0sY2FjaGVIaW50Om8sZ2V0OigpPT5fKGUsdCxuLHIpfX0sXz0oZSx0LG4sbz10WzBdLnR5cGUpPT57Y29uc3Qgcz1lLnNlc3Npb24ucGFjaz9hLlRleHR1cmVUeXBlLnBhY2tlZDphLlRleHR1cmVUeXBlLnVucGFja2VkLHU9IXIuU2hhcGVVdGlsLmFyZUVxdWFsKHRbMF0uZGltcyx0WzFdLmRpbXMpO2xldCBsPXRbMF0uZGltcztjb25zdCBjPWUuc2Vzc2lvbi5wYWNrO2lmKHUpe2NvbnN0IGE9ci5Ccm9hZGNhc3RVdGlsLmNhbGNTaGFwZSh0WzBdLmRpbXMsdFsxXS5kaW1zLCExKTtpZighYSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZXJmb3JtIGJpbmFyeSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtsPWE7Y29uc3QgdT1sLmxlbmd0aCxwPTAhPT10WzBdLmRpbXMubGVuZ3RoP3RbMF0uZGltcy5sZW5ndGg6MSxkPTAhPT10WzFdLmRpbXMubGVuZ3RoP3RbMV0uZGltcy5sZW5ndGg6MSxmPTAhPT10WzBdLmRpbXMubGVuZ3RoP1wiYmNhc3RJbmRpY2VzX0EoaW5kaWNlcywgYWluZGljZXMpO1wiOlwiYWluZGljZXNbMF0gPSAwO1wiLGg9MCE9PXRbMV0uZGltcy5sZW5ndGg/XCJiY2FzdEluZGljZXNfQihpbmRpY2VzLCBiaW5kaWNlcyk7XCI6XCJiaW5kaWNlc1swXSA9IDA7XCIsZz0oMCxpLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxtPWM/YFxcbiAgICAgICR7bi5ib2R5fVxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgYSA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCBiID0gZ2V0QkF0T3V0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHJlc3VsdCA9ICR7bi5uYW1lfShhLCBiKTtcXG4gICAgICAgICR7Zy5vdXRwdXR9ID0gcmVzdWx0O1xcbiAgICAgIH1gOmBcXG4gICAgICAke24uYm9keX1cXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7dX1dKSB7XFxuICAgICAgICBpbnQgYWluZGljZXNbJHtwfV07XFxuICAgICAgICBpbnQgYmluZGljZXNbJHtkfV07XFxuICAgICAgICAke2Z9XFxuICAgICAgICAke2h9XFxuICAgICAgICByZXR1cm4gJHtuLm5hbWV9KF9BKGFpbmRpY2VzKSwgX0IoYmluZGljZXMpKTtcXG4gICAgICB9YDtyZXR1cm57bmFtZTpuLm5hbWUsaW5wdXROYW1lczpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6W3Msc10sb3V0cHV0OntkaW1zOmwsdHlwZTpvLHRleHR1cmVUeXBlOnN9LHNoYWRlclNvdXJjZTptLGhhc01haW46Y319Y29uc3QgcD0oMCxpLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxkPWBcXG4gICAgJHtuLmJvZHl9XFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICB2ZWM0IHYxID0gJHtwLnRleHR1cmUyRH0oQSwgVGV4Q29vcmRzKTtcXG4gICAgICB2ZWM0IHYyID0gJHtwLnRleHR1cmUyRH0oQiwgVGV4Q29vcmRzKTtcXG4gICAgICB2ZWM0IHJlc3VsdCA9ICR7bi5uYW1lfSh2MSwgdjIpO1xcbiAgICAgICR7cC5vdXRwdXR9ID0gcmVzdWx0O1xcbiAgICB9XFxuICAgIGA7cmV0dXJue25hbWU6bi5uYW1lLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOltzLHNdLG91dHB1dDp7ZGltczp0WzBdLmRpbXMsdHlwZTpvLHRleHR1cmVUeXBlOnN9LHNoYWRlclNvdXJjZTpkLGhhc01haW46ITB9fTt0LmFkZD0oZSx0KT0+W2UucnVuKHcoZSx0LHMoKSksdCldLHQuYW5kPShlLHQpPT5bZS5ydW4odyhlLHQsaCgpLFwiYm9vbFwiKSx0KV0sdC5kaXY9KGUsdCk9PltlLnJ1bih3KGUsdCx1KCkpLHQpXSx0LmVxdWFsPShlLHQpPT5bZS5ydW4odyhlLHQscCgpLFwiYm9vbFwiKSx0KV0sdC5ncmVhdGVyPShlLHQpPT5bZS5ydW4odyhlLHQsZCgpLFwiYm9vbFwiKSx0KV0sdC5sZXNzPShlLHQpPT5bZS5ydW4odyhlLHQsZigpLFwiYm9vbFwiKSx0KV0sdC5tdWw9KGUsdCk9PltlLnJ1bih3KGUsdCxsKCkpLHQpXSx0Lm9yPShlLHQpPT5bZS5ydW4odyhlLHQsZygpLFwiYm9vbFwiKSx0KV0sdC5wb3c9KGUsdCk9PltlLnJ1bih3KGUsdCxiKCkpLHQpXSx0LnBSZWx1PShlLHQpPT5bZS5ydW4odyhlLHQseSgpKSx0KV0sdC5zdWI9KGUsdCk9PltlLnJ1bih3KGUsdCxjKCkpLHQpXSx0Lnhvcj0oZSx0KT0+W2UucnVuKHcoZSx0LG0oKSxcImJvb2xcIiksdCldfSw0NzUyOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlQ2FzdEF0dHJpYnV0ZXM9dC5jYXN0PXZvaWQgMDtjb25zdCByPW4oNzI3Myk7dC5jYXN0PShlLHQsbik9PihvKHQpLFtlLmNhc3QodFswXSxuKV0pLHQucGFyc2VDYXN0QXR0cmlidXRlcz1lPT5yLlByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhlLmF0dHJpYnV0ZXMuZ2V0SW50KFwidG9cIikpO2NvbnN0IG89ZT0+e2lmKCFlfHwxIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQ2FzdCByZXF1aXJlcyAxIGlucHV0LlwiKTtpZihcInN0cmluZ1wiPT09ZVswXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSw0NTk1OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNyZWF0ZVBhY2tlZENvbmNhdFByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNjc1Nyksbz1uKDU2MzkpLGk9big0MzIpLGE9big1NjE0KTt0LmNyZWF0ZVBhY2tlZENvbmNhdFByb2dyYW1JbmZvTG9hZGVyPShlLHQsbik9Pntjb25zdCB1PShsPXQubGVuZ3RoLGM9bi5jYWNoZUtleSx7bmFtZTpcIkNvbmNhdCAocGFja2VkKVwiLGlucHV0TmFtZXM6QXJyYXkuZnJvbSh7bGVuZ3RoOmx9LCgoZSx0KT0+YFgke3R9YCkpLGlucHV0VHlwZXM6QXJyYXkobCkuZmlsbChvLlRleHR1cmVUeXBlLnBhY2tlZCksY2FjaGVIaW50OmN9KTt2YXIgbCxjO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse2dldDooKT0+KChlLHQsbix1KT0+e2NvbnN0IGw9blswXS5kaW1zLnNsaWNlKCk7aWYodT49bC5sZW5ndGh8fHU8LTEqbC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhpcyBzcGVjaWZpZWQgZm9yIGNvbmNhdCBkb2Vzbid0IG1hdGNoIGlucHV0IGRpbWVuc2lvbmFsaXR5XCIpO3U8MCYmKHU9bC5sZW5ndGgrdSk7Y29uc3QgYz1sLnNsaWNlKDApO2ZvcihsZXQgZT0xO2U8bi5sZW5ndGg7ZSsrKXtjb25zdCB0PW5bZV0uZGltcy5zbGljZSgpO2ZvcihsZXQgZT0wO2U8bC5sZW5ndGg7ZSsrKWlmKGU9PT11KWNbdV0rPXRbZV07ZWxzZSBpZihsW2VdIT09dFtlXSl0aHJvdyBuZXcgRXJyb3IoXCJub24gY29uY2F0IGRpbWVuc2lvbnMgbXVzdCBtYXRjaFwiKX1jb25zdCBwPWMubGVuZ3RoLGQ9KDAsYS5nZXRDaGFubmVscykoXCJjb29yZHNcIixwKSxmPSgwLGkuZ2V0Q29vcmRzRGF0YVR5cGUpKHApLGg9KDAsYS51bnBhY2tGcm9tQ2hhbm5lbCkoKSxnPW4ubWFwKChlPT5lLmRpbXMpKSxtPSgwLGkuZ2V0R2xDaGFubmVscykocCksYj1uZXcgQXJyYXkoZy5sZW5ndGgtMSk7YlswXT1nWzBdW3VdO2ZvcihsZXQgZT0xO2U8Yi5sZW5ndGg7ZSsrKWJbZV09YltlLTFdK2dbZV1bdV07Y29uc3QgeT1tW3VdLHc9bS5zbGljZSgtMiksXz1tLmpvaW4oKTtsZXQgdj1gaWYgKCR7eX0gPCAke2JbMF19KSB7XFxuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICBnZXRYMCgke199KSwgdmVjMigke3cuam9pbigpfSkpO1xcbiAgICAgICAgfWA7Zm9yKGxldCBlPTE7ZTxiLmxlbmd0aDtlKyspe2NvbnN0IHQ9YltlLTFdO3YrPWBcXG4gICAgICAgICAgICBpZiAoJHt5fSA8ICR7YltlXX0gICYmICR7eX0gPj0gJHtiW2UtMV19KSB7XFxuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICAgICAgZ2V0WCR7ZX0oJHtzKG0seSx0KX0pLFxcbiAgICAgICAgICAgICAgICB2ZWMyKCR7cyh3LHksdCl9KSk7XFxuICAgICAgICAgICAgfWB9Y29uc3QgeD1iLmxlbmd0aCxUPWJbYi5sZW5ndGgtMV07dis9YFxcbiAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgICAgZ2V0WCR7eH0oJHtzKG0seSxUKX0pLFxcbiAgICAgICAgICAgICAgdmVjMigke3Modyx5LFQpfSkpO2A7Y29uc3QgUz0oMCxyLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxPPWBcXG4gICAgICAgICAgJHtofVxcbiAgICAgICAgICBmbG9hdCBnZXRWYWx1ZSgke20ubWFwKChlPT5cImludCBcIitlKSl9KSB7XFxuICAgICAgICAgICAgJHt2fVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgICAke2Z9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICAgIGludCBsYXN0RGltID0gY29vcmRzLiR7bVtwLTFdfTtcXG4gICAgICAgICAgICBjb29yZHMuJHttW3AtMV19ID0gY29vcmRzLiR7bVtwLTJdfTtcXG4gICAgICAgICAgICBjb29yZHMuJHttW3AtMl19ID0gbGFzdERpbTtcXG5cXG4gICAgICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoZ2V0VmFsdWUoJHtkfSksIDAuLCAwLiwgMC4pO1xcblxcbiAgICAgICAgICAgICR7ZFtwLTFdfSA9ICR7ZFtwLTFdfSArIDE7XFxuICAgICAgICAgICAgaWYgKCR7ZFtwLTFdfSA8ICR7Y1twLTFdfSkge1xcbiAgICAgICAgICAgICAgcmVzdWx0LmcgPSBnZXRWYWx1ZSgke2R9KTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgJHtkW3AtMl19ID0gJHtkW3AtMl19ICsgMTtcXG4gICAgICAgICAgICBpZiAoJHtkW3AtMl19IDwgJHtjW3AtMl19KSB7XFxuICAgICAgICAgICAgICByZXN1bHQuYSA9IGdldFZhbHVlKCR7ZH0pO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAke2RbcC0xXX0gPSAke2RbcC0xXX0gLSAxO1xcbiAgICAgICAgICAgIGlmICgke2RbcC0yXX0gPCAke2NbcC0yXX0gJiZcXG4gICAgICAgICAgICAgICAgJHtkW3AtMV19IDwgJHtjW3AtMV19KSB7XFxuICAgICAgICAgICAgICByZXN1bHQuYiA9IGdldFZhbHVlKCR7ZH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAke1Mub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXQ6e2RpbXM6Yyx0eXBlOm5bMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnBhY2tlZH0sc2hhZGVyU291cmNlOk8saGFzTWFpbjohMH0pfSkoZSx1LHQsbi5heGlzKX0pfTtjb25zdCBzPShlLHQsbik9Pntjb25zdCByPWUuaW5kZXhPZih0KTtyZXR1cm4gZS5tYXAoKChlLHQpPT50PT09cj9gJHtlfSAtICR7bn1gOmUpKS5qb2luKCl9fSw2NjY4OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlQ29uY2F0QXR0cmlidXRlcz10LmNvbmNhdD12b2lkIDA7Y29uc3Qgcj1uKDQ5MTApLG89big1NjM5KSxpPW4oNDU5NSk7dC5jb25jYXQ9KGUsdCxuKT0+KHAodCksZS5zZXNzaW9uLnBhY2smJnRbMF0uZGltcy5sZW5ndGg+MT9bZS5ydW4oKDAsaS5jcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mb0xvYWRlcikoZSx0LG4pLHQpXTpbZS5ydW4oYShlLHQsbiksdCldKTtjb25zdCBhPShlLHQsbik9Pntjb25zdCByPShpPXQubGVuZ3RoLGE9bi5jYWNoZUtleSx7bmFtZTpcIkNvbmNhdFwiLGlucHV0TmFtZXM6QXJyYXkuZnJvbSh7bGVuZ3RoOml9LCgoZSx0KT0+YFgke3R9YCkpLGlucHV0VHlwZXM6QXJyYXkoaSkuZmlsbChvLlRleHR1cmVUeXBlLnVucGFja2VkKSxjYWNoZUhpbnQ6YX0pO3ZhciBpLGE7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7Z2V0OigpPT4oKGUsdCxuLHIpPT57Y29uc3QgaT1uWzBdLmRpbXMuc2xpY2UoKTtpZihyPj1pLmxlbmd0aHx8cjwtMSppLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGlzIHNwZWNpZmllZCBmb3IgY29uY2F0IGRvZXNuJ3QgbWF0Y2ggaW5wdXQgZGltZW5zaW9uYWxpdHlcIik7cjwwJiYocj1pLmxlbmd0aCtyKTtjb25zdCBhPWkuc2xpY2UoMCk7Zm9yKGxldCBlPTE7ZTxuLmxlbmd0aDtlKyspe2NvbnN0IHQ9bltlXS5kaW1zLnNsaWNlKCk7Zm9yKGxldCBlPTA7ZTxpLmxlbmd0aDtlKyspaWYoZT09PXIpYVtyXSs9dFtlXTtlbHNlIGlmKGlbZV0hPT10W2VdKXRocm93IG5ldyBFcnJvcihcIm5vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoXCIpfWNvbnN0IHA9YS5sZW5ndGgsZD1uZXcgQXJyYXkobi5sZW5ndGgpO2xldCBmPTA7Zm9yKGxldCBlPTA7ZTxkLmxlbmd0aDsrK2UpZis9bltlXS5kaW1zW3JdLGRbZV09ZjtsZXQgaD1cIlwiO2g9bi5sZW5ndGg8NT9zKGQpOnUoZCk7Y29uc3QgZz1gXFxuICAgICAgICAke2wobi5sZW5ndGgscCl9XFxuICAgICAgICAke2MoZCl9XFxuICAgICAgICAke2h9XFxuICAgICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cH1dKSB7XFxuICAgICAgICAgIGludCB0ZXh0dXJlSW5kZXggPSBnZXRUZXh0dXJlV2hlcmVEYXRhUmVzaWRlcyAoaW5kaWNlc1ske3J9XSk7XFxuXFxuICAgICAgICAgIGlmKHRleHR1cmVJbmRleCAhPSAwKSB7XFxuICAgICAgICAgICAgaW5kaWNlc1ske3J9XSA9IGluZGljZXNbJHtyfV0gLSBpbnQoZ2V0U2l6ZUluQ29uY2F0QXhpc1ZhbHVlRnJvbUluZGV4KHRleHR1cmVJbmRleC1pbnQoMSkpKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gZmV0Y2hEYXRhRnJvbUNvcnJlY3RUZXh0dXJlKHRleHR1cmVJbmRleCwgaW5kaWNlcyk7XFxuICAgICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXQ6e2RpbXM6YSx0eXBlOm5bMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6Z30pfSkoMCxyLHQsbi5heGlzKX0pfSxzPWU9PmBpbnQgZ2V0VGV4dHVyZVdoZXJlRGF0YVJlc2lkZXMoaW50IGluZGV4KSB7XFxuICAgICAgJHtlLm1hcCgoKGUsdCk9PmBpZihpbmRleDwke2V9KSB7cmV0dXJuICR7dH07fVxcbmApKS5qb2luKFwiXCIpfVxcbiAgICB9YCx1PWU9PnMoZSksbD0oZSx0KT0+e2NvbnN0IG49W2BmbG9hdCBmZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmUoaW50IHRleHR1cmVJbmRleCwgaW50IGluZGljZXNbJHt0fV0pIHtgXTtmb3IobGV0IHQ9MDt0PGU7Kyt0KTA9PT10P24ucHVzaChgXFx0aWYgKHRleHR1cmVJbmRleCA9PSAke3R9KSB7IHJldHVybiBfWCR7dH0oaW5kaWNlcyk7IH1gKTp0PT09ZS0xP24ucHVzaChgXFx0ZWxzZSB7IHJldHVybiBfWCR7dH0oaW5kaWNlcyk7IH1gKTpuLnB1c2goYFxcdGVsc2UgaWYgKHRleHR1cmVJbmRleCA9PSAke3R9KSB7IHJldHVybiBfWCR7dH0oaW5kaWNlcyk7IH1gKTtyZXR1cm4gbi5wdXNoKFwiXFx0fVwiKSxuLmpvaW4oXCJcXG5cIil9LGM9ZT0+e2NvbnN0IHQ9W1wiaW50IGdldFNpemVJbkNvbmNhdEF4aXNWYWx1ZUZyb21JbmRleChpbnQgaW5kZXgpIHtcIl07Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDsrK24pMD09PW4/dC5wdXNoKGBcXHRpZiAoaW5kZXggPT0gJHtufSkgeyByZXR1cm4gJHtlW25dfTsgfWApOm49PT1lLmxlbmd0aC0xP3QucHVzaChgXFx0ZWxzZSB7IHJldHVybiAke2Vbbl19OyB9YCk6dC5wdXNoKGBcXHRlbHNlIGlmIChpbmRleCA9PSAke259KSB7IHJldHVybiAke2Vbbl19OyB9YCk7cmV0dXJuIHQucHVzaChcIlxcdH1cIiksdC5qb2luKFwiXFxuXCIpfTt0LnBhcnNlQ29uY2F0QXR0cmlidXRlcz1lPT4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F4aXM6ZS5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIil9KTtjb25zdCBwPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKTtjb25zdCB0PWVbMF0udHlwZSxuPWVbMF0uZGltcy5sZW5ndGg7aWYoXCJzdHJpbmdcIj09PXQpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIHlldFwiKTtmb3IoY29uc3QgciBvZiBlKXtpZihyLnR5cGUhPT10KXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvcnMgc2hvdWxkIGJlIG9uZSB0eXBlXCIpO2lmKHIuZGltcy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGVcIil9fX0sNzgyNTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5jcmVhdGVVbnBhY2tlZEdyb3VwZWRDb252UHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9bigxMzE1KSxvPW4oNjc1NyksaT1uKDU2MzkpLGE9big5NzU0KSxzPW4oMjE1MCk7dC5jcmVhdGVVbnBhY2tlZEdyb3VwZWRDb252UHJvZ3JhbUluZm9Mb2FkZXI9KGUsdCxuKT0+e2NvbnN0IHU9KGw9dC5sZW5ndGg+MixjPW4uY2FjaGVLZXkse25hbWU6XCJHcm91cGVkQ29udlwiLGlucHV0TmFtZXM6bD9bXCJYXCIsXCJXXCIsXCJCaWFzXCJdOltcIlhcIixcIldcIl0saW5wdXRUeXBlczpsP1tpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZF06W2kuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZF0sY2FjaGVIaW50OmN9KTt2YXIgbCxjO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse2dldDooKT0+KChlLHQsbix1KT0+e2NvbnN0IGw9dC5sZW5ndGg+Mj9cInZhbHVlICs9IGdldEJpYXMob3V0cHV0X2NoYW5uZWwpO1wiOlwiXCIsYz10WzBdLmRpbXMuc2xpY2UoKSxwPXRbMV0uZGltcy5zbGljZSgpLGQ9cFswXS91Lmdyb3VwO3IuTG9nZ2VyLnZlcmJvc2UoXCJHcm91cGVkQ29udlwiLGBhdXRwUGFkOiR7dS5hdXRvUGFkfSwgZGlsYXRpb25zOiR7dS5kaWxhdGlvbnN9LCBncm91cDoke3UuZ3JvdXB9LCBrZXJuZWxTaGFwZToke3Uua2VybmVsU2hhcGV9LCBwYWRzOiR7dS5wYWRzfSwgc3RyaWRlczoke3Uuc3RyaWRlc31gKTtjb25zdCBmPSgwLGEuY2FsY3VsYXRlT3V0cHV0U2hhcGUpKGMscCx1LmRpbGF0aW9ucyx1LnBhZHMsdS5zdHJpZGVzKSxoPSgwLG8uZ2V0R2xzbCkoZS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLHthY3RpdmF0aW9uRnVuY3Rpb246ZyxhcHBseUFjdGl2YXRpb246bX09KDAscy5nZXRBY3RpdmF0aW9uU25pcHBldCkodSksYj1gXFxuICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoJHt1LnN0cmlkZXNbMF19LCAke3Uuc3RyaWRlc1sxXX0pO1xcbiAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKCR7dS5wYWRzWzBdfSwgJHt1LnBhZHNbMV19KTtcXG4gICR7Z31cXG4gIHZvaWQgbWFpbigpIHtcXG4gICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICBpbnQgb3V0cHV0X2NoYW5uZWwgPSBjb29yZHMueTtcXG4gICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnp3ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgIGludCBncm91cF9pZCA9IG91dHB1dF9jaGFubmVsIC8gJHtkfTtcXG5cXG4gICAgZmxvYXQgdmFsdWUgPSAwLjA7XFxuICAgIGZvciAoaW50IHdJbkNoYW5uZWwgPSAwOyB3SW5DaGFubmVsIDwgJHtwWzFdfTsgd0luQ2hhbm5lbCsrKSB7XFxuICAgICAgaW50IGlucHV0X2NoYW5uZWwgPSBncm91cF9pZCAqICR7cFsxXX0gKyB3SW5DaGFubmVsO1xcbiAgICAgIGZvciAoaW50IHdIZWlnaHQgPSAwOyB3SGVpZ2h0IDwgJHtwWzJdfTsgd0hlaWdodCsrKSB7XFxuICAgICAgICBpbnQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqICR7dS5kaWxhdGlvbnNbMF19O1xcblxcbiAgICAgICAgaWYgKHhIZWlnaHQgPCAwIHx8IHhIZWlnaHQgPj0gJHtjWzJdfSkge1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZvciAoaW50IHdXaWR0aCA9IDA7IHdXaWR0aCA8ICR7cFszXX07IHdXaWR0aCsrKSB7XFxuICAgICAgICAgIGludCB4V2lkdGggPSB4UkNDb3JuZXIueSArIHdXaWR0aCAqICR7dS5kaWxhdGlvbnNbMV19O1xcbiAgICAgICAgICBpZiAoeFdpZHRoIDwgMCB8fCB4V2lkdGggPj0gJHtjWzNdfSkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCBpbnB1dF9jaGFubmVsLCB4V2lkdGgsIHhIZWlnaHQpO1xcbiAgICAgICAgICBmbG9hdCB3VmFsID0gZ2V0VyhvdXRwdXRfY2hhbm5lbCwgd0luQ2hhbm5lbCwgd1dpZHRoLCB3SGVpZ2h0KTtcXG4gICAgICAgICAgdmFsdWUgKz0geFZhbCp3VmFsO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICAke2x9XFxuICAgICR7bX1cXG4gICAgJHtoLm91dHB1dH0gPSB2ZWM0KHZhbHVlLCAuMCwgLjAsIC4wKTtcXG4gIH1cXG5gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpmLHR5cGU6dFswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpiLGhhc01haW46ITB9KX0pKGUsdCx1LG4pfSl9fSw3NzA4OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNvbnYyRFBhY2tlZD10LmNvbnYyRFBhY2tlZFBvaW50d2lzZT12b2lkIDA7Y29uc3Qgcj1uKDk3NTQpLG89big1OTUwKSxpPW4oNTYzMik7dC5jb252MkRQYWNrZWRQb2ludHdpc2U9KGUsdCxuKT0+e2NvbnN0IG89dFswXS5kaW1zLGE9dFsxXS5kaW1zLHM9KDAsci5jYWxjdWxhdGVPdXRwdXRTaGFwZSkobyxhLG4uZGlsYXRpb25zLG4ucGFkcyxuLnN0cmlkZXMpLHU9ZS5yZXNoYXBlUGFja2VkKHRbMF0sW29bMV0sb1syXSpvWzNdXSksbD1lLnJlc2hhcGVQYWNrZWQodFsxXSxbYVswXSxhWzFdXSksYz10Lmxlbmd0aD4yP1tsLHUsdFsyXV06W2wsdV0scD1lLnJ1bigoMCxpLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKShlLGMsbiksYyk7cmV0dXJuIGUucmVzaGFwZVBhY2tlZChwLHMpfSx0LmNvbnYyRFBhY2tlZD0oZSx0LG4pPT57Y29uc3QgYT10WzBdLmRpbXMscz10WzFdLmRpbXMsdT0oMCxyLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShhLHMsbi5kaWxhdGlvbnMsbi5wYWRzLG4uc3RyaWRlcyksbD1lLnJ1bigoMCxvLmNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvTG9hZGVyKShlLHRbMF0sdFsxXSx1LG4pLFt0WzBdXSksYz1lLnJlc2hhcGVQYWNrZWQodFsxXSxbc1swXSxzWzFdKnNbMl0qc1szXV0pLHA9Mz09PXQubGVuZ3RoP1tjLGwsdFsyXV06W2MsbF0sZD1lLnJ1bigoMCxpLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKShlLHAsbikscCk7cmV0dXJuIGUucmVzaGFwZVBhY2tlZChkLHUpfX0sNTA0MjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPXQuY29udlRyYW5zcG9zZT12b2lkIDA7Y29uc3Qgcj1uKDQ5MTApLG89big2NzU3KSxpPW4oNTYzOSksYT1uKDIxNTApLHM9KGUsdCxuLHIsbyxpKT0+KGUtMSkqdCtuKyhyLTEpKm8rMS1pLHU9KGUsdCxuLHIsbyk9Pntjb25zdCBpPU1hdGguZmxvb3IoZS8yKTtcIlNBTUVfVVBQRVJcIj09PXQ/KG5bcl09aSxuW29dPWUtaSk6XCJTQU1FX0xPV0VSXCI9PT10JiYobltyXT1lLWksbltvXT1pKX07dC5jb252VHJhbnNwb3NlPShlLHQsbik9PihkKHQsbiksbChlLHQsbikpO2NvbnN0IGw9KGUsdCxuKT0+e2NvbnN0IHI9cChuLHQpO3JldHVybltjKGUsdCxyKV19LGM9KGUsdCxuKT0+ZS5ydW4oKChlLHQsbik9Pntjb25zdCByPShzPXQubGVuZ3RoPjIsdT1uLmNhY2hlS2V5LHtuYW1lOlwiQ29udlRyYW5zcG9zZVwiLGlucHV0TmFtZXM6cz9bXCJYXCIsXCJXXCIsXCJCXCJdOltcIlhcIixcIldcIl0saW5wdXRUeXBlczpzP1tpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZF06W2kuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZF0sY2FjaGVIaW50OnV9KTt2YXIgcyx1O3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+KChlLHQsbixyKT0+e2NvbnN0IHM9dC5sZW5ndGg+Mj9cImdldEIob3V0cHV0X2NoYW5uZWwpXCI6XCIwLjBcIix1PXRbMF0uZGltcyxsPXRbMV0uZGltcyxjPWxbMV0scD1sWzBdL3IuZ3JvdXAsZD1bdFswXS5kaW1zWzBdLHRbMV0uZGltc1sxXSpyLmdyb3VwLC4uLnIub3V0cHV0U2hhcGVdLGY9KDAsby5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbikse2FjdGl2YXRpb25GdW5jdGlvbjpoLGFwcGx5QWN0aXZhdGlvbjpnfT0oMCxhLmdldEFjdGl2YXRpb25TbmlwcGV0KShyKSxtPWBcXG4gIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMigke3Iuc3RyaWRlc1swXX0sICR7ci5zdHJpZGVzWzFdfSk7XFxuICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoJHtyLnBhZHNbMF19LCAke3IucGFkc1sxXX0pO1xcbiAgJHtofVxcbiAgdm9pZCBtYWluKCkge1xcbiAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgIGludCBvdXRwdXRfY2hhbm5lbCA9IGNvb3Jkcy55O1xcblxcbiAgICBpdmVjMiBsb2MgPSBjb29yZHMuencgKyBwYWRzO1xcblxcbiAgICBpbnQgZ3JvdXBfaWQgPSBvdXRwdXRfY2hhbm5lbCAvICR7Y307XFxuICAgIGludCB3T3V0Q2hhbm5lbCA9IG91dHB1dF9jaGFubmVsIC0gZ3JvdXBfaWQgKiAke2N9O1xcblxcbiAgICBmbG9hdCB2YWx1ZSA9ICR7c307XFxuICAgIGZvciAoaW50IGluQ2hhbm5lbE9mZnNldCA9IDA7IGluQ2hhbm5lbE9mZnNldCA8ICR7cH07IGluQ2hhbm5lbE9mZnNldCsrKSB7XFxuICAgICAgaW50IGlucHV0X2NoYW5uZWwgPSBncm91cF9pZCAqICR7cH0gKyBpbkNoYW5uZWxPZmZzZXQ7XFxuICAgICAgZm9yIChpbnQgd1dPZmYgPSAwOyB3V09mZiA8ICR7bFsyXX07IHdXT2ZmKyspIHtcXG4gICAgICAgIGZvciAoaW50IHdIT2ZmID0gMDsgd0hPZmYgPCAke2xbM119OyB3SE9mZisrKSB7XFxuICAgICAgICAgIGl2ZWMyIHdPZmYgPSBpdmVjMih3V09mZiAqICR7ci5kaWxhdGlvbnNbMF19LCB3SE9mZiAqICR7ci5kaWxhdGlvbnNbMV19KTtcXG4gICAgICAgICAgaXZlYzIgd0xvYyA9IGxvYyAtIHdPZmY7XFxuICAgICAgICAgIGl2ZWMyIHdMb2NJbiA9IHdMb2MgLyBzdHJpZGVzO1xcbiAgICAgICAgICBpZiAoXFxuICAgICAgICAgICAgd0xvY0luICogc3RyaWRlcyA9PSB3TG9jICYmXFxuICAgICAgICAgICAgd0xvY0luLnggPj0gMCAmJiB3TG9jSW4ueCA8ICR7dVsyXX0gJiZcXG4gICAgICAgICAgICB3TG9jSW4ueSA+PSAwICYmIHdMb2NJbi55IDwgJHt1WzNdfVxcbiAgICAgICAgICApIHtcXG4gICAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgaW5wdXRfY2hhbm5lbCwgd0xvY0luLnksIHdMb2NJbi54KTtcXG4gICAgICAgICAgICBmbG9hdCB3VmFsID0gZ2V0VyhpbnB1dF9jaGFubmVsLCB3T3V0Q2hhbm5lbCwgd0hPZmYsIHdXT2ZmKTtcXG4gICAgICAgICAgICB2YWx1ZSArPSB4VmFsICogd1ZhbDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICAke2d9XFxuICAgICR7Zi5vdXRwdXR9ID0gdmVjNCh2YWx1ZSwgLjAsIC4wLCAuMCk7XFxuICB9XFxuYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtvdXRwdXQ6e2RpbXM6ZCx0eXBlOnRbMF0udHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6bSxoYXNNYWluOiEwfSl9KShlLHQscixuKX0pfSkoZSx0LG4pLHQpLHA9KGUsdCk9Pntjb25zdCBuPWUua2VybmVsU2hhcGUuc2xpY2UoKTtpZigwPT09ZS5rZXJuZWxTaGFwZS5sZW5ndGgpZm9yKGxldCBlPTI7ZTx0WzFdLmRpbXMubGVuZ3RoOysrZSluLnB1c2godFsxXS5kaW1zW2VdKTtjb25zdCByPWUucGFkcy5zbGljZSgpLG89ZS5vdXRwdXRTaGFwZS5zbGljZSgpOygoZSx0LG4scixvLGksYSxsKT0+e2NvbnN0IGM9ZS5sZW5ndGgtMixwPTA9PT1sLmxlbmd0aDtmb3IobGV0IGQ9MDtkPGM7KytkKXtjb25zdCBmPXA/ZVtkKzJdKmlbZF06bFtkXSxoPXMoZVtkKzJdLGlbZF0sb1tkXSx0W2RdLG5bZF0sZik7dShoLHIsbyxkLGQrYykscCYmbC5wdXNoKGlbZF0qKGVbZCsyXS0xKSthW2RdKyh0W2RdLTEpKm5bZF0rMS1vW2RdLW9bZCtjXSl9fSkodFswXS5kaW1zLG4sZS5kaWxhdGlvbnMsZS5hdXRvUGFkLHIsZS5zdHJpZGVzLGUub3V0cHV0UGFkZGluZyxvKTtjb25zdCBpPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIE9iamVjdC5hc3NpZ24oaSx7a2VybmVsU2hhcGU6bixwYWRzOnIsb3V0cHV0U2hhcGU6byxjYWNoZUtleTplLmNhY2hlS2V5fSksaX07dC5wYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPWU9Pntjb25zdCB0PWUuYXR0cmlidXRlcyxuPSgwLGEucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKSh0KSxvPXQuZ2V0U3RyaW5nKFwiYXV0b19wYWRcIixcIk5PVFNFVFwiKSxpPXQuZ2V0SW50cyhcImRpbGF0aW9uc1wiLFsxLDFdKSxzPXQuZ2V0SW50KFwiZ3JvdXBcIiwxKSx1PXQuZ2V0SW50cyhcImtlcm5lbF9zaGFwZVwiLFtdKSxsPXQuZ2V0SW50cyhcIm91dHB1dF9wYWRkaW5nXCIsWzAsMF0pLGM9dC5nZXRJbnRzKFwib3V0cHV0X3NoYXBlXCIsW10pLHA9dC5nZXRJbnRzKFwicGFkc1wiLFswLDAsMCwwXSksZD10LmdldEludHMoXCJzdHJpZGVzXCIsWzEsMV0pO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KShPYmplY3QuYXNzaWduKHthdXRvUGFkOm8sZGlsYXRpb25zOmksZ3JvdXA6cyxrZXJuZWxTaGFwZTp1LG91dHB1dFBhZGRpbmc6bCxvdXRwdXRTaGFwZTpjLHBhZHM6cCxzdHJpZGVzOmR9LG4pKX07Y29uc3QgZD0oZSx0KT0+e2lmKCFlfHwyIT09ZS5sZW5ndGgmJjMhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoNCE9PWVbMF0uZGltcy5sZW5ndGh8fDQhPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252XCIpO2lmKGVbMF0uZGltc1sxXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2NvbnN0IG49ZVsxXS5kaW1zWzFdKnQuZ3JvdXA7aWYoMz09PWUubGVuZ3RoJiYoMSE9PWVbMl0uZGltcy5sZW5ndGh8fGVbMl0uZGltc1swXSE9PW4pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmlhc1wiKTtjb25zdCByPWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5sZW5ndGghPT1yKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke3J9RGApO2lmKHQuc3RyaWRlcy5sZW5ndGghPT1yKXRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtyfURgKTtpZih0LnBhZHMubGVuZ3RoIT09MipyKXRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHsyKnJ9RGApO2lmKHQub3V0cHV0UGFkZGluZy5sZW5ndGghPT1yKXRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7cn1EYCk7aWYoMCE9PXQua2VybmVsU2hhcGUubGVuZ3RoJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtlcm5lbCBzaGFwZVwiKTtpZigwIT09dC5vdXRwdXRTaGFwZS5sZW5ndGgmJnQub3V0cHV0U2hhcGUubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgb3V0cHV0IHNoYXBlXCIpO2lmKFwiZmxvYXQzMlwiIT09ZVswXS50eXBlfHxcImZsb2F0MzJcIiE9PWVbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJDb252VHJhbnNwb3NlIGlucHV0KFgsVykgc2hvdWxkIGJlIGZsb2F0IHRlbnNvclwiKTtpZigzPT09ZS5sZW5ndGgmJlwiZmxvYXQzMlwiIT09ZVsyXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkNvbnZUcmFuc3Bvc2UgaW5wdXQoYmlhcykgc2hvdWxkIGJlIGZsb2F0IHRlbnNvclwiKX19LDk3NTQ6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VDb252QXR0cmlidXRlcz10LmNvbnY9dC5jYWxjdWxhdGVPdXRwdXRTaGFwZT12b2lkIDA7Y29uc3Qgcj1uKDQ5MTApLG89big3MjczKSxpPW4oNzgyNSksYT1uKDc3MDgpLHM9bigzMjgxKSx1PW4oMjE1MCksbD1uKDE2MjUpLGM9big4Mjc2KTt0LmNhbGN1bGF0ZU91dHB1dFNoYXBlPShlLHQsbixyLG8pPT57Y29uc3QgaT1lWzBdLGE9ZS5zbGljZSgyKSxzPWEubGVuZ3RoLHU9dFswXSxsPXQuc2xpY2UoMikubWFwKCgoZSx0KT0+ZSsoZS0xKSooblt0XS0xKSkpLGM9YS5tYXAoKChlLHQpPT5lK3JbdF0rclt0K3NdKSkubWFwKCgoZSx0KT0+TWF0aC5mbG9vcigoZS1sW3RdK29bdF0pL29bdF0pKSk7cmV0dXJuW2ksdV0uY29uY2F0KC4uLmMpfSx0LmNvbnY9KGUsdCxuKT0+KGcodCxuKSxwKGUsdCxuKSk7Y29uc3QgcD0oZSx0LG4pPT57Y29uc3Qgcj1oKG4sdCksbz1lLnNlc3Npb24ucGFjayxzPTE9PT1yLmtlcm5lbFNoYXBlWzBdJiYxPT09ci5rZXJuZWxTaGFwZVsxXTtyZXR1cm4gci5ncm91cD4xP1tlLnJ1bigoMCxpLmNyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mb0xvYWRlcikoZSx0LHIpLHQpXTpzJiZvP1tkKGUsdCxyKV06byYmND09PXRbMF0uZGltcy5sZW5ndGgmJjE9PT10WzBdLmRpbXNbMF0mJiFzP1soMCxhLmNvbnYyRFBhY2tlZCkoZSx0LHIpXTpbZihlLHQscildfSxkPShlLG4scik9Pntjb25zdCBvPW5bMF0uZGltcyxpPW5bMV0uZGltcyxhPSgwLHQuY2FsY3VsYXRlT3V0cHV0U2hhcGUpKG8saSxyLmRpbGF0aW9ucyxyLnBhZHMsci5zdHJpZGVzKSxzPWUucmVzaGFwZVVucGFja2VkKG5bMF0sW29bMV0sb1syXSpvWzNdXSksdT1lLnJlc2hhcGVVbnBhY2tlZChuWzFdLFtpWzBdLGlbMV1dKSxsPW4ubGVuZ3RoPjI/W3UscyxuWzJdXTpbdSxzXSxwPWUucnVuKCgwLGMuY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIpKGwsciksbCk7cmV0dXJuIGUucmVzaGFwZVVucGFja2VkKHAsYSl9LGY9KGUsbixyKT0+e2NvbnN0IG89blswXS5kaW1zLGk9blsxXS5kaW1zLGE9KDAsdC5jYWxjdWxhdGVPdXRwdXRTaGFwZSkobyxpLHIuZGlsYXRpb25zLHIucGFkcyxyLnN0cmlkZXMpLHU9ZS5ydW4oKDAsbC5jcmVhdGVJbTJDb2xQcm9ncmFtSW5mb0xvYWRlcikoZSxuWzBdLG5bMV0sYSxyKSxbblswXV0pLGM9Mz09PW4ubGVuZ3RoP1t1LG5bMV0sblsyXV06W3UsblsxXV07cmV0dXJuIGUucnVuKCgwLHMuY3JlYXRlRG90UHJvZHVjdFByb2dyYW1JbmZvTG9hZGVyKShlLG4sYSxyKSxjKX0saD0oZSx0KT0+e2NvbnN0IG49ZS5rZXJuZWxTaGFwZS5zbGljZSgpO2lmKDA9PT1lLmtlcm5lbFNoYXBlLmxlbmd0aClmb3IobGV0IGU9MjtlPHRbMV0uZGltcy5sZW5ndGg7KytlKW4ucHVzaCh0WzFdLmRpbXNbZV0pO2NvbnN0IHI9ZS5wYWRzLnNsaWNlKCk7by5Qb29sQ29udlV0aWwuYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKHRbMF0uZGltcyxlLnN0cmlkZXMsZS5kaWxhdGlvbnMsbixyLGUuYXV0b1BhZCk7Y29uc3QgaT1PYmplY3QuYXNzaWduKHt9LGUpO3JldHVybiBPYmplY3QuYXNzaWduKGkse2tlcm5lbFNoYXBlOm4scGFkczpyLGNhY2hlS2V5OmUuY2FjaGVLZXl9KSxpfTt0LnBhcnNlQ29udkF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5hdHRyaWJ1dGVzLG49KDAsdS5wYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpKHQpLG89dC5nZXRTdHJpbmcoXCJhdXRvX3BhZFwiLFwiTk9UU0VUXCIpLGk9dC5nZXRJbnRzKFwiZGlsYXRpb25zXCIsWzEsMV0pLGE9dC5nZXRJbnQoXCJncm91cFwiLDEpLHM9dC5nZXRJbnRzKFwia2VybmVsX3NoYXBlXCIsW10pLGw9dC5nZXRJbnRzKFwicGFkc1wiLFswLDAsMCwwXSksYz10LmdldEludHMoXCJzdHJpZGVzXCIsWzEsMV0pO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KShPYmplY3QuYXNzaWduKHthdXRvUGFkOm8sZGlsYXRpb25zOmksZ3JvdXA6YSxrZXJuZWxTaGFwZTpzLHBhZHM6bCxzdHJpZGVzOmN9LG4pKX07Y29uc3QgZz0oZSx0KT0+e2lmKCFlfHwyIT09ZS5sZW5ndGgmJjMhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoNCE9PWVbMF0uZGltcy5sZW5ndGh8fDQhPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252XCIpO2lmKGVbMF0uZGltc1sxXSE9PWVbMV0uZGltc1sxXSp0Lmdyb3VwKXRocm93IG5ldyBFcnJvcihcIkZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcIik7aWYoMz09PWUubGVuZ3RoJiYoMSE9PWVbMl0uZGltcy5sZW5ndGh8fGVbMV0uZGltc1swXSE9PWVbMl0uZGltc1swXSkpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2NvbnN0IG49ZVswXS5kaW1zLmxlbmd0aC0yO2lmKHQuZGlsYXRpb25zLmxlbmd0aCE9PW4pdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7bn1EYCk7aWYodC5zdHJpZGVzLmxlbmd0aCE9PW4pdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke259RGApO2lmKHQucGFkcy5sZW5ndGghPT0yKm4pdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAkezIqbn1EYCk7aWYoMCE9PXQua2VybmVsU2hhcGUubGVuZ3RoJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtlcm5lbCBzaGFwZVwiKTtpZihcImZsb2F0MzJcIiE9PWVbMF0udHlwZXx8XCJmbG9hdDMyXCIhPT1lWzFdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ29udiBpbnB1dChYLFcpIHNob3VsZCBiZSBmbG9hdCB0ZW5zb3JcIik7aWYoMz09PWUubGVuZ3RoJiZcImZsb2F0MzJcIiE9PWVbMl0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJDb252IGlucHV0KGJpYXMpIHNob3VsZCBiZSBmbG9hdCB0ZW5zb3JcIil9fSw2NzQyOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlcz10LmRlcHRoVG9TcGFjZT12b2lkIDA7Y29uc3Qgcj1uKDU3MDcpO3QuZGVwdGhUb1NwYWNlPShlLHQsbik9PntvKHQpO2NvbnN0IGk9bi5ibG9ja3NpemUsYT1pKmkscz1cIkRDUlwiPT09bi5tb2RlP1swLDMsNCwxLDUsMl06WzAsMSw0LDIsNSwzXSx1PVwiRENSXCI9PT1uLm1vZGU/W3RbMF0uZGltc1swXSxpLGksdFswXS5kaW1zWzFdL2EsdFswXS5kaW1zWzJdLHRbMF0uZGltc1szXV06W3RbMF0uZGltc1swXSx0WzBdLmRpbXNbMV0vYSxpLGksdFswXS5kaW1zWzJdLHRbMF0uZGltc1szXV0sbD1lLnJlc2hhcGVVbnBhY2tlZCh0WzBdLHUpLGM9e3Blcm06cyxjYWNoZUtleTpgJHtzfWB9LFtwXT0oMCxyLnRyYW5zcG9zZSkoZSxbbF0sYyksZD1bdFswXS5kaW1zWzBdLHRbMF0uZGltc1sxXS9hLHRbMF0uZGltc1syXSppLHRbMF0uZGltc1szXSppXTtyZXR1cm5bZS5yZXNoYXBlVW5wYWNrZWQocCxkKV19LHQucGFyc2VEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzPWU9Pntjb25zdCB0PWUuYXR0cmlidXRlcy5nZXRJbnQoXCJibG9ja3NpemVcIik7aWYodDwxKXRocm93IG5ldyBFcnJvcihgYmxvY2tzaXplIG11c3QgYmUgPj0gMSwgYnV0IGdvdCA6ICR7dH0gZm9yIERlcHRoVG9TcGFjZWApO2NvbnN0IG49ZS5hdHRyaWJ1dGVzLmdldFN0cmluZyhcIm1vZGVcIixcIkRDUlwiKTtpZihcIkRDUlwiIT09biYmXCJDUkRcIiE9PW4pdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgbW9kZTogJHtufSBmb3IgRGVwdGhUb1NwYWNlYCk7cmV0dXJue21vZGU6bixibG9ja3NpemU6dH19O2NvbnN0IG89ZT0+e2lmKDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYERlcHRoVG9TcGFjZSBleHBlY3QgMSBpbnB1dHMsIGJ1dCBnb3QgJHtlLmxlbmd0aH1gKTtpZihcInN0cmluZ1wiPT09ZVswXS50eXBlfHw0IT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVwdGhUb1NwYWNlIGlucHV0IHNob3VsZCBiZSBhIDQtRCBudW1lcmljIHRlbnNvclwiKX19LDMyODE6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlRG90UHJvZHVjdFByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNzI3Myksbz1uKDY3NTcpLGk9big1NjM5KSxhPW4oMjE1MCkscz1uKDE2MjUpO3QuY3JlYXRlRG90UHJvZHVjdFByb2dyYW1JbmZvTG9hZGVyPShlLHQsbix1KT0+e2NvbnN0IGw9KChlLHQpPT4oe25hbWU6XCJDb252RG90UHJvZHVjdFwiLGlucHV0TmFtZXM6ZT9bXCJJbTJDb2xcIixcIktcIixcIkJcIl06W1wiSW0yQ29sXCIsXCJLXCJdLGlucHV0VHlwZXM6ZT9baS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24saS5UZXh0dXJlVHlwZS51bnBhY2tlZF06W2kuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uXSxjYWNoZUtleTp0LmFjdGl2YXRpb25DYWNoZUtleX0pKSh0Lmxlbmd0aD4yLHUpO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbCkse2dldDooKT0+KChlLHQsbix1LGwpPT57Y29uc3QgYz1uWzBdLmRpbXMscD1uWzFdLmRpbXMsZD1bcFswXSxNYXRoLmNlaWwoY1sxXSpwWzJdKnBbM10vNCldLGY9KDAscy5jYWxjdWxhdGVJbTJDb2xEaW1zKShjLHAsdSksW2gsZ109ZS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoZCxpLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24pLG09ci5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZiksW2IseV09ZS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoZixpLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24pLHc9dS5sZW5ndGgsXz1uLmxlbmd0aDwzP1wiMC4wXCI6XCJfQihiKVwiLHY9TWF0aC5jZWlsKGNbMV0qcFsyXSpwWzNdLzQpLHthY3RpdmF0aW9uRnVuY3Rpb246eCxhcHBseUFjdGl2YXRpb246VH09KDAsYS5nZXRBY3RpdmF0aW9uU25pcHBldCkobCksUz0oMCxvLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxPPWBcXG4ke3h9XFxuZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3d9XSkge1xcbiAgaW50IGJbMV07XFxuICBiWzBdID0gaW5kaWNlc1sxXTtcXG4gIGludCBpbTJjb2xbNF07XFxuICBpbTJjb2xbMF0gPSBpbmRpY2VzWzBdO1xcbiAgaW0yY29sWzFdID0gaW5kaWNlc1syXTtcXG4gIGltMmNvbFsyXSA9IGluZGljZXNbM107XFxuICBpbnQgaW0yY29sT2Zmc2V0ID0gaW0yY29sWzBdICogJHttWzBdfSArIGltMmNvbFsxXSAqICR7bVsxXX0gKyBpbTJjb2xbMl0gKiAke21bMl19O1xcbiAgaW50IGtlcm5lbE9mZnNldCA9IGluZGljZXNbMV0gKiAke2RbMV19O1xcbiAgZmxvYXQgdmFsdWUgPSAke199O1xcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCAke3Z9OyArK2kpIHtcXG4gICAgdmVjMiBpbTJjb2xDb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhpbTJjb2xPZmZzZXQsICR7Yn0sICR7eX0pO1xcbiAgICB2ZWMyIGtlcm5lbENvb3JkcyA9IG9mZnNldFRvQ29vcmRzKGtlcm5lbE9mZnNldCwgJHtofSwgJHtnfSk7XFxuICAgIHZhbHVlICs9IGRvdCgke1MudGV4dHVyZTJEfShJbTJDb2wsIGltMmNvbENvb3JkcyksICR7Uy50ZXh0dXJlMkR9KEssIGtlcm5lbENvb3JkcykpO1xcbiAgICArK2ltMmNvbE9mZnNldDtcXG4gICAgKytrZXJuZWxPZmZzZXQ7XFxuICB9XFxuICAke1R9XFxuICByZXR1cm4gdmFsdWU7XFxufWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7b3V0cHV0OntkaW1zOnUsdHlwZTpuWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOk99KX0pKGUsbCx0LG4sdSl9KX19LDQxMjU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VGbGF0dGVuQXR0cmlidXRlcz10LmZsYXR0ZW49dm9pZCAwO2NvbnN0IHI9big3MjczKTt0LmZsYXR0ZW49KGUsdCxuKT0+e28odCxuKTtjb25zdCBpPXIuU2hhcGVVdGlsLmZsYXR0ZW5TaGFwZSh0WzBdLmRpbXMsbik7cmV0dXJuW2UucmVzaGFwZVVucGFja2VkKHRbMF0saSldfSx0LnBhcnNlRmxhdHRlbkF0dHJpYnV0ZXM9ZT0+ZS5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwxKTtjb25zdCBvPShlLHQpPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0dGVuIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2NvbnN0IG49ZVswXS5kaW1zLmxlbmd0aDtpZigwPT09bil0aHJvdyBuZXcgRXJyb3IoXCJzY2FsYXIgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO2lmKHQ8LW58fHQ+bil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGF4aXNcIik7aWYoXCJzdHJpbmdcIj09PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQuXCIpfX0sMjE1MDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXM9dC5nZXRBY3RpdmF0aW9uU25pcHBldD12b2lkIDA7Y29uc3Qgcj1uKDcyNzMpLG89big5MDg3KTt0LmdldEFjdGl2YXRpb25TbmlwcGV0PWZ1bmN0aW9uKGUpe2xldCB0O3N3aXRjaChlLmFjdGl2YXRpb24pe2Nhc2VcIlJlbHVcIjp0PSgwLG8uZ2xzbFJlbHUpKCk7YnJlYWs7Y2FzZVwiU2lnbW9pZFwiOnQ9KDAsby5nbHNsU2lnbW9pZCkoKTticmVhaztjYXNlXCJDbGlwXCI6dD0oMCxvLmdsc2xDbGlwKShlLmNsaXBNaW4sZS5jbGlwTWF4KTticmVhaztkZWZhdWx0OnJldHVybnthY3RpdmF0aW9uRnVuY3Rpb246XCJcIixhcHBseUFjdGl2YXRpb246XCJcIn19Y29uc3Qgbj10Lm5hbWU7cmV0dXJue2FjdGl2YXRpb25GdW5jdGlvbjp0LmJvZHksYXBwbHlBY3RpdmF0aW9uOmB2YWx1ZSA9ICR7bn1fKHZhbHVlKTtgfX0sdC5wYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5nZXRTdHJpbmcoXCJhY3RpdmF0aW9uXCIsXCJcIik7aWYoXCJDbGlwXCI9PT10KXtjb25zdFtuLG9dPWUuZ2V0RmxvYXRzKFwiYWN0aXZhdGlvbl9wYXJhbXNcIixbci5NSU5fQ0xJUCxyLk1BWF9DTElQXSk7cmV0dXJue2FjdGl2YXRpb246dCxjbGlwTWF4Om8sY2xpcE1pbjpuLGFjdGl2YXRpb25DYWNoZUtleTpgJHt0fToke259LCR7b31gfX1yZXR1cm57YWN0aXZhdGlvbjp0LGFjdGl2YXRpb25DYWNoZUtleTp0fX19LDYxNDk6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VHYXRoZXJBdHRyaWJ1dGVzPXQuZ2F0aGVyPXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDYxNDUpLGk9big3MjczKSxhPW4oNTYzOSk7dC5nYXRoZXI9KGUsdCxuKT0+KGwodCxuLmF4aXMpLFtlLnJ1bih1KGUsdCxuKSx0KV0pLHQucGFyc2VHYXRoZXJBdHRyaWJ1dGVzPWU9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXhpczplLmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiLDApfSk7Y29uc3Qgcz17bmFtZTpcIkdhdGhlclwiLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkLGEuVGV4dHVyZVR5cGUudW5wYWNrZWRdfSx1PShlLHQsbik9Pntjb25zdCByPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXl9KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHtnZXQ6KCk9PigoZSx0LG4scik9Pntjb25zdCBvPW5bMF0uZGltcy5zbGljZSgpLHM9blsxXS5kaW1zLnNsaWNlKCksdT1uZXcgQXJyYXkoby5sZW5ndGgrcy5sZW5ndGgtMSk7cj1pLlNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKHIsby5sZW5ndGgpO2NvbnN0IGw9W107Zm9yKGxldCBlPTA7ZTx1Lmxlbmd0aDtlKyspZTxyPyh1W2VdPW9bZV0sbC5wdXNoKGBpbnB1dElkeFske2V9XSA9IG91dHB1dElkeFske2V9XTtgKSk6ZTxyK3MubGVuZ3RoPyh1W2VdPXNbZS1yXSxsLnB1c2goYGluZGV4RGF0YUlkeFske2Utcn1dID0gb3V0cHV0SWR4WyR7ZX1dO2ApKToodVtlXT1vW2Utcy5sZW5ndGgrMV0sbC5wdXNoKGBpbnB1dElkeFske2Utcy5sZW5ndGgrMX1dID0gb3V0cHV0SWR4WyR7ZX1dO2ApKTtjb25zdCBjPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHt1Lmxlbmd0aHx8MX1dKSB7XFxuICAgICAgICBpbnQgaW5wdXRJZHhbJHtvLmxlbmd0aH1dO1xcbiAgICAgICAgaW50IGluZGV4RGF0YUlkeFske3MubGVuZ3RofHwxfV07XFxuICAgICAgICBpbmRleERhdGFJZHhbMF0gPSAwO1xcbiAgICAgICAgJHtsLmpvaW4oXCJcXG4gICAgICAgIFwiKX1cXG4gICAgICAgIGludCBpZHggPSBpbnQoX0IoaW5kZXhEYXRhSWR4KSk7XFxuICAgICAgICBpbnB1dElkeFske3J9XSA9IGlkeCA8IDAgPyBpZHggKyAke29bcl19IDogaWR4O1xcbiAgICAgICAgcmV0dXJuIF9BKGlucHV0SWR4KTtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXQ6e2RpbXM6dSx0eXBlOm5bMF0udHlwZSx0ZXh0dXJlVHlwZTphLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6Y30pfSkoMCxyLHQsbi5heGlzKX0pfSxsPShlLHQpPT57aWYoIWV8fDIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXIgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2NvbnN0IG49ZVswXS5kaW1zLmxlbmd0aDtpZihuPDEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYodDwtbnx8dD5uLTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBheGlzLlwiKTtpZigtMT09PW8uTlVNQkVSX1RZUEVTLmluZGV4T2YoZVswXS50eXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhaWQgaW5wdXQgdHlwZS5cIik7aWYoXCJpbnQzMlwiIT09ZVsxXS50eXBlJiZcImludDE2XCIhPT1lWzFdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWlkIGlucHV0IHR5cGUuXCIpfX0sNTM3ODooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZUdlbW1BdHRyaWJ1dGVzVjExPXQucGFyc2VHZW1tQXR0cmlidXRlc1Y3PXQuZ2VtbT12b2lkIDA7Y29uc3Qgcj1uKDQ5MTApLG89big3MjczKSxpPW4oNTYzOSk7dC5nZW1tPShlLHQsbik9PihsKHQsbiksW2UucnVuKHModCxuKSx0KV0pO2NvbnN0IGE9KGUsdCk9Pntjb25zdCBuPTAhPT1lLmF0dHJpYnV0ZXMuZ2V0SW50KFwidHJhbnNBXCIsMCksbz0wIT09ZS5hdHRyaWJ1dGVzLmdldEludChcInRyYW5zQlwiLDApLGk9ZS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiYWxwaGFcIiwxKSxhPWUuYXR0cmlidXRlcy5nZXRGbG9hdChcImJldGFcIiwxKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe3RyYW5zQTpuLHRyYW5zQjpvLGFscGhhOmksYmV0YTphLGlzT3B0aW9uYWxDOnR9KX07dC5wYXJzZUdlbW1BdHRyaWJ1dGVzVjc9ZT0+YShlLCExKSx0LnBhcnNlR2VtbUF0dHJpYnV0ZXNWMTE9ZT0+YShlLCEwKTtjb25zdCBzPShlLHQpPT57Y29uc3Qgbj17bmFtZTpcIkdlbW1cIixpbnB1dE5hbWVzOjM9PT1lLmxlbmd0aD9bXCJBXCIsXCJCXCIsXCJDXCJdOltcIkFcIixcIkJcIl0saW5wdXRUeXBlczozPT09ZS5sZW5ndGg/W2kuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkXTpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkXSxrZXk6dC5jYWNoZUtleX07cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7Z2V0OigpPT51KG4sZSx0KX0pfSx1PShlLHQsbik9Pntjb25zdCByPXRbMF0uZGltcy5zbGljZSgpLGE9dFsxXS5kaW1zLnNsaWNlKCksW3MsdV09by5HZW1tVXRpbC5nZXRTaGFwZU9mR2VtbVJlc3VsdChyLG4udHJhbnNBLGEsbi50cmFuc0IsMz09PXQubGVuZ3RoP3RbMl0uZGltczp2b2lkIDApLGw9W3MsdV07aWYoIWwpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIGdlbW0gb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bGV0IGM9cltyLmxlbmd0aC0xXSxwPVwiXCI7bi50cmFuc0EmJihjPXJbMF0pLG4udHJhbnNBJiZuLnRyYW5zQj9wPVwidmFsdWUgKz0gX0FfVChhKSAqIF9CX1QoYik7XCI6bi50cmFuc0EmJiFuLnRyYW5zQj9wPVwidmFsdWUgKz0gX0FfVChhKSAqIF9CKGIpO1wiOiFuLnRyYW5zQSYmbi50cmFuc0I/cD1cInZhbHVlICs9IF9BKGEpICogX0JfVChiKTtcIjpuLnRyYW5zQXx8bi50cmFuc0J8fChwPVwidmFsdWUgKz0gX0EoYSkgKiBfQihiKTtcIik7Y29uc3QgZD1sLmxlbmd0aCxmPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7ZH1dKSB7XFxuICAgICAgICAgIGludCBhWyR7ZH1dO1xcbiAgICAgICAgICBpbnQgYlske2R9XTtcXG4gICAgICAgICAgJHszPT09dC5sZW5ndGg/YGludCBjWyR7dFsyXS5kaW1zLmxlbmd0aH1dO2A6XCJcIn1cXG5cXG4gICAgICAgICAgY29weVZlYyhpbmRpY2VzLCBhKTtcXG4gICAgICAgICAgY29weVZlYyhpbmRpY2VzLCBiKTtcXG4gICAgICAgICAgJHszPT09dC5sZW5ndGg/XCJiY2FzdEluZGljZXNfQyhpbmRpY2VzLCBjKTtcIjpcIlwifVxcblxcbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9IDAuMDtcXG4gICAgICAgICAgZm9yIChpbnQgaz0wOyBrPCR7Y307ICsraykge1xcbiAgICAgICAgICAgICAgYVske2QtMX1dID0gaztcXG4gICAgICAgICAgICAgIGJbJHtkLTJ9XSA9IGs7XFxuICAgICAgICAgICAgICAke3B9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIGFscGhhO1xcbiAgICAgICAgICAkezM9PT10Lmxlbmd0aD9cInZhbHVlICs9IGJldGEgKiBfQyhjKTtcIjpcIlwifVxcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOmwsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sdmFyaWFibGVzOlt7bmFtZTpcImFscGhhXCIsdHlwZTpcImZsb2F0XCIsZGF0YTpuLmFscGhhfSx7bmFtZTpcImJldGFcIix0eXBlOlwiZmxvYXRcIixkYXRhOm4uYmV0YX1dLHNoYWRlclNvdXJjZTpmfSl9LGw9KGUsdCk9PntpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBpcyBtaXNzaW5nXCIpO2lmKHQuaXNPcHRpb25hbEMmJihlLmxlbmd0aDwyfHxlLmxlbmd0aD4zKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhaWQgaW5wdXQgc2hhcGUuXCIpO2lmKCF0LmlzT3B0aW9uYWxDJiYzIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiR2VtbSByZXF1aXJlcyAzIGlucHV0c1wiKTtpZigzPT09ZS5sZW5ndGgmJjEhPT1lWzJdLmRpbXMubGVuZ3RoJiYyIT09ZVsyXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHNoYXBlIG9mIENcIik7aWYoXCJmbG9hdDMyXCIhPT1lWzBdLnR5cGUmJlwiZmxvYXQ2NFwiIT09ZVswXS50eXBlfHxcImZsb2F0MzJcIiE9PWVbMV0udHlwZSYmXCJmbG9hdDY0XCIhPT1lWzFdLnR5cGV8fDM9PT1lLmxlbmd0aCYmXCJmbG9hdDMyXCIhPT1lWzJdLnR5cGUmJlwiZmxvYXQ2NFwiIT09ZVsyXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoZVswXS50eXBlIT09ZVsxXS50eXBlfHwzPT09ZS5sZW5ndGgmJmVbMF0udHlwZSE9PWVbMl0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlcyBhcmUgbWlzbWF0Y2hlZFwiKX19LDU5NTA6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlUGFja2VkSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9big2NzU3KSxvPW4oNTYzOSksaT1uKDU2MTQpO3QuY3JlYXRlUGFja2VkSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXI9KGUsdCxuLGEscyk9Pntjb25zdCB1PShsPXMuY2FjaGVLZXkse25hbWU6XCJJbTJDb2wgKHBhY2tlZClcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS5wYWNrZWRdLGNhY2hlSGludDpsfSk7dmFyIGw7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Z2V0OigpPT4oKGUsdCxuLGEscyx1KT0+e2NvbnN0IGw9bi5kaW1zLGM9YS5kaW1zLHA9cy5sZW5ndGgsZD1bY1sxXSpjWzJdKmNbM10sc1syXSpzWzNdXSxmPWNbMl0qY1szXSxoPSgwLGkudW5wYWNrRnJvbUNoYW5uZWwpKCksZz0oMCxyLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtsZXQgbT1cIlwiO2ZvcihsZXQgZT0wO2U8PTE7ZSsrKWZvcihsZXQgdD0wO3Q8PTE7dCsrKW0rPWBcXG4gICAgICAgICAgICBibG9ja0luZGV4ID0gcmMueCArICR7dH07XFxuICAgICAgICAgICAgcG9zID0gcmMueSArICR7ZX07XFxuXFxuICAgICAgICAgICAgaWYoYmxvY2tJbmRleCA8ICR7ZFsxXX0gJiYgcG9zIDwgJHtkWzBdfSkge1xcbiAgICAgICAgICAgICAgb2Zmc2V0WSA9IGludChibG9ja0luZGV4IC8gKCR7c1twLTFdfSkpICogJHt1LnN0cmlkZXNbMF19IC1cXG4gICAgICAgICAgICAgICAgJHt1LnBhZHNbMF19O1xcbiAgICAgICAgICAgICAgZDAgPSBvZmZzZXRZICsgJHt1LmRpbGF0aW9uc1swXX0gKiAoaW1vZChwb3MsICR7Zn0pIC8gJHtjWzJdfSk7XFxuXFxuICAgICAgICAgICAgICBpZihkMCA8ICR7bFsyXX0gJiYgZDAgPj0gMCkge1xcbiAgICAgICAgICAgICAgICBvZmZzZXRYID0gaW1vZChibG9ja0luZGV4LCAke3NbcC0xXX0pICogJHt1LnN0cmlkZXNbMV19IC1cXG4gICAgICAgICAgICAgICAgICAke3UucGFkc1sxXX07XFxuICAgICAgICAgICAgICAgIGQxID0gb2Zmc2V0WCArICR7dS5kaWxhdGlvbnNbMV19ICogaW1vZChpbW9kKHBvcywgJHtmfSksICR7Y1syXX0pO1xcblxcbiAgICAgICAgICAgICAgICBpZihkMSA8ICR7bFszXX0gJiYgZDEgPj0gMCkge1xcblxcbiAgICAgICAgICAgICAgICAgIGNoID0gaW50KGZsb2F0KHBvcykvICR7Zn0uKTtcXG4gICAgICAgICAgICAgICAgICAgIGlubmVyRGltcyA9IHZlYzIoZDAsIGQxKTtcXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFskezIqZSt0fV0gPSBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRBKDAsIGNoLCBpbnQoaW5uZXJEaW1zLngpLFxcbiAgICAgICAgICAgICAgICAgICAgICBpbnQoaW5uZXJEaW1zLnkpKSwgaW5uZXJEaW1zKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYDtjb25zdCBiPWBcXG4gICAgICAke2h9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuMCk7XFxuICAgICAgICAgIGludCBibG9ja0luZGV4LCBwb3MsIG9mZnNldFksIGQwLCBvZmZzZXRYLCBkMSwgY2g7XFxuICAgICAgICAgIHZlYzIgaW5uZXJEaW1zO1xcbiAgICAgICAgICAke219XFxuICAgICAgICAgICR7Zy5vdXRwdXR9ID0gcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgICAgICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dDp7ZGltczpkLHR5cGU6bi50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUucGFja2VkfSxzaGFkZXJTb3VyY2U6YixoYXNNYWluOiEwfSl9KShlLHUsdCxuLGEscyl9KX19LDE2MjU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY2FsY3VsYXRlSW0yQ29sRGltcz10LmNyZWF0ZUltMkNvbFByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNTYzOSk7dC5jcmVhdGVJbTJDb2xQcm9ncmFtSW5mb0xvYWRlcj0oZSxuLG8saSxhKT0+e2NvbnN0IHM9KHU9YS5jYWNoZUtleSx7bmFtZTpcIkltMkNvbFwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltyLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6dX0pO3ZhciB1O3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2dldDooKT0+KChlLG4sbyxpLGEscyk9Pntjb25zdCB1PW8uZGltcyxsPWkuZGltcyxjPWEubGVuZ3RoLHA9KDAsdC5jYWxjdWxhdGVJbTJDb2xEaW1zKSh1LGwsYSw0KSxkPWBcXG4gICAgICAgIGNvbnN0IGludCBYQyA9ICR7dVsxXX07XFxuICAgICAgICBjb25zdCBpbnQgWEggPSAke3VbMl19O1xcbiAgICAgICAgY29uc3QgaW50IFhXID0gJHt1WzNdfTtcXG4gICAgICAgIGNvbnN0IGludCBLSCA9ICR7cy5rZXJuZWxTaGFwZVswXX07XFxuICAgICAgICBjb25zdCBpbnQgS1cgPSAke3Mua2VybmVsU2hhcGVbMV19O1xcbiAgICAgICAgY29uc3QgaW50IGRpbGF0aW9uSCA9ICR7cy5kaWxhdGlvbnNbMF19O1xcbiAgICAgICAgY29uc3QgaW50IGRpbGF0aW9uVyA9ICR7cy5kaWxhdGlvbnNbMV19O1xcbiAgICAgICAgY29uc3QgaW50IHN0cmlkZUggPSAke3Muc3RyaWRlc1swXX07XFxuICAgICAgICBjb25zdCBpbnQgc3RyaWRlVyA9ICR7cy5zdHJpZGVzWzFdfTtcXG4gICAgICAgIGNvbnN0IGludCBwYWRIID0gJHtzLnBhZHNbMF19O1xcbiAgICAgICAgY29uc3QgaW50IHBhZFcgPSAke3MucGFkc1sxXX07XFxuICAgICAgICBjb25zdCBpbnQgS0hLVyA9IEtIKktXO1xcbiAgICAgICAgY29uc3QgaW50IFhDS0hLVyA9IFhDICogS0hLVztcXG4gICAgICAgIGNvbnN0IGludCBvdXRwdXRDaGFubmVscyA9IDQ7XFxuICAgICAgICB2ZWM0IHByb2Nlc3MoaW50IGluZGljZXNbJHtjfV0pIHtcXG4gICAgICAgICAgaW50IGIgID0gaW5kaWNlc1swXTsgLy8gYmF0Y2ggc2l6ZVxcbiAgICAgICAgICBpbnQgb2ggPSBpbmRpY2VzWzFdICogc3RyaWRlSCAtIHBhZEg7IC8vb3V0cHV0IGhlaWdodFxcbiAgICAgICAgICBpbnQgb3cgPSBpbmRpY2VzWzJdICogc3RyaWRlVyAtIHBhZFc7IC8vb3V0cHV0IHdpZHRoXFxuICAgICAgICAgIGludCBwID0gaW5kaWNlc1szXSAqIG91dHB1dENoYW5uZWxzOyAvL3BhdGNoXFxuICAgICAgICAgIHZlYzQgdmFsdWUgPSB2ZWM0KDAuMCk7XFxuICAgICAgICAgIGZvcihpbnQgaT0wOyBpIDwgb3V0cHV0Q2hhbm5lbHM7ICsraSkge1xcbiAgICAgICAgICAgIGlmKHAgPCBYQ0tIS1cpIHtcXG4gICAgICAgICAgICAgIGludCBwYXRjaEMgPSBwIC8gS0hLVztcXG4gICAgICAgICAgICAgIGludCBwYXRjaEggPSAocCAtIHBhdGNoQypLSEtXKSAvIEtXO1xcbiAgICAgICAgICAgICAgaW50IHBhdGNoVyA9IChwIC0gcGF0Y2hDKktIS1cpIC0gcGF0Y2hIICogS1c7XFxuICAgICAgICAgICAgICBpbnQgeGgyID0gb2ggKyBwYXRjaEggKiBkaWxhdGlvbkg7XFxuICAgICAgICAgICAgICBpbnQgeHcyID0gb3cgKyBwYXRjaFcgKiBkaWxhdGlvblc7XFxuICAgICAgICAgICAgICBpbnQgeFske3UubGVuZ3RofV07XFxuICAgICAgICAgICAgICB4WzBdID0gYjtcXG4gICAgICAgICAgICAgIHhbMV0gPSBwYXRjaEM7XFxuICAgICAgICAgICAgICB4WzJdID0geGgyO1xcbiAgICAgICAgICAgICAgeFszXSA9IHh3MjtcXG4gICAgICAgICAgICAgIGlmKHhoMiA+PSAwICYmXFxuICAgICAgICAgICAgICAgICAgeGgyIDwgWEggJiZcXG4gICAgICAgICAgICAgICAgICB4dzIgPj0gMCAmJlxcbiAgICAgICAgICAgICAgICAgIHh3MiA8IFhXKSB7XFxuICAgICAgICAgICAgICAgIHZhbHVlW2ldID0gX1goeCk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICsrcDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpwLHR5cGU6by50eXBlLHRleHR1cmVUeXBlOnIuVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbn0sc2hhZGVyU291cmNlOmR9KX0pKDAscyxuLG8saSxhKX0pfSx0LmNhbGN1bGF0ZUltMkNvbERpbXM9KGUsdCxuLHI9NCk9PltuWzBdLG5bMl0sblszXSxNYXRoLmNlaWwoZVsxXSp0WzJdKnRbM10vcildfSw2OTgxOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzPXQuaW1hZ2VTY2FsZXI9dm9pZCAwO2NvbnN0IHI9big0OTEwKSxvPW4oNTYzOSk7dC5pbWFnZVNjYWxlcj0oZSx0LG4pPT4odSh0KSxbZS5ydW4oYShlLHQsbiksdCldKSx0LnBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzPWU9Pntjb25zdCB0PWUuYXR0cmlidXRlcy5nZXRGbG9hdChcInNjYWxlXCIpLG49ZS5hdHRyaWJ1dGVzLmdldEZsb2F0cyhcImJpYXNcIik7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtzY2FsZTp0LGJpYXM6bn0pfTtjb25zdCBpPXtuYW1lOlwiSW1hZ2VTY2FsZXJcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19LGE9KGUsdCxuKT0+e2NvbnN0IHI9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGkpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleX0pO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+KChlLHQsbixyKT0+e2NvbnN0IGk9blswXS5kaW1zLnNsaWNlKCksYT1pLmxlbmd0aCx1PWBcXG4gICAgICAke3Moci5iaWFzLmxlbmd0aCl9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2F9XSkge1xcbiAgICAgICAgcmV0dXJuIF9YKGluZGljZXMpICogc2NhbGUgKyBnZXRCaWFzKGJpYXMsIGluZGljZXNbMV0pO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dDp7ZGltczppLHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHZhcmlhYmxlczpbe25hbWU6XCJiaWFzXCIsdHlwZTpcImZsb2F0XCIsYXJyYXlMZW5ndGg6ci5iaWFzLmxlbmd0aCxkYXRhOnIuYmlhc30se25hbWU6XCJzY2FsZVwiLHR5cGU6XCJmbG9hdFwiLGRhdGE6ci5zY2FsZX1dLHNoYWRlclNvdXJjZTp1fSl9KSgwLHIsdCxuKX0pfSxzPWU9Pntjb25zdCB0PVtgZmxvYXQgZ2V0QmlhcyhmbG9hdCBiaWFzWyR7ZX1dLCBpbnQgY2hhbm5lbCkge2BdO2ZvcihsZXQgbj0wO248ZTsrK24pMD09PW4/dC5wdXNoKGBcXHRpZiAoY2hhbm5lbCA9PSAke259KSB7IHJldHVybiBiaWFzWyR7bn1dOyB9YCk6bj09PWUtMT90LnB1c2goYFxcdGVsc2UgeyByZXR1cm4gYmlhc1ske259XTsgfWApOnQucHVzaChgXFx0ZWxzZSBpZiAoY2hhbm5lbCA9PSAke259KSB7IHJldHVybiBiaWFzWyR7bn1dOyB9YCk7cmV0dXJuIHQucHVzaChcIlxcdH1cIiksdC5qb2luKFwiXFxuXCIpfSx1PWU9PntpZighZXx8MSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkltYWdlU2NhbGVyIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKDQhPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKFwiZmxvYXQzMlwiIT09ZVswXS50eXBlJiZcImZsb2F0NjRcIiE9PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0sNzQxMzooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZUluc3RhbmNlTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM9dC5pbnN0YW5jZU5vcm1hbGl6YXRpb249dm9pZCAwO2NvbnN0IHI9big2NzU3KSxvPW4oNTYzOSk7dC5pbnN0YW5jZU5vcm1hbGl6YXRpb249KGUsdCxuKT0+e2wodCk7Y29uc3Qgcj1lLnJ1bihhKHRbMF0pLHQpO3JldHVybltlLnJ1bih1KGUsdFswXSxuLHIuZGltcyksW3RbMF0scix0WzFdLHRbMl1dKV19LHQucGFyc2VJbnN0YW5jZU5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzPWU9PmUuYXR0cmlidXRlcy5nZXRGbG9hdChcImVwc2lsb25cIiwxZS01KTtjb25zdCBpPXtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uX01lYW5BbmRWYXJpYW5jZVwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnVucGFja2VkXX0sYT1lPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30saSkse2dldDooKT0+KChlLHQpPT57Y29uc3Qgbj10LmRpbXMuc2xpY2UoKSxyPW5bMV0saT1uWzJdKm5bM10sYT1bblswXSxyXSxzPWBcXG4gICAgICB2ZWM0IHByb2Nlc3MoaW50WzJdIGluZGljZXMpIHtcXG4gICAgICAgIHZlYzQgdiA9IHZlYzQoMC4wKTtcXG4gICAgICAgIGludCBhWzRdO1xcbiAgICAgICAgYVswXSA9IGluZGljZXNbMF07XFxuICAgICAgICBhWzFdID0gaW5kaWNlc1sxXTtcXG4gICAgICAgIGZsb2F0IHRlbXAgPSAwLjA7XFxuICAgICAgICBmb3IoaW50IGEyPTA7IGEyPCR7blsyXX07IGEyKyspIHtcXG4gICAgICAgICAgYVsyXSA9IGEyO1xcbiAgICAgICAgICBmb3IoaW50IGEzPTA7IGEzPCR7blszXX07IGEzKyspIHtcXG4gICAgICAgICAgICBhWzNdID0gYTM7XFxuICAgICAgICAgICAgZmxvYXQgeCA9IF9YKGEpO1xcbiAgICAgICAgICAgIHRlbXAgKz0geDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZmxvYXQgbWVhbiA9IHRlbXAgLyBmbG9hdCgke2l9KTtcXG4gICAgICAgIHRlbXAgPSAwLjA7XFxuICAgICAgICBmb3IoaW50IGEyPTA7IGEyPCR7blsyXX07IGEyKyspIHtcXG4gICAgICAgICAgYVsyXSA9IGEyO1xcbiAgICAgICAgICBmb3IoaW50IGEzPTA7IGEzPCR7blszXX07IGEzKyspIHtcXG4gICAgICAgICAgICBhWzNdID0gYTM7XFxuICAgICAgICAgICAgZmxvYXQgeCA9IF9YKGEpO1xcbiAgICAgICAgICAgIHRlbXAgKz0gKHggLSBtZWFuKSAqICh4IC0gbWVhbik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHYuciA9IG1lYW47XFxuICAgICAgICB2LmcgPSB0ZW1wIC8gZmxvYXQoJHtpfSk7XFxuXFxuICAgICAgICByZXR1cm4gdjtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6YSx0eXBlOnQudHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb259LHNoYWRlclNvdXJjZTpzfSl9KShpLGUpfSkscz17bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvbl9Db21wdXRlT3V0cHV0XCIsaW5wdXROYW1lczpbXCJYXCIsXCJNZWFuQW5kVmFyaWFuY2VcIixcIlNjYWxlXCIsXCJCXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uLG8uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZF19LHU9KGUsdCxuLGkpPT57Y29uc3QgYT1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2NhY2hlSGludDpgJHtufWB9KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtnZXQ6KCk9PigoZSx0LG4saSxhKT0+e2NvbnN0IHM9KDAsci5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksW3UsbF09ZS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoYSxvLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24pLFtjLHBdPVt1LzQsbF0sZD1gXFxuICAgICAgdmVjNCBnZXRfTWVhbkFuZFZhcmlhbmNlKGludFsyXSBtdikge1xcbiAgICAgICAgaW50IG9mZnNldCA9IGluZGljZXNUb09mZnNldF9NZWFuQW5kVmFyaWFuY2UobXYpO1xcbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7Y30sICR7cH0pO1xcbiAgICAgICAgcmV0dXJuICR7cy50ZXh0dXJlMkR9KE1lYW5BbmRWYXJpYW5jZSwgY29vcmRzKTtcXG4gICAgICB9XFxuXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbNF0gaW5kaWNlcykge1xcbiAgICAgICAgaW50IG12WzJdO1xcbiAgICAgICAgbXZbMF0gPSBpbmRpY2VzWzBdO1xcbiAgICAgICAgbXZbMV0gPSBpbmRpY2VzWzFdO1xcbiAgICAgICAgdmVjNCBtZWFuX2FuZF92YXJpYW5jZSA9IGdldF9NZWFuQW5kVmFyaWFuY2UobXYpO1xcbiAgICAgICAgZmxvYXQgbWVhbiA9IG1lYW5fYW5kX3ZhcmlhbmNlLnI7XFxuICAgICAgICBmbG9hdCB2YXJpYW5jZSA9IG1lYW5fYW5kX3ZhcmlhbmNlLmc7XFxuXFxuICAgICAgICBpbnQgc2JbMV07XFxuICAgICAgICBzYlswXSA9IGluZGljZXNbMV07XFxuICAgICAgICBmbG9hdCBzY2FsZSA9IF9TY2FsZShzYik7XFxuICAgICAgICBmbG9hdCBiID0gX0Ioc2IpO1xcblxcbiAgICAgICAgcmV0dXJuIHNjYWxlICogKF9YKGluZGljZXMpIC0gbWVhbikgLyBzcXJ0KHZhcmlhbmNlICsgZXBzaWxvbikgKyBiO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dDp7ZGltczpuLmRpbXMsdHlwZTpuLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sdmFyaWFibGVzOlt7bmFtZTpcImVwc2lsb25cIix0eXBlOlwiZmxvYXRcIixkYXRhOml9XSxzaGFkZXJTb3VyY2U6ZH0pfSkoZSxhLHQsbixpKX0pfSxsPWU9PntpZighZXx8MyE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkluc3RhbmNlTm9ybWFsaXphdGlvbiByZXF1aXJlcyAzIGlucHV0cy5cIik7Y29uc3QgdD1lWzBdLG49ZVsxXSxyPWVbMl07aWYodC5kaW1zLmxlbmd0aDwzfHwxIT09bi5kaW1zLmxlbmd0aHx8MSE9PXIuZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYobi5kaW1zWzBdIT09dC5kaW1zWzFdfHxyLmRpbXNbMF0hPT10LmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc2hhcGVzIGFyZSBtaXNtYXRjaGVkLlwiKTtpZihcImZsb2F0MzJcIiE9PXQudHlwZSYmXCJmbG9hdDY0XCIhPT10LnR5cGV8fFwiZmxvYXQzMlwiIT09bi50eXBlJiZcImZsb2F0NjRcIiE9PW4udHlwZXx8XCJmbG9hdDMyXCIhPT1yLnR5cGUmJlwiZmxvYXQ2NFwiIT09ci50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoNCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiT25seSBzdXBwb3J0IDQtRCBpbnB1dCBzaGFwZS5cIil9fSw3MDA2OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNyZWF0ZUxyblByb2dyYW1JbmZvTG9hZGVyPXQucGFyc2VMcm5BdHRyaWJ1dGVzPXQubHJuPXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDU2MzkpO3QubHJuPShlLHQsbik9PihzKHQpLFtlLnJ1bihhKHQsbiksdCldKSx0LnBhcnNlTHJuQXR0cmlidXRlcz1lPT57Y29uc3QgdD1lLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJhbHBoYVwiLDFlLTQpLG49ZS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiYmV0YVwiLC43NSksbz1lLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJiaWFzXCIsMSksaT1lLmF0dHJpYnV0ZXMuZ2V0SW50KFwic2l6ZVwiKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2FscGhhOnQsYmV0YTpuLGJpYXM6byxzaXplOml9KX07Y29uc3QgaT17bmFtZTpcIkxSTlwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnVucGFja2VkXX07ZnVuY3Rpb24gYShlLHQpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30saSkse2NhY2hlSGludDp0LmNhY2hlS2V5LGdldDooKT0+ZnVuY3Rpb24oZSx0KXtjb25zdCBuPWVbMF0uZGltc1sxXSxyPWVbMF0uZGltcy5sZW5ndGgsYT0tTWF0aC5mbG9vcigodC5zaXplLTEpLzIpLHM9TWF0aC5jZWlsKCh0LnNpemUtMSkvMiksdT1gZmxvYXQoJHt0LmFscGhhfSkgLyBmbG9hdCgke3Quc2l6ZX0pYCxsPWBcXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3J9XSkge1xcbiAgICAgICAgaW50IGMgPSBpbmRpY2VzWzFdO1xcbiAgICAgICAgZmxvYXQgeCA9IF9YKGluZGljZXMpO1xcbiAgICAgICAgZmxvYXQgc3F1YXJlX3N1bSA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAke2F9OyBpIDw9ICR7c307IGkrKykge1xcbiAgICAgICAgICBpbnQgaWR4ID0gYyArIGk7XFxuICAgICAgICAgIGlmIChjID49IDAgJiYgYyA8ICR7bn0pIHtcXG4gICAgICAgICAgICBpbmRpY2VzWzFdID0gaWR4O1xcbiAgICAgICAgICAgIGZsb2F0IGogPSBfWChpbmRpY2VzKTtcXG4gICAgICAgICAgICBzcXVhcmVfc3VtICs9IGogKiBqO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4geCAvIHBvdyhmbG9hdCgke3QuYmlhc30pICsgJHt1fSAqIHNxdWFyZV9zdW0sIGZsb2F0KCR7dC5iZXRhfSkpO1xcbiAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGkpLHtjYWNoZUhpbnQ6dC5jYWNoZUtleSxvdXRwdXQ6e2RpbXM6ZVswXS5kaW1zLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpsfSl9KGUsdCl9KX10LmNyZWF0ZUxyblByb2dyYW1JbmZvTG9hZGVyPWE7Y29uc3Qgcz1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJMUk4gcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoNCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgb25seSBzdXBwb3J0IExSTiBmb3IgaW5wdXQgd2l0aCBcIk5DSFdcIiBmb3JtYXQnKTtpZihcImZsb2F0MzJcIiE9PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgYmUgZmxvYXQgdHlwZVwiKX19LDU2MzI6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9big3MjczKSxvPW4oNjc1NyksaT1uKDU2MzkpLGE9big0MzIpLHM9bigyMTUwKSx1PW4oODI3Nik7dC5jcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcj0oZSx0LG4pPT57Y29uc3QgbD0oYz10Lmxlbmd0aD4yLHA9bi5hY3RpdmF0aW9uQ2FjaGVLZXkse25hbWU6XCJNYXRNdWwgKHBhY2tlZClcIixpbnB1dE5hbWVzOmM/W1wiQVwiLFwiQlwiLFwiQmlhc1wiXTpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6Yz9baS5UZXh0dXJlVHlwZS5wYWNrZWQsaS5UZXh0dXJlVHlwZS5wYWNrZWQsaS5UZXh0dXJlVHlwZS5wYWNrZWRdOltpLlRleHR1cmVUeXBlLnBhY2tlZCxpLlRleHR1cmVUeXBlLnBhY2tlZF0sY2FjaGVIaW50OnB9KTt2YXIgYyxwO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbCkse2dldDooKT0+KChlLHQsbixsKT0+e2NvbnN0IGM9bi5sZW5ndGg+MixwPWM/XCJ2YWx1ZSArPSBnZXRCaWFzRm9yTWF0bXVsKCk7XCI6XCJcIixkPW5bMF0uZGltcyxmPW5bMV0uZGltcyxoPXIuQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoZCxmLCEwKSxnPSFyLlNoYXBlVXRpbC5hcmVFcXVhbChuWzBdLmRpbXMsblsxXS5kaW1zKTtpZighaCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2NvbnN0IG09ZFtkLmxlbmd0aC0xXSxiPU1hdGguY2VpbChtLzIpLHk9ZC5sZW5ndGgsdz1mLmxlbmd0aCxfPSgwLG8uZ2V0R2xzbCkoZS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLHY9KDAsYS5nZXRDb29yZHNEYXRhVHlwZSkoaC5sZW5ndGgpLHg9aC5sZW5ndGgsVD0oMCxhLmdldEdsQ2hhbm5lbHMpKCkse2FjdGl2YXRpb25GdW5jdGlvbjpTLGFwcGx5QWN0aXZhdGlvbjpPfT0oMCxzLmdldEFjdGl2YXRpb25TbmlwcGV0KShsKSxBPWM/YCR7KDAsdS5nZXRCaWFzRm9yTWF0bXVsKSh2LFQsblsyXS5kaW1zLGgsITApfWA6XCJcIixFPWc/YCR7ZnVuY3Rpb24oZSx0LG4sbyl7bGV0IGk9W10sYT1bXTtjb25zdCBzPW5bMF0uZGltcyx1PW5bMV0uZGltcyxsPXMubGVuZ3RoLGM9dS5sZW5ndGgscD1vLmxlbmd0aCxkPXAtbCxmPXAtYztpPXMubWFwKCgoZSxuKT0+YGNvb3Jkcy4ke3RbbitkXX1gKSksaVtsLTFdPVwiaSoyXCIsaS5qb2luKFwiLCBcIiksYT11Lm1hcCgoKGUsbik9PmBjb29yZHMuJHt0W24rZl19YCkpLGFbYy0yXT1cImkqMlwiLGEuam9pbihcIiwgXCIpO2NvbnN0IGg9ci5Ccm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXMocyxvKSxnPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKHUsbyksbT1oLm1hcCgoZT0+YGNvb3Jkcy4ke3RbZStkXX0gPSAwO2ApKS5qb2luKFwiXFxuXCIpLGI9Zy5tYXAoKGU9PmBjb29yZHMuJHt0W2UrZl19ID0gMDtgKSkuam9pbihcIlxcblwiKSx5PWBpbnQgbGFzdERpbSA9IGNvb3Jkcy4ke3RbcC0xXX07XFxuICBjb29yZHMuJHt0W3AtMV19ID0gY29vcmRzLiR7dFtwLTJdfTtcXG4gIGNvb3Jkcy4ke3RbcC0yXX0gPSBsYXN0RGltO2A7cmV0dXJuYFxcbnZlYzQgZ2V0QUF0T3V0Q29vcmRzTWF0bXVsKGludCBpKSB7XFxuICAke2V9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgJHt5fVxcbiAgJHttfVxcbiAgdmVjNCBvdXRwdXRWYWx1ZSA9IGdldEEoJHtpfSk7XFxuICByZXR1cm4gb3V0cHV0VmFsdWU7XFxufVxcblxcbnZlYzQgZ2V0QkF0T3V0Q29vcmRzTWF0bXVsKGludCBpKSB7XFxuICAke2V9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgJHt5fVxcbiAgJHtifVxcbiAgdmVjNCBvdXRwdXRWYWx1ZSA9IGdldEIoJHthfSk7XFxuICByZXR1cm4gb3V0cHV0VmFsdWU7XFxufWB9KHYsVCxuLGgpfWA6XCJcIixJPWc/XCJnZXRBQXRPdXRDb29yZHNNYXRtdWwoaSlcIjpgZ2V0QSgke2Z1bmN0aW9uKGUsdCl7bGV0IG49XCJcIjtmb3IobGV0IHI9MDtyPHQtMjtyKyspbis9YHJjLiR7ZVtyXX0sIGA7cmV0dXJuIG4rPWByYy4ke2VbdC0yXX0sIGkqMmAsbn0oVCx5KX0pYCwkPWc/XCJnZXRCQXRPdXRDb29yZHNNYXRtdWwoaSlcIjpgZ2V0Qigke2Z1bmN0aW9uKGUsdCl7bGV0IG49XCJcIjtmb3IobGV0IHI9MDtyPHQtMjtyKyspbis9YHJjLiR7ZVtyXX0sIGA7cmV0dXJuIG4rPWBpKjIsIHJjLiR7ZVt0LTFdfWAsbn0oVCx3KX0pYCxQPWBcXG4gICAgICAgICAgICAke0V9XFxuICAgICAgICAgICAgJHtBfVxcbiAgICAgICAgICAgICR7U31cXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICAgICAke2c/XCJcIjpgJHt2fSByYyA9XFxuICAgICAgICAgIGdldE91dHB1dENvb3JkcygpOyBpbnQgbGFzdERpbSA9IHJjLiR7VFt4LTFdfTsgcmMuJHtUW3gtMV19ID1cXG4gICAgICAgICAgcmMuJHtUW3gtMl19OyByYy4ke1RbeC0yXX0gPSBsYXN0RGltO1xcbiAgICAgIGB9XFxuXFxuICAgICAgICAgICAgICB2ZWM0IHZhbHVlID0gdmVjNCgwKTtcXG4gICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtifTsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIHZlYzQgYSA9ICR7SX07XFxuICAgICAgICAgICAgICAgIHZlYzQgYiA9ICR7JH07XFxuXFxuICAgICAgICAgICAgICAgIHZhbHVlICs9IChhLnJyYmIgKiBiLnJncmcpO1xcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAoYS5nZ2FhICogYi5iYWJhKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICR7cH1cXG4gICAgICAgICAgICAgICR7T31cXG4gICAgICAgICAgICAgICR7Xy5vdXRwdXR9ID0gdmFsdWU7XFxuICAgICAgICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7b3V0cHV0OntkaW1zOmgsdHlwZTpuWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS5wYWNrZWR9LHNoYWRlclNvdXJjZTpQLGhhc01haW46ITB9KX0pKGUsbCx0LG4pfSl9fSw4Mjc2OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldEJpYXNGb3JNYXRtdWw9dC5jcmVhdGVNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcj10LnBhcnNlTWF0TXVsQXR0cmlidXRlcz10Lm1hdE11bD12b2lkIDA7Y29uc3Qgcj1uKDcyNzMpLG89big1NjM5KSxpPW4oNDMyKSxhPW4oMjE1MCkscz1uKDU2MzIpO3QubWF0TXVsPShlLHQsbik9PihjKHQpLGUuc2Vzc2lvbi5wYWNrP1tlLnJ1bigoMCxzLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKShlLHQsbiksdCldOltlLnJ1bihsKHQsbiksdCldKSx0LnBhcnNlTWF0TXVsQXR0cmlidXRlcz1lPT4oMCxhLnBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcykoZS5hdHRyaWJ1dGVzKTtjb25zdCB1PShlLHQpPT4oe25hbWU6XCJNYXRNdWxcIixpbnB1dE5hbWVzOmU/W1wiQVwiLFwiQlwiLFwiQmlhc1wiXTpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6ZT9bby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdOltvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDp0fSk7ZnVuY3Rpb24gbChlLHQpe2NvbnN0IG49dShlLmxlbmd0aD4yLHQuYWN0aXZhdGlvbkNhY2hlS2V5KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtnZXQ6KCk9PmZ1bmN0aW9uKGUsdCxuKXtjb25zdCBzPXRbMF0uZGltcyx1PXRbMV0uZGltcyxsPXIuQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUocyx1LCEwKTtpZighbCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2NvbnN0IGM9KDAsaS5nZXRDb29yZHNEYXRhVHlwZSkobC5sZW5ndGgpLGQ9KDAsaS5nZXRHbENoYW5uZWxzKSgpLHthY3RpdmF0aW9uRnVuY3Rpb246ZixhcHBseUFjdGl2YXRpb246aH09KDAsYS5nZXRBY3RpdmF0aW9uU25pcHBldCkobiksZz10Lmxlbmd0aD4yLG09Zz9cInZhbHVlICs9IGdldEJpYXNGb3JNYXRtdWwoKTtcIjpcIlwiLGI9Zz9gJHtwKGMsZCx0WzJdLmRpbXMsbCwhMSl9YDpcIlwiLHk9bC5sZW5ndGgsdz1zLmxlbmd0aCxfPXUubGVuZ3RoLHY9YFxcbiAgICAke2Z9XFxuICAgICR7Yn1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3l9XSkge1xcbiAgICAgICAgaW50IGFbJHt3fV07XFxuICAgICAgICBpbnQgYlske199XTtcXG4gICAgICAgIGJjYXN0TWF0bXVsSW5kaWNlc19BKGluZGljZXMsIGEpO1xcbiAgICAgICAgYmNhc3RNYXRtdWxJbmRpY2VzX0IoaW5kaWNlcywgYik7XFxuXFxuICAgICAgICBmbG9hdCB2YWx1ZTtcXG4gICAgICAgIGZvciAoaW50IGs9MDsgazwke3Nbcy5sZW5ndGgtMV19OyArK2spIHtcXG4gICAgICAgICAgICBhWyR7dy0xfV0gPSBrO1xcbiAgICAgICAgICAgIGJbJHtfLTJ9XSA9IGs7XFxuICAgICAgICAgICAgdmFsdWUgKz0gX0EoYSkgKiBfQihiKTtcXG4gICAgICAgIH1cXG4gICAgICAgICR7bX1cXG4gICAgICAgICR7aH1cXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOmwsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnZ9KX0obixlLHQpfSl9dC5jcmVhdGVNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcj1sO2NvbnN0IGM9ZT0+e2lmKCFlfHwyIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTWF0TXVsIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRpbXNbZVswXS5kaW1zLmxlbmd0aC0xXSE9PWVbMV0uZGltc1tlWzFdLmRpbXMubGVuZ3RoLTJdKXRocm93IG5ldyBFcnJvcihcInNoYXJlZCBkaW1lbnNpb24gZG9lcyBub3QgbWF0Y2guXCIpO2lmKFwiZmxvYXQzMlwiIT09ZVswXS50eXBlJiZcImZsb2F0NjRcIiE9PWVbMF0udHlwZXx8XCJmbG9hdDMyXCIhPT1lWzFdLnR5cGUmJlwiZmxvYXQ2NFwiIT09ZVsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcImlucHV0cyBzaG91bGQgYmUgZmxvYXQgdHlwZVwiKTtpZihlWzBdLnR5cGUhPT1lWzFdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRzIHR5cGVzIHNob3VsZCBtYXRjaFwiKX07ZnVuY3Rpb24gcChlLHQsbixvLGkpe2xldCBhPVwiXCI7Y29uc3Qgcz1uLmxlbmd0aCx1PW8ubGVuZ3RoLGw9dS1zO2E9dTwyJiZzPjA/XCJjb29yZHNcIjpuLm1hcCgoKGUsbik9PmBjb29yZHMuJHt0W24rbF19YCkpLmpvaW4oXCIsIFwiKTtjb25zdCBjPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKG4sbykubWFwKChlPT5gY29vcmRzLiR7dFtlK2xdfSA9IDA7YCkpLmpvaW4oXCJcXG5cIik7bGV0IHA9XCJ2ZWM0KG91dHB1dFZhbHVlLnh4LCBvdXRwdXRWYWx1ZS55eSlcIjtyZXR1cm4gMT09PXIuU2hhcGVVdGlsLnNpemUobikmJihwPVwidmVjNChvdXRwdXRWYWx1ZS54KVwiKSxpP2BcXG52ZWM0IGdldEJpYXNGb3JNYXRtdWwoKSB7XFxuICAke2V9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgJHtjfVxcbiAgdmVjNCBvdXRwdXRWYWx1ZSA9IGdldEJpYXMoJHthfSk7XFxuICByZXR1cm4gJHtwfTtcXG59YDpgXFxuZmxvYXQgZ2V0Qmlhc0Zvck1hdG11bCgpIHtcXG4gICR7ZX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAke2N9XFxuICByZXR1cm4gZ2V0Qmlhcyhjb29yZHMueCk7XFxufWB9dC5nZXRCaWFzRm9yTWF0bXVsPXB9LDk6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlUGFja1Byb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNjc1Nyksbz1uKDU2MzkpLGk9big0MzIpLGE9big1NjE0KSxzPXtuYW1lOlwicGFja1wiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnVucGFja2VkUmV2ZXJzZWRdfTt0LmNyZWF0ZVBhY2tQcm9ncmFtSW5mb0xvYWRlcj0oZSx0KT0+T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtnZXQ6KCk9PigoZSx0KT0+e2NvbnN0IG49KDAsci5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksdT10LmRpbXMsbD11Lmxlbmd0aCxjPXQuZGltcy5sZW5ndGgscD0oMCxpLmdldENvb3Jkc0RhdGFUeXBlKShjKSxkPSgwLGEuZ2V0Q2hhbm5lbHMpKFwicmNcIixjKSxmPShoPWMsZz1kLG09dVt1Lmxlbmd0aC0yXSxiPXVbdS5sZW5ndGgtMV0sMD09PWh8fDE9PT1oP1wiXCI6YFxcbiAgICBpbnQgciA9ICR7Z1toLTJdfTtcXG4gICAgaW50IGMgPSAke2dbaC0xXX07XFxuICAgIGludCBycDEgPSAke2dbaC0yXX0gKyAxO1xcbiAgICBpbnQgY3AxID0gJHtnW2gtMV19ICsgMTtcXG4gICAgYm9vbCByRWRnZSA9IHJwMSA+PSAke2J9O1xcbiAgICBib29sIGNFZGdlID0gY3AxID49ICR7bX07XFxuICAgIGApO3ZhciBoLGcsbSxiO2xldCB5O3k9MD09PWw/WzEsMV06MT09PWw/W3VbMF0sMV06W3VbYy0xXSx1W2MtMl1dO2NvbnN0IHc9ZnVuY3Rpb24oZSx0LG4pe2lmKDA9PT1lKXJldHVyblwiZmFsc2VcIjtpZigxPT09ZSlyZXR1cm5gcmMgPiAke3RbMF19YDtsZXQgcj1cIlwiO2ZvcihsZXQgbz1lLTI7bzxlO28rKylyKz1gJHtuW29dfSA+PSAke3Rbby1lKzJdfWAsbzxlLTEmJihyKz1cInx8XCIpO3JldHVybiByfShjLHksZCksXz1mdW5jdGlvbihlLHQpe2NvbnN0IG49ZS5sZW5ndGg7aWYoMD09PW4pcmV0dXJuXCJnZXRBKCksIDAsIDAsIDBcIjtpZigxPT09bilyZXR1cm5gZ2V0QShyYyksXFxuICAgICAgICAgICAgcmMgKyAxID49ICR7ZVswXX0gPyAwLiA6IGdldEEocmMgKyAxKSxcXG4gICAgICAgICAgICAwLCAwYDtsZXQgcj1cIlwiO2lmKG4+Milmb3IobGV0IGU9MDtlPG4tMjsrK2Upcis9YCR7dFtlXX0sYDtyZXR1cm5gZ2V0QSgke3J9ciwgYyksXFxuICAgICAgICAgIHJFZGdlID8gMC4gOiBnZXRBKCR7cn1ycDEsIGMpLFxcbiAgICAgICAgICBjRWRnZSA/IDAuIDogZ2V0QSgke3J9ciwgY3AxKSxcXG4gICAgICAgICAgckVkZ2UgfHwgY0VkZ2UgPyAwLiA6IGdldEEoJHtyfXJwMSwgY3AxKWB9KHUsZCksdj1gXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICR7cH0gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgICAgaWYoJHt3fSkge1xcbiAgICAgICAgICAgICR7bi5vdXRwdXR9ID0gdmVjNCgwKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAke2Z9XFxuXFxuICAgICAgICAgICAgJHtuLm91dHB1dH0gPSB2ZWM0KCR7X30pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtoYXNNYWluOiEwLG91dHB1dDp7ZGltczp0LmRpbXMsdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS5wYWNrZWR9LHNoYWRlclNvdXJjZTp2fSl9KShlLHQpfSl9LDU2MTQ6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQudW5wYWNrRnJvbUNoYW5uZWw9dC5nZXRDaGFubmVscz10LmdldFZlY0NoYW5uZWxzPXZvaWQgMDtjb25zdCByPW4oNDMyKTtmdW5jdGlvbiBvKGUsdCl7cmV0dXJuKDAsci5nZXRHbENoYW5uZWxzKSh0KS5tYXAoKHQ9PmAke2V9LiR7dH1gKSl9dC5nZXRWZWNDaGFubmVscz1vLHQuZ2V0Q2hhbm5lbHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMT09PXQ/W2VdOm8oZSx0KX0sdC51bnBhY2tGcm9tQ2hhbm5lbD1mdW5jdGlvbigpe3JldHVyblwiXFxuICAgIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCBpbnQgZGltKSB7XFxuICAgICAgaW50IG1vZENvb3JkID0gaW1vZChkaW0sIDIpO1xcbiAgICAgIHJldHVybiBtb2RDb29yZCA9PSAwID8gZnJhZy5yIDogZnJhZy5nO1xcbiAgICB9XFxuXFxuICAgIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCB2ZWMyIGlubmVyRGltcykge1xcbiAgICAgIHZlYzIgbW9kQ29vcmQgPSBtb2QoaW5uZXJEaW1zLCAyLik7XFxuICAgICAgcmV0dXJuIG1vZENvb3JkLnggPT0gMC4gP1xcbiAgICAgICAgKG1vZENvb3JkLnkgPT0gMC4gPyBmcmFnLnIgOiBmcmFnLmcpIDpcXG4gICAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5iIDogZnJhZy5hKTtcXG4gICAgfVxcbiAgXCJ9fSw1NTY1OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlUGFkQXR0cmlidXRlc1YxMT10LnBhZFYxMT10LnBhcnNlUGFkQXR0cmlidXRlc1YyPXQucGFkVjI9dm9pZCAwO2NvbnN0IHI9big0OTEwKSxvPW4oNzI3MyksaT1uKDY3NTcpLGE9big1NjM5KSxzPXtuYW1lOlwiUGFkXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2EuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTt0LnBhZFYyPShlLHQsbik9PihjKHQpLFtlLnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+bChlLHRbMF0sbil9KSx0KV0pLHQucGFyc2VQYWRBdHRyaWJ1dGVzVjI9ZT0+e2NvbnN0IHQ9ZS5hdHRyaWJ1dGVzLmdldFN0cmluZyhcIm1vZGVcIixcImNvbnN0YW50XCIpLG49ZS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwidmFsdWVcIiwwKSxvPWUuYXR0cmlidXRlcy5nZXRJbnRzKFwicGFkc1wiKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe21vZGU6dCx2YWx1ZTpuLHBhZHM6b30pfSx0LnBhZFYxMT0oZSxuLHIpPT57cChuKTtjb25zdCBvPXUoZSxuLHIpO3JldHVybigwLHQucGFkVjIpKGUsW25bMF1dLG8pfSx0LnBhcnNlUGFkQXR0cmlidXRlc1YxMT1lPT5lLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwibW9kZVwiLFwiY29uc3RhbnRcIik7Y29uc3QgdT0oZSx0LG4pPT57aWYoIWUuc2Vzc2lvbi5pc0luaXRpYWxpemVyKHRbMV0uZGF0YUlkKXx8dC5sZW5ndGg+PTMmJiFlLnNlc3Npb24uaXNJbml0aWFsaXplcih0WzJdLmRhdGFJZCkpdGhyb3cgbmV3IEVycm9yKFwiZHluYW1pYyBwYWQgYXR0cmlidXRlcyBhcmUgbm90IGFsbG93ZWRcIik7Y29uc3Qgbz1BcnJheS5mcm9tKHRbMV0uaW50ZWdlckRhdGEpLGk9dC5sZW5ndGg+PTM/dFsyXS5mbG9hdERhdGFbMF06MDtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe21vZGU6bixwYWRzOm8sdmFsdWU6aX0pfSxsPShlLHQsbik9Pntjb25zdCByPW8uU2hhcGVVdGlsLnBhZFNoYXBlKHQuZGltcy5zbGljZSgpLG4ucGFkcyksaT1yLmxlbmd0aCxzPWBcXG4gICAgICAke2QoZSx0LG4pfVxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7aX1dIGluZGljZXMpIHtcXG4gICAgICAgICAgcmV0dXJuIHBhZEEoaW5kaWNlcyk7XFxuICAgICAgfWA7cmV0dXJue25hbWU6XCJQYWRcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZF0sb3V0cHV0OntkaW1zOnIsdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnN9fSxjPWU9PntpZighZXx8MSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlBhZCByZXF1aXJlcyAxIGlucHV0XCIpO2lmKFwiZmxvYXQzMlwiIT09ZVswXS50eXBlJiZcImZsb2F0NjRcIiE9PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfSxwPWU9PntpZighZXx8MiE9PWUubGVuZ3RoJiYzIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUGFkIHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoXCJpbnQzMlwiIT09ZVsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoZS5sZW5ndGg+PTMmJlwic3RyaW5nXCI9PT1lWzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0sZD0oZSx0LG4pPT57Y29uc3Qgcj0oMCxpLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxbcyx1XT1lLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh0LmRpbXMsYS5UZXh0dXJlVHlwZS51bnBhY2tlZCksbD1vLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyh0LmRpbXMpO3N3aXRjaChuLm1vZGUpe2Nhc2VcImNvbnN0YW50XCI6cmV0dXJuIGYocix0LmRpbXMsbCxzLHUsbi5wYWRzLG4udmFsdWUpO2Nhc2VcInJlZmxlY3RcIjpyZXR1cm4gaChyLHQuZGltcyxsLHMsdSxuLnBhZHMpO2Nhc2VcImVkZ2VcIjpyZXR1cm4gZyhyLHQuZGltcyxsLHMsdSxuLnBhZHMpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlXCIpfX0sZj0oZSx0LG4scixvLGksYSk9Pntjb25zdCBzPXQubGVuZ3RoO2xldCB1PVwiXCI7Zm9yKGxldCBlPXMtMTtlPj0wOy0tZSl1Kz1gXFxuICAgICAgICBrID0gbVske2V9XSAtICR7aVtlXX07XFxuICAgICAgICBpZiAoayA8IDApICByZXR1cm4gY29uc3RhbnQ7XFxuICAgICAgICBpZiAoayA+PSAke3RbZV19KSByZXR1cm4gY29uc3RhbnQ7XFxuICAgICAgICBvZmZzZXQgKz0gayAqICR7bltlXX07XFxuICAgICAgICBgO3JldHVybmBcXG4gICAgICBmbG9hdCBwYWRBKGludCBtWyR7c31dKSB7XFxuICAgICAgICBjb25zdCBmbG9hdCBjb25zdGFudCA9IGZsb2F0KCR7YX0pO1xcbiAgICAgICAgaW50IG9mZnNldCA9IDA7XFxuICAgICAgICBpbnQgayA9IDA7XFxuICAgICAgICAke3V9XFxuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHtyfSwgJHtvfSk7XFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke2UudGV4dHVyZTJEfShBLCBjb29yZHMpKTtcXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9XFxuICAgICAgYH0saD0oZSx0LG4scixvLGkpPT57Y29uc3QgYT10Lmxlbmd0aDtsZXQgcz1cIlwiO2ZvcihsZXQgZT1hLTE7ZT49MDstLWUpcys9YFxcbiAgICAgICAgayA9IG1bJHtlfV0gLSAke2lbZV19O1xcbiAgICAgICAgaWYgKGsgPCAwKSB7IGsgPSAtazsgfVxcbiAgICAgICAge1xcbiAgICAgICAgICBjb25zdCBpbnQgXzJuXzEgPSAkezIqKHRbZV0tMSl9O1xcbiAgICAgICAgICBrID0gaW50KCBtb2QoIGZsb2F0KGspLCBmbG9hdChfMm5fMSkgKSApIDtcXG4gICAgICAgICAgaWYoayA+PSAke3RbZV19KSB7IGsgPSBfMm5fMSAtIGs7IH1cXG4gICAgICAgIH1cXG4gICAgICAgIG9mZnNldCArPSBrICogJHtuW2VdfTtcXG4gICAgICAgIGA7cmV0dXJuYFxcbiAgICAgIGZsb2F0IHBhZEEoaW50IG1bJHthfV0pIHtcXG4gICAgICAgIGludCBvZmZzZXQgPSAwO1xcbiAgICAgICAgaW50IGsgPSAwO1xcbiAgICAgICAgJHtzfVxcbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7cn0sICR7b30pO1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHtlLnRleHR1cmUyRH0oQSwgY29vcmRzKSk7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGB9LGc9KGUsdCxuLHIsbyxpKT0+e2NvbnN0IGE9dC5sZW5ndGg7bGV0IHM9XCJcIjtmb3IobGV0IGU9YS0xO2U+PTA7LS1lKXMrPWBcXG4gICAgICAgIGsgPSBtWyR7ZX1dIC0gJHtpW2VdfTtcXG4gICAgICAgIGlmIChrIDwgMCkgIGsgPSAwO1xcbiAgICAgICAgaWYgKGsgPj0gJHt0W2VdfSkgayA9ICR7dFtlXS0xfTtcXG4gICAgICAgIG9mZnNldCArPSBrICogJHtuW2VdfTtcXG4gICAgICBgO3JldHVybmBcXG4gICAgICBmbG9hdCBwYWRBKGludCBtWyR7YX1dKSB7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcXG4gICAgICAgIGludCBrID0gMDtcXG4gICAgICAgICR7c31cXG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke3J9LCAke299KTtcXG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7ZS50ZXh0dXJlMkR9KEEsIGNvb3JkcykpO1xcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH1cXG4gICAgICBgfX0sMjgzNDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nbG9iYWxNYXhQb29sPXQucGFyc2VNYXhQb29sQXR0cmlidXRlcz10Lm1heFBvb2w9dC5wYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlcz10Lmdsb2JhbEF2ZXJhZ2VQb29sPXQucGFyc2VBdmVyYWdlUG9vbEF0dHJpYnV0ZXM9dC5hdmVyYWdlUG9vbD12b2lkIDA7Y29uc3Qgcj1uKDQ5MTApLG89big3MjczKSxpPW4oNTYzOSk7dC5hdmVyYWdlUG9vbD0oZSx0LG4pPT57cCh0KTtjb25zdCByPXtuYW1lOlwiQXZlcmFnZVBvb2xcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZF0sY2FjaGVIaW50Om4uY2FjaGVLZXl9O3JldHVybltlLnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+YSh0LHIsITEsbil9KSx0KV19LHQucGFyc2VBdmVyYWdlUG9vbEF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5hdHRyaWJ1dGVzLmdldFN0cmluZyhcImF1dG9fcGFkXCIsXCJOT1RTRVRcIiksbj1lLmF0dHJpYnV0ZXMuZ2V0SW50KFwiY2VpbF9tb2RlXCIsMCksbz0wIT09ZS5hdHRyaWJ1dGVzLmdldEludChcImNvdW50X2luY2x1ZGVfcGFkXCIsMCksaT1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcImtlcm5lbF9zaGFwZVwiKSxhPWUuYXR0cmlidXRlcy5nZXRJbnRzKFwic3RyaWRlc1wiLFtdKSxzPWUuYXR0cmlidXRlcy5nZXRJbnRzKFwicGFkc1wiLFtdKTtpZigwIT09bil0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIEF2ZXJhZ2VQb29sXCIpO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXV0b1BhZDp0LGNlaWxNb2RlOm4sY291bnRJbmNsdWRlUGFkOm8sa2VybmVsU2hhcGU6aSxzdHJpZGVzOmEscGFkczpzfSl9O2NvbnN0IGE9KGUsdCxuLHIpPT57Y29uc3RbYSxzXT11KGUscixuKSxsPW8uU2hhcGVVdGlsLnNpemUoYS5rZXJuZWxTaGFwZSk7bGV0IGM9XCJcIjthLmNvdW50SW5jbHVkZVBhZD9jKz1gdmFsdWUgLz0gZmxvYXQoJHtsfSk7YDpjKz1gdmFsdWUgLz0gZmxvYXQoJHtsfSAtIHBhZCk7YDtjb25zdCBwPWBcXG4gICAgICAgICR7ZChlWzBdLmRpbXMsYSxcInZhbHVlICs9IF9YKHgpO1wiLGMsXCIwLjBcIil9XFxuICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXQ6e2RpbXM6cyx0eXBlOmVbMF0udHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6cH0pfTt0Lmdsb2JhbEF2ZXJhZ2VQb29sPShlLHQsbik9PntwKHQpO2NvbnN0IHI9e25hbWU6XCJHbG9iYWxBdmVyYWdlUG9vbFwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6YCR7bi5jb3VudEluY2x1ZGVQYWR9YH07cmV0dXJuW2UucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7Z2V0OigpPT5hKHQsciwhMCxuKX0pLHQpXX0sdC5wYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlcz1lPT57Y29uc3QgdD0wIT09ZS5hdHRyaWJ1dGVzLmdldEludChcImNvdW50X2luY2x1ZGVfcGFkXCIsMCk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHthdXRvUGFkOlwiXCIsY2VpbE1vZGU6MCxjb3VudEluY2x1ZGVQYWQ6dCxrZXJuZWxTaGFwZTpbXSxzdHJpZGVzOltdLHBhZHM6W119KX0sdC5tYXhQb29sPShlLHQsbik9PntwKHQpO2NvbnN0IHI9e25hbWU6XCJNYXhQb29sXCIsaW5wdXROYW1lczpbXCJYXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDpuLmNhY2hlS2V5fTtyZXR1cm5bZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHtnZXQ6KCk9PnModCxyLCExLG4pfSksdCldfSx0LnBhcnNlTWF4UG9vbEF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5hdHRyaWJ1dGVzLmdldFN0cmluZyhcImF1dG9fcGFkXCIsXCJOT1RTRVRcIiksbj1lLmF0dHJpYnV0ZXMuZ2V0SW50KFwiY2VpbF9tb2RlXCIsMCksbz1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcImtlcm5lbF9zaGFwZVwiKSxpPWUuYXR0cmlidXRlcy5nZXRJbnRzKFwic3RyaWRlc1wiLFtdKSxhPWUuYXR0cmlidXRlcy5nZXRJbnRzKFwicGFkc1wiLFtdKSxzPWUuYXR0cmlidXRlcy5nZXRJbnQoXCJzdG9yYWdlX29yZGVyXCIsMCksdT1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcImRpbGF0aW9uc1wiLFtdKTtpZigwIT09cyl0aHJvdyBuZXcgRXJyb3IoXCJjb2x1bW4gbWFqb3Igc3RvcmFnZSBvcmRlciBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtpZigwIT09bil0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHthdXRvUGFkOnQsY2VpbE1vZGU6bixjb3VudEluY2x1ZGVQYWQ6ITEsa2VybmVsU2hhcGU6byxzdHJpZGVzOmkscGFkczphLHN0b3JhZ2VPcmRlcjpzLGRpbGF0aW9uczp1fSl9O2NvbnN0IHM9KGUsdCxuLHIpPT57Y29uc3RbbyxhXT11KGUscixuKSxzPWBcXG4gICAgICAke2QoZVswXS5kaW1zLG8sXCJcXG4gICAgICB2YWx1ZSA9IG1heChfWCh4KSwgdmFsdWUpO1xcbiAgICBcIixcIlwiLFwiLTFlNVwiKX1cXG4gICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXQ6e2RpbXM6YSx0eXBlOmVbMF0udHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6c30pfSx1PShlLHQsbik9Pntjb25zdCByPWVbMF0uZGltcy5zbGljZSgpLGk9T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxcImRpbGF0aW9uc1wiKSxhPXQua2VybmVsU2hhcGUuc2xpY2UoKSxzPXQuc3RyaWRlcy5zbGljZSgpLHU9aT90LmRpbGF0aW9ucy5zbGljZSgpOltdLGw9dC5wYWRzLnNsaWNlKCk7by5Qb29sQ29udlV0aWwuYWRqdXN0UG9vbEF0dHJpYnV0ZXMobixyLGEscyx1LGwpO2NvbnN0IGM9by5Qb29sQ29udlV0aWwuY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShuLHIscyx1LGEsbCx0LmF1dG9QYWQpLHA9T2JqZWN0LmFzc2lnbih7fSx0KTtyZXR1cm4gaT9PYmplY3QuYXNzaWduKHAse2tlcm5lbFNoYXBlOmEsc3RyaWRlczpzLHBhZHM6bCxkaWxhdGlvbnM6dSxjYWNoZUtleTp0LmNhY2hlS2V5fSk6T2JqZWN0LmFzc2lnbihwLHtrZXJuZWxTaGFwZTphLHN0cmlkZXM6cyxwYWRzOmwsY2FjaGVLZXk6dC5jYWNoZUtleX0pLFtwLGNdfSxsPXthdXRvUGFkOlwiXCIsY2VpbE1vZGU6MCxjb3VudEluY2x1ZGVQYWQ6ITEsa2VybmVsU2hhcGU6W10sc3RyaWRlczpbXSxwYWRzOltdLHN0b3JhZ2VPcmRlcjowLGRpbGF0aW9uczpbXSxjYWNoZUtleTpcIlwifSxjPXtuYW1lOlwiR2xvYmFsTWF4UG9vbFwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkXX07dC5nbG9iYWxNYXhQb29sPShlLHQpPT4ocCh0KSxbZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGMpLHtnZXQ6KCk9PnModCxjLCEwLGwpfSksdCldKTtjb25zdCBwPWU9PntpZighZXx8MSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlBvb2wgb3BzIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwiZmxvYXQzMlwiIT09ZVswXS50eXBlJiZcImZsb2F0NjRcIiE9PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfSxkPShlLHQsbixyLGkpPT57Y29uc3QgYT1lLmxlbmd0aDtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aDw9Mil7Y29uc3Qgbz10Lmtlcm5lbFNoYXBlW3Qua2VybmVsU2hhcGUubGVuZ3RoLTFdLHM9dC5zdHJpZGVzW3Quc3RyaWRlcy5sZW5ndGgtMV0sdT10LnBhZHNbdC5wYWRzLmxlbmd0aC8yLTFdLGw9dC5wYWRzW3QucGFkcy5sZW5ndGgtMV0sYz1lW2EtMV07bGV0IHA9XCJcIixkPVwiXCIsZj1cIlwiO2lmKHA9dStsIT09MD9gXFxuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtvfTsgaSsrKSB7XFxuICAgICAgICAgICAgeFske2F9IC0gMV0gPSBpbmRpY2VzWyR7YX0gLSAxXSAqICR7c30gLSAke3V9ICsgaTtcXG4gICAgICAgICAgICBpZiAoeFske2F9IC0gMV0gPCAwIHx8IHhbJHthfSAtIDFdID49ICR7Y30pIHtcXG4gICAgICAgICAgICAgIHBhZCsrO1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICR7bn1cXG4gICAgICAgICAgfWA6YFxcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7b307IGkrKykge1xcbiAgICAgICAgICAgIHhbJHthfSAtIDFdID0gaW5kaWNlc1ske2F9IC0gMV0gKiAke3N9IC0gJHt1fSArIGk7XFxuICAgICAgICAgICAgJHtufVxcbiAgICAgICAgICB9YCwyPT09dC5rZXJuZWxTaGFwZS5sZW5ndGgpe2NvbnN0IG49dC5rZXJuZWxTaGFwZVt0Lmtlcm5lbFNoYXBlLmxlbmd0aC0yXSxyPXQuc3RyaWRlc1t0LnN0cmlkZXMubGVuZ3RoLTJdLGk9dC5wYWRzW3QucGFkcy5sZW5ndGgvMi0yXSxzPXQucGFkc1t0LnBhZHMubGVuZ3RoLTJdLHU9ZVthLTJdO2Q9aStzIT09MD9gXFxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCAke259OyBqKyspIHtcXG4gICAgICAgICAgICAgIHhbJHthfSAtIDJdID0gaW5kaWNlc1ske2F9IC0gMl0gKiAke3J9IC0gJHtpfSArIGo7XFxuICAgICAgICAgICAgICBpZiAoeFske2F9IC0gMl0gPCAwIHx8IHhbJHthfSAtIDJdID49ICR7dX0pIHtcXG4gICAgICAgICAgICAgICAgcGFkKz0gJHtvfTtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgIGA6YFxcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgJHtufTsgaisrKSB7XFxuICAgICAgICAgICAgICB4WyR7YX0gLSAyXSA9IGluZGljZXNbJHthfSAtIDJdICogJHtyfSAtICR7aX0gKyBqO1xcbiAgICAgICAgICAgIGAsZj1cIlxcbiAgICAgICAgICB9XFxuICAgICAgICBcIn1yZXR1cm5gXFxuICAgICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7YX1dKSB7XFxuICAgICAgICAgIGludCB4WyR7YX1dO1xcbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIHgpO1xcblxcbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9ICR7aX07XFxuICAgICAgICAgIGludCBwYWQgPSAwO1xcbiAgICAgICAgICAke2R9XFxuICAgICAgICAgICR7cH1cXG4gICAgICAgICAgJHtmfVxcbiAgICAgICAgICAke3J9XFxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICBgfXtjb25zdCBzPW8uU2hhcGVVdGlsLnNpemUodC5rZXJuZWxTaGFwZSksdT1vLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyh0Lmtlcm5lbFNoYXBlKSxsPXUubGVuZ3RoLGM9dC5wYWRzLmxlbmd0aCxwPWgobCksZD1mKGUsXCJpbnB1dERpbXNcIiksZz1mKHQucGFkcyxcInBhZHNcIiksbT1mKHUsXCJrZXJuZWxTdHJpZGVzXCIpLGI9Zih0LnN0cmlkZXMsXCJzdHJpZGVzXCIpO2xldCB5PVwiXCI7cmV0dXJuIHk9dC5wYWRzLnJlZHVjZSgoKGUsdCk9PmUrdCkpP2BcXG4gICAgICAgICAgICBpZiAoeFtqXSA+PSBpbnB1dERpbXNbal0gfHwgeFtqXSA8IDApIHtcXG4gICAgICAgICAgICAgIHBhZCsrO1xcbiAgICAgICAgICAgICAgaXNQYWQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmICghaXNQYWQpIHtcXG4gICAgICAgICAgICAke259XFxuICAgICAgICAgIH1gOmBcXG4gICAgICAgICAgfVxcbiAgICAgICAgICAke259XFxuICAgICAgICBgLGBcXG4gICAgICAgICR7cH1cXG4gICAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHthfV0pIHtcXG4gICAgICAgICAgaW50IHhbJHthfV07XFxuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgeCk7XFxuICAgICAgICAgIGludCBvZmZzZXRbJHtsfV07XFxuICAgICAgICAgIGludCBwYWRzWyR7Y31dO1xcbiAgICAgICAgICBpbnQgaW5wdXREaW1zWyR7YX1dO1xcbiAgICAgICAgICBpbnQga2VybmVsU3RyaWRlc1ske2x9XTtcXG4gICAgICAgICAgaW50IHN0cmlkZXNbJHtsfV07XFxuICAgICAgICAgICR7Z31cXG4gICAgICAgICAgJHtkfVxcbiAgICAgICAgICAke2J9XFxuICAgICAgICAgICR7bX1cXG5cXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSAke2l9O1xcbiAgICAgICAgICBpbnQgcGFkID0gMDtcXG4gICAgICAgICAgYm9vbCBpc1BhZCA9IGZhbHNlO1xcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7c307IGkrKykge1xcbiAgICAgICAgICAgIG9mZnNldFRvSW5kaWNlcyhpLCBrZXJuZWxTdHJpZGVzLCBvZmZzZXQpO1xcbiAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XFxuICAgICAgICAgICAgZm9yIChpbnQgaiA9ICR7YX0gLSAke2x9OyBqIDwgJHthfTsgaisrKSB7XFxuICAgICAgICAgICAgICB4W2pdID0gaW5kaWNlc1tqXSAqIHN0cmlkZXNbaiAtICR7YX0gKyAke2x9XVxcbiAgICAgICAgICAgICAgICArIG9mZnNldFtqIC0gJHthfSArICR7bH1dIC0gcGFkc1tqIC0gMl07XFxuICAgICAgICAgICAgICAke3l9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgJHtyfVxcblxcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgYH19LGY9KGUsdCk9PntsZXQgbj1cIlwiO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKW4rPWBcXG4gICAgICAke3R9WyR7cn1dID0gJHtlW3JdfTtcXG4gICAgYDtyZXR1cm4gbn0saD1lPT5gXFxuICB2b2lkIG9mZnNldFRvSW5kaWNlcyhpbnQgb2Zmc2V0LCBpbnRbJHtlfV0gc3RyaWRlcywgb3V0IGludFske2V9XSBpbmRpY2VzKSB7XFxuICAgIGlmICgke2V9ID09IDApIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2V9IC0gMTsgKytpKSB7XFxuICAgICAgaW5kaWNlc1tpXSA9IG9mZnNldCAvIHN0cmlkZXNbaV07XFxuICAgICAgb2Zmc2V0IC09IGluZGljZXNbaV0gKiBzdHJpZGVzW2ldO1xcbiAgICB9XFxuICAgIGluZGljZXNbJHtlfSAtIDFdID0gb2Zmc2V0O1xcbiAgfWB9LDEwMTA6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucmVkdWNlTG9nU3VtU3F1YXJlPXQucmVkdWNlTG9nU3VtPXQucmVkdWNlUHJvZD10LnJlZHVjZU1pbj10LnJlZHVjZU1heD10LnJlZHVjZU1lYW49dC5yZWR1Y2VTdW09dC5wYXJzZVJlZHVjZUF0dHJpYnV0ZXM9dm9pZCAwO2NvbnN0IHI9big0OTEwKSxvPW4oNjE0NSksaT1uKDcyNzMpLGE9big1NjM5KSxzPShlLHQsbixyLG8pPT57bCh0KTtjb25zdCBpPXtuYW1lOnIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2EuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTtyZXR1cm5bZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGkpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9PnUoZSx0LG4scixvLGkpfSksdCldfTt0LnBhcnNlUmVkdWNlQXR0cmlidXRlcz1lPT57Y29uc3QgdD1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcImF4ZXNcIixbXSksbj0xPT09ZS5hdHRyaWJ1dGVzLmdldEludChcImtlZXBkaW1zXCIsMSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtheGVzOnQsa2VlcERpbXM6bn0pfTtjb25zdCB1PShlLHQsbixyLG8scyk9Pntjb25zdCB1PVtdLGw9dFswXS5kaW1zLmxlbmd0aHx8MSxjPVtdLHA9aS5TaGFwZVV0aWwubm9ybWFsaXplQXhlcyhuLmF4ZXMsdFswXS5kaW1zLmxlbmd0aCksZD1vKHQscCk7bGV0IGY9ZFsxXTtmb3IobGV0IGU9MDtlPHRbMF0uZGltcy5sZW5ndGg7ZSsrKXAuaW5kZXhPZihlKT49MHx8MD09PXAubGVuZ3RoPyhuLmtlZXBEaW1zJiZ1LnB1c2goMSksZj1gXFxuICAgICAgICAgIGZvcihpbnQgaiR7ZX0gPSAwOyBqJHtlfSA8ICR7dFswXS5kaW1zW2VdfTsgaiR7ZX0rKykge1xcbiAgICAgICAgICAgIGlucHV0SWR4WyR7ZX1dID0gaiR7ZX07XFxuICAgICAgICAgICAgJHtmfVxcbiAgICAgICAgICB9YCk6KGMucHVzaChgaW5wdXRJZHhbJHtlfV0gPSBvdXRwdXRJZHhbJHt1Lmxlbmd0aH1dO2ApLHUucHVzaCh0WzBdLmRpbXNbZV0pKTtjb25zdCBoPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHt1Lmxlbmd0aHx8MX1dKSB7XFxuICAgICAgICBmbG9hdCB2YWx1ZTsgICAgICAgICAgICAgICAgIC8vIGZpbmFsIHJlc3VsdFxcbiAgICAgICAgaW50IGlucHV0SWR4WyR7bH1dOyAgICAgIC8vIGFkZHJlc3NpbmcgaW5wdXQgZGF0YVxcbiAgICAgICAgJHtjLmpvaW4oXCJcXG5cIil9XFxuICAgICAgICAke2RbMF19ICAgICAgIC8vIGluaXQgb3BzIGZvciByZWR1Y2UgbWF4L21pblxcbiAgICAgICAgJHtmfVxcbiAgICAgICAgJHtkWzJdfSAgICAgICAvLyBmaW5hbCBjb21wdXRhdGlvbiBmb3IgcmVkdWNlIG1lYW5cXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtvdXRwdXQ6e2RpbXM6dSx0eXBlOnRbMF0udHlwZSx0ZXh0dXJlVHlwZTphLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6aH0pfSxsPWU9PntpZighZXx8MSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlJlZHVjZSBvcCByZXF1aXJlcyAxIGlucHV0LlwiKTtpZigtMT09PW8uTlVNQkVSX1RZUEVTLmluZGV4T2YoZVswXS50eXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfTt0LnJlZHVjZVN1bT0oZSx0LG4pPT5zKGUsdCxuLFwiUmVkdWNlU3VtXCIsKCgpPT5bXCJ2YWx1ZSA9IDAuMDtcIixcInZhbHVlICs9IF9BKGlucHV0SWR4KTtcIixcIlwiXSkpLHQucmVkdWNlTWVhbj0oZSx0LG4pPT5zKGUsdCxuLFwiUmVkdWNlTWVhblwiLCgoZSx0KT0+e2xldCBuPTE7Zm9yKGxldCByPTA7cjxlWzBdLmRpbXMubGVuZ3RoO3IrKykodC5pbmRleE9mKHIpPj0wfHwwPT09dC5sZW5ndGgpJiYobio9ZVswXS5kaW1zW3JdKTtyZXR1cm5bXCJ2YWx1ZSA9IDAuMDtcIixcInZhbHVlICs9IF9BKGlucHV0SWR4KTtcIixgdmFsdWUgLz0gJHtufS47YF19KSksdC5yZWR1Y2VNYXg9KGUsdCxuKT0+cyhlLHQsbixcIlJlZHVjZU1heFwiLCgoZSx0KT0+e2NvbnN0IG49W107Zm9yKGxldCByPTA7cjxlWzBdLmRpbXMubGVuZ3RoO3IrKykodC5pbmRleE9mKHIpPj0wfHwwPT09dC5sZW5ndGgpJiZuLnB1c2goYGlucHV0SWR4WyR7cn1dID0gMDtgKTtyZXR1cm5bYCR7bi5qb2luKFwiXFxuXCIpfVxcbnZhbHVlID0gX0EoaW5wdXRJZHgpO2AsXCJ2YWx1ZSA9IG1heCh2YWx1ZSwgX0EoaW5wdXRJZHgpKTtcIixcIlwiXX0pKSx0LnJlZHVjZU1pbj0oZSx0LG4pPT5zKGUsdCxuLFwiUmVkdWNlTWluXCIsKChlLHQpPT57Y29uc3Qgbj1bXTtmb3IobGV0IHI9MDtyPGVbMF0uZGltcy5sZW5ndGg7cisrKSh0LmluZGV4T2Yocik+PTB8fDA9PT10Lmxlbmd0aCkmJm4ucHVzaChgaW5wdXRJZHhbJHtyfV0gPSAwO2ApO3JldHVybltgJHtuLmpvaW4oXCJcXG5cIil9XFxudmFsdWUgPSBfQShpbnB1dElkeCk7YCxcInZhbHVlID0gbWluKHZhbHVlLCBfQShpbnB1dElkeCkpO1wiLFwiXCJdfSkpLHQucmVkdWNlUHJvZD0oZSx0LG4pPT5zKGUsdCxuLFwiUmVkdWNlUHJvZFwiLCgoKT0+W1widmFsdWUgPSAxLjA7XCIsXCJ2YWx1ZSAqPSBfQShpbnB1dElkeCk7XCIsXCJcIl0pKSx0LnJlZHVjZUxvZ1N1bT0oZSx0LG4pPT5zKGUsdCxuLFwiUmVkdWNlTG9nU3VtXCIsKCgpPT5bXCJ2YWx1ZSA9IDAuMDtcIixcInZhbHVlICs9IF9BKGlucHV0SWR4KTtcIixcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pKSx0LnJlZHVjZUxvZ1N1bVNxdWFyZT0oZSx0LG4pPT5zKGUsdCxuLFwiUmVkdWNlTG9nU3VtU3F1YXJlXCIsKCgpPT5bXCJmbG9hdCB0OyB2YWx1ZSA9IDAuMDtcIixcInQgPSBfQShpbnB1dElkeCk7IHZhbHVlICs9IHQgKiB0O1wiLFwiXCJdKSl9LDczNzk6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuaXNSZXNoYXBlQ2hlYXA9dC5wcm9jZXNzRGltczNEPXQuY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9big3MjczKSxvPW4oNjc1NyksaT1uKDU2MzkpLGE9big1NjE0KTt0LmNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvTG9hZGVyPShlLHQsbik9Pntjb25zdCBzPShlPT4oe25hbWU6XCJSZXNoYXBlIChwYWNrZWQpXCIsaW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS5wYWNrZWRdLGlucHV0TmFtZXM6W1wiQVwiXSxjYWNoZUhpbnQ6YCR7ZX1gfSkpKG4pO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2dldDooKT0+KChlLHQsbixzKT0+e2NvbnN0IHU9dC5kaW1zLGw9cztsZXQgYz1cIlwiO2ZvcihsZXQgZT0wO2U8NDtlKyspe2xldCB0PVwiXCI7c3dpdGNoKGUpe2Nhc2UgMDp0PVwib3V0cHV0Q29vcmRzID0gcmM7XCI7YnJlYWs7Y2FzZSAxOnQ9XCJvdXRwdXRDb29yZHMgPSBpdmVjMyhyYy54LCByYy55KzEsIHJjLnopO1wiO2JyZWFrO2Nhc2UgMjp0PVwib3V0cHV0Q29vcmRzID0gaXZlYzMocmMueCwgcmMueSwgcmMueisxKTtcIjticmVhaztjYXNlIDM6dD1cIm91dHB1dENvb3JkcyA9IGl2ZWMzKHJjLngsIHJjLnkrMSwgcmMueisxKTtcIjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcn1jKz1gXFxuICAgICAgICAke3R9XFxuICAgICAgICAke2U+MD9cImlmKG91dHB1dENvb3Jkcy55IDwgcm93cyAmJiBvdXRwdXRDb29yZHMueiA8IGNvbHMpe1wiOlwiXCJ9XFxuICAgICAgICAgIGludCBmbGF0dGVuZWRJbmRleCA9IGdldEZsYXR0ZW5lZEluZGV4KG91dHB1dENvb3Jkcyk7XFxuXFxuICAgICAgICAgIGl2ZWMzIGlucHV0UkMgPSBpbnB1dENvb3Jkc0Zyb21SZXNoYXBlZE91dENvb3JkcyhmbGF0dGVuZWRJbmRleCk7XFxuICAgICAgICAgIHZlYzIgaW5uZXJEaW1zID0gdmVjMihmbG9hdChpbnB1dFJDLnkpLGZsb2F0KGlucHV0UkMueikpO1xcblxcbiAgICAgICAgICByZXN1bHRbJHtlfV0gPSBnZXRDaGFubmVsKGdldEEoaW5wdXRSQy54LCBpbnB1dFJDLnksIGlucHV0UkMueiksIGlubmVyRGltcyk7XFxuXFxuICAgICAgICAke2U+MD9cIn1cIjpcIlwifVxcbiAgICAgIGB9Y29uc3QgcD0oMCxvLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxkPWBcXG4gICAgICAke2Z1bmN0aW9uKGUpe2NvbnN0IHQ9ci5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZSksbj1bXCJiXCIsXCJyXCIsXCJjXCJdLG89XCJpbmRleFwiO3JldHVybmBcXG4gICAgaXZlYzMgaW5wdXRDb29yZHNGcm9tUmVzaGFwZWRPdXRDb29yZHMoaW50IGluZGV4KSB7XFxuICAgICAgJHt0Lm1hcCgoKGUscik9PmBpbnQgJHtuW3JdfSA9ICR7b30gLyAke2V9OyAke3I9PT10Lmxlbmd0aC0xP2BpbnQgJHtuW3IrMV19ID0gJHtvfSAtICR7bltyXX0gKiAke2V9YDpgaW5kZXggLT0gJHtuW3JdfSAqICR7ZX1gfTtgKSkuam9pbihcIlwiKX1cXG4gICAgICByZXR1cm4gaXZlYzMoYiwgciwgYyk7XFxuICAgIH1cXG4gIGB9KHUpfVxcbiAgICAgICR7ZnVuY3Rpb24oZSl7Y29uc3QgdD1yLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhlKTtyZXR1cm5gXFxuICBpbnQgZ2V0RmxhdHRlbmVkSW5kZXgoaXZlYzMgY29vcmRzKSB7XFxuICAgIC8vIHJldmVyc2UgeSwgeiBvcmRlclxcbiAgICByZXR1cm4gY29vcmRzLnggKiAke3RbMF19ICsgY29vcmRzLnogKiAke3RbMV19ICsgY29vcmRzLnk7XFxuICB9XFxuYH0obCl9XFxuICAgICAgJHsoMCxhLnVucGFja0Zyb21DaGFubmVsKSgpfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4wKTtcXG5cXG4gICAgICAgIGl2ZWMzIG91dHB1dENvb3JkcztcXG4gICAgICAgIGludCByb3dzID0gJHtsWzJdfTtcXG4gICAgICAgIGludCBjb2xzID0gJHtsWzFdfTtcXG5cXG4gICAgICAgICR7Y31cXG4gICAgICAgICR7cC5vdXRwdXR9ID0gcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtvdXRwdXQ6e2RpbXM6bCx0eXBlOnQudHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnBhY2tlZH0sc2hhZGVyU291cmNlOmQsaGFzTWFpbjohMH0pfSkoZSx0LHMsbil9KX0sdC5wcm9jZXNzRGltczNEPWZ1bmN0aW9uKGUpe2lmKDA9PT1lLmxlbmd0aClyZXR1cm5bMSwxLDFdO2xldCB0PTE7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aC0yOysrbil0Kj1lW25dO3JldHVyblt0LGUubGVuZ3RoPjE/ZVtlLmxlbmd0aC0yXToxLGVbZS5sZW5ndGgtMV1dfSx0LmlzUmVzaGFwZUNoZWFwPWZ1bmN0aW9uKGUsdCl7bGV0IG49ITE7cmV0dXJuIG49MD09PWUubGVuZ3RofHwwPT09dC5sZW5ndGh8fChlLmxlbmd0aDwyfHx0Lmxlbmd0aDwyP2VbZS5sZW5ndGgtMV09PT10W3QubGVuZ3RoLTFdOmVbZS5sZW5ndGgtMV09PT10W3QubGVuZ3RoLTFdJiZlW2UubGVuZ3RoLTJdPT09dFt0Lmxlbmd0aC0yXSksbn19LDgxMjY6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucmVzaGFwZT12b2lkIDA7Y29uc3Qgcj1uKDcyNzMpO3QucmVzaGFwZT0oZSx0KT0+e2NvbnN0IG49ci5TaGFwZVV0aWwuY2FsY3VsYXRlUmVzaGFwZWREaW1zKHRbMF0uZGltcyx0WzFdLmludGVnZXJEYXRhKTtyZXR1cm4gZS5zZXNzaW9uLnBhY2s/W2UucmVzaGFwZVBhY2tlZCh0WzBdLG4pXTpbZS5yZXNoYXBlVW5wYWNrZWQodFswXSxuKV19fSwyODAxOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlUmVzaXplQXR0cmlidXRlc1YxMT10LnBhcnNlUmVzaXplQXR0cmlidXRlc1YxMD10LnJlc2l6ZT12b2lkIDA7Y29uc3Qgcj1uKDY3NTcpLG89big1NjM5KSxpPW4oNDMyKSxhPW4oNTYxNCkscz1uKDM5ODApLHU9e25hbWU6XCJSZXNpemVcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS5wYWNrZWRdfTt0LnJlc2l6ZT0oZSx0LG4pPT4oKDAscy52YWxpZGF0ZUlucHV0cykodCxuKSxbZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9PmwoZSx0LG4pfSksdCldKSx0LnBhcnNlUmVzaXplQXR0cmlidXRlc1YxMD1lPT4oMCxzLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzKShlLDEwKSx0LnBhcnNlUmVzaXplQXR0cmlidXRlc1YxMT1lPT4oMCxzLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzKShlLDExKTtjb25zdCBsPShlLHQsbik9Pntjb25zdCBzPSgwLHIuZ2V0R2xzbCkoZS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLFtsLHBdPWModCxuKTtpZihsLmV2ZXJ5KChlPT4xPT09ZSkpJiZcInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiIT09bi5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSlyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtvdXRwdXQ6e2RpbXM6cCx0eXBlOnRbMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnBhY2tlZH0saGFzTWFpbjohMCxzaGFkZXJTb3VyY2U6YHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgdiA9ICR7cy50ZXh0dXJlMkR9KFgsIFRleENvb3Jkcyk7XFxuICAgICAgICAgICAgICAgICAgICAke3Mub3V0cHV0fSA9IHY7XFxuICAgICAgICAgICAgICAgIH1gfSk7Y29uc3QgZD1wLmxlbmd0aDtpZihkPDIpdGhyb3cgbmV3IEVycm9yKGBvdXRwdXQgZGltZW5zaW9uIHNob3VsZCBiZSBhdCBsZWFzdCAyLCBidXQgZ290ICR7ZH1gKTtjb25zdCBmPXBbZC0yXSxoPXBbZC0xXSxnPXRbMF0uZGltcztpZihkIT09Zy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBvdXRwdXQgZGltZW5zaW9uIHNob3VsZCBtYXRjaCBpbnB1dCAke2cubGVuZ3RofSwgYnV0IGdvdCAke2R9YCk7Y29uc3QgbT1nW2QtMl0sYj1nW2QtMV0seT1sW2QtMl0sdz1sW2QtMV07bGV0IF89XCJcIjtpZihcImxpbmVhclwiIT09bi5tb2RlKXRocm93IG5ldyBFcnJvcihgcmVzaXplIChwYWNrZWQpIGRvZXMgbm90IHN1cHBvcnQgbW9kZTogJyR7bi5tb2RlfSdgKTtzd2l0Y2gobi5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSl7Y2FzZVwiYXN5bW1ldHJpY1wiOl89XCJcXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgZ2V0U291cmNlRnJhY0luZGV4KGl2ZWM0IGNvb3Jkcykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZWM0KGNvb3JkcykgLyBzY2FsZVdIV0g7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIFwiO2JyZWFrO2Nhc2VcImhhbGZfcGl4ZWxcIjpfPVwiXFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHZlYzQoY29vcmRzKSArIDAuNSkgLyBzY2FsZVdIV0ggLSAwLjU7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIFwiO2JyZWFrO2Nhc2VcInB5dG9yY2hfaGFsZl9waXhlbFwiOl89YFxcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBmY29vcmRzID0gdmVjNChjb29yZHMpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2h9LjAgPiAxLjAgPyAoZmNvb3Jkcy54ICsgMC41KSAvIHNjYWxlV0hXSC54IC0gMC41IDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2Z9LjAgPiAxLjAgPyAoZmNvb3Jkcy55ICsgMC41KSAvIHNjYWxlV0hXSC55IC0gMC41IDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2h9LjAgPiAxLjAgPyAoZmNvb3Jkcy56ICsgMC41KSAvIHNjYWxlV0hXSC56IC0gMC41IDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2Z9LjAgPiAxLjAgPyAoZmNvb3Jkcy53ICsgMC41KSAvIHNjYWxlV0hXSC53IC0gMC41IDogMC4wXFxuICAgICAgICAgICAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBgO2JyZWFrO2Nhc2VcImFsaWduX2Nvcm5lcnNcIjpfPWBcXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgZ2V0U291cmNlRnJhY0luZGV4KGl2ZWM0IGNvb3Jkcykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgcmVzaXplZCA9IHZlYzQoJHtofS4wIC0gMS4wLCAke2Z9LjAgLSAxLjAsICR7aH0uMCAtIDEuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtmfS4wIC0gMS4wKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IG9yaWdpbmFsID0gdmVjNCgke2J9LjAgLSAxLjAsICR7bX0uMCAtIDEuMCwgJHtifS4wIC0gMS4wLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke219LjAgLSAxLjApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgbmV3X3NjYWxlID0gb3JpZ2luYWwgLyByZXNpemVkO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZWM0KGNvb3JkcykgKiBuZXdfc2NhbGU7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGA7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHJlc2l6ZSAocGFja2VkKSBkb2VzIG5vdCBzdXBwb3J0IGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcke24uY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGV9J2ApfWNvbnN0IHY9KDAsaS5nZXRDb29yZHNEYXRhVHlwZSkoZCkseD1gXFxuICAgICAgICAgICAgY29uc3QgdmVjMiBpbnB1dFdIID0gdmVjMigke219LjAsICR7Yn0uMCk7XFxuICAgICAgICAgICAgY29uc3QgdmVjNCBzY2FsZVdIV0ggPSB2ZWM0KGZsb2F0KCR7eX0pLCBmbG9hdCgke3d9KSwgZmxvYXQoJHt5fSksIGZsb2F0KCR7d30pKTtcXG4gICAgICAgICAgICAkeygwLGEudW5wYWNrRnJvbUNoYW5uZWwpKCl9XFxuICAgICAgICAgICAgJHtffVxcbiAgICAgICAgICAgIGZsb2F0IGdldEFWYWx1ZShpbnQgeDEwLCBpbnQgciwgaW50IGMsIGludCBkKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKGdldEEoeDEwLCByLCBjLCBkKSwgdmVjMihjLCBkKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgICAgICAgJHt2fSByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgICAgICAgICBpbnQgYmF0Y2ggPSByY1swXTtcXG4gICAgICAgICAgICAgICAgaW50IGRlcHRoID0gcmNbMV07XFxuXFxuICAgICAgICAgICAgICAgIC8vIHJldHJpZXZlIHRoZSA0IGNvb3JkaW5hdGVzIHRoYXQgaXMgdXNlZCBpbiB0aGUgNCBwYWNrZWQgb3V0cHV0IHZhbHVlcy5cXG4gICAgICAgICAgICAgICAgaXZlYzQgY29vcmRzID0gaXZlYzQocmMud3osIHJjLncgKyAxLCByYy56ICsgMSk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgc291cmNlIGluZGV4IGluIGZyYWN0aW9uXFxuICAgICAgICAgICAgICAgIHZlYzQgc291cmNlRnJhYyA9IGdldFNvdXJjZUZyYWNJbmRleChjb29yZHMpO1xcblxcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGxvd2VyIGFuZCB1cHBlciBib3VuZCBvZiB0aGUgNCB2YWx1ZXMgdGhhdCB3aWxsIGJlIHBhY2tlZCBpbnRvIG9uZSB0ZXhlbC5cXG4gICAgICAgICAgICAgICAgaXZlYzQgeDAwID0gaXZlYzQobWF4KHNvdXJjZUZyYWMueHksIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMueHkpKSk7XFxuICAgICAgICAgICAgICAgIGl2ZWM0IHgwMSA9IGl2ZWM0KG1heChzb3VyY2VGcmFjLnh3LCB2ZWMyKDAuMCkpLCBtaW4oaW5wdXRXSCAtIDEuMCwgY2VpbChzb3VyY2VGcmFjLnh3KSkpO1xcbiAgICAgICAgICAgICAgICBpdmVjNCB4MTAgPSBpdmVjNChtYXgoc291cmNlRnJhYy56eSwgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy56eSkpKTtcXG4gICAgICAgICAgICAgICAgaXZlYzQgeDExID0gaXZlYzQobWF4KHNvdXJjZUZyYWMuencsIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMuencpKSk7XFxuXFxuICAgICAgICAgICAgICAgIGJvb2wgaGFzTmV4dFJvdyA9IHJjLncgPCAke2YtMX07XFxuICAgICAgICAgICAgICAgIGJvb2wgaGFzTmV4dENvbCA9IHJjLnogPCAke2gtMX07XFxuXFxuICAgICAgICAgICAgICAgIC8vIHBhY2sgeDAwLCB4MDEsIHgxMCwgeDExJ3MgdG9wLWxlZnQgY29ybmVyIGludG8gb25lIHZlYzQgc3RydWN0dXJlXFxuICAgICAgICAgICAgICAgIHZlYzQgdG9wTGVmdCA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueCwgeDAwLnkpLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS54LCB4MDEueSkgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLngsIHgxMC55KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLngsIHgxMS55KSA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIHBhY2sgeDAwLCB4MDEsIHgxMCwgeDExJ3MgdG9wLXJpZ2h0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxcbiAgICAgICAgICAgICAgICB2ZWM0IHRvcFJpZ2h0ID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgIGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMC54LCB4MDAudyksXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLngsIHgwMS53KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTAueCwgeDEwLncpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTEueCwgeDExLncpIDogMC4wKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gcGFjayB4MDAsIHgwMSwgeDEwLCB4MTEncyBib3R0b20tbGVmdCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcXG4gICAgICAgICAgICAgICAgdmVjNCBib3R0b21MZWZ0ID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgIGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMC56LCB4MDAueSksXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLnosIHgwMS55KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTAueiwgeDEwLnkpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTEueiwgeDExLnkpIDogMC4wKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gcGFjayB4MDAsIHgwMSwgeDEwLCB4MTEncyBib3R0b20tcmlnaHQgY29ybmVyIGludG8gb25lIHZlYzQgc3RydWN0dXJlXFxuICAgICAgICAgICAgICAgIHZlYzQgYm90dG9tUmlnaHQgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLnosIHgwMC53KSxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueiwgeDAxLncpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC56LCB4MTAudykgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS56LCB4MTEudykgOiAwLjApO1xcblxcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGludGVycG9sYXRpb24gZnJhY3Rpb24gb24gdSBhbmQgdiBkaXJlY3Rpb25cXG4gICAgICAgICAgICAgICAgdmVjNCBmcmFjID0gdmVjNChzb3VyY2VGcmFjKSAtIGZsb29yKHNvdXJjZUZyYWMpO1xcbiAgICAgICAgICAgICAgICB2ZWM0IGNsYW1wRnJhYyA9IGNsYW1wKGZyYWMsIHZlYzQoMC4wKSwgdmVjNCgxLjApKTtcXG5cXG4gICAgICAgICAgICAgICAgdmVjNCB0b3AgPSBtaXgodG9wTGVmdCwgdG9wUmlnaHQsIGNsYW1wRnJhYy55d3l3KTtcXG4gICAgICAgICAgICAgICAgdmVjNCBib3R0b20gPSBtaXgoYm90dG9tTGVmdCwgYm90dG9tUmlnaHQsIGNsYW1wRnJhYy55d3l3KTtcXG4gICAgICAgICAgICAgICAgdmVjNCBuZXdWYWx1ZSA9IG1peCh0b3AsIGJvdHRvbSwgY2xhbXBGcmFjLnh4enopO1xcblxcbiAgICAgICAgICAgICAgICAke3Mub3V0cHV0fSA9IHZlYzQobmV3VmFsdWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7b3V0cHV0OntkaW1zOnAsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS5wYWNrZWR9LGhhc01haW46ITAsc2hhZGVyU291cmNlOnh9KX0sYz0oZSx0KT0+e2NvbnN0IG49ZVswXS5kaW1zO2xldCByLG89dC5zY2FsZXM7aWYoMD09PW8ubGVuZ3RoKXtjb25zdCBpPWVbdC5zY2FsZXNJbnB1dElkeF07aWYoaSYmMCE9PWkuc2l6ZSl7aWYoZVt0LnNpemVzSW5wdXRJZHhdKXRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIG9mIHNjYWxlcyBvciBzaXplcyBtdXN0IGJlIHByb3ZpZGVkIGFzIGlucHV0LlwiKTtvPXAoaSx0Lm1vZGUsdC5pc1Jlc2l6ZSl9ZWxzZXtjb25zdCBpPWVbdC5zaXplc0lucHV0SWR4XTtpZighaXx8MD09PWkuc2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJFaXRoZXIgc2NhbGVzIG9yIHNpemVzIE1VU1QgYmUgcHJvdmlkZWQgYXMgaW5wdXQuXCIpO3I9QXJyYXkuZnJvbShpLmludGVnZXJEYXRhKSxvPWQocixuLHQubW9kZSx0LmlzUmVzaXplKX19ZWxzZSBpZihlW3Quc2l6ZXNJbnB1dElkeF0pdGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgb2Ygc2NhbGVzIG9yIHNpemVzIG11c3QgYmUgcHJvdmlkZWQgYXMgaW5wdXQuXCIpO2NvbnN0IGk9cnx8bi5tYXAoKChlLHQpPT5NYXRoLmZsb29yKGUqb1t0XSkpKTtyZXR1cm5bbyxpXX0scD0oZSx0LG4pPT57Y29uc3Qgcj1BcnJheS5mcm9tKGUuZmxvYXREYXRhKTtyZXR1cm4oMCxzLnNjYWxlc1ZhbGlkYXRpb24pKHIsdCxuKSxyfSxkPShlLHQsbixyKT0+e2NvbnN0IG89dC5sZW5ndGgsaT1uZXcgQXJyYXkobyk7Zm9yKGxldCBuPTAscj1vO248cjtuKyspaWYoMD09PXRbbl0pe2lmKDAhPT1lW25dKXRocm93IG5ldyBFcnJvcihcIklucHV0IGRpbSBpcyB6ZXJvIGJ1dCByZXF1aXJlZCBvdXRwdXQgZGltIGlzIG5vbi16ZXJvLlwiKTtpW25dPTF9ZWxzZSBpW25dPWVbbl0vdFtuXTtyZXR1cm4oMCxzLnNjYWxlc1ZhbGlkYXRpb24pKGksbixyKSxpfX0sNTY1OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnNoYXBlPXZvaWQgMDtjb25zdCByPW4oOTI0MCk7dC5zaGFwZT0oZSx0KT0+KG8odCksW25ldyByLlRlbnNvcihbdFswXS5kaW1zLmxlbmd0aF0sXCJpbnQzMlwiLHZvaWQgMCx2b2lkIDAsbmV3IEludDMyQXJyYXkodFswXS5kaW1zKSldKTtjb25zdCBvPWU9PntpZighZXx8MSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIHJlcXVpcmVzIDEgaW5wdXQuXCIpfX0sMjQ0NDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5zbGljZVYxMD10LnBhcnNlU2xpY2VBdHRyaWJ1dGVzPXQuc2xpY2U9dm9pZCAwO2NvbnN0IHI9big0OTEwKSxvPW4oNjE0NSksaT1uKDcyNzMpLGE9big1NjM5KSxzPXtuYW1lOlwiU2xpY2VcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O3Quc2xpY2U9KGUsdCxuKT0+KGwodCksW2UucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT51KGUsdFswXSxuKX0pLHQpXSksdC5wYXJzZVNsaWNlQXR0cmlidXRlcz1lPT57Y29uc3QgdD1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcInN0YXJ0c1wiKSxuPWUuYXR0cmlidXRlcy5nZXRJbnRzKFwiZW5kc1wiKSxvPWUuYXR0cmlidXRlcy5nZXRJbnRzKFwiYXhlc1wiLFtdKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe3N0YXJ0czp0LGVuZHM6bixheGVzOm99KX07Y29uc3QgdT0oZSx0LG4pPT57Y29uc3Qgcj0wPT09bi5heGVzLmxlbmd0aD90LmRpbXMuc2xpY2UoMCkubWFwKCgoZSx0KT0+dCkpOm4uYXhlcyxvPWkuU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXMocix0LmRpbXMubGVuZ3RoKSx1PW4uc3RhcnRzLm1hcCgoKGUsbik9PmU+dC5kaW1zW29bbl1dLTE/dC5kaW1zW29bbl1dOmkuU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoZSx0LmRpbXNbb1tuXV0pKSksbD1uLmVuZHMubWFwKCgoZSxuKT0+ZT50LmRpbXNbb1tuXV0tMT90LmRpbXNbb1tuXV06aS5TaGFwZVV0aWwubm9ybWFsaXplQXhpcyhlLHQuZGltc1tvW25dXSkpKSxjPXQuZGltcy5zbGljZSgpLHA9W107Zm9yKGxldCBlPTA7ZTxvLmxlbmd0aDtlKyspY1tvW2VdXT1sW2VdLXVbZV0sdVtlXT4wJiZwLnB1c2goYG91dHB1dElkeFske29bZV19XSArPSAke3VbZV19O2ApO2NvbnN0IGQ9YFxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IG91dHB1dElkeFske2MubGVuZ3RofV0pIHtcXG4gICAgICAgICR7cC5qb2luKFwiXFxuICAgICAgXCIpfVxcbiAgICAgICAgcmV0dXJuIF9BKG91dHB1dElkeCk7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7b3V0cHV0OntkaW1zOmMsdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmR9KX0sbD1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTbGljZSByZXF1aXJlcyAxIGlucHV0LlwiKTtpZigtMT09PW8uTlVNQkVSX1RZUEVTLmluZGV4T2YoZVswXS50eXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfTt0LnNsaWNlVjEwPShlLHQpPT57cCh0KTtjb25zdCBuPWMoZSx0KTtyZXR1cm5bZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9PnUoZSx0WzBdLG4pfSksW3RbMF1dKV19O2NvbnN0IGM9KGUsdCk9PntpZighZS5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIodFsxXS5kYXRhSWQpfHwhZS5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIodFsyXS5kYXRhSWQpfHx0Lmxlbmd0aD49NCYmIWUuc2Vzc2lvbi5pc0luaXRpYWxpemVyKHRbM10uZGF0YUlkKXx8dC5sZW5ndGg+PTUmJiFlLnNlc3Npb24uaXNJbml0aWFsaXplcih0WzRdLmRhdGFJZCkpdGhyb3cgbmV3IEVycm9yKFwiZHluYW1pYyBzbGljZSBhdHRyaWJ1dGVzIGFyZSBub3QgYWxsb3dlZFwiKTtpZih0Lmxlbmd0aD49NSYmdFs0XS5pbnRlZ2VyRGF0YS5zb21lKChlPT4xIT09ZSkpKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBub24tMSBzdGVwcyBpcyBub3Qgc3VwcG9ydGVkIGZvciBTbGljZVwiKTtjb25zdCBuPUFycmF5LmZyb20odFsxXS5pbnRlZ2VyRGF0YSkscj1BcnJheS5mcm9tKHRbMl0uaW50ZWdlckRhdGEpLG89dC5sZW5ndGg+PTQ/QXJyYXkuZnJvbSh0WzNdLmludGVnZXJEYXRhKTpbXTtyZXR1cm57c3RhcnRzOm4sZW5kczpyLGF4ZXM6byxjYWNoZUtleTpgJHtvfTske259OyR7cn1gfX0scD1lPT57aWYoIWV8fGUubGVuZ3RoPDN8fGUubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBudW1iZXIuXCIpO2lmKFwiaW50MzJcIiE9PWVbMV0udHlwZXx8MSE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZihcImludDMyXCIhPT1lWzJdLnR5cGV8fDEhPT1lWzJdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoZS5sZW5ndGg+PTQmJihcImludDMyXCIhPT1lWzNdLnR5cGV8fDEhPT1lWzNdLmRpbXMubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKGUubGVuZ3RoPj01JiYoXCJpbnQzMlwiIT09ZVs0XS50eXBlfHwxIT09ZVs0XS5kaW1zLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX19LDgxNTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5zb2Z0bWF4VjEzPXQucGFyc2VTb2Z0bWF4QXR0cmlidXRlc1YxMz10LnBhcnNlU29mdG1heEF0dHJpYnV0ZXM9dC5zb2Z0bWF4PXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDcyNzMpLGk9big2NzU3KSxhPW4oNTYzOSkscz1uKDU3MDcpLHU9e25hbWU6XCJTb2Z0bWF4Q29tcHV0ZU1heFwiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkXX0sbD17bmFtZTpcIlNvZnRtYXhDb21wdXRlU2NhbGVcIixpbnB1dE5hbWVzOltcIkFcIixcIk1heFwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkLGEuVGV4dHVyZVR5cGUudW5wYWNrZWRdfSxjPXtuYW1lOlwiU29mdE1heFwiLGlucHV0TmFtZXM6W1wiQVwiLFwiTWF4XCIsXCJOb3JtXCJdLGlucHV0VHlwZXM6W2EuVGV4dHVyZVR5cGUudW5wYWNrZWQsYS5UZXh0dXJlVHlwZS51bnBhY2tlZCxhLlRleHR1cmVUeXBlLnVucGFja2VkXX07dC5zb2Z0bWF4PShlLHQsbik9PntnKHQpO2NvbnN0IHI9dFswXS5kaW1zLnNsaWNlKCksaT1vLlNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKG4uYXhpcyxyLmxlbmd0aCksYT1vLlNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24ocixpKSxzPW8uU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKHIsaSk7cmV0dXJuIHAoZSx0LG4sYSxzKX0sdC5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzPWU9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXhpczplLmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiLDEpfSksdC5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzPWU9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXhpczplLmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiLC0xKX0pLHQuc29mdG1heFYxMz0oZSx0LG4pPT57Zyh0KTtjb25zdCBpPXRbMF0uZGltcy5zbGljZSgpLGE9by5TaGFwZVV0aWwubm9ybWFsaXplQXhpcyhuLmF4aXMsaS5sZW5ndGgpLHU9aS5sZW5ndGgsbD1hIT09dS0xLGM9W107bGV0IGQsZj1bXSxoPVtdO2wmJihmPUFycmF5LmZyb20oe2xlbmd0aDp1fSkubWFwKCgoZSx0KT0+dCkpLGZbYV09dS0xLGZbdS0xXT1hLGYubWFwKChlPT5jLnB1c2goaVtlXSkpKSxkPSgwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7cGVybTpmfSksaD0oMCxzLnRyYW5zcG9zZSkoZSx0LGQpKTtjb25zdCBtPWw/by5TaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKGMsdS0xKTpvLlNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24oaSx1LTEpLGI9bD9vLlNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihjLHUtMSk6by5TaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oaSx1LTEpLHk9cChlLGw/aDp0LG4sbSxiKTtyZXR1cm4gbD8oMCxzLnRyYW5zcG9zZSkoZSx5LGQpOnl9O2NvbnN0IHA9KGUsdCxuLHIsbyk9Pntjb25zdCBpPWQoZSx0WzBdLHIsbyxbcl0pLGE9ZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9Pml9KSx0KSxzPWYoZSx0WzBdLHIsbyxpLm91dHB1dC5kaW1zLFtyXSkscD1lLnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbCkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+c30pLFt0WzBdLGFdKSxnPWgoZSx0WzBdLHIsbyxpLm91dHB1dC5kaW1zLHMub3V0cHV0LmRpbXMpO3JldHVybltlLnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYykse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+Z30pLFt0WzBdLGEscF0pXX0sZD0oZSx0LG4scixvKT0+e2NvbnN0W3MsbF09ZS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQodC5kaW1zLGEuVGV4dHVyZVR5cGUudW5wYWNrZWQpLGM9by5sZW5ndGg7aWYobjwxfHxyPDEpdGhyb3cgbmV3IEVycm9yKFwiTG9naWNhbCByb3cgY291bnQgTiBhbmQgZmVhdHVyZSBjb3VudCBEIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIik7aWYoMSE9PW8ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkRpbWVuc2lvbmFsaXR5IG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIDFcIik7aWYob1swXSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnRcIik7Y29uc3QgcD0oMCxpLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxkPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludFske2N9XSBpbmRpY2VzKSB7XFxuICAgICAgICBpbnQgbG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0ID0gaW5kaWNlc1swXSAqICR7cn07XFxuXFxuICAgICAgICBmbG9hdCBtYXggPSBnZXRDb2xvckFzRmxvYXQoJHtwLnRleHR1cmUyRH0oQSwgb2Zmc2V0VG9Db29yZHMobG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0LCAke3N9LFxcbiAgICAgICAgJHtsfSApKSk7XFxuICAgICAgICBmb3IoaW50IGk9MTsgaTwke3J9OyArK2kpXFxuICAgICAgICB7XFxuICAgICAgICAgIGZsb2F0IGN1cnJlbnQgPSBnZXRDb2xvckFzRmxvYXQoJHtwLnRleHR1cmUyRH0oQSwgb2Zmc2V0VG9Db29yZHMobG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0ICsgaSxcXG4gICAgICAgICAgICAke3N9LCAke2x9KSkpO1xcbiAgICAgICAgICBpZihjdXJyZW50ID4gbWF4KVxcbiAgICAgICAgICBtYXggPSBjdXJyZW50O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIG1heDtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtvdXRwdXQ6e2RpbXM6byx0eXBlOnQudHlwZSx0ZXh0dXJlVHlwZTphLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6ZH0pfSxmPShlLHQsbixyLG8scyk9Pntjb25zdFt1LGNdPWUuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KHQuZGltcyxhLlRleHR1cmVUeXBlLnVucGFja2VkKSxwPXMubGVuZ3RoO2lmKG48MXx8cjwxKXRocm93IG5ldyBFcnJvcihcIkxvZ2ljYWwgcm93IGNvdW50IE4gYW5kIGZlYXR1cmUgY291bnQgRCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpO2lmKDEhPT1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgb3V0cHV0IHNob3VsZCBiZSAxXCIpO2lmKHNbMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50XCIpO2lmKDEhPT1vLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDFcIik7aWYob1swXSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgb2YgdGhlIGludGVybWVkaWF0ZSByZXN1bHRzIHNob3VsZCBiZSBlcXVhbCB0byBsb2dpY2FsIHJvdyBjb3VudFwiKTtjb25zdCBkPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludFske3B9XSBpbmRpY2VzKSB7XFxuICAgICAgICBpbnQgbG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0ID0gaW5kaWNlc1swXSAqICR7cn07XFxuXFxuICAgICAgICBmbG9hdCBub3JtX2ZhY3RvciA9IDAuMDtcXG4gICAgICAgIGZsb2F0IG1heCA9IF9NYXgoaW5kaWNlcyk7XFxuICAgICAgICBmb3IoaW50IGk9MDsgaTwke3J9OyArK2kpXFxuICAgICAgICB7XFxuICAgICAgICAgIG5vcm1fZmFjdG9yICs9IGV4cChnZXRDb2xvckFzRmxvYXQoJHsoMCxpLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKS50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCArIGksXFxuICAgICAgICAgICAgJHt1fSwgJHtjfSkpKSAtIG1heCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gbm9ybV9mYWN0b3I7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxsKSx7b3V0cHV0OntkaW1zOnMsdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmR9KX0saD0oZSx0LG4scixvLGkpPT57Y29uc3Rbcyx1XT1lLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh0LmRpbXMsYS5UZXh0dXJlVHlwZS51bnBhY2tlZCksbD10LmRpbXMubGVuZ3RoO2lmKG48MXx8cjwxKXRocm93IG5ldyBFcnJvcihcIkxvZ2ljYWwgcm93IGNvdW50IE4gYW5kIGZlYXR1cmUgY291bnQgRCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpO2lmKDEhPT1vLmxlbmd0aHx8MSE9PWkubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkRpbWVuc2lvbmFsaXR5IG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgMVwiKTtpZihvWzBdIT09bnx8aVswXSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgb2YgdGhlIGludGVybWVkaWF0ZSByZXN1bHRzIHNob3VsZCBiZSBlcXVhbCB0byBsb2dpY2FsIHJvdyBjb3VudFwiKTtjb25zdCBwPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludFske2x9XSBpbmRpY2VzKSB7XFxuXFxuICAgICAgLy8gZ2V0IG9mZnNldCBvZiBjdXJyZW50IGxvZ2ljYWwgdGVuc29yIGluZGV4IGZyb20gdGhlIDItRCB0ZXh0dXJlIGNvb3JkaW5hdGVzIChUZXhDb29yZHMpXFxuICAgICAgaW50IG9mZnNldCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtzfSwgJHt1fSk7XFxuXFxuICAgICAgLy9kZXRlcm1pbmUgdGhlIGxvZ2ljYWwgcm93IGZvciB0aGlzIGluZGV4XFxuICAgICAgaW50IGxvZ2ljYWxfcm93X2luZGV4WzFdO1xcbiAgICAgIGxvZ2ljYWxfcm93X2luZGV4WzBdID0gb2Zmc2V0IC8gJHtyfTtcXG5cXG4gICAgICBmbG9hdCBub3JtX2ZhY3RvciA9IF9Ob3JtKGxvZ2ljYWxfcm93X2luZGV4KTtcXG5cXG4gICAgICAvLyBhdm9pZCBwb3NzaWJsZSBkaXZpc2lvbiBieSAwXFxuICAgICAgLy8gaWYgbm9ybV9mYWNvciBpcyAwLCBhbGwgZWxlbWVudHMgYXJlIHplcm9cXG4gICAgICAvLyBpZiBzbywgcmV0dXJuIDBcXG4gICAgICBpZihub3JtX2ZhY3RvciA9PSAwLjApXFxuICAgICAgICByZXR1cm4gMC4wO1xcblxcbiAgICAgIHJldHVybiBleHAoX0EoaW5kaWNlcykgLSBfTWF4KGxvZ2ljYWxfcm93X2luZGV4KSkgLyBub3JtX2ZhY3RvcjtcXG4gICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxjKSx7b3V0cHV0OntkaW1zOnQuZGltcyx0eXBlOnQudHlwZSx0ZXh0dXJlVHlwZTphLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6cH0pfSxnPWU9PntpZighZXx8MSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNvZnRtYXggcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoXCJmbG9hdDMyXCIhPT1lWzBdLnR5cGUmJlwiZmxvYXQ2NFwiIT09ZVswXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZVwiKX19LDU2NDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZVNwbGl0QXR0cmlidXRlcz10LnNwbGl0PXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDcyNzMpLGk9big1NjM5KSxhPXtuYW1lOlwiU3BsaXRcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O3Quc3BsaXQ9KGUsdCxuKT0+e2wodCk7Y29uc3Qgcj1vLlNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKG4uYXhpcyx0WzBdLmRpbXMubGVuZ3RoKSxpPXMoZSx0LHIsbiksYz1bXTtmb3IobGV0IG89MDtvPGk7KytvKWMucHVzaChlLnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpgJHtuLmNhY2hlS2V5fTske299YCxnZXQ6KCk9PnUoZSx0WzBdLG4scixvKX0pLHQpKTtyZXR1cm4gY30sdC5wYXJzZVNwbGl0QXR0cmlidXRlcz1lPT57Y29uc3QgdD1lLmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiLDApLG49ZS5hdHRyaWJ1dGVzLmdldEludHMoXCJzcGxpdFwiLFtdKSxvPWUub3V0cHV0cy5sZW5ndGg7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtheGlzOnQsc3BsaXQ6bixudW1PdXRwdXRzOm99KX07Y29uc3Qgcz0oZSx0LG4scik9Pntjb25zdFssaV09by5TcGxpdFV0aWwuc3BsaXRTaGFwZSh0WzBdLmRpbXMsbixyLnNwbGl0LHIubnVtT3V0cHV0cyk7cmV0dXJuIGkubGVuZ3RofSx1PShlLHQsbixyLHMpPT57Y29uc3RbdSxsXT1vLlNwbGl0VXRpbC5zcGxpdFNoYXBlKHQuZGltcyxyLG4uc3BsaXQsbi5udW1PdXRwdXRzKSxjPWxbc10scD11W3NdLGQ9YFxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtwLmxlbmd0aH1dKSB7XFxuICAgICAgICBpbmRpY2VzWyR7cn1dICs9ICR7Y307XFxuICAgICAgICByZXR1cm4gX0EoaW5kaWNlcyk7XFxuICAgICAgfVxcbiAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpgJHtuLmNhY2hlS2V5fToke3N9YCxvdXRwdXQ6e2RpbXM6cCx0eXBlOnQudHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6ZH0pfSxsPWU9PntpZighZXx8MSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNwbGl0IHJlcXVpcmVzIG9uZSBpbnB1dC5cIik7aWYoXCJpbnQ4XCIhPT1lWzBdLnR5cGUmJlwidWludDhcIiE9PWVbMF0udHlwZSYmXCJpbnQxNlwiIT09ZVswXS50eXBlJiZcInVpbnQxNlwiIT09ZVswXS50eXBlJiZcImludDMyXCIhPT1lWzBdLnR5cGUmJlwidWludDMyXCIhPT1lWzBdLnR5cGUmJlwiZmxvYXQzMlwiIT09ZVswXS50eXBlJiZcImZsb2F0NjRcIiE9PWVbMF0udHlwZSYmXCJib29sXCIhPT1lWzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX19LDU0MTY6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VTcXVlZXplQXR0cmlidXRlcz10LnNxdWVlemVWMTM9dC5zcXVlZXplPXZvaWQgMDtjb25zdCByPW4oNzI3Myk7dC5zcXVlZXplPShlLHQsbik9PntvKHQpO2NvbnN0IGk9ci5TaGFwZVV0aWwuc3F1ZWV6ZVNoYXBlKHRbMF0uZGltcyxuKTtyZXR1cm5bZS5yZXNoYXBlVW5wYWNrZWQodFswXSxpKV19LHQuc3F1ZWV6ZVYxMz0oZSxuKT0+KGkobiksKDAsdC5zcXVlZXplKShlLFtuWzBdXSxBcnJheS5mcm9tKG5bMV0uaW50ZWdlckRhdGEpKSksdC5wYXJzZVNxdWVlemVBdHRyaWJ1dGVzPWU9PmUuYXR0cmlidXRlcy5nZXRJbnRzKFwiYXhlc1wiKTtjb25zdCBvPWU9PntpZighZXx8MSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNxdWVlemUgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoXCJzdHJpbmdcIj09PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHRlbnNvciB0eXBlcy5cIil9LGk9ZT0+e2lmKCFlfHwyIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiU3F1ZWV6ZSByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoXCJpbnQzMlwiIT09ZVsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSwxMjQwOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnN1bT12b2lkIDA7Y29uc3Qgcj1uKDY3NTcpLG89big1NjM5KTt0LnN1bT0oZSx0KT0+e2EodCk7Y29uc3Qgbj17bmFtZTpcIlN1bVwiLGlucHV0TmFtZXM6dC5tYXAoKChlLHQpPT5gWCR7dH1gKSksaW5wdXRUeXBlczpuZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwoby5UZXh0dXJlVHlwZS51bnBhY2tlZCl9O3JldHVybltlLnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+aShlLHQsbil9KSx0KV19O2NvbnN0IGk9KGUsdCxuKT0+e2NvbnN0IGk9KDAsci5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksYT10WzBdLmRpbXMuc2xpY2UoKSxzPWBcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IHJlc3VsdCA9ICR7dC5tYXAoKChlLHQpPT5gJHtpLnRleHR1cmUyRH0oWCR7dH0sVGV4Q29vcmRzKWApKS5qb2luKFwiICsgXCIpfTtcXG4gICAgICAgICR7aS5vdXRwdXR9ID0gcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtvdXRwdXQ6e2RpbXM6YSx0eXBlOnRbMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnVucGFja2VkfSxoYXNNYWluOiEwLHNoYWRlclNvdXJjZTpzfSl9LGE9ZT0+e2lmKCFlfHwwPT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiU3VtIHJlcXVpcmVzIGlucHV0cy5cIik7Y29uc3QgdD1lWzBdLmRpbXMubGVuZ3RoO2ZvcihsZXQgbj0xO248ZS5sZW5ndGg7bisrKXtpZih0IT09ZVtuXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBzaGFwZXMgYXJlIG1pc21hdGNoZWQuXCIpO2ZvcihsZXQgcj0wO3I8dDtyKyspaWYoZVswXS5kaW1zW3JdIT09ZVtuXS5kaW1zW3JdKXRocm93IG5ldyBFcnJvcihcIklucHV0IHNoYXBlcyBhcmUgbm90IG1hdGNoZWQuXCIpfWlmKFwiZmxvYXQzMlwiIT09ZVswXS50eXBlJiZcImZsb2F0NjRcIiE9PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2ZvcihsZXQgdD0xO3Q8ZS5sZW5ndGg7dCsrKWlmKGVbMF0udHlwZSE9PWVbdF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlcyBhcmUgbm90IG1hdGNoZWQuXCIpfX0sNTk0NDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC50aWxlPXZvaWQgMDtjb25zdCByPW4oNjE0NSksbz1uKDU2MzkpO3QudGlsZT0oZSx0KT0+e2EodCk7Y29uc3Qgbj17bmFtZTpcIlRpbGVcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O3JldHVybltlLnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+aShlLHQsbil9KSx0KV19O2NvbnN0IGk9KGUsdCxuKT0+e2NvbnN0IHI9dFswXS5kaW1zLnNsaWNlKCksaT1uZXcgQXJyYXkoci5sZW5ndGgpLGE9W107Zm9yKGxldCBlPTA7ZTxyLmxlbmd0aDtlKyspaVtlXT1yW2VdKnRbMV0ubnVtYmVyRGF0YVtlXSxhLnB1c2goYGlucHV0SWR4WyR7ZX1dID0gaW50KG1vZChmbG9hdChvdXRwdXRJZHhbJHtlfV0pLCAke3JbZV19LikpO2ApO2NvbnN0IHM9aS5sZW5ndGgsdT1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7c31dKSB7XFxuICAgICAgICBpbnQgaW5wdXRJZHhbJHtzfV07XFxuICAgICAgICAke2Euam9pbihcIlxcblwiKX1cXG4gICAgICAgIHJldHVybiBfQShpbnB1dElkeCk7XFxuICAgICAgfVxcbiAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczppLHR5cGU6dFswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTp1fSl9LGE9ZT0+e2lmKCFlfHwyIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSByZXF1aXJlcyAyIGlucHV0LlwiKTtpZigxIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2Vjb25kIGlucHV0IHNoYXBlIG11c3QgMSBkaW1lbnNpb24uXCIpO2lmKGVbMV0uZGltc1swXSE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYoLTE9PT1yLk5VTUJFUl9UWVBFUy5pbmRleE9mKGVbMF0udHlwZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZihcImludDMyXCIhPT1lWzFdLnR5cGUmJlwiaW50MTZcIiE9PWVbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlcGVhdCB0eXBlLlwiKX19LDU3MDc6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzPXQudHJhbnNwb3NlPXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDcyNzMpLGk9big1NjM5KSxhPXtuYW1lOlwiVHJhbnNwb3NlXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTt0LnRyYW5zcG9zZT0oZSx0LG4pPT4ocCh0KSxbZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9PnMoZSx0WzBdLG4ucGVybSl9KSx0KV0pLHQucGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzPWU9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7cGVybTplLmF0dHJpYnV0ZXMuZ2V0SW50cyhcInBlcm1cIixbXSl9KTtjb25zdCBzPShlLHQsbik9Pntjb25zdCByPXQuZGltcztuPXUocixuKTtjb25zdCBvPWwocixuKSxzPXIubGVuZ3RoLHA9YFxcbiAgICAgICR7YyhcInBlcm1cIixuLHMpfVxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtzfV0pIHtcXG4gICAgICAgIGludCBhWyR7c31dO1xcbiAgICAgICAgcGVybShhLCBpbmRpY2VzKTtcXG4gICAgICAgIHJldHVybiBfQShhKTtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtvdXRwdXQ6e2RpbXM6byx0eXBlOnQudHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6cH0pfSx1PShlLHQpPT4odCYmdC5sZW5ndGghPT1lLmxlbmd0aCYmKHQ9Wy4uLmUua2V5cygpXS5yZXZlcnNlKCkpLHQpLGw9KGUsdCk9Pih0PXUoZSx0KSxvLlNoYXBlVXRpbC5zb3J0QmFzZWRPblBlcm0oZSx0KSksYz0oZSx0LG4pPT57Y29uc3Qgcj1bXTtyLnB1c2goYHZvaWQgJHtlfShvdXQgaW50IGFbJHtufV0sIGludCBzcmNbJHtufV0pIHtgKTtmb3IobGV0IGU9MDtlPG47KytlKXIucHVzaChgXFx0YVske3RbZV19XT1zcmNbJHtlfV07YCk7cmV0dXJuIHIucHVzaChcIlxcdH1cIiksci5qb2luKFwiXFxuXCIpfSxwPWU9PntpZighZXx8MSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9zZSByZXF1aXJlcyAxIGlucHV0LlwiKTtpZihcImZsb2F0MzJcIiE9PWVbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT1lWzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGJlIGZsb2F0IHRlbnNvclwiKX19LDI0ODg6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZW5jb2RlQXNVaW50OD12b2lkIDA7Y29uc3Qgcj1uKDY3NTcpLG89big1NjM5KTt0LmVuY29kZUFzVWludDg9KGUsdCk9Pntjb25zdCBuPXQuc2hhcGUsaT0oMCxyLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxhPWBcXG4gICAgY29uc3QgZmxvYXQgRkxPQVRfTUFYID0gMS43MDE0MTE4NGUzODtcXG4gICAgY29uc3QgZmxvYXQgRkxPQVRfTUlOID0gMS4xNzU0OTQzNWUtMzg7XFxuXFxuICAgIGJvb2wgaXNOYU4oZmxvYXQgdmFsKSB7XFxuICAgICAgcmV0dXJuICh2YWwgPCAxLjAgfHwgMC4wIDwgdmFsIHx8IHZhbCA9PSAwLjApID8gZmFsc2UgOiB0cnVlO1xcbiAgICB9XFxuXFxuICAgIGhpZ2hwIHZlYzQgZW5jb2RlQXNVaW50OChoaWdocCBmbG9hdCB2KSB7XFxuICAgICAgaWYgKGlzTmFOKHYpKSB7XFxuICAgICAgICByZXR1cm4gdmVjNCgyNTUsIDI1NSwgMjU1LCAyNTUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBoaWdocCBmbG9hdCBhdiA9IGFicyh2KTtcXG5cXG4gICAgICBpZihhdiA8IEZMT0FUX01JTikge1xcbiAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG4gICAgICB9IGVsc2UgaWYodiA+IEZMT0FUX01BWCkge1xcbiAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsIDEyOC4wLCAxMjcuMCkgLyAyNTUuMDtcXG4gICAgICB9IGVsc2UgaWYodiA8IC1GTE9BVF9NQVgpIHtcXG4gICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAgMTI4LjAsIDI1NS4wKSAvIDI1NS4wO1xcbiAgICAgIH1cXG5cXG4gICAgICBoaWdocCB2ZWM0IGMgPSB2ZWM0KDAsMCwwLDApO1xcblxcbiAgICAgIGhpZ2hwIGZsb2F0IGUgPSBmbG9vcihsb2cyKGF2KSk7XFxuICAgICAgaGlnaHAgZmxvYXQgbSA9IGV4cDIoZnJhY3QobG9nMihhdikpKSAtIDEuMDtcXG5cXG4gICAgICBjWzJdID0gZmxvb3IoMTI4LjAgKiBtKTtcXG4gICAgICBtIC09IGNbMl0gLyAxMjguMDtcXG4gICAgICBjWzFdID0gZmxvb3IoMzI3NjguMCAqIG0pO1xcbiAgICAgIG0gLT0gY1sxXSAvIDMyNzY4LjA7XFxuICAgICAgY1swXSA9IGZsb29yKDgzODg2MDguMCAqIG0pO1xcblxcbiAgICAgIGhpZ2hwIGZsb2F0IGViaWFzID0gZSArIDEyNy4wO1xcbiAgICAgIGNbM10gPSBmbG9vcihlYmlhcyAvIDIuMCk7XFxuICAgICAgZWJpYXMgLT0gY1szXSAqIDIuMDtcXG4gICAgICBjWzJdICs9IGZsb29yKGViaWFzKSAqIDEyOC4wO1xcblxcbiAgICAgIGNbM10gKz0gMTI4LjAgKiBzdGVwKDAuMCwgLXYpO1xcblxcbiAgICAgIHJldHVybiBjIC8gMjU1LjA7XFxuICAgIH1cXG5cXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIGZsb2F0IHZhbHVlID0gJHtpLnRleHR1cmUyRH0oWCxUZXhDb29yZHMpLnI7XFxuICAgICAgJHtpLm91dHB1dH0gPSBlbmNvZGVBc1VpbnQ4KHZhbHVlKTtcXG4gICAgfWAscz17bmFtZTpcIlVpbnQ4RW5jb2RlXCIsaW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF0saW5wdXROYW1lczpbXCJYXCJdLG91dHB1dDp7ZGltczpuLHR5cGU6dC50ZW5zb3IudHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLmRvd25sb2FkVWludDhBc0Zsb2F0fSxzaGFkZXJTb3VyY2U6YSxoYXNNYWluOiEwfTtyZXR1cm4gZS5leGVjdXRlUHJvZ3JhbShzLFt0LnRlbnNvcl0pfX0sOTA4NzooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC50YW5oPXQudGFuPXQuc3FydD10LnNpbj10LnNpZ21vaWQ9dC5yZWx1PXQubm90PXQubmVnPXQubG9nPXQucGFyc2VMZWFreVJlbHVBdHRyaWJ1dGVzPXQubGVha3lSZWx1PXQuaWRlbnRpdHk9dC5mbG9vcj10LmV4cD10LnBhcnNlRWx1QXR0cmlidXRlcz10LmVsdT10LmNvcz10LmNlaWw9dC5jbGlwVjExPXQucGFyc2VDbGlwQXR0cmlidXRlcz10LmNsaXA9dC5hdGFuPXQuYXNpbj10LmFjb3M9dC5hYnM9dC5nbHNsVGFuaD10Lmdsc2xUYW49dC5nbHNsU3FydD10Lmdsc2xTaWdtb2lkPXQuZ2xzbFJlbHU9dC5nbHNsU2luPXQuZ2xzbE5vdD10Lmdsc2xOZWc9dC5nbHNsTG9nPXQuZ2xzbExlYWt5UmVsdT10Lmdsc2xJZGVudGl0eT10Lmdsc2xDbGlwPXQuZ2xzbEZsb29yPXQuZ2xzbEV4cD10Lmdsc2xFbHU9dC5nbHNsQ29zPXQuZ2xzbENlaWw9dC5nbHNsQXRhbj10Lmdsc2xBc2luPXQuZ2xzbEFjb3M9dC5nbHNsQWJzPXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDcyNzMpLGk9bigxOTk3KSxhPW4oNjc1Nykscz1uKDU2MzkpO2Z1bmN0aW9uIHUoKXtyZXR1cm4gJChcImFic1wiKX1mdW5jdGlvbiBsKCl7cmV0dXJuICQoXCJhY29zXCIpfWZ1bmN0aW9uIGMoKXtyZXR1cm4gJChcImFzaW5cIil9ZnVuY3Rpb24gcCgpe3JldHVybiAkKFwiYXRhblwiKX1mdW5jdGlvbiBkKCl7cmV0dXJuICQoXCJjZWlsXCIpfWZ1bmN0aW9uIGYoKXtyZXR1cm4gJChcImNvc1wiKX1mdW5jdGlvbiBoKGUpe2NvbnN0IHQ9XCJlbHVcIjtyZXR1cm57Ym9keTpgXFxuICBjb25zdCBmbG9hdCBhbHBoYSA9IGZsb2F0KCR7ZX0pO1xcblxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gYSA+PSAwLjAgPyBhOiAoZXhwKGEpIC0gMS4wKSAqIGFscGhhO1xcbiAgfVxcbiAgdmVjNCAke3R9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIHZlYzQoJHt0fV8odi54KSwgJHt0fV8odi55KSwgJHt0fV8odi56KSwgJHt0fV8odi53KSk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGcoKXtyZXR1cm4gJChcImV4cFwiKX1mdW5jdGlvbiBtKCl7cmV0dXJuICQoXCJmbG9vclwiKX1mdW5jdGlvbiBiKGUsdCl7Y29uc3Qgbj1cImNsaXBcIjtyZXR1cm57Ym9keTpgXFxuICBjb25zdCBmbG9hdCBtaW4gPSBmbG9hdCgke2V9KTtcXG4gIGNvbnN0IGZsb2F0IG1heCA9IGZsb2F0KCR7dH0pO1xcblxcbiAgZmxvYXQgJHtufV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gY2xhbXAoYSwgbWluLCBtYXgpO1xcbiAgfVxcbiAgdmVjNCAke259Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIGNsYW1wKHYsIG1pbiwgbWF4KTtcXG4gIH1cXG4gIGAsbmFtZTpuLHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24geSgpe2NvbnN0IGU9XCJpbmRlbnRpdHlcIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9XyhmbG9hdCBhKSB7XFxuICAgIHJldHVybiBhO1xcbiAgfVxcbiAgdmVjNCAke2V9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIHY7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIHcoZSl7Y29uc3QgdD1cImxlYWt5UmVsdVwiO3JldHVybntib2R5OmBcXG4gIGNvbnN0IGZsb2F0IGFscGhhID0gZmxvYXQoJHtlfSk7XFxuXFxuICBmbG9hdCAke3R9XyhmbG9hdCBhKSB7XFxuICAgIHJldHVybiBhIDwgMC4wID8gYSAqIGFscGhhIDogYTtcXG4gIH1cXG4gIHZlYzQgJHt0fV8odmVjNCB2KSB7XFxuICAgIHJldHVybiB2ZWM0KCR7dH1fKHYueCksICR7dH1fKHYueSksICR7dH1fKHYueiksICR7dH1fKHYudykpO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBfKCl7cmV0dXJuICQoXCJsb2dcIil9ZnVuY3Rpb24gdigpe2NvbnN0IGU9XCJuZWdcIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9XyhmbG9hdCBhKSB7XFxuICAgIHJldHVybiAtYTtcXG4gIH1cXG4gIHZlYzQgJHtlfV8odmVjNCB2KSB7XFxuICAgIHJldHVybiAtdjtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24geCgpe2NvbnN0IGU9XCJub3RcIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9XyhmbG9hdCBhKSB7XFxuICAgIHJldHVybiBmbG9hdCggISBib29sKGEpICk7XFxuICB9XFxuICBib29sICR7ZX1fKGJvb2wgYSkge1xcbiAgICByZXR1cm4gIWE7XFxuICB9XFxuICB2ZWM0ICR7ZX1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gdmVjNCghYm9vbCh2LngpLCAhYm9vbCh2LnkpLCAhYm9vbCh2LnopLCAhYm9vbCh2LncpKTtcXG4gIH1cXG4gIGJ2ZWM0ICR7ZX1fKGJ2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIGJ2ZWM0KCF2LngsICF2LnksICF2LnosICF2LncpO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBUKCl7cmV0dXJuICQoXCJzaW5cIil9ZnVuY3Rpb24gUygpe2NvbnN0IGU9XCJyZWx1XCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gbWF4KCBhLCAwLjAgKTtcXG4gIH1cXG4gIHZlYzQgJHtlfV8odmVjNCB2KSB7XFxuICAgIHJldHVybiBtYXgoIHYsIDAuMCApO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBPKCl7Y29uc3QgZT1cInNpZ21vaWRcIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9XyhmbG9hdCBhKSB7XFxuICAgIHJldHVybiAxLjAgLyAoMS4wICsgZXhwKC1hKSk7XFxuICB9XFxuICB2ZWM0ICR7ZX1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtdikpO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBBKCl7cmV0dXJuICQoXCJzcXJ0XCIpfWZ1bmN0aW9uIEUoKXtyZXR1cm4gJChcInRhblwiKX1mdW5jdGlvbiBJKCl7Y29uc3QgZT1cInRhbmhcIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9XyhmbG9hdCBhKSB7XFxuICAgIGEgPSBjbGFtcChhLCAtMTAuLCAxMC4pO1xcbiAgICBhID0gZXhwKDIuKmEpO1xcbiAgICByZXR1cm4gKGEgLSAxLikgLyAoYSArIDEuKTtcXG4gIH1cXG4gIHZlYzQgJHtlfV8odmVjNCB2KSB7XFxuICAgIHYgPSBjbGFtcCh2LCAtMTAuLCAxMC4pO1xcbiAgICB2ID0gZXhwKDIuKnYpO1xcbiAgICByZXR1cm4gKHYgLSAxLikgLyAodiArIDEuKTtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gJChlKXtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9XyhmbG9hdCBhKSB7XFxuICAgIHJldHVybiAke2V9KGEpO1xcbiAgfVxcbiAgdmVjNCAke2V9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuICR7ZX0odik7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fXQuZ2xzbEFicz11LHQuZ2xzbEFjb3M9bCx0Lmdsc2xBc2luPWMsdC5nbHNsQXRhbj1wLHQuZ2xzbENlaWw9ZCx0Lmdsc2xDb3M9Zix0Lmdsc2xFbHU9aCx0Lmdsc2xFeHA9Zyx0Lmdsc2xGbG9vcj1tLHQuZ2xzbENsaXA9Yix0Lmdsc2xJZGVudGl0eT15LHQuZ2xzbExlYWt5UmVsdT13LHQuZ2xzbExvZz1fLHQuZ2xzbE5lZz12LHQuZ2xzbE5vdD14LHQuZ2xzbFNpbj1ULHQuZ2xzbFJlbHU9Uyx0Lmdsc2xTaWdtb2lkPU8sdC5nbHNsU3FydD1BLHQuZ2xzbFRhbj1FLHQuZ2xzbFRhbmg9STtjb25zdCBQPShlLHQsbixyKT0+e2NvbnN0IG89ZS5zZXNzaW9uLnBhY2s/cy5UZXh0dXJlVHlwZS5wYWNrZWQ6cy5UZXh0dXJlVHlwZS51bnBhY2tlZCxpPXtuYW1lOm4ubmFtZSxpbnB1dFR5cGVzOltvXSxpbnB1dE5hbWVzOltcIkFcIl0sY2FjaGVIaW50OnJ9O3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30saSkse2dldDooKT0+KChlLHQsbixyKT0+e2NvbnN0IG89ZS5zZXNzaW9uLnBhY2s/cy5UZXh0dXJlVHlwZS5wYWNrZWQ6cy5UZXh0dXJlVHlwZS51bnBhY2tlZCxpPSgwLGEuZ2V0R2xzbCkoZS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dDp7ZGltczpuLmRpbXMsdHlwZTpuLnR5cGUsdGV4dHVyZVR5cGU6b30sc2hhZGVyU291cmNlOmBcXG4gICAgICR7ci5ib2R5fVxcbiAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICB2ZWM0IHYgPSAke2kudGV4dHVyZTJEfShBLCBUZXhDb29yZHMpO1xcbiAgICAgICB2ID0gJHtyLm5hbWV9Xyh2KTtcXG4gICAgICAgJHtpLm91dHB1dH0gPSB2O1xcbiAgICAgfVxcbiAgICAgYCxoYXNNYWluOiEwfSl9KShlLGksdCxuKX0pfTt0LmFicz0oZSx0KT0+W2UucnVuKFAoZSx0WzBdLHUoKSksdCldLHQuYWNvcz0oZSx0KT0+W2UucnVuKFAoZSx0WzBdLGwoKSksdCldLHQuYXNpbj0oZSx0KT0+W2UucnVuKFAoZSx0WzBdLGMoKSksdCldLHQuYXRhbj0oZSx0KT0+W2UucnVuKFAoZSx0WzBdLHAoKSksdCldLHQuY2xpcD0oZSx0LG4pPT5bZS5ydW4oUChlLHRbMF0sYihuLm1pbixuLm1heCksbi5jYWNoZUtleSksdCldLHQucGFyc2VDbGlwQXR0cmlidXRlcz1lPT4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe21pbjplLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJtaW5cIixvLk1JTl9DTElQKSxtYXg6ZS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibWF4XCIsby5NQVhfQ0xJUCl9KSx0LmNsaXBWMTE9KGUsbik9Pntjb25zdCByPUQoZSxuKTtyZXR1cm4oMCx0LmNsaXApKGUsW25bMF1dLHIpfTtjb25zdCBEPShlLHQpPT57aWYodC5sZW5ndGg+PTMmJighZS5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIodFsxXS5kYXRhSWQpfHwhZS5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIodFsyXS5kYXRhSWQpKSl0aHJvdyBuZXcgRXJyb3IoXCJkeW5hbWljIGNsaXAgYXR0cmlidXRlcyBhcmUgbm90IGFsbG93ZWRcIik7Y29uc3Qgbj10Lmxlbmd0aD49Mz90WzFdLm51bWJlckRhdGFbMF06by5NSU5fQ0xJUCxpPXQubGVuZ3RoPj0zP3RbMl0ubnVtYmVyRGF0YVswXTpvLk1BWF9DTElQO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7bWluOm4sbWF4Oml9KX07dC5jZWlsPShlLHQpPT5bZS5ydW4oUChlLHRbMF0sZCgpKSx0KV0sdC5jb3M9KGUsdCk9PltlLnJ1bihQKGUsdFswXSxmKCkpLHQpXSx0LmVsdT0oZSx0LG4pPT5bZS5ydW4oUChlLHRbMF0saChuLmFscGhhKSxuLmNhY2hlS2V5KSx0KV0sdC5wYXJzZUVsdUF0dHJpYnV0ZXM9ZT0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHthbHBoYTplLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJhbHBoYVwiLDEpfSksdC5leHA9KGUsdCk9PltlLnJ1bihQKGUsdFswXSxnKCkpLHQpXSx0LmZsb29yPShlLHQpPT5bZS5ydW4oUChlLHRbMF0sbSgpKSx0KV0sdC5pZGVudGl0eT0oZSx0KT0+W2UucnVuKFAoZSx0WzBdLHkoKSksdCldLHQubGVha3lSZWx1PShlLHQsbik9PltlLnJ1bihQKGUsdFswXSx3KG4uYWxwaGEpLG4uY2FjaGVLZXkpLHQpXSx0LnBhcnNlTGVha3lSZWx1QXR0cmlidXRlcz1lPT4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2FscGhhOmUuYXR0cmlidXRlcy5nZXRGbG9hdChcImFscGhhXCIsLjAxKX0pLHQubG9nPShlLHQpPT5bZS5ydW4oUChlLHRbMF0sXygpKSx0KV0sdC5uZWc9KGUsdCk9PltlLnJ1bihQKGUsdFswXSx2KCkpLHQpXSx0Lm5vdD0oZSx0KT0+W2UucnVuKFAoZSx0WzBdLHgoKSksdCldLHQucmVsdT0oZSx0KT0+W2UucnVuKFAoZSx0WzBdLFMoKSksdCldLHQuc2lnbW9pZD0oZSx0KT0+W2UucnVuKFAoZSx0WzBdLE8oKSksdCldLHQuc2luPShlLHQpPT5bZS5ydW4oUChlLHRbMF0sVCgpKSx0KV0sdC5zcXJ0PShlLHQpPT5bZS5ydW4oUChlLHRbMF0sQSgpKSx0KV0sdC50YW49KGUsdCk9PltlLnJ1bihQKGUsdFswXSxFKCkpLHQpXSx0LnRhbmg9KGUsdCk9PltlLnJ1bihQKGUsdFswXSxJKCkpLHQpXX0sNTQwOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyPXQuY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm89dm9pZCAwO2NvbnN0IHI9big2NzU3KSxvPW4oNTYzOSksaT1uKDQzMiksYT1uKDU2MTQpLHM9e25hbWU6XCJ1bnBhY2tcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS5wYWNrZWRdfTt0LmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvPShlLHQpPT57Y29uc3Qgbj10LmRpbXMubGVuZ3RoLHU9KDAsYS5nZXRDaGFubmVscykoXCJyY1wiLG4pLGw9dS5zbGljZSgtMiksYz0oMCxpLmdldENvb3Jkc0RhdGFUeXBlKShuKSxwPSgwLGEudW5wYWNrRnJvbUNoYW5uZWwpKCksZD0wPT09dC5kaW1zLmxlbmd0aD9cIlwiOmZ1bmN0aW9uKGUsdCl7aWYoMT09PWUpcmV0dXJuXCJyY1wiO2xldCBuPVwiXCI7Zm9yKGxldCByPTA7cjxlO3IrKyluKz10W3JdLHI8ZS0xJiYobis9XCIsXCIpO3JldHVybiBufShuLHUpLGY9bjw9MT9cInJjXCI6YHZlYzIoJHtsLmpvaW4oXCIsXCIpfSlgLGg9YFxcbiAgICAke3B9XFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAke2N9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgIC8vIFNhbXBsZSB0aGUgdGV4dHVyZSB3aXRoIHRoZSBjb29yZHMgdG8gZ2V0IHRoZSByZ2JhIGNoYW5uZWwgdmFsdWUuXFxuICAgICAgIHZlYzQgcGFja2VkSW5wdXQgPSBnZXRBKCR7ZH0pO1xcblxcbiAgICAgICAkeygwLHIuZ2V0R2xzbCkoZS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLm91dHB1dH0gPSB2ZWM0KGdldENoYW5uZWwocGFja2VkSW5wdXQsICR7Zn0pLCAwLCAwLCAwKTtcXG4gICAgIH1cXG4gICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2hhc01haW46ITAsb3V0cHV0OntkaW1zOnQuZGltcyx0eXBlOnQudHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6aH0pfSx0LmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyPShlLG4pPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2dldDooKT0+KDAsdC5jcmVhdGVVbnBhY2tQcm9ncmFtSW5mbykoZSxuKX0pfSw3ODYyOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlVW5zcXVlZXplQXR0cmlidXRlcz10LnVuc3F1ZWV6ZVYxMz10LnVuc3F1ZWV6ZT12b2lkIDA7Y29uc3Qgcj1uKDcyNzMpO3QudW5zcXVlZXplPShlLHQsbik9PntvKHQpO2NvbnN0IGk9ci5TaGFwZVV0aWwudW5zcXVlZXplU2hhcGUodFswXS5kaW1zLG4pO3JldHVybltlLnJlc2hhcGVVbnBhY2tlZCh0WzBdLGkpXX0sdC51bnNxdWVlemVWMTM9KGUsbik9PihpKG4pLCgwLHQudW5zcXVlZXplKShlLFtuWzBdXSxBcnJheS5mcm9tKG5bMV0uaW50ZWdlckRhdGEpKSksdC5wYXJzZVVuc3F1ZWV6ZUF0dHJpYnV0ZXM9ZT0+ZS5hdHRyaWJ1dGVzLmdldEludHMoXCJheGVzXCIpO2NvbnN0IG89ZT0+e2lmKCFlfHwxIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVW5zcXVlZXplIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwic3RyaW5nXCI9PT1lWzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSxpPWU9PntpZighZXx8MiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlVuc3F1ZWV6ZSByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoXCJpbnQzMlwiIT09ZVsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSwzOTgwOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnNjYWxlc1ZhbGlkYXRpb249dC52YWxpZGF0ZUlucHV0cz10LnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzPXQucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWOT10LnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzVjc9dC51cHNhbXBsZT12b2lkIDA7Y29uc3Qgcj1uKDQ5MTApLG89big2NzU3KSxpPW4oNTYzOSksYT17bmFtZTpcIlVwc2FtcGxlXCIsaW5wdXROYW1lczpbXCJYXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTt0LnVwc2FtcGxlPShlLG4scik9PigoMCx0LnZhbGlkYXRlSW5wdXRzKShuLHIpLFtlLnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpyLmNhY2hlS2V5LGdldDooKT0+cyhlLG4scil9KSxuKV0pLHQucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWNz1lPT4oMCx0LnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzKShlLDcpLHQucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWOT1lPT4oMCx0LnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzKShlLDkpLHQucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXM9KGUsbik9Pntjb25zdCBvPW4+PTEwLGk9ZS5hdHRyaWJ1dGVzLmdldFN0cmluZyhcIm1vZGVcIixcIm5lYXJlc3RcIik7aWYoXCJuZWFyZXN0XCIhPT1pJiZcImxpbmVhclwiIT09aSYmKG48MTF8fFwiY3ViaWNcIiE9PWkpKXRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIG1vZGU6ICR7aX1gKTtsZXQgYT1bXTtuPDkmJihhPWUuYXR0cmlidXRlcy5nZXRGbG9hdHMoXCJzY2FsZXNcIiksKDAsdC5zY2FsZXNWYWxpZGF0aW9uKShhLGksbykpO2NvbnN0IHM9ZS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiZXh0cmFwb2xhdGlvbl92YWx1ZVwiLDApLHU9bj4xMD9lLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwiY29vcmRpbmF0ZV90cmFuc2Zvcm1hdGlvbl9tb2RlXCIsXCJoYWxmX3BpeGVsXCIpOlwiYXN5bW1ldHJpY1wiO2lmKC0xPT09W1wiYXN5bW1ldHJpY1wiLFwicHl0b3JjaF9oYWxmX3BpeGVsXCIsXCJ0Zl9oYWxmX3BpeGVsX2Zvcl9ublwiLFwiYWxpZ25fY29ybmVyc1wiLFwidGZfY3JvcF9hbmRfcmVzaXplXCIsXCJoYWxmX3BpeGVsXCJdLmluZGV4T2YodSkpdGhyb3cgbmV3IEVycm9yKGBjb29yZGluYXRlX3RyYW5zZm9ybV9tb2RlICcke3V9JyBpcyBub3Qgc3VwcG9ydGVkYCk7Y29uc3QgbD1cInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiPT09dSxjPWwscD1cIm5lYXJlc3RcIj09PWkmJm4+PTExP2UuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJuZWFyZXN0X21vZGVcIixcInJvdW5kX3ByZWZlcl9mbG9vclwiKTpcIlwiO2lmKC0xPT09W1wicm91bmRfcHJlZmVyX2Zsb29yXCIsXCJyb3VuZF9wcmVmZXJfY2VpbFwiLFwiZmxvb3JcIixcImNlaWxcIixcIlwiXS5pbmRleE9mKHApKXRocm93IG5ldyBFcnJvcihgbmVhcmVzdF9tb2RlICcke3B9JyBpcyBub3Qgc3VwcG9ydGVkYCk7Y29uc3QgZD1lLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJjdWJpY19jb2VmZl9hXCIsLS43NSksZj0wIT09ZS5hdHRyaWJ1dGVzLmdldEludChcImV4Y2x1ZGVfb3V0c2lkZVwiLDApO2lmKGYmJlwiY3ViaWNcIiE9PWkpdGhyb3cgbmV3IEVycm9yKFwiZXhjbHVkZV9vdXRzaWRlIGNhbiBiZSBzZXQgdG8gMSBvbmx5IHdoZW4gbW9kZSBpcyBDVUJJQy5cIik7Y29uc3QgaD1uPDExfHxcIm5lYXJlc3RcIj09PWkmJlwiYXN5bW1ldHJpY1wiPT09dSYmXCJmbG9vclwiPT09cDtsZXQgZz0wLG09MCxiPTA7cmV0dXJuIG4+MTA/ZS5pbnB1dHMubGVuZ3RoPjI/KGc9MSxtPTIsYj0zKToobT0xLGI9Mik6OT09PW4mJihtPTEpLCgwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7b3BzZXQ6bixpc1Jlc2l6ZTpvLG1vZGU6aSxzY2FsZXM6YSxleHRyYXBvbGF0aW9uVmFsdWU6cyxjb29yZGluYXRlVHJhbnNmb3JtTW9kZTp1LHVzZUV4dHJhcG9sYXRpb246YyxuZWVkUm9pSW5wdXQ6bCxuZWFyZXN0TW9kZTpwLGN1YmljQ29lZmZpY2llbnRBOmQsZXhjbHVkZU91dHNpZGU6Zix1c2VOZWFyZXN0MnhPcHRpbWl6YXRpb246aCxyb2lJbnB1dElkeDpnLHNjYWxlc0lucHV0SWR4Om0sc2l6ZXNJbnB1dElkeDpifSl9O2NvbnN0IHM9KGUsdCxuKT0+e2NvbnN0IHI9KDAsby5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksW3MsdV09ZS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQodFswXS5kaW1zLGkuVGV4dHVyZVR5cGUudW5wYWNrZWQpLGw9dFswXS5kaW1zLm1hcCgoKGUsdCk9Pk1hdGguZmxvb3IoZSpuLnNjYWxlc1t0XSkpKSxbYyxwXT1lLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChsLGkuVGV4dHVyZVR5cGUudW5wYWNrZWQpLGQ9bC5sZW5ndGgsZj1uZXcgQXJyYXkoZCksaD1uZXcgQXJyYXkoZCk7bGV0IGc9YFxcbiAgICAgIGludCBvdXRwdXRfcGl0Y2hlc1ske2R9XTtcXG4gICAgICBpbnQgaW5wdXRfcGl0Y2hlc1ske2R9XTtcXG4gICAgICBgO2ZvcihsZXQgZT1kLTE7ZT49MDtlLS0pZltlXT1lPT09ZC0xPzE6ZltlKzFdKmxbZSsxXSxoW2VdPWU9PT1kLTE/MTpoW2UrMV0qdFswXS5kaW1zW2UrMV0sZys9YFxcbiAgICAgICAgb3V0cHV0X3BpdGNoZXNbJHtlfV0gPSAke2ZbZV19O1xcbiAgICAgICAgaW5wdXRfcGl0Y2hlc1ske2V9XSA9ICR7aFtlXX07XFxuICAgICAgICBgO2NvbnN0IG09YFxcbiAgICAgIGZsb2F0IGdldElucHV0RmxvYXQoaW50IGluZGV4KSB7XFxuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKGluZGV4LCAke3N9LCAke3V9KTtcXG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7ci50ZXh0dXJlMkR9KFgsIGNvb3JkcykpO1xcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH1cXG4gICAgICBgLGI9XCJuZWFyZXN0XCI9PT1uLm1vZGU/YFxcbiAgICAke219XFxuICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtkfV0pIHtcXG4gICAgICBpbnQgaW5wdXRfaW5kZXggPSAwO1xcbiAgICAgIGludCBvdXRwdXRfaW5kZXggPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7Y30sICR7cH0pO1xcblxcbiAgICAgICR7Z31cXG5cXG4gICAgICBpbnQgZCwgbTtcXG4gICAgICBmb3IgKGludCBkaW0gPSAwOyBkaW0gPCAke2R9OyArK2RpbSkge1xcbiAgICAgICAgZCA9IG91dHB1dF9pbmRleCAvIG91dHB1dF9waXRjaGVzW2RpbV07XFxuICAgICAgICBtID0gb3V0cHV0X2luZGV4IC0gZCAqIG91dHB1dF9waXRjaGVzW2RpbV07XFxuICAgICAgICBvdXRwdXRfaW5kZXggPSBtO1xcblxcbiAgICAgICAgaWYgKHNjYWxlc1tkaW1dICE9IDEgJiYgZCA+IDApIHtcXG4gICAgICAgICAgaW50IGQyID0gZCAvIHNjYWxlc1tkaW1dO1xcbiAgICAgICAgICBtID0gZCAtIGQyICogc2NhbGVzW2RpbV07XFxuICAgICAgICAgIGQgPSBkMjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlucHV0X2luZGV4ICs9IGlucHV0X3BpdGNoZXNbZGltXSAqIGQ7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4KTtcXG4gICAgfWA6ND09PWQ/YFxcbiAgICAke219XFxuICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbNF0pIHtcXG4gICAgICBpbnQgaW5wdXRfaW5kZXggPSAwO1xcbiAgICAgIGludCBvdXRwdXRfaW5kZXggPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7Y30sICR7cH0pO1xcblxcbiAgICAgICR7Z31cXG5cXG4gICAgICBpbnQgbTtcXG4gICAgICBpbnQgaW5kZXhfb2ZfZGltMCwgaW5kZXhfb2ZfZGltMSwgaW5kZXhfb2ZfZGltMiwgaW5kZXhfb2ZfZGltMztcXG4gICAgICBpbmRleF9vZl9kaW0wID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbMF07XFxuICAgICAgbSA9IG91dHB1dF9pbmRleCAtIGluZGV4X29mX2RpbTAgKiBvdXRwdXRfcGl0Y2hlc1swXTtcXG4gICAgICBpbmRleF9vZl9kaW0xID0gbSAvIG91dHB1dF9waXRjaGVzWzFdO1xcbiAgICAgIG0gPSBtIC0gaW5kZXhfb2ZfZGltMSAqIG91dHB1dF9waXRjaGVzWzFdO1xcbiAgICAgIGluZGV4X29mX2RpbTIgPSBtIC8gb3V0cHV0X3BpdGNoZXNbMl07XFxuICAgICAgbSA9IG0gLSBpbmRleF9vZl9kaW0yICogb3V0cHV0X3BpdGNoZXNbMl07XFxuICAgICAgaW5kZXhfb2ZfZGltMyA9IG07XFxuXFxuICAgICAgaW50IGluZGV4X29mX2lucHV0X2RpbTIsIGluZGV4X29mX2lucHV0X2RpbTMsIHhfb2Zmc2V0LCB5X29mZnNldDtcXG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0yID0gaW5kZXhfb2ZfZGltMiAvIHNjYWxlc1syXTtcXG4gICAgICB5X29mZnNldCA9IGluZGV4X29mX2RpbTIgLSBpbmRleF9vZl9pbnB1dF9kaW0yICogc2NhbGVzWzJdO1xcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTMgPSBpbmRleF9vZl9kaW0zIC8gc2NhbGVzWzNdO1xcbiAgICAgIHhfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMyAtIGluZGV4X29mX2lucHV0X2RpbTMgKiBzY2FsZXNbM107XFxuXFxuICAgICAgaW5wdXRfaW5kZXggPSBpbmRleF9vZl9kaW0wICogaW5wdXRfcGl0Y2hlc1swXSArXFxuICAgICAgICAgICAgaW5kZXhfb2ZfZGltMSAqIGlucHV0X3BpdGNoZXNbMV0gK1xcbiAgICAgICAgICAgIGluZGV4X29mX2lucHV0X2RpbTIgKiBpbnB1dF9waXRjaGVzWzJdICtcXG4gICAgICAgICAgICBpbmRleF9vZl9pbnB1dF9kaW0zO1xcblxcbiAgICAgIGZsb2F0IHgwMCA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXgpO1xcbiAgICAgIGZsb2F0IHgxMCwgeDAxLCB4MTE7XFxuXFxuICAgICAgYm9vbCBlbmRfb2ZfZGltMiA9IGZhbHNlO1xcbiAgICAgIGlmIChpbmRleF9vZl9pbnB1dF9kaW0yID09ICgke3RbMF0uZGltc1syXX0gLSAxKSkge1xcbiAgICAgICAgLy8gSXQncyB0aGUgZW5kIGluIGRpbWVuc2lvbiAyXFxuICAgICAgICB4MDEgPSB4MDA7XFxuICAgICAgICBlbmRfb2ZfZGltMiA9IHRydWU7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHgwMSA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzJdKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTMgPT0gKGlucHV0X3BpdGNoZXNbMl0gLSAxKSkge1xcbiAgICAgICAgLy8gSXQncyB0aGUgZW5kIGluIGRpbWVuc2lvbiAzXFxuICAgICAgICB4MTAgPSB4MDA7XFxuICAgICAgICB4MTEgPSB4MDE7XFxuICAgICAgfVxcbiAgICAgIGVsc2Uge1xcbiAgICAgICAgeDEwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIDEpO1xcbiAgICAgICAgeDExID0gZW5kX29mX2RpbTIgPyB4MTAgOiBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgaW5wdXRfcGl0Y2hlc1syXSArIDEpO1xcbiAgICAgIH1cXG5cXG4gICAgICBmbG9hdCB5MCA9IHgwMCArIGZsb2F0KHlfb2Zmc2V0KSAqICh4MDEgLSB4MDApIC8gZmxvYXQoc2NhbGVzWzJdKTtcXG4gICAgICBmbG9hdCB5MSA9IHgxMCArIGZsb2F0KHlfb2Zmc2V0KSAqICh4MTEgLSB4MTApIC8gZmxvYXQoc2NhbGVzWzJdKTtcXG4gICAgICByZXR1cm4geTAgKyBmbG9hdCh4X29mZnNldCkgKiAoeTEgLSB5MCkgLyBmbG9hdChzY2FsZXNbM10pO1xcbiAgICB9YDpgXFxuICAgICR7bX1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1syXSkge1xcbiAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XFxuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtjfSwgJHtwfSk7XFxuXFxuICAgICAgJHtnfVxcblxcbiAgICAgIGludCBtO1xcbiAgICAgIGludCBpbmRleF9vZl9kaW0wLCBpbmRleF9vZl9kaW0xO1xcbiAgICAgIGluZGV4X29mX2RpbTAgPSBvdXRwdXRfaW5kZXggLyBvdXRwdXRfcGl0Y2hlc1swXTtcXG4gICAgICBtID0gb3V0cHV0X2luZGV4IC0gaW5kZXhfb2ZfZGltMCAqIG91dHB1dF9waXRjaGVzWzBdO1xcbiAgICAgIGluZGV4X29mX2RpbTEgPSBtO1xcblxcbiAgICAgIGludCBpbmRleF9vZl9pbnB1dF9kaW0wLCBpbmRleF9vZl9pbnB1dF9kaW0xLCB4X29mZnNldCwgeV9vZmZzZXQ7XFxuICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMCA9IGluZGV4X29mX2RpbTAgLyBzY2FsZXNbMF07XFxuICAgICAgeV9vZmZzZXQgPSBpbmRleF9vZl9kaW0wIC0gaW5kZXhfb2ZfaW5wdXRfZGltMCAqIHNjYWxlc1swXTtcXG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0xID0gaW5kZXhfb2ZfZGltMSAvIHNjYWxlc1sxXTtcXG4gICAgICB4X29mZnNldCA9IGluZGV4X29mX2RpbTEgLSBpbmRleF9vZl9pbnB1dF9kaW0xICogc2NhbGVzWzFdO1xcblxcbiAgICAgIGlucHV0X2luZGV4ID0gaW5kZXhfb2ZfaW5wdXRfZGltMCAqIGlucHV0X3BpdGNoZXNbMF0gKyBpbmRleF9vZl9pbnB1dF9kaW0xO1xcblxcbiAgICAgIGZsb2F0IHgwMCA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXgpO1xcbiAgICAgIGZsb2F0IHgxMCwgeDAxLCB4MTE7XFxuXFxuICAgICAgYm9vbCBlbmRfb2ZfZGltMCA9IGZhbHNlO1xcbiAgICAgIGlmIChpbmRleF9vZl9pbnB1dF9kaW0wID09ICgke3RbMF0uZGltc1swXX0gLSAxKSkge1xcbiAgICAgICAgLy8gSXQncyB0aGUgZW5kIGluIGRpbWVuc2lvbiAwXFxuICAgICAgICB4MDEgPSB4MDA7XFxuICAgICAgICBlbmRfb2ZfZGltMCA9IHRydWU7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHgwMSA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzBdKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTEgPT0gKGlucHV0X3BpdGNoZXNbMF0gLSAxKSkge1xcbiAgICAgICAgLy8gSXQncyB0aGUgZW5kIGluIGRpbWVuc2lvbiAxXFxuICAgICAgICB4MTAgPSB4MDA7XFxuICAgICAgICB4MTEgPSB4MDE7XFxuICAgICAgfVxcbiAgICAgIGVsc2Uge1xcbiAgICAgICAgeDEwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIDEpO1xcbiAgICAgICAgeDExID0gZW5kX29mX2RpbTAgPyB4MTAgOiBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgaW5wdXRfcGl0Y2hlc1swXSArIDEpO1xcbiAgICAgIH1cXG5cXG4gICAgICBmbG9hdCB5MCA9IHgwMCArIGZsb2F0KHlfb2Zmc2V0KSAqICh4MDEgLSB4MDApIC8gZmxvYXQoc2NhbGVzWzBdKTtcXG4gICAgICBmbG9hdCB5MSA9IHgxMCArIGZsb2F0KHlfb2Zmc2V0KSAqICh4MTEgLSB4MTApIC8gZmxvYXQoc2NhbGVzWzBdKTtcXG4gICAgICByZXR1cm4geTAgKyBmbG9hdCh4X29mZnNldCkgKiAoeTEgLSB5MCkgLyBmbG9hdChzY2FsZXNbMV0pO1xcbiAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtvdXRwdXQ6e2RpbXM6bCx0eXBlOnRbMF0udHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6Yix2YXJpYWJsZXM6W3tuYW1lOlwic2NhbGVzXCIsdHlwZTpcImludFwiLGFycmF5TGVuZ3RoOm4uc2NhbGVzLmxlbmd0aCxkYXRhOm4uc2NhbGVzLm1hcCgoZT0+TWF0aC5jZWlsKGUpKSl9XX0pfTt0LnZhbGlkYXRlSW5wdXRzPShlLHQpPT57aWYoIWV8fHQub3BzZXQ8OSYmMSE9PWUubGVuZ3RofHx0Lm9wc2V0Pj05JiZ0Lm9wc2V0PDExJiYyIT09ZS5sZW5ndGh8fHQub3BzZXQ+PTExJiZlLmxlbmd0aDwyKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXRzLlwiKTtpZih0LnNjYWxlcy5sZW5ndGg+MCYmZVswXS5kaW1zLmxlbmd0aCE9PXQuc2NhbGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHNoYXBlLlwiKTtpZihcInN0cmluZ1wiPT09ZVswXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdGVuc29yIHR5cGVzLlwiKX0sdC5zY2FsZXNWYWxpZGF0aW9uPShlLHQsbik9PntpZihuKXtmb3IoY29uc3QgdCBvZiBlKWlmKHQ8PTApdGhyb3cgbmV3IEVycm9yKFwiU2NhbGUgdmFsdWUgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiAwLlwiKX1lbHNlIGZvcihjb25zdCB0IG9mIGUpaWYodDwxKXRocm93IG5ldyBFcnJvcihcIlNjYWxlIHZhbHVlIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMS5cIik7aWYoIShcImxpbmVhclwiIT09dCYmXCJjdWJpY1wiIT09dHx8Mj09PWUubGVuZ3RofHw0PT09ZS5sZW5ndGgmJjE9PT1lWzBdJiYxPT09ZVsxXSkpdGhyb3cgbmV3IEVycm9yKGAnTGluZWFyJyBtb2RlIGFuZCAnQ3ViaWMnIG1vZGUgb25seSBzdXBwb3J0IDItRCBpbnB1dHMgKCdCaWxpbmVhcicsICdCaWN1YmljJykgICAgICAgICBvciA0LUQgaW5wdXRzIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgb3V0ZXJtb3N0IDIgc2NhbGUgdmFsdWVzIGJlaW5nIDEgICAgICAgICBpbiB0aGUgJHtuP1wiUmVzaXplXCI6XCJVcHNhbXBsZVwifSBvcGVhcnRvci5gKX19LDI3NTc6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuUHJvZ3JhbU1hbmFnZXI9dm9pZCAwO2NvbnN0IHI9big4NDUzKSxvPW4oMTMxNSksaT1uKDg4OTcpLGE9big2NzU3KTt0LlByb2dyYW1NYW5hZ2VyPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuKXt0aGlzLnByb2ZpbGVyPWUsdGhpcy5nbENvbnRleHQ9dCx0aGlzLnRleHR1cmVMYXlvdXRTdHJhdGVneT1uLHRoaXMucmVwbz1uZXcgTWFwLHRoaXMuYXR0cmlidXRlc0JvdW5kPSExfWdldEFydGlmYWN0KGUpe3JldHVybiB0aGlzLnJlcG8uZ2V0KGUpfXNldEFydGlmYWN0KGUsdCl7dGhpcy5yZXBvLnNldChlLHQpfXJ1bihlLHQsbil7dmFyIHI7dGhpcy5wcm9maWxlci5ldmVudChcIm9wXCIsYFByb2dyYW1NYW5hZ2VyLnJ1biAke251bGwhPT0ocj1lLnByb2dyYW1JbmZvLm5hbWUpJiZ2b2lkIDAhPT1yP3I6XCJ1bmtub3duIGtlcm5lbFwifWAsKCgpPT57dmFyIHI7Y29uc3QgaT10aGlzLmdsQ29udGV4dC5nbCxhPWUucHJvZ3JhbTtpLnVzZVByb2dyYW0oYSk7dHJ5e3RoaXMuYmluZE91dHB1dChuKSx0aGlzLmF0dHJpYnV0ZXNCb3VuZHx8dGhpcy5iaW5kQXR0cmlidXRlcyhlLmF0dHJpYkxvY2F0aW9ucyksdGhpcy5iaW5kVW5pZm9ybXMoZS51bmlmb3JtTG9jYXRpb25zLG51bGwhPT0ocj1lLnByb2dyYW1JbmZvLnZhcmlhYmxlcykmJnZvaWQgMCE9PXI/cjpbXSx0KX1jYXRjaCh0KXt0aHJvdyBvLkxvZ2dlci5lcnJvcihcIlByb2dyYW1NYW5hZ2VyXCIsZS5wcm9ncmFtSW5mby5zaGFkZXJTb3VyY2UpLHR9dGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIkdsQ29udGV4dC5kcmF3KClcIiwoKCk9Pnt0aGlzLmdsQ29udGV4dC5kcmF3KCl9KSl9KSx0aGlzLmdsQ29udGV4dCl9ZGlzcG9zZSgpe3RoaXMudmVydGV4U2hhZGVyJiZ0aGlzLmdsQ29udGV4dC5kZWxldGVTaGFkZXIodGhpcy52ZXJ0ZXhTaGFkZXIpLHRoaXMucmVwby5mb3JFYWNoKChlPT50aGlzLmdsQ29udGV4dC5kZWxldGVQcm9ncmFtKGUucHJvZ3JhbSkpKX1idWlsZChlLHQsbil7cmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoXCJiYWNrZW5kXCIsXCJQcm9ncmFtTWFuYWdlci5idWlsZFwiLCgoKT0+e2NvbnN0IHI9bmV3IGkuR2xzbFByZXByb2Nlc3Nvcih0aGlzLmdsQ29udGV4dCxlLHQsbiksbz1yLnByZXByb2Nlc3MoKSxhPXRoaXMuY29tcGlsZShvKTtyZXR1cm57cHJvZ3JhbUluZm86ZSxwcm9ncmFtOmEsdW5pZm9ybUxvY2F0aW9uczp0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbnMoYSxyLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcyxyLmNvbnRleHQucHJvZ3JhbUluZm8udmFyaWFibGVzKSxhdHRyaWJMb2NhdGlvbnM6dGhpcy5nZXRBdHRyaWJMb2NhdGlvbnMoYSl9fSkpfWNvbXBpbGUoZSl7aWYoIXRoaXMudmVydGV4U2hhZGVyKXtvLkxvZ2dlci52ZXJib3NlKFwiUHJvcmdyYW1NYW5hZ2VyXCIsXCJDb21waWxpbmcgYW5kIGNhY2hpbmcgVmVydGV4IHNoYWRlciBmb3IgdGhlIGZpcnN0IHRpbWVcIik7Y29uc3QgZT0oMCxhLmdldFZlcnRleFNoYWRlclNvdXJjZSkodGhpcy5nbENvbnRleHQudmVyc2lvbik7dGhpcy52ZXJ0ZXhTaGFkZXI9dGhpcy5nbENvbnRleHQuY29tcGlsZVNoYWRlcihlLHRoaXMuZ2xDb250ZXh0LmdsLlZFUlRFWF9TSEFERVIpfXIuZW52LmRlYnVnJiZvLkxvZ2dlci52ZXJib3NlKFwiUHJvcmdyYW1NYW5hZ2VyXCIsYEZyYWdTaGFkZXI6XFxuJHtlfVxcbmApO2NvbnN0IHQ9dGhpcy5nbENvbnRleHQuY29tcGlsZVNoYWRlcihlLHRoaXMuZ2xDb250ZXh0LmdsLkZSQUdNRU5UX1NIQURFUiksbj10aGlzLmdsQ29udGV4dC5jcmVhdGVQcm9ncmFtKHRoaXMudmVydGV4U2hhZGVyLHQpO3JldHVybiB0aGlzLmdsQ29udGV4dC5kZWxldGVTaGFkZXIodCksbn1iaW5kT3V0cHV0KGUpe2NvbnN0IHQ9ZS53aWR0aCxuPWUuaGVpZ2h0O28uTG9nZ2VyLnZlcmJvc2UoXCJQcm9yZ3JhbU1hbmFnZXJcIixgQmluZGluZyBvdXRwdXQgdGV4dHVyZSB0byBGcmFtZWJ1ZmZlcjogdy9oPSR7dH0vJHtufSwgc2hhcGU9JHtlLnNoYXBlfSwgdHlwZT0ke2UudGVuc29yLnR5cGV9YCksdGhpcy5nbENvbnRleHQuYXR0YWNoRnJhbWVidWZmZXIoZS50ZXh0dXJlLHQsbil9YmluZEF0dHJpYnV0ZXMoZSl7Y29uc3QgdD1lLnBvc2l0aW9uLG49ZS50ZXh0dXJlQ29vcmQ7dGhpcy5nbENvbnRleHQuc2V0VmVydGV4QXR0cmlidXRlcyh0LG4pLHRoaXMuYXR0cmlidXRlc0JvdW5kPSEwfWJpbmRVbmlmb3JtcyhlLHQsbil7dmFyIHI7Y29uc3Qgbz10aGlzLmdsQ29udGV4dC5nbDtsZXQgaT0wO2Zvcihjb25zdHtuYW1lOmEsdHlwZTpzLGxvY2F0aW9uOnUsYXJyYXlMZW5ndGg6bH1vZiBlKXtjb25zdCBlPW51bGw9PT0ocj10LmZpbmQoKGU9PmUubmFtZT09PWEpKSl8fHZvaWQgMD09PXI/dm9pZCAwOnIuZGF0YTtpZihcInNhbXBsZXIyRFwiIT09cyYmIWUpdGhyb3cgbmV3IEVycm9yKGB2YXJpYWJsZSAnJHthfScgZG9lcyBub3QgaGF2ZSBkYXRhIGRlZmluZWQgaW4gcHJvZ3JhbSBpbmZvYCk7c3dpdGNoKHMpe2Nhc2VcInNhbXBsZXIyRFwiOnRoaXMuYmluZFRleHR1cmUobltpXSx1LGkpLGkrKzticmVhaztjYXNlXCJmbG9hdFwiOmw/by51bmlmb3JtMWZ2KHUsZSk6by51bmlmb3JtMWYodSxlKTticmVhaztjYXNlXCJpbnRcIjpsP28udW5pZm9ybTFpdih1LGUpOm8udW5pZm9ybTFpKHUsZSk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gbm90IGltcGxlbWVudGVkOiAke3N9YCl9fX1iaW5kVGV4dHVyZShlLHQsbil7dGhpcy5nbENvbnRleHQuYmluZFRleHR1cmVUb1VuaWZvcm0oZS50ZXh0dXJlLG4sdCl9Z2V0QXR0cmliTG9jYXRpb25zKGUpe3JldHVybntwb3NpdGlvbjp0aGlzLmdldEF0dHJpYkxvY2F0aW9uKGUsXCJwb3NpdGlvblwiKSx0ZXh0dXJlQ29vcmQ6dGhpcy5nZXRBdHRyaWJMb2NhdGlvbihlLFwidGV4dHVyZUNvb3JkXCIpfX1nZXRVbmlmb3JtTG9jYXRpb25zKGUsdCxuKXtjb25zdCByPVtdO2lmKHQpZm9yKGNvbnN0IG4gb2YgdClyLnB1c2goe25hbWU6bix0eXBlOlwic2FtcGxlcjJEXCIsbG9jYXRpb246dGhpcy5nZXRVbmlmb3JtTG9jYXRpb24oZSxuKX0pO2lmKG4pZm9yKGNvbnN0IHQgb2YgbilyLnB1c2goT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtsb2NhdGlvbjp0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihlLHQubmFtZSl9KSk7cmV0dXJuIHJ9Z2V0VW5pZm9ybUxvY2F0aW9uKGUsdCl7Y29uc3Qgbj10aGlzLmdsQ29udGV4dC5nbC5nZXRVbmlmb3JtTG9jYXRpb24oZSx0KTtpZihudWxsPT09bil0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gJHt0fSBub3QgZm91bmQuYCk7cmV0dXJuIG59Z2V0QXR0cmliTG9jYXRpb24oZSx0KXtyZXR1cm4gdGhpcy5nbENvbnRleHQuZ2wuZ2V0QXR0cmliTG9jYXRpb24oZSx0KX19fSwyMTcxOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LldlYkdMU2Vzc2lvbkhhbmRsZXI9dm9pZCAwO2NvbnN0IHI9bigxMzE1KSxvPW4oNTg4MSksaT1uKDc4NjApLGE9big0MTEwKSxzPW4oMjc1NyksdT1uKDc2MTgpLGw9big1MjQzKTt0LldlYkdMU2Vzc2lvbkhhbmRsZXI9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLmJhY2tlbmQ9ZSx0aGlzLmNvbnRleHQ9dCx0aGlzLmxheW91dFN0cmF0ZWd5PW5ldyB1LlByZWZlckxvZ2ljYWxTdHJhdGVneShlLmdsQ29udGV4dC5tYXhUZXh0dXJlU2l6ZSksdGhpcy5wcm9ncmFtTWFuYWdlcj1uZXcgcy5Qcm9ncmFtTWFuYWdlcih0aGlzLmNvbnRleHQucHJvZmlsZXIsZS5nbENvbnRleHQsdGhpcy5sYXlvdXRTdHJhdGVneSksdGhpcy50ZXh0dXJlTWFuYWdlcj1uZXcgbC5UZXh0dXJlTWFuYWdlcihlLmdsQ29udGV4dCx0aGlzLmxheW91dFN0cmF0ZWd5LHRoaXMuY29udGV4dC5wcm9maWxlcix7cmV1c2VUZXh0dXJlczpcImZ1bGxcIj09PWUudGV4dHVyZUNhY2hlTW9kZX0pLHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwLHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXAsdGhpcy5wYWNrPWUucGFjayx0aGlzLnBhY2sydW5wYWNrTWFwPW5ldyBNYXAsdGhpcy51bnBhY2sycGFja01hcD1uZXcgTWFwfWNyZWF0ZUluZmVyZW5jZUhhbmRsZXIoKXtyZXR1cm4gbmV3IGkuV2ViR0xJbmZlcmVuY2VIYW5kbGVyKHRoaXMpfW9uR3JhcGhJbml0aWFsaXplZChlKXtjb25zdCB0PWUuZ2V0VmFsdWVzKCkuZmlsdGVyKChlPT4tMT09PWUuZnJvbSYmZS50ZW5zb3IpKS5tYXAoKGU9PmUudGVuc29yLmRhdGFJZCkpO3RoaXMuaW5pdGlhbGl6ZXJzPW5ldyBTZXQodCl9aXNJbml0aWFsaXplcihlKXtyZXR1cm4hIXRoaXMuaW5pdGlhbGl6ZXJzJiZ0aGlzLmluaXRpYWxpemVycy5oYXMoZSl9YWRkSW5pdGlhbGl6ZXIoZSl7dGhpcy5pbml0aWFsaXplcnMuYWRkKGUpfWdldFRleHR1cmVEYXRhKGUsdCl7cmV0dXJuIHQ/dGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldChlKTp0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQoZSl9c2V0VGV4dHVyZURhdGEoZSx0LG49ITEpe3IuTG9nZ2VyLnZlcmJvc2UoXCJXZWJHTFNlc3Npb25IYW5kbGVyXCIsXCJTdG9yaW5nIFRleHR1cmUgZGF0YSBpbiBjYWNoZVwiKSxuP3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5zZXQoZSx0KTp0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZS5zZXQoZSx0KX1kaXNwb3NlKCl7dGhpcy5wcm9ncmFtTWFuYWdlci5kaXNwb3NlKCksdGhpcy50ZXh0dXJlTWFuYWdlci5jbGVhckFjdGl2ZVRleHR1cmVzKCksdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2goKGU9PnRoaXMudGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUoZSwhMCkpKSx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKChlPT50aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKGUsITApKSksdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcH1yZXNvbHZlKGUsdCxuKXtjb25zdCByPSgwLG8ucmVzb2x2ZU9wZXJhdG9yKShlLHQsYS5XRUJHTF9PUF9SRVNPTFZFX1JVTEVTKTtyZXR1cm57aW1wbDpyLm9wSW1wbCxjb250ZXh0OnIub3BJbml0P3Iub3BJbml0KGUsbik6ZX19fX0sOTYyMjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5VaW50OERhdGFFbmNvZGVyPXQuUkdCQUZsb2F0RGF0YUVuY29kZXI9dC5SZWRGbG9hdDMyRGF0YUVuY29kZXI9dm9pZCAwO2NvbnN0IHI9bigxMzE1KTt0LlJlZEZsb2F0MzJEYXRhRW5jb2Rlcj1jbGFzc3tjb25zdHJ1Y3RvcihlLHQ9MSl7aWYoMT09PXQpdGhpcy5pbnRlcm5hbEZvcm1hdD1lLlIzMkYsdGhpcy5mb3JtYXQ9ZS5SRUQsdGhpcy50ZXh0dXJlVHlwZT1lLkZMT0FULHRoaXMuY2hhbm5lbFNpemU9dDtlbHNle2lmKDQhPT10KXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7dH1gKTt0aGlzLmludGVybmFsRm9ybWF0PWUuUkdCQTMyRix0aGlzLmZvcm1hdD1lLlJHQkEsdGhpcy50ZXh0dXJlVHlwZT1lLkZMT0FULHRoaXMuY2hhbm5lbFNpemU9dH19ZW5jb2RlKGUsdCl7bGV0IG4sbztyZXR1cm4gZS5jb25zdHJ1Y3RvciE9PUZsb2F0MzJBcnJheSYmKHIuTG9nZ2VyLndhcm5pbmcoXCJFbmNvZGVyXCIsXCJkYXRhIHdhcyBub3Qgb2YgdHlwZSBGbG9hdDMyOyBjcmVhdGluZyBuZXcgRmxvYXQzMkFycmF5XCIpLG89bmV3IEZsb2F0MzJBcnJheShlKSksdCp0aGlzLmNoYW5uZWxTaXplPmUubGVuZ3RoPyhyLkxvZ2dlci53YXJuaW5nKFwiRW5jb2RlclwiLFwiU291cmNlIGRhdGEgdG9vIHNtYWxsLiBBbGxvY2F0aW5nIGxhcmdlciBhcnJheVwiKSxvPWUsbj10aGlzLmFsbG9jYXRlKHQqdGhpcy5jaGFubmVsU2l6ZSksby5mb3JFYWNoKCgoZSx0KT0+blt0XT1lKSkpOihvPWUsbj1vKSxufWFsbG9jYXRlKGUpe3JldHVybiBuZXcgRmxvYXQzMkFycmF5KDQqZSl9ZGVjb2RlKGUsdCl7cmV0dXJuIDE9PT10aGlzLmNoYW5uZWxTaXplP2UuZmlsdGVyKCgoZSx0KT0+dCU0PT0wKSkuc3ViYXJyYXkoMCx0KTplLnN1YmFycmF5KDAsdCl9fSx0LlJHQkFGbG9hdERhdGFFbmNvZGVyPWNsYXNze2NvbnN0cnVjdG9yKGUsdD0xLG4pe2lmKDEhPT10JiY0IT09dCl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnVtYmVyIG9mIGNoYW5uZWxzOiAke3R9YCk7dGhpcy5pbnRlcm5hbEZvcm1hdD1lLlJHQkEsdGhpcy5mb3JtYXQ9ZS5SR0JBLHRoaXMuY2hhbm5lbFNpemU9dCx0aGlzLnRleHR1cmVUeXBlPW58fGUuRkxPQVR9ZW5jb2RlKGUsdCl7bGV0IG49ZTtyZXR1cm4gMT09PXRoaXMuY2hhbm5lbFNpemUmJihyLkxvZ2dlci52ZXJib3NlKFwiRW5jb2RlclwiLFwiRXhwbG9kaW5nIGludG8gYSBsYXJnZXIgYXJyYXlcIiksbj10aGlzLmFsbG9jYXRlKHQpLGUuZm9yRWFjaCgoKGUsdCk9Pm5bNCp0XT1lKSkpLG59YWxsb2NhdGUoZSl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoNCplKX1kZWNvZGUoZSx0KXtyZXR1cm4gMT09PXRoaXMuY2hhbm5lbFNpemU/ZS5maWx0ZXIoKChlLHQpPT50JTQ9PTApKS5zdWJhcnJheSgwLHQpOmUuc3ViYXJyYXkoMCx0KX19LHQuVWludDhEYXRhRW5jb2Rlcj1jbGFzc3tjb25zdHJ1Y3RvcihlLHQ9MSl7aWYodGhpcy5jaGFubmVsU2l6ZT00LDE9PT10KXRoaXMuaW50ZXJuYWxGb3JtYXQ9ZS5BTFBIQSx0aGlzLmZvcm1hdD1lLkFMUEhBLHRoaXMudGV4dHVyZVR5cGU9ZS5VTlNJR05FRF9CWVRFLHRoaXMuY2hhbm5lbFNpemU9dDtlbHNle2lmKDQhPT10KXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7dH1gKTt0aGlzLmludGVybmFsRm9ybWF0PWUuUkdCQSx0aGlzLmZvcm1hdD1lLlJHQkEsdGhpcy50ZXh0dXJlVHlwZT1lLlVOU0lHTkVEX0JZVEUsdGhpcy5jaGFubmVsU2l6ZT10fX1lbmNvZGUoZSx0KXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZS5idWZmZXIsZS5ieXRlT2Zmc2V0LGUuYnl0ZUxlbmd0aCl9YWxsb2NhdGUoZSl7cmV0dXJuIG5ldyBVaW50OEFycmF5KGUqdGhpcy5jaGFubmVsU2l6ZSl9ZGVjb2RlKGUsdCl7aWYoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpcmV0dXJuIGUuc3ViYXJyYXkoMCx0KTt0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXJyYXkgdHlwZTogJHtlLmNvbnN0cnVjdG9yfWApfX19LDc2MTg6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0QmF0Y2hEaW09dC5zaXplVG9TcXVhcmlzaFNoYXBlPXQuZ2V0Um93c0NvbHM9dC5zaXplRnJvbVNoYXBlPXQuaXNJbnQ9dC5wYXJzZUF4aXNQYXJhbT10LnNxdWVlemVTaGFwZT10LlByZWZlckxvZ2ljYWxTdHJhdGVneT10LkFsd2F5c0tlZXBPcmlnaW5hbFNpemVTdHJhdGVneT12b2lkIDA7Y29uc3Qgcj1uKDEzMTUpLG89big3MjczKTtmdW5jdGlvbiBpKGUsdCl7Y29uc3Qgbj1bXSxyPVtdLG89bnVsbCE9dCYmQXJyYXkuaXNBcnJheSh0KSYmMD09PXQubGVuZ3RoLGk9bnVsbD09dHx8bz9udWxsOmEodCxlKS5zb3J0KCk7bGV0IHM9MDtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoOysrdCl7aWYobnVsbCE9aSl7aWYoaVtzXT09PXQmJjEhPT1lW3RdKXRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc3F1ZWV6ZSBheGlzICR7dH0gc2luY2UgaXRzIGRpbSAnJHtlW3RdfScgaXMgbm90IDFgKTsobnVsbD09aVtzXXx8aVtzXT50KSYmMT09PWVbdF0mJihuLnB1c2goZVt0XSksci5wdXNoKHQpKSxpW3NdPD10JiZzKyt9MSE9PWVbdF0mJihuLnB1c2goZVt0XSksci5wdXNoKHQpKX1yZXR1cm57bmV3U2hhcGU6bixrZXB0RGltczpyfX1mdW5jdGlvbiBhKGUsdCl7Y29uc3Qgbj10Lmxlbmd0aDtyZXR1cm4gZT1udWxsPT1lP3QubWFwKCgoZSx0KT0+dCkpOltdLmNvbmNhdChlKSwoMCxvLmFzc2VydCkoZS5ldmVyeSgoZT0+ZT49LW4mJmU8bikpLCgoKT0+YEFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGluIHJhbmdlIFstJHtufSwgJHtufSkgYnV0IGdvdCBheGlzICR7ZX1gKSksKDAsby5hc3NlcnQpKGUuZXZlcnkocyksKCgpPT5gQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW50ZWdlcnMgYnV0IGdvdCBheGlzICR7ZX1gKSksZS5tYXAoKGU9PmU8MD9uK2U6ZSkpfWZ1bmN0aW9uIHMoZSl7cmV0dXJuIGUlMT09MH1mdW5jdGlvbiB1KGUpe2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gMTtsZXQgdD1lWzBdO2ZvcihsZXQgbj0xO248ZS5sZW5ndGg7bisrKXQqPWVbbl07cmV0dXJuIHR9ZnVuY3Rpb24gbChlKXtjb25zdCB0PU1hdGguY2VpbChNYXRoLnNxcnQoZSkpO3JldHVyblt0LE1hdGguY2VpbChlL3QpXX10LkFsd2F5c0tlZXBPcmlnaW5hbFNpemVTdHJhdGVneT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLm1heFRleHR1cmVTaXplPWV9Y29tcHV0ZVRleHR1cmVXSChlLHQpe2lmKDA9PT1lLmxlbmd0aClyZXR1cm5bMSwxXTtjb25zdCBuPXRoaXMubWF4VGV4dHVyZVNpemU7aWYodCYmdm9pZCAwIT09dC5icmVha0F4aXMpe2NvbnN0IG89dC5icmVha0F4aXM+PWUubGVuZ3RoPzE6ZS5zbGljZSh0LmJyZWFrQXhpcykucmVkdWNlKCgoZSx0KT0+ZSp0KSksaT10LmJyZWFrQXhpczw9MD8xOmUuc2xpY2UoMCx0LmJyZWFrQXhpcykucmVkdWNlKCgoZSx0KT0+ZSp0KSk7aWYoIShvPm58fGk+bikpcmV0dXJuW28saV07ci5Mb2dnZXIudmVyYm9zZShcIlRleHR1cmVMYXlvdXRcIixgR2l2ZW4gd2lkdGgvaGVpZ2h0IHByZWZlcmVuY2VzIHdlcmUgdW5hdHRhaW5hYmxlOiBzaGFwZToke2V9LCBicmVha0F4aXM6JHt0LmJyZWFrQXhpc31gKX1jb25zdCBvPWUucmVkdWNlKCgoZSx0KT0+ZSp0KSk7bGV0IGk9TWF0aC5mbG9vcihNYXRoLnNxcnQobykpO2Zvcig7aTxuJiZpPG8mJm8laSE9MDtpKyspO2lmKGk+PW58fG8laSE9MCl0aHJvdyBuZXcgRXJyb3IoYFRoZSBnaXZlbiBkaW1lbnNpb25zIGFyZSBvdXRzaWRlIHRoaXMgR1BVJ3MgYm91bmRhcmllczogJHtlfWApO3JldHVybltpLG8vaV19fSx0LlByZWZlckxvZ2ljYWxTdHJhdGVneT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLm1heFRleHR1cmVTaXplPWV9Y29tcHV0ZVRleHR1cmVXSChlLHQpe2NvbnN0IG49dGhpcy5jb21wdXRlVGV4dHVyZShlLHQpO3JldHVybiB0JiZ0LmlzUGFja2VkJiYoblswXS89MixuWzFdLz0yKSx0JiZ0LnJldmVyc2VXSD9bblsxXSxuWzBdXTpufWNvbXB1dGVUZXh0dXJlKGUsdCl7Y29uc3Qgbj10JiZ0LmlzUGFja2VkO2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gbj9bMiwyXTpbMSwxXTtsZXQgbz10aGlzLm1heFRleHR1cmVTaXplO2lmKHQmJnZvaWQgMCE9PXQuYnJlYWtBeGlzKXtjb25zdCBuPXQuYnJlYWtBeGlzPj1lLmxlbmd0aD8xOmUuc2xpY2UodC5icmVha0F4aXMpLnJlZHVjZSgoKGUsdCk9PmUqdCkpLGk9dC5icmVha0F4aXM8PTA/MTplLnNsaWNlKDAsdC5icmVha0F4aXMpLnJlZHVjZSgoKGUsdCk9PmUqdCkpO2lmKCEobj5vfHxpPm8pKXJldHVybltuLGldO3IuTG9nZ2VyLnZlcmJvc2UoXCJUZXh0dXJlTGF5b3V0XCIsYEdpdmVuIHdpZHRoL2hlaWdodCBwcmVmZXJlbmNlcyB3ZXJlIHVuYXR0YWluYWJsZTogc2hhcGU6JHtlfSwgYnJlYWtBeGlzOiR7dC5icmVha0F4aXN9YCl9bGV0IGE9ZS5zbGljZSgwKTtpZihuJiYobyo9MixhPWEubWFwKCgoZSx0KT0+dD49YS5sZW5ndGgtMj9hW3RdJTI9PTA/YVt0XTphW3RdKzE6YVt0XSkpLDE9PT1hLmxlbmd0aCYmKGE9WzIsYVswXV0pKSwyIT09YS5sZW5ndGgpe2NvbnN0IGU9aShhKTthPWUubmV3U2hhcGV9Y29uc3Qgcz11KGEpO3JldHVybiBhLmxlbmd0aDw9MSYmczw9bz9bMSxzXToyPT09YS5sZW5ndGgmJmFbMF08PW8mJmFbMV08PW8/YTozPT09YS5sZW5ndGgmJmFbMF0qYVsxXTw9byYmYVsyXTw9bz9bYVswXSphWzFdLGFbMl1dOjM9PT1hLmxlbmd0aCYmYVswXTw9byYmYVsxXSphWzJdPD1vP1thWzBdLGFbMV0qYVsyXV06ND09PWEubGVuZ3RoJiZhWzBdKmFbMV0qYVsyXTw9byYmYVszXTw9bz9bYVswXSphWzFdKmFbMl0sYVszXV06ND09PWEubGVuZ3RoJiZhWzBdPD1vJiZhWzFdKmFbMl0qYVszXTw9bz9bYVswXSxhWzFdKmFbMl0qYVszXV06bj9sKHMvNCkubWFwKChlPT4yKmUpKTpsKHMpfX0sdC5zcXVlZXplU2hhcGU9aSx0LnBhcnNlQXhpc1BhcmFtPWEsdC5pc0ludD1zLHQuc2l6ZUZyb21TaGFwZT11LHQuZ2V0Um93c0NvbHM9ZnVuY3Rpb24oZSl7aWYoMD09PWUubGVuZ3RoKXRocm93IEVycm9yKFwiQ2Fubm90IGdldCByb3dzIGFuZCBjb2x1bW5zIG9mIGFuIGVtcHR5IHNoYXBlIGFycmF5LlwiKTtyZXR1cm5bZS5sZW5ndGg+MT9lW2UubGVuZ3RoLTJdOjEsZVtlLmxlbmd0aC0xXV19LHQuc2l6ZVRvU3F1YXJpc2hTaGFwZT1sLHQuZ2V0QmF0Y2hEaW09ZnVuY3Rpb24oZSx0PTIpe3JldHVybiB1KGUuc2xpY2UoMCxlLmxlbmd0aC10KSl9fSwzMzE0OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGU9dC5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQ9dC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlPXZvaWQgMDtjb25zdCByPW4oNzI3Myksbz1uKDU2MzkpO3QuY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZT0oZSxuLHIpPT57Y29uc3QgaT1yPT09by5UZXh0dXJlVHlwZS51bnBhY2tlZHx8cj09PW8uVGV4dHVyZVR5cGUudW5wYWNrZWRSZXZlcnNlZD8xOjQsYT1yPT09by5UZXh0dXJlVHlwZS5wYWNrZWQscz1yPT09by5UZXh0dXJlVHlwZS51bnBhY2tlZFJldmVyc2VkfHxyPT09by5UZXh0dXJlVHlwZS5wYWNrZWQsdT1yPT09by5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uP24ubGVuZ3RoLTE6dm9pZCAwLGw9cj09PW8uVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbj9uLm1hcCgoKGUsdCk9PnQ9PT1uLmxlbmd0aC0xPzQqZTplKSk6dm9pZCAwO3JldHVybigwLHQuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZSkoZSxuLGksbCx7aXNQYWNrZWQ6YSxyZXZlcnNlV0g6cyxicmVha0F4aXM6dX0pfSx0LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodD0oZSxuLHIpPT57Y29uc3Qgbz0oMCx0LmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tVGV4dHVyZVR5cGUpKGUsbixyKTtyZXR1cm5bby53aWR0aCxvLmhlaWdodF19LHQuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZT0oZSx0LG49MSxvLGkpPT57Y29uc3QgYT0hKCFpfHwhaS5pc1BhY2tlZCksW3MsdV09ZS5jb21wdXRlVGV4dHVyZVdIKGEmJm98fHQsaSksbD10Lmxlbmd0aDtsZXQgYz10LnNsaWNlKDApO2lmKDA9PT1sJiYoYz1bMV0pLDE9PT1uKW89dDtlbHNlIGlmKGEpe2lmKDQhPT1uKXRocm93IG5ldyBFcnJvcihcImEgcGFja2VkIHRleHR1cmUgbXVzdCBiZSA0LWNoYW5uZWxcIik7bz10LGw+MCYmKGNbbC0xXT1NYXRoLmNlaWwoY1tsLTFdLzIpKSxsPjEmJihjW2wtMl09TWF0aC5jZWlsKGNbbC0yXS8yKSl9ZWxzZSBpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJVbnBhY2tlZCBzaGFwZSBpcyBuZWVkZWQgd2hlbiB1c2luZyBjaGFubmVscyA+IDFcIik7cmV0dXJue3dpZHRoOnMsaGVpZ2h0OnUsY2hhbm5lbHM6bixpc1BhY2tlZDphLHNoYXBlOmMsc3RyaWRlczpyLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhjKSx1bnBhY2tlZFNoYXBlOm8scmV2ZXJzZWRXSDppJiZpLnJldmVyc2VXSH19fSw1MjQzOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlRleHR1cmVNYW5hZ2VyPXZvaWQgMDtjb25zdCByPW4oMTMxNSk7dC5UZXh0dXJlTWFuYWdlcj1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixyKXt0aGlzLmdsQ29udGV4dD1lLHRoaXMubGF5b3V0U3RyYXRlZ3k9dCx0aGlzLnByb2ZpbGVyPW4sdGhpcy5jb25maWc9cix0aGlzLnBlbmRpbmdSZWFkPW5ldyBNYXAsci5yZXVzZVRleHR1cmVzJiYodGhpcy5pblVzZVRleHR1cmVzPW5ldyBNYXAsdGhpcy5pZGxlVGV4dHVyZXM9bmV3IE1hcCx0aGlzLnRleHR1cmVMb29rdXA9bmV3IE1hcCl9Y3JlYXRlVGV4dHVyZUZyb21MYXlvdXQoZSx0LG4sbyl7Y29uc3QgaT10aGlzLnRvRW5jb2RlclR5cGUoZSksYT10aGlzLmdsQ29udGV4dC5nZXRFbmNvZGVyKGksdC5jaGFubmVsc3x8MSxvKTtpZih0LmlzUGFja2VkJiYxPT09byl0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7Y29uc3Qgcz10LndpZHRoLHU9dC5oZWlnaHQ7bGV0IGwsYztpZih0aGlzLmNvbmZpZy5yZXVzZVRleHR1cmVzKXtsPWAke3N9eCR7dX1fJHthLmZvcm1hdH1fJHthLmludGVybmFsRm9ybWF0fV8ke2EudGV4dHVyZVR5cGV9YCxjPXRoaXMuaW5Vc2VUZXh0dXJlcy5nZXQobCksY3x8KGM9W10sdGhpcy5pblVzZVRleHR1cmVzLnNldChsLGMpKTtjb25zdCB0PXRoaXMuaWRsZVRleHR1cmVzLmdldChsKTtpZih0JiZ0Lmxlbmd0aD4wKXtjb25zdCByPXQucG9wKCk7cmV0dXJuIGMucHVzaChyKSwxPT09byYmdGhpcy5nbENvbnRleHQudXBkYXRlVGV4dHVyZShyLHMsdSxhLHRoaXMudG9UZXh0dXJlRGF0YShlLG4pKSxyfX1yLkxvZ2dlci52ZXJib3NlKFwiVGV4dHVyZU1hbmFnZXJcIixgQ3JlYXRpbmcgbmV3IHRleHR1cmUgb2Ygc2l6ZSAke3Qud2lkdGh9eCR7dC5oZWlnaHR9YCk7Y29uc3QgcD10aGlzLmdsQ29udGV4dC5hbGxvY2F0ZVRleHR1cmUocyx1LGEsdGhpcy50b1RleHR1cmVEYXRhKGUsbikpO3JldHVybiB0aGlzLmNvbmZpZy5yZXVzZVRleHR1cmVzJiYoYy5wdXNoKHApLHRoaXMudGV4dHVyZUxvb2t1cC5zZXQocCxsKSkscH1yZWFkVGV4dHVyZShlLHQsbil7cmV0dXJuIG58fChuPTEpLHRoaXMucHJvZmlsZXIuZXZlbnQoXCJiYWNrZW5kXCIsXCJUZXh0dXJlTWFuYWdlci5yZWFkVGV4dHVyZVwiLCgoKT0+e2NvbnN0IHI9ZS5zaGFwZS5yZWR1Y2UoKChlLHQpPT5lKnQpKSpuLG89dGhpcy5nbENvbnRleHQucmVhZFRleHR1cmUoZS50ZXh0dXJlLGUud2lkdGgsZS5oZWlnaHQscix0aGlzLnRvRW5jb2RlclR5cGUodCksbik7cmV0dXJuIHRoaXMudG9UZW5zb3JEYXRhKHQsbyl9KSl9YXN5bmMgcmVhZFRleHR1cmVBc3luYyhlLHQsbil7Y29uc3Qgcj1lLnRlbnNvci5kYXRhSWQ7aWYobnx8KG49MSksdGhpcy5wZW5kaW5nUmVhZC5oYXMocikpe2NvbnN0IGU9dGhpcy5wZW5kaW5nUmVhZC5nZXQocik7cmV0dXJuIG5ldyBQcm9taXNlKCh0PT5udWxsPT1lP3ZvaWQgMDplLnB1c2godCkpKX1yZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlRleHR1cmVNYW5hZ2VyLnJlYWRUZXh0dXJlQXN5bmNcIiwoYXN5bmMoKT0+e3RoaXMucGVuZGluZ1JlYWQuc2V0KHIsW10pO2NvbnN0IG89ZS5zaGFwZS5yZWR1Y2UoKChlLHQpPT5lKnQpKSpuO2F3YWl0IHRoaXMuZ2xDb250ZXh0LmNyZWF0ZUFuZFdhaXRGb3JGZW5jZSgpO2NvbnN0IGk9dGhpcy5nbENvbnRleHQucmVhZFRleHR1cmUoZS50ZXh0dXJlLGUud2lkdGgsZS5oZWlnaHQsbyx0aGlzLnRvRW5jb2RlclR5cGUodCksbiksYT10aGlzLnRvVGVuc29yRGF0YSh0LGkpLHM9dGhpcy5wZW5kaW5nUmVhZC5nZXQocik7cmV0dXJuIHRoaXMucGVuZGluZ1JlYWQuZGVsZXRlKHIpLG51bGw9PXN8fHMuZm9yRWFjaCgoZT0+ZShhKSkpLGF9KSl9cmVhZFVpbnQ4VGV4dHVyZUFzRmxvYXQoZSl7cmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoXCJiYWNrZW5kXCIsXCJUZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdFwiLCgoKT0+e2NvbnN0IHQ9ZS5zaGFwZS5yZWR1Y2UoKChlLHQpPT5lKnQpKSxuPXRoaXMuZ2xDb250ZXh0LnJlYWRUZXh0dXJlKGUudGV4dHVyZSxlLndpZHRoLGUuaGVpZ2h0LDQqdCxcImJ5dGVcIiw0KTtyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShuLmJ1ZmZlcixuLmJ5dGVPZmZzZXQsdCl9KSl9cmVsZWFzZVRleHR1cmUoZSx0KXtsZXQgbjtpZih0aGlzLmNvbmZpZy5yZXVzZVRleHR1cmVzJiYobj10aGlzLnRleHR1cmVMb29rdXAuZ2V0KGUudGV4dHVyZSksbikpe3QmJnRoaXMudGV4dHVyZUxvb2t1cC5kZWxldGUobik7Y29uc3Qgcj10aGlzLmluVXNlVGV4dHVyZXMuZ2V0KG4pO2lmKHIpe2NvbnN0IHQ9ci5pbmRleE9mKGUudGV4dHVyZSk7aWYoLTEhPT10KXtyLnNwbGljZSh0LDEpO2xldCBvPXRoaXMuaWRsZVRleHR1cmVzLmdldChuKTtvfHwobz1bXSx0aGlzLmlkbGVUZXh0dXJlcy5zZXQobixvKSksby5wdXNoKGUudGV4dHVyZSl9fX1uJiYhdHx8KHIuTG9nZ2VyLnZlcmJvc2UoXCJUZXh0dXJlTWFuYWdlclwiLGBEZWxldGluZyB0ZXh0dXJlIG9mIHNpemUgJHtlLndpZHRofXgke2UuaGVpZ2h0fWApLHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVRleHR1cmUoZS50ZXh0dXJlKSl9dG9UZW5zb3JEYXRhKGUsdCl7c3dpdGNoKGUpe2Nhc2VcImludDE2XCI6cmV0dXJuIHQgaW5zdGFuY2VvZiBJbnQxNkFycmF5P3Q6SW50MTZBcnJheS5mcm9tKHQpO2Nhc2VcImludDMyXCI6cmV0dXJuIHQgaW5zdGFuY2VvZiBJbnQzMkFycmF5P3Q6SW50MzJBcnJheS5mcm9tKHQpO2Nhc2VcImludDhcIjpyZXR1cm4gdCBpbnN0YW5jZW9mIEludDhBcnJheT90OkludDhBcnJheS5mcm9tKHQpO2Nhc2VcInVpbnQxNlwiOnJldHVybiB0IGluc3RhbmNlb2YgVWludDE2QXJyYXk/dDpVaW50MTZBcnJheS5mcm9tKHQpO2Nhc2VcInVpbnQzMlwiOnJldHVybiB0IGluc3RhbmNlb2YgVWludDMyQXJyYXk/dDpVaW50MzJBcnJheS5mcm9tKHQpO2Nhc2VcInVpbnQ4XCI6Y2FzZVwiYm9vbFwiOnJldHVybiB0IGluc3RhbmNlb2YgVWludDhBcnJheT90OlVpbnQ4QXJyYXkuZnJvbSh0KTtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIHQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXk/dDpGbG9hdDMyQXJyYXkuZnJvbSh0KTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIHQgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXk/dDpGbG9hdDY0QXJyYXkuZnJvbSh0KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVGVuc29yRGF0YSB0eXBlICR7ZX0gaXMgbm90IHN1cHBvcnRlZGApfX10b1RleHR1cmVEYXRhKGUsdCl7aWYodClyZXR1cm4gdCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheT90Om5ldyBGbG9hdDMyQXJyYXkodCl9dG9FbmNvZGVyVHlwZShlKXtyZXR1cm5cImZsb2F0XCJ9Y2xlYXJBY3RpdmVUZXh0dXJlcygpe3RoaXMuZ2xDb250ZXh0LmNsZWFyQWN0aXZlVGV4dHVyZXMoKX19fSw1NjM5OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIG47T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5UZXh0dXJlVHlwZT12b2lkIDAsKG49dC5UZXh0dXJlVHlwZXx8KHQuVGV4dHVyZVR5cGU9e30pKVtuLnVucGFja2VkPTBdPVwidW5wYWNrZWRcIixuW24udW5wYWNrZWRSZXZlcnNlZD0xXT1cInVucGFja2VkUmV2ZXJzZWRcIixuW24ucGFja2VkPTJdPVwicGFja2VkXCIsbltuLmRvd25sb2FkVWludDhBc0Zsb2F0PTNdPVwiZG93bmxvYWRVaW50OEFzRmxvYXRcIixuW24ucGFja2VkTGFzdERpbWVuc2lvbj00XT1cInBhY2tlZExhc3REaW1lbnNpb25cIn0sNDMyOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldEdsQ2hhbm5lbHM9dC5nZXRDb29yZHNEYXRhVHlwZT10LmdldFNxdWVlemVkUGFyYW1zPXQuc3F1ZWV6ZUlucHV0U2hhcGU9dC5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWVBdE91dENvb3Jkcz10LmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZT10LnJlcGVhdGVkVHJ5PXQuZ2V0UGFja2VkU2hhcGU9dm9pZCAwO2NvbnN0IHI9big3MjczKTt0LmdldFBhY2tlZFNoYXBlPWZ1bmN0aW9uKGUpe2NvbnN0IHQ9ZS5sZW5ndGg7cmV0dXJuIGUuc2xpY2UoMCx0LTEpLmNvbmNhdChlW3QtMV0vNCl9LHQucmVwZWF0ZWRUcnk9YXN5bmMgZnVuY3Rpb24oZSx0PShlPT4wKSxuKXtyZXR1cm4gbmV3IFByb21pc2UoKChyLG8pPT57bGV0IGk9MDtjb25zdCBhPSgpPT57aWYoZSgpKXJldHVybiB2b2lkIHIoKTtpKys7Y29uc3Qgcz10KGkpO251bGwhPW4mJmk+PW4/bygpOnNldFRpbWVvdXQoYSxzKX07YSgpfSkpfSx0LmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZT1mdW5jdGlvbihlKXtyZXR1cm4oMCxyLmFzc2VydCkodm9pZCAwIT09ZSYmMCE9PWUubGVuZ3RoLCgoKT0+XCJlbXB0eSBzdHJpbmcgZm91bmQgZm9yIHNhbXBsZXIgbmFtZVwiKSksXCJnZXRcIitlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSl9LHQuZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHM9ZnVuY3Rpb24oZSl7cmV0dXJuKDAsci5hc3NlcnQpKHZvaWQgMCE9PWUmJjAhPT1lLmxlbmd0aCwoKCk9PlwiZW1wdHkgc3RyaW5nIGZvdW5kIGZvciBzYW1wbGVyIG5hbWVcIikpLFwiZ2V0XCIrZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStlLnNsaWNlKDEpK1wiQXRPdXRDb29yZHNcIn0sdC5zcXVlZXplSW5wdXRTaGFwZT1mdW5jdGlvbihlLHQpe2xldCBuPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZSkpO3JldHVybiBuPXQsbn0sdC5nZXRTcXVlZXplZFBhcmFtcz1mdW5jdGlvbihlLHQpe3JldHVybiB0Lm1hcCgodD0+ZVt0XSkpLmpvaW4oXCIsIFwiKX0sdC5nZXRDb29yZHNEYXRhVHlwZT1mdW5jdGlvbihlKXtpZihlPD0xKXJldHVyblwiaW50XCI7aWYoMj09PWUpcmV0dXJuXCJpdmVjMlwiO2lmKDM9PT1lKXJldHVyblwiaXZlYzNcIjtpZig0PT09ZSlyZXR1cm5cIml2ZWM0XCI7aWYoNT09PWUpcmV0dXJuXCJpdmVjNVwiO2lmKDY9PT1lKXJldHVyblwiaXZlYzZcIjt0aHJvdyBFcnJvcihgR1BVIGZvciByYW5rICR7ZX0gaXMgbm90IHlldCBzdXBwb3J0ZWRgKX0sdC5nZXRHbENoYW5uZWxzPWZ1bmN0aW9uKGU9Nil7cmV0dXJuW1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXS5zbGljZSgwLGUpfX0sMzM4OTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5jcmVhdGVOZXdXZWJHTENvbnRleHQ9dC5jcmVhdGVXZWJHTENvbnRleHQ9dm9pZCAwO2NvbnN0IHI9bigxMzE1KSxvPW4oMzUyNCksaT17fTtmdW5jdGlvbiBhKGUpe2NvbnN0IHQ9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZG9jdW1lbnQpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBPZmZzY3JlZW5DYW52YXMpdGhyb3cgbmV3IFR5cGVFcnJvcihcImZhaWxlZCB0byBjcmVhdGUgY2FudmFzOiBPZmZzY3JlZW5DYW52YXMgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpfWNvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtyZXR1cm4gZS53aWR0aD0xLGUuaGVpZ2h0PTEsZX0oKTtsZXQgbjtjb25zdCBpPXthbHBoYTohMSxkZXB0aDohMSxhbnRpYWxpYXM6ITEsc3RlbmNpbDohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEscHJlbXVsdGlwbGllZEFscGhhOiExLGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6ITF9O2lmKCghZXx8XCJ3ZWJnbDJcIj09PWUpJiYobj10LmdldENvbnRleHQoXCJ3ZWJnbDJcIixpKSxuKSl0cnl7cmV0dXJuIG5ldyBvLldlYkdMQ29udGV4dChuLDIpfWNhdGNoKGUpe3IuTG9nZ2VyLndhcm5pbmcoXCJHbENvbnRleHRGYWN0b3J5XCIsYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wyJy4gRXJyb3I6ICR7ZX1gKX1pZigoIWV8fFwid2ViZ2xcIj09PWUpJiYobj10LmdldENvbnRleHQoXCJ3ZWJnbFwiLGkpfHx0LmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIixpKSxuKSl0cnl7cmV0dXJuIG5ldyBvLldlYkdMQ29udGV4dChuLDEpfWNhdGNoKGUpe3IuTG9nZ2VyLndhcm5pbmcoXCJHbENvbnRleHRGYWN0b3J5XCIsYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wnIG9yICdleHBlcmltZW50YWwtd2ViZ2wnLiBFcnJvcjogJHtlfWApfXRocm93IG5ldyBFcnJvcihcIldlYkdMIGlzIG5vdCBzdXBwb3J0ZWRcIil9dC5jcmVhdGVXZWJHTENvbnRleHQ9ZnVuY3Rpb24gZSh0KXtsZXQgbjt0JiZcIndlYmdsMlwiIT09dHx8IShcIndlYmdsMlwiaW4gaSk/dCYmXCJ3ZWJnbFwiIT09dHx8IShcIndlYmdsXCJpbiBpKXx8KG49aS53ZWJnbCk6bj1pLndlYmdsMixuPW58fGEodCksdD10fHwxPT09bi52ZXJzaW9uP1wid2ViZ2xcIjpcIndlYmdsMlwiO2NvbnN0IHI9bi5nbDtyZXR1cm4gaVt0XT1uLHIuaXNDb250ZXh0TG9zdCgpPyhkZWxldGUgaVt0XSxlKHQpKTooci5kaXNhYmxlKHIuREVQVEhfVEVTVCksci5kaXNhYmxlKHIuU1RFTkNJTF9URVNUKSxyLmRpc2FibGUoci5CTEVORCksci5kaXNhYmxlKHIuRElUSEVSKSxyLmRpc2FibGUoci5QT0xZR09OX09GRlNFVF9GSUxMKSxyLmRpc2FibGUoci5TQU1QTEVfQ09WRVJBR0UpLHIuZW5hYmxlKHIuU0NJU1NPUl9URVNUKSxyLmVuYWJsZShyLkNVTExfRkFDRSksci5jdWxsRmFjZShyLkJBQ0spLG4pfSx0LmNyZWF0ZU5ld1dlYkdMQ29udGV4dD1hfSwzNTI0OmZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG4pO28mJiEoXCJnZXRcImluIG8/IXQuX19lc01vZHVsZTpvLndyaXRhYmxlfHxvLmNvbmZpZ3VyYWJsZSl8fChvPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsbyl9OmZ1bmN0aW9uKGUsdCxuLHIpe3ZvaWQgMD09PXImJihyPW4pLGVbcl09dFtuXX0pLG89dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pfTpmdW5jdGlvbihlLHQpe2UuZGVmYXVsdD10fSksaT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciBuIGluIGUpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxuKSYmcih0LGUsbik7cmV0dXJuIG8odCxlKSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LldlYkdMQ29udGV4dD10LmxpbmVhclNlYXJjaExhc3RUcnVlPXZvaWQgMDtjb25zdCBhPW4oODQ1Mykscz1pKG4oOTYyMikpLHU9big0MzIpO2Z1bmN0aW9uIGwoZSl7bGV0IHQ9MDtmb3IoO3Q8ZS5sZW5ndGgmJmVbdF0oKTsrK3QpO3JldHVybiB0LTF9dC5saW5lYXJTZWFyY2hMYXN0VHJ1ZT1sLHQuV2ViR0xDb250ZXh0PWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5mcmFtZUJ1ZmZlckJvdW5kPSExLHRoaXMuaXRlbXNUb1BvbGw9W10sdGhpcy5nbD1lLHRoaXMudmVyc2lvbj10LHRoaXMuZ2V0RXh0ZW5zaW9ucygpLHRoaXMudmVydGV4YnVmZmVyPXRoaXMuY3JlYXRlVmVydGV4YnVmZmVyKCksdGhpcy5mcmFtZWJ1ZmZlcj10aGlzLmNyZWF0ZUZyYW1lYnVmZmVyKCksdGhpcy5xdWVyeVZpdGFsUGFyYW1ldGVycygpfWFsbG9jYXRlVGV4dHVyZShlLHQsbixyKXtjb25zdCBvPXRoaXMuZ2wsaT1vLmNyZWF0ZVRleHR1cmUoKTtvLmJpbmRUZXh0dXJlKG8uVEVYVFVSRV8yRCxpKSxvLnRleFBhcmFtZXRlcmkoby5URVhUVVJFXzJELG8uVEVYVFVSRV9NSU5fRklMVEVSLG8uTkVBUkVTVCksby50ZXhQYXJhbWV0ZXJpKG8uVEVYVFVSRV8yRCxvLlRFWFRVUkVfTUFHX0ZJTFRFUixvLk5FQVJFU1QpLG8udGV4UGFyYW1ldGVyaShvLlRFWFRVUkVfMkQsby5URVhUVVJFX1dSQVBfUyxvLkNMQU1QX1RPX0VER0UpLG8udGV4UGFyYW1ldGVyaShvLlRFWFRVUkVfMkQsby5URVhUVVJFX1dSQVBfVCxvLkNMQU1QX1RPX0VER0UpO2NvbnN0IGE9cj9uLmVuY29kZShyLGUqdCk6bnVsbDtyZXR1cm4gby50ZXhJbWFnZTJEKG8uVEVYVFVSRV8yRCwwLG4uaW50ZXJuYWxGb3JtYXQsZSx0LDAsbi5mb3JtYXQsbi50ZXh0dXJlVHlwZSxhKSx0aGlzLmNoZWNrRXJyb3IoKSxpfXVwZGF0ZVRleHR1cmUoZSx0LG4scixvKXtjb25zdCBpPXRoaXMuZ2w7aS5iaW5kVGV4dHVyZShpLlRFWFRVUkVfMkQsZSk7Y29uc3QgYT1yLmVuY29kZShvLHQqbik7aS50ZXhTdWJJbWFnZTJEKGkuVEVYVFVSRV8yRCwwLDAsMCx0LG4sci5mb3JtYXQsci50ZXh0dXJlVHlwZSxhKSx0aGlzLmNoZWNrRXJyb3IoKX1hdHRhY2hGcmFtZWJ1ZmZlcihlLHQsbil7Y29uc3Qgcj10aGlzLmdsO3IuYmluZFRleHR1cmUoci5URVhUVVJFXzJELGUpLHIuYmluZEZyYW1lYnVmZmVyKHIuRlJBTUVCVUZGRVIsdGhpcy5mcmFtZWJ1ZmZlciksci5mcmFtZWJ1ZmZlclRleHR1cmUyRChyLkZSQU1FQlVGRkVSLHIuQ09MT1JfQVRUQUNITUVOVDAsci5URVhUVVJFXzJELGUsMCksdGhpcy5jaGVja0Vycm9yKCksci52aWV3cG9ydCgwLDAsdCxuKSxyLnNjaXNzb3IoMCwwLHQsbil9cmVhZFRleHR1cmUoZSx0LG4scixvLGkpe2NvbnN0IGE9dGhpcy5nbDtpfHwoaT0xKSx0aGlzLmZyYW1lQnVmZmVyQm91bmR8fHRoaXMuYXR0YWNoRnJhbWVidWZmZXIoZSx0LG4pO2NvbnN0IHM9dGhpcy5nZXRFbmNvZGVyKG8saSksdT1zLmFsbG9jYXRlKHQqbik7cmV0dXJuIGEuYmluZFRleHR1cmUoYS5URVhUVVJFXzJELGUpLGEuZnJhbWVidWZmZXJUZXh0dXJlMkQoYS5GUkFNRUJVRkZFUixhLkNPTE9SX0FUVEFDSE1FTlQwLGEuVEVYVFVSRV8yRCxlLDApLGEucmVhZFBpeGVscygwLDAsdCxuLGEuUkdCQSxzLnRleHR1cmVUeXBlLHUpLHRoaXMuY2hlY2tFcnJvcigpLHMuZGVjb2RlKHUscil9aXNGcmFtZWJ1ZmZlclJlYWR5KCl7cmV0dXJuITB9Z2V0QWN0aXZlVGV4dHVyZSgpe2NvbnN0IGU9dGhpcy5nbDtyZXR1cm5cIlRFWFRVUkVcIisoZS5nZXRQYXJhbWV0ZXIodGhpcy5nbC5BQ1RJVkVfVEVYVFVSRSktZS5URVhUVVJFMCl9Z2V0VGV4dHVyZUJpbmRpbmcoKXtyZXR1cm4gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5URVhUVVJFX0JJTkRJTkdfMkQpfWdldEZyYW1lYnVmZmVyQmluZGluZygpe3JldHVybiB0aGlzLmdsLmdldFBhcmFtZXRlcih0aGlzLmdsLkZSQU1FQlVGRkVSX0JJTkRJTkcpfXNldFZlcnRleEF0dHJpYnV0ZXMoZSx0KXtjb25zdCBuPXRoaXMuZ2w7bi52ZXJ0ZXhBdHRyaWJQb2ludGVyKGUsMyxuLkZMT0FULCExLDIwLDApLG4uZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoZSksLTEhPT10JiYobi52ZXJ0ZXhBdHRyaWJQb2ludGVyKHQsMixuLkZMT0FULCExLDIwLDEyKSxuLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHQpKSx0aGlzLmNoZWNrRXJyb3IoKX1jcmVhdGVQcm9ncmFtKGUsdCl7Y29uc3Qgbj10aGlzLmdsLHI9bi5jcmVhdGVQcm9ncmFtKCk7cmV0dXJuIG4uYXR0YWNoU2hhZGVyKHIsZSksbi5hdHRhY2hTaGFkZXIocix0KSxuLmxpbmtQcm9ncmFtKHIpLHJ9Y29tcGlsZVNoYWRlcihlLHQpe2NvbnN0IG49dGhpcy5nbCxyPW4uY3JlYXRlU2hhZGVyKHQpO2lmKCFyKXRocm93IG5ldyBFcnJvcihgY3JlYXRlU2hhZGVyKCkgcmV0dXJuZWQgbnVsbCB3aXRoIHR5cGUgJHt0fWApO2lmKG4uc2hhZGVyU291cmNlKHIsZSksbi5jb21waWxlU2hhZGVyKHIpLCExPT09bi5nZXRTaGFkZXJQYXJhbWV0ZXIocixuLkNPTVBJTEVfU1RBVFVTKSl0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjb21waWxlIHNoYWRlcjogJHtuLmdldFNoYWRlckluZm9Mb2cocil9XFxuU2hhZGVyIHNvdXJjZTpcXG4ke2V9YCk7cmV0dXJuIHJ9ZGVsZXRlU2hhZGVyKGUpe3RoaXMuZ2wuZGVsZXRlU2hhZGVyKGUpfWJpbmRUZXh0dXJlVG9Vbmlmb3JtKGUsdCxuKXtjb25zdCByPXRoaXMuZ2w7ci5hY3RpdmVUZXh0dXJlKHIuVEVYVFVSRTArdCksdGhpcy5jaGVja0Vycm9yKCksci5iaW5kVGV4dHVyZShyLlRFWFRVUkVfMkQsZSksdGhpcy5jaGVja0Vycm9yKCksci51bmlmb3JtMWkobix0KSx0aGlzLmNoZWNrRXJyb3IoKX1kcmF3KCl7dGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZ2wuVFJJQU5HTEVfU1RSSVAsMCw0KSx0aGlzLmNoZWNrRXJyb3IoKX1jaGVja0Vycm9yKCl7aWYoYS5lbnYuZGVidWcpe2NvbnN0IGU9dGhpcy5nbCx0PWUuZ2V0RXJyb3IoKTtsZXQgbj1cIlwiO3N3aXRjaCh0KXtjYXNlIGUuTk9fRVJST1I6cmV0dXJuO2Nhc2UgZS5JTlZBTElEX0VOVU06bj1cIklOVkFMSURfRU5VTVwiO2JyZWFrO2Nhc2UgZS5JTlZBTElEX1ZBTFVFOm49XCJJTlZBTElEX1ZBTFVFXCI7YnJlYWs7Y2FzZSBlLklOVkFMSURfT1BFUkFUSU9OOm49XCJJTlZBTElEX09QRVJBVElPTlwiO2JyZWFrO2Nhc2UgZS5JTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTjpuPVwiSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT05cIjticmVhaztjYXNlIGUuT1VUX09GX01FTU9SWTpuPVwiT1VUX09GX01FTU9SWVwiO2JyZWFrO2Nhc2UgZS5DT05URVhUX0xPU1RfV0VCR0w6bj1cIkNPTlRFWFRfTE9TVF9XRUJHTFwiO2JyZWFrO2RlZmF1bHQ6bj1gVW5rbm93biBXZWJHTCBFcnJvcjogJHt0LnRvU3RyaW5nKDE2KX1gfXRocm93IG5ldyBFcnJvcihuKX19ZGVsZXRlVGV4dHVyZShlKXt0aGlzLmdsLmRlbGV0ZVRleHR1cmUoZSl9ZGVsZXRlUHJvZ3JhbShlKXt0aGlzLmdsLmRlbGV0ZVByb2dyYW0oZSl9Z2V0RW5jb2RlcihlLHQsbj0wKXtpZigyPT09dGhpcy52ZXJzaW9uKXJldHVybiBuZXcgcy5SZWRGbG9hdDMyRGF0YUVuY29kZXIodGhpcy5nbCx0KTtzd2l0Y2goZSl7Y2FzZVwiZmxvYXRcIjpyZXR1cm4gMT09PW58fHRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkP25ldyBzLlJHQkFGbG9hdERhdGFFbmNvZGVyKHRoaXMuZ2wsdCk6bmV3IHMuUkdCQUZsb2F0RGF0YUVuY29kZXIodGhpcy5nbCx0LHRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbi5IQUxGX0ZMT0FUX09FUyk7Y2FzZVwiaW50XCI6dGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO2Nhc2VcImJ5dGVcIjpyZXR1cm4gbmV3IHMuVWludDhEYXRhRW5jb2Rlcih0aGlzLmdsLHQpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGFUeXBlOiAke2V9YCl9fWNsZWFyQWN0aXZlVGV4dHVyZXMoKXtjb25zdCBlPXRoaXMuZ2w7Zm9yKGxldCB0PTA7dDx0aGlzLm1heFRleHR1cmVJbWFnZVVuaXRzOysrdCllLmFjdGl2ZVRleHR1cmUoZS5URVhUVVJFMCt0KSxlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCxudWxsKX1kaXNwb3NlKCl7aWYodGhpcy5kaXNwb3NlZClyZXR1cm47Y29uc3QgZT10aGlzLmdsO2UuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsbnVsbCksZS5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLmZyYW1lYnVmZmVyKSxlLmJpbmRCdWZmZXIoZS5BUlJBWV9CVUZGRVIsbnVsbCksZS5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhidWZmZXIpLGUuYmluZEJ1ZmZlcihlLkVMRU1FTlRfQVJSQVlfQlVGRkVSLG51bGwpLGUuZmluaXNoKCksdGhpcy5kaXNwb3NlZD0hMH1jcmVhdGVEZWZhdWx0R2VvbWV0cnkoKXtyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbLTEsMSwwLDAsMSwtMSwtMSwwLDAsMCwxLDEsMCwxLDEsMSwtMSwwLDEsMF0pfWNyZWF0ZVZlcnRleGJ1ZmZlcigpe2NvbnN0IGU9dGhpcy5nbCx0PWUuY3JlYXRlQnVmZmVyKCk7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiY3JlYXRlQnVmZmVyKCkgcmV0dXJuZWQgbnVsbFwiKTtjb25zdCBuPXRoaXMuY3JlYXRlRGVmYXVsdEdlb21ldHJ5KCk7cmV0dXJuIGUuYmluZEJ1ZmZlcihlLkFSUkFZX0JVRkZFUix0KSxlLmJ1ZmZlckRhdGEoZS5BUlJBWV9CVUZGRVIsbixlLlNUQVRJQ19EUkFXKSx0aGlzLmNoZWNrRXJyb3IoKSx0fWNyZWF0ZUZyYW1lYnVmZmVyKCl7Y29uc3QgZT10aGlzLmdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiY3JlYXRlRnJhbWVidWZmZXIgcmV0dXJuZWQgbnVsbFwiKTtyZXR1cm4gZX1xdWVyeVZpdGFsUGFyYW1ldGVycygpe2NvbnN0IGU9dGhpcy5nbDtpZih0aGlzLmlzRmxvYXRUZXh0dXJlQXR0YWNoYWJsZVRvRnJhbWVCdWZmZXI9dGhpcy5jaGVja0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyKCksdGhpcy5pc1JlbmRlckZsb2F0MzJTdXBwb3J0ZWQ9dGhpcy5jaGVja1JlbmRlckZsb2F0MzIoKSx0aGlzLmlzRmxvYXQzMkRvd25sb2FkU3VwcG9ydGVkPXRoaXMuY2hlY2tGbG9hdDMyRG93bmxvYWQoKSwxPT09dGhpcy52ZXJzaW9uJiYhdGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uJiYhdGhpcy5pc1JlbmRlckZsb2F0MzJTdXBwb3J0ZWQpdGhyb3cgbmV3IEVycm9yKFwiYm90aCBmbG9hdDMyIGFuZCBmbG9hdDE2IFRleHR1cmVUeXBlIGFyZSBub3Qgc3VwcG9ydGVkXCIpO3RoaXMuaXNCbGVuZFN1cHBvcnRlZD0hdGhpcy5pc1JlbmRlckZsb2F0MzJTdXBwb3J0ZWR8fHRoaXMuY2hlY2tGbG9hdDMyQmxlbmQoKSx0aGlzLm1heFRleHR1cmVTaXplPWUuZ2V0UGFyYW1ldGVyKGUuTUFYX1RFWFRVUkVfU0laRSksdGhpcy5tYXhUZXh0dXJlSW1hZ2VVbml0cz1lLmdldFBhcmFtZXRlcihlLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKSx0aGlzLnZlcnNpb259Z2V0RXh0ZW5zaW9ucygpezI9PT10aGlzLnZlcnNpb24/KHRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbj10aGlzLmdsLmdldEV4dGVuc2lvbihcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIiksdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24oXCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyXCIpKToodGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSx0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpKX1jaGVja0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyKCl7Y29uc3QgZT10aGlzLmdsLHQ9ZS5jcmVhdGVUZXh0dXJlKCk7ZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsdCk7Y29uc3Qgbj0yPT09dGhpcy52ZXJzaW9uP2UuUkdCQTMyRjplLlJHQkE7ZS50ZXhJbWFnZTJEKGUuVEVYVFVSRV8yRCwwLG4sMSwxLDAsZS5SR0JBLGUuRkxPQVQsbnVsbCk7Y29uc3Qgcj1lLmNyZWF0ZUZyYW1lYnVmZmVyKCk7ZS5iaW5kRnJhbWVidWZmZXIoZS5GUkFNRUJVRkZFUixyKSxlLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGUuRlJBTUVCVUZGRVIsZS5DT0xPUl9BVFRBQ0hNRU5UMCxlLlRFWFRVUkVfMkQsdCwwKTtjb25zdCBvPWUuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhlLkZSQU1FQlVGRkVSKT09PWUuRlJBTUVCVUZGRVJfQ09NUExFVEU7cmV0dXJuIGUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELG51bGwpLGUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsbnVsbCksZS5kZWxldGVUZXh0dXJlKHQpLGUuZGVsZXRlRnJhbWVidWZmZXIociksb31jaGVja1JlbmRlckZsb2F0MzIoKXtpZigyPT09dGhpcy52ZXJzaW9uKXtpZighdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uKXJldHVybiExfWVsc2UgaWYoIXRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uKXJldHVybiExO3JldHVybiB0aGlzLmlzRmxvYXRUZXh0dXJlQXR0YWNoYWJsZVRvRnJhbWVCdWZmZXJ9Y2hlY2tGbG9hdDMyRG93bmxvYWQoKXtpZigyPT09dGhpcy52ZXJzaW9uKXtpZighdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uKXJldHVybiExfWVsc2V7aWYoIXRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uKXJldHVybiExO2lmKCF0aGlzLmdsLmdldEV4dGVuc2lvbihcIldFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSlyZXR1cm4hMX1yZXR1cm4gdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyfWNoZWNrRmxvYXQzMkJsZW5kKCl7Y29uc3QgZT10aGlzLmdsO2xldCB0LG4scixvLGk7dHJ5e3Q9ZS5jcmVhdGVUZXh0dXJlKCksbj1lLmNyZWF0ZUZyYW1lYnVmZmVyKCksZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsdCk7Y29uc3QgYT0yPT09dGhpcy52ZXJzaW9uP2UuUkdCQTMyRjplLlJHQkE7cmV0dXJuIGUudGV4SW1hZ2UyRChlLlRFWFRVUkVfMkQsMCxhLDEsMSwwLGUuUkdCQSxlLkZMT0FULG51bGwpLGUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsbiksZS5mcmFtZWJ1ZmZlclRleHR1cmUyRChlLkZSQU1FQlVGRkVSLGUuQ09MT1JfQVRUQUNITUVOVDAsZS5URVhUVVJFXzJELHQsMCksZS5lbmFibGUoZS5CTEVORCkscj1lLmNyZWF0ZVNoYWRlcihlLlZFUlRFWF9TSEFERVIpLCEhciYmKGUuc2hhZGVyU291cmNlKHIsXCJ2b2lkIG1haW4oKXt9XCIpLGUuY29tcGlsZVNoYWRlcihyKSxvPWUuY3JlYXRlU2hhZGVyKGUuRlJBR01FTlRfU0hBREVSKSwhIW8mJihlLnNoYWRlclNvdXJjZShvLFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O3ZvaWQgbWFpbigpe2dsX0ZyYWdDb2xvcj12ZWM0KDAuNSk7fVwiKSxlLmNvbXBpbGVTaGFkZXIobyksaT1lLmNyZWF0ZVByb2dyYW0oKSwhIWkmJihlLmF0dGFjaFNoYWRlcihpLHIpLGUuYXR0YWNoU2hhZGVyKGksbyksZS5saW5rUHJvZ3JhbShpKSxlLnVzZVByb2dyYW0oaSksZS5kcmF3QXJyYXlzKGUuUE9JTlRTLDAsMSksZS5nZXRFcnJvcigpPT09ZS5OT19FUlJPUikpKX1maW5hbGx5e2UuZGlzYWJsZShlLkJMRU5EKSxpJiZlLmRlbGV0ZVByb2dyYW0oaSksciYmZS5kZWxldGVTaGFkZXIociksbyYmZS5kZWxldGVTaGFkZXIobyksbiYmKGUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsbnVsbCksZS5kZWxldGVGcmFtZWJ1ZmZlcihuKSksdCYmKGUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELG51bGwpLGUuZGVsZXRlVGV4dHVyZSh0KSl9fWJlZ2luVGltZXIoKXtpZigyPT09dGhpcy52ZXJzaW9uJiZ0aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbil7Y29uc3QgZT10aGlzLmdsLHQ9dGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24sbj1lLmNyZWF0ZVF1ZXJ5KCk7cmV0dXJuIGUuYmVnaW5RdWVyeSh0LlRJTUVfRUxBUFNFRF9FWFQsbiksbn10aHJvdyBuZXcgRXJyb3IoXCJXZWJHTDEgcHJvZmlsaW5nIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLlwiKX1lbmRUaW1lcigpe2lmKDIhPT10aGlzLnZlcnNpb258fCF0aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbil0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTDEgcHJvZmlsaW5nIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkXCIpO3tjb25zdCBlPXRoaXMuZ2wsdD10aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbjtlLmVuZFF1ZXJ5KHQuVElNRV9FTEFQU0VEX0VYVCl9fWlzVGltZXJSZXN1bHRBdmFpbGFibGUoZSl7bGV0IHQ9ITEsbj0hMTtpZigyIT09dGhpcy52ZXJzaW9ufHwhdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiKTt7Y29uc3Qgcj10aGlzLmdsLG89dGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb247dD1yLmdldFF1ZXJ5UGFyYW1ldGVyKGUsci5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFKSxuPXIuZ2V0UGFyYW1ldGVyKG8uR1BVX0RJU0pPSU5UX0VYVCl9cmV0dXJuIHQmJiFufWdldFRpbWVyUmVzdWx0KGUpe2xldCB0PTA7aWYoMiE9PXRoaXMudmVyc2lvbil0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTDEgcHJvZmlsaW5nIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkXCIpO3tjb25zdCBuPXRoaXMuZ2w7dD1uLmdldFF1ZXJ5UGFyYW1ldGVyKGUsbi5RVUVSWV9SRVNVTFQpLG4uZGVsZXRlUXVlcnkoZSl9cmV0dXJuIHQvMWU2fWFzeW5jIHdhaXRGb3JRdWVyeUFuZEdldFRpbWUoZSl7cmV0dXJuIGF3YWl0KDAsdS5yZXBlYXRlZFRyeSkoKCgpPT50aGlzLmlzVGltZXJSZXN1bHRBdmFpbGFibGUoZSkpKSx0aGlzLmdldFRpbWVyUmVzdWx0KGUpfWFzeW5jIGNyZWF0ZUFuZFdhaXRGb3JGZW5jZSgpe2NvbnN0IGU9dGhpcy5jcmVhdGVGZW5jZSh0aGlzLmdsKTtyZXR1cm4gdGhpcy5wb2xsRmVuY2UoZSl9Y3JlYXRlRmVuY2UoZSl7bGV0IHQ7Y29uc3Qgbj1lLHI9bi5mZW5jZVN5bmMobi5TWU5DX0dQVV9DT01NQU5EU19DT01QTEVURSwwKTtyZXR1cm4gZS5mbHVzaCgpLHQ9bnVsbD09PXI/KCk9PiEwOigpPT57Y29uc3QgZT1uLmNsaWVudFdhaXRTeW5jKHIsMCwwKTtyZXR1cm4gZT09PW4uQUxSRUFEWV9TSUdOQUxFRHx8ZT09PW4uQ09ORElUSU9OX1NBVElTRklFRH0se3F1ZXJ5OnIsaXNGZW5jZVBhc3NlZDp0fX1hc3luYyBwb2xsRmVuY2UoZSl7cmV0dXJuIG5ldyBQcm9taXNlKCh0PT57dGhpcy5hZGRJdGVtVG9Qb2xsKCgoKT0+ZS5pc0ZlbmNlUGFzc2VkKCkpLCgoKT0+dCgpKSl9KSl9cG9sbEl0ZW1zKCl7Y29uc3QgZT1sKHRoaXMuaXRlbXNUb1BvbGwubWFwKChlPT5lLmlzRG9uZUZuKSkpO2ZvcihsZXQgdD0wO3Q8PWU7Kyt0KXtjb25zdHtyZXNvbHZlRm46ZX09dGhpcy5pdGVtc1RvUG9sbFt0XTtlKCl9dGhpcy5pdGVtc1RvUG9sbD10aGlzLml0ZW1zVG9Qb2xsLnNsaWNlKGUrMSl9YXN5bmMgYWRkSXRlbVRvUG9sbChlLHQpe3RoaXMuaXRlbXNUb1BvbGwucHVzaCh7aXNEb25lRm46ZSxyZXNvbHZlRm46dH0pLHRoaXMuaXRlbXNUb1BvbGwubGVuZ3RoPjF8fGF3YWl0KDAsdS5yZXBlYXRlZFRyeSkoKCgpPT4odGhpcy5wb2xsSXRlbXMoKSwwPT09dGhpcy5pdGVtc1RvUG9sbC5sZW5ndGgpKSl9fX0sNjQ5NjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5FeGVjdXRpb25QbGFuPXZvaWQgMDtjb25zdCByPW4oMTMxNSk7Y2xhc3Mgb3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMub3A9ZSx0aGlzLm5vZGU9dH19dC5FeGVjdXRpb25QbGFuPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuKXt0aGlzLmdyYXBoPWUsdGhpcy5wcm9maWxlcj1uLHRoaXMuaW5pdGlhbGl6ZSh0KX1pbml0aWFsaXplKGUpe3RoaXMucHJvZmlsZXIuZXZlbnQoXCJzZXNzaW9uXCIsXCJFeGVjdXRpb25QbGFuLmluaXRpYWxpemVcIiwoKCk9Pntjb25zdCB0PXRoaXMuZ3JhcGguZ2V0Tm9kZXMoKTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRoZSBzaXplIG9mIG5vZGVzIGFuZCBPUHMgZG8gbm90IG1hdGNoLlwiKTt0aGlzLl9vcHM9ZS5tYXAoKChlLG4pPT5uZXcgbyhlLHRbbl0pKSksdGhpcy5yZXNldCgpLHRoaXMuX3N0YXJ0ZXI9W10sdGhpcy5fb3BzLmZvckVhY2goKChlLHQpPT57bGV0IG49ITA7Zm9yKGNvbnN0IHQgb2YgZS5ub2RlLmlucHV0cylpZighdGhpcy5fdmFsdWVzW3RdJiYtMT09PXRoaXMuZ3JhcGguZ2V0SW5wdXRJbmRpY2VzKCkuaW5kZXhPZih0KSl7bj0hMTticmVha31uJiZ0aGlzLl9zdGFydGVyLnB1c2godCl9KSl9KSl9cmVzZXQoKXt0aGlzLl92YWx1ZXM9dGhpcy5ncmFwaC5nZXRWYWx1ZXMoKS5tYXAoKGU9PmUudGVuc29yKSl9YXN5bmMgZXhlY3V0ZShlLHQpe3JldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KFwic2Vzc2lvblwiLFwiRXhlY3V0aW9uUGxhbi5leGVjdXRlXCIsKGFzeW5jKCk9Pnt0aGlzLnJlc2V0KCk7Y29uc3Qgbj1lLmNyZWF0ZUluZmVyZW5jZUhhbmRsZXIoKSxvPXRoaXMuZ3JhcGguZ2V0SW5wdXRJbmRpY2VzKCk7aWYodC5sZW5ndGghPT1vLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYG51bWJlciBvZiBpbnB1dCB0ZW5zb3JzIGRvbid0IG1hdGNoIHRoZSBudW1iZXIgb2YgaW5wdXRzIHRvIHRoZSBtb2RlbDogYWN0dWFsOiAke3QubGVuZ3RofSBleHBlY3RlZDogJHtvLmxlbmd0aH1gKTt0LmZvckVhY2goKChlLHQpPT57Y29uc3Qgbj1vW3RdO3RoaXMuX3ZhbHVlc1tuXT1lfSkpO2NvbnN0IGk9dGhpcy5fc3RhcnRlci5zbGljZSgwKSxhPXRoaXMuZ3JhcGguZ2V0VmFsdWVzKCkscz10aGlzLmdyYXBoLmdldE5vZGVzKCk7bGV0IHU9MDtmb3IoO3U8aS5sZW5ndGg7KXtjb25zdCBlPWlbdSsrXSx0PXRoaXMuX29wc1tlXSxvPXQubm9kZS5pbnB1dHMubWFwKChlPT50aGlzLl92YWx1ZXNbZV0pKTtpZigtMSE9PW8uaW5kZXhPZih2b2lkIDApKXRocm93IG5ldyBFcnJvcihgdW5yZXNvbHZlZCBpbnB1dCBkZXRlY3RlZDogb3A6ICR7dC5ub2RlfWApO2NvbnN0IGw9bztyLkxvZ2dlci52ZXJib3NlKFwiRXhlY1BsYW5cIixgUnVuaW5nIG9wOiR7dC5ub2RlLm5hbWV9ICgke2wubWFwKCgoZSxuKT0+YCcke3Qubm9kZS5pbnB1dHNbbl19JzogJHtlLnR5cGV9WyR7ZS5kaW1zLmpvaW4oXCIsXCIpfV1gKSkuam9pbihcIiwgXCIpfSlgKTtjb25zdCBjPWF3YWl0IHRoaXMucHJvZmlsZXIuZXZlbnQoXCJub2RlXCIsdC5ub2RlLm5hbWUsKGFzeW5jKCk9PnQub3AuaW1wbChuLGwsdC5vcC5jb250ZXh0KSkpO2lmKGMubGVuZ3RoIT09dC5ub2RlLm91dHB1dHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRoZSBzaXplIG9mIG91dHB1dCBkb2VzIG5vdCBtYXRjaCBtb2RlbCBkZWZpbml0aW9uLlwiKTtjLmZvckVhY2goKChlLG4pPT57Y29uc3Qgcj10Lm5vZGUub3V0cHV0c1tuXTtpZih0aGlzLl92YWx1ZXNbcl0pdGhyb3cgbmV3IEVycm9yKGBvdXRwdXQgWyR7cn1dIGFscmVhZHkgaGFzIHZhbHVlOiBvcDoke3Qubm9kZS5uYW1lfWApO3RoaXMuX3ZhbHVlc1tyXT1lfSkpO2NvbnN0IHA9bmV3IFNldDtjLmZvckVhY2goKChlLG4pPT57Y29uc3Qgcj10Lm5vZGUub3V0cHV0c1tuXTtmb3IoY29uc3QgZSBvZiBhW3JdLnRvKXtjb25zdCB0PXNbZV07bGV0IG49ITA7Zm9yKGNvbnN0IGUgb2YgdC5pbnB1dHMpaWYoIXRoaXMuX3ZhbHVlc1tlXSl7bj0hMTticmVha31uJiZwLmFkZChlKX19KSksaS5wdXNoKC4uLnApfWNvbnN0IGw9W107Zm9yKGxldCBlPTA7ZTx0aGlzLmdyYXBoLmdldE91dHB1dEluZGljZXMoKS5sZW5ndGg7ZSsrKXtjb25zdCB0PXRoaXMuZ3JhcGguZ2V0T3V0cHV0SW5kaWNlcygpW2VdLG49dGhpcy5fdmFsdWVzW3RdO2lmKHZvaWQgMD09PW4pdGhyb3cgbmV3IEVycm9yKGByZXF1aXJlZCBvdXRwdXQgWyR7dH1dIGRvZXMgbm90IGhhdmUgdmFsdWVgKTswPT09dD9hd2FpdCBuLmdldERhdGEoKTpuLmRhdGEsbC5wdXNoKG4pfXJldHVybiByLkxvZ2dlci52ZXJib3NlKFwiRXhlY1BsYW5cIixcImRpc3Bvc2luZyBvZiBpbmZlcmVuY2VIYW5kbGVyXCIpLG4uZGlzcG9zZSgpLGx9KSl9fX0sNDY2MjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5HcmFwaD12b2lkIDA7Y29uc3Qgcj1uKDE0NDYpLG89big2ODc0KSxpPW4oMTI4NyksYT1uKDkyNDApLHM9big3MjczKTt2YXIgdT1pLm9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnM7dC5HcmFwaD17ZnJvbTooZSx0KT0+bmV3IHAoZSx0KX07Y2xhc3MgbHtjb25zdHJ1Y3RvcihlKXt0aGlzLl9mcm9tPXZvaWQgMCx0aGlzLl90bz1bXSx0aGlzLnRlbnNvcj12b2lkIDAsdGhpcy50eXBlPXZvaWQgMCxlJiYodGhpcy50eXBlPXMuUHJvdG9VdGlsLnRlbnNvclZhbHVlVHlwZUZyb21Qcm90byhlLnR5cGUudGVuc29yVHlwZSkpfWdldCBmcm9tKCl7cmV0dXJuIHRoaXMuX2Zyb219Z2V0IHRvKCl7cmV0dXJuIHRoaXMuX3RvfX1jbGFzcyBje2NvbnN0cnVjdG9yKGUsdCl7ZSBpbnN0YW5jZW9mIHIub25ueC5Ob2RlUHJvdG8/KHRoaXMubmFtZT1lLm5hbWUsdGhpcy5vcFR5cGU9ZS5vcFR5cGUsdGhpcy5hdHRyaWJ1dGVzPW5ldyBvLkF0dHJpYnV0ZShlLmF0dHJpYnV0ZSkpOmUgaW5zdGFuY2VvZiB1Lk5vZGUmJih0aGlzLm5hbWU9bnVsbCE9dD90OmUubmFtZSgpLHRoaXMub3BUeXBlPWUub3BUeXBlKCksdGhpcy5hdHRyaWJ1dGVzPW5ldyBvLkF0dHJpYnV0ZShzLlByb3RvVXRpbC50ZW5zb3JBdHRyaWJ1dGVzRnJvbU9SVEZvcm1hdChlKSkpLHRoaXMuaW5wdXRzPVtdLHRoaXMub3V0cHV0cz1bXSx0aGlzLmV4ZWN1dGVOb2RlPSEwfX1jbGFzcyBwe2NvbnN0cnVjdG9yKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcImdyYXBoIGlzIGVtcHR5XCIpO3RoaXMuYnVpbGRHcmFwaChlKSx0aGlzLnRyYW5zZm9ybUdyYXBoKHQpLHRoaXMuY2hlY2tJc0FjeWNsaWMoKX1nZXRJbnB1dEluZGljZXMoKXtyZXR1cm4gdGhpcy5fYWxsSW5wdXRJbmRpY2VzfWdldElucHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5fYWxsSW5wdXROYW1lc31nZXRPdXRwdXRJbmRpY2VzKCl7cmV0dXJuIHRoaXMuX2FsbE91dHB1dEluZGljZXN9Z2V0T3V0cHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5fYWxsT3V0cHV0TmFtZXN9Z2V0VmFsdWVzKCl7cmV0dXJuIHRoaXMuX2FsbERhdGF9Z2V0Tm9kZXMoKXtyZXR1cm4gdGhpcy5fbm9kZXN9YnVpbGRHcmFwaChlKXtpZihlIGluc3RhbmNlb2Ygci5vbm54LkdyYXBoUHJvdG8pdGhpcy5idWlsZEdyYXBoRnJvbU9ubnhGb3JtYXQoZSk7ZWxzZXtpZighKGUgaW5zdGFuY2VvZiB1LkdyYXBoKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiR3JhcGggdHlwZSBpcyBub3Qgc3VwcG9ydGVkLlwiKTt0aGlzLmJ1aWxkR3JhcGhGcm9tT3J0Rm9ybWF0KGUpfX1idWlsZEdyYXBoRnJvbU9ubnhGb3JtYXQoZSl7Y29uc3QgdD1uZXcgTWFwO3RoaXMuX2FsbERhdGE9W10sdGhpcy5fYWxsSW5wdXRJbmRpY2VzPVtdLHRoaXMuX2FsbElucHV0TmFtZXM9W10sdGhpcy5fYWxsT3V0cHV0SW5kaWNlcz1bXSx0aGlzLl9hbGxPdXRwdXROYW1lcz1bXSx0aGlzLl9ub2Rlcz1bXTtjb25zdCBuPW5ldyBNYXA7aWYoIWUuaW5wdXQpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBpbmZvcm1hdGlvbiBpbiBncmFwaDogaW5wdXRcIik7Y29uc3Qgcj1bXTtmb3IoY29uc3QgbiBvZiBlLmlucHV0KXtpZih0LmhhcyhuLm5hbWUpKXRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBpbnB1dCBuYW1lOiAke24ubmFtZX1gKTtjb25zdCBlPXRoaXMuX2FsbERhdGEucHVzaChuZXcgbChuKSktMTt0LnNldChuLm5hbWUsZSksci5wdXNoKG4ubmFtZSl9aWYoIWUuaW5pdGlhbGl6ZXIpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBpbmZvcm1hdGlvbiBpbiBncmFwaDogaW5pdGlhbGl6ZXJcIik7Zm9yKGNvbnN0IG4gb2YgZS5pbml0aWFsaXplcil7bGV0IGU9dC5nZXQobi5uYW1lKTtpZih2b2lkIDA9PT1lKXtjb25zdCByPW5ldyBsO3IudHlwZT17c2hhcGU6e2RpbXM6cy5Qcm90b1V0aWwudGVuc29yRGltc0Zyb21Qcm90byhuLmRpbXMpfSx0ZW5zb3JUeXBlOnMuUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKG4uZGF0YVR5cGUpfSxlPXRoaXMuX2FsbERhdGEucHVzaChyKS0xLHQuc2V0KG4ubmFtZSxlKX10aGlzLl9hbGxEYXRhW2VdLl9mcm9tPS0xLHRoaXMuX2FsbERhdGFbZV0udGVuc29yPWEuVGVuc29yLmZyb21Qcm90byhuKX1mb3IobGV0IGU9MDtlPHRoaXMuX2FsbERhdGEubGVuZ3RoO2UrKyl0aGlzLl9hbGxEYXRhW2VdLnRlbnNvcnx8KHRoaXMuX2FsbElucHV0SW5kaWNlcy5wdXNoKGUpLHRoaXMuX2FsbElucHV0TmFtZXMucHVzaChyW2VdKSk7aWYoIWUub3V0cHV0KXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG91dHB1dFwiKTtmb3IoY29uc3QgbiBvZiBlLm91dHB1dCl7aWYodC5oYXMobi5uYW1lKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgb3V0cHV0IG5hbWU6ICR7bi5uYW1lfWApO2NvbnN0IGU9dGhpcy5fYWxsRGF0YS5wdXNoKG5ldyBsKG4pKS0xO3Quc2V0KG4ubmFtZSxlKSx0aGlzLl9hbGxPdXRwdXRJbmRpY2VzLnB1c2goZSksdGhpcy5fYWxsT3V0cHV0TmFtZXMucHVzaChuLm5hbWUpfWlmKCFlLm5vZGUpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBpbmZvcm1hdGlvbiBpbiBncmFwaDogbm9kZVwiKTtmb3IoY29uc3QgdCBvZiBlLm5vZGUpe2lmKCF0Lm5hbWUpZm9yKGxldCBlPTA7O2UrKyl7Y29uc3Qgcj1gdW5uYW1lZF8ke3Qub3BUeXBlfV8ke2V9YDtpZighbi5oYXMocikpe3QubmFtZT1yO2JyZWFrfX1pZihuLmhhcyh0Lm5hbWUpKXRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBub2RlIG5hbWU6ICR7dC5uYW1lfWApO2NvbnN0IGU9dGhpcy5fbm9kZXMucHVzaChuZXcgYyh0KSktMTtuLnNldCh0Lm5hbWUsZSl9Zm9yKGxldCBuPTA7bjx0aGlzLl9ub2Rlcy5sZW5ndGg7bisrKXtjb25zdCByPXRoaXMuX25vZGVzW25dLG89ZS5ub2RlW25dO2lmKCFvLm91dHB1dCl0aHJvdyBuZXcgRXJyb3IoYG1pc3Npbmcgb3V0cHV0IGZvciBub2RlOiAke28ubmFtZX1gKTtmb3IoY29uc3QgZSBvZiBvLm91dHB1dCl7bGV0IGk9dC5nZXQoZSk7aWYodm9pZCAwPT09aSYmKGk9dGhpcy5fYWxsRGF0YS5wdXNoKG5ldyBsKS0xLHQuc2V0KGUsaSkpLHIub3V0cHV0cy5wdXNoKGkpLHZvaWQgMCE9PXRoaXMuX2FsbERhdGFbaV0uX2Zyb20pdGhyb3cgbmV3IEVycm9yKGBtdWx0aXBsZSBub2RlcyBvdXRwdXQgdG8gb25lIGRhdGEgdmFsdWU6ICR7aX1gKTtpZih0aGlzLl9hbGxEYXRhW2ldLl9mcm9tPW4sXCJDb25zdGFudFwiPT09by5vcFR5cGUpe2lmKCFvLmF0dHJpYnV0ZXx8MSE9PW8uYXR0cmlidXRlLmxlbmd0aHx8IW8uYXR0cmlidXRlWzBdLnQpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBhdHRyaWJ1dGVzIG9yIG1pc3NpbmcgdGVuc29yIHZhbHVlIGluIGF0dHJpYnV0ZXMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3JcIik7aWYoIW8ub3V0cHV0fHwxIT09by5vdXRwdXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgb3V0cHV0IG9yIGluY29ycmVjdCBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvclwiKTtyLm91dHB1dHMucG9wKCksci5leGVjdXRlTm9kZT0hMSx0aGlzLl9hbGxEYXRhW2ldLl9mcm9tPS0xLHRoaXMuX2FsbERhdGFbaV0udGVuc29yPWEuVGVuc29yLmZyb21Qcm90byhvLmF0dHJpYnV0ZVswXS50KX19fWZvcihsZXQgbj0wO248dGhpcy5fbm9kZXMubGVuZ3RoO24rKyl7Y29uc3Qgcj10aGlzLl9ub2Rlc1tuXSxvPWUubm9kZVtuXTtpZighby5pbnB1dCl0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgaW5wdXQgZm9yIG5vZGU6ICR7by5uYW1lfWApO2Zvcihjb25zdCBlIG9mIG8uaW5wdXQpe2NvbnN0IGk9dC5nZXQoZSk7aWYodm9pZCAwPT09aSl7aWYoXCJcIj09PWUmJjM9PT1vLmlucHV0Lmxlbmd0aCYmXCJSZXNpemVcIj09PW8ub3BUeXBlKWNvbnRpbnVlO3Rocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIGlucHV0ICcke2V9JyBmb3Igbm9kZTogJHtvLm5hbWV9YCl9ci5pbnB1dHMucHVzaChpKSx0aGlzLl9hbGxEYXRhW2ldLl90by5wdXNoKG4pfX1yZXR1cm4hMH1idWlsZEdyYXBoRnJvbU9ydEZvcm1hdChlKXt2YXIgdCxuLHI7Y29uc3Qgbz1uZXcgTWFwO3RoaXMuX2FsbERhdGE9W10sdGhpcy5fYWxsSW5wdXRJbmRpY2VzPVtdLHRoaXMuX2FsbElucHV0TmFtZXM9W10sdGhpcy5fYWxsT3V0cHV0SW5kaWNlcz1bXSx0aGlzLl9hbGxPdXRwdXROYW1lcz1bXSx0aGlzLl9ub2Rlcz1bXTtjb25zdCBpPW5ldyBNYXAscD1bXTtmb3IobGV0IGk9MDtpPGUuaW5wdXRzTGVuZ3RoKCk7aSsrKXtjb25zdCBhPWUuaW5wdXRzKGkpO2lmKG8uaGFzKGEpKXRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBpbnB1dCBuYW1lOiAke2F9YCk7Zm9yKGxldCBpPTA7aTxlLm5vZGVBcmdzTGVuZ3RoKCk7aSsrKWlmKChudWxsPT09KHQ9ZS5ub2RlQXJncyhpKSl8fHZvaWQgMD09PXQ/dm9pZCAwOnQubmFtZSgpKT09PWEpe2NvbnN0IHQ9bmV3IGw7aWYoKG51bGw9PT0ocj1udWxsPT09KG49ZS5ub2RlQXJncyhpKSl8fHZvaWQgMD09PW4/dm9pZCAwOm4udHlwZSgpKXx8dm9pZCAwPT09cj92b2lkIDA6ci52YWx1ZVR5cGUoKSkhPT11LlR5cGVJbmZvVmFsdWUudGVuc29yX3R5cGUpdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSB0eXBlIGZvciB0aGUgbm9kZUFyZy5cIik7Y29uc3QgYz1lLm5vZGVBcmdzKGkpLnR5cGUoKS52YWx1ZShuZXcgdS5UZW5zb3JUeXBlQW5kU2hhcGUpLGQ9cy5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8oYy5lbGVtVHlwZSgpKSxmPWMuc2hhcGUoKSxoPVtdO2ZvcihsZXQgZT0wO2U8Zi5kaW1MZW5ndGgoKTtlKyspaC5wdXNoKHMuTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKGYuZGltKGUpLnZhbHVlKCkuZGltVmFsdWUoKSkpO3QudHlwZT17c2hhcGU6e2RpbXM6aH0sdGVuc29yVHlwZTpkfTtjb25zdCBnPXRoaXMuX2FsbERhdGEucHVzaCh0KS0xO28uc2V0KGEsZykscC5wdXNoKGEpfX1mb3IobGV0IHQ9MDt0PGUuaW5pdGlhbGl6ZXJzTGVuZ3RoKCk7dCsrKXtjb25zdCBuPWUuaW5pdGlhbGl6ZXJzKHQpO2xldCByPW8uZ2V0KG4ubmFtZSgpKTtpZih2b2lkIDA9PT1yKXtjb25zdCBlPW5ldyBsLHQ9cy5Qcm90b1V0aWwudGVuc29yRGltc0Zyb21PUlRGb3JtYXQobiksaT1zLlByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhuLmRhdGFUeXBlKCkpO2UudHlwZT17c2hhcGU6e2RpbXM6dH0sdGVuc29yVHlwZTppfSxyPXRoaXMuX2FsbERhdGEucHVzaChlKS0xLG8uc2V0KG4ubmFtZSgpLHIpfXRoaXMuX2FsbERhdGFbcl0uX2Zyb209LTEsdGhpcy5fYWxsRGF0YVtyXS50ZW5zb3I9YS5UZW5zb3IuZnJvbU9ydFRlbnNvcihuKX1mb3IobGV0IGU9MDtlPHRoaXMuX2FsbERhdGEubGVuZ3RoO2UrKyl0aGlzLl9hbGxEYXRhW2VdLnRlbnNvcnx8KHRoaXMuX2FsbElucHV0SW5kaWNlcy5wdXNoKGUpLHRoaXMuX2FsbElucHV0TmFtZXMucHVzaChwW2VdKSk7Zm9yKGxldCB0PTA7dDxlLm91dHB1dHNMZW5ndGgoKTt0Kyspe2NvbnN0IG49ZS5vdXRwdXRzKHQpO2lmKG8uaGFzKG4pKXRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBvdXRwdXQgbmFtZTogJHtufWApO2NvbnN0IHI9dGhpcy5fYWxsRGF0YS5wdXNoKG5ldyBsKS0xO28uc2V0KG4sciksdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5wdXNoKHIpLHRoaXMuX2FsbE91dHB1dE5hbWVzLnB1c2gobil9aWYoIWUubm9kZXMpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBpbmZvcm1hdGlvbiBpbiBncmFwaDogbm9kZVwiKTtmb3IobGV0IHQ9MDt0PGUubm9kZXNMZW5ndGgoKTt0Kyspe2NvbnN0IG49ZS5ub2Rlcyh0KTtsZXQgcj1uLm5hbWUoKTtpZighcilmb3IobGV0IGU9MDtyPWB1bm5hbWVkXyR7bi5vcFR5cGUoKX1fJHtlfWAsaS5oYXMocik7ZSsrKTtpZihpLmhhcyhyKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgbm9kZSBuYW1lOiAke3J9YCk7Y29uc3Qgbz10aGlzLl9ub2Rlcy5wdXNoKG5ldyBjKG4scikpLTE7aS5zZXQocixvKX1mb3IobGV0IHQ9MDt0PHRoaXMuX25vZGVzLmxlbmd0aDt0Kyspe2NvbnN0IG49dGhpcy5fbm9kZXNbdF0scj1lLm5vZGVzKHQpO2lmKG51bGw9PXIpdGhyb3cgbmV3IEVycm9yKGBObyBub2RlIGV4aXN0cyBhdCBpbmRleCAke3R9YCk7aWYoMD09PShudWxsPT1yP3ZvaWQgMDpyLm91dHB1dHNMZW5ndGgoKSkpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIG91dHB1dCBmb3Igbm9kZTogJHtyLm5hbWV9YCk7Zm9yKGxldCBlPTA7ZTwobnVsbD09cj92b2lkIDA6ci5vdXRwdXRzTGVuZ3RoKCkpO2UrKyl7Y29uc3QgaT1udWxsPT1yP3ZvaWQgMDpyLm91dHB1dHMoZSk7bGV0IHM9by5nZXQoaSk7aWYodm9pZCAwPT09cyYmKHM9dGhpcy5fYWxsRGF0YS5wdXNoKG5ldyBsKS0xLG8uc2V0KGkscykpLG4ub3V0cHV0cy5wdXNoKHMpLHZvaWQgMCE9PXRoaXMuX2FsbERhdGFbc10uX2Zyb20pdGhyb3cgbmV3IEVycm9yKGBtdWx0aXBsZSBub2RlcyBvdXRwdXQgdG8gb25lIGRhdGEgdmFsdWU6ICR7c31gKTtpZih0aGlzLl9hbGxEYXRhW3NdLl9mcm9tPXQsXCJDb25zdGFudFwiPT09ci5vcFR5cGUoKSl7aWYoMSE9PXIuYXR0cmlidXRlc0xlbmd0aCgpfHwhci5hdHRyaWJ1dGVzKDApLnQoKSl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGF0dHJpYnV0ZXMgb3IgbWlzc2luZyB0ZW5zb3IgdmFsdWUgaW4gYXR0cmlidXRlcyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvclwiKTtpZigxIT09ci5vdXRwdXRzTGVuZ3RoKCkpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBvdXRwdXQgb3IgaW5jb3JyZWN0IG51bWJlciBvZiBvdXRwdXRzIGZvciB0aGlzIENvbnN0YW50IG9wZXJhdG9yXCIpO24ub3V0cHV0cy5wb3AoKSxuLmV4ZWN1dGVOb2RlPSExLHRoaXMuX2FsbERhdGFbc10uX2Zyb209LTEsdGhpcy5fYWxsRGF0YVtzXS50ZW5zb3I9YS5UZW5zb3IuZnJvbU9ydFRlbnNvcihyLmF0dHJpYnV0ZXMoMCkudCgpKX19fWZvcihsZXQgdD0wO3Q8dGhpcy5fbm9kZXMubGVuZ3RoO3QrKyl7Y29uc3Qgbj10aGlzLl9ub2Rlc1t0XSxyPWUubm9kZXModCk7aWYoMD09PXIuaW5wdXRzTGVuZ3RoKCkpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGlucHV0IGZvciBub2RlOiAke3IubmFtZX1gKTtmb3IobGV0IGU9MDtlPHIuaW5wdXRzTGVuZ3RoKCk7ZSsrKXtjb25zdCBpPXIuaW5wdXRzKGUpLGE9by5nZXQoaSk7aWYodm9pZCAwPT09YSl0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBpbnB1dCAnJHtpfScgZm9yIG5vZGU6ICR7ci5uYW1lKCl9YCk7bi5pbnB1dHMucHVzaChhKSx0aGlzLl9hbGxEYXRhW2FdLl90by5wdXNoKHQpfX19Y2hlY2tJc0FjeWNsaWMoKXtjb25zdCBlPW5ldyBTZXQ7dGhpcy5fYWxsSW5wdXRJbmRpY2VzLmZvckVhY2goKHQ9Pnt0aGlzLl9hbGxEYXRhW3RdLl90by5mb3JFYWNoKCh0PT57ZS5hZGQodCl9KSl9KSk7Y29uc3QgdD1BcnJheS5mcm9tKGUpLG49bmV3IEFycmF5KHRoaXMuX25vZGVzLmxlbmd0aCkuZmlsbChcIndoaXRlXCIpO2Zvcig7dC5sZW5ndGg+MDspe2NvbnN0IGU9dC5wb3AoKTtcImdyYXlcIj09PW5bZV0/bltlXT1cImJsYWNrXCI6KHQucHVzaChlKSxuW2VdPVwiZ3JheVwiLHRoaXMuX25vZGVzW2VdLm91dHB1dHMuZm9yRWFjaCgocj0+e2NvbnN0IG89dGhpcy5fYWxsRGF0YVtyXTtpZih2b2lkIDAhPT1vLnRlbnNvcil0aHJvdyBuZXcgRXJyb3IoXCJub2RlIG91dHB1dHMgc2hvdWxkIG5vdCBiZSBpbml0aWFsaXplZFwiKTtpZihvLl9mcm9tIT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJmcm9tIHByb3BlcnR5IG9mIHRoZSBWYWx1ZSBvYmplY3QgZG9lc24ndCBtYXRjaCBpbmRleCBvZiBOb2RlIGJlaW5nIHByb2Nlc3NlZFwiKTtvLl90by5mb3JFYWNoKChlPT57aWYoXCJncmF5XCI9PT1uW2VdKXRocm93IG5ldyBFcnJvcihcIm1vZGVsIGdyYXBoIGlzIGN5Y2xpY1wiKTtcIndoaXRlXCI9PT1uW2VdJiZ0LnB1c2goZSl9KSl9KSkpfX10cmFuc2Zvcm1HcmFwaChlKXt0aGlzLnJlbW92ZUFsbElkZW50aXR5Tm9kZXMoKSx0aGlzLnJlbW92ZUFsbERyb3BvdXROb2RlcygpLHRoaXMuZnVzZUNvbnZBY3RpdmF0aW9uTm9kZXMoKSxlJiZlLnRyYW5zZm9ybUdyYXBoKHRoaXMpLHRoaXMuZmluYWxpemVHcmFwaCgpfWZpbmFsaXplR3JhcGgoKXtsZXQgZT0wO2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX25vZGVzLmxlbmd0aCwwKTtsZXQgbj0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fbm9kZXMubGVuZ3RoO2UrKyl0W2VdPW4sdGhpcy5fbm9kZXNbZV0uZXhlY3V0ZU5vZGU/KG4hPT1lJiYodGhpcy5fbm9kZXNbbl09dGhpcy5fbm9kZXNbZV0pLG4rKyk6dGhpcy5fbm9kZXNbZV0ub3V0cHV0cy5mb3JFYWNoKChlPT57dGhpcy5fYWxsRGF0YVtlXS5fZnJvbT0tMn0pKTt0aGlzLl9ub2Rlcy5zcGxpY2Uobix0aGlzLl9ub2Rlcy5sZW5ndGgtbik7Zm9yKGxldCBlPTA7ZTx0aGlzLl9hbGxEYXRhLmxlbmd0aDtlKyspe2NvbnN0IG49dGhpcy5fYWxsRGF0YVtlXTt2b2lkIDAhPT1uLl9mcm9tJiYtMSE9PW4uX2Zyb20mJi0yIT09bi5fZnJvbSYmKG4uX2Zyb209dFtuLl9mcm9tXSk7Zm9yKGxldCBlPTA7ZTxuLl90by5sZW5ndGg7ZSsrKXtpZighKG4uX3RvW2VdPj0wKSl0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gdXBkYXRlIGEgcmVtb3ZlZCBub2RlXCIpO24uX3RvW2VdPXRbbi5fdG9bZV1dfX1lPTA7Zm9yKGxldCB0PTA7dDx0aGlzLl9hbGxEYXRhLmxlbmd0aDt0KyspaWYoLTIhPT10aGlzLl9hbGxEYXRhW3RdLmZyb218fC0xIT09dGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5pbmRleE9mKHQrZSkpe2lmKGU+MCl7bGV0IG49LTE7dm9pZCAwIT09dGhpcy5fYWxsRGF0YVt0XS5mcm9tJiYtMSE9PXRoaXMuX2FsbERhdGFbdF0uZnJvbT8obj10aGlzLl9ub2Rlc1t0aGlzLl9hbGxEYXRhW3RdLmZyb21dLm91dHB1dHMuaW5kZXhPZih0K2UpLC0xIT09biYmKHRoaXMuX25vZGVzW3RoaXMuX2FsbERhdGFbdF0uZnJvbV0ub3V0cHV0c1tuXT10KSk6KG49dGhpcy5fYWxsSW5wdXRJbmRpY2VzLmluZGV4T2YodCtlKSwtMSE9PW4mJih0aGlzLl9hbGxJbnB1dEluZGljZXNbbl09dCkpLHRoaXMuX2FsbERhdGFbdF0udG8uZm9yRWFjaCgocj0+e249dGhpcy5fbm9kZXNbcl0uaW5wdXRzLmluZGV4T2YodCtlKSwtMSE9PW4mJih0aGlzLl9ub2Rlc1tyXS5pbnB1dHNbbl09dCl9KSksMD09PXRoaXMuX2FsbERhdGFbdF0udG8ubGVuZ3RoJiYobj10aGlzLl9hbGxPdXRwdXRJbmRpY2VzLmluZGV4T2YodCtlKSwtMSE9PW4mJih0aGlzLl9hbGxPdXRwdXRJbmRpY2VzW25dPXQpKX19ZWxzZSBlKyssdGhpcy5fYWxsRGF0YS5zcGxpY2UodCwxKSx0LS19ZGVsZXRlTm9kZShlKXtjb25zdCB0PXRoaXMuX25vZGVzW2VdO2lmKHQub3V0cHV0cy5sZW5ndGg+MSlmb3IobGV0IGU9MTtlPHQub3V0cHV0cy5sZW5ndGg7ZSsrKWlmKHRoaXMuX2FsbERhdGFbdC5vdXRwdXRzW2VdXS50by5sZW5ndGg+MCl0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIGRlbGV0aW9uIHdpdGggbW9yZSB0aGFuIG9uZSBvdXRwdXQgY29ubmVjdGVkIHRvIG90aGVyIG5vZGVzIGlzIG5vdCBzdXBwb3J0ZWQuIFwiKTt0LmV4ZWN1dGVOb2RlPSExO2NvbnN0IG49dC5pbnB1dHNbMF0scj10Lm91dHB1dHNbMF0sbz10aGlzLl9hbGxEYXRhW3JdLnRvO2ZvcihsZXQgbj0wO248dC5pbnB1dHMubGVuZ3RoO24rKyl7Y29uc3Qgcj10aGlzLl9hbGxEYXRhW3QuaW5wdXRzW25dXS50by5pbmRleE9mKGUpO2lmKC0xPT09cil0aHJvdyBuZXcgRXJyb3IoXCJUaGUgVmFsdWUgb2JqZWN0IGRvZXNuJ3QgaGF2ZSB0aGUgY3VycmVudCBOb2RlIGluIGl0J3MgJ3RvJyBwcm9wZXJ0eSBcIik7dGhpcy5fYWxsRGF0YVt0LmlucHV0c1tuXV0udG8uc3BsaWNlKHIsMSl9dGhpcy5fYWxsRGF0YVtyXS5fdG89W107Y29uc3QgaT10aGlzLl9hbGxPdXRwdXRJbmRpY2VzLmluZGV4T2Yocik7aWYoLTEhPT1pJiYodGhpcy5fYWxsT3V0cHV0SW5kaWNlc1tpXT1uKSxvJiZvLmxlbmd0aD4wKWZvcihjb25zdCBlIG9mIG8pe2NvbnN0IHQ9dGhpcy5fbm9kZXNbZV0uaW5wdXRzLmluZGV4T2Yocik7aWYoLTE9PT10KXRocm93IG5ldyBFcnJvcihcIlRoZSBOb2RlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIG91dHB1dCBWYWx1ZSBpbiBpdCdzICdpbnB1dHMnIHByb3BlcnR5IFwiKTt0aGlzLl9ub2Rlc1tlXS5pbnB1dHNbdF09bix0aGlzLl9hbGxEYXRhW25dLnRvLnB1c2goZSl9fXJlbW92ZUFsbERyb3BvdXROb2Rlcygpe2xldCBlPTA7Zm9yKGNvbnN0IHQgb2YgdGhpcy5fbm9kZXMpe2lmKFwiRHJvcG91dFwiPT09dC5vcFR5cGUpe2lmKDEhPT10LmlucHV0cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRHJvcG91dCBub2RlcyBzaG91bGQgb25seSBjb250YWluIG9uZSBpbnB1dC4gXCIpO2lmKDEhPT10Lm91dHB1dHMubGVuZ3RoJiYyIT09dC5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEcm9wb3V0IG5vZGVzIHNob3VsZCBjb250YWluIGVpdGhlciAxIG9yIDIgb3V0cHV0KHMpXCIpO2lmKDI9PT10Lm91dHB1dHMubGVuZ3RoJiYwIT09dGhpcy5fYWxsRGF0YVt0Lm91dHB1dHNbMV1dLl90by5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRHJvcG91dCBub2RlcydzIHNlY29uZCBvdXRwdXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2VkIGJ5IG90aGVyIG5vZGVzXCIpO3RoaXMuZGVsZXRlTm9kZShlKX1lKyt9fXJlbW92ZUFsbElkZW50aXR5Tm9kZXMoKXtsZXQgZT0wO2Zvcihjb25zdCB0IG9mIHRoaXMuX25vZGVzKVwiSWRlbnRpdHlcIj09PXQub3BUeXBlJiZ0aGlzLmRlbGV0ZU5vZGUoZSksZSsrfWlzQWN0aXZhdGlvbihlKXtzd2l0Y2goZS5vcFR5cGUpe2Nhc2VcIlJlbHVcIjpjYXNlXCJTaWdtb2lkXCI6Y2FzZVwiQ2xpcFwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCl7Zm9yKGNvbnN0IGUgb2YgdGhpcy5fbm9kZXMpaWYoXCJDb252XCI9PT1lLm9wVHlwZSl7Y29uc3QgdD10aGlzLl9hbGxEYXRhW2Uub3V0cHV0c1swXV0uX3RvO2lmKDE9PT10Lmxlbmd0aCYmdGhpcy5pc0FjdGl2YXRpb24odGhpcy5fbm9kZXNbdFswXV0pKXtjb25zdCBuPXRoaXMuX25vZGVzW3RbMF1dO2lmKFwiQ2xpcFwiPT09bi5vcFR5cGUpaWYoMT09PW4uaW5wdXRzLmxlbmd0aCl0cnl7ZS5hdHRyaWJ1dGVzLnNldChcImFjdGl2YXRpb25fcGFyYW1zXCIsXCJmbG9hdHNcIixbbi5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibWluXCIpLG4uYXR0cmlidXRlcy5nZXRGbG9hdChcIm1heFwiKV0pfWNhdGNoKHQpe2UuYXR0cmlidXRlcy5zZXQoXCJhY3RpdmF0aW9uX3BhcmFtc1wiLFwiZmxvYXRzXCIsW3MuTUlOX0NMSVAscy5NQVhfQ0xJUF0pfWVsc2V7aWYoIShuLmlucHV0cy5sZW5ndGg+PTMmJnZvaWQgMCE9PXRoaXMuX2FsbERhdGFbbi5pbnB1dHNbMV1dLnRlbnNvciYmdm9pZCAwIT09dGhpcy5fYWxsRGF0YVtuLmlucHV0c1syXV0udGVuc29yKSljb250aW51ZTtlLmF0dHJpYnV0ZXMuc2V0KFwiYWN0aXZhdGlvbl9wYXJhbXNcIixcImZsb2F0c1wiLFt0aGlzLl9hbGxEYXRhW24uaW5wdXRzWzFdXS50ZW5zb3IuZmxvYXREYXRhWzBdLHRoaXMuX2FsbERhdGFbbi5pbnB1dHNbMl1dLnRlbnNvci5mbG9hdERhdGFbMF1dKX1lLmF0dHJpYnV0ZXMuc2V0KFwiYWN0aXZhdGlvblwiLFwic3RyaW5nXCIsbi5vcFR5cGUpLHRoaXMuZGVsZXRlTm9kZSh0WzBdKX19fX19LDEzMTU6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lm5vdz10LlByb2ZpbGVyPXQuTG9nZ2VyPXZvaWQgMDtjb25zdCBuPXt2ZXJib3NlOjFlMyxpbmZvOjJlMyx3YXJuaW5nOjRlMyxlcnJvcjo1ZTMsZmF0YWw6NmUzfSxyPXtub25lOm5ldyBjbGFzc3tsb2coZSx0LG4pe319LGNvbnNvbGU6bmV3IGNsYXNze2xvZyhlLHQsbil7Y29uc29sZS5sb2coYCR7dGhpcy5jb2xvcihlKX0gJHtuP1wiXHUwMDFiWzM1bVwiK24rXCJcdTAwMWJbMG0gXCI6XCJcIn0ke3R9YCl9Y29sb3IoZSl7c3dpdGNoKGUpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm5cIlx1MDAxYlszNDs0MG12XHUwMDFiWzBtXCI7Y2FzZVwiaW5mb1wiOnJldHVyblwiXHUwMDFiWzMybWlcdTAwMWJbMG1cIjtjYXNlXCJ3YXJuaW5nXCI6cmV0dXJuXCJcdTAwMWJbMzA7NDNtd1x1MDAxYlswbVwiO2Nhc2VcImVycm9yXCI6cmV0dXJuXCJcdTAwMWJbMzE7NDBtZVx1MDAxYlswbVwiO2Nhc2VcImZhdGFsXCI6cmV0dXJuXCJcdTAwMWJbMTAxbWZcdTAwMWJbMG1cIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgc2V2ZXJpdHk6ICR7ZX1gKX19fX0sbz17cHJvdmlkZXI6XCJjb25zb2xlXCIsbWluaW1hbFNldmVyaXR5Olwid2FybmluZ1wiLGxvZ0RhdGVUaW1lOiEwLGxvZ1NvdXJjZUxvY2F0aW9uOiExfTtsZXQgaT17XCJcIjpvfTtmdW5jdGlvbiBhKGUsdCxuLHIpe2lmKHZvaWQgMD09PXQpcmV0dXJuIG89ZSx7dmVyYm9zZTphLnZlcmJvc2UuYmluZChudWxsLG8pLGluZm86YS5pbmZvLmJpbmQobnVsbCxvKSx3YXJuaW5nOmEud2FybmluZy5iaW5kKG51bGwsbyksZXJyb3I6YS5lcnJvci5iaW5kKG51bGwsbyksZmF0YWw6YS5mYXRhbC5iaW5kKG51bGwsbyl9O2lmKHZvaWQgMD09PW4pcyhlLHQpO2Vsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIG4mJnZvaWQgMD09PXIpcyhlLHQpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIG4mJnZvaWQgMD09PXIpcyhlLG4sMCx0KTtlbHNle2lmKFwic3RyaW5nXCIhPXR5cGVvZiBufHxcIm51bWJlclwiIT10eXBlb2Ygcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW5wdXQgaXMgdmFsaWRcIik7cyhlLG4sMCx0KX12YXIgb31mdW5jdGlvbiBzKGUsdCxvLGEpe2NvbnN0IHM9aVthfHxcIlwiXXx8aVtcIlwiXTtuW2VdPG5bcy5taW5pbWFsU2V2ZXJpdHldfHwocy5sb2dEYXRlVGltZSYmKHQ9YCR7KG5ldyBEYXRlKS50b0lTT1N0cmluZygpfXwke3R9YCkscy5sb2dTb3VyY2VMb2NhdGlvbixyW3MucHJvdmlkZXJdLmxvZyhlLHQsYSkpfSFmdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUpe2k9e30sbihcIlwiLGV8fHt9KX1mdW5jdGlvbiBuKGUsbil7aWYoXCIqXCI9PT1lKXQobik7ZWxzZXtjb25zdCB0PWlbZV18fG87aVtlXT17cHJvdmlkZXI6bi5wcm92aWRlcnx8dC5wcm92aWRlcixtaW5pbWFsU2V2ZXJpdHk6bi5taW5pbWFsU2V2ZXJpdHl8fHQubWluaW1hbFNldmVyaXR5LGxvZ0RhdGVUaW1lOnZvaWQgMD09PW4ubG9nRGF0ZVRpbWU/dC5sb2dEYXRlVGltZTpuLmxvZ0RhdGVUaW1lLGxvZ1NvdXJjZUxvY2F0aW9uOnZvaWQgMD09PW4ubG9nU291cmNlTG9jYXRpb24/dC5sb2dTb3VyY2VMb2NhdGlvbjpuLmxvZ1NvdXJjZUxvY2F0aW9ufX19ZS52ZXJib3NlPWZ1bmN0aW9uKHQsbil7ZShcInZlcmJvc2VcIix0LG4pfSxlLmluZm89ZnVuY3Rpb24odCxuKXtlKFwiaW5mb1wiLHQsbil9LGUud2FybmluZz1mdW5jdGlvbih0LG4pe2UoXCJ3YXJuaW5nXCIsdCxuKX0sZS5lcnJvcj1mdW5jdGlvbih0LG4pe2UoXCJlcnJvclwiLHQsbil9LGUuZmF0YWw9ZnVuY3Rpb24odCxuKXtlKFwiZmF0YWxcIix0LG4pfSxlLnJlc2V0PXQsZS5zZXQ9bixlLnNldFdpdGhFbnY9ZnVuY3Rpb24oZSl7Y29uc3QgdD17fTtlLmxvZ0xldmVsJiYodC5taW5pbWFsU2V2ZXJpdHk9ZS5sb2dMZXZlbCksbihcIlwiLHQpfX0oYXx8KGE9e30pKSx0LkxvZ2dlcj1hO2NsYXNzIHV7Y29uc3RydWN0b3IoZSx0LG4scixvLGkpe3RoaXMuY2F0ZWdvcnk9ZSx0aGlzLm5hbWU9dCx0aGlzLnN0YXJ0VGltZT1uLHRoaXMuZW5kQ2FsbGJhY2s9cix0aGlzLnRpbWVyPW8sdGhpcy5jdHg9aX1hc3luYyBlbmQoKXtyZXR1cm4gdGhpcy5lbmRDYWxsYmFjayh0aGlzKX1hc3luYyBjaGVja1RpbWVyKCl7aWYodm9pZCAwPT09dGhpcy5jdHh8fHZvaWQgMD09PXRoaXMudGltZXIpdGhyb3cgbmV3IEVycm9yKFwiTm8gd2ViZ2wgdGltZXIgZm91bmRcIik7cmV0dXJuIHRoaXMuY3R4LmVuZFRpbWVyKCksdGhpcy5jdHgud2FpdEZvclF1ZXJ5QW5kR2V0VGltZSh0aGlzLnRpbWVyKX19Y2xhc3MgbHtjb25zdHJ1Y3RvcihlLHQsbixyKXt0aGlzLmNhdGVnb3J5PWUsdGhpcy5uYW1lPXQsdGhpcy5zdGFydFRpbWU9bix0aGlzLmVuZFRpbWU9cn19dC5Qcm9maWxlcj1jbGFzc3tzdGF0aWMgY3JlYXRlKGUpe3JldHVybiB2b2lkIDA9PT1lP25ldyB0aGlzOm5ldyB0aGlzKGUubWF4TnVtYmVyRXZlbnRzLGUuZmx1c2hCYXRjaFNpemUsZS5mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHMpfWNvbnN0cnVjdG9yKGUsdCxuKXt0aGlzLl9zdGFydGVkPSExLHRoaXMuX2ZsdXNoUG9pbnRlcj0wLHRoaXMuX3N0YXJ0ZWQ9ITEsdGhpcy5fbWF4TnVtYmVyRXZlbnRzPXZvaWQgMD09PWU/MWU0OmUsdGhpcy5fZmx1c2hCYXRjaFNpemU9dm9pZCAwPT09dD8xMDp0LHRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcz12b2lkIDA9PT1uPzVlMzpufXN0YXJ0KCl7dGhpcy5fc3RhcnRlZD0hMCx0aGlzLl90aW1pbmdFdmVudHM9W10sdGhpcy5fZmx1c2hUaW1lPSgwLHQubm93KSgpLHRoaXMuX2ZsdXNoUG9pbnRlcj0wfXN0b3AoKXtmb3IodGhpcy5fc3RhcnRlZD0hMTt0aGlzLl9mbHVzaFBvaW50ZXI8dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDt0aGlzLl9mbHVzaFBvaW50ZXIrKyl0aGlzLmxvZ09uZUV2ZW50KHRoaXMuX3RpbWluZ0V2ZW50c1t0aGlzLl9mbHVzaFBvaW50ZXJdKX1ldmVudChlLHQsbixyKXtjb25zdCBvPXRoaXMuX3N0YXJ0ZWQ/dGhpcy5iZWdpbihlLHQscik6dm9pZCAwO2xldCBpPSExO2NvbnN0IGE9bigpO2lmKGEmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGEudGhlbilyZXR1cm4gaT0hMCxuZXcgUHJvbWlzZSgoKGUsdCk9PnthLnRoZW4oKGFzeW5jIHQ9PntvJiZhd2FpdCBvLmVuZCgpLGUodCl9KSwoYXN5bmMgZT0+e28mJmF3YWl0IG8uZW5kKCksdChlKX0pKX0pKTtpZighaSYmbyl7Y29uc3QgZT1vLmVuZCgpO2lmKGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUudGhlbilyZXR1cm4gbmV3IFByb21pc2UoKCh0LG4pPT57ZS50aGVuKCgoKT0+e3QoYSl9KSwoZT0+e24oZSl9KSl9KSl9cmV0dXJuIGF9YmVnaW4oZSxuLHIpe2lmKCF0aGlzLl9zdGFydGVkKXRocm93IG5ldyBFcnJvcihcInByb2ZpbGVyIGlzIG5vdCBzdGFydGVkIHlldFwiKTtpZih2b2lkIDA9PT1yKXtjb25zdCByPSgwLHQubm93KSgpO3JldHVybiB0aGlzLmZsdXNoKHIpLG5ldyB1KGUsbixyLChlPT50aGlzLmVuZFN5bmMoZSkpKX17Y29uc3QgdD1yLmJlZ2luVGltZXIoKTtyZXR1cm4gbmV3IHUoZSxuLDAsKGFzeW5jIGU9PnRoaXMuZW5kKGUpKSx0LHIpfX1hc3luYyBlbmQoZSl7Y29uc3QgdD1hd2FpdCBlLmNoZWNrVGltZXIoKTt0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoPHRoaXMuX21heE51bWJlckV2ZW50cyYmKHRoaXMuX3RpbWluZ0V2ZW50cy5wdXNoKG5ldyBsKGUuY2F0ZWdvcnksZS5uYW1lLGUuc3RhcnRUaW1lLHQpKSx0aGlzLmZsdXNoKHQpKX1lbmRTeW5jKGUpe2NvbnN0IG49KDAsdC5ub3cpKCk7dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDx0aGlzLl9tYXhOdW1iZXJFdmVudHMmJih0aGlzLl90aW1pbmdFdmVudHMucHVzaChuZXcgbChlLmNhdGVnb3J5LGUubmFtZSxlLnN0YXJ0VGltZSxuKSksdGhpcy5mbHVzaChuKSl9bG9nT25lRXZlbnQoZSl7dC5Mb2dnZXIudmVyYm9zZShgUHJvZmlsZXIuJHtlLmNhdGVnb3J5fWAsYCR7KGUuZW5kVGltZS1lLnN0YXJ0VGltZSkudG9GaXhlZCgyKX1tcyBvbiBldmVudCAnJHtlLm5hbWV9JyBhdCAke2UuZW5kVGltZS50b0ZpeGVkKDIpfWApfWZsdXNoKGUpe2lmKHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGgtdGhpcy5fZmx1c2hQb2ludGVyPj10aGlzLl9mbHVzaEJhdGNoU2l6ZXx8ZS10aGlzLl9mbHVzaFRpbWU+PXRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyl7Zm9yKGNvbnN0IGU9dGhpcy5fZmx1c2hQb2ludGVyO3RoaXMuX2ZsdXNoUG9pbnRlcjxlK3RoaXMuX2ZsdXNoQmF0Y2hTaXplJiZ0aGlzLl9mbHVzaFBvaW50ZXI8dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDt0aGlzLl9mbHVzaFBvaW50ZXIrKyl0aGlzLmxvZ09uZUV2ZW50KHRoaXMuX3RpbWluZ0V2ZW50c1t0aGlzLl9mbHVzaFBvaW50ZXJdKTt0aGlzLl9mbHVzaFRpbWU9KDAsdC5ub3cpKCl9fWdldCBzdGFydGVkKCl7cmV0dXJuIHRoaXMuX3N0YXJ0ZWR9fSx0Lm5vdz1cInVuZGVmaW5lZFwiIT10eXBlb2YgcGVyZm9ybWFuY2UmJnBlcmZvcm1hbmNlLm5vdz8oKT0+cGVyZm9ybWFuY2Uubm93KCk6RGF0ZS5ub3d9LDE3NDU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTW9kZWw9dm9pZCAwO2NvbnN0IHI9big1Njg2KSxvPW4oMTQ0NiksaT1uKDQ2NjIpLGE9bigxMjg3KSxzPW4oNzI3Myk7dmFyIHU9YS5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO3QuTW9kZWw9Y2xhc3N7Y29uc3RydWN0b3IoKXt9bG9hZChlLHQsbil7aWYoIW4pdHJ5e3JldHVybiB2b2lkIHRoaXMubG9hZEZyb21Pbm54Rm9ybWF0KGUsdCl9Y2F0Y2goZSl7aWYodm9pZCAwIT09bil0aHJvdyBlfXRoaXMubG9hZEZyb21PcnRGb3JtYXQoZSx0KX1sb2FkRnJvbU9ubnhGb3JtYXQoZSx0KXtjb25zdCBuPW8ub25ueC5Nb2RlbFByb3RvLmRlY29kZShlKTtpZihzLkxvbmdVdGlsLmxvbmdUb051bWJlcihuLmlyVmVyc2lvbik8Myl0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IHN1cHBvcnQgT05OWCBtb2RlbCB3aXRoIElSX1ZFUlNJT04+PTNcIik7dGhpcy5fb3BzZXRzPW4ub3BzZXRJbXBvcnQubWFwKChlPT4oe2RvbWFpbjplLmRvbWFpbix2ZXJzaW9uOnMuTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKGUudmVyc2lvbil9KSkpLHRoaXMuX2dyYXBoPWkuR3JhcGguZnJvbShuLmdyYXBoLHQpfWxvYWRGcm9tT3J0Rm9ybWF0KGUsdCl7Y29uc3Qgbj1uZXcgci5mbGF0YnVmZmVycy5CeXRlQnVmZmVyKGUpLG89dS5JbmZlcmVuY2VTZXNzaW9uLmdldFJvb3RBc0luZmVyZW5jZVNlc3Npb24obikubW9kZWwoKTtpZihzLkxvbmdVdGlsLmxvbmdUb051bWJlcihvLmlyVmVyc2lvbigpKTwzKXRocm93IG5ldyBFcnJvcihcIm9ubHkgc3VwcG9ydCBPTk5YIG1vZGVsIHdpdGggSVJfVkVSU0lPTj49M1wiKTt0aGlzLl9vcHNldHM9W107Zm9yKGxldCBlPTA7ZTxvLm9wc2V0SW1wb3J0TGVuZ3RoKCk7ZSsrKXtjb25zdCB0PW8ub3BzZXRJbXBvcnQoZSk7dGhpcy5fb3BzZXRzLnB1c2goe2RvbWFpbjpudWxsPT10P3ZvaWQgMDp0LmRvbWFpbigpLHZlcnNpb246cy5Mb25nVXRpbC5sb25nVG9OdW1iZXIodC52ZXJzaW9uKCkpfSl9dGhpcy5fZ3JhcGg9aS5HcmFwaC5mcm9tKG8uZ3JhcGgoKSx0KX1nZXQgZ3JhcGgoKXtyZXR1cm4gdGhpcy5fZ3JhcGh9Z2V0IG9wc2V0cygpe3JldHVybiB0aGlzLl9vcHNldHN9fX0sNjE0NTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuRkxPQVRfVFlQRVM9dC5JTlRfVFlQRVM9dC5OVU1CRVJfVFlQRVM9dm9pZCAwLHQuTlVNQkVSX1RZUEVTPVtcImZsb2F0MzJcIixcImZsb2F0NjRcIixcImludDMyXCIsXCJpbnQxNlwiLFwiaW50OFwiLFwidWludDE2XCIsXCJ1aW50MzJcIixcInVpbnQ4XCJdLHQuSU5UX1RZUEVTPVtcImludDMyXCIsXCJpbnQxNlwiLFwiaW50OFwiLFwidWludDE2XCIsXCJ1aW50MzJcIixcInVpbnQ4XCJdLHQuRkxPQVRfVFlQRVM9W1wiZmxvYXQzMlwiLFwiZmxvYXQ2NFwiXX0sNTg4MTooZSx0KT0+e1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSx0KXtpZih0LmVuZHNXaXRoKFwiK1wiKSl7Y29uc3Qgbj1OdW1iZXIucGFyc2VJbnQodC5zdWJzdHJpbmcoMCx0Lmxlbmd0aC0xKSwxMCk7cmV0dXJuIWlzTmFOKG4pJiZuPD1lfWlmKDI9PT10LnNwbGl0KFwiLVwiKS5sZW5ndGgpe2NvbnN0IG49dC5zcGxpdChcIi1cIikscj1OdW1iZXIucGFyc2VJbnQoblswXSwxMCksbz1OdW1iZXIucGFyc2VJbnQoblsxXSwxMCk7cmV0dXJuIWlzTmFOKHIpJiYhaXNOYU4obykmJnI8PWUmJmU8PW99cmV0dXJuIE51bWJlci5wYXJzZUludCh0LDEwKT09PWV9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5yZXNvbHZlT3BlcmF0b3I9dm9pZCAwLHQucmVzb2x2ZU9wZXJhdG9yPWZ1bmN0aW9uKGUsdCxyKXtmb3IoY29uc3QgbyBvZiByKXtjb25zdCByPW9bMF0saT1vWzFdLGE9b1syXSxzPW9bM10sdT1vWzRdO2lmKGUub3BUeXBlPT09cilmb3IoY29uc3QgZSBvZiB0KWlmKChlLmRvbWFpbj09PWl8fFwiYWkub25ueFwiPT09ZS5kb21haW4mJlwiXCI9PT1pKSYmbihlLnZlcnNpb24sYSkpcmV0dXJue29wSW1wbDpzLG9wSW5pdDp1fX10aHJvdyBuZXcgVHlwZUVycm9yKGBjYW5ub3QgcmVzb2x2ZSBvcGVyYXRvciAnJHtlLm9wVHlwZX0nIHdpdGggb3BzZXRzOiAke3QubWFwKChlPT5gJHtlLmRvbWFpbnx8XCJhaS5vbm54XCJ9IHYke2UudmVyc2lvbn1gKSkuam9pbihcIiwgXCIpfWApfX0sMTI4NzooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5vbm54cnVudGltZT12b2lkIDA7Y29uc3Qgcj1uKDU2ODYpO3ZhciBvLGk7bz10Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSksZnVuY3Rpb24oZSl7bGV0IHQ7IWZ1bmN0aW9uKGUpe2VbZS5VTkRFRklORUQ9MF09XCJVTkRFRklORURcIixlW2UuRkxPQVQ9MV09XCJGTE9BVFwiLGVbZS5JTlQ9Ml09XCJJTlRcIixlW2UuU1RSSU5HPTNdPVwiU1RSSU5HXCIsZVtlLlRFTlNPUj00XT1cIlRFTlNPUlwiLGVbZS5HUkFQSD01XT1cIkdSQVBIXCIsZVtlLkZMT0FUUz02XT1cIkZMT0FUU1wiLGVbZS5JTlRTPTddPVwiSU5UU1wiLGVbZS5TVFJJTkdTPThdPVwiU1RSSU5HU1wiLGVbZS5URU5TT1JTPTldPVwiVEVOU09SU1wiLGVbZS5HUkFQSFM9MTBdPVwiR1JBUEhTXCIsZVtlLlNQQVJTRV9URU5TT1I9MTFdPVwiU1BBUlNFX1RFTlNPUlwiLGVbZS5TUEFSU0VfVEVOU09SUz0xMl09XCJTUEFSU0VfVEVOU09SU1wifSh0PWUuQXR0cmlidXRlVHlwZXx8KGUuQXR0cmlidXRlVHlwZT17fSkpfSgoaT1vLmV4cGVyaW1lbnRhbHx8KG8uZXhwZXJpbWVudGFsPXt9KSkuZmJzfHwoaS5mYnM9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2xldCB0OyFmdW5jdGlvbihlKXtlW2UuVU5LTk9XTj0wXT1cIlVOS05PV05cIixlW2UuVkFMVUU9MV09XCJWQUxVRVwiLGVbZS5QQVJBTT0yXT1cIlBBUkFNXCJ9KHQ9ZS5EaW1lbnNpb25WYWx1ZVR5cGV8fChlLkRpbWVuc2lvblZhbHVlVHlwZT17fSkpfShlLmZic3x8KGUuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2xldCB0OyFmdW5jdGlvbihlKXtlW2UuVU5ERUZJTkVEPTBdPVwiVU5ERUZJTkVEXCIsZVtlLkZMT0FUPTFdPVwiRkxPQVRcIixlW2UuVUlOVDg9Ml09XCJVSU5UOFwiLGVbZS5JTlQ4PTNdPVwiSU5UOFwiLGVbZS5VSU5UMTY9NF09XCJVSU5UMTZcIixlW2UuSU5UMTY9NV09XCJJTlQxNlwiLGVbZS5JTlQzMj02XT1cIklOVDMyXCIsZVtlLklOVDY0PTddPVwiSU5UNjRcIixlW2UuU1RSSU5HPThdPVwiU1RSSU5HXCIsZVtlLkJPT0w9OV09XCJCT09MXCIsZVtlLkZMT0FUMTY9MTBdPVwiRkxPQVQxNlwiLGVbZS5ET1VCTEU9MTFdPVwiRE9VQkxFXCIsZVtlLlVJTlQzMj0xMl09XCJVSU5UMzJcIixlW2UuVUlOVDY0PTEzXT1cIlVJTlQ2NFwiLGVbZS5DT01QTEVYNjQ9MTRdPVwiQ09NUExFWDY0XCIsZVtlLkNPTVBMRVgxMjg9MTVdPVwiQ09NUExFWDEyOFwiLGVbZS5CRkxPQVQxNj0xNl09XCJCRkxPQVQxNlwifSh0PWUuVGVuc29yRGF0YVR5cGV8fChlLlRlbnNvckRhdGFUeXBlPXt9KSl9KGUuZmJzfHwoZS5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7bGV0IHQ7IWZ1bmN0aW9uKGUpe2VbZS5QcmltaXRpdmU9MF09XCJQcmltaXRpdmVcIixlW2UuRnVzZWQ9MV09XCJGdXNlZFwifSh0PWUuTm9kZVR5cGV8fChlLk5vZGVUeXBlPXt9KSl9KGUuZmJzfHwoZS5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7bGV0IHQ7IWZ1bmN0aW9uKGUpe2VbZS5OT05FPTBdPVwiTk9ORVwiLGVbZS50ZW5zb3JfdHlwZT0xXT1cInRlbnNvcl90eXBlXCIsZVtlLnNlcXVlbmNlX3R5cGU9Ml09XCJzZXF1ZW5jZV90eXBlXCIsZVtlLm1hcF90eXBlPTNdPVwibWFwX3R5cGVcIn0odD1lLlR5cGVJbmZvVmFsdWV8fChlLlR5cGVJbmZvVmFsdWU9e30pKX0oZS5mYnN8fChlLmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc1NoYXBlKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1NoYXBlKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1kaW0odCxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiByPyhufHxuZXcgZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvbikuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqdCksdGhpcy5iYik6bnVsbH1kaW1MZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9c3RhdGljIHN0YXJ0U2hhcGUoZSl7ZS5zdGFydE9iamVjdCgxKX1zdGF0aWMgYWRkRGltKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgwLHQsMCl9c3RhdGljIGNyZWF0ZURpbVZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnREaW1WZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgZW5kU2hhcGUoZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZVNoYXBlKGUsdCl7cmV0dXJuIG4uc3RhcnRTaGFwZShlKSxuLmFkZERpbShlLHQpLG4uZW5kU2hhcGUoZSl9fXQuU2hhcGU9bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc0RpbWVuc2lvbihlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNEaW1lbnNpb24oZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXZhbHVlKHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIG4/KHR8fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1kZW5vdGF0aW9uKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9c3RhdGljIHN0YXJ0RGltZW5zaW9uKGUpe2Uuc3RhcnRPYmplY3QoMil9c3RhdGljIGFkZFZhbHVlKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgwLHQsMCl9c3RhdGljIGFkZERlbm90YXRpb24oZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEsdCwwKX1zdGF0aWMgZW5kRGltZW5zaW9uKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVEaW1lbnNpb24oZSx0LHIpe3JldHVybiBuLnN0YXJ0RGltZW5zaW9uKGUpLG4uYWRkVmFsdWUoZSx0KSxuLmFkZERlbm90YXRpb24oZSxyKSxuLmVuZERpbWVuc2lvbihlKX19dC5EaW1lbnNpb249bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc0RpbWVuc2lvblZhbHVlKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0RpbWVuc2lvblZhbHVlKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1kaW1UeXBlKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQ4KHRoaXMuYmJfcG9zK3QpOmUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZVR5cGUuVU5LTk9XTn1kaW1WYWx1ZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MrZSk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9ZGltUGFyYW0oZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH1zdGF0aWMgc3RhcnREaW1lbnNpb25WYWx1ZShlKXtlLnN0YXJ0T2JqZWN0KDMpfXN0YXRpYyBhZGREaW1UeXBlKHQsbil7dC5hZGRGaWVsZEludDgoMCxuLGUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZVR5cGUuVU5LTk9XTil9c3RhdGljIGFkZERpbVZhbHVlKGUsdCl7ZS5hZGRGaWVsZEludDY0KDEsdCxlLmNyZWF0ZUxvbmcoMCwwKSl9c3RhdGljIGFkZERpbVBhcmFtKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgyLHQsMCl9c3RhdGljIGVuZERpbWVuc2lvblZhbHVlKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVEaW1lbnNpb25WYWx1ZShlLHQscixvKXtyZXR1cm4gbi5zdGFydERpbWVuc2lvblZhbHVlKGUpLG4uYWRkRGltVHlwZShlLHQpLG4uYWRkRGltVmFsdWUoZSxyKSxuLmFkZERpbVBhcmFtKGUsbyksbi5lbmREaW1lbnNpb25WYWx1ZShlKX19dC5EaW1lbnNpb25WYWx1ZT1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzVGVuc29yVHlwZUFuZFNoYXBlKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1RlbnNvclR5cGVBbmRTaGFwZShlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9ZWxlbVR5cGUoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB0P3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK3QpOmUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUR9c2hhcGUodCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gbj8odHx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5TaGFwZSkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfXN0YXRpYyBzdGFydFRlbnNvclR5cGVBbmRTaGFwZShlKXtlLnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGRFbGVtVHlwZSh0LG4pe3QuYWRkRmllbGRJbnQzMigwLG4sZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRCl9c3RhdGljIGFkZFNoYXBlKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxLHQsMCl9c3RhdGljIGVuZFRlbnNvclR5cGVBbmRTaGFwZShlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlVGVuc29yVHlwZUFuZFNoYXBlKGUsdCxyKXtyZXR1cm4gbi5zdGFydFRlbnNvclR5cGVBbmRTaGFwZShlKSxuLmFkZEVsZW1UeXBlKGUsdCksbi5hZGRTaGFwZShlLHIpLG4uZW5kVGVuc29yVHlwZUFuZFNoYXBlKGUpfX10LlRlbnNvclR5cGVBbmRTaGFwZT1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzTWFwVHlwZShlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNNYXBUeXBlKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1rZXlUeXBlKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcyt0KTplLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEfXZhbHVlVHlwZSh0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBuPyh0fHxuZXcgZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0TWFwVHlwZShlKXtlLnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGRLZXlUeXBlKHQsbil7dC5hZGRGaWVsZEludDMyKDAsbixlLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEKX1zdGF0aWMgYWRkVmFsdWVUeXBlKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxLHQsMCl9c3RhdGljIGVuZE1hcFR5cGUoZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZU1hcFR5cGUoZSx0LHIpe3JldHVybiBuLnN0YXJ0TWFwVHlwZShlKSxuLmFkZEtleVR5cGUoZSx0KSxuLmFkZFZhbHVlVHlwZShlLHIpLG4uZW5kTWFwVHlwZShlKX19dC5NYXBUeXBlPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNTZXF1ZW5jZVR5cGUoZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2VxdWVuY2VUeXBlKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1lbGVtVHlwZSh0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBuPyh0fHxuZXcgZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0U2VxdWVuY2VUeXBlKGUpe2Uuc3RhcnRPYmplY3QoMSl9c3RhdGljIGFkZEVsZW1UeXBlKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgwLHQsMCl9c3RhdGljIGVuZFNlcXVlbmNlVHlwZShlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlU2VxdWVuY2VUeXBlKGUsdCl7cmV0dXJuIG4uc3RhcnRTZXF1ZW5jZVR5cGUoZSksbi5hZGRFbGVtVHlwZShlLHQpLG4uZW5kU2VxdWVuY2VUeXBlKGUpfX10LlNlcXVlbmNlVHlwZT1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7KGUuZmJzfHwoZS5mYnM9e30pKS5FZGdlRW5kPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9bm9kZUluZGV4KCl7cmV0dXJuIHRoaXMuYmIucmVhZFVpbnQzMih0aGlzLmJiX3Bvcyl9c3JjQXJnSW5kZXgoKXtyZXR1cm4gdGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrNCl9ZHN0QXJnSW5kZXgoKXtyZXR1cm4gdGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrOCl9c3RhdGljIGNyZWF0ZUVkZ2VFbmQoZSx0LG4scil7cmV0dXJuIGUucHJlcCg0LDEyKSxlLndyaXRlSW50MzIociksZS53cml0ZUludDMyKG4pLGUud3JpdGVJbnQzMih0KSxlLm9mZnNldCgpfX19KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzTm9kZUVkZ2UoZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTm9kZUVkZ2UoZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfW5vZGVJbmRleCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5yZWFkVWludDMyKHRoaXMuYmJfcG9zK2UpOjB9aW5wdXRFZGdlcyh0LG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHI/KG58fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCkuX19pbml0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrMTIqdCx0aGlzLmJiKTpudWxsfWlucHV0RWRnZXNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9b3V0cHV0RWRnZXModCxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiByPyhufHxuZXcgZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQpLl9faW5pdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzEyKnQsdGhpcy5iYik6bnVsbH1vdXRwdXRFZGdlc0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1zdGF0aWMgc3RhcnROb2RlRWRnZShlKXtlLnN0YXJ0T2JqZWN0KDMpfXN0YXRpYyBhZGROb2RlSW5kZXgoZSx0KXtlLmFkZEZpZWxkSW50MzIoMCx0LDApfXN0YXRpYyBhZGRJbnB1dEVkZ2VzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxLHQsMCl9c3RhdGljIHN0YXJ0SW5wdXRFZGdlc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoMTIsdCw0KX1zdGF0aWMgYWRkT3V0cHV0RWRnZXMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDIsdCwwKX1zdGF0aWMgc3RhcnRPdXRwdXRFZGdlc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoMTIsdCw0KX1zdGF0aWMgZW5kTm9kZUVkZ2UoZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZU5vZGVFZGdlKGUsdCxyLG8pe3JldHVybiBuLnN0YXJ0Tm9kZUVkZ2UoZSksbi5hZGROb2RlSW5kZXgoZSx0KSxuLmFkZElucHV0RWRnZXMoZSxyKSxuLmFkZE91dHB1dEVkZ2VzKGUsbyksbi5lbmROb2RlRWRnZShlKX19dC5Ob2RlRWRnZT1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzTm9kZShlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNOb2RlKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1uYW1lKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9ZG9jU3RyaW5nKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9ZG9tYWluKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9c2luY2VWZXJzaW9uKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMCk7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrZSk6MH1pbmRleCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiBlP3RoaXMuYmIucmVhZFVpbnQzMih0aGlzLmJiX3BvcytlKTowfW9wVHlwZShlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH10eXBlKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrdCk6ZS5leHBlcmltZW50YWwuZmJzLk5vZGVUeXBlLlByaW1pdGl2ZX1leGVjdXRpb25Qcm92aWRlclR5cGUoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9aW5wdXRzKGUsdCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIG4/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK24pKzQqZSx0KTpudWxsfWlucHV0c0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjApO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9b3V0cHV0cyhlLHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjIpO3JldHVybiBuP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytuKSs0KmUsdCk6bnVsbH1vdXRwdXRzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMik7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1hdHRyaWJ1dGVzKHQsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNCk7cmV0dXJuIHI/KG58fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCp0KSx0aGlzLmJiKTpudWxsfWF0dHJpYnV0ZXNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI0KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfWlucHV0QXJnQ291bnRzKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjYpO3JldHVybiB0P3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrdCkrNCplKTowfWlucHV0QXJnQ291bnRzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1pbnB1dEFyZ0NvdW50c0FycmF5KCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIGU/bmV3IEludDMyQXJyYXkodGhpcy5iYi5ieXRlcygpLmJ1ZmZlcix0aGlzLmJiLmJ5dGVzKCkuYnl0ZU9mZnNldCt0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2UpLHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpKTpudWxsfWltcGxpY2l0SW5wdXRzKGUsdCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyOCk7cmV0dXJuIG4/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK24pKzQqZSx0KTpudWxsfWltcGxpY2l0SW5wdXRzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyOCk7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1zdGF0aWMgc3RhcnROb2RlKGUpe2Uuc3RhcnRPYmplY3QoMTMpfXN0YXRpYyBhZGROYW1lKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgwLHQsMCl9c3RhdGljIGFkZERvY1N0cmluZyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMSx0LDApfXN0YXRpYyBhZGREb21haW4oZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDIsdCwwKX1zdGF0aWMgYWRkU2luY2VWZXJzaW9uKGUsdCl7ZS5hZGRGaWVsZEludDMyKDMsdCwwKX1zdGF0aWMgYWRkSW5kZXgoZSx0KXtlLmFkZEZpZWxkSW50MzIoNCx0LDApfXN0YXRpYyBhZGRPcFR5cGUoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDUsdCwwKX1zdGF0aWMgYWRkVHlwZSh0LG4pe3QuYWRkRmllbGRJbnQzMig2LG4sZS5leHBlcmltZW50YWwuZmJzLk5vZGVUeXBlLlByaW1pdGl2ZSl9c3RhdGljIGFkZEV4ZWN1dGlvblByb3ZpZGVyVHlwZShlLHQpe2UuYWRkRmllbGRPZmZzZXQoNyx0LDApfXN0YXRpYyBhZGRJbnB1dHMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDgsdCwwKX1zdGF0aWMgY3JlYXRlSW5wdXRzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydElucHV0c1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBhZGRPdXRwdXRzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg5LHQsMCl9c3RhdGljIGNyZWF0ZU91dHB1dHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0T3V0cHV0c1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBhZGRBdHRyaWJ1dGVzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxMCx0LDApfXN0YXRpYyBjcmVhdGVBdHRyaWJ1dGVzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEF0dHJpYnV0ZXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgYWRkSW5wdXRBcmdDb3VudHMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDExLHQsMCl9c3RhdGljIGNyZWF0ZUlucHV0QXJnQ291bnRzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkSW50MzIodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW5wdXRBcmdDb3VudHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgYWRkSW1wbGljaXRJbnB1dHMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEyLHQsMCl9c3RhdGljIGNyZWF0ZUltcGxpY2l0SW5wdXRzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEltcGxpY2l0SW5wdXRzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGVuZE5vZGUoZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZU5vZGUoZSx0LHIsbyxpLGEscyx1LGwsYyxwLGQsZixoKXtyZXR1cm4gbi5zdGFydE5vZGUoZSksbi5hZGROYW1lKGUsdCksbi5hZGREb2NTdHJpbmcoZSxyKSxuLmFkZERvbWFpbihlLG8pLG4uYWRkU2luY2VWZXJzaW9uKGUsaSksbi5hZGRJbmRleChlLGEpLG4uYWRkT3BUeXBlKGUscyksbi5hZGRUeXBlKGUsdSksbi5hZGRFeGVjdXRpb25Qcm92aWRlclR5cGUoZSxsKSxuLmFkZElucHV0cyhlLGMpLG4uYWRkT3V0cHV0cyhlLHApLG4uYWRkQXR0cmlidXRlcyhlLGQpLG4uYWRkSW5wdXRBcmdDb3VudHMoZSxmKSxuLmFkZEltcGxpY2l0SW5wdXRzKGUsaCksbi5lbmROb2RlKGUpfX10Lk5vZGU9bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc1ZhbHVlSW5mbyhlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNWYWx1ZUluZm8oZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfW5hbWUoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH1kb2NTdHJpbmcoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH10eXBlKHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIG4/KHR8fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRWYWx1ZUluZm8oZSl7ZS5zdGFydE9iamVjdCgzKX1zdGF0aWMgYWRkTmFtZShlLHQpe2UuYWRkRmllbGRPZmZzZXQoMCx0LDApfXN0YXRpYyBhZGREb2NTdHJpbmcoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEsdCwwKX1zdGF0aWMgYWRkVHlwZShlLHQpe2UuYWRkRmllbGRPZmZzZXQoMix0LDApfXN0YXRpYyBlbmRWYWx1ZUluZm8oZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZVZhbHVlSW5mbyhlLHQscixvKXtyZXR1cm4gbi5zdGFydFZhbHVlSW5mbyhlKSxuLmFkZE5hbWUoZSx0KSxuLmFkZERvY1N0cmluZyhlLHIpLG4uYWRkVHlwZShlLG8pLG4uZW5kVmFsdWVJbmZvKGUpfX10LlZhbHVlSW5mbz1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzVHlwZUluZm8oZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVHlwZUluZm8oZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfWRlbm90YXRpb24oZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH12YWx1ZVR5cGUoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiB0P3RoaXMuYmIucmVhZFVpbnQ4KHRoaXMuYmJfcG9zK3QpOmUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb1ZhbHVlLk5PTkV9dmFsdWUoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fdW5pb24oZSx0aGlzLmJiX3Bvcyt0KTpudWxsfXN0YXRpYyBzdGFydFR5cGVJbmZvKGUpe2Uuc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZERlbm90YXRpb24oZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDAsdCwwKX1zdGF0aWMgYWRkVmFsdWVUeXBlKHQsbil7dC5hZGRGaWVsZEludDgoMSxuLGUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb1ZhbHVlLk5PTkUpfXN0YXRpYyBhZGRWYWx1ZShlLHQpe2UuYWRkRmllbGRPZmZzZXQoMix0LDApfXN0YXRpYyBlbmRUeXBlSW5mbyhlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlVHlwZUluZm8oZSx0LHIsbyl7cmV0dXJuIG4uc3RhcnRUeXBlSW5mbyhlKSxuLmFkZERlbm90YXRpb24oZSx0KSxuLmFkZFZhbHVlVHlwZShlLHIpLG4uYWRkVmFsdWUoZSxvKSxuLmVuZFR5cGVJbmZvKGUpfX10LlR5cGVJbmZvPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3MgdHtjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNPcGVyYXRvclNldElkKGUsbil7cmV0dXJuKG58fG5ldyB0KS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc09wZXJhdG9yU2V0SWQoZSxuKXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChufHxuZXcgdCkuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfWRvbWFpbihlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfXZlcnNpb24oKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmJfcG9zK2UpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfXN0YXRpYyBzdGFydE9wZXJhdG9yU2V0SWQoZSl7ZS5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkRG9tYWluKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgwLHQsMCl9c3RhdGljIGFkZFZlcnNpb24oZSx0KXtlLmFkZEZpZWxkSW50NjQoMSx0LGUuY3JlYXRlTG9uZygwLDApKX1zdGF0aWMgZW5kT3BlcmF0b3JTZXRJZChlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlT3BlcmF0b3JTZXRJZChlLG4scil7cmV0dXJuIHQuc3RhcnRPcGVyYXRvclNldElkKGUpLHQuYWRkRG9tYWluKGUsbiksdC5hZGRWZXJzaW9uKGUsciksdC5lbmRPcGVyYXRvclNldElkKGUpfX1lLk9wZXJhdG9yU2V0SWQ9dH0oZS5mYnN8fChlLmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc1RlbnNvcihlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNUZW5zb3IoZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfW5hbWUoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH1kb2NTdHJpbmcoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH1kaW1zKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3Bvcyt0KSs4KmUpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWRpbXNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9ZGF0YVR5cGUoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEwKTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcyt0KTplLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEfXJhd0RhdGEoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkVWludDgodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3Bvcyt0KStlKTowfXJhd0RhdGFMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfXJhd0RhdGFBcnJheSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiBlP25ldyBVaW50OEFycmF5KHRoaXMuYmIuYnl0ZXMoKS5idWZmZXIsdGhpcy5iYi5ieXRlcygpLmJ5dGVPZmZzZXQrdGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSx0aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKSk6bnVsbH1zdHJpbmdEYXRhKGUsdCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIG4/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK24pKzQqZSx0KTpudWxsfXN0cmluZ0RhdGFMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfXN0YXRpYyBzdGFydFRlbnNvcihlKXtlLnN0YXJ0T2JqZWN0KDYpfXN0YXRpYyBhZGROYW1lKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgwLHQsMCl9c3RhdGljIGFkZERvY1N0cmluZyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMSx0LDApfXN0YXRpYyBhZGREaW1zKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgyLHQsMCl9c3RhdGljIGNyZWF0ZURpbXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDgsdC5sZW5ndGgsOCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRJbnQ2NCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnREaW1zVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig4LHQsOCl9c3RhdGljIGFkZERhdGFUeXBlKHQsbil7dC5hZGRGaWVsZEludDMyKDMsbixlLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEKX1zdGF0aWMgYWRkUmF3RGF0YShlLHQpe2UuYWRkRmllbGRPZmZzZXQoNCx0LDApfXN0YXRpYyBjcmVhdGVSYXdEYXRhVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3RvcigxLHQubGVuZ3RoLDEpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkSW50OCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRSYXdEYXRhVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3RvcigxLHQsMSl9c3RhdGljIGFkZFN0cmluZ0RhdGEoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDUsdCwwKX1zdGF0aWMgY3JlYXRlU3RyaW5nRGF0YVZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRTdHJpbmdEYXRhVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGVuZFRlbnNvcihlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlVGVuc29yKGUsdCxyLG8saSxhLHMpe3JldHVybiBuLnN0YXJ0VGVuc29yKGUpLG4uYWRkTmFtZShlLHQpLG4uYWRkRG9jU3RyaW5nKGUsciksbi5hZGREaW1zKGUsbyksbi5hZGREYXRhVHlwZShlLGkpLG4uYWRkUmF3RGF0YShlLGEpLG4uYWRkU3RyaW5nRGF0YShlLHMpLG4uZW5kVGVuc29yKGUpfX10LlRlbnNvcj1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzU3BhcnNlVGVuc29yKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1NwYXJzZVRlbnNvcihlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9dmFsdWVzKHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIG4/KHR8fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9aW5kaWNlcyh0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBuPyh0fHxuZXcgZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcikuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfWRpbXMoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpKzgqZSk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9ZGltc0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1zdGF0aWMgc3RhcnRTcGFyc2VUZW5zb3IoZSl7ZS5zdGFydE9iamVjdCgzKX1zdGF0aWMgYWRkVmFsdWVzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgwLHQsMCl9c3RhdGljIGFkZEluZGljZXMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEsdCwwKX1zdGF0aWMgYWRkRGltcyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMix0LDApfXN0YXRpYyBjcmVhdGVEaW1zVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig4LHQubGVuZ3RoLDgpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkSW50NjQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0RGltc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoOCx0LDgpfXN0YXRpYyBlbmRTcGFyc2VUZW5zb3IoZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZVNwYXJzZVRlbnNvcihlLHQscixvKXtyZXR1cm4gbi5zdGFydFNwYXJzZVRlbnNvcihlKSxuLmFkZFZhbHVlcyhlLHQpLG4uYWRkSW5kaWNlcyhlLHIpLG4uYWRkRGltcyhlLG8pLG4uZW5kU3BhcnNlVGVuc29yKGUpfX10LlNwYXJzZVRlbnNvcj1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzQXR0cmlidXRlKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0F0dHJpYnV0ZShlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9bmFtZShlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfWRvY1N0cmluZyhlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfXR5cGUoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiB0P3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK3QpOmUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVUeXBlLlVOREVGSU5FRH1mKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMCk7cmV0dXJuIGU/dGhpcy5iYi5yZWFkRmxvYXQzMih0aGlzLmJiX3BvcytlKTowfWkoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gZT90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcytlKTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1zKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfXQodCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIG4/KHR8fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9Zyh0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE4KTtyZXR1cm4gbj8odHx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfWZsb2F0cyhlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gdD90aGlzLmJiLnJlYWRGbG9hdDMyKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrdCkrNCplKTowfWZsb2F0c0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjApO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9ZmxvYXRzQXJyYXkoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gZT9uZXcgRmxvYXQzMkFycmF5KHRoaXMuYmIuYnl0ZXMoKS5idWZmZXIsdGhpcy5iYi5ieXRlcygpLmJ5dGVPZmZzZXQrdGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSx0aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKSk6bnVsbH1pbnRzKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjIpO3JldHVybiB0P3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrdCkrOCplKTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1pbnRzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMik7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1zdHJpbmdzKGUsdCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNCk7cmV0dXJuIG4/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK24pKzQqZSx0KTpudWxsfXN0cmluZ3NMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI0KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfXRlbnNvcnModCxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI2KTtyZXR1cm4gcj8obnx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KnQpLHRoaXMuYmIpOm51bGx9dGVuc29yc0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjYpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9Z3JhcGhzKHQsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyOCk7cmV0dXJuIHI/KG58fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KnQpLHRoaXMuYmIpOm51bGx9Z3JhcGhzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyOCk7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1zdGF0aWMgc3RhcnRBdHRyaWJ1dGUoZSl7ZS5zdGFydE9iamVjdCgxMyl9c3RhdGljIGFkZE5hbWUoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDAsdCwwKX1zdGF0aWMgYWRkRG9jU3RyaW5nKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxLHQsMCl9c3RhdGljIGFkZFR5cGUodCxuKXt0LmFkZEZpZWxkSW50MzIoMixuLGUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVUeXBlLlVOREVGSU5FRCl9c3RhdGljIGFkZEYoZSx0KXtlLmFkZEZpZWxkRmxvYXQzMigzLHQsMCl9c3RhdGljIGFkZEkoZSx0KXtlLmFkZEZpZWxkSW50NjQoNCx0LGUuY3JlYXRlTG9uZygwLDApKX1zdGF0aWMgYWRkUyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoNSx0LDApfXN0YXRpYyBhZGRUKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg2LHQsMCl9c3RhdGljIGFkZEcoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDcsdCwwKX1zdGF0aWMgYWRkRmxvYXRzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg4LHQsMCl9c3RhdGljIGNyZWF0ZUZsb2F0c1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZEZsb2F0MzIodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0RmxvYXRzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGFkZEludHMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDksdCwwKX1zdGF0aWMgY3JlYXRlSW50c1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoOCx0Lmxlbmd0aCw4KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZEludDY0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEludHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDgsdCw4KX1zdGF0aWMgYWRkU3RyaW5ncyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMTAsdCwwKX1zdGF0aWMgY3JlYXRlU3RyaW5nc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRTdHJpbmdzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGFkZFRlbnNvcnMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDExLHQsMCl9c3RhdGljIGNyZWF0ZVRlbnNvcnNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0VGVuc29yc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBhZGRHcmFwaHMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEyLHQsMCl9c3RhdGljIGNyZWF0ZUdyYXBoc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRHcmFwaHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgZW5kQXR0cmlidXRlKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVBdHRyaWJ1dGUoZSx0LHIsbyxpLGEscyx1LGwsYyxwLGQsZixoKXtyZXR1cm4gbi5zdGFydEF0dHJpYnV0ZShlKSxuLmFkZE5hbWUoZSx0KSxuLmFkZERvY1N0cmluZyhlLHIpLG4uYWRkVHlwZShlLG8pLG4uYWRkRihlLGkpLG4uYWRkSShlLGEpLG4uYWRkUyhlLHMpLG4uYWRkVChlLHUpLG4uYWRkRyhlLGwpLG4uYWRkRmxvYXRzKGUsYyksbi5hZGRJbnRzKGUscCksbi5hZGRTdHJpbmdzKGUsZCksbi5hZGRUZW5zb3JzKGUsZiksbi5hZGRHcmFwaHMoZSxoKSxuLmVuZEF0dHJpYnV0ZShlKX19dC5BdHRyaWJ1dGU9bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc0dyYXBoKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0dyYXBoKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1pbml0aWFsaXplcnModCxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiByPyhufHxuZXcgZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcikuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqdCksdGhpcy5iYik6bnVsbH1pbml0aWFsaXplcnNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9bm9kZUFyZ3ModCxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiByPyhufHxuZXcgZS5leHBlcmltZW50YWwuZmJzLlZhbHVlSW5mbykuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqdCksdGhpcy5iYik6bnVsbH1ub2RlQXJnc0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1ub2Rlcyh0LG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHI/KG58fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuTm9kZSkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqdCksdGhpcy5iYik6bnVsbH1ub2Rlc0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1tYXhOb2RlSW5kZXgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEwKTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50MzIodGhpcy5iYl9wb3MrZSk6MH1ub2RlRWRnZXModCxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gcj8obnx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5Ob2RlRWRnZSkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqdCksdGhpcy5iYik6bnVsbH1ub2RlRWRnZXNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfWlucHV0cyhlLHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiBuP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytuKSs0KmUsdCk6bnVsbH1pbnB1dHNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfW91dHB1dHMoZSx0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE2KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCplLHQpOm51bGx9b3V0cHV0c0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTYpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9c3BhcnNlSW5pdGlhbGl6ZXJzKHQsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIHI/KG58fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuU3BhcnNlVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCp0KSx0aGlzLmJiKTpudWxsfXNwYXJzZUluaXRpYWxpemVyc0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTgpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9c3RhdGljIHN0YXJ0R3JhcGgoZSl7ZS5zdGFydE9iamVjdCg4KX1zdGF0aWMgYWRkSW5pdGlhbGl6ZXJzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgwLHQsMCl9c3RhdGljIGNyZWF0ZUluaXRpYWxpemVyc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRJbml0aWFsaXplcnNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgYWRkTm9kZUFyZ3MoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEsdCwwKX1zdGF0aWMgY3JlYXRlTm9kZUFyZ3NWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0Tm9kZUFyZ3NWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgYWRkTm9kZXMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDIsdCwwKX1zdGF0aWMgY3JlYXRlTm9kZXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0Tm9kZXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgYWRkTWF4Tm9kZUluZGV4KGUsdCl7ZS5hZGRGaWVsZEludDMyKDMsdCwwKX1zdGF0aWMgYWRkTm9kZUVkZ2VzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg0LHQsMCl9c3RhdGljIGNyZWF0ZU5vZGVFZGdlc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnROb2RlRWRnZXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgYWRkSW5wdXRzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg1LHQsMCl9c3RhdGljIGNyZWF0ZUlucHV0c1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRJbnB1dHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgYWRkT3V0cHV0cyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoNix0LDApfXN0YXRpYyBjcmVhdGVPdXRwdXRzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE91dHB1dHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgYWRkU3BhcnNlSW5pdGlhbGl6ZXJzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg3LHQsMCl9c3RhdGljIGNyZWF0ZVNwYXJzZUluaXRpYWxpemVyc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRTcGFyc2VJbml0aWFsaXplcnNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgZW5kR3JhcGgoZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZUdyYXBoKGUsdCxyLG8saSxhLHMsdSxsKXtyZXR1cm4gbi5zdGFydEdyYXBoKGUpLG4uYWRkSW5pdGlhbGl6ZXJzKGUsdCksbi5hZGROb2RlQXJncyhlLHIpLG4uYWRkTm9kZXMoZSxvKSxuLmFkZE1heE5vZGVJbmRleChlLGkpLG4uYWRkTm9kZUVkZ2VzKGUsYSksbi5hZGRJbnB1dHMoZSxzKSxuLmFkZE91dHB1dHMoZSx1KSxuLmFkZFNwYXJzZUluaXRpYWxpemVycyhlLGwpLG4uZW5kR3JhcGgoZSl9fXQuR3JhcGg9bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc01vZGVsKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc01vZGVsKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1pclZlcnNpb24oKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmJfcG9zK2UpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfW9wc2V0SW1wb3J0KHQsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gcj8obnx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5PcGVyYXRvclNldElkKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCp0KSx0aGlzLmJiKTpudWxsfW9wc2V0SW1wb3J0TGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfXByb2R1Y2VyTmFtZShlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfXByb2R1Y2VyVmVyc2lvbihlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEwKTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH1kb21haW4oZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9bW9kZWxWZXJzaW9uKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MrZSk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9ZG9jU3RyaW5nKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTYpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfWdyYXBoKHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTgpO3JldHVybiBuPyh0fHxuZXcgZS5leHBlcmltZW50YWwuZmJzLkdyYXBoKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9Z3JhcGhEb2NTdHJpbmcoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9c3RhdGljIHN0YXJ0TW9kZWwoZSl7ZS5zdGFydE9iamVjdCg5KX1zdGF0aWMgYWRkSXJWZXJzaW9uKGUsdCl7ZS5hZGRGaWVsZEludDY0KDAsdCxlLmNyZWF0ZUxvbmcoMCwwKSl9c3RhdGljIGFkZE9wc2V0SW1wb3J0KGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxLHQsMCl9c3RhdGljIGNyZWF0ZU9wc2V0SW1wb3J0VmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE9wc2V0SW1wb3J0VmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGFkZFByb2R1Y2VyTmFtZShlLHQpe2UuYWRkRmllbGRPZmZzZXQoMix0LDApfXN0YXRpYyBhZGRQcm9kdWNlclZlcnNpb24oZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDMsdCwwKX1zdGF0aWMgYWRkRG9tYWluKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg0LHQsMCl9c3RhdGljIGFkZE1vZGVsVmVyc2lvbihlLHQpe2UuYWRkRmllbGRJbnQ2NCg1LHQsZS5jcmVhdGVMb25nKDAsMCkpfXN0YXRpYyBhZGREb2NTdHJpbmcoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDYsdCwwKX1zdGF0aWMgYWRkR3JhcGgoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDcsdCwwKX1zdGF0aWMgYWRkR3JhcGhEb2NTdHJpbmcoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDgsdCwwKX1zdGF0aWMgZW5kTW9kZWwoZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZU1vZGVsKGUsdCxyLG8saSxhLHMsdSxsLGMpe3JldHVybiBuLnN0YXJ0TW9kZWwoZSksbi5hZGRJclZlcnNpb24oZSx0KSxuLmFkZE9wc2V0SW1wb3J0KGUsciksbi5hZGRQcm9kdWNlck5hbWUoZSxvKSxuLmFkZFByb2R1Y2VyVmVyc2lvbihlLGkpLG4uYWRkRG9tYWluKGUsYSksbi5hZGRNb2RlbFZlcnNpb24oZSxzKSxuLmFkZERvY1N0cmluZyhlLHUpLG4uYWRkR3JhcGgoZSxsKSxuLmFkZEdyYXBoRG9jU3RyaW5nKGUsYyksbi5lbmRNb2RlbChlKX19dC5Nb2RlbD1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIHR7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzS2VybmVsQ3JlYXRlSW5mb3MoZSxuKXtyZXR1cm4obnx8bmV3IHQpLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzS2VybmVsQ3JlYXRlSW5mb3MoZSxuKXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChufHxuZXcgdCkuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfW5vZGVJbmRpY2VzKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkVWludDMyKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrdCkrNCplKTowfW5vZGVJbmRpY2VzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfW5vZGVJbmRpY2VzQXJyYXkoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP25ldyBVaW50MzJBcnJheSh0aGlzLmJiLmJ5dGVzKCkuYnVmZmVyLHRoaXMuYmIuYnl0ZXMoKS5ieXRlT2Zmc2V0K3RoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrZSksdGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSkpOm51bGx9a2VybmVsRGVmSGFzaGVzKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkVWludDY0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrdCkrOCplKTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1rZXJuZWxEZWZIYXNoZXNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9c3RhdGljIHN0YXJ0S2VybmVsQ3JlYXRlSW5mb3MoZSl7ZS5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkTm9kZUluZGljZXMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDAsdCwwKX1zdGF0aWMgY3JlYXRlTm9kZUluZGljZXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRJbnQzMih0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnROb2RlSW5kaWNlc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBhZGRLZXJuZWxEZWZIYXNoZXMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEsdCwwKX1zdGF0aWMgY3JlYXRlS2VybmVsRGVmSGFzaGVzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig4LHQubGVuZ3RoLDgpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkSW50NjQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0S2VybmVsRGVmSGFzaGVzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig4LHQsOCl9c3RhdGljIGVuZEtlcm5lbENyZWF0ZUluZm9zKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVLZXJuZWxDcmVhdGVJbmZvcyhlLG4scil7cmV0dXJuIHQuc3RhcnRLZXJuZWxDcmVhdGVJbmZvcyhlKSx0LmFkZE5vZGVJbmRpY2VzKGUsbiksdC5hZGRLZXJuZWxEZWZIYXNoZXMoZSxyKSx0LmVuZEtlcm5lbENyZWF0ZUluZm9zKGUpfX1lLktlcm5lbENyZWF0ZUluZm9zPXR9KGUuZmJzfHwoZS5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNTdWJHcmFwaFNlc3Npb25TdGF0ZShlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTdWJHcmFwaFNlc3Npb25TdGF0ZShlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9Z3JhcGhJZChlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfXNlc3Npb25TdGF0ZSh0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBuPyh0fHxuZXcgZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZSkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfXN0YXRpYyBzdGFydFN1YkdyYXBoU2Vzc2lvblN0YXRlKGUpe2Uuc3RhcnRPYmplY3QoMil9c3RhdGljIGFkZEdyYXBoSWQoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDAsdCwwKX1zdGF0aWMgYWRkU2Vzc2lvblN0YXRlKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxLHQsMCl9c3RhdGljIGVuZFN1YkdyYXBoU2Vzc2lvblN0YXRlKGUpe2xldCB0PWUuZW5kT2JqZWN0KCk7cmV0dXJuIGUucmVxdWlyZWRGaWVsZCh0LDQpLHR9c3RhdGljIGNyZWF0ZVN1YkdyYXBoU2Vzc2lvblN0YXRlKGUsdCxyKXtyZXR1cm4gbi5zdGFydFN1YkdyYXBoU2Vzc2lvblN0YXRlKGUpLG4uYWRkR3JhcGhJZChlLHQpLG4uYWRkU2Vzc2lvblN0YXRlKGUsciksbi5lbmRTdWJHcmFwaFNlc3Npb25TdGF0ZShlKX19dC5TdWJHcmFwaFNlc3Npb25TdGF0ZT1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzU2Vzc2lvblN0YXRlKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1Nlc3Npb25TdGF0ZShlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9a2VybmVscyh0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBuPyh0fHxuZXcgZS5leHBlcmltZW50YWwuZmJzLktlcm5lbENyZWF0ZUluZm9zKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c3ViR3JhcGhTZXNzaW9uU3RhdGVzKHQsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gcj8obnx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5TdWJHcmFwaFNlc3Npb25TdGF0ZSkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqdCksdGhpcy5iYik6bnVsbH1zdWJHcmFwaFNlc3Npb25TdGF0ZXNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9c3RhdGljIHN0YXJ0U2Vzc2lvblN0YXRlKGUpe2Uuc3RhcnRPYmplY3QoMil9c3RhdGljIGFkZEtlcm5lbHMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDAsdCwwKX1zdGF0aWMgYWRkU3ViR3JhcGhTZXNzaW9uU3RhdGVzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxLHQsMCl9c3RhdGljIGNyZWF0ZVN1YkdyYXBoU2Vzc2lvblN0YXRlc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRTdWJHcmFwaFNlc3Npb25TdGF0ZXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgZW5kU2Vzc2lvblN0YXRlKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVTZXNzaW9uU3RhdGUoZSx0LHIpe3JldHVybiBuLnN0YXJ0U2Vzc2lvblN0YXRlKGUpLG4uYWRkS2VybmVscyhlLHQpLG4uYWRkU3ViR3JhcGhTZXNzaW9uU3RhdGVzKGUsciksbi5lbmRTZXNzaW9uU3RhdGUoZSl9fXQuU2Vzc2lvblN0YXRlPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNJbmZlcmVuY2VTZXNzaW9uKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0luZmVyZW5jZVNlc3Npb24oZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBidWZmZXJIYXNJZGVudGlmaWVyKGUpe3JldHVybiBlLl9faGFzX2lkZW50aWZpZXIoXCJPUlRNXCIpfW9ydFZlcnNpb24oZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH1tb2RlbCh0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBuPyh0fHxuZXcgZS5leHBlcmltZW50YWwuZmJzLk1vZGVsKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c2Vzc2lvblN0YXRlKHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIG4/KHR8fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0SW5mZXJlbmNlU2Vzc2lvbihlKXtlLnN0YXJ0T2JqZWN0KDMpfXN0YXRpYyBhZGRPcnRWZXJzaW9uKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgwLHQsMCl9c3RhdGljIGFkZE1vZGVsKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxLHQsMCl9c3RhdGljIGFkZFNlc3Npb25TdGF0ZShlLHQpe2UuYWRkRmllbGRPZmZzZXQoMix0LDApfXN0YXRpYyBlbmRJbmZlcmVuY2VTZXNzaW9uKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBmaW5pc2hJbmZlcmVuY2VTZXNzaW9uQnVmZmVyKGUsdCl7ZS5maW5pc2godCxcIk9SVE1cIil9c3RhdGljIGZpbmlzaFNpemVQcmVmaXhlZEluZmVyZW5jZVNlc3Npb25CdWZmZXIoZSx0KXtlLmZpbmlzaCh0LFwiT1JUTVwiLCEwKX1zdGF0aWMgY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbihlLHQscixvKXtyZXR1cm4gbi5zdGFydEluZmVyZW5jZVNlc3Npb24oZSksbi5hZGRPcnRWZXJzaW9uKGUsdCksbi5hZGRNb2RlbChlLHIpLG4uYWRkU2Vzc2lvblN0YXRlKGUsbyksbi5lbmRJbmZlcmVuY2VTZXNzaW9uKGUpfX10LkluZmVyZW5jZVNlc3Npb249bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSl9LDE3MjM6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuT25ueGpzU2Vzc2lvbkhhbmRsZXI9dm9pZCAwO2NvbnN0IHI9big4NDUzKSxvPW4oOTI0MCk7dC5Pbm54anNTZXNzaW9uSGFuZGxlcj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnNlc3Npb249ZSx0aGlzLmlucHV0TmFtZXM9dGhpcy5zZXNzaW9uLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lcz10aGlzLnNlc3Npb24ub3V0cHV0TmFtZXN9YXN5bmMgZGlzcG9zZSgpe31hc3luYyBydW4oZSx0LG4pe2NvbnN0IGk9bmV3IE1hcDtmb3IoY29uc3QgdCBpbiBlKWlmKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkpe2NvbnN0IG49ZVt0XTtpLnNldCh0LG5ldyBvLlRlbnNvcihuLmRpbXMsbi50eXBlLHZvaWQgMCx2b2lkIDAsbi5kYXRhKSl9Y29uc3QgYT1hd2FpdCB0aGlzLnNlc3Npb24ucnVuKGkpLHM9e307cmV0dXJuIGEuZm9yRWFjaCgoKGUsdCk9PntzW3RdPW5ldyByLlRlbnNvcihlLnR5cGUsZS5kYXRhLGUuZGltcyl9KSksc31zdGFydFByb2ZpbGluZygpe3RoaXMuc2Vzc2lvbi5zdGFydFByb2ZpbGluZygpfWVuZFByb2ZpbGluZygpe3RoaXMuc2Vzc2lvbi5lbmRQcm9maWxpbmcoKX19fSw2MDI3OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlNlc3Npb249dm9pZCAwO2NvbnN0IHI9big3MDY3KSxvPW4oMTI5NiksaT1uKDE5NzUpLGE9big2NDk2KSxzPW4oMTMxNSksdT1uKDE3NDUpO3QuU2Vzc2lvbj1jbGFzc3tjb25zdHJ1Y3RvcihlPXt9KXt0aGlzLl9pbml0aWFsaXplZD0hMSx0aGlzLmJhY2tlbmRIaW50PWUuYmFja2VuZEhpbnQsdGhpcy5wcm9maWxlcj1zLlByb2ZpbGVyLmNyZWF0ZShlLnByb2ZpbGVyKSx0aGlzLmNvbnRleHQ9e3Byb2ZpbGVyOnRoaXMucHJvZmlsZXIsZ3JhcGhJbnB1dFR5cGVzOltdLGdyYXBoSW5wdXREaW1zOltdfX1nZXQgaW5wdXROYW1lcygpe3JldHVybiB0aGlzLl9tb2RlbC5ncmFwaC5nZXRJbnB1dE5hbWVzKCl9Z2V0IG91dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX21vZGVsLmdyYXBoLmdldE91dHB1dE5hbWVzKCl9c3RhcnRQcm9maWxpbmcoKXt0aGlzLnByb2ZpbGVyLnN0YXJ0KCl9ZW5kUHJvZmlsaW5nKCl7dGhpcy5wcm9maWxlci5zdG9wKCl9YXN5bmMgbG9hZE1vZGVsKGUsdCxuKXthd2FpdCB0aGlzLnByb2ZpbGVyLmV2ZW50KFwic2Vzc2lvblwiLFwiU2Vzc2lvbi5sb2FkTW9kZWxcIiwoYXN5bmMoKT0+e2NvbnN0IGE9YXdhaXQoMCxpLnJlc29sdmVCYWNrZW5kKSh0aGlzLmJhY2tlbmRIaW50KTtpZih0aGlzLnNlc3Npb25IYW5kbGVyPWEuY3JlYXRlU2Vzc2lvbkhhbmRsZXIodGhpcy5jb250ZXh0KSx0aGlzLl9tb2RlbD1uZXcgdS5Nb2RlbCxcInN0cmluZ1wiPT10eXBlb2YgZSl7Y29uc3QgdD1lLmVuZHNXaXRoKFwiLm9ydFwiKTtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZmV0Y2gpe2NvbnN0IG49YXdhaXQoMCxvLnByb21pc2lmeSkoci5yZWFkRmlsZSkoZSk7dGhpcy5pbml0aWFsaXplKG4sdCl9ZWxzZXtjb25zdCBuPWF3YWl0IGZldGNoKGUpLHI9YXdhaXQgbi5hcnJheUJ1ZmZlcigpO3RoaXMuaW5pdGlhbGl6ZShuZXcgVWludDhBcnJheShyKSx0KX19ZWxzZSBpZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpdGhpcy5pbml0aWFsaXplKGUpO2Vsc2V7Y29uc3Qgcj1uZXcgVWludDhBcnJheShlLHR8fDAsbnx8ZS5ieXRlTGVuZ3RoKTt0aGlzLmluaXRpYWxpemUocil9fSkpfWluaXRpYWxpemUoZSx0KXtpZih0aGlzLl9pbml0aWFsaXplZCl0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IGluaXRpYWxpemVkXCIpO3RoaXMucHJvZmlsZXIuZXZlbnQoXCJzZXNzaW9uXCIsXCJTZXNzaW9uLmluaXRpYWxpemVcIiwoKCk9Pntjb25zdCBuPXRoaXMuc2Vzc2lvbkhhbmRsZXIudHJhbnNmb3JtR3JhcGg/dGhpcy5zZXNzaW9uSGFuZGxlcjp2b2lkIDA7dGhpcy5fbW9kZWwubG9hZChlLG4sdCksdGhpcy5zZXNzaW9uSGFuZGxlci5vbkdyYXBoSW5pdGlhbGl6ZWQmJnRoaXMuc2Vzc2lvbkhhbmRsZXIub25HcmFwaEluaXRpYWxpemVkKHRoaXMuX21vZGVsLmdyYXBoKSx0aGlzLmluaXRpYWxpemVPcHModGhpcy5fbW9kZWwuZ3JhcGgpLHRoaXMuX2V4ZWN1dGlvblBsYW49bmV3IGEuRXhlY3V0aW9uUGxhbih0aGlzLl9tb2RlbC5ncmFwaCx0aGlzLl9vcHMsdGhpcy5wcm9maWxlcil9KSksdGhpcy5faW5pdGlhbGl6ZWQ9ITB9YXN5bmMgcnVuKGUpe2lmKCF0aGlzLl9pbml0aWFsaXplZCl0aHJvdyBuZXcgRXJyb3IoXCJzZXNzaW9uIG5vdCBpbml0aWFsaXplZCB5ZXRcIik7cmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoXCJzZXNzaW9uXCIsXCJTZXNzaW9uLnJ1blwiLChhc3luYygpPT57Y29uc3QgdD10aGlzLm5vcm1hbGl6ZUFuZFZhbGlkYXRlSW5wdXRzKGUpLG49YXdhaXQgdGhpcy5fZXhlY3V0aW9uUGxhbi5leGVjdXRlKHRoaXMuc2Vzc2lvbkhhbmRsZXIsdCk7cmV0dXJuIHRoaXMuY3JlYXRlT3V0cHV0KG4pfSkpfW5vcm1hbGl6ZUFuZFZhbGlkYXRlSW5wdXRzKGUpe2NvbnN0IHQ9dGhpcy5fbW9kZWwuZ3JhcGguZ2V0SW5wdXROYW1lcygpO2lmKEFycmF5LmlzQXJyYXkoZSkpe2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbmNvcnJlY3QgaW5wdXQgYXJyYXkgbGVuZ3RoOiBleHBlY3RlZCAke3QubGVuZ3RofSBidXQgZ290ICR7ZS5sZW5ndGh9YCl9ZWxzZXtpZihlLnNpemUhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGluY29ycmVjdCBpbnB1dCBtYXAgc2l6ZTogZXhwZWN0ZWQgJHt0Lmxlbmd0aH0gYnV0IGdvdCAke2Uuc2l6ZX1gKTtjb25zdCBuPW5ldyBBcnJheShlLnNpemUpO2xldCByPTA7Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aDsrK28pe2NvbnN0IGk9ZS5nZXQodFtvXSk7aWYoIWkpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGlucHV0IHRlbnNvciBmb3I6ICcke25hbWV9J2ApO25bcisrXT1pfWU9bn1pZih0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzJiYwIT09dGhpcy5jb250ZXh0LmdyYXBoSW5wdXRUeXBlcy5sZW5ndGgmJnRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcyYmMCE9PXRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcy5sZW5ndGgpdGhpcy52YWxpZGF0ZUlucHV0VGVuc29yRGltcyh0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dERpbXMsZSwhMSk7ZWxzZXtjb25zdCB0PXRoaXMuX21vZGVsLmdyYXBoLmdldElucHV0SW5kaWNlcygpLG49dGhpcy5fbW9kZWwuZ3JhcGguZ2V0VmFsdWVzKCkscj1uZXcgQXJyYXkodC5sZW5ndGgpO2ZvcihsZXQgbz0wO288dC5sZW5ndGg7KytvKXtjb25zdCBpPW5bdFtvXV07cltvXT1pLnR5cGUuc2hhcGUuZGltcyx0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzLnB1c2goaS50eXBlLnRlbnNvclR5cGUpLHRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcy5wdXNoKGVbb10uZGltcyl9dGhpcy52YWxpZGF0ZUlucHV0VGVuc29yRGltcyhyLGUsITApfXJldHVybiB0aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JUeXBlcyh0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzLGUpLGV9dmFsaWRhdGVJbnB1dFRlbnNvclR5cGVzKGUsdCl7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspe2NvbnN0IHI9ZVtuXSxvPXRbbl0udHlwZTtpZihyIT09byl0aHJvdyBuZXcgRXJyb3IoYGlucHV0IHRlbnNvclske259XSBjaGVjayBmYWlsZWQ6IGV4cGVjdGVkIHR5cGUgJyR7cn0nIGJ1dCBnb3QgJHtvfWApfX12YWxpZGF0ZUlucHV0VGVuc29yRGltcyhlLHQsbil7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspe2NvbnN0IG89ZVtyXSxpPXRbcl0uZGltcztpZighdGhpcy5jb21wYXJlVGVuc29yRGltcyhvLGksbikpdGhyb3cgbmV3IEVycm9yKGBpbnB1dCB0ZW5zb3JbJHtyfV0gY2hlY2sgZmFpbGVkOiBleHBlY3RlZCBzaGFwZSAnWyR7by5qb2luKFwiLFwiKX1dJyBidXQgZ290IFske2kuam9pbihcIixcIil9XWApfX1jb21wYXJlVGVuc29yRGltcyhlLHQsbil7aWYoZS5sZW5ndGghPT10Lmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoOysrcilpZihlW3JdIT09dFtyXSYmKCFufHwwIT09ZVtyXSkpcmV0dXJuITE7cmV0dXJuITB9Y3JlYXRlT3V0cHV0KGUpe2NvbnN0IHQ9dGhpcy5fbW9kZWwuZ3JhcGguZ2V0T3V0cHV0TmFtZXMoKTtpZihlLmxlbmd0aCE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIG51bWJlciBvZiBvdXRwdXRzIGRvIG5vdCBtYXRjaCBudW1iZXIgb2YgZ2VuZXJhdGVkIG91dHB1dHNcIik7Y29uc3Qgbj1uZXcgTWFwO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7KytyKW4uc2V0KHRbcl0sZVtyXSk7cmV0dXJuIG59aW5pdGlhbGl6ZU9wcyhlKXtjb25zdCB0PWUuZ2V0Tm9kZXMoKTt0aGlzLl9vcHM9bmV3IEFycmF5KHQubGVuZ3RoKTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl0aGlzLl9vcHNbbl09dGhpcy5zZXNzaW9uSGFuZGxlci5yZXNvbHZlKHRbbl0sdGhpcy5fbW9kZWwub3BzZXRzLGUpfX19LDkyNDA6ZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuVGVuc29yPXZvaWQgMDtjb25zdCBvPW4oMzQ0MiksaT1yKG4oMzcyMCkpLGE9bigxNDQ2KSxzPW4oMTI4NyksdT1uKDcyNzMpO3ZhciBsPXMub25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicztjbGFzcyBje2dldCBkYXRhKCl7aWYodm9pZCAwPT09dGhpcy5jYWNoZSl7Y29uc3QgZT10aGlzLmRhdGFQcm92aWRlcih0aGlzLmRhdGFJZCk7aWYoZS5sZW5ndGghPT10aGlzLnNpemUpdGhyb3cgbmV3IEVycm9yKFwiTGVuZ3RoIG9mIGRhdGEgcHJvdmlkZWQgYnkgdGhlIERhdGEgUHJvdmlkZXIgaXMgaW5jb25zaXN0ZW50IHdpdGggdGhlIGRpbXMgb2YgdGhpcyBUZW5zb3IuXCIpO3RoaXMuY2FjaGU9ZX1yZXR1cm4gdGhpcy5jYWNoZX1nZXQgc3RyaW5nRGF0YSgpe2lmKFwic3RyaW5nXCIhPT10aGlzLnR5cGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcImRhdGEgdHlwZSBpcyBub3Qgc3RyaW5nXCIpO3JldHVybiB0aGlzLmRhdGF9Z2V0IGludGVnZXJEYXRhKCl7c3dpdGNoKHRoaXMudHlwZSl7Y2FzZVwidWludDhcIjpjYXNlXCJpbnQ4XCI6Y2FzZVwidWludDE2XCI6Y2FzZVwiaW50MTZcIjpjYXNlXCJpbnQzMlwiOmNhc2VcInVpbnQzMlwiOmNhc2VcImJvb2xcIjpyZXR1cm4gdGhpcy5kYXRhO2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihcImRhdGEgdHlwZSBpcyBub3QgaW50ZWdlciAodWludDgsIGludDgsIHVpbnQxNiwgaW50MTYsIGludDMyLCB1aW50MzIsIGJvb2wpXCIpfX1nZXQgZmxvYXREYXRhKCl7c3dpdGNoKHRoaXMudHlwZSl7Y2FzZVwiZmxvYXQzMlwiOmNhc2VcImZsb2F0NjRcIjpyZXR1cm4gdGhpcy5kYXRhO2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihcImRhdGEgdHlwZSBpcyBub3QgZmxvYXQgKGZsb2F0MzIsIGZsb2F0NjQpXCIpfX1nZXQgbnVtYmVyRGF0YSgpe2lmKFwic3RyaW5nXCIhPT10aGlzLnR5cGUpcmV0dXJuIHRoaXMuZGF0YTt0aHJvdyBuZXcgVHlwZUVycm9yKFwidHlwZSBjYW5ub3QgYmUgbm9uLW51bWJlciAoc3RyaW5nKVwiKX1nZXQoZSl7cmV0dXJuIHRoaXMuZGF0YVt1LlNoYXBlVXRpbC5pbmRpY2VzVG9PZmZzZXQoZSx0aGlzLnN0cmlkZXMpXX1zZXQoZSx0KXt0aGlzLmRhdGFbdS5TaGFwZVV0aWwuaW5kaWNlc1RvT2Zmc2V0KGUsdGhpcy5zdHJpZGVzKV09dH1hc3luYyBnZXREYXRhKCl7cmV0dXJuIHZvaWQgMD09PXRoaXMuY2FjaGUmJih0aGlzLmNhY2hlPWF3YWl0IHRoaXMuYXN5bmNEYXRhUHJvdmlkZXIodGhpcy5kYXRhSWQpKSx0aGlzLmNhY2hlfWdldCBzdHJpZGVzKCl7cmV0dXJuIHRoaXMuX3N0cmlkZXN8fCh0aGlzLl9zdHJpZGVzPXUuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHRoaXMuZGltcykpLHRoaXMuX3N0cmlkZXN9Y29uc3RydWN0b3IoZSx0LG4scixpLGE9by5HdWlkLmNyZWF0ZSgpKXt0aGlzLmRpbXM9ZSx0aGlzLnR5cGU9dCx0aGlzLmRhdGFQcm92aWRlcj1uLHRoaXMuYXN5bmNEYXRhUHJvdmlkZXI9cix0aGlzLmNhY2hlPWksdGhpcy5kYXRhSWQ9YSx0aGlzLnNpemU9dS5TaGFwZVV0aWwudmFsaWRhdGVEaW1zQW5kQ2FsY1NpemUoZSk7Y29uc3Qgcz10aGlzLnNpemUsbD12b2lkIDA9PT1uJiZ2b2lkIDA9PT1yJiZ2b2lkIDA9PT1pO2lmKHZvaWQgMCE9PWkmJmkubGVuZ3RoIT09cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklucHV0IGRpbXMgZG9lc24ndCBtYXRjaCBkYXRhIGxlbmd0aC5cIik7aWYoXCJzdHJpbmdcIj09PXQpe2lmKCEodm9pZCAwPT09aXx8QXJyYXkuaXNBcnJheShpKSYmaS5ldmVyeSgoZT0+XCJzdHJpbmdcIj09dHlwZW9mIGUpKSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhY2hlIHNob3VsZCBiZSBhIHN0cmluZyBhcnJheVwiKTtsJiYodGhpcy5jYWNoZT1uZXcgQXJyYXkocykpfWVsc2V7aWYodm9pZCAwIT09aSl7Y29uc3QgZT1kKHQpO2lmKCEoaSBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoYGNhY2hlIHNob3VsZCBiZSB0eXBlICR7ZS5uYW1lfWApfWlmKGwpe2NvbnN0IGU9bmV3IEFycmF5QnVmZmVyKHMqZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2VcImJvb2xcIjpjYXNlXCJpbnQ4XCI6Y2FzZVwidWludDhcIjpyZXR1cm4gMTtjYXNlXCJpbnQxNlwiOmNhc2VcInVpbnQxNlwiOnJldHVybiAyO2Nhc2VcImludDMyXCI6Y2FzZVwidWludDMyXCI6Y2FzZVwiZmxvYXQzMlwiOnJldHVybiA0O2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gODtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGNhbGN1bGF0ZSBzaXplb2YoKSBvbiB0eXBlICR7ZX1gKX19KHQpKTt0aGlzLmNhY2hlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyhkKHQpKShlKX0oZSx0KX19fXN0YXRpYyBmcm9tUHJvdG8oZSl7aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNvbnN0cnVjdCBWYWx1ZSBmcm9tIGFuIGVtcHR5IHRlbnNvclwiKTtjb25zdCB0PXUuUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGUuZGF0YVR5cGUpLG49dS5Qcm90b1V0aWwudGVuc29yRGltc0Zyb21Qcm90byhlLmRpbXMpLHI9bmV3IGMobix0KTtpZihcInN0cmluZ1wiPT09dCllLnN0cmluZ0RhdGEuZm9yRWFjaCgoKGUsdCk9PntyLmRhdGFbdF09KDAsdS5kZWNvZGVVdGY4U3RyaW5nKShlKX0pKTtlbHNlIGlmKGUucmF3RGF0YSYmXCJudW1iZXJcIj09dHlwZW9mIGUucmF3RGF0YS5ieXRlTGVuZ3RoJiZlLnJhd0RhdGEuYnl0ZUxlbmd0aD4wKXtjb25zdCB0PXIuZGF0YSxuPW5ldyBEYXRhVmlldyhlLnJhd0RhdGEuYnVmZmVyLGUucmF3RGF0YS5ieXRlT2Zmc2V0LGUucmF3RGF0YS5ieXRlTGVuZ3RoKSxvPXAoZS5kYXRhVHlwZSksaT1lLnJhd0RhdGEuYnl0ZUxlbmd0aC9vO2lmKGUucmF3RGF0YS5ieXRlTGVuZ3RoJW8hPTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBidWZmZXIgbGVuZ3RoXCIpO2lmKHQubGVuZ3RoIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJidWZmZXIgbGVuZ3RoIG1pc21hdGNoXCIpO2ZvcihsZXQgcj0wO3I8aTtyKyspe2NvbnN0IGk9aChuLGUuZGF0YVR5cGUscipvKTt0W3JdPWl9fWVsc2V7bGV0IHQ7c3dpdGNoKGUuZGF0YVR5cGUpe2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUOnQ9ZS5mbG9hdERhdGE7YnJlYWs7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDp0PWUuaW50MzJEYXRhO2JyZWFrO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0OnQ9ZS5pbnQ2NERhdGE7YnJlYWs7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOnQ9ZS5kb3VibGVEYXRhO2JyZWFrO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQ6dD1lLnVpbnQ2NERhdGE7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJ1bnNwZWNpZmljIGVycm9yXCIpfWlmKG51bGw9PXQpdGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIHRvIHBvcHVsYXRlIGRhdGEgZnJvbSBhIHRlbnNvcnByb3RvIHZhbHVlXCIpO2NvbnN0IG49ci5kYXRhO2lmKG4ubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgbGVuZ3RoIG1pc21hdGNoXCIpO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7cisrKXtjb25zdCBvPXRbcl07aS5kZWZhdWx0LmlzTG9uZyhvKT9uW3JdPWYobyxlLmRhdGFUeXBlKTpuW3JdPW99fXJldHVybiByfXN0YXRpYyBmcm9tRGF0YShlLHQsbil7cmV0dXJuIG5ldyBjKHQsbix2b2lkIDAsdm9pZCAwLGUpfXN0YXRpYyBmcm9tT3J0VGVuc29yKGUpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBjb25zdHJ1Y3QgVmFsdWUgZnJvbSBhbiBlbXB0eSB0ZW5zb3JcIik7Y29uc3QgdD11LlByb3RvVXRpbC50ZW5zb3JEaW1zRnJvbU9SVEZvcm1hdChlKSxuPXUuUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGUuZGF0YVR5cGUoKSkscj1uZXcgYyh0LG4pO2lmKFwic3RyaW5nXCI9PT1uKWZvcihsZXQgdD0wO3Q8ZS5zdHJpbmdEYXRhTGVuZ3RoKCk7dCsrKXIuZGF0YVt0XT1lLnN0cmluZ0RhdGEodCk7ZWxzZSBpZihlLnJhd0RhdGFBcnJheSgpJiZcIm51bWJlclwiPT10eXBlb2YgZS5yYXdEYXRhTGVuZ3RoKCkmJmUucmF3RGF0YUxlbmd0aCgpPjApe2NvbnN0IHQ9ci5kYXRhLG49bmV3IERhdGFWaWV3KGUucmF3RGF0YUFycmF5KCkuYnVmZmVyLGUucmF3RGF0YUFycmF5KCkuYnl0ZU9mZnNldCxlLnJhd0RhdGFMZW5ndGgoKSksbz1wKGUuZGF0YVR5cGUoKSksaT1lLnJhd0RhdGFMZW5ndGgoKS9vO2lmKGUucmF3RGF0YUxlbmd0aCgpJW8hPTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBidWZmZXIgbGVuZ3RoXCIpO2lmKHQubGVuZ3RoIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJidWZmZXIgbGVuZ3RoIG1pc21hdGNoXCIpO2ZvcihsZXQgcj0wO3I8aTtyKyspe2NvbnN0IGk9aChuLGUuZGF0YVR5cGUoKSxyKm8pO3Rbcl09aX19cmV0dXJuIHJ9fWZ1bmN0aW9uIHAoZSl7c3dpdGNoKGUpe2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDpyZXR1cm4gMTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6cmV0dXJuIDI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOnJldHVybiA0O2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0OmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQ6cmV0dXJuIDg7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBjYWxjdWxhdGUgc2l6ZW9mKCkgb24gdHlwZSAke2Eub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVtlXX1gKX19ZnVuY3Rpb24gZChlKXtzd2l0Y2goZSl7Y2FzZVwiYm9vbFwiOmNhc2VcInVpbnQ4XCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gSW50MTZBcnJheTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gSW50MzJBcnJheTtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gVWludDMyQXJyYXk7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiBGbG9hdDMyQXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJ1bnNwZWNpZmllZCBlcnJvclwiKX19ZnVuY3Rpb24gZihlLHQpe2lmKHQ9PT1hLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjR8fHQ9PT1sLlRlbnNvckRhdGFUeXBlLklOVDY0KXtpZihlLmdyZWF0ZXJUaGFuT3JFcXVhbCgyMTQ3NDgzNjQ4KXx8ZS5sZXNzVGhhbigtMjE0NzQ4MzY0OCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImludDY0IGlzIG5vdCBzdXBwb3J0ZWRcIil9ZWxzZXtpZih0IT09YS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMiYmdCE9PWwuVGVuc29yRGF0YVR5cGUuVUlOVDMyJiZ0IT09YS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NCYmdCE9PWwuVGVuc29yRGF0YVR5cGUuVUlOVDY0KXRocm93IG5ldyBUeXBlRXJyb3IoYG5vdCBhIExPTkcgdHlwZTogJHthLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVbdF19YCk7aWYoZS5ncmVhdGVyVGhhbk9yRXF1YWwoNDI5NDk2NzI5Nil8fGUubGVzc1RoYW4oMCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcInVpbnQ2NCBpcyBub3Qgc3VwcG9ydGVkXCIpfXJldHVybiBlLnRvTnVtYmVyKCl9ZnVuY3Rpb24gaChlLHQsbil7c3dpdGNoKHQpe2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6cmV0dXJuIGUuZ2V0VWludDgobik7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpyZXR1cm4gZS5nZXRJbnQ4KG4pO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpyZXR1cm4gZS5nZXRVaW50MTYobiwhMCk7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6cmV0dXJuIGUuZ2V0SW50MTYobiwhMCk7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6cmV0dXJuIGUuZ2V0RmxvYXQzMihuLCEwKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpyZXR1cm4gZS5nZXRJbnQzMihuLCEwKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6cmV0dXJuIGUuZ2V0VWludDMyKG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0OnJldHVybiBmKGkuZGVmYXVsdC5mcm9tQml0cyhlLmdldFVpbnQzMihuLCEwKSxlLmdldFVpbnQzMihuKzQsITApLCExKSx0KTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6cmV0dXJuIGUuZ2V0RmxvYXQ2NChuLCEwKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQ6cmV0dXJuIGYoaS5kZWZhdWx0LmZyb21CaXRzKGUuZ2V0VWludDMyKG4sITApLGUuZ2V0VWludDMyKG4rNCwhMCksITApLHQpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVhZCBmcm9tIERhdGFWaWV3IGZvciB0eXBlICR7YS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3RdfWApfX10LlRlbnNvcj1jfSw3MjczOmZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlY29kZVV0ZjhTdHJpbmc9dC5NQVhfQ0xJUD10Lk1JTl9DTElQPXQuUG9vbENvbnZVdGlsPXQuUmVkdWNlVXRpbD10LlNwbGl0VXRpbD10Lk1hdGhVdGlsPXQuU2hhcGVVdGlsPXQuTG9uZ1V0aWw9dC5Qcm90b1V0aWw9dC5HZW1tVXRpbD10LmFycmF5Q29weUhlbHBlcj10LkJyb2FkY2FzdFV0aWw9dC5NYXRNdWxVdGlsPXQuQXJyYXlVdGlsPXQuYXNzZXJ0PXQuY2hlY2tJbnB1dHNTaGFwZT12b2lkIDA7Y29uc3Qgbz1uKDU2ODYpLGk9cihuKDM3MjApKSxhPW4oMTQ0Nikscz1uKDkyNDApO3QuY2hlY2tJbnB1dHNTaGFwZT1mdW5jdGlvbihlLC4uLnQpe2lmKCFlfHxlLmxlbmd0aCE9PXQubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWlmKCFlW25dLmRpbXN8fGVbbl0uZGltcy5sZW5ndGghPT10W25dKXJldHVybiExO3JldHVybiEwfSx0LmFzc2VydD1mdW5jdGlvbihlLHQpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcInN0cmluZ1wiPT10eXBlb2YgdD90OnQoKSl9LHQuQXJyYXlVdGlsPWNsYXNze3N0YXRpYyBhcnJheXNFcXVhbChlLHQpe2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspaWYoZVtuXSE9PXRbbl0pcmV0dXJuITE7cmV0dXJuITB9fTtjbGFzcyB1e3N0YXRpYyBwcmVwcm9jZXNzSW5wdXRTaGFwZXMoZSx0KXtyZXR1cm5bMT09PWUubGVuZ3RoP1sxLGVbMF1dOmUsMT09PXQubGVuZ3RoP1t0WzBdLDFdOnRdfXN0YXRpYyBwb3N0cHJvY2Vzc091dHB1dFNoYXBlKGUsdCxuKXsxPT09dCYmZS5zcGxpY2UoZS5sZW5ndGgtMiwxKSwxPT09biYmZS5wb3AoKX1zdGF0aWMgY2FsY01hdE11bFNoYXBlKGUsdCl7cmV0dXJuIGVbMV0hPT10WzBdP3ZvaWQgMDpbZVswXSx0WzFdXX19dC5NYXRNdWxVdGlsPXU7Y2xhc3MgbHtzdGF0aWMgY2FsY1NoYXBlKGUsdCxuPSExKXtjb25zdCByPWUubGVuZ3RoLG89dC5sZW5ndGg7aWYoMD09PXIpcmV0dXJuIHQ7aWYoMD09PW8pcmV0dXJuIGU7Y29uc3QgaT1NYXRoLm1heChlLmxlbmd0aCx0Lmxlbmd0aCksYT1uZXcgQXJyYXkoaSk7aWYobil7aWYocjwyfHxvPDIpcmV0dXJuO2NvbnN0IG49dS5jYWxjTWF0TXVsU2hhcGUoW2Vbci0yXSxlW3ItMV1dLFt0W28tMl0sdFtvLTFdXSk7aWYodm9pZCAwPT09bilyZXR1cm47W2FbaS0yXSxhW2ktMV1dPW59Zm9yKGxldCBzPW4/MzoxO3M8PWk7cysrKXtjb25zdCBuPXItczwwPzE6ZVtyLXNdLHU9by1zPDA/MTp0W28tc107aWYobiE9PXUmJm4+MSYmdT4xKXJldHVybjthW2ktc109TWF0aC5tYXgobix1KX1yZXR1cm4gYX1zdGF0aWMgaW5kZXgoZSx0KXtjb25zdCBuPW5ldyBBcnJheSh0Lmxlbmd0aCk7cmV0dXJuIGwuZmlsbEluZGV4KGUsdCxuKSxufXN0YXRpYyBmaWxsSW5kZXgoZSx0LG4pe2NvbnN0IHI9ZS5sZW5ndGgtdC5sZW5ndGg7Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aDtvKyspbltvXT1lW3Irb10ldFtvXX1zdGF0aWMgY2FsYyhlLHQsbixyLG8pe2NvbnN0IGk9bC5jYWxjU2hhcGUoZS5kaW1zLHQuZGltcyk7aWYoaSl7aWYociYmIWQuYXJlRXF1YWwoaSxlLmRpbXMpKXJldHVybjtjb25zdCBhPWQuc2l6ZShpKSx1PXI/ZTpuZXcgcy5UZW5zb3IoaSxvfHxlLnR5cGUpO2lmKDA9PT1pLmxlbmd0aCl1LnNldChbXSxuKGUuZ2V0KFtdKSx0LmdldChbXSkpKTtlbHNle2NvbnN0IHI9bmV3IEFycmF5KGkubGVuZ3RoKSxvPW5ldyBBcnJheShlLmRpbXMubGVuZ3RoKSxzPW5ldyBBcnJheSh0LmRpbXMubGVuZ3RoKTtsZXQgYyxwPTAsZD0wLGY9ITEsaD0hMTswPT09ZS5kaW1zLmxlbmd0aCYmKHA9ZS5nZXQoW10pLGY9ITApLDA9PT10LmRpbXMubGVuZ3RoJiYoZD10LmdldChbXSksaD0hMCk7Zm9yKGxldCBnPTA7ZzxhO2crKyl7Yz1nO2ZvcihsZXQgZT1pLmxlbmd0aC0xO2U+PTA7ZS0tKXJbZV09YyVpW2VdLGM9TWF0aC5mbG9vcihjL2lbZV0pO2Z8fChsLmZpbGxJbmRleChyLGUuZGltcyxvKSxwPWUuZ2V0KG8pKSxofHwobC5maWxsSW5kZXgocix0LmRpbXMscyksZD10LmdldChzKSksdS5zZXQocixuKHAsZCkpfX1yZXR1cm4gdX19c3RhdGljIGlzVmFsaWRCcm9hZGNhc3QoZSx0KXtjb25zdCBuPWUubGVuZ3RoLHI9dC5sZW5ndGg7aWYobj5yKXJldHVybiExO2ZvcihsZXQgbz0xO288PW47bysrKWlmKDEhPT1lW24tb10mJmVbbi1vXSE9PXRbci1vXSlyZXR1cm4hMTtyZXR1cm4hMH1zdGF0aWMgZ2V0QnJvYWRjYXN0RGltcyhlLHQpe2NvbnN0IG49ZS5sZW5ndGgscj1bXTtmb3IobGV0IG89MDtvPG47bysrKXtjb25zdCBpPW4tMS1vLGE9ZVtpXXx8MTsodFt0Lmxlbmd0aC0xLW9dfHwxKT4xJiYxPT09YSYmci51bnNoaWZ0KGkpfXJldHVybiByfX10LkJyb2FkY2FzdFV0aWw9bCx0LmFycmF5Q29weUhlbHBlcj1mdW5jdGlvbihlLHQsbixyLG8pe2lmKHI8MHx8cj49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IG91dCBvZiBib3VuZHNcIik7aWYocitvPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHNcIik7aWYobitvPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHRcIik7Zm9yKGxldCBpPTA7aTxvO2krKyllW24raV09dFtyK2ldfSx0LkdlbW1VdGlsPWNsYXNze3N0YXRpYyBnZXRTaGFwZU9mR2VtbVJlc3VsdChlLHQsbixyLG8pe2lmKDIhPT1lLmxlbmd0aHx8MiE9PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNoYXBlIG5lZWQgdG8gYmUgb2Ygc2l6ZSAyXCIpO2xldCBpLGEsczt0PyhpPWVbMV0sYT1lWzBdKTooaT1lWzBdLGE9ZVsxXSk7bGV0IHU9LTE7aWYocj8ocz1uWzBdLHU9MSk6KHM9blsxXSx1PTApLG5bdV0hPT1hKXRocm93IG5ldyBFcnJvcihcImRpbWVuc2lvbiBtaXNtYXRjaFwiKTtpZihpPD0wfHxzPD0wfHxhPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2hhcGUgc3BlY2lmaWVkXCIpO2lmKG8mJiFsLmlzVmFsaWRCcm9hZGNhc3QobyxbaSxzXSkpdGhyb3cgbmV3IEVycm9yKFwiZ2VtbTogaW52YWxpZCBiaWFzIHNoYXBlIGZvciBicm9hZGNhc3RcIik7cmV0dXJuW2kscyxhXX19O2NsYXNzIGN7c3RhdGljIHRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGUpe3N3aXRjaChlKXtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OnJldHVyblwiaW50OFwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OnJldHVyblwidWludDhcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOnJldHVyblwiYm9vbFwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2OnJldHVyblwiaW50MTZcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6cmV0dXJuXCJ1aW50MTZcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpyZXR1cm5cImludDMyXCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOnJldHVyblwidWludDMyXCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6cmV0dXJuXCJmbG9hdDMyXCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOnJldHVyblwiZmxvYXQ2NFwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlNUUklORzpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0OnJldHVyblwiaW50MzJcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQ6cmV0dXJuXCJ1aW50MzJcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2Eub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVtlXX1gKX19c3RhdGljIHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKGUpe3N3aXRjaChlKXtjYXNlXCJpbnQ4XCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4O2Nhc2VcInVpbnQ4XCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODtjYXNlXCJib29sXCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MO2Nhc2VcImludDE2XCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjtjYXNlXCJpbnQzMlwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI7Y2FzZVwidWludDMyXCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFO2Nhc2VcInN0cmluZ1wiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuU1RSSU5HO2Nhc2VcImludDY0XCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDtjYXNlXCJ1aW50NjRcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fXN0YXRpYyB0ZW5zb3JEaW1zRnJvbVByb3RvKGUpe3JldHVybiBlLm1hcCgoZT0+aS5kZWZhdWx0LmlzTG9uZyhlKT9lLnRvTnVtYmVyKCk6ZSkpfXN0YXRpYyB0ZW5zb3JWYWx1ZVR5cGVGcm9tUHJvdG8oZSl7cmV0dXJue3RlbnNvclR5cGU6Yy50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhlLmVsZW1UeXBlKSxzaGFwZTp7ZGltczpjLnRlbnNvckRpbXNGcm9tUHJvdG8oZS5zaGFwZS5kaW0ubWFwKChlPT5lLmRpbVZhbHVlKSkpfX19c3RhdGljIHRlbnNvckRpbXNGcm9tT1JURm9ybWF0KGUpe2NvbnN0IHQ9W107Zm9yKGxldCBuPTA7bjxlLmRpbXNMZW5ndGgoKTtuKyspdC5wdXNoKHAubG9uZ1RvTnVtYmVyKGUuZGltcyhuKSkpO3JldHVybiB0fXN0YXRpYyB0ZW5zb3JBdHRyaWJ1dGVzRnJvbU9SVEZvcm1hdChlKXtjb25zdCB0PVtdO2ZvcihsZXQgbj0wO248ZS5hdHRyaWJ1dGVzTGVuZ3RoKCk7bisrKXQucHVzaChlLmF0dHJpYnV0ZXMobikpO3JldHVybiB0fX10LlByb3RvVXRpbD1jO2NsYXNzIHB7c3RhdGljIGxvbmdUb051bWJlcihlLHQpe3JldHVybiBpLmRlZmF1bHQuaXNMb25nKGUpP2UudG9OdW1iZXIoKTplIGluc3RhbmNlb2Ygby5mbGF0YnVmZmVycy5Mb25nP2kuZGVmYXVsdC5mcm9tVmFsdWUoe2xvdzplLmxvdyxoaWdoOmUuaGlnaCx1bnNpZ25lZDpudWxsIT10JiZ0fSkudG9OdW1iZXIoKTplfXN0YXRpYyBpc0xvbmcoZSl7cmV0dXJuIGkuZGVmYXVsdC5pc0xvbmcoZSl8fGUgaW5zdGFuY2VvZiBvLmZsYXRidWZmZXJzLkxvbmd9fXQuTG9uZ1V0aWw9cDtjbGFzcyBke3N0YXRpYyBzaXplKGUpe3JldHVybiBkLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZSwwLGUubGVuZ3RoKX1zdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24oZSx0KXtpZih0PDB8fHQ+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke3R9IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7ZS5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGQuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShlLHQsZS5sZW5ndGgpfXN0YXRpYyBzaXplVG9EaW1lbnNpb24oZSx0KXtpZih0PDB8fHQ+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke3R9IGZvciBzaXplVG9EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke2UubGVuZ3RofSBkaW1lbnNpb25zLmApO3JldHVybiBkLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZSwwLHQpfXN0YXRpYyBnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGUsdCxuKXtsZXQgcj0xO2ZvcihsZXQgbz10O288bjtvKyspe2lmKGVbb108PTApdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGdldCB2YWxpZCBzaXplIGZyb20gc3BlY2lmaWVkIGRpbWVuc2lvbiByYW5nZS4gTW9zdCBsaWtlbHkgdGhlIHJhbmdlIGNvbnRhaW5zIDAgb3IgbmVnYXRpdmUgdmFsdWVzIGluIHRoZW0uXCIpO3IqPWVbb119cmV0dXJuIHJ9c3RhdGljIGNvbXB1dGVTdHJpZGVzKGUpe2NvbnN0IHQ9ZS5sZW5ndGg7aWYoMD09PXQpcmV0dXJuW107aWYoMT09PXQpcmV0dXJuWzFdO2NvbnN0IG49bmV3IEFycmF5KHQpO25bdC0xXT0xLG5bdC0yXT1lW3QtMV07Zm9yKGxldCByPXQtMztyPj0wOy0tciluW3JdPW5bcisxXSplW3IrMV07cmV0dXJuIG59c3RhdGljIHRyYW5zcG9zZShlKXtyZXR1cm4gZS5zbGljZSgpLnJldmVyc2UoKX1zdGF0aWMgaW5kaWNlc1RvT2Zmc2V0KGUsdCxuKXt2b2lkIDA9PT1uJiYobj1lLmxlbmd0aCk7bGV0IHI9MDtmb3IobGV0IG89MDtvPG47KytvKXIrPXRbb10qZVtvXTtyZXR1cm4gcn1zdGF0aWMgb2Zmc2V0VG9JbmRpY2VzKGUsdCl7Y29uc3Qgbj10Lmxlbmd0aDtpZigwPT09bilyZXR1cm5bXTtpZigxPT09bilyZXR1cm5bZSp0WzBdXTtjb25zdCByPW5ldyBBcnJheSh0Lmxlbmd0aCk7Zm9yKGxldCBuPTA7bjxyLmxlbmd0aC0xOysrbilyW25dPU1hdGguZmxvb3IoZS90W25dKSxlLT1yW25dKnRbbl07cmV0dXJuIHJbci5sZW5ndGgtMV09ZSxyfXN0YXRpYyBub3JtYWxpemVBeGlzKGUsdCl7aWYoZTwtdCYmZT49dCl0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBheGlzIGZvciB0aGlzIG9wZXJhdGlvbi5cIik7cmV0dXJuIGU8MD9lK3Q6ZX1zdGF0aWMgbm9ybWFsaXplQXhlcyhlLHQpe3JldHVybiBlLm1hcCgoZT0+dGhpcy5ub3JtYWxpemVBeGlzKGUsdCkpKX1zdGF0aWMgaW5jcmVtZW50SW5kZXgoZSx0LG4pe2lmKDA9PT10Lmxlbmd0aHx8MD09PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkluZGV4IGluY3JlbWVudGluZyB1bnN1cHBvcnRlZCBmb3Igc2NhbGFyIFRlbnNvclwiKTtpZih2b2lkIDA9PT1uKW49dC5sZW5ndGg7ZWxzZSBpZihuPD0wfHxuPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCBheGlzIHRvIGluY3JlbWVudCBvblwiKTtmb3IobGV0IHI9bi0xO3I+PTAmJihlW3JdKyssIShlW3JdPHRbcl0pKTstLXIpZVtyXT0wfXN0YXRpYyBjYWxjdWxhdGVSZXNoYXBlZERpbXMoZSx0KXtpZigwPT09dC5sZW5ndGgpe2lmKDA9PT1lLmxlbmd0aHx8MT09PWQuc2l6ZShlKSlyZXR1cm5bXTt0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgcmVzaGFwZSB0byBhIHNjYWxhciBUZW5zb3JcIil9Y29uc3Qgbj10Lmxlbmd0aCxyPW5ldyBBcnJheShuKTtsZXQgbz0tMSxpPTE7Zm9yKGxldCBhPTA7YTxuO2ErKyl7aWYodFthXTwtMSl0aHJvdyBuZXcgRXJyb3IoXCJhIGRpbWVuc2lvbiBpbiBzaGFwZSBoaW50cyBjYW5ub3QgYmUgbGVzcyB0aGFuIC0xXCIpO2lmKC0xPT09dFthXSl7aWYoLTEhPT1vKXRocm93IG5ldyBFcnJvcihcImF0IG1vc3Qgb25lIGRpbWVuc2lvbiBpbiBzaGFwZSBoaW50cyBjYW4gYmUgLTFcIik7bz1hfWVsc2V7aWYoMD09PXRbYV0pe2lmKGE+PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRoZSBkaW1lbnNpb24gd2l0aCB2YWx1ZSB6ZXJvIGV4Y2VlZHMgdGhlIGRpbWVuc2lvbiBzaXplIG9mIHRoZSBpbnB1dCB0ZW5zb3JcIik7clthXT1lW2FdfWVsc2UgclthXT10W2FdO2kqPXJbYV19fWNvbnN0IGE9ZC5zaXplKGUpO2lmKC0xIT09byl7aWYoYSVpIT0wKXRocm93IG5ldyBFcnJvcihgdGhlIGlucHV0IHRlbnNvciBjYW5ub3QgYmUgcmVzaGFwZWQgdG8gdGhlIHJlcXVlc3RlZCBzaGFwZS4gSW5wdXQgc2hhcGU6IFske2V9XSBPdXRwdXQgc2hhcGU6IFske3R9XWApO3Jbb109YS9pfWVsc2UgaWYoaSE9PWEpdGhyb3cgbmV3IEVycm9yKFwicmVzaGFwZWREaW1zIGFuZCBvcmlnaW5hbERpbXMgZG9uJ3QgaGF2ZSBtYXRjaGluZyBzaXplc1wiKTtyZXR1cm4gcn1zdGF0aWMgc29ydEJhc2VkT25QZXJtKGUsdCl7cmV0dXJuIHQ/dC5tYXAoKHQ9PmVbdF0pKTplLnNsaWNlKCkucmV2ZXJzZSgpfXN0YXRpYyBwYWRTaGFwZShlLHQpe2NvbnN0IG49ZS5sZW5ndGg7cmV0dXJuIGUubWFwKCgoZSxyKT0+ZSt0W3JdK3RbcituXSkpfXN0YXRpYyBhcmVFcXVhbChlLHQpe3JldHVybiBlLmxlbmd0aD09PXQubGVuZ3RoJiZlLmV2ZXJ5KCgoZSxuKT0+ZT09PXRbbl0pKX1zdGF0aWMgdmFsaWRhdGVEaW1zQW5kQ2FsY1NpemUoZSl7aWYoZS5sZW5ndGg+Nil0aHJvdyBuZXcgVHlwZUVycm9yKFwiT25seSByYW5rIDAgdG8gNiBpcyBzdXBwb3J0ZWQgZm9yIHRlbnNvciBzaGFwZS5cIik7bGV0IHQ9MTtmb3IoY29uc3QgbiBvZiBlKXtpZighTnVtYmVyLmlzSW50ZWdlcihuKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNoYXBlOiAke259IGlzIG5vdCBhbiBpbnRlZ2VyYCk7aWYobjwwfHxuPjIxNDc0ODM2NDcpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBzaGFwZTogbGVuZ3RoICR7bn0gaXMgbm90IGFsbG93ZWRgKTt0Kj1ufXJldHVybiB0fXN0YXRpYyBmbGF0dGVuU2hhcGUoZSx0KXt0PDAmJih0Kz1lLmxlbmd0aCk7Y29uc3Qgbj1lLnJlZHVjZSgoKGUsdCk9PmUqdCksMSkscj1lLnNsaWNlKHQpLnJlZHVjZSgoKGUsdCk9PmUqdCksMSk7cmV0dXJuW24vcixyXX1zdGF0aWMgc3F1ZWV6ZVNoYXBlKGUsdCl7Y29uc3Qgbj1uZXcgQXJyYXk7dD1kLm5vcm1hbGl6ZUF4ZXModCxlLmxlbmd0aCk7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2NvbnN0IG89dC5pbmRleE9mKHIpPj0wO2lmKG8mJjEhPT1lW3JdKXRocm93IG5ldyBFcnJvcihcInNxdWVlemUgYW4gYXhpcyBvZiBzaXplIGRpZmZlcmVudCB0aGFuIDFcIik7KDA9PT10Lmxlbmd0aCYmZVtyXT4xfHx0Lmxlbmd0aD4wJiYhbykmJm4ucHVzaChlW3JdKX1yZXR1cm4gbn1zdGF0aWMgdW5zcXVlZXplU2hhcGUoZSx0KXtjb25zdCBuPW5ldyBBcnJheShlLmxlbmd0aCt0Lmxlbmd0aCk7bi5maWxsKDApO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCByPWQubm9ybWFsaXplQXhpcyh0W2VdLG4ubGVuZ3RoKTtpZihyPj1uLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCInYXhlcycgaGFzIGFuIG91dCBvZiByYW5nZSBheGlzXCIpO2lmKDAhPT1uW3JdKXRocm93IG5ldyBFcnJvcihcIidheGVzJyBoYXMgYSBkdXBsaWNhdGUgYXhpc1wiKTtuW3JdPTF9bGV0IHI9MDtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKykwPT09blt0XSYmKG5bdF09ZVtyKytdKTtpZihyIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGhlIHVuc3F1ZWV6ZWQgZGltZW5zaW9uIGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZFwiKTtyZXR1cm4gbn19dC5TaGFwZVV0aWw9ZCx0Lk1hdGhVdGlsPWNsYXNze3N0YXRpYyBzcXIoZSx0LG4scixvKXtpZihyPDB8fHI+PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZUluZGV4IG91dCBvZiBib3VuZHNcIik7aWYobjwwfHxuPj1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKHIrbz50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzXCIpO2lmKG4rbz5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0XCIpO2ZvcihsZXQgaT0wO2k8bztpKyspZVtuK2ldKz1NYXRoLnBvdyh0W3IraV0sMil9c3RhdGljIGF4cHkoZSx0LG4scixvLGkpe2lmKHI8MHx8cj49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IG91dCBvZiBib3VuZHNcIik7aWYocitvPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHNcIik7aWYobitvPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHRcIik7Zm9yKGxldCBhPTA7YTxvO2ErKyllW24rYV0rPWkqdFtyK2FdfXN0YXRpYyBwb3d4KGUsdCxuLHIsbyxpKXtpZihyPDB8fHI+PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZUluZGV4IG91dCBvZiBib3VuZHNcIik7aWYobjwwfHxuPj1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKHIrbz50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzXCIpO2lmKG4rbz5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0XCIpO2ZvcihsZXQgYT0wO2E8bzthKyspZVtuK2FdPU1hdGgucG93KHRbcithXSxpKX1zdGF0aWMgbXVsKGUsdCxuLHIsbyl7aWYocjwwfHxyPj10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MHx8bj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihyK28+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kc1wiKTtpZihuK28+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdFwiKTtmb3IobGV0IGk9MDtpPG87aSsrKWVbbitpXT10W3IraV0qZVtuK2ldfX07Y2xhc3MgZntzdGF0aWMgc3BsaXRTaGFwZShlLHQsbixyKXtpZigwPT09bi5sZW5ndGgpe2lmKCFyKXRocm93IG5ldyBFcnJvcihcIm5lZWQgdG8ga25vdyBudW1iZXIgb2Ygb3V0cHV0cyB3aGVuIHRoZSAnc3BsaXQnIGF0dHJpYnV0ZSBpcyBub3Qgc3BlY2lmaWVkXCIpO2YuZGV0ZXJtaW5lU3BsaXQoZVt0XSxyLG4pfWNvbnN0IG89W10saT1bMF07Zm9yKGxldCByPTA7cjxuLmxlbmd0aDsrK3IpezAhPT1yJiZpLnB1c2goaVtyLTFdK25bci0xXSk7Y29uc3QgYT1lLnNsaWNlKCk7YVt0XT1uW3JdLG8ucHVzaChhKX1yZXR1cm5bbyxpXX1zdGF0aWMgZGV0ZXJtaW5lU3BsaXQoZSx0LG4pe2lmKGUldCE9MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3Qgc3BsaXQgdGVuc29yIHRvIGVxdWFsIHNpemVkIHBhcnRzXCIpO2ZvcihsZXQgcj0wO3I8dDsrK3Ipbi5wdXNoKGUvdCl9fXQuU3BsaXRVdGlsPWY7Y2xhc3MgaHtzdGF0aWMgY2FsY1JlZHVjZShlLHQsbixyLG8pe2NvbnN0IGk9ZS5kaW1zLnNsaWNlKDApOzA9PT10Lmxlbmd0aCYmaS5mb3JFYWNoKCgoZSxuKT0+dC5wdXNoKG4pKSk7Y29uc3QgYT1oLmNhbGNSZWR1Y2VTaGFwZShpLHQsITApLHU9ZC5zaXplKGEpLGM9bmV3IHMuVGVuc29yKGEsZS50eXBlKSxwPWQuY29tcHV0ZVN0cmlkZXMoYSksZj1kLmNvbXB1dGVTdHJpZGVzKGkpLGc9bmV3IEFycmF5KGkubGVuZ3RoKTtmb3IobGV0IG49MDtuPHU7bisrKXtjb25zdCBhPWQub2Zmc2V0VG9JbmRpY2VzKG4scCk7bC5maWxsSW5kZXgoYSxpLGcpLGMuc2V0KGEsaC5jYWxjUmVkdWNlQnlBeGlzKGUubnVtYmVyRGF0YSx0LGksMCxkLmluZGljZXNUb09mZnNldChnLGYpLHIsbykpfXJldHVybiBuP2M6bmV3IHMuVGVuc29yKGguY2FsY1JlZHVjZVNoYXBlKGksdCxuKSxjLnR5cGUsdm9pZCAwLHZvaWQgMCxjLmRhdGEsYy5kYXRhSWQpfXN0YXRpYyBjYWxjUmVkdWNlQnlBeGlzKGUsdCxuLHIsbyxpLGEpe2xldCBzPTA7aWYocj49dC5sZW5ndGgpcmV0dXJuIGkoZVtvXSk7Y29uc3QgdT10W3JdLGw9dT49bi5sZW5ndGg/MTpkLnNpemUobi5zbGljZSh1KzEpKTtmb3IobGV0IGM9MDtjPG5bdV07YysrKXM9MD09PWM/aC5jYWxjUmVkdWNlQnlBeGlzKGUsdCxuLHIrMSxvLGksYSk6YShzLGguY2FsY1JlZHVjZUJ5QXhpcyhlLHQsbixyKzEsbyxpLGEpKSxvKz1sO3JldHVybiBzfXN0YXRpYyBjYWxjUmVkdWNlU2hhcGUoZSx0LG4pe2NvbnN0IHI9ZS5zbGljZSgpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXJbdFtlXV09bj8xOjA7cmV0dXJuIHIuZmlsdGVyKChlPT4wIT09ZSkpfX10LlJlZHVjZVV0aWw9aDtjbGFzcyBne3N0YXRpYyBhZGp1c3RQb29sQXR0cmlidXRlcyhlLHQsbixyLG8saSl7aWYoIWUmJm4ubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3BlY2lmaWVkIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIDIgbGVzcyB0aGFuIGxlbmd0aCBvZiBpbnB1dCBkaW1lbnNpb25zXCIpO2lmKGUpZm9yKGxldCBlPTA7ZTx0Lmxlbmd0aC0yO2UrKyllPj1uLmxlbmd0aD9uLnB1c2godFtlKzJdKTpuW2VdPXRbZSsyXTtmb3IobGV0IGU9MDtlPG4ubGVuZ3RoO2UrKylpZihlPHIubGVuZ3RoKXtpZihyW2VdPDApdGhyb3cgbmV3IEVycm9yKFwic3RyaWRlcyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSByLnB1c2goMSk7Zm9yKGxldCBlPTA7ZTxuLmxlbmd0aDtlKyspaWYoZTxvLmxlbmd0aCl7aWYob1tlXTwwKXRocm93IG5ldyBFcnJvcihcImRpbGF0aW9ucyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBvLnB1c2goMSk7Zm9yKGxldCBlPTA7ZTwyKm4ubGVuZ3RoO2UrKylpZihlPGkubGVuZ3RoKXtpZihpW2VdPDApdGhyb3cgbmV3IEVycm9yKFwicGFkIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIGkucHVzaCgwKTtmb3IobGV0IGU9MDtlPG4ubGVuZ3RoO2UrKyl7aWYobltlXTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJrZXJuZWwgc2hhcGVzIG5lZWQgdG8gYmUgZ3JlYXRlciB0aGFuIDBcIik7aWYoaVtlXT49bltlXXx8aVtlK24ubGVuZ3RoXT49bltlXSl0aHJvdyBuZXcgRXJyb3IoXCJwYWRzIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4ga2VybmVsXCIpfX1zdGF0aWMgYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKGUsdCxuLHIsbyxpKXtpZihpKXtpZihvLmxlbmd0aCE9PTIqKGUubGVuZ3RoLTIpKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBwYWRzIHNob3VsZCBiZSB0d2ljZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHN0cmlkZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKHIubGVuZ3RoIT09ZS5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Yga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7Zm9yKGxldCBhPTA7YTxlLmxlbmd0aC0yO2ErKylnLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKGVbYSsyXSx0W2FdLG5bYV0sclthXSxvLGEsYStlLmxlbmd0aC0yLGkpfX1zdGF0aWMgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShlLHQsbixyLG8saSxhKXtpZih0Lmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaGFwZSBtdXN0IGJlIG9mIHNpemUgZ3JlYXRlciB0aGFuIDBcIik7Y29uc3Qgcz1bdFswXSx0WzFdXTtyZXR1cm4gZy5jb21wdXRlU2hhcGVIZWxwZXIoZSx0LHMsbixyLG8saSxhKSxzfXN0YXRpYyBjb21wdXRlQ29udk91dHB1dFNoYXBlKGUsdCxuLHIsbyxpLGEpe2lmKGUubGVuZ3RoPD0wfHx0Lmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHRlbnNvciBkaW1zIG9yIGludmFsaWQgZmlsdGVyIHRlbnNvciBkaW1zXCIpO2NvbnN0IHM9W2VbMF0sdFswXV07cmV0dXJuIGcuY29tcHV0ZVNoYXBlSGVscGVyKCExLGUscyxuLHIsbyxpLGEpLHN9c3RhdGljIGNvbXB1dGVTaGFwZUhlbHBlcihlLHQsbixyLG8saSxhLHMpe2lmKGUpZm9yKGxldCBlPTA7ZTx0Lmxlbmd0aC0yO2UrKyluLnB1c2goMSk7ZWxzZSBmb3IobGV0IGU9MDtlPHQubGVuZ3RoLTI7ZSsrKW4ucHVzaChnLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKHRbZSsyXSxyW2VdLG9bZV0saVtlXSxhLGUsZSt0Lmxlbmd0aC0yLHMpKX1zdGF0aWMgYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoZSx0LG4scixvLGksYSxzKXtjb25zdCB1PW4qKHItMSkrMTtpZighc3x8XCJOT1RTRVRcIj09PXMpcmV0dXJuIE1hdGguZmxvb3IoKGUrb1tpXStvW2FdLXUpL3QrMSk7c3dpdGNoKHMpe2Nhc2VcIlZBTElEXCI6cmV0dXJuIG9baV09MCxvW2FdPTAsTWF0aC5mbG9vcigoZS11KS90KzEpO2Nhc2VcIlNBTUVfTE9XRVJcIjpjYXNlXCJTQU1FX1VQUEVSXCI6aWYoMSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiRGlsYXRpb24gbm90IHN1cHBvcnRlZCBmb3IgU0FNRV9VUFBFUiBvciBTQU1FX0xPV0VSXCIpO3tjb25zdCBuPSgoZSt0LTEpL3QtMSkqdCtyLWU7cmV0dXJuIG9baV09XCJTQU1FX0xPV0VSXCI9PT1zP01hdGguZmxvb3IoKG4rMSkvMik6TWF0aC5mbG9vcihuLzIpLG9bYV09bi1vW2ldLE1hdGguZmxvb3IoKGUrbi1yKS90KzEpfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlXCIpfX19dC5Qb29sQ29udlV0aWw9Zyx0Lk1JTl9DTElQPS0zNDAyODIzNDY2Mzg1Mjg4NmUyMix0Lk1BWF9DTElQPTM0MDI4MjM0NjYzODUyODg2ZTIyLHQuZGVjb2RlVXRmOFN0cmluZz1mdW5jdGlvbihlKXtyZXR1cm4obmV3IFRleHREZWNvZGVyKS5kZWNvZGUoZSl9fSwzODM4OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LldlYkdwdUJhY2tlbmQ9dm9pZCAwO2NvbnN0IHI9big4NDUzKSxvPW4oNDk1NSksaT1uKDc3NzEpLGE9big4NTEwKSxzPW4oODMwNSk7dC5XZWJHcHVCYWNrZW5kPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5jdXJyZW50S2VybmVsSWQ9bnVsbCx0aGlzLmNvbW1hbmRFbmNvZGVyPW51bGwsdGhpcy5jb21wdXRlUGFzc0VuY29kZXI9bnVsbCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj0wLHRoaXMucHJvZmlsaW5nRW5hYmxlZD0hMX1nZXQgY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKXtpZihudWxsPT09dGhpcy5jdXJyZW50S2VybmVsSWQpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKTogY3VycmVudEtlcm5lbElkIGlzIG51bGwuIChzaG91bGQgbm90IGhhcHBlbilcIik7bGV0IGU9dGhpcy5rZXJuZWxDdXN0b21EYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7cmV0dXJuIGV8fChlPXt9LHRoaXMua2VybmVsQ3VzdG9tRGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQsZSkpLGV9YXN5bmMgaW5pdGlhbGl6ZSgpe2lmKCFuYXZpZ2F0b3IuZ3B1KXRocm93IG5ldyBFcnJvcihcIldlYkdwdUJhY2tlbmQ6IFdlYkdQVSBpcyBub3QgYXZhaWxhYmxlLlwiKTtjb25zdCBlPWF3YWl0IG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoKTtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHcHVCYWNrZW5kOiBGYWlsZWQgdG8gZ2V0IEdQVSBhZGFwdGVyLlwiKTtjb25zdCB0PXtyZXF1aXJlZExpbWl0czp7bWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplOmUubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZSxtYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjplLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbixtYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemU6ZS5saW1pdHMubWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplfX07ZS5mZWF0dXJlcy5oYXMoXCJ0aW1lc3RhbXAtcXVlcnktaW5zaWRlLXBhc3Nlc1wiKSYmXCJkZWZhdWx0XCI9PT1yLmVudi53ZWJncHUucHJvZmlsaW5nTW9kZSYmKHRoaXMucHJvZmlsaW5nRW5hYmxlZD0hMCx0LnJlcXVpcmVkRmVhdHVyZXM9W1widGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXNcIl0pLHRoaXMuZGV2aWNlPWF3YWl0IGUucmVxdWVzdERldmljZSh0KSx0aGlzLmdwdURhdGFNYW5hZ2VyPSgwLGkuY3JlYXRlR3B1RGF0YU1hbmFnZXIpKHRoaXMpLHRoaXMucHJvZ3JhbU1hbmFnZXI9bmV3IHMuUHJvZ3JhbU1hbmFnZXIodGhpcyksdGhpcy5rZXJuZWxzPW5ldyBNYXAsdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YT1uZXcgTWFwLHRoaXMua2VybmVsQ3VzdG9tRGF0YT1uZXcgTWFwLHRoaXMuZGV2aWNlLm9udW5jYXB0dXJlZGVycm9yPWU9PntlLmVycm9yIGluc3RhbmNlb2YgR1BVVmFsaWRhdGlvbkVycm9yJiZjb25zb2xlLmVycm9yKGBBbiB1bmNhdWdodCBXZWJHUFUgdmFsaWRhdGlvbiBlcnJvciB3YXMgcmFpc2VkOiAke2UuZXJyb3IubWVzc2FnZX1gKX0sdGhpcy5wcm9maWxpbmdFbmFibGVkJiYodGhpcy5wcm9maWxpbmdRdWVyeVNldD10aGlzLmRldmljZS5jcmVhdGVRdWVyeVNldCh7dHlwZTpcInRpbWVzdGFtcFwiLGNvdW50OjJ9KSl9ZGlzcG9zZSgpe31nZXRDb21tYW5kRW5jb2Rlcigpe3JldHVybiB0aGlzLmNvbW1hbmRFbmNvZGVyfHwodGhpcy5jb21tYW5kRW5jb2Rlcj10aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpKSx0aGlzLmNvbW1hbmRFbmNvZGVyfWdldENvbXB1dGVQYXNzRW5jb2Rlcigpe3JldHVybiB0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcnx8KHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPXRoaXMuZ2V0Q29tbWFuZEVuY29kZXIoKS5iZWdpbkNvbXB1dGVQYXNzKCkpLHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyfWVuZENvbXB1dGVQYXNzKCl7dGhpcy5jb21wdXRlUGFzc0VuY29kZXImJih0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlci5lbmQoKSx0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj1udWxsKX1mbHVzaCgpe3RoaXMuZW5kQ29tcHV0ZVBhc3MoKSx0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoW3RoaXMuZ2V0Q29tbWFuZEVuY29kZXIoKS5maW5pc2goKV0pLHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVmcmVzaFBlbmRpbmdCdWZmZXJzKCksdGhpcy5jb21tYW5kRW5jb2Rlcj1udWxsLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPTB9cnVuKGUsdCxuLHIsaSl7aWYodC5sZW5ndGghPT1lLmlucHV0VHlwZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgSW5wdXQgc2l6ZSBtdXN0IGJlIGVxdWFsIHRvICR7ZS5pbnB1dFR5cGVzLmxlbmd0aH0uYCk7Y29uc3QgYT1bXTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoOysrZSl7Y29uc3Qgbj10aGlzLmdwdURhdGFNYW5hZ2VyLmdldCh0W2VdLmRhdGEpO2lmKCFuKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGlucHV0OiAke3RbZV0uZGF0YX1gKTthW2VdPW59Y29uc3Qgcz0oKGUsdCxuKT0+e2NvbnN0IHI9dC5tYXAoKGU9PmAke2Uuam9pbihcIixcIil9YCkpLmpvaW4oXCJfXCIpLG89bi5qb2luKFwiX1wiKTtsZXQgaT1lLm5hbWU7cmV0dXJuIGUuY2FjaGVIaW50JiYoaSs9XCJbXCIrZS5jYWNoZUhpbnQrXCJdXCIpLGkrPVwiOlwiK3IrXCI7XCIrbyxpfSkoZSx0Lm1hcCgoZT0+ZS5kaW1zKSksYS5tYXAoKGU9PmUudHlwZSkpKTtsZXQgdT10aGlzLnByb2dyYW1NYW5hZ2VyLmdldEFydGlmYWN0KHMpO2NvbnN0IGw9dT91LnByb2dyYW1JbmZvOlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZ2V0P2UuZ2V0KCk6ZSxjPTA9PT1uLmxlbmd0aD9sLm91dHB1dHMubWFwKCgoZSx0KT0+dCkpOm47aWYoYy5sZW5ndGghPT1sLm91dHB1dHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgT3V0cHV0IHNpemUgJHtjLmxlbmd0aH0gbXVzdCBiZSBlcXVhbCB0byAke2wub3V0cHV0cy5sZW5ndGh9LmApO2NvbnN0IHA9W10sZD1bXTtmb3IobGV0IGU9MDtlPGwub3V0cHV0cy5sZW5ndGg7KytlKXtpZighTnVtYmVyLmlzSW50ZWdlcihjW2VdKXx8Y1tlXTwtMnx8Y1tlXT49bC5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb3V0cHV0IGluZGV4OiAke2NbZV19YCk7Y29uc3QgdD0tMT09PWNbZV0sbj0tMj09PWNbZV0sbz10fHxuP2kobC5vdXRwdXRzW2VdLmRhdGFUeXBlLGwub3V0cHV0c1tlXS5kaW1zKTpyKGNbZV0sbC5vdXRwdXRzW2VdLmRhdGFUeXBlLGwub3V0cHV0c1tlXS5kaW1zKSxhPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KG8uZGF0YSk7aWYoIWEpdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3Igb3V0cHV0OiAke28uZGF0YX1gKTtpZih0JiZ0aGlzLnRlbXBvcmFyeURhdGEucHVzaChhKSxuKXtsZXQgZT10aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7ZXx8KGU9W10sdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQsZSkpLGUucHVzaChhKX1wLnB1c2gobyksZC5wdXNoKGEpfWNvbnN0IGY9dGhpcy5wcm9ncmFtTWFuYWdlci5ub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZShsLmRpc3BhdGNoR3JvdXAodCkpO3JldHVybiB1fHwodT10aGlzLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKGwsZiksdGhpcy5wcm9ncmFtTWFuYWdlci5zZXRBcnRpZmFjdChzLHUpKSwoMCxvLkxPR19ERUJVRykoXCJpbmZvXCIsKCgpPT5gW1Byb2dyYW1NYW5hZ2VyXSBydW4gXCIke2wubmFtZX1cIiAoa2V5PSR7c30pIHdpdGggJHtmWzBdfXgke2ZbMV19eCR7ZlsyXX1gKSksdGhpcy5wcm9ncmFtTWFuYWdlci5ydW4odSxhLGQsZikscH11cGxvYWQoZSx0KXt0aGlzLmdwdURhdGFNYW5hZ2VyLnVwbG9hZChlLHQpfW1lbWNweShlLHQpe3RoaXMuZ3B1RGF0YU1hbmFnZXIubWVtY3B5KGUsdCl9YXN5bmMgZG93bmxvYWQoZSx0KXtjb25zdCBuPWF3YWl0IHRoaXMuZ3B1RGF0YU1hbmFnZXIuZG93bmxvYWQoZSk7dCgpLnNldChuZXcgVWludDhBcnJheShuKSl9YWxsb2MoZSl7cmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKGUpLmlkfWZyZWUoZSl7cmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShlKX1jcmVhdGVLZXJuZWwoZSx0LG4pe2NvbnN0IHI9YS5XRUJHUFVfT1BfUkVTT0xWRV9SVUxFUy5nZXQoZSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgbm90IGltcGxlbWVudGVkOiAke2V9YCk7dGhpcy5rZXJuZWxzLnNldCh0LFtlLHJbMF0sW3JbMV0sbl1dKX1yZWxlYXNlS2VybmVsKGUpe2NvbnN0IHQ9dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQoZSk7aWYodCl7Zm9yKGNvbnN0IGUgb2YgdCl0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoZS5pZCk7dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5kZWxldGUoZSl9dGhpcy5rZXJuZWxDdXN0b21EYXRhLmRlbGV0ZShlKSx0aGlzLmtlcm5lbHMuZGVsZXRlKGUpfWNvbXB1dGVLZXJuZWwoZSx0KXtjb25zdCBuPXRoaXMua2VybmVscy5nZXQoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgbm90IGNyZWF0ZWQ6ICR7ZX1gKTtjb25zdFtyLGksYV09bjtpZihudWxsIT09dGhpcy5jdXJyZW50S2VybmVsSWQpdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgXCIke3J9XCIgaXMgbm90IGFsbG93ZWQgdG8gYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5YCk7dGhpcy5jdXJyZW50S2VybmVsSWQ9ZSxhWzBdJiYoYVsxXT1hWzBdKGFbMV0pLGFbMF09dm9pZCAwKSwoMCxvLkxPR19ERUJVRykoXCJpbmZvXCIsKCgpPT5gW1dlYkdQVV0gU3RhcnQgdG8gcnVuIGtlcm5lbCBcIiR7cn1cIi4uLmApKSx0aGlzLnRlbXBvcmFyeURhdGE9W107dHJ5e3JldHVybiBpKHQsYVsxXSksMH1jYXRjaChlKXtyZXR1cm4oMCxvLkxPR19ERUJVRykoXCJ3YXJuaW5nXCIsYFtXZWJHUFVdIEtlcm5lbCBcIiR7cn1cIiBmYWlsZWQuIEVycm9yOiAke2V9YCksMX1maW5hbGx5e2Zvcihjb25zdCBlIG9mIHRoaXMudGVtcG9yYXJ5RGF0YSl0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoZS5pZCk7dGhpcy50ZW1wb3JhcnlEYXRhPVtdLHRoaXMuY3VycmVudEtlcm5lbElkPW51bGx9fX19LDc2NzU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuaW5pdD12b2lkIDA7Y29uc3Qgcj1uKDc5MTcpLG89bigzODM4KSxpPW4oNDk1NSksYT1uKDY5NTIpO2NsYXNzIHN7Y29uc3RydWN0b3IoZSx0LG4scil7dGhpcy5tb2R1bGU9ZSx0aGlzLmRhdGFUeXBlPXQsdGhpcy5kYXRhPW4sdGhpcy5kaW1zPXJ9Z2V0RmxvYXQzMkFycmF5KCl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSxhLlNoYXBlVXRpbC5zaXplKHRoaXMuZGltcykpfXJlc2hhcGUoZSl7aWYoYS5TaGFwZVV0aWwuc2l6ZShlKSE9PWEuU2hhcGVVdGlsLnNpemUodGhpcy5kaW1zKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5ldyBzaGFwZVwiKTtyZXR1cm4gbmV3IHModGhpcy5tb2R1bGUsdGhpcy5kYXRhVHlwZSx0aGlzLmRhdGEsZSl9fWNsYXNzIHV7Z2V0IGN1c3RvbURhdGEoKXtyZXR1cm4gdGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxDdXN0b21EYXRhfWNvbnN0cnVjdG9yKGUsdCxuKXt0aGlzLm1vZHVsZT1lLHRoaXMuYmFja2VuZD10O2NvbnN0IHI9ZS5IRUFQVTMyO2xldCBvPW4+PjI7dGhpcy5vcEtlcm5lbENvbnRleHQ9cltvKytdO2NvbnN0IGk9cltvKytdLGE9W107Zm9yKGxldCB0PTA7dDxpO3QrKyl7Y29uc3QgdD1yW28rK10sbj1yW28rK10saT1yW28rK10sdT1bXTtmb3IobGV0IGU9MDtlPGk7ZSsrKXUucHVzaChyW28rK10pO2EucHVzaChuZXcgcyhlLHQsbix1KSl9dGhpcy5pbnB1dHM9YX1jb21wdXRlKGUsdCl7dmFyIG4sbyxpO2NvbnN0IHU9bnVsbCE9PShvPW51bGw9PT0obj1udWxsPT10P3ZvaWQgMDp0LmlucHV0cyl8fHZvaWQgMD09PW4/dm9pZCAwOm4ubWFwKChlPT5cIm51bWJlclwiPT10eXBlb2YgZT90aGlzLmlucHV0c1tlXTplKSkpJiZ2b2lkIDAhPT1vP286dGhpcy5pbnB1dHMsbD1udWxsIT09KGk9bnVsbD09dD92b2lkIDA6dC5vdXRwdXRzKSYmdm9pZCAwIT09aT9pOltdO3JldHVybiB0aGlzLmJhY2tlbmQucnVuKGUsdSxsLCgoZSx0LG4pPT5uZXcgcyh0aGlzLm1vZHVsZSx0LHRoaXMub3V0cHV0KGUsbiksbikpLCgoZSx0KT0+e2NvbnN0IG49KDAsci5nZXRUZW5zb3JFbGVtZW50U2l6ZSkoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKTtjb25zdCBvPW4qYS5TaGFwZVV0aWwuc2l6ZSh0KTtyZXR1cm4gbmV3IHModGhpcy5tb2R1bGUsZSx0aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKG8pLmlkLHQpfSkpfW91dHB1dChlLHQpe2NvbnN0IG49dGhpcy5tb2R1bGUuc3RhY2tTYXZlKCk7dHJ5e2NvbnN0IG49dGhpcy5tb2R1bGUuc3RhY2tBbGxvYyg0KigxK3QubGVuZ3RoKSk7bGV0IHI9bj4+Mjt0aGlzLm1vZHVsZS5IRUFQVTMyW3IrK109dC5sZW5ndGg7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdGhpcy5tb2R1bGUuSEVBUFUzMltyKytdPXRbZV07cmV0dXJuIHRoaXMubW9kdWxlLl9Kc2VwT3V0cHV0KHRoaXMub3BLZXJuZWxDb250ZXh0LGUsbil9ZmluYWxseXt0aGlzLm1vZHVsZS5zdGFja1Jlc3RvcmUobil9fX10LmluaXQ9YXN5bmMgZT0+e2NvbnN0IHQ9ZS5qc2VwSW5pdDtpZih0JiZuYXZpZ2F0b3IuZ3B1KXtjb25zdCBuPW5ldyBvLldlYkdwdUJhY2tlbmQ7YXdhaXQgbi5pbml0aWFsaXplKCksdCh7YmFja2VuZDpufSwoZT0+bi5hbGxvYyhlKSksKGU9Pm4uZnJlZShlKSksKCh0LHIsbyxhPSExKT0+e2lmKGEpKDAsaS5MT0dfREVCVUcpKFwidmVyYm9zZVwiLCgoKT0+YFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9HcHU6IHNyYz0ke3R9LCBkc3Q9JHtyfSwgc2l6ZT0ke299YCkpLG4ubWVtY3B5KHQscik7ZWxzZXsoMCxpLkxPR19ERUJVRykoXCJ2ZXJib3NlXCIsKCgpPT5gW1dlYkdQVV0ganNlcENvcHlDcHVUb0dwdTogZGF0YU9mZnNldD0ke3R9LCBncHVEYXRhSWQ9JHtyfSwgc2l6ZT0ke299YCkpO2NvbnN0IGE9ZS5IRUFQVTguc3ViYXJyYXkodCx0K28pO24udXBsb2FkKHIsYSl9fSksKGFzeW5jKHQscixvKT0+eygwLGkuTE9HX0RFQlVHKShcInZlcmJvc2VcIiwoKCk9PmBbV2ViR1BVXSBqc2VwQ29weUdwdVRvQ3B1OiBncHVEYXRhSWQ9JHt0fSwgZGF0YU9mZnNldD0ke3J9LCBzaXplPSR7b31gKSksYXdhaXQgbi5kb3dubG9hZCh0LCgoKT0+ZS5IRUFQVTguc3ViYXJyYXkocixyK28pKSl9KSwoKGUsdCxyKT0+bi5jcmVhdGVLZXJuZWwoZSx0LHIpKSwoZT0+bi5yZWxlYXNlS2VybmVsKGUpKSwoKHQscik9PnsoMCxpLkxPR19ERUJVRykoXCJ2ZXJib3NlXCIsKCgpPT5gW1dlYkdQVV0ganNlcFJ1bjoga2VybmVsPSR7dH0sIGNvbnRleHREYXRhT2Zmc2V0PSR7cn1gKSk7Y29uc3Qgbz1uZXcgdShlLG4scik7cmV0dXJuIG4uY29tcHV0ZUtlcm5lbCh0LG8pfSkpfX19LDQ5NTU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTE9HX0RFQlVHPXQuTE9HPXZvaWQgMDtjb25zdCByPW4oODQ1Myksbz1uKDc5MTcpLGk9W1wiVlwiLFwiSVwiLFwiV1wiLFwiRVwiLFwiRlwiXTt0LkxPRz0oZSx0KT0+e2NvbnN0IG49KDAsby5sb2dMZXZlbFN0cmluZ1RvRW51bSkoZSk7dmFyIGEscztuPj0oMCxvLmxvZ0xldmVsU3RyaW5nVG9FbnVtKShyLmVudi5sb2dMZXZlbCkmJihhPW4scz1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3QoKTp0LGNvbnNvbGUubG9nKGBbJHtpW2FdfSwkeyhuZXcgRGF0ZSkudG9JU09TdHJpbmcoKX1dJHtzfWApKX0sdC5MT0dfREVCVUc9KC4uLmUpPT57ci5lbnYuZGVidWcmJigwLHQuTE9HKSguLi5lKX19LDY5NTI6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1BWF9DTElQPXQuTUlOX0NMSVA9dC5HZW1tVXRpbD10LlBvb2xDb252VXRpbD10LlNoYXBlVXRpbD10LkJyb2FkY2FzdFV0aWw9dC5NYXRNdWxVdGlsPXZvaWQgMDtjbGFzcyBue3N0YXRpYyBjYWxjTWF0TXVsU2hhcGUoZSx0KXtyZXR1cm4gZVsxXSE9PXRbMF0/dm9pZCAwOltlWzBdLHRbMV1dfX10Lk1hdE11bFV0aWw9bjtjbGFzcyBye3N0YXRpYyBjYWxjU2hhcGUoZSx0LHI9ITEpe2NvbnN0IG89ZS5sZW5ndGgsaT10Lmxlbmd0aDtpZigwPT09bylyZXR1cm4gdDtpZigwPT09aSlyZXR1cm4gZTtjb25zdCBhPU1hdGgubWF4KGUubGVuZ3RoLHQubGVuZ3RoKSxzPW5ldyBBcnJheShhKTtpZihyKXtpZihvPDJ8fGk8MilyZXR1cm47Y29uc3Qgcj1uLmNhbGNNYXRNdWxTaGFwZShbZVtvLTJdLGVbby0xXV0sW3RbaS0yXSx0W2ktMV1dKTtpZih2b2lkIDA9PT1yKXJldHVybjtbc1thLTJdLHNbYS0xXV09cn1mb3IobGV0IG49cj8zOjE7bjw9YTtuKyspe2NvbnN0IHI9by1uPDA/MTplW28tbl0sdT1pLW48MD8xOnRbaS1uXTtpZihyIT09dSYmcj4xJiZ1PjEpcmV0dXJuO3NbYS1uXT1NYXRoLm1heChyLHUpfXJldHVybiBzfXN0YXRpYyBpc1ZhbGlkQnJvYWRjYXN0KGUsdCl7Y29uc3Qgbj1lLmxlbmd0aCxyPXQubGVuZ3RoO2lmKG4+cilyZXR1cm4hMTtmb3IobGV0IG89MTtvPD1uO28rKylpZigxIT09ZVtuLW9dJiZlW24tb10hPT10W3Itb10pcmV0dXJuITE7cmV0dXJuITB9fXQuQnJvYWRjYXN0VXRpbD1yO2NsYXNzIG97c3RhdGljIHNpemUoZSl7cmV0dXJuIG8uZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShlLDAsZS5sZW5ndGgpfXN0YXRpYyBzaXplRnJvbURpbWVuc2lvbihlLHQpe2lmKHQ8MHx8dD5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7dH0gZm9yIHNpemVGcm9tRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHtlLmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gby5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGUsdCxlLmxlbmd0aCl9c3RhdGljIHNpemVUb0RpbWVuc2lvbihlLHQpe2lmKHQ8MHx8dD5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7dH0gZm9yIHNpemVUb0RpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7ZS5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIG8uZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShlLDAsdCl9c3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZSx0LG4pe2xldCByPTE7Zm9yKGxldCBvPXQ7bzxuO28rKyl7aWYoZVtvXTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgMCBvciBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS5cIik7cio9ZVtvXX1yZXR1cm4gcn1zdGF0aWMgY29tcHV0ZVN0cmlkZXMoZSl7Y29uc3QgdD1lLmxlbmd0aDtpZigwPT09dClyZXR1cm5bXTtpZigxPT09dClyZXR1cm5bMV07Y29uc3Qgbj1uZXcgQXJyYXkodCk7blt0LTFdPTEsblt0LTJdPWVbdC0xXTtmb3IobGV0IHI9dC0zO3I+PTA7LS1yKW5bcl09bltyKzFdKmVbcisxXTtyZXR1cm4gbn1zdGF0aWMgbm9ybWFsaXplQXhpcyhlLHQpe2lmKGU8LXQmJmU+PXQpdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYXhpcyBmb3IgdGhpcyBvcGVyYXRpb24uXCIpO3JldHVybiBlPDA/ZSt0OmV9c3RhdGljIG5vcm1hbGl6ZUF4ZXMoZSx0KXtyZXR1cm4gZS5tYXAoKG49PnRoaXMubm9ybWFsaXplQXhpcyhuLG51bGwhPXQ/dDplLmxlbmd0aCkpKX1zdGF0aWMgc29ydEJhc2VkT25QZXJtKGUsdCl7cmV0dXJuIHQ/dC5tYXAoKHQ9PmVbdF0pKTplLnNsaWNlKCkucmV2ZXJzZSgpfXN0YXRpYyBwYWRTaGFwZShlLHQpe2NvbnN0IG49ZS5sZW5ndGg7cmV0dXJuIGUubWFwKCgoZSxyKT0+ZSt0W3JdK3RbcituXSkpfXN0YXRpYyBhcmVFcXVhbChlLHQpe3JldHVybiBlLmxlbmd0aD09PXQubGVuZ3RoJiZlLmV2ZXJ5KCgoZSxuKT0+ZT09PXRbbl0pKX19dC5TaGFwZVV0aWw9bztjbGFzcyBpe3N0YXRpYyBhZGp1c3RQb29sQXR0cmlidXRlcyhlLHQsbixyLG8saSl7aWYoIWUmJm4ubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3BlY2lmaWVkIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIDIgbGVzcyB0aGFuIGxlbmd0aCBvZiBpbnB1dCBkaW1lbnNpb25zXCIpO2lmKGUpZm9yKGxldCBlPTA7ZTx0Lmxlbmd0aC0yO2UrKyllPj1uLmxlbmd0aD9uLnB1c2godFtlKzJdKTpuW2VdPXRbZSsyXTtmb3IobGV0IGU9MDtlPG4ubGVuZ3RoO2UrKylpZihlPHIubGVuZ3RoKXtpZihyW2VdPDApdGhyb3cgbmV3IEVycm9yKFwic3RyaWRlcyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSByLnB1c2goMSk7Zm9yKGxldCBlPTA7ZTxuLmxlbmd0aDtlKyspaWYoZTxvLmxlbmd0aCl7aWYob1tlXTwwKXRocm93IG5ldyBFcnJvcihcImRpbGF0aW9ucyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBvLnB1c2goMSk7Zm9yKGxldCBlPTA7ZTwyKm4ubGVuZ3RoO2UrKylpZihlPGkubGVuZ3RoKXtpZihpW2VdPDApdGhyb3cgbmV3IEVycm9yKFwicGFkIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIGkucHVzaCgwKTtmb3IobGV0IGU9MDtlPG4ubGVuZ3RoO2UrKyl7aWYobltlXTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJrZXJuZWwgc2hhcGVzIG5lZWQgdG8gYmUgZ3JlYXRlciB0aGFuIDBcIik7aWYoaVtlXT49bltlXXx8aVtlK24ubGVuZ3RoXT49bltlXSl0aHJvdyBuZXcgRXJyb3IoXCJwYWRzIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4ga2VybmVsXCIpfX1zdGF0aWMgYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKGUsdCxuLHIsbyxhLHMpe2lmKHMpe2lmKG8ubGVuZ3RoIT09MiooZS5sZW5ndGgtMikpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHBhZHMgc2hvdWxkIGJlIHR3aWNlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYoci5sZW5ndGghPT1lLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtmb3IobGV0IHU9MDt1PGUubGVuZ3RoLTI7dSsrKWkuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoZVt1KyhhPzE6MildLHRbdV0sblt1XSxyW3VdLG8sdSx1K2UubGVuZ3RoLTIscyl9fXN0YXRpYyBjb21wdXRlUG9vbE91dHB1dFNoYXBlKGUsdCxuLHIsbyxhLHMpe2lmKHQubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMFwiKTtjb25zdCB1PVt0WzBdLHRbMV1dO3JldHVybiBpLmNvbXB1dGVTaGFwZUhlbHBlcihlLHQsdSxuLHIsbyxhLHMpLHV9c3RhdGljIGNvbXB1dGVDb252T3V0cHV0U2hhcGUoZSx0LG4scixvLGEscyl7aWYoZS5sZW5ndGg8PTB8fHQubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXNcIik7Y29uc3QgdT1bZVswXSx0WzBdXTtyZXR1cm4gaS5jb21wdXRlU2hhcGVIZWxwZXIoITEsZSx1LG4scixvLGEscyksdX1zdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKGUsdCxuLHIsbyxhLHMsdSl7aWYoZSlmb3IobGV0IGU9MDtlPHQubGVuZ3RoLTI7ZSsrKW4ucHVzaCgxKTtlbHNlIGZvcihsZXQgZT0wO2U8dC5sZW5ndGgtMjtlKyspbi5wdXNoKGkuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodFtlKzJdLHJbZV0sb1tlXSxhW2VdLHMsZSxlK3QubGVuZ3RoLTIsdSkpfXN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZShlLHQsbixyLG8saSxhLHMpe2NvbnN0IHU9biooci0xKSsxO2lmKCFzfHxcIk5PVFNFVFwiPT09cylyZXR1cm4gTWF0aC5mbG9vcigoZStvW2ldK29bYV0tdSkvdCsxKTtzd2l0Y2gocyl7Y2FzZVwiVkFMSURcIjpyZXR1cm4gb1tpXT0wLG9bYV09MCxNYXRoLmZsb29yKChlLXUpL3QrMSk7Y2FzZVwiU0FNRV9MT1dFUlwiOmNhc2VcIlNBTUVfVVBQRVJcIjppZigxIT09bil0aHJvdyBuZXcgRXJyb3IoXCJEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVJcIik7e2NvbnN0IG49KChlK3QtMSkvdC0xKSp0K3ItZTtyZXR1cm4gb1tpXT1cIlNBTUVfTE9XRVJcIj09PXM/TWF0aC5mbG9vcigobisxKS8yKTpNYXRoLmZsb29yKG4vMiksb1thXT1uLW9baV0sTWF0aC5mbG9vcigoZStuLXIpL3QrMSl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBBdXRvUGFkIHR5cGVcIil9fX10LlBvb2xDb252VXRpbD1pLHQuR2VtbVV0aWw9Y2xhc3N7c3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KGUsdCxuLG8saSl7aWYoMiE9PWUubGVuZ3RofHwyIT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDJcIik7bGV0IGEscyx1O3Q/KGE9ZVsxXSxzPWVbMF0pOihhPWVbMF0scz1lWzFdKTtsZXQgbD0tMTtpZihvPyh1PW5bMF0sbD0xKToodT1uWzFdLGw9MCksbltsXSE9PXMpdGhyb3cgbmV3IEVycm9yKFwiZGltZW5zaW9uIG1pc21hdGNoXCIpO2lmKGE8PTB8fHU8PTB8fHM8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaGFwZSBzcGVjaWZpZWRcIik7aWYoaSYmIXIuaXNWYWxpZEJyb2FkY2FzdChpLFthLHVdKSl0aHJvdyBuZXcgRXJyb3IoXCJnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdFwiKTtyZXR1cm5bYSx1LHNdfX0sdC5NSU5fQ0xJUD0tMzQwMjgyMzQ2NjM4NTI4ODZlMjIsdC5NQVhfQ0xJUD0zNDAyODIzNDY2Mzg1Mjg4NmUyMn0sMzg3OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXk9dm9pZCAwO2NsYXNzIG57Y29uc3RydWN0b3IoZSl7T2JqZWN0LmFzc2lnbih0aGlzLGUpfWdldCBjYWNoZUtleSgpe3JldHVybiB0aGlzLl9jYWNoZUtleXx8KHRoaXMuX2NhY2hlS2V5PU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLnNvcnQoKS5tYXAoKGU9PmAke3RoaXNbZV19YCkpLmpvaW4oXCI7XCIpKSx0aGlzLl9jYWNoZUtleX19dC5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXk9ZT0+bmV3IG4oZSl9LDc3NzE6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlR3B1RGF0YU1hbmFnZXI9dm9pZCAwO2NvbnN0IHI9big0OTU1KSxvPW4oMTE2MyksaT1lPT4xNipNYXRoLmNlaWwoZS8xNik7bGV0IGE9MDtjbGFzcyBze2NvbnN0cnVjdG9yKGUpe3RoaXMuYmFja2VuZD1lLHRoaXMuc3RvcmFnZUNhY2hlPW5ldyBNYXAsdGhpcy5kb3dubG9hZENhY2hlPW5ldyBNYXAsdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZz1bXSx0aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdfXVwbG9hZChlLHQpe2NvbnN0IG49dC5idWZmZXIsbz10LmJ5dGVPZmZzZXQsYT10LmJ5dGVMZW5ndGgscz1pKGEpLHU9dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KGUpO2lmKCF1KXRocm93IG5ldyBFcnJvcihcImdwdSBkYXRhIGZvciB1cGxvYWRpbmcgZG9lcyBub3QgZXhpc3RcIik7aWYodS5vcmlnaW5hbFNpemUhPT1hKXRocm93IG5ldyBFcnJvcihgaW5jb25zaXN0ZW50IGRhdGEgc2l6ZS4gZ3B1IGRhdGEgc2l6ZT0ke3Uub3JpZ2luYWxTaXplfSwgZGF0YSBzaXplPSR7YX1gKTtjb25zdCBsPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHttYXBwZWRBdENyZWF0aW9uOiEwLHNpemU6cyx1c2FnZTpHUFVCdWZmZXJVc2FnZS5NQVBfV1JJVEV8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN9KSxjPWwuZ2V0TWFwcGVkUmFuZ2UoKTtuZXcgVWludDhBcnJheShjKS5zZXQobmV3IFVpbnQ4QXJyYXkobixvLGEpKSxsLnVubWFwKCk7Y29uc3QgcD10aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTt0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSxwLmNvcHlCdWZmZXJUb0J1ZmZlcihsLDAsdS5ncHVEYXRhLmJ1ZmZlciwwLHMpLCgwLHIuTE9HX0RFQlVHKShcInZlcmJvc2VcIiwoKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51cGxvYWQoaWQ9JHtlfSlgKSksdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZy5wdXNoKGwpfW1lbWNweShlLHQpe2NvbnN0IG49dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KGUpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0XCIpO2NvbnN0IHI9dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpO2lmKCFyKXRocm93IG5ldyBFcnJvcihcImRlc3RpbmF0aW9uIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3RcIik7aWYobi5vcmlnaW5hbFNpemUhPT1yLm9yaWdpbmFsU2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJpbmNvbnNpc3RlbnQgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBncHUgZGF0YSBzaXplXCIpO2NvbnN0IG89aShuLm9yaWdpbmFsU2l6ZSk7dGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCkuY29weUJ1ZmZlclRvQnVmZmVyKG4uZ3B1RGF0YS5idWZmZXIsMCxyLmdwdURhdGEuYnVmZmVyLDAsbyl9Y3JlYXRlKGUsdD1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFfEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUKXtjb25zdCBuPWkoZSkscz10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpuLHVzYWdlOnR9KSx1PXtpZDphKyssdHlwZTpvLkdwdURhdGFUeXBlLmRlZmF1bHQsYnVmZmVyOnN9O3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQodS5pZCx7Z3B1RGF0YTp1LG9yaWdpbmFsU2l6ZTplfSksKDAsci5MT0dfREVCVUcpKFwidmVyYm9zZVwiLCgoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLmNyZWF0ZShzaXplPSR7ZX0pID0+IGlkPSR7dS5pZH1gKSksdX1nZXQoZSl7dmFyIHQ7cmV0dXJuIG51bGw9PT0odD10aGlzLnN0b3JhZ2VDYWNoZS5nZXQoZSkpfHx2b2lkIDA9PT10P3ZvaWQgMDp0LmdwdURhdGF9cmVsZWFzZShlKXtjb25zdCB0PXRoaXMuc3RvcmFnZUNhY2hlLmdldChlKTtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJyZWxlYXNpbmcgZGF0YSBkb2VzIG5vdCBleGlzdFwiKTtyZXR1cm4oMCxyLkxPR19ERUJVRykoXCJ2ZXJib3NlXCIsKCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVsZWFzZShpZD0ke2V9KSwgZ3B1RGF0YUlkPSR7dC5ncHVEYXRhLmlkfWApKSx0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUoZSksdGhpcy5idWZmZXJzUGVuZGluZy5wdXNoKHQuZ3B1RGF0YS5idWZmZXIpLHRoaXMuZG93bmxvYWRDYWNoZS5nZXQoZSkmJnRoaXMuZG93bmxvYWRDYWNoZS5kZWxldGUoZSksdC5vcmlnaW5hbFNpemV9YXN5bmMgZG93bmxvYWQoZSl7Y29uc3QgdD10aGlzLmRvd25sb2FkQ2FjaGUuZ2V0KGUpO2lmKHQpcmV0dXJuIHQuZGF0YTtjb25zdCBuPXRoaXMuc3RvcmFnZUNhY2hlLmdldChlKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIGRvZXMgbm90IGV4aXN0XCIpO2NvbnN0IHI9dGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCk7dGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCk7Y29uc3Qgbz10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpuLm9yaWdpbmFsU2l6ZSx1c2FnZTpHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRH0pO3IuY29weUJ1ZmZlclRvQnVmZmVyKG4uZ3B1RGF0YS5idWZmZXIsMCxvLDAsbi5vcmlnaW5hbFNpemUpLHRoaXMuYmFja2VuZC5mbHVzaCgpO2NvbnN0IGk9bmV3IFByb21pc2UoKGU9PntvLm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRCkudGhlbigoKCk9Pntjb25zdCB0PW8uZ2V0TWFwcGVkUmFuZ2UoKS5zbGljZSgwKTtvLmRlc3Ryb3koKSxlKHQpfSkpfSkpO3JldHVybiB0aGlzLmRvd25sb2FkQ2FjaGUuc2V0KGUse2RhdGE6aX0pLGl9cmVmcmVzaFBlbmRpbmdCdWZmZXJzKCl7Zm9yKGNvbnN0IGUgb2YgdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZyllLmRlc3Ryb3koKTtmb3IoY29uc3QgZSBvZiB0aGlzLmJ1ZmZlcnNQZW5kaW5nKWUuZGVzdHJveSgpfX10LmNyZWF0ZUdwdURhdGFNYW5hZ2VyPSguLi5lKT0+bmV3IHMoLi4uZSl9LDg1MTA6ZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQsbixyKXt2b2lkIDA9PT1yJiYocj1uKTt2YXIgbz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbik7byYmIShcImdldFwiaW4gbz8hdC5fX2VzTW9kdWxlOm8ud3JpdGFibGV8fG8uY29uZmlndXJhYmxlKXx8KG89e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbbl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixvKX06ZnVuY3Rpb24oZSx0LG4scil7dm9pZCAwPT09ciYmKHI9biksZVtyXT10W25dfSksbz10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSl9OmZ1bmN0aW9uKGUsdCl7ZS5kZWZhdWx0PXR9KSxpPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIG4gaW4gZSlcImRlZmF1bHRcIiE9PW4mJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pJiZyKHQsZSxuKTtyZXR1cm4gbyh0LGUpLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuV0VCR1BVX09QX1JFU09MVkVfUlVMRVM9dm9pZCAwO2NvbnN0IGE9aShuKDUwNCkpLHM9big5NzcwKSx1PW4oNDI3MSksbD1uKDE1MjIpLGM9aShuKDUyNjIpKSxwPW4oMjYyNSksZD1pKG4oOTMwMikpO3QuV0VCR1BVX09QX1JFU09MVkVfUlVMRVM9bmV3IE1hcChbW1wiQWJzXCIsW2QuYWJzXV0sW1wiQWNvc1wiLFtkLmFjb3NdXSxbXCJBY29zaFwiLFtkLmFjb3NoXV0sW1wiQWRkXCIsW2EuYWRkXV0sW1wiQXNpblwiLFtkLmFzaW5dXSxbXCJBc2luaFwiLFtkLmFzaW5oXV0sW1wiQXRhblwiLFtkLmF0YW5dXSxbXCJBdGFuaFwiLFtkLmF0YW5oXV0sW1wiQXZlcmFnZVBvb2xcIixbYy5hdmVyYWdlUG9vbCxjLnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXV0sW1wiQ2VpbFwiLFtkLmNlaWxdXSxbXCJDbGlwVjEwXCIsW2QuY2xpcFYxMF1dLFtcIkNsaXBcIixbZC5jbGlwXV0sW1wiQ29udlwiLFtzLmNvbnYscy5wYXJzZUNvbnZBdHRyaWJ1dGVzXV0sW1wiQ29zXCIsW2QuY29zXV0sW1wiQ29zaFwiLFtkLmNvc2hdXSxbXCJEaXZcIixbYS5kaXZdXSxbXCJFbHVcIixbZC5lbHUsZC5wYXJzZUFscGhhQXR0cmlidXRlc11dLFtcIkVyZlwiLFtkLmVyZl1dLFtcIkV4cFwiLFtkLmV4cF1dLFtcIkZsb29yXCIsW2QuZmxvb3JdXSxbXCJHZW1tXCIsW3UuZ2VtbSx1LnBhcnNlR2VtbUF0dHJpYnV0ZXNdXSxbXCJHbG9iYWxBdmVyYWdlUG9vbFwiLFtjLmdsb2JhbEF2ZXJhZ2VQb29sLGMucGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXNdXSxbXCJHbG9iYWxNYXhQb29sXCIsW2MuZ2xvYmFsTWF4UG9vbCxjLnBhcnNlR2xvYmFsTWF4UG9vbEF0dHJpYnV0ZXNdXSxbXCJMZWFreVJlbHVcIixbZC5sZWFreVJlbHUsZC5wYXJzZUFscGhhQXR0cmlidXRlc11dLFtcIk1hdE11bFwiLFtsLm1hdE11bF1dLFtcIk1heFBvb2xcIixbYy5tYXhQb29sLGMucGFyc2VNYXhQb29sQXR0cmlidXRlc11dLFtcIk11bFwiLFthLm11bF1dLFtcIk5lZ1wiLFtkLm5lZ11dLFtcIlBvd1wiLFthLnBvd11dLFtcIlJlY2lwcm9jYWxcIixbZC5yZWNpcHJvY2FsXV0sW1wiUmVsdVwiLFtkLnJlbHVdXSxbXCJTaWdtb2lkXCIsW2Quc2lnbW9pZF1dLFtcIlNpblwiLFtkLnNpbl1dLFtcIlNpbmhcIixbZC5zaW5oXV0sW1wiU3FydFwiLFtkLnNxcnRdXSxbXCJTdWJcIixbYS5zdWJdXSxbXCJUYW5cIixbZC50YW5dXSxbXCJUYW5oXCIsW2QudGFuaF1dLFtcIlRocmVzaG9sZGVkUmVsdVwiLFtkLnRocmVzaG9sZGVkUmVsdSxkLnBhcnNlQWxwaGFBdHRyaWJ1dGVzXV0sW1wiVHJhbnNwb3NlXCIsW3AudHJhbnNwb3NlLHAucGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzXV1dKX0sMTQyNzooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuYmlhc0FjdGl2YXRpb25TbmlwcGV0PXQuYWN0aXZhdGlvbkZuU25pcHBldD10LnR5cGVTbmlwcGV0PXZvaWQgMCx0LnR5cGVTbmlwcGV0PWU9Pntzd2l0Y2goZSl7Y2FzZSAxOnJldHVyblwiZjMyXCI7Y2FzZSAyOnJldHVyblwidmVjMjxmMzI+XCI7Y2FzZSAzOnJldHVyblwidmVjMzxmMzI+XCI7Y2FzZSA0OnJldHVyblwidmVjNDxmMzI+XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYCR7ZX0tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSx0LmFjdGl2YXRpb25GblNuaXBwZXQ9KGUsdD0hMSxuPSExLHI9Myk9PlwiXCIsdC5iaWFzQWN0aXZhdGlvblNuaXBwZXQ9KGUsdCk9PmBcXG4gICAgICAke2U/XCJ2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3Jkcyk7XCI6XCJcIn1cXG4gICAgICAke3Q/XCJ2YWx1ZSA9IGFjdGl2YXRpb24odmFsdWUsIGNvb3Jkcyk7XCI6XCJcIn1cXG4gICAgICBgfSw5NDU2OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNyZWF0ZUNvbnYyRE1hdE11bFByb2dyYW1JbmZvPXZvaWQgMDtjb25zdCByPW4oNDk1NSksbz1uKDY5NTIpLGk9bigxMTYzKSxhPW4oMTQyNykscz1uKDQwODUpLHU9bigxNTgpO3QuY3JlYXRlQ29udjJETWF0TXVsUHJvZ3JhbUluZm89KGUsdCxuLGwsYyxwLGQsZixoKT0+e2NvbnN0IGc9XCJOSFdDXCI9PT1uLmZvcm1hdCxtPWc/ZVswXS5kaW1zWzNdOmVbMF0uZGltc1sxXSxiPWxbMF0seT1nP2xbMl06bFszXSx3PWc/bFsxXTpsWzJdLF89Zz9sWzNdOmxbMV0sdj0oKG0lND09MHx8bSUzPT0wKSYmZ3x8eSU0PT0wJiYhZykmJl8lND09MCx4PWc/Xzp5KncsVD1nP3kqdzpfLFM9dj9bOCw4LDFdOlt4PD00PzQ6MTYseD40JiZUPD00PzQ6MTYsMV0sTz12P1s0LDQsMV06W3g8PTQ/MToyLHg+NCYmVDw9ND8xOjIsMV0sQT1bTWF0aC5jZWlsKHgvU1swXS9PWzBdKSxNYXRoLmNlaWwoVC9TWzFdL09bMV0pLE1hdGguY2VpbChiL1NbMl0vT1sxXSldOygwLHIuTE9HX0RFQlVHKShcInZlcmJvc2VcIiwoKCk9PmBbY29udjJkX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke0F9YCkpO2NvbnN0IEU9dj9nJiZtJTQhPTA/Mzo0Ok9bMF0sST1TWzFdKk9bMV0sJD1TWzBdKk9bMF0sUD1NYXRoLm1heChTWzBdKkUsU1sxXSksRD1jJUk9PTAsaz1wJSQ9PTAsQz1kJVA9PTAsUj12P1tFLDQsNF06WzEsMSwxXSxNPVtgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiB4OiBhcnJheTwke3YmJjQ9PT1FP1widmVjNDxmMzI+XCI6XCJmMzJcIn0+O2AsYEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gdzogYXJyYXk8JHt2P1widmVjNDxmMzI+XCI6XCJmMzJcIn0+O2BdO2xldCBOPWBcXG4gICAgICBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IGkzMiwgdmFsdWUgOiAke3Y/XCJ2ZWM0PGYzMj5cIjpcImYzMlwifSkge1xcbiAgICAgICAgcmVzdWx0W2ZsYXRJbmRleF0gPSAke3Y/XCJ2ZWM0PGYzMj5cIjpcImYzMlwifSh2YWx1ZSk7XFxuICAgICAgfVxcbiAgICAgIGZuIHNldE91dHB1dEF0Q29vcmRzKGQwIDogaTMyLCBkMSA6IGkzMiwgZDIgOiBpMzIsIGQzIDogaTMyLCB2YWx1ZSA6ICR7dj9cInZlYzQ8ZjMyPlwiOlwiZjMyXCJ9KSB7XFxuICAgICAgICBsZXQgZmxhdEluZGV4ID0gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKHZlYzQ8aTMyPihkMCwgZDEsIGQyLCBkMykpO1xcbiAgICAgICAgc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggJHt2P1wiLyA0XCI6XCJcIn0sIHZhbHVlKTtcXG4gICAgICB9YDtyZXR1cm4gZiYmKE0ucHVzaChgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkPiBiaWFzOiBhcnJheTwke3Y/XCJ2ZWM0PGYzMj5cIjpcImYzMlwifT47YCksTis9YFxcbiAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gJHt2P1widmVjNDxmMzI+XCI6XCJmMzJcIn0ge1xcbiAgICAgICAgICByZXR1cm4gYmlhc1tjb29yZHMuJHtnP1wid1wiOlwieVwifSR7dj9cIi8gNFwiOlwiXCJ9XTtcXG4gICAgICAgIH1gKSxPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dHM6W3tkaW1zOmwsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZSxncHVEYXRhVHlwZTppLkdwdURhdGFUeXBlLmRlZmF1bHR9XSxkaXNwYXRjaEdyb3VwOigpPT4oe3g6QVswXSx5OkFbMV0sejpBWzJdfSksZ2V0U2hhZGVyU291cmNlOigpPT5gXFxuICAgICAgICAke3MudXRpbEZ1bmN0aW9uc31cXG4gICAgICAgIC8vc3RydWN0IFVuaWZvcm1zIHsgeFNoYXBlIDogdmVjNDxpMzI+LCB3U2hhcGUgOiB2ZWM0PGkzMj4sIG91dFNoYXBlIDogdmVjNDxpMzI+LFxcbiAgICAgICAgLy8gIG91dFNoYXBlU3RyaWRlczogdmVjMzxpMzI+LCBmaWx0ZXJEaW1zIDogdmVjMjxpMzI+LCBwYWQgOiB2ZWMyPGkzMj4sIHN0cmlkZSA6IHZlYzI8aTMyPixcXG4gICAgICAgIC8vICBkaWxhdGlvbiA6IHZlYzI8aTMyPiwgZGltQU91dGVyIDogaTMyLCBkaW1CT3V0ZXIgOiBpMzIsIGRpbUlubmVyIDogaTMyIH07XFxuICAgICAgICAke00uam9pbihcIlwiKX1cXG4gICAgICAgIEBncm91cCgwKSBAYmluZGluZygke00ubGVuZ3RofSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IHJlc3VsdDogYXJyYXk8JHt2P1widmVjNDxmMzI+XCI6XCJmMzJcIn0+O1xcbiAgICAgICAgLy9AZ3JvdXAoMCkgQGJpbmRpbmcoJHtNLmxlbmd0aCsxfSkgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztcXG5cXG4gICAgICAgIGNvbnN0IHhTaGFwZSA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke2VbMF0uZGltcy5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3Qgd1NoYXBlIDogdmVjNDxpMzI+ID0gdmVjNDxpMzI+KCR7ZVsxXS5kaW1zLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCBvdXRTaGFwZSA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke2wuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IG91dFNoYXBlU3RyaWRlcyA6IHZlYzM8aTMyPiA9IHZlYzM8aTMyPigke28uU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGwpLnNsaWNlKDAsMykuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IGZpbHRlckRpbXMgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHtuLmtlcm5lbFNoYXBlWzBdfSwgJHtuLmtlcm5lbFNoYXBlWzFdfSk7XFxuICAgICAgICBjb25zdCBwYWQgOiB2ZWMyPGkzMj4gPSB2ZWMyPGkzMj4oJHtuLnBhZHNbMF19LCAke24ucGFkc1sxXX0pO1xcbiAgICAgICAgY29uc3Qgc3RyaWRlIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7bi5zdHJpZGVzWzBdfSwgJHtuLnN0cmlkZXNbMV19KTtcXG4gICAgICAgIGNvbnN0IGRpbGF0aW9uIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7bi5kaWxhdGlvbnNbMF19LCAke24uZGlsYXRpb25zWzFdfSk7XFxuICAgICAgICBjb25zdCBkaW1BT3V0ZXIgOiBpMzIgPSAke2N9O1xcbiAgICAgICAgY29uc3QgZGltQk91dGVyIDogaTMyID0gJHtwfTtcXG4gICAgICAgIGNvbnN0IGRpbUlubmVyIDogaTMyID0gJHtkfTtcXG4gICAgICAgICR7Tn1cXG4gICAgICAgICR7KChlLHQsbixyLG89ITEsaSxzPSExLHU9NCxsPTQsYz00KT0+e2NvbnN0IHA9ZT9cIlxcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhSb3csIHhDb2wsIHhDaCk7XFxuICAgIFwiOlwiXFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeENoLCB4Um93LCB4Q29sKTtcXG4gICAgXCIsZD1lP1wiXFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXFxuICAgICAgYmF0Y2gsXFxuICAgICAgcm93IC8gb3V0V2lkdGgsXFxuICAgICAgcm93ICUgb3V0V2lkdGgsXFxuICAgICAgY29sKTtcXG4gICAgXCI6XCJcXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcXG4gICAgICBiYXRjaCxcXG4gICAgICByb3csXFxuICAgICAgY29sIC8gb3V0V2lkdGgsXFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xcbiAgICBcIixmPWU/XCJ4U2hhcGVbMV1cIjpcInhTaGFwZVsyXVwiLGg9ZT9cInhTaGFwZVsyXVwiOlwieFNoYXBlWzNdXCIsZz1lP1wicm93XCI6XCJjb2xcIixtPWU/XCJjb2xcIjpcInJvd1wiLGI9YFxcbiAgICBsZXQgaW5DaGFubmVscyA9IHdTaGFwZVsyXTtcXG4gICAgbGV0IG91dFdpZHRoID0gJHtlP1wib3V0U2hhcGVbMl1cIjpcIm91dFNoYXBlWzNdXCJ9O1xcbiAgICBsZXQgb3V0Um93ID0gJHtnfSAvIG91dFdpZHRoO1xcbiAgICBsZXQgb3V0Q29sID0gJHtnfSAlIG91dFdpZHRoO1xcblxcbiAgICBsZXQgV1JvdyA9ICR7bX0gLyAoZmlsdGVyRGltc1sxXSAqIGluQ2hhbm5lbHMpO1xcbiAgICBsZXQgV0NvbCA9ICR7bX0gLyBpbkNoYW5uZWxzICUgZmlsdGVyRGltc1sxXTtcXG4gICAgbGV0IHhSb3cgPSBvdXRSb3cgKiBzdHJpZGVbMF0gKyBkaWxhdGlvblswXSAqIFdSb3cgLSBwYWRbMF07XFxuICAgIGxldCB4Q29sID0gb3V0Q29sICogc3RyaWRlWzFdICsgZGlsYXRpb25bMV0gKiBXQ29sIC0gcGFkWzFdO1xcbiAgICBsZXQgeENoID0gJHttfSAlIGluQ2hhbm5lbHM7XFxuICAgIHZhciByZXNEYXRhID0gJHsoMCxhLnR5cGVTbmlwcGV0KSh1KX0oMC4wKTtcXG4gICAgLy8gVGhlIGJvdW5kcyBjaGVja2luZyBpcyBhbHdheXMgbmVlZGVkIHNpbmNlIHdlIHVzZSBpdCB0byBwYWQgemVybyBmb3JcXG4gICAgLy8gdGhlICdzYW1lJyBwYWRkaW5nIHR5cGUuXFxuICAgIGlmICh4Um93ID49IDAgJiYgeFJvdyA8ICR7Zn0gJiYgeENvbCA+PSAwICYmIHhDb2wgPCAke2h9KSB7XFxuICAgICAgJHtwfVxcbiAgICAgIGxldCB4SW5kZXggPSBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgeFNoYXBlKTtcXG4gICAgICAkeyhlPT57c3dpdGNoKGUpe2Nhc2UgMTpyZXR1cm5cInJlc0RhdGEgPSB4W3hJbmRleF07XCI7Y2FzZSAzOnJldHVyblwicmVzRGF0YSA9IHZlYzM8ZjMyPih4W3hJbmRleF0sIHhbeEluZGV4ICsgMV0sIHhbeEluZGV4ICsgMl0pO1wiO2Nhc2UgNDpyZXR1cm5cInJlc0RhdGEgPSB4W3hJbmRleCAvIDRdO1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7ZX0gaXMgbm90IHN1cHBvcnRlZC5gKX19KSh1KX1cXG4gICAgfVxcbiAgICByZXR1cm4gcmVzRGF0YTtgLHk9ZT90JiZyP2BcXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHt1fTtcXG4gICAgJHtifWA6YFxcbiAgICBsZXQgY29sID0gY29sSW4gKiAke3V9O1xcbiAgICBpZiAocm93IDwgZGltQU91dGVyICYmIGNvbCA8IGRpbUlubmVyKSB7XFxuICAgICAgJHtifVxcbiAgICB9XFxuICAgIHJldHVybiAkeygwLGEudHlwZVNuaXBwZXQpKHUpfSgwLjApO2A6ciYmbj9gXFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7dX07XFxuICAgICR7Yn1gOmBcXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHt1fTtcXG4gICAgaWYgKHJvdyA8IGRpbUlubmVyICYmIGNvbCA8IGRpbUJPdXRlcikge1xcbiAgICAgICR7Yn1cXG4gICAgfVxcbiAgICByZXR1cm4gJHsoMCxhLnR5cGVTbmlwcGV0KSh1KX0oMC4wKTtgLHc9YCR7KGU9Pntzd2l0Y2goZSl7Y2FzZSAxOnJldHVyblwicmV0dXJuIHdbcm93ICogd1NoYXBlWzNdICsgY29sSW5dO1wiO2Nhc2UgNDpyZXR1cm5cInJldHVybiB3W3JvdyAqIHdTaGFwZVszXSAvIDQgKyBjb2xJbl07XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHtlfSBpcyBub3Qgc3VwcG9ydGVkLmApfX0pKGwpfWAsXz0oMCxhLnR5cGVTbmlwcGV0KShjKSx2PWU/KDAsYS50eXBlU25pcHBldCkodSk6KDAsYS50eXBlU25pcHBldCkobCkseD1lPygwLGEudHlwZVNuaXBwZXQpKGwpOigwLGEudHlwZVNuaXBwZXQpKHUpO3JldHVybmBcXG4gICAgJHsoMCxhLmFjdGl2YXRpb25GblNuaXBwZXQpKGkscyw0PT09Yyw0KX1cXG4gICAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHt2fSB7XFxuICAgICAgJHtlP3k6d31cXG4gICAgfVxcblxcbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke3h9IHtcXG4gICAgICAke2U/dzp5fVxcbiAgICB9XFxuXFxuICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIsIHZhbHVlSW4gOiAke199KSB7XFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtjfTtcXG4gICAgICBpZiAocm93IDwgZGltQU91dGVyICYmIGNvbCA8IGRpbUJPdXRlcilcXG4gICAgICB7XFxuICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcXG4gICAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJvdXRTaGFwZVsyXVwiOlwib3V0U2hhcGVbM11cIn07XFxuICAgICAgJHtkfVxcbiAgICAgICR7KDAsYS5iaWFzQWN0aXZhdGlvblNuaXBwZXQpKG8saSl9XFxuICAgICAgc2V0T3V0cHV0QXRDb29yZHMoY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdLCB2YWx1ZSk7XFxuICAgICAgfVxcbiAgICB9YH0pKGcsRCxrLEMsZix2b2lkIDAsITEsUlswXSxSWzFdLFJbMl0pfVxcbiAgICAgICAgICAgICR7dj8oMCx1Lm1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlKShPLFMsIWcsUCk6KDAsdS5tYWtlTWF0TXVsUGFja2VkU291cmNlKShPLFMsIWcsUCwhMSx2b2lkIDAsaCl9YH0pfX0sNDA4NTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQudXRpbEZ1bmN0aW9ucz12b2lkIDAsdC51dGlsRnVuY3Rpb25zPVwiXFxuZm4gZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmRzIDogdmVjNDxpMzI+LCBzaGFwZSA6IHZlYzQ8aTMyPikgLT4gaTMyIHtcXG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXFxuICAgICAgc2hhcGUueSAqIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS56ICogc2hhcGUudywgc2hhcGUudywgMSkpO1xcbn1cXG5mbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiBpMzIge1xcbiAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcXG4gICAgb3V0U2hhcGVTdHJpZGVzLngsIG91dFNoYXBlU3RyaWRlcy55LCBvdXRTaGFwZVN0cmlkZXMueiwgMSkpO1xcbn1cXG5cIn0sMTU4OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5tYWtlTWF0TXVsUGFja2VkU291cmNlPXQubWFrZU1hdE11bFBhY2tlZFZlYzRTb3VyY2U9dm9pZCAwLHQubWFrZU1hdE11bFBhY2tlZFZlYzRTb3VyY2U9KGUsdCxuPSExLHI9MzIsbz0hMSxpPTMyLGE9ITEpPT57Y29uc3Qgcz10WzFdKmVbMV0sdT10WzBdKmVbMF0sbD1uP3M6cixjPW4/cjpzLHA9bC90WzBdLGQ9ci90WzFdO2lmKCghbnx8NCE9PXB8fDQhPT1lWzFdKSYmKG58fDMhPT1wJiY0IT09cCl8fGwldFswXSE9MHx8ciV0WzFdIT0wfHw0IT09ZVswXSl0aHJvdyBuZXcgRXJyb3IoYElmIHRyYW5zcG9zZUEgJHtufSBpcyB0cnVlLCBpbm5lckVsZW1lbnRTaXplICR7cH0gYW5kIHdvcmtQZXJUaHJlYWRbMV0gJHtlWzFdfSBtdXN0IGJlIDQuXFxuICAgICAgT3RoZXJ3aXNlLCBpbm5lckVsZW1lbnRTaXplICR7cH0gbXVzdCBiZSAzIG9yIDQuXFxuICB0aWxlQVdpZHRoICR7bH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7dFswXX0uIHRpbGVJbm5lciAke3J9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0gJHt0WzFdfS4gY29sUGVyVGhyZWFkICR7ZVswXX0gbXVzdCBiZSA0LmApO3JldHVybmBcXG52YXI8d29ya2dyb3VwPiBtbV9Bc3ViIDogYXJyYXk8YXJyYXk8dmVjJHtwfTxmMzI+LCAke2wvcH0+LCAke2N9PjtcXG52YXI8d29ya2dyb3VwPiBtbV9Cc3ViIDogYXJyYXk8YXJyYXk8dmVjNDxmMzI+LCAke3UvZVswXX0+LCAke3J9PjtcXG5cXG5jb25zdCByb3dQZXJUaHJlYWQgPSAke2VbMV19O1xcbmNvbnN0IGNvbFBlclRocmVhZCA9ICR7ZVswXX07XFxuY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9ICR7cH07XFxuY29uc3QgdGlsZUlubmVyID0gJHtyfTtcXG5cXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt0WzBdfSwgJHt0WzFdfSwgJHt0WzJdfSlcXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXFxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XFxuICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcXG4gIGxldCB0aWxlUm93ID0gJHthP1wiMFwiOlwibG9jYWxSb3cgKiByb3dQZXJUaHJlYWRcIn07XFxuICBsZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpO1xcblxcbiAgbGV0IGdsb2JhbFJvdyA9ICR7YT9cIjBcIjpcImkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZFwifTtcXG4gIGxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCk7XFxuICBsZXQgYmF0Y2ggPSAke28/XCIwXCI6XCJpMzIoZ2xvYmFsSWQueilcIn07XFxuICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3N9O1xcblxcbiAgbGV0IG51bVRpbGVzID0gJHtvP2Ake01hdGguY2VpbChpL3IpfWA6XCIoZGltSW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDFcIn07XFxuICB2YXIga1N0YXJ0ID0gJHtvP2BpMzIoZ2xvYmFsSWQueikgKiAke2l9YDpcIjBcIn07XFxuXFxuICB2YXIgYWNjOiBhcnJheTx2ZWM0PGYzMj4sIHJvd1BlclRocmVhZD47XFxuXFxuICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cXG4gIGxldCB0aWxlUm93QiA9IGxvY2FsUm93ICogJHtkfTtcXG4gIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtVGlsZXM7IHQgPSB0ICsgMSkge1xcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93ICsgaW5uZXJSb3c7XFxuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XFxuICAgICAgICAgICR7Zj1uLGY/XCJcXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxcbiAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcXG4gICAgICAgICAgZ2xvYmFsUm93U3RhcnQgLyBpbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wpO1xcbiAgICAgICAgXCI6XCJcXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxcbiAgICAgICAgICBnbG9iYWxSb3cgKyBpbm5lclJvdyxcXG4gICAgICAgICAga1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sKTtcXG4gICAgICAgIFwifVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXFxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7ZH07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XFxuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XFxuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLCBrU3RhcnQgKyBpbnB1dFJvdywgZ2xvYmFsQ29sKTtcXG4gICAgICB9XFxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lciAvIGlubmVyRWxlbWVudFNpemU7IGsgPSBrICsgMSkge1xcbiAgICAgICAgICBsZXQgQkNhY2hlZDAgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVt0aWxlQ29sXTtcXG4gICAgICAgICAgbGV0IEJDYWNoZWQxID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW3RpbGVDb2xdO1xcbiAgICAgICAgICBsZXQgQkNhY2hlZDIgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bdGlsZUNvbF07XFxuICAgICAgICAgICR7Mz09PXA/XCJcIjpcImxldCBCQ2FjaGVkMyA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVt0aWxlQ29sXTtcIn1cXG5cXG4gICAgICAgICAgJHsoKGUsdCk9PmU/YFxcbiAgICAgICAgbGV0IEFDYWNoZWQwID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bbG9jYWxSb3ddO1xcbiAgICAgICAgbGV0IEFDYWNoZWQxID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW2xvY2FsUm93XTtcXG4gICAgICAgIGxldCBBQ2FjaGVkMiA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVtsb2NhbFJvd107XFxuICAgICAgICAkezM9PT10P1wiXCI6XCJsZXQgQUNhY2hlZDMgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bbG9jYWxSb3ddO1wifVxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQwW2ldICsgYWNjW2ldO1xcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQxW2ldICsgYWNjW2ldO1xcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQyW2ldICsgYWNjW2ldO1xcbiAgICAgICAgICAkezM9PT10P1wiXCI6XCJhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQzW2ldICsgYWNjW2ldO1wifVxcbiAgICAgICAgfWA6YFxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGldW2tdO1xcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQueCArIGFjY1tpXTtcXG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkLnkgKyBhY2NbaV07XFxuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZC56ICsgYWNjW2ldO1xcbiAgICAgICAgICAkezM9PT10P1wiXCI6XCJhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQudyArIGFjY1tpXTtcIn1cXG4gICAgICAgIH1gKShuLHApfVxcbiAgICAgIH1cXG5cXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuICB9XFxuXFxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sLCBhY2NbaW5uZXJSb3ddKTtcXG4gIH1cXG59YDt2YXIgZn07Y29uc3Qgbj1lPT5lP1wiXFxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXFxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRDb2wpO1xcbiAgICAgICAgICAgIFwiOlwiXFxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Um93LFxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRDb2wpO1xcbiAgICAgICAgICAgIFwiO3QubWFrZU1hdE11bFBhY2tlZFNvdXJjZT0oZSx0LHI9ITEsbz0zMixpPSExLGE9MzIscz0hMSk9Pntjb25zdCB1PWVbMV0qdFsxXSxsPWVbMF0qdFswXSxjPXI/dTpvLHA9cj9vOnU7aWYocCV0WzFdIT0wfHxjJXRbMF0hPTB8fG8ldFsxXSE9MCl0aHJvdyBuZXcgRXJyb3IoYHRpbGVBSGlnaHQgJHtwfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdJHt0WzFdfSwgdGlsZUFXaWR0aCAke2N9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3RbMF19LCB0aWxlSW5uZXIgJHtvfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdJHt0WzFdfWApO2NvbnN0IGQ9cC90WzFdLGY9Yy90WzBdLGg9by90WzFdLGc9cz9gXFxuICAgIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xcbiAgICBsZXQgbG9jYWxDb2wgPSBpMzIobG9jYWxJZC54KTtcXG4gICAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHt1fTtcXG4gICAgbGV0IGdsb2JhbENvbFN0YXJ0ID0gaTMyKHdvcmtncm91cElkLngpICogJHtsfTtcXG5cXG4gICAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXFxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtVGlsZXM7IHQgPSB0ICsgMSkge1xcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7cH07IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3RbMV19KSB7XFxuICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7Y307IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3RbMF19KSB7XFxuICAgICAgICAgICR7bihyKX1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxcbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHtvfTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7dFsxXX0pIHtcXG4gICAgICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7bH07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3RbMF19KSB7XFxuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxcbiAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxcbiAgICAgICAgICAgIGdsb2JhbENvbFN0YXJ0ICsgaW5wdXRDb2wpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XFxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcblxcbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxcbiAgICAgIHZhciBCQ2FjaGVkIDogYXJyYXk8ZjMyLCBjb2xQZXJUaHJlYWQ+O1xcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcXG4gICAgICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XFxuICAgICAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVtsb2NhbENvbCArIGlubmVyICogJHt0WzBdfV07XFxuICAgICAgICB9XFxuICAgICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9ICR7cj9gbW1fQXN1YltrXVtsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfV07YDpgbW1fQXN1Yltsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfV1ba107YH1cXG4gICAgICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcXG4gICAgICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICtcXG4gICAgICAgICAgICAgICAgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG4gICAgfVxcbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICAgIGxldCBnUm93ID0gZ2xvYmFsUm93U3RhcnQgKyBsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfTtcXG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xcbiAgICAgICAgbGV0IGdDb2wgPSBnbG9iYWxDb2xTdGFydCArIGxvY2FsQ29sICsgaW5uZXJDb2wgKiAke3RbMF19O1xcbiAgICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdSb3csIGdDb2wsIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgYDpgXFxubGV0IHRpbGVSb3cgPSBpMzIobG9jYWxJZC55KSAqIHJvd1BlclRocmVhZDtcXG5sZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpICogY29sUGVyVGhyZWFkO1xcblxcbmxldCBnbG9iYWxSb3cgPSBpMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWQ7XFxubGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KSAqIGNvbFBlclRocmVhZDtcXG5sZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3V9O1xcblxcbmxldCB0aWxlUm93QSA9IGkzMihsb2NhbElkLnkpICogJHtkfTtcXG5sZXQgdGlsZUNvbEEgPSBpMzIobG9jYWxJZC54KSAqICR7Zn07XFxubGV0IHRpbGVSb3dCID0gaTMyKGxvY2FsSWQueSkgKiAke2h9O1xcbi8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxcbmZvciAodmFyIHQgPSAwOyB0IDwgbnVtVGlsZXM7IHQgPSB0ICsgMSkge1xcbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxcbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7ZH07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCAke2Z9OyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dBICsgaW5uZXJSb3c7XFxuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbEEgKyBpbm5lckNvbDtcXG4gICAgICAke24ocil9XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke2h9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XFxuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbCArIGlubmVyQ29sO1xcbiAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxcbiAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXFxuICAgICAgICBnbG9iYWxDb2wgKyBpbm5lckNvbCk7XFxuICAgIH1cXG4gIH1cXG4gIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcXG4gIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxcbiAgdmFyIEJDYWNoZWQgOiBhcnJheTxmMzIsIGNvbFBlclRocmVhZD47XFxuICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XFxuICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XFxuICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW3RpbGVDb2wgKyBpbm5lcl07XFxuICAgIH1cXG5cXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gICAgICAkeyhlPT5lP1wibGV0IEFDYWNoZWQgPSBtbV9Bc3ViW2tdW3RpbGVSb3cgKyBpbm5lclJvd107XCI6XCJsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGlubmVyUm93XVtrXTtcIikocil9XFxuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcXG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gKyBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxufVxcblxcbmZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xcbiAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCArIGlubmVyQ29sLFxcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xcbiAgfVxcbn1cXG5gO3JldHVybmBcXG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0FzdWIgOiBhcnJheTxhcnJheTxmMzIsICR7Y30+LCAke3B9PjtcXG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0JzdWIgOiBhcnJheTxhcnJheTxmMzIsICR7bH0+LCAke299PjtcXG4gIGNvbnN0IHJvd1BlclRocmVhZCA9ICR7ZVsxXX07XFxuICBjb25zdCBjb2xQZXJUaHJlYWQgPSAke2VbMF19O1xcbiAgY29uc3QgdGlsZUlubmVyID0gJHtvfTtcXG5cXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt0WzBdfSwgJHt0WzFdfSwgJHt0WzJdfSlcXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXFxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XFxuICAgIGxldCBiYXRjaCA9ICR7aT9cIjBcIjpcImkzMihnbG9iYWxJZC56KVwifTtcXG4gICAgbGV0IG51bVRpbGVzID0gJHtpP2Ake01hdGguY2VpbChhL28pfWA6XCIoZGltSW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDFcIn07XFxuICAgIHZhciBrU3RhcnQgPSAke2k/YGkzMihnbG9iYWxJZC56KSAqICR7YX1gOlwiMFwifTtcXG5cXG4gICAgdmFyIGFjYyA6IGFycmF5PGFycmF5PGYzMiwgY29sUGVyVGhyZWFkPiwgcm93UGVyVGhyZWFkPjtcXG5cXG4gICAgLy8gV2l0aG91dCB0aGlzIGluaXRpYWxpemF0aW9uIHN0cmFuZ2UgdmFsdWVzIHNob3cgdXAgaW4gYWNjLlxcbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XFxuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IDAuMDtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgJHtnfVxcbiAgfVxcbmB9fSw1MDQ6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuc3ViPXQucG93PXQubXVsPXQuZGl2PXQuYWRkPXZvaWQgMDtjb25zdCByPW4oNjk1Miksbz1uKDExNjMpLGk9bigyMDc1KSxhPShlLHQsbixhLHMpPT57Y29uc3QgdT17bmFtZTp0LGlucHV0VHlwZXM6W28uR3B1RGF0YVR5cGUuZGVmYXVsdCxvLkdwdURhdGFUeXBlLmRlZmF1bHRdLGNhY2hlSGludDpzfTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtnZXQ6KCk9PigoZSx0LG4sYSxzLHU9dC5kYXRhVHlwZSk9Pnt2YXIgbCxjO2NvbnN0IHA9IXIuU2hhcGVVdGlsLmFyZUVxdWFsKHQuZGltcyxuLmRpbXMpO2xldCBkPXQuZGltcyxmPXIuU2hhcGVVdGlsLnNpemUodC5kaW1zKSxoPSExO2lmKHApe2NvbnN0IGU9ci5Ccm9hZGNhc3RVdGlsLmNhbGNTaGFwZSh0LmRpbXMsbi5kaW1zLCExKTtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZXJmb3JtIGJpbmFyeSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtkPWUsZj1yLlNoYXBlVXRpbC5zaXplKGQpO2xldCBvPTE7Zm9yKGxldCBlPTA7ZTxkLmxlbmd0aDtlKyspe2NvbnN0IHI9bnVsbCE9PShsPXQuZGltc1t0LmRpbXMubGVuZ3RoLWVdKSYmdm9pZCAwIT09bD9sOjE7aWYociE9PShudWxsIT09KGM9bi5kaW1zW24uZGltcy5sZW5ndGgtZV0pJiZ2b2lkIDAhPT1jP2M6MSkpYnJlYWs7byo9cn1vJTQ9PTAmJihoPSEwKX1lbHNlIGg9ITA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7Z2V0U2hhZGVyU291cmNlOmU9PigoZSx0LG4sbyxhLHMsdSxsLGM9XCJmMzJcIixwPVwiZjMyXCIsZD1cImYzMlwiKT0+e2NvbnN0IGY9ci5TaGFwZVV0aWwuc2l6ZShvKSxoPU1hdGguY2VpbChmLzQpO2xldCBnLG07XCJzdHJpbmdcIj09dHlwZW9mIHU/Zz1tPShlLHQpPT5gJHt1fSgoJHtlfSksKCR7dH0pKWA6XCJmdW5jdGlvblwiPT10eXBlb2YgdT9nPW09dTooZz11LnNjYWxhcixtPXUudmVjdG9yKTtsZXQgYj1cIlwiO2NvbnN0IHk9KDAsaS5jcmVhdGVJbmRpY2VzSGVscGVyKShcIm91dHB1dFwiLG8pO2lmKHMpe2NvbnN0IGU9ZT0+e2NvbnN0IHQ9ci5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZSksbj1bXTtmb3IobGV0IHI9ZS5sZW5ndGgtMTtyPj0wO3ItLSl7Y29uc3QgaT0wPT09by5sZW5ndGg/XCIwdVwiOjE9PT1vLmxlbmd0aD9cIigqb3V0cHV0SW5kaWNlcylcIjpgKCpvdXRwdXRJbmRpY2VzKVske3Irby5sZW5ndGgtZS5sZW5ndGh9XWA7bi5wdXNoKGAke3Rbcl19dSAqICgke2l9ICUgJHtlW3JdfXUpYCl9cmV0dXJuIG4ubGVuZ3RoPjA/bi5qb2luKFwiK1wiKTpcIjB1XCJ9O2I9YFxcbiAgJHt5Lm8yaUltcGx9XFxuXFxuICBmbiBjYWxjT2Zmc2V0QShvdXRwdXRJbmRpY2VzOiBwdHI8ZnVuY3Rpb24sICR7eS5pVHlwZX0+KSAtPiB1MzIge1xcbiAgICByZXR1cm4gJHtlKHQpfTtcXG4gIH1cXG5cXG4gIGZuIGNhbGNPZmZzZXRCKG91dHB1dEluZGljZXM6IHB0cjxmdW5jdGlvbiwgJHt5LmlUeXBlfT4pIC0+IHUzMiB7XFxuICAgIHJldHVybiAke2Uobil9O1xcbiAgfVxcbiAgYH1sZXQgdztpZihhKXc9cz9gXFxuICAgICAgJHt5LmluZGljZXNWYXJpYWJsZURlY2xhcmF0aW9uKFwib3V0cHV0SW5kaWNlc1wiKX1cXG4gICAgICAke3kubzJpQ2FsbChcImdsb2JhbF9pZHggKiA0dVwiLFwib3V0cHV0SW5kaWNlc1wiKX1cXG4gICAgICBsZXQgb2Zmc2V0QSA9IGNhbGNPZmZzZXRBKCZvdXRwdXRJbmRpY2VzKTtcXG4gICAgICBsZXQgb2Zmc2V0QiA9IGNhbGNPZmZzZXRCKCZvdXRwdXRJbmRpY2VzKTtcXG4gICAgICBvdXRwdXREYXRhW2dsb2JhbF9pZHhdID0gJHttKFwiYURhdGFbb2Zmc2V0QSAvIDR1XVwiLFwiYkRhdGFbb2Zmc2V0QiAvIDR1XVwiKX07YDpgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9ICR7bShcImFEYXRhW2dsb2JhbF9pZHhdXCIsXCJiRGF0YVtnbG9iYWxfaWR4XVwiKX07YDtlbHNle2lmKCFzKXRocm93IG5ldyBFcnJvcihcIm5vIG5lY2Vzc2FyeSB0byB1c2Ugc2NhbGFyIGltcGxlbWVudGF0aW9uIGZvciBlbGVtZW50LXdpc2UgYmluYXJ5IG9wIGltcGxlbWVudGF0aW9uLlwiKTtjb25zdCBlPWU9Pntjb25zdCB0PWBhRGF0YVtpbmRleEEke2V9XVtjb21wb25lbnRBJHtlfV1gLG49YGJEYXRhW2luZGV4QiR7ZX1dW2NvbXBvbmVudEIke2V9XWA7cmV0dXJuYFxcbiAgICAgICR7eS5vMmlDYWxsKGBnbG9iYWxfaWR4ICogNHUgKyAke2V9dWAsXCJvdXRwdXRJbmRpY2VzXCIpfVxcbiAgICAgIGxldCBvZmZzZXRBJHtlfSA9IGNhbGNPZmZzZXRBKCZvdXRwdXRJbmRpY2VzKTtcXG4gICAgICBsZXQgb2Zmc2V0QiR7ZX0gPSBjYWxjT2Zmc2V0Qigmb3V0cHV0SW5kaWNlcyk7XFxuICAgICAgbGV0IGluZGV4QSR7ZX0gPSBvZmZzZXRBJHtlfSAvIDR1O1xcbiAgICAgIGxldCBpbmRleEIke2V9ID0gb2Zmc2V0QiR7ZX0gLyA0dTtcXG4gICAgICBsZXQgY29tcG9uZW50QSR7ZX0gPSBvZmZzZXRBJHtlfSAlIDR1O1xcbiAgICAgIGxldCBjb21wb25lbnRCJHtlfSA9IG9mZnNldEIke2V9ICUgNHU7XFxuICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XVske2V9XSA9ICR7Zyh0LG4pfTtgfTt3PWBcXG4gICAgICAke3kuaW5kaWNlc1ZhcmlhYmxlRGVjbGFyYXRpb24oXCJvdXRwdXRJbmRpY2VzXCIpfVxcbiAgICAgICR7ZSgwKX1cXG4gICAgICAke2UoMSl9XFxuICAgICAgJHtlKDIpfVxcbiAgICAgICR7ZSgzKX1gfXJldHVybmBcXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gYURhdGEgOiBhcnJheTx2ZWM0PCR7Y30+PjtcXG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gYkRhdGEgOiBhcnJheTx2ZWM0PCR7cH0+PjtcXG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0RGF0YSA6IGFycmF5PHZlYzQ8JHtkfT4+O1xcblxcbiAgJHtudWxsIT1sP2w6XCJcIn1cXG4gICR7Yn1cXG5cXG4gICR7ZS5tYWluU3RhcnQoKX1cXG4gICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoaCl9XFxuICAgICR7d31cXG4gIH1gfSkoZSx0LmRpbXMsbi5kaW1zLGQsaCxwLGEscyksb3V0cHV0czpbe2RpbXM6ZCxkYXRhVHlwZTp1LGdwdURhdGFUeXBlOm8uR3B1RGF0YVR5cGUuZGVmYXVsdH1dLGRpc3BhdGNoR3JvdXA6KCk9Pih7eDpNYXRoLmNlaWwoZi82NC8oaD80OjEpKX0pfSl9KSh1LGVbMF0sZVsxXSxuLGEpfSl9O3QuYWRkPWU9PntlLmNvbXB1dGUoYShlLmlucHV0cyxcIkFkZFwiLCgoZSx0KT0+YCR7ZX0rJHt0fWApKSl9LHQuZGl2PWU9PntlLmNvbXB1dGUoYShlLmlucHV0cyxcIkRpdlwiLCgoZSx0KT0+YCR7ZX0vJHt0fWApKSl9LHQubXVsPWU9PntlLmNvbXB1dGUoYShlLmlucHV0cyxcIk11bFwiLCgoZSx0KT0+YCR7ZX0qJHt0fWApKSl9LHQucG93PWU9PntlLmNvbXB1dGUoYShlLmlucHV0cyxcIlBvd1wiLHtzY2FsYXI6KGUsdCk9PmBwb3dfZjMyKCR7ZX0sJHt0fSlgLHZlY3RvcjooZSx0KT0+YHBvd192ZjMyKCR7ZX0sJHt0fSlgfSxcIlxcbiAgICBmbiBwb3dfZjMyKGEgOiBmMzIsIGIgOiBmMzIpIC0+IGYzMiB7XFxuICAgICAgaWYgKGIgPT0gMC4wKSB7XFxuICAgICAgICByZXR1cm4gMS4wO1xcbiAgICAgIH0gZWxzZSBpZiAoYSA8IDAuMCAmJiBiICE9IGZsb29yKGIpKSB7XFxuICAgICAgICByZXR1cm4gcG93KGEsIGIpOyAvLyBOYU5cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHNlbGVjdChzaWduKGEpLCAxLjAsIHJvdW5kKGFicyhiKSAlIDIuMCkgIT0gMS4wKSAqIHBvdyhhYnMoYSksIGIpO1xcbiAgICB9XFxuICAgIGZuIHBvd192ZjMyKGEgOiB2ZWM0PGYzMj4sIGIgOiB2ZWM0PGYzMj4pIC0+IHZlYzQ8ZjMyPiB7XFxuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHZlY3Rvcml6ZWQgcG93XFxuICAgICAgcmV0dXJuIHZlYzQ8ZjMyPihwb3dfZjMyKGEueCwgYi54KSwgcG93X2YzMihhLnksIGIueSksIHBvd19mMzIoYS56LCBiLnopLCBwb3dfZjMyKGEudywgYi53KSk7XFxuICAgIH1cXG4gICAgICBcIikpfSx0LnN1Yj1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHMsXCJTdWJcIiwoKGUsdCk9PmAke2V9LSR7dH1gKSkpfX0sMjA3NTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5jcmVhdGVTaGFkZXJIZWxwZXI9dC5jcmVhdGVJbmRpY2VzSGVscGVyPXQuV09SS0dST1VQX1NJWkU9dm9pZCAwO2NvbnN0IHI9big2OTUyKTt0LldPUktHUk9VUF9TSVpFPTY0LHQuY3JlYXRlSW5kaWNlc0hlbHBlcj0oZSx0KT0+e2NvbnN0IG49dC5sZW5ndGg8Mj9cInUzMlwiOmBhcnJheTx1MzIsICR7dC5sZW5ndGh9PmAsbz1yLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyh0KTtsZXQgaT1cIlwiO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGgtMTtlKyspaSs9YFxcbiAgICBsZXQgZGltJHtlfSA9IGN1cnJlbnQgLyAke29bZV19dTtcXG4gICAgbGV0IHJlc3Qke2V9ID0gY3VycmVudCAlICR7b1tlXX11O1xcbiAgICAoKmluZGljZXMpWyR7ZX1dID0gZGltJHtlfTtcXG4gICAgY3VycmVudCA9IHJlc3Qke2V9O1xcbiAgICBgO2krPWAoKmluZGljZXMpWyR7dC5sZW5ndGgtMX1dID0gY3VycmVudDtgO2NvbnN0IGE9dC5sZW5ndGg8Mj9cIlwiOmBcXG4gIGZuIGloX28yaV8ke2V9KG9mZnNldDogdTMyLCBpbmRpY2VzOiBwdHI8ZnVuY3Rpb24sICR7bn0+KSB7XFxuICAgIHZhciBjdXJyZW50ID0gb2Zmc2V0O1xcbiAgICAke2l9XFxuICB9YCxzPVtdO2lmKDA9PT10Lmxlbmd0aClzLnB1c2goXCIwdVwiKTtlbHNlIGlmKHQubGVuZ3RoPDIpcy5wdXNoKFwiKCppbmRpY2VzKVwiKTtlbHNlIGZvcihsZXQgZT10Lmxlbmd0aC0xO2U+PTA7ZS0tKXMucHVzaChgJHtvW2VdfXUgKiAoKCppbmRpY2VzKVske2V9XSlgKTtyZXR1cm57bzJpSW1wbDphLG8yaUNhbGw6KG4scik9PnQubGVuZ3RoPDI/YCR7cn09JHtufTtgOmBpaF9vMmlfJHtlfSgke259LCAmJHtyfSk7YCxpMm9JbXBsOnQubGVuZ3RoPDI/XCJcIjpgXFxuICBmbiBpaF9pMm9fJHtlfShpbmRpY2VzOiBwdHI8ZnVuY3Rpb24sICR7bn0+KSAtPiB1MzIge1xcbiAgICByZXR1cm4gJHtzLmpvaW4oXCIrXCIpfTtcXG4gIH1gLGkyb0V4cHJlc3Npb246KG4scik9PnQubGVuZ3RoPDI/YCgke3I/XCIqXCI6XCJcIn0ke259KWA6YGloX2kyb18ke2V9KCR7cj9cIlwiOlwiJlwifSR7bn0pYCxpbmRpY2VzVmFyaWFibGVEZWNsYXJhdGlvbjooZSx0KT0+YHZhciAke2V9OiR7bn0ke3Q/YD0ke259KCR7dC5qb2luKFwiLFwiKX0pYDpcIlwifTtgLGlUeXBlOm59fTtjbGFzcyBve2NvbnN0cnVjdG9yKGUpe3RoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXA9ZX1ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGUpe3JldHVybmBpZiAoZ2xvYmFsX2lkeCA+PSAke1wibnVtYmVyXCI9PXR5cGVvZiBlP2Ake2V9dWA6ZX0pIHsgcmV0dXJuOyB9YH1tYWluU3RhcnQoZT10LldPUktHUk9VUF9TSVpFKXtjb25zdCBuPVwibnVtYmVyXCI9PXR5cGVvZiBlP2U6ZVswXSxyPVwibnVtYmVyXCI9PXR5cGVvZiBlPzE6ZVsxXSxvPVwibnVtYmVyXCI9PXR5cGVvZiBlPzE6ZVsyXSxpPTE9PT10aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdJiYxPT09dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsyXTtyZXR1cm5gQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7bn0sICR7cn0sICR7b30pXFxuICBmbiBtYWluKCR7aT9cIkBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxfaWQgOiB2ZWMzPHUzMj5cIjpcIkBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2luZGV4IDogdTMyLFxcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPlwifSkge1xcbiAgICAke2k/XCJsZXQgZ2xvYmFsX2lkeCA9IGdsb2JhbF9pZC54O1wiOmBsZXQgZ2xvYmFsX2lkeCA9ICh3b3JrZ3JvdXBfaWQueiAqICR7dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFswXSp0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdfXUgK1xcbiAgICAgICAgICB3b3JrZ3JvdXBfaWQueSAqICR7dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFswXX11ICsgd29ya2dyb3VwX2lkLngpICogJHtuKnIqb311ICsgbG9jYWxfaW5kZXg7YH1cXG4gIGB9fXQuY3JlYXRlU2hhZGVySGVscGVyPWU9Pm5ldyBvKGUpfSw5MTkyOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNyZWF0ZUdyb3VwZWRDb252UHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9big2OTUyKSxvPW4oMTE2MyksaT1uKDIwNzUpLGE9big5NzcwKSxzPW4oMzk5Nyk7dC5jcmVhdGVHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyPShlLHQsbik9Pntjb25zdCB1PShsPWUubGVuZ3RoPjIsYz10LmNhY2hlS2V5LHtuYW1lOlwiR3JvdXBlZENvbnZcIixpbnB1dFR5cGVzOmw/W28uR3B1RGF0YVR5cGUuZGVmYXVsdCxvLkdwdURhdGFUeXBlLmRlZmF1bHQsby5HcHVEYXRhVHlwZS5kZWZhdWx0XTpbby5HcHVEYXRhVHlwZS5kZWZhdWx0LG8uR3B1RGF0YVR5cGUuZGVmYXVsdF0sY2FjaGVIaW50OmN9KTt2YXIgbCxjO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse2dldDooKT0+KChlLHQsbix1KT0+e2NvbnN0IGw9ZS5sZW5ndGg+MixjPWw/XCJ2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTtcIjpcIlwiLHA9ZVswXS5kaW1zLGQ9ZVsxXS5kaW1zLGY9ZFswXS9uLmdyb3VwLGg9XCJmMzJcIix7YWN0aXZhdGlvbkZ1bmN0aW9uOmcsYXBwbHlBY3RpdmF0aW9uOm19PSgwLHMuZ2V0QWN0aWNhdGlvblNuaXBwZXQpKG4pLGI9W2BAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHggOiBhcnJheTwke2h9PjtgLGBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHcgOiBhcnJheTwke2h9PjtgXTtsJiZiLnB1c2goYEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZD4gYiA6IGFycmF5PCR7aH0+O2ApO2NvbnN0IHk9XCJOSFdDXCI9PT1uLmZvcm1hdCx3PSgwLGEuY2FsY3VsYXRlT3V0cHV0U2hhcGUpKHAsZCxuLmRpbGF0aW9ucyxuLnBhZHMsbi5zdHJpZGVzLHkpLF89ci5TaGFwZVV0aWwuc2l6ZSh3KSx2PSgwLGkuY3JlYXRlSW5kaWNlc0hlbHBlcikoXCJvdXRwdXRcIix3KSx4PSgwLGkuY3JlYXRlSW5kaWNlc0hlbHBlcikoXCJ4XCIscCksVD0oMCxpLmNyZWF0ZUluZGljZXNIZWxwZXIpKFwid1wiLGQpO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dHM6W3tkaW1zOnU/dSh3KTp3LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6by5HcHVEYXRhVHlwZS5kZWZhdWx0fV0sZ2V0U2hhZGVyU291cmNlOmU9PmBcXG4gIGNvbnN0IHN0cmlkZXM6IHZlYzI8dTMyPiA9IHZlYzIoJHtuLnN0cmlkZXNbMF19dSwgJHtuLnN0cmlkZXNbMV19dSk7XFxuICBjb25zdCBwYWRzOiB2ZWMyPHUzMj4gPSB2ZWMyKCR7bi5wYWRzWzBdfXUsICR7bi5wYWRzWzFdfXUpO1xcblxcbiAgJHtiLmpvaW4oXCJcXG5cIil9XFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtiLmxlbmd0aH0pIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke2h9PjtcXG5cXG4gICR7Z31cXG4gICR7di5vMmlJbXBsfVxcbiAgJHt4Lmkyb0ltcGx9XFxuICAke1QuaTJvSW1wbH1cXG5cXG4gICR7ZS5tYWluU3RhcnQoKX1cXG4gICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXyl9XFxuXFxuICAgICR7di5pbmRpY2VzVmFyaWFibGVEZWNsYXJhdGlvbihcIm91dHB1dEluZGljZXNcIil9XFxuICAgICR7di5vMmlDYWxsKFwiZ2xvYmFsX2lkeFwiLFwib3V0cHV0SW5kaWNlc1wiKX1cXG4gICAgbGV0IGJhdGNoOiB1MzIgPSBvdXRwdXRJbmRpY2VzWzBdO1xcbiAgICBsZXQgb3V0cHV0X2NoYW5uZWw6IHUzMiA9IG91dHB1dEluZGljZXNbJHt5PzM6MX1dO1xcbiAgICBsZXQgeFJDQ29ybmVyOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4ob3V0cHV0SW5kaWNlc1ske3k/MToyfV0sIG91dHB1dEluZGljZXNbJHt5PzI6M31dKSAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICBsZXQgZ3JvdXBfaWQ6IHUzMiA9IG91dHB1dF9jaGFubmVsIC8gJHtmfXU7XFxuXFxuICAgIHZhciB2YWx1ZTogJHtofSA9ICR7aH0oMCk7XFxuICAgIGZvciAodmFyIHdJbkNoYW5uZWw6IHUzMiA9IDB1OyB3SW5DaGFubmVsIDwgJHtkWzFdfXU7IHdJbkNoYW5uZWwrKykge1xcbiAgICAgIGxldCBpbnB1dF9jaGFubmVsID0gZ3JvdXBfaWQgKiAke2RbMV19dSArIHdJbkNoYW5uZWw7XFxuICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCAke2RbMl19dTsgd0hlaWdodCsrKSB7XFxuICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqICR7bi5kaWxhdGlvbnNbMF19dTtcXG5cXG4gICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSAke3BbeT8xOjJdfXUpIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCAke2RbM119dTsgd1dpZHRoKyspIHtcXG4gICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogJHtuLmRpbGF0aW9uc1sxXX11O1xcbiAgICAgICAgICBpZiAoeFdpZHRoIDwgMHUgfHwgeFdpZHRoID49ICR7cFt5PzI6M119dSkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgICR7eC5pbmRpY2VzVmFyaWFibGVEZWNsYXJhdGlvbihcInhJbmRpY2VzXCIseT9bXCJiYXRjaFwiLFwieEhlaWdodFwiLFwieFdpZHRoXCIsXCJpbnB1dF9jaGFubmVsXCJdOltcImJhdGNoXCIsXCJpbnB1dF9jaGFubmVsXCIsXCJ4SGVpZ2h0XCIsXCJ4V2lkdGhcIl0pfVxcbiAgICAgICAgICBsZXQgeFZhbCA9IHhbJHt4Lmkyb0V4cHJlc3Npb24oXCJ4SW5kaWNlc1wiKX1dO1xcbiAgICAgICAgICAke1QuaW5kaWNlc1ZhcmlhYmxlRGVjbGFyYXRpb24oXCJ3SW5kaWNlc1wiLFtcIm91dHB1dF9jaGFubmVsXCIsXCJ3SW5DaGFubmVsXCIsXCJ3SGVpZ2h0XCIsXCJ3V2lkdGhcIl0pfVxcbiAgICAgICAgICBsZXQgd1ZhbCA9IHdbJHtULmkyb0V4cHJlc3Npb24oXCJ3SW5kaWNlc1wiKX1dO1xcbiAgICAgICAgICB2YWx1ZSArPSB4VmFsKndWYWw7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgICR7Y31cXG4gICAgJHttfVxcbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcXG4gIH1gLGRpc3BhdGNoR3JvdXA6KCk9Pih7eDpNYXRoLmNlaWwoXy82NCl9KX0pfSkoZSx1LHQsbil9KX19LDk3NzA6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY29udj10LnBhcnNlQ29udkF0dHJpYnV0ZXM9dC5jYWxjdWxhdGVPdXRwdXRTaGFwZT12b2lkIDA7Y29uc3Qgcj1uKDY5NTIpLG89bigzODcpLGk9big5MTkyKSxhPW4oMzgyMikscz1uKDM5OTcpLHU9bigyNjI1KTt0LmNhbGN1bGF0ZU91dHB1dFNoYXBlPShlLHQsbixyLG8saSk9Pntjb25zdCBhPWVbMF0scz1lLnNsaWNlKGk/MToyLGk/Mzo0KSx1PXMubGVuZ3RoLGw9dFswXSxjPXQuc2xpY2UoMikubWFwKCgoZSx0KT0+ZSsoZS0xKSooblt0XS0xKSkpLHA9cy5tYXAoKChlLHQpPT5lK3JbdF0rclt0K3VdKSkubWFwKCgoZSx0KT0+TWF0aC5mbG9vcigoZS1jW3RdK29bdF0pL29bdF0pKSk7cmV0dXJuIHAuc3BsaWNlKDAsMCxhKSxwLnNwbGljZShpPzM6MSwwLGwpLHB9O2NvbnN0IGw9KDAsby5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtwZXJtOlsyLDMsMSwwXX0pLGM9KGUsdCk9Pntjb25zdCBuPWUua2VybmVsU2hhcGUuc2xpY2UoKTtmb3IobGV0IGU9MjtlPHRbMV0uZGltcy5sZW5ndGg7KytlKTA9PT1uW2UtMl0mJihuW2UtMl09dFsxXS5kaW1zW2VdKTtjb25zdCBvPWUucGFkcy5zbGljZSgpO3IuUG9vbENvbnZVdGlsLmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0WzBdLmRpbXMsZS5zdHJpZGVzLGUuZGlsYXRpb25zLG4sbyxcIk5IV0NcIj09PWUuZm9ybWF0LGUuYXV0b1BhZCk7Y29uc3QgaT1PYmplY3QuYXNzaWduKHt9LGUpO3JldHVybiBPYmplY3QuYXNzaWduKGkse2tlcm5lbFNoYXBlOm4scGFkczpvLGNhY2hlS2V5OmUuY2FjaGVLZXl9KSxpfTt0LnBhcnNlQ29udkF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9KDAscy5wYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpKGUpLG49ZS5mb3JtYXQscj1bXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW2UuYXV0b19wYWRdLGk9ZS5kaWxhdGlvbnMsYT1lLmdyb3VwLHU9ZS5rZXJuZWxfc2hhcGUsbD1lLnBhZHMsYz1lLnN0cmlkZXMscD1lLndfaXNfY29uc3QoKTtyZXR1cm4oMCxvLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoT2JqZWN0LmFzc2lnbih7YXV0b1BhZDpyLGZvcm1hdDpuLGRpbGF0aW9uczppLGdyb3VwOmEsa2VybmVsU2hhcGU6dSxwYWRzOmwsc3RyaWRlczpjLHdJc0NvbnN0OnB9LHQpKX0sdC5jb252PShlLG4pPT57KChlLHQpPT57aWYoIWV8fDIhPT1lLmxlbmd0aCYmMyE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZig0IT09ZVswXS5kaW1zLmxlbmd0aCYmMyE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG9ubHkgc3VwcG9ydCBjb252IDFEIGFuZCAyRFwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtpZihlWzBdLmRpbXNbXCJOSFdDXCI9PT10LmZvcm1hdD9lWzBdLmRpbXMubGVuZ3RoLTE6MV0hPT1lWzFdLmRpbXNbMV0qdC5ncm91cCl0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2lmKDM9PT1lLmxlbmd0aCYmKDEhPT1lWzJdLmRpbXMubGVuZ3RofHxlWzFdLmRpbXNbMF0hPT1lWzJdLmRpbXNbMF0pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmlhc1wiKTtjb25zdCBuPWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke259RGApO2lmKHQuc3RyaWRlcy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtufURgKTtpZih0LnBhZHMubGVuZ3RoIT09MipuKXRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHsyKm59RGApO2lmKDAhPT10Lmtlcm5lbFNoYXBlLmxlbmd0aCYmdC5rZXJuZWxTaGFwZS5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXJuZWwgc2hhcGVcIik7aWYoMSE9PWVbMF0uZGF0YVR5cGV8fDEhPT1lWzFdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIkNvbnYgaW5wdXQoWCxXKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpO2lmKDM9PT1lLmxlbmd0aCYmMSE9PWVbMl0uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ29udiBpbnB1dChiaWFzKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfSkoZS5pbnB1dHMsbiksMz09PWUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPygoZSx0KT0+e2NvbnN0IG49XCJOSFdDXCI9PT10LmZvcm1hdCxyPVtlLmlucHV0c1swXS5yZXNoYXBlKG4/W2UuaW5wdXRzWzBdLmRpbXNbMF0sMSxlLmlucHV0c1swXS5kaW1zWzFdLGUuaW5wdXRzWzBdLmRpbXNbMl1dOltlLmlucHV0c1swXS5kaW1zWzBdLGUuaW5wdXRzWzBdLmRpbXNbMV0sMSxlLmlucHV0c1swXS5kaW1zWzJdXSksZS5pbnB1dHNbMV0ucmVzaGFwZShbZS5pbnB1dHNbMV0uZGltc1swXSxlLmlucHV0c1sxXS5kaW1zWzFdLDEsZS5pbnB1dHNbMV0uZGltc1syXV0pXTszPT09ZS5pbnB1dHMubGVuZ3RoJiZyLnB1c2goZS5pbnB1dHNbMl0pO2NvbnN0IG89WzAsdC5wYWRzWzBdLDAsdC5wYWRzWzFdXSxhPVsxXS5jb25jYXQodC5zdHJpZGVzKSxzPVsxXS5jb25jYXQodC5kaWxhdGlvbnMpLHU9WzFdLmNvbmNhdCh0Lmtlcm5lbFNoYXBlKSxsPWMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtwYWRzOm8sc3RyaWRlczphLGRpbGF0aW9uczpzLGtlcm5lbFNoYXBlOnV9KSxyKTtlLmNvbXB1dGUoKDAsaS5jcmVhdGVHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyKShyLGwsKGU9Pm4/W2VbMF0sZVsyXSxlWzNdXTpbXSkpKX0pKGUsbik6KChlLG4scik9Pnt2YXIgbztjb25zdCBzPWMocixuKSxwPTM9PT1uLmxlbmd0aCxkPVwiTkhXQ1wiPT09ci5mb3JtYXQsZj1uWzBdLmRpbXNbZD8xOjJdLGg9blswXS5kaW1zW2Q/MjozXSxnPW5bMF0uZGltc1tkPzM6MV0sbT1uWzFdLmRpbXNbMl0sYj1uWzFdLmRpbXNbM10seT0oMCx0LmNhbGN1bGF0ZU91dHB1dFNoYXBlKShuWzBdLmRpbXMsblsxXS5kaW1zLHIuZGlsYXRpb25zLHMucGFkcyxyLnN0cmlkZXMsZCksdz15W2Q/MToyXSxfPXlbZD8yOjNdLHY9eVtkPzM6MV07aWYoZCYmbT09PWYmJmI9PT1oJiZcIlZBTElEXCI9PT1yLmF1dG9QYWR8fDE9PT1tJiYxPT09YiYmMT09PXIuZGlsYXRpb25zWzBdJiYxPT09ci5kaWxhdGlvbnNbMV0mJjE9PT1yLnN0cmlkZXNbMF0mJjE9PT1yLnN0cmlkZXNbMV0mJihcIlNBTUVfVVBQRVJcIj09PXIuYXV0b1BhZHx8XCJTQU1FX0xPV0VSXCI9PT1yLmF1dG9QYWR8fFwiVkFMSURcIj09PXIuYXV0b1BhZCkpcmV0dXJuIHZvaWQgZS5jb21wdXRlKCgwLGkuY3JlYXRlR3JvdXBlZENvbnZQcm9ncmFtSW5mb0xvYWRlcikobixzKSk7aWYoIWR8fDEhPT1yLmdyb3VwKXJldHVybiB2b2lkIGUuY29tcHV0ZSgoMCxpLmNyZWF0ZUdyb3VwZWRDb252UHJvZ3JhbUluZm9Mb2FkZXIpKG4scykpO2NvbnN0IHg9ZD93Kl86dixUPWQ/djp3Kl8sUz1tKmIqZyxPPW51bGwhPT0obz1lLmN1c3RvbURhdGEud1QpJiZ2b2lkIDAhPT1vP286ZS5jb21wdXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1LnRyYW5zcG9zZVByb2dyYW1NZXRhZGF0YSkse2NhY2hlSGludDpsLmNhY2hlS2V5LGdldDooKT0+KDAsdS5jcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbykoblsxXSxsLnBlcm0pfSkse2lucHV0czpbMV0sb3V0cHV0czpbci53SXNDb25zdD8tMjotMV19KVswXTtyLndJc0NvbnN0JiYhZS5jdXN0b21EYXRhLndUJiYoZS5jdXN0b21EYXRhLndUPU8pO2NvbnN0IEE9W25bMF0sT107cCYmKGR8fDEhPT1uWzJdLmRpbXMubGVuZ3RoP0EucHVzaChuWzJdKTpBLnB1c2goblsyXS5yZXNoYXBlKFtuWzJdLmRpbXNbMF0sMSwxXSkpKSxlLmNvbXB1dGUoKDAsYS5jcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mb0xvYWRlcikoQSxzLHkseCxULFMscCwhMCkse2lucHV0czpBfSl9KShlLGUuaW5wdXRzLG4pfX0sMzgyMjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5jcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDExNjMpLG89big5NDU2KTt0LmNyZWF0ZUNvbnYyRE1hdE11bFByb2dyYW1JbmZvTG9hZGVyPShlLHQsbixpLGEscyx1LGwpPT57Y29uc3QgYz0oKGUsdCk9Pih7bmFtZTpcIkNvbnYyRE1hdE11bFwiLGlucHV0VHlwZXM6ZT9bci5HcHVEYXRhVHlwZS5kZWZhdWx0LHIuR3B1RGF0YVR5cGUuZGVmYXVsdCxyLkdwdURhdGFUeXBlLmRlZmF1bHRdOltyLkdwdURhdGFUeXBlLmRlZmF1bHQsci5HcHVEYXRhVHlwZS5kZWZhdWx0XSxjYWNoZUhpbnQ6dH0pKSh1LHQuY2FjaGVLZXkpO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYykse2dldDooKT0+KDAsby5jcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mbykoZSxjLHQsbixpLGEscyx1LGwpfSl9fSwzOTk3OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcz10LmdldEFjdGljYXRpb25TbmlwcGV0PXZvaWQgMDtjb25zdCByPW4oNjk1Mik7dC5nZXRBY3RpY2F0aW9uU25pcHBldD1lPT57c3dpdGNoKGUuYWN0aXZhdGlvbil7Y2FzZVwiUmVsdVwiOnJldHVybnthY3RpdmF0aW9uRnVuY3Rpb246XCJcIixhcHBseUFjdGl2YXRpb246XCJ2YWx1ZSA9IG1heCh2YWx1ZSwgMC4wKTtcIn07Y2FzZVwiU2lnbW9pZFwiOnJldHVybnthY3RpdmF0aW9uRnVuY3Rpb246XCJcIixhcHBseUFjdGl2YXRpb246XCJ2YWx1ZSA9ICgxLjAgLyAoMS4wICsgZXhwKC12YWx1ZSkpKTtcIn07Y2FzZVwiQ2xpcFwiOnJldHVybnthY3RpdmF0aW9uRnVuY3Rpb246YGNvbnN0IGNsaXBfbWluXz1mMzIoJHtlLmNsaXBNaW59KTtjb25zdCBjbGlwX21heF89ZjMyKCR7ZS5jbGlwTWF4fSk7YCxhcHBseUFjdGl2YXRpb246XCJ2YWx1ZSA9IGNsYW1wKHZhbHVlLCBjbGlwX21pbl8sIGNsaXBfbWF4Xyk7XCJ9O2RlZmF1bHQ6cmV0dXJue2FjdGl2YXRpb25GdW5jdGlvbjpcIlwiLGFwcGx5QWN0aXZhdGlvbjpcIlwifX19LHQucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzPWU9Pntjb25zdCB0PShudWxsPT1lP3ZvaWQgMDplLmFjdGl2YXRpb24pfHxcIlwiO2lmKFwiQ2xpcFwiPT09dCl7Y29uc3RbbixvXT0obnVsbD09ZT92b2lkIDA6ZS5hY3RpdmF0aW9uX3BhcmFtcyl8fFtyLk1JTl9DTElQLHIuTUFYX0NMSVBdO3JldHVybnthY3RpdmF0aW9uOnQsY2xpcE1heDpvLGNsaXBNaW46bixhY3RpdmF0aW9uQ2FjaGVLZXk6YCR7dH06JHtufSwke299YH19cmV0dXJue2FjdGl2YXRpb246dCxhY3RpdmF0aW9uQ2FjaGVLZXk6dH19fSw0MjcxOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlR2VtbUF0dHJpYnV0ZXM9dC5nZW1tPXZvaWQgMDtjb25zdCByPW4oNjk1Miksbz1uKDM4NyksaT1uKDExNjMpO3QuZ2VtbT0oZSx0KT0+eyhlPT57aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbWlzc2luZ1wiKTtpZihlLmxlbmd0aDwyfHxlLmxlbmd0aD4zKXRocm93IG5ldyBFcnJvcihcIkludmFpZCBpbnB1dCBudW1iZXIuXCIpO2lmKDM9PT1lLmxlbmd0aCYmZVsyXS5kaW1zLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUgb2YgQ1wiKTtpZigxIT09ZVswXS5kYXRhVHlwZXx8MSE9PWVbMV0uZGF0YVR5cGV8fDM9PT1lLmxlbmd0aCYmMSE9PWVbMl0uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZihlWzBdLmRhdGFUeXBlIT09ZVsxXS5kYXRhVHlwZXx8Mz09PWUubGVuZ3RoJiZlWzBdLmRhdGFUeXBlIT09ZVsyXS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlcyBhcmUgbWlzbWF0Y2hlZFwiKX0pKGUuaW5wdXRzKSxlLmNvbXB1dGUoKChlLHQpPT57Y29uc3Qgbj17bmFtZTpcIkdlbW1cIixpbnB1dFR5cGVzOjM9PT1lLmxlbmd0aD9baS5HcHVEYXRhVHlwZS5kZWZhdWx0LGkuR3B1RGF0YVR5cGUuZGVmYXVsdCxpLkdwdURhdGFUeXBlLmRlZmF1bHRdOltpLkdwdURhdGFUeXBlLmRlZmF1bHQsaS5HcHVEYXRhVHlwZS5kZWZhdWx0XSxjYWNoZUhpbnQ6dC5jYWNoZUtleX07cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7Z2V0OigpPT4oKGUsdCxuKT0+e2NvbnN0IG89dFswXS5kaW1zLnNsaWNlKCksYT10WzFdLmRpbXMuc2xpY2UoKSxbcyx1LGxdPXIuR2VtbVV0aWwuZ2V0U2hhcGVPZkdlbW1SZXN1bHQobyxuLnRyYW5zQSxhLG4udHJhbnNCLDM9PT10Lmxlbmd0aD90WzJdLmRpbXM6dm9pZCAwKSxjPVtzLHVdO2lmKCFjKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2NvbnN0IHA9ci5TaGFwZVV0aWwuc2l6ZShjKTtsZXQgZD1cIlwiO24udHJhbnNBJiZuLnRyYW5zQj9kPVwidmFsdWUgKz0gYVtrICogTSArIG1dICogYltuICogSyArIGtdO1wiOm4udHJhbnNBJiYhbi50cmFuc0I/ZD1cInZhbHVlICs9IGFbayAqIE0gKyBtXSAqIGJbayAqIE4gKyBuXTtcIjohbi50cmFuc0EmJm4udHJhbnNCP2Q9XCJ2YWx1ZSArPSBhW20gKiBLICsga10gKiBiW24gKiBLICsga107XCI6bi50cmFuc0F8fG4udHJhbnNCfHwoZD1cInZhbHVlICs9IGFbbSAqIEsgKyBrXSAqIGJbayAqIE4gKyBuXTtcIik7Y29uc3QgZj1cImYzMlwiLGg9MT09PW4uYWxwaGE/XCJcIjpcInZhbHVlICo9IGFscGhhO1wiLGc9Mz09PXQubGVuZ3RoP2B2YWx1ZSArPSBiZXRhICogY1skeygoZSx0LG4pPT57aWYoMD09PW4ubGVuZ3RoKXJldHVyblwiMHVcIjtjb25zdCByPTE9PT1uLmxlbmd0aCYmMSE9PWV8fDI9PT1uLmxlbmd0aCYmblswXSE9PWUsbz1uW24ubGVuZ3RoLTFdIT09dDtsZXQgaT1cIjB1XCI7cmV0dXJuIHJ8fChpKz1gKyBtICogJHtuW24ubGVuZ3RoLTFdfXVgKSxvfHwoaSs9XCIrblwiKSxpfSkocyx1LHRbMl0uZGltcyl9XTtgOlwiXCIsbT1bYEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gYSA6IGFycmF5PCR7Zn0+O2AsYEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gYiA6IGFycmF5PCR7Zn0+O2BdO3JldHVybiAzPT09dC5sZW5ndGgmJm0ucHVzaChgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkPiBjIDogYXJyYXk8JHtmfT47YCksT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXRzOlt7ZGltczpjLGRhdGFUeXBlOnRbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6aS5HcHVEYXRhVHlwZS5kZWZhdWx0fV0sZ2V0U2hhZGVyU291cmNlOmU9PmBcXG4gIGNvbnN0IE06IHUzMiA9ICR7c311O1xcbiAgY29uc3QgTjogdTMyID0gJHt1fXU7XFxuICBjb25zdCBLOiB1MzIgPSAke2x9dTtcXG4gIGNvbnN0IGFscGhhID0gJHtmfSgke24uYWxwaGF9KTtcXG4gIGNvbnN0IGJldGEgPSAke2Z9KCR7bi5iZXRhfSk7XFxuXFxuICAke20uam9pbihcIlxcblwiKX1cXG4gIEBncm91cCgwKSBAYmluZGluZygke3QubGVuZ3RofSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7Zn0+O1xcblxcbiAgJHtlLm1haW5TdGFydCgpfVxcbiAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhwKX1cXG5cXG4gICAgbGV0IG0gPSBnbG9iYWxfaWQueCAvIE47XFxuICAgIGxldCBuID0gZ2xvYmFsX2lkLnggJSBOO1xcblxcbiAgICB2YXIgdmFsdWUgPSAke2Z9KDApO1xcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgazwke2x9dTsgaysrKSB7XFxuICAgICAgJHtkfVxcbiAgICB9XFxuXFxuICAgICR7aH1cXG4gICAgJHtnfVxcbiAgICBvdXRwdXRbZ2xvYmFsX2lkLnhdID0gdmFsdWU7XFxuXFxuICB9YCxkaXNwYXRjaEdyb3VwOigpPT4oe3g6TWF0aC5jZWlsKHAvNjQpfSl9KX0pKG4sZSx0KX0pfSkoZS5pbnB1dHMsdCkpfSx0LnBhcnNlR2VtbUF0dHJpYnV0ZXM9ZT0+KDAsby5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKGUpfSwxNTIyOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lm1hdE11bD10LmNyZWF0ZU1hdG11bFByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNjk1Miksbz1uKDExNjMpLGk9bigzOTk3KTt0LmNyZWF0ZU1hdG11bFByb2dyYW1JbmZvTG9hZGVyPShlLHQpPT57Y29uc3Qgbj0oYT1lLmxlbmd0aD4yLHM9dC5hY3RpdmF0aW9uQ2FjaGVLZXkse25hbWU6XCJNYXRNdWxcIixpbnB1dFR5cGVzOmE/W28uR3B1RGF0YVR5cGUuZGVmYXVsdCxvLkdwdURhdGFUeXBlLmRlZmF1bHQsby5HcHVEYXRhVHlwZS5kZWZhdWx0XTpbby5HcHVEYXRhVHlwZS5kZWZhdWx0LG8uR3B1RGF0YVR5cGUuZGVmYXVsdF0sY2FjaGVIaW50OnN9KTt2YXIgYSxzO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+KChlLHQsbik9Pntjb25zdCBhPXRbMF0uZGltcyxzPXRbMV0uZGltcyx1PXIuQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoYSxzLCEwKTtpZighdSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2NvbnN0IGw9ci5TaGFwZVV0aWwuc2l6ZSh1KSxjPVwiZjMyXCIse2FjdGl2YXRpb25GdW5jdGlvbjpwLGFwcGx5QWN0aXZhdGlvbjpkfT0oMCxpLmdldEFjdGljYXRpb25TbmlwcGV0KShuKSxmPXVbdS5sZW5ndGgtMl0saD1hW2EubGVuZ3RoLTFdLGc9dVt1Lmxlbmd0aC0xXTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXRzOlt7ZGltczp1LGRhdGFUeXBlOnRbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6by5HcHVEYXRhVHlwZS5kZWZhdWx0fV0sZ2V0U2hhZGVyU291cmNlOmU9PmBcXG4gIGNvbnN0IE06IHUzMiA9ICR7Zn11O1xcbiAgY29uc3QgTjogdTMyID0gJHtnfXU7XFxuICBjb25zdCBLOiB1MzIgPSAke2h9dTtcXG5cXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gYSA6IGFycmF5PCR7Y30+O1xcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBiIDogYXJyYXk8JHtjfT47XFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7Y30+O1xcblxcbiAgJHtwfVxcblxcbiAgJHtlLm1haW5TdGFydCgpfVxcbiAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhsKX1cXG5cXG4gICAgbGV0IHN0YWNrID0gZ2xvYmFsX2lkeCAvIChNICogTik7XFxuICAgIGxldCBtbiA9IGdsb2JhbF9pZHggJSAoTSAqIE4pO1xcbiAgICBsZXQgbiA9IGdsb2JhbF9pZHggJSBOO1xcbiAgICBsZXQgbSA9IG1uIC8gTjtcXG5cXG4gICAgbGV0IG9mZnNldEEgPSBzdGFjayAqIChNICogSyk7XFxuICAgIGxldCBvZmZzZXRCID0gc3RhY2sgKiAoSyAqIE4pO1xcblxcbiAgICB2YXIgdmFsdWUgPSAke2N9KDApO1xcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgazwke2h9dTsgaysrKSB7XFxuICAgICAgdmFsdWUgKz0gYVtvZmZzZXRBICsgbSAqIEsgKyBrXSAqIGJbb2Zmc2V0QiArIGsgKiBOICsgbl07XFxuICAgIH1cXG4gICAgJHtkfVxcbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcXG4gIH1gLGRpc3BhdGNoR3JvdXA6KCk9Pih7eDpNYXRoLmNlaWwobC82NCl9KX0pfSkobixlLHQpfSl9LHQubWF0TXVsPWU9PnsoZT0+e2lmKCFlfHwyIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTWF0TXVsIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRpbXNbZVswXS5kaW1zLmxlbmd0aC0xXSE9PWVbMV0uZGltc1tlWzFdLmRpbXMubGVuZ3RoLTJdKXRocm93IG5ldyBFcnJvcihcInNoYXJlZCBkaW1lbnNpb24gZG9lcyBub3QgbWF0Y2guXCIpO2lmKDEhPT1lWzBdLmRhdGFUeXBlfHwxIT09ZVsxXS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dHMgc2hvdWxkIGJlIGZsb2F0IHR5cGVcIil9KShlLmlucHV0cyksZS5jb21wdXRlKCgwLHQuY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIpKGUuaW5wdXRzLHthY3RpdmF0aW9uOlwiXCIsYWN0aXZhdGlvbkNhY2hlS2V5OlwiXCJ9KSl9fSw1MjYyOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lmdsb2JhbE1heFBvb2w9dC5wYXJzZUdsb2JhbE1heFBvb2xBdHRyaWJ1dGVzPXQucGFyc2VNYXhQb29sQXR0cmlidXRlcz10Lm1heFBvb2w9dC5nbG9iYWxBdmVyYWdlUG9vbD10LnBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzPXQuYXZlcmFnZVBvb2w9dC5wYXJzZUF2ZXJhZ2VQb29sQXR0cmlidXRlcz12b2lkIDA7Y29uc3Qgcj1uKDY5NTIpLG89bigzODcpLGk9bigxMTYzKSxhPW4oMjA3NSkscz1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJQb29sIG9wcyByZXF1aXJlcyAxIGlucHV0LlwiKTtpZig0IT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJQb29sIG9wcyBzdXBwb3J0cyAyLUQgaW5wdXRzIG9ubHkgZm9yIG5vdy5cIik7aWYoMSE9PWVbMF0uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0sdT0oZSx0LG4pPT57Y29uc3Qgbz1cIk5IV0NcIj09PXQuZm9ybWF0LGk9bz9bZVswXS5kaW1zWzBdLGVbMF0uZGltc1szXSxlWzBdLmRpbXNbMV0sZVswXS5kaW1zWzJdXTplWzBdLmRpbXMuc2xpY2UoKSxhPU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsXCJkaWxhdGlvbnNcIikscz10Lmtlcm5lbFNoYXBlLnNsaWNlKCksdT10LnN0cmlkZXMuc2xpY2UoKSxsPWE/dC5kaWxhdGlvbnMuc2xpY2UoKTpbXSxjPXQucGFkcy5zbGljZSgpO3IuUG9vbENvbnZVdGlsLmFkanVzdFBvb2xBdHRyaWJ1dGVzKG4saSxzLHUsbCxjKTtjb25zdCBwPXIuUG9vbENvbnZVdGlsLmNvbXB1dGVQb29sT3V0cHV0U2hhcGUobixpLHUsbCxzLGMsdC5hdXRvUGFkKSxkPU9iamVjdC5hc3NpZ24oe30sdCk7cmV0dXJuIGE/T2JqZWN0LmFzc2lnbihkLHtrZXJuZWxTaGFwZTpzLHN0cmlkZXM6dSxwYWRzOmMsZGlsYXRpb25zOmwsY2FjaGVLZXk6dC5jYWNoZUtleX0pOk9iamVjdC5hc3NpZ24oZCx7a2VybmVsU2hhcGU6cyxzdHJpZGVzOnUscGFkczpjLGNhY2hlS2V5OnQuY2FjaGVLZXl9KSxbZCxvP1twWzBdLHBbMl0scFszXSxwWzFdXTpwXX0sbD0oZSx0LG4sbyxpLHMsdSxsKT0+e2NvbnN0IGM9XCJOSFdDXCI9PT1vLmZvcm1hdCxwPXQubGVuZ3RoLGQ9ci5TaGFwZVV0aWwuc2l6ZShuKSxmPSgwLGEuY3JlYXRlSW5kaWNlc0hlbHBlcikoXCJvdXRwdXRcIixuKSxoPSgwLGEuY3JlYXRlSW5kaWNlc0hlbHBlcikoXCJ4XCIsdCk7aWYoby5rZXJuZWxTaGFwZS5sZW5ndGg8PTIpe2NvbnN0IG49by5rZXJuZWxTaGFwZVtvLmtlcm5lbFNoYXBlLmxlbmd0aC0xXSxyPW8uc3RyaWRlc1tvLnN0cmlkZXMubGVuZ3RoLTFdLGE9by5wYWRzW28ucGFkcy5sZW5ndGgvMi0xXSxnPXAtKGM/MjoxKTtsZXQgbT1cIlwiLGI9XCJcIix5PVwiXCI7aWYobT1hK28ucGFkc1tvLnBhZHMubGVuZ3RoLTFdIT09MD9gXFxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7bn11OyBpKyspIHtcXG4gICAgICAgICAgICAgICAgeEluZGljZXNbJHtnfV0gPSBpbmRpY2VzWyR7Z31dICogJHtyfSAtICR7YX0gKyBpO1xcbiAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtnfV0gPCAwIHx8IHhJbmRpY2VzWyR7Z31dID49ICR7dFtnXX0pIHtcXG4gICAgICAgICAgICAgICAgICBwYWQrKztcXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7aC5pMm9FeHByZXNzaW9uKFwieEluZGljZXNcIil9XTtcXG4gICAgICAgICAgICAgICAgJHtpfVxcbiAgICAgICAgICAgICAgfWA6YFxcbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke259dTsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7Z31dID0gaW5kaWNlc1ske2d9XSAqICR7cn0gLSAke2F9ICsgaTtcXG4gICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske2guaTJvRXhwcmVzc2lvbihcInhJbmRpY2VzXCIpfV07XFxuICAgICAgICAgICAgICAgICR7aX1cXG4gICAgICAgICAgICAgIH1gLDI9PT1vLmtlcm5lbFNoYXBlLmxlbmd0aCl7Y29uc3QgZT1vLmtlcm5lbFNoYXBlW28ua2VybmVsU2hhcGUubGVuZ3RoLTJdLHI9by5zdHJpZGVzW28uc3RyaWRlcy5sZW5ndGgtMl0saT1vLnBhZHNbby5wYWRzLmxlbmd0aC8yLTJdLGE9by5wYWRzW28ucGFkcy5sZW5ndGgtMl0scz1wLShjPzM6MiksdT10W3NdO2I9aSthIT09MD9gXFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgJHtlfXU7IGorKykge1xcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7c31dID0gaW5kaWNlc1ske3N9XSAqICR7cn0gLSAke2l9ICsgajtcXG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtzfV0gPCAwIHx8IHhJbmRpY2VzWyR7c31dID49ICR7dX0pIHtcXG4gICAgICAgICAgICAgICAgICAgIHBhZCs9ICR7bn07XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBgOmBcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCAke2V9dTsgaisrKSB7XFxuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtzfV0gPSBpbmRpY2VzWyR7c31dICogJHtyfSAtICR7aX0gKyBqO1xcbiAgICAgICAgICAgICAgICBgLHk9XCJcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBcIn1yZXR1cm5gXFxuICAgICAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiB4IDogYXJyYXk8JHt1fT47XFxuICAgICAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke3V9PjtcXG5cXG4gICAgICAgICAgICAke2YubzJpSW1wbH1cXG4gICAgICAgICAgICAke2guaTJvSW1wbH1cXG5cXG4gICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XFxuICAgICAgICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhkKX1cXG5cXG4gICAgICAgICAgICAgICR7Zi5pbmRpY2VzVmFyaWFibGVEZWNsYXJhdGlvbihcImluZGljZXNcIil9XFxuICAgICAgICAgICAgICAke2YubzJpQ2FsbChcImdsb2JhbF9pZHhcIixcImluZGljZXNcIil9XFxuICAgICAgICAgICAgICAke2YuaW5kaWNlc1ZhcmlhYmxlRGVjbGFyYXRpb24oXCJ4SW5kaWNlc1wiKX1cXG4gICAgICAgICAgICAgICR7Zi5vMmlDYWxsKFwiZ2xvYmFsX2lkeFwiLFwieEluZGljZXNcIil9XFxuXFxuICAgICAgICAgICAgICB2YXIgdmFsdWU6ICR7dX0gPSAke3V9KCR7bH0pO1xcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IDA7XFxuICAgICAgICAgICAgICAke2J9XFxuICAgICAgICAgICAgICAke219XFxuICAgICAgICAgICAgICAke3l9XFxuICAgICAgICAgICAgICAke3N9XFxuXFxuICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcXG4gICAgICAgICAgICB9YH17aWYoYyl0aHJvdyBuZXcgRXJyb3IoXCJQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC5cIik7Y29uc3Qgbj1yLlNoYXBlVXRpbC5zaXplKG8ua2VybmVsU2hhcGUpLGE9ci5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoby5rZXJuZWxTaGFwZSksZz1hLmxlbmd0aCxtPW8ucGFkcy5sZW5ndGg7bGV0IGI9XCJcIjtyZXR1cm4gYj1vLnBhZHMucmVkdWNlKCgoZSx0KT0+ZSt0KSk/YFxcbiAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbal0gPj0gaW5wdXREaW1zW2pdKSB7XFxuICAgICAgICAgICAgICAgICAgcGFkKys7XFxuICAgICAgICAgICAgICAgICAgaXNQYWQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBpZiAoIWlzUGFkKSB7XFxuICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHtoLmkyb0V4cHJlc3Npb24oXCJ4SW5kaWNlc1wiKX1dO1xcbiAgICAgICAgICAgICAgICAke2l9XFxuICAgICAgICAgICAgICB9YDpgXFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7aC5pMm9FeHByZXNzaW9uKFwieEluZGljZXNcIil9XTtcXG4gICAgICAgICAgICAgICR7aX1cXG4gICAgICAgICAgICBgLGBcXG4gICAgICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHggOiBhcnJheTwke3V9PjtcXG4gICAgICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7dX0+O1xcblxcbiAgICAgICAgICAgICR7Zi5vMmlJbXBsfVxcbiAgICAgICAgICAgICR7aC5pMm9JbXBsfVxcblxcbiAgICAgICAgICAgIGNvbnN0IHBhZHMgPSBhcnJheTx1MzIsICR7bX0+KCR7by5wYWRzLm1hcCgoZT0+YCR7ZX11YCkpLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICAgICAgY29uc3QgaW5wdXREaW1zID0gYXJyYXk8dTMyLCAke3B9Pigke3QubWFwKChlPT5gJHtlfXVgKSkuam9pbihcIixcIil9KTtcXG4gICAgICAgICAgICBjb25zdCBrZXJuZWxTdHJpZGVzID0gYXJyYXk8dTMyLCAke2d9Pigke2EubWFwKChlPT5gJHtlfXVgKSkuam9pbihcIixcIil9KTtcXG4gICAgICAgICAgICBjb25zdCBzdHJpZGVzID0gYXJyYXk8dTMyLCAke2d9Pigke28uc3RyaWRlcy5tYXAoKGU9PmAke2V9dWApKS5qb2luKFwiLFwiKX0pO1xcblxcbiAgICAgICAgICAgICR7ZS5tYWluU3RhcnQoKX1cXG4gICAgICAgICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGQpfVxcblxcbiAgICAgICAgICAgICAgJHtmLmluZGljZXNWYXJpYWJsZURlY2xhcmF0aW9uKFwiaW5kaWNlc1wiKX1cXG4gICAgICAgICAgICAgICR7Zi5vMmlDYWxsKFwiZ2xvYmFsX2lkeFwiLFwiaW5kaWNlc1wiKX1cXG4gICAgICAgICAgICAgICR7Zi5pbmRpY2VzVmFyaWFibGVEZWNsYXJhdGlvbihcInhJbmRpY2VzXCIpfVxcbiAgICAgICAgICAgICAgJHtmLm8yaUNhbGwoXCJnbG9iYWxfaWR4XCIsXCJ4SW5kaWNlc1wiKX1cXG5cXG4gICAgICAgICAgICAgIHZhciBvZmZzZXRzOiBhcnJheTx1MzIsICR7Z30+O1xcblxcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHt1fSgke2x9KTtcXG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xcbiAgICAgICAgICAgICAgdmFyIGlzUGFkID0gZmFsc2U7XFxuXFxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7bn11OyBpKyspIHtcXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGk7XFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwdTsgaiA8ICR7Zy0xfXU7IGorKykge1xcbiAgICAgICAgICAgICAgICAgIG9mZnNldHNbal0gPSBvZmZzZXQgLyBrZXJuZWxTdHJpZGVzW2pdO1xcbiAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSBvZmZzZXRzW2pdICoga2VybmVsU3RyaWRlc1tqXTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBvZmZzZXRzWyR7Zy0xfV0gPSBvZmZzZXQ7XFxuXFxuICAgICAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAke3AtZ311OyBqIDwgJHtwfXU7IGorKykge1xcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzW2pdID0gaW5kaWNlc1tqXSAqIHN0cmlkZXNbaiAtICR7cC1nfXVdXFxuICAgICAgICAgICAgICAgICAgICArIG9mZnNldHNbaiAtICR7cC1nfXVdIC0gcGFkc1tqIC0gMnVdO1xcbiAgICAgICAgICAgICAgICAgICR7Yn1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICR7c31cXG5cXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xcbiAgICAgICAgICAgIH1gfX0sYz1lPT4oe2Zvcm1hdDplLmZvcm1hdCxhdXRvUGFkOltcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bZS5hdXRvX3BhZF0sY2VpbE1vZGU6ZS5jZWlsX21vZGUsa2VybmVsU2hhcGU6ZS5rZXJuZWxfc2hhcGUsc3RyaWRlczplLnN0cmlkZXMscGFkczplLnBhZHN9KSxwPShlLHQsbixvKT0+e2NvbnN0W2Esc109dShlLG8sbiksYz1yLlNoYXBlVXRpbC5zaXplKGEua2VybmVsU2hhcGUpLHA9XCJmMzJcIjtsZXQgZD1cIlwiO3JldHVybiBhLmNvdW50SW5jbHVkZVBhZD9kKz1gdmFsdWUgLz0gJHtwfSgke2N9KTtgOmQrPWB2YWx1ZSAvPSAke3B9KCR7Y30gLSBwYWQpO2AsT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXRzOlt7ZGltczpzLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6aS5HcHVEYXRhVHlwZS5kZWZhdWx0fV0sZ2V0U2hhZGVyU291cmNlOnQ9PmwodCxlWzBdLmRpbXMscyxhLFwidmFsdWUgKz0geF92YWw7XCIsZCxwLFwiMC4wXCIpLGRpc3BhdGNoR3JvdXA6KCk9Pih7eDpNYXRoLmNlaWwoci5TaGFwZVV0aWwuc2l6ZShzKS82NCl9KX0pfTt0LnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzPWU9Pntjb25zdCB0PTAhPT1lLmNvdW50X2luY2x1ZGVfcGFkLG49YyhlKTtpZigwIT09bi5jZWlsTW9kZSl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIEF2ZXJhZ2VQb29sXCIpO3JldHVybigwLG8uY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KShPYmplY3QuYXNzaWduKHtjb3VudEluY2x1ZGVQYWQ6dH0sbikpfSx0LmF2ZXJhZ2VQb29sPShlLHQpPT57cyhlLmlucHV0cyk7Y29uc3Qgbj17bmFtZTpcIkF2ZXJhZ2VQb29sXCIsaW5wdXRUeXBlczpbaS5HcHVEYXRhVHlwZS5kZWZhdWx0XSxjYWNoZUhpbnQ6dC5jYWNoZUtleX07ZS5jb21wdXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7Z2V0OigpPT5wKGUuaW5wdXRzLG4sITEsdCl9KSl9O2NvbnN0IGQ9e2F1dG9QYWQ6XCJcIixjZWlsTW9kZTowLGNvdW50SW5jbHVkZVBhZDohMSxrZXJuZWxTaGFwZTpbXSxzdHJpZGVzOltdLHBhZHM6W10sc3RvcmFnZU9yZGVyOjAsZGlsYXRpb25zOltdLGNhY2hlS2V5OlwiXCJ9O3QucGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5mb3JtYXQ7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7Zm9ybWF0OnR9LGQpLHtjYWNoZUtleTp0fSl9LHQuZ2xvYmFsQXZlcmFnZVBvb2w9KGUsdCk9PntzKGUuaW5wdXRzKTtjb25zdCBuPXtuYW1lOlwiR2xvYmFsQXZlcmFnZVBvb2xcIixpbnB1dFR5cGVzOltpLkdwdURhdGFUeXBlLmRlZmF1bHRdLGNhY2hlSGludDp0LmNhY2hlS2V5fTtlLmNvbXB1dGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtnZXQ6KCk9PnAoZS5pbnB1dHMsbiwhMCx0KX0pKX07Y29uc3QgZj0oZSx0LG4sbyk9Pntjb25zdFthLHNdPXUoZSxvLG4pO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dHM6W3tkaW1zOnMsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZSxncHVEYXRhVHlwZTppLkdwdURhdGFUeXBlLmRlZmF1bHR9XSxnZXRTaGFkZXJTb3VyY2U6dD0+bCh0LGVbMF0uZGltcyxzLGEsXCJcXG4gICAgICB2YWx1ZSA9IG1heCh4X3ZhbCwgdmFsdWUpO1xcbiAgICBcIixcIlwiLFwiZjMyXCIsXCItMWU1XCIpLGRpc3BhdGNoR3JvdXA6KCk9Pih7eDpNYXRoLmNlaWwoci5TaGFwZVV0aWwuc2l6ZShzKS82NCl9KX0pfTt0Lm1heFBvb2w9KGUsdCk9PntzKGUuaW5wdXRzKTtjb25zdCBuPXtuYW1lOlwiTWF4UG9vbFwiLGlucHV0VHlwZXM6W2kuR3B1RGF0YVR5cGUuZGVmYXVsdF0sY2FjaGVIaW50OnQuY2FjaGVLZXl9O2UuY29tcHV0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+ZihlLmlucHV0cyxuLCExLHQpfSkpfSx0LnBhcnNlTWF4UG9vbEF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5zdG9yYWdlX29yZGVyLG49ZS5kaWxhdGlvbnMscj1jKGUpO2lmKDAhPT10KXRocm93IG5ldyBFcnJvcihcImNvbHVtbiBtYWpvciBzdG9yYWdlIG9yZGVyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO2lmKDAhPT1yLmNlaWxNb2RlKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtyZXR1cm4oMCxvLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoT2JqZWN0LmFzc2lnbih7c3RvcmFnZU9yZGVyOnQsZGlsYXRpb25zOm59LHIpKX0sdC5wYXJzZUdsb2JhbE1heFBvb2xBdHRyaWJ1dGVzPWU9Pntjb25zdCB0PWUuZm9ybWF0O3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe2Zvcm1hdDp0fSxkKSx7Y2FjaGVLZXk6dH0pfSx0Lmdsb2JhbE1heFBvb2w9KGUsdCk9PntzKGUuaW5wdXRzKTtjb25zdCBuPXtuYW1lOlwiR2xvYmFsTWF4UG9vbFwiLGlucHV0VHlwZXM6W2kuR3B1RGF0YVR5cGUuZGVmYXVsdF0sY2FjaGVIaW50OnQuY2FjaGVLZXl9O2UuY29tcHV0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+ZihlLmlucHV0cyxuLCEwLHQpfSkpfX0sMjYyNTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXM9dC50cmFuc3Bvc2U9dC5jcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbz10LnRyYW5zcG9zZVByb2dyYW1NZXRhZGF0YT12b2lkIDA7Y29uc3Qgcj1uKDY5NTIpLG89bigzODcpLGk9bigxMTYzKSxhPW4oMjA3NSk7dC50cmFuc3Bvc2VQcm9ncmFtTWV0YWRhdGE9e25hbWU6XCJUcmFuc3Bvc2VcIixpbnB1dFR5cGVzOltpLkdwdURhdGFUeXBlLmRlZmF1bHRdfTtjb25zdCBzPShlLHQpPT50JiZ0Lmxlbmd0aCE9PWUubGVuZ3RoP1suLi5lLmtleXMoKV0ucmV2ZXJzZSgpOnQ7dC5jcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbz0oZSxuKT0+e2NvbnN0IG89ZS5kaW1zLHU9cyhvLG4pLGw9KChlLHQpPT5yLlNoYXBlVXRpbC5zb3J0QmFzZWRPblBlcm0oZSxzKGUsdCkpKShvLHUpLGM9by5sZW5ndGgscD1yLlNoYXBlVXRpbC5zaXplKGwpLGQ9KDAsYS5jcmVhdGVJbmRpY2VzSGVscGVyKShcIm91dHB1dFwiLGwpLGY9KDAsYS5jcmVhdGVJbmRpY2VzSGVscGVyKShcImFcIixvKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQudHJhbnNwb3NlUHJvZ3JhbU1ldGFkYXRhKSx7b3V0cHV0czpbe2RpbXM6bCxkYXRhVHlwZTplLmRhdGFUeXBlLGdwdURhdGFUeXBlOmkuR3B1RGF0YVR5cGUuZGVmYXVsdH1dLGdldFNoYWRlclNvdXJjZTplPT5gXFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGEgOiBhcnJheTxmMzI+O1xcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTxmMzI+O1xcblxcbiAgJHsoKGUsdCk9Pntjb25zdCBuPVtdO24ucHVzaChgZm4gcGVybShhOiBwdHI8ZnVuY3Rpb24sIGFycmF5PHUzMiwgJHt0fT4+LCBpOiBwdHI8ZnVuY3Rpb24sIGFycmF5PHUzMiwgJHt0fT4+KSB7YCk7Zm9yKGxldCByPTA7cjx0OysrciluLnB1c2goYFxcdCgqYSlbJHtlW3JdfV09KCppKVske3J9XTtgKTtyZXR1cm4gbi5wdXNoKFwiXFx0fVwiKSxuLmpvaW4oXCJcXG5cIil9KSh1LGMpfVxcbiAgJHtkLm8yaUltcGx9XFxuICAke2YuaTJvSW1wbH1cXG5cXG4gICR7ZS5tYWluU3RhcnQoKX1cXG4gICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMocCl9XFxuXFxuICAgICR7ZC5pbmRpY2VzVmFyaWFibGVEZWNsYXJhdGlvbihcImluZGljZXNcIil9XFxuICAgICR7ZC5vMmlDYWxsKFwiZ2xvYmFsX2lkeFwiLFwiaW5kaWNlc1wiKX1cXG4gICAgJHtmLmluZGljZXNWYXJpYWJsZURlY2xhcmF0aW9uKFwiYUluZGljZXNcIil9XFxuICAgIHBlcm0oJmFJbmRpY2VzLCAmaW5kaWNlcyk7XFxuXFxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGFbJHtmLmkyb0V4cHJlc3Npb24oXCJhSW5kaWNlc1wiKX1dO1xcbiAgfWAsZGlzcGF0Y2hHcm91cDooKT0+KHt4Ok1hdGguY2VpbChwLzY0KX0pfSl9LHQudHJhbnNwb3NlPShlLG4pPT57KGU9PntpZighZXx8MSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9zZSByZXF1aXJlcyAxIGlucHV0LlwiKTtpZigxIT09ZVswXS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfSkoZS5pbnB1dHMpLGUuY29tcHV0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdC50cmFuc3Bvc2VQcm9ncmFtTWV0YWRhdGEpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9PigwLHQuY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8pKGUuaW5wdXRzWzBdLG4ucGVybSl9KSl9LHQucGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzPWU9PigwLG8uY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7cGVybTplLnBlcm19KX0sOTMwMjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC50aHJlc2hvbGRlZFJlbHU9dC50YW5oPXQudGFuPXQuc3FydD10LnNpbmg9dC5zaW49dC5zaWdtb2lkPXQucmVsdT10LnJlY2lwcm9jYWw9dC5uZWc9dC5sZWFreVJlbHU9dC5mbG9vcj10LmV4cD10LmVyZj10LmVsdT10LnBhcnNlQWxwaGFBdHRyaWJ1dGVzPXQuY29zaD10LmNvcz10LmNlaWw9dC5jbGlwPXQuY2xpcFYxMD10LmF0YW5oPXQuYXRhbj10LmFzaW5oPXQuYXNpbj10LmFjb3NoPXQuYWNvcz10LmFicz12b2lkIDA7Y29uc3Qgcj1uKDY5NTIpLG89bigzODcpLGk9bigxMTYzKSxhPShlLHQsbixvLGEpPT57Y29uc3Qgcz17bmFtZTp0LGlucHV0VHlwZXM6W2kuR3B1RGF0YVR5cGUuZGVmYXVsdF0sY2FjaGVIaW50OmF9O3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2dldDooKT0+KChlLHQsbixvKT0+T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtnZXRTaGFkZXJTb3VyY2U6ZT0+KChlLHQsbixyKT0+e2NvbnN0IG89TWF0aC5jZWlsKHQvNCk7bGV0IGk9XCJcIjtyZXR1cm4gaT1cInN0cmluZ1wiPT10eXBlb2Ygbj9gJHtufShhKWA6bihcImFcIiksYFxcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBpbnB1dERhdGEgOiBhcnJheTx2ZWM0PGYzMj4+O1xcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXREYXRhIDogYXJyYXk8dmVjNDxmMzI+PjtcXG5cXG4gICR7bnVsbCE9cj9yOlwiXCJ9XFxuXFxuICAke2UubWFpblN0YXJ0KCl9XFxuICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG8pfVxcblxcbiAgICBsZXQgYSA9IGlucHV0RGF0YVtnbG9iYWxfaWR4XTtcXG4gICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9ICR7aX07XFxuICB9YH0pKGUsci5TaGFwZVV0aWwuc2l6ZSh0LmRpbXMpLG4sbyksb3V0cHV0czpbe2RpbXM6dC5kaW1zLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6aS5HcHVEYXRhVHlwZS5kZWZhdWx0fV0sZGlzcGF0Y2hHcm91cDplPT4oe3g6TWF0aC5jZWlsKHIuU2hhcGVVdGlsLnNpemUoZVswXS5kaW1zKS82NC80KX0pfSkpKHMsZSxuLG8pfSl9O3QuYWJzPWU9PntlLmNvbXB1dGUoYShlLmlucHV0c1swXSxcIkFic1wiLFwiYWJzXCIpKX0sdC5hY29zPWU9PntlLmNvbXB1dGUoYShlLmlucHV0c1swXSxcIkFjb3NcIixcImFjb3NcIikpfSx0LmFjb3NoPWU9PntlLmNvbXB1dGUoYShlLmlucHV0c1swXSxcIkFjb3NoXCIsXCJhY29zaFwiKSl9LHQuYXNpbj1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJBc2luXCIsXCJhc2luXCIpKX0sdC5hc2luaD1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJBc2luaFwiLFwiYXNpbmhcIikpfSx0LmF0YW49ZT0+e2UuY29tcHV0ZShhKGUuaW5wdXRzWzBdLFwiQXRhblwiLFwiYXRhblwiKSl9LHQuYXRhbmg9ZT0+e2UuY29tcHV0ZShhKGUuaW5wdXRzWzBdLFwiQXRhbmhcIixcImF0YW5oXCIpKX0sdC5jbGlwVjEwPShlLHQpPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJDbGlwXCIsKGU9PmBjbGFtcCgke2V9LCBjbGlwX21pbl8sIGNsaXBfbWF4XylgKSxgXFxuICAgIGNvbnN0IGNsaXBfbWluXzogdmVjNDxmMzI+ID0gdmVjNChmMzIoJHt0Lm1pbn0pKTtcXG4gICAgY29uc3QgY2xpcF9tYXhfOiB2ZWM0PGYzMj4gPSB2ZWM0KGYzMigke3QubWF4fSkpO1xcbmAsdC5jYWNoZUtleSkse2lucHV0czpbMF19KX0sdC5jbGlwPWU9Pntjb25zdCBuPShlPT57Y29uc3QgdD1lLmxlbmd0aD49Mj9lWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdOnIuTUlOX0NMSVAsbj1lLmxlbmd0aD49Mz9lWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdOnIuTUFYX0NMSVA7cmV0dXJuKDAsby5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHttaW46dCxtYXg6bn0pfSkoZS5pbnB1dHMpOygwLHQuY2xpcFYxMCkoZSxuKX0sdC5jZWlsPWU9PntlLmNvbXB1dGUoYShlLmlucHV0c1swXSxcIkNlaWxcIixcImNlaWxcIikpfSx0LmNvcz1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJDb3NcIixcImNvc1wiKSl9LHQuY29zaD1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJDb3NoXCIsXCJjb3NoXCIpKX0sdC5wYXJzZUFscGhhQXR0cmlidXRlcz1lPT4oMCxvLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoZSksdC5lbHU9KGUsdCk9PntlLmNvbXB1dGUoYShlLmlucHV0c1swXSxcIkVsdVwiLChlPT5gZWx1X3ZmMzIoJHtlfSlgKSxgXFxuICBjb25zdCBlbHVfYWxwaGFfOiBmMzIgPSBmMzIoJHt0LmFscGhhfSk7XFxuXFxuICBmbiBlbHVfZjMyKGE6IGYzMikgLT4gZjMyIHtcXG4gIHJldHVybiBzZWxlY3QoKGV4cChhKSAtIDEuMCkgKiBlbHVfYWxwaGFfLCBhLCBhID49IDAuMCk7XFxuICB9XFxuXFxuICBmbiBlbHVfdmYzMih2OiB2ZWM0PGYzMj4pIC0+IHZlYzQ8ZjMyPiB7XFxuICByZXR1cm4gdmVjNChlbHVfZjMyKHYueCksIGVsdV9mMzIodi55KSwgZWx1X2YzMih2LnopLCBlbHVfZjMyKHYudykpO1xcbiAgfWAsdC5jYWNoZUtleSkpfSx0LmVyZj1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJFcmZcIiwoZT0+YGVyZl92ZjMyKCR7ZX0pYCksXCJcXG4gIGNvbnN0IHIwOiBmMzIgPSAwLjMyNzU5MTE7XFxuICBjb25zdCByMTogZjMyID0gMC4yNTQ4Mjk1OTI7XFxuICBjb25zdCByMjogZjMyID0gLTAuMjg0NDk2NzM2O1xcbiAgY29uc3QgcjM6IGYzMiA9IDEuNDIxNDEzNzQxO1xcbiAgY29uc3QgcjQ6IGYzMiA9IC0xLjQ1MzE1MjAyNztcXG4gIGNvbnN0IHI1OiBmMzIgPSAxLjA2MTQwNTQyOTtcXG5cXG4gIGZuIGVyZl92ZjMyKHY6IHZlYzQ8ZjMyPikgLT4gdmVjNDxmMzI+IHtcXG4gICAgbGV0IGFic3YgPSBhYnModik7XFxuICAgIGxldCB4ID0gMS4wIC8gKDEuMCArIHIwICogYWJzdik7XFxuICAgIHJldHVybiBzaWduKHYpICogKDEuMCAtICgoKChyNSAqIHggKyByNCkgKiB4ICsgcjMpICogeCArIHIyKSAqIHggKyByMSkgKiB4ICogZXhwKC1hYnN2ICogYWJzdikpO1xcbiAgfVwiKSl9LHQuZXhwPWU9PntlLmNvbXB1dGUoYShlLmlucHV0c1swXSxcIkV4cFwiLFwiZXhwXCIpKX0sdC5mbG9vcj1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJGbG9vclwiLFwiZmxvb3JcIikpfSx0LmxlYWt5UmVsdT0oZSx0KT0+e2UuY29tcHV0ZShhKGUuaW5wdXRzWzBdLFwiTGVha3lSZWx1XCIsKGU9PmBzZWxlY3QobGVha3lfcmVsdV9hbHBoYV8gKiAke2V9LCAke2V9LCAke2V9ID49IHZlYzQ8ZjMyPigwLjApKWApLGBjb25zdCBsZWFreV9yZWx1X2FscGhhXzogZjMyID0gZjMyKCR7dC5hbHBoYX0pO2AsdC5jYWNoZUtleSkpfSx0Lm5lZz1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJOZWdcIiwoZT0+YC0ke2V9YCkpKX0sdC5yZWNpcHJvY2FsPWU9PntlLmNvbXB1dGUoYShlLmlucHV0c1swXSxcIlJlY2lwcm9jYWxcIiwoZT0+YDEuMC8ke2V9YCkpKX0sdC5yZWx1PWU9PntlLmNvbXB1dGUoYShlLmlucHV0c1swXSxcIlJlbHVcIiwoZT0+YHNlbGVjdCh2ZWM0PGYzMj4oMC4wKSwgJHtlfSwgJHtlfSA+IHZlYzQ8ZjMyPigwLjApKWApKSl9LHQuc2lnbW9pZD1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJTaWdtb2lkXCIsKGU9PmAoMS4wIC8gKDEuMCArIGV4cCgtJHtlfSkpKWApKSl9LHQuc2luPWU9PntlLmNvbXB1dGUoYShlLmlucHV0c1swXSxcIlNpblwiLFwic2luXCIpKX0sdC5zaW5oPWU9PntlLmNvbXB1dGUoYShlLmlucHV0c1swXSxcIlNpbmhcIixcInNpbmhcIikpfSx0LnNxcnQ9ZT0+e2UuY29tcHV0ZShhKGUuaW5wdXRzWzBdLFwiU3FydFwiLFwic3FydFwiKSl9LHQudGFuPWU9PntlLmNvbXB1dGUoYShlLmlucHV0c1swXSxcIlRhblwiLFwidGFuXCIpKX0sdC50YW5oPWU9PntlLmNvbXB1dGUoYShlLmlucHV0c1swXSxcIlRhbmhcIixcInRhbmhcIikpfSx0LnRocmVzaG9sZGVkUmVsdT0oZSx0KT0+KGUuY29tcHV0ZShhKGUuaW5wdXRzWzBdLFwiVGhyZXNob2xkZWRSZWx1XCIsKGU9PmBzZWxlY3QodmVjNDxmMzI+KDAuMCksICR7ZX0sICR7ZX0gPiB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXylgKSxgY29uc3QgdGhyZXNob2xkZWRfcmVsdV9hbHBoYV86IHZlYzQ8ZjMyPiA9IHZlYzQ8ZjMyPigke3QuYWxwaGF9KTtgLHQuY2FjaGVLZXkpKSwwKX0sODMwNTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Qcm9ncmFtTWFuYWdlcj12b2lkIDA7Y29uc3Qgcj1uKDQ5NTUpLG89bigyMDc1KTt0LlByb2dyYW1NYW5hZ2VyPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuYmFja2VuZD1lLHRoaXMucmVwbz1uZXcgTWFwLHRoaXMuYXR0cmlidXRlc0JvdW5kPSExfWdldEFydGlmYWN0KGUpe3JldHVybiB0aGlzLnJlcG8uZ2V0KGUpfXNldEFydGlmYWN0KGUsdCl7dGhpcy5yZXBvLnNldChlLHQpfXJ1bihlLHQsbixyKXtjb25zdCBvPXRoaXMuYmFja2VuZC5kZXZpY2UsaT10aGlzLmJhY2tlbmQuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk7dGhpcy5iYWNrZW5kLnByb2ZpbGluZ0VuYWJsZWQmJmkud3JpdGVUaW1lc3RhbXAodGhpcy5iYWNrZW5kLnByb2ZpbGluZ1F1ZXJ5U2V0LDApLGkuc2V0UGlwZWxpbmUoZS5jb21wdXRlUGlwZWxpbmUpO2NvbnN0IGE9W107Zm9yKGNvbnN0IGUgb2YgdClhLnB1c2goe2JpbmRpbmc6YS5sZW5ndGgscmVzb3VyY2U6e2J1ZmZlcjplLmJ1ZmZlcn19KTtmb3IoY29uc3QgZSBvZiBuKWEucHVzaCh7YmluZGluZzphLmxlbmd0aCxyZXNvdXJjZTp7YnVmZmVyOmUuYnVmZmVyfX0pO2NvbnN0IHM9by5jcmVhdGVCaW5kR3JvdXAoe2xheW91dDplLmNvbXB1dGVQaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksZW50cmllczphfSk7aWYoaS5zZXRCaW5kR3JvdXAoMCxzKSxpLmRpc3BhdGNoV29ya2dyb3VwcyguLi5yKSx0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKyssdGhpcy5iYWNrZW5kLnByb2ZpbGluZ0VuYWJsZWQpe2kud3JpdGVUaW1lc3RhbXAodGhpcy5iYWNrZW5kLnByb2ZpbGluZ1F1ZXJ5U2V0LDEpO2NvbnN0IGU9dGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZSgxNixHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ3xHUFVCdWZmZXJVc2FnZS5RVUVSWV9SRVNPTFZFKSx0PXRoaXMuYmFja2VuZC5ncHVEYXRhTWFuYWdlci5jcmVhdGUoMTYsR1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUR8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QpO3RoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpLHRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpLnJlc29sdmVRdWVyeVNldCh0aGlzLmJhY2tlbmQucHJvZmlsaW5nUXVlcnlTZXQsMCwyLGUuYnVmZmVyLDApLHRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpLmNvcHlCdWZmZXJUb0J1ZmZlcihlLmJ1ZmZlciwwLHQuYnVmZmVyLDAsMTYpLHRoaXMuYmFja2VuZC5mbHVzaCgpO2NvbnN0IG49dGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxJZCxyPXRoaXMuYmFja2VuZC5rZXJuZWxzLmdldChuKVswXTt0LmJ1ZmZlci5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpLnRoZW4oKCgpPT57Y29uc3Qgbz1uZXcgQmlnVWludDY0QXJyYXkodC5idWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKSksaT1vWzBdLGE9b1sxXTt0LmJ1ZmZlci51bm1hcCgpLHZvaWQgMD09PXRoaXMuYmFja2VuZC5wcm9maWxpbmdUaW1lQmFzZSYmKHRoaXMuYmFja2VuZC5wcm9maWxpbmdUaW1lQmFzZT1pKTtjb25zdCBzPU51bWJlcihpLXRoaXMuYmFja2VuZC5wcm9maWxpbmdUaW1lQmFzZSksdT1OdW1iZXIoYS10aGlzLmJhY2tlbmQucHJvZmlsaW5nVGltZUJhc2UpO2lmKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihzKXx8IU51bWJlci5pc1NhZmVJbnRlZ2VyKHUpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiaW5jb3JyZWN0IHRpbWVzdGFtcCByYW5nZVwiKTt0aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShlLmlkKSx0aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZSh0LmlkKSxjb25zb2xlLmxvZyhgW3Byb2ZpbGluZ10ga2VybmVsIFwiJHtufXwke3J9XCIgZXhlY3V0aW9uIHRpbWU6ICR7dS1zfSBuc2ApfSkpfXRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PTE2JiZ0aGlzLmJhY2tlbmQuZmx1c2goKX1kaXNwb3NlKCl7fWJ1aWxkKGUsdCl7Y29uc3Qgbj10aGlzLmJhY2tlbmQuZGV2aWNlLGk9ZS5nZXRTaGFkZXJTb3VyY2UoKDAsby5jcmVhdGVTaGFkZXJIZWxwZXIpKHQpKSxhPW4uY3JlYXRlU2hhZGVyTW9kdWxlKHtjb2RlOml9KTtyZXR1cm4oMCxyLkxPR19ERUJVRykoXCJ2ZXJib3NlXCIsKCgpPT5gW1dlYkdQVV0gc2hhZGVyIGNvZGU6ICR7aX1gKSkse3Byb2dyYW1JbmZvOmUsY29tcHV0ZVBpcGVsaW5lOm4uY3JlYXRlQ29tcHV0ZVBpcGVsaW5lKHtjb21wdXRlOnttb2R1bGU6YSxlbnRyeVBvaW50OlwibWFpblwifSxsYXlvdXQ6XCJhdXRvXCJ9KX19bm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUoZSl7Y29uc3QgdD1cIm51bWJlclwiPT10eXBlb2YgZT9lOmUueCxuPVwibnVtYmVyXCI9PXR5cGVvZiBlPzE6ZS55fHwxLHI9XCJudW1iZXJcIj09dHlwZW9mIGU/MTplLnp8fDEsbz10aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjtpZih0PD1vJiZuPD1vJiZyPD1vKXJldHVyblt0LG4scl07Y29uc3QgaT10Km4qcjtsZXQgYT1NYXRoLmNlaWwoTWF0aC5zcXJ0KGkpKTtpZihhPm8pe2lmKGE9TWF0aC5jZWlsKE1hdGguY2JydChpKSksYT5vKXRocm93IG5ldyBFcnJvcihcIlRvdGFsIGRpc3BhdGNoIHNpemUgZXhjZWVkcyBXZWJHUFUgbWF4aW11bS5cIik7cmV0dXJuW2EsYSxhXX1yZXR1cm5bYSxhLDFdfX19LDExNjM6KGUsdCk9PntcInVzZSBzdHJpY3RcIjt2YXIgbjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkdwdURhdGFUeXBlPXZvaWQgMCwobj10LkdwdURhdGFUeXBlfHwodC5HcHVEYXRhVHlwZT17fSkpW24uZGVmYXVsdD0wXT1cImRlZmF1bHRcIixuW24udXBsb2FkPTFdPVwidXBsb2FkXCIsbltuLnByb2ZpbGU9Ml09XCJwcm9maWxlXCJ9LDM4OTk6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lml0ZXJhdGVFeHRyYU9wdGlvbnM9dm9pZCAwLHQuaXRlcmF0ZUV4dHJhT3B0aW9ucz0oZSxuLHIsbyk9PntpZihcIm9iamVjdFwiPT10eXBlb2YgZSYmbnVsbCE9PWUpe2lmKHIuaGFzKGUpKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zXCIpO3IuYWRkKGUpfU9iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKChbZSxpXSk9Pntjb25zdCBhPW4/bitlOmU7aWYoXCJvYmplY3RcIj09dHlwZW9mIGkpKDAsdC5pdGVyYXRlRXh0cmFPcHRpb25zKShpLGErXCIuXCIscixvKTtlbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBpfHxcIm51bWJlclwiPT10eXBlb2YgaSlvKGEsaS50b1N0cmluZygpKTtlbHNle2lmKFwiYm9vbGVhblwiIT10eXBlb2YgaSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6IFwiK3R5cGVvZiBpKTtvKGEsaT9cIjFcIjpcIjBcIil9fSkpfX0sOTU0NDpmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHIsbz10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG4pO28mJiEoXCJnZXRcImluIG8/IXQuX19lc01vZHVsZTpvLndyaXRhYmxlfHxvLmNvbmZpZ3VyYWJsZSl8fChvPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsbyl9OmZ1bmN0aW9uKGUsdCxuLHIpe3ZvaWQgMD09PXImJihyPW4pLGVbcl09dFtuXX0pLGk9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pfTpmdW5jdGlvbihlLHQpe2UuZGVmYXVsdD10fSksYT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciBuIGluIGUpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxuKSYmbyh0LGUsbik7cmV0dXJuIGkodCxlKSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmVuZFByb2ZpbGluZz10LnJ1bj10LnJlbGVhc2VTZXNzaW9uPXQuY3JlYXRlU2Vzc2lvbj10LmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT10LmNyZWF0ZVNlc3Npb25BbGxvY2F0ZT10LmluaXRPcnQ9dC5pbml0V2FzbT12b2lkIDA7Y29uc3Qgcz1uKDg0NTMpLHU9big3Njc1KSxsPWEobigxMjU5KSksYz1uKDI2MykscD0oKT0+ISFzLmVudi53YXNtLnByb3h5JiZcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQ7bGV0IGQsZixoLGc9ITEsbT0hMSxiPSExO2NvbnN0IHk9W10sdz1bXSxfPVtdLHY9W10seD1bXSxUPVtdLFM9KCk9PntpZihnfHwhbXx8Ynx8IWQpdGhyb3cgbmV3IEVycm9yKFwid29ya2VyIG5vdCByZWFkeVwiKX0sTz1lPT57c3dpdGNoKGUuZGF0YS50eXBlKXtjYXNlXCJpbml0LXdhc21cIjpnPSExLGUuZGF0YS5lcnI/KGI9ITAsZlsxXShlLmRhdGEuZXJyKSk6KG09ITAsZlswXSgpKTticmVhaztjYXNlXCJpbml0LW9ydFwiOmUuZGF0YS5lcnI/aFsxXShlLmRhdGEuZXJyKTpoWzBdKCk7YnJlYWs7Y2FzZVwiY3JlYXRlX2FsbG9jYXRlXCI6ZS5kYXRhLmVycj95LnNoaWZ0KClbMV0oZS5kYXRhLmVycik6eS5zaGlmdCgpWzBdKGUuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcImNyZWF0ZV9maW5hbGl6ZVwiOmUuZGF0YS5lcnI/dy5zaGlmdCgpWzFdKGUuZGF0YS5lcnIpOncuc2hpZnQoKVswXShlLmRhdGEub3V0KTticmVhaztjYXNlXCJjcmVhdGVcIjplLmRhdGEuZXJyP18uc2hpZnQoKVsxXShlLmRhdGEuZXJyKTpfLnNoaWZ0KClbMF0oZS5kYXRhLm91dCk7YnJlYWs7Y2FzZVwicmVsZWFzZVwiOmUuZGF0YS5lcnI/di5zaGlmdCgpWzFdKGUuZGF0YS5lcnIpOnYuc2hpZnQoKVswXSgpO2JyZWFrO2Nhc2VcInJ1blwiOmUuZGF0YS5lcnI/eC5zaGlmdCgpWzFdKGUuZGF0YS5lcnIpOnguc2hpZnQoKVswXShlLmRhdGEub3V0KTticmVhaztjYXNlXCJlbmQtcHJvZmlsaW5nXCI6ZS5kYXRhLmVycj9ULnNoaWZ0KClbMV0oZS5kYXRhLmVycik6VC5zaGlmdCgpWzBdKCl9fSxBPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudD9udWxsPT09KHI9bnVsbD09PWRvY3VtZW50fHx2b2lkIDA9PT1kb2N1bWVudD92b2lkIDA6ZG9jdW1lbnQuY3VycmVudFNjcmlwdCl8fHZvaWQgMD09PXI/dm9pZCAwOnIuc3JjOnZvaWQgMDt0LmluaXRXYXNtPWFzeW5jKCk9PntpZihwKCkpe2lmKG0pcmV0dXJuO2lmKGcpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRXYXNtKCknIGRldGVjdGVkLlwiKTtpZihiKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRXYXNtKCknIGZhaWxlZC5cIik7cmV0dXJuIGc9ITAsdm9pZCAwPT09cy5lbnYud2FzbS53YXNtUGF0aHMmJkEmJjAhPT1BLmluZGV4T2YoXCJibG9iOlwiKSYmKHMuZW52Lndhc20ud2FzbVBhdGhzPUEuc3Vic3RyKDAsK0EubGFzdEluZGV4T2YoXCIvXCIpKzEpKSxuZXcgUHJvbWlzZSgoKGUsdCk9PntudWxsPT1kfHxkLnRlcm1pbmF0ZSgpLGQ9big4MDUwKS5aKCksZC5vbm1lc3NhZ2U9TyxmPVtlLHRdO2NvbnN0IHI9e3R5cGU6XCJpbml0LXdhc21cIixpbjpzLmVudi53YXNtfTtkLnBvc3RNZXNzYWdlKHIpfSkpfXJldHVybigwLGMuaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KShzLmVudi53YXNtKX0sdC5pbml0T3J0PWFzeW5jKGUsdCk9PntpZihwKCkpcmV0dXJuIFMoKSxuZXcgUHJvbWlzZSgoKG4scik9PntoPVtuLHJdO2NvbnN0IG89e3R5cGU6XCJpbml0LW9ydFwiLGluOntudW1UaHJlYWRzOmUsbG9nZ2luZ0xldmVsOnR9fTtkLnBvc3RNZXNzYWdlKG8pfSkpO2wuaW5pdE9ydChlLHQpLGF3YWl0KDAsdS5pbml0KSgoMCxjLmdldEluc3RhbmNlKSgpKX0sdC5jcmVhdGVTZXNzaW9uQWxsb2NhdGU9YXN5bmMgZT0+cCgpPyhTKCksbmV3IFByb21pc2UoKCh0LG4pPT57eS5wdXNoKFt0LG5dKTtjb25zdCByPXt0eXBlOlwiY3JlYXRlX2FsbG9jYXRlXCIsaW46e21vZGVsOmV9fTtkLnBvc3RNZXNzYWdlKHIsW2UuYnVmZmVyXSl9KSkpOmwuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKGUpLHQuY3JlYXRlU2Vzc2lvbkZpbmFsaXplPWFzeW5jKGUsdCk9PnAoKT8oUygpLG5ldyBQcm9taXNlKCgobixyKT0+e3cucHVzaChbbixyXSk7Y29uc3Qgbz17dHlwZTpcImNyZWF0ZV9maW5hbGl6ZVwiLGluOnttb2RlbGRhdGE6ZSxvcHRpb25zOnR9fTtkLnBvc3RNZXNzYWdlKG8pfSkpKTpsLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZShlLHQpLHQuY3JlYXRlU2Vzc2lvbj1hc3luYyhlLHQpPT5wKCk/KFMoKSxuZXcgUHJvbWlzZSgoKG4scik9PntfLnB1c2goW24scl0pO2NvbnN0IG89e3R5cGU6XCJjcmVhdGVcIixpbjp7bW9kZWw6ZSxvcHRpb25zOnR9fTtkLnBvc3RNZXNzYWdlKG8sW2UuYnVmZmVyXSl9KSkpOmwuY3JlYXRlU2Vzc2lvbihlLHQpLHQucmVsZWFzZVNlc3Npb249YXN5bmMgZT0+e2lmKHAoKSlyZXR1cm4gUygpLG5ldyBQcm9taXNlKCgodCxuKT0+e3YucHVzaChbdCxuXSk7Y29uc3Qgcj17dHlwZTpcInJlbGVhc2VcIixpbjplfTtkLnBvc3RNZXNzYWdlKHIpfSkpO2wucmVsZWFzZVNlc3Npb24oZSl9LHQucnVuPWFzeW5jKGUsdCxuLHIsbyk9PnAoKT8oUygpLG5ldyBQcm9taXNlKCgoaSxhKT0+e3gucHVzaChbaSxhXSk7Y29uc3Qgcz17dHlwZTpcInJ1blwiLGluOntzZXNzaW9uSWQ6ZSxpbnB1dEluZGljZXM6dCxpbnB1dHM6bixvdXRwdXRJbmRpY2VzOnIsb3B0aW9uczpvfX07ZC5wb3N0TWVzc2FnZShzLGwuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMobikpfSkpKTpsLnJ1bihlLHQsbixyLG8pLHQuZW5kUHJvZmlsaW5nPWFzeW5jIGU9PntpZihwKCkpcmV0dXJuIFMoKSxuZXcgUHJvbWlzZSgoKHQsbik9PntULnB1c2goW3Qsbl0pO2NvbnN0IHI9e3R5cGU6XCJlbmQtcHJvZmlsaW5nXCIsaW46ZX07ZC5wb3N0TWVzc2FnZShyKX0pKTtsLmVuZFByb2ZpbGluZyhlKX19LDc5MTg6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuc2V0UnVuT3B0aW9ucz12b2lkIDA7Y29uc3Qgcj1uKDM4OTkpLG89big5NDQ0KSxpPW4oMjYzKTt0LnNldFJ1bk9wdGlvbnM9ZT0+e2NvbnN0IHQ9KDAsaS5nZXRJbnN0YW5jZSkoKTtsZXQgbj0wO2NvbnN0IGE9W10scz1lfHx7fTt0cnl7aWYodm9pZCAwPT09KG51bGw9PWU/dm9pZCAwOmUubG9nU2V2ZXJpdHlMZXZlbCkpcy5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgZS5sb2dTZXZlcml0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1NldmVyaXR5TGV2ZWwpfHxlLmxvZ1NldmVyaXR5TGV2ZWw8MHx8ZS5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYodm9pZCAwPT09KG51bGw9PWU/dm9pZCAwOmUubG9nVmVyYm9zaXR5TGV2ZWwpKXMubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKFwibnVtYmVyXCIhPXR5cGVvZiBlLmxvZ1ZlcmJvc2l0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nVmVyYm9zaXR5TGV2ZWx9YCk7dm9pZCAwPT09KG51bGw9PWU/dm9pZCAwOmUudGVybWluYXRlKSYmKHMudGVybWluYXRlPSExKTtsZXQgaT0wO2lmKHZvaWQgMCE9PShudWxsPT1lP3ZvaWQgMDplLnRhZykmJihpPSgwLG8uYWxsb2NXYXNtU3RyaW5nKShlLnRhZyxhKSksbj10Ll9PcnRDcmVhdGVSdW5PcHRpb25zKHMubG9nU2V2ZXJpdHlMZXZlbCxzLmxvZ1ZlcmJvc2l0eUxldmVsLCEhcy50ZXJtaW5hdGUsaSksMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY3JlYXRlIHJ1biBvcHRpb25zXCIpO3JldHVybiB2b2lkIDAhPT0obnVsbD09ZT92b2lkIDA6ZS5leHRyYSkmJigwLHIuaXRlcmF0ZUV4dHJhT3B0aW9ucykoZS5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LCgoZSxyKT0+e2NvbnN0IGk9KDAsby5hbGxvY1dhc21TdHJpbmcpKGUsYSkscz0oMCxvLmFsbG9jV2FzbVN0cmluZykocixhKTtpZigwIT09dC5fT3J0QWRkUnVuQ29uZmlnRW50cnkobixpLHMpKXRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc2V0IGEgcnVuIGNvbmZpZyBlbnRyeTogJHtlfSAtICR7cn1gKX0pKSxbbixhXX1jYXRjaChlKXt0aHJvdyAwIT09biYmdC5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMobiksYS5mb3JFYWNoKHQuX2ZyZWUpLGV9fX0sNjY0MDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Pbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXI9dm9pZCAwO2NvbnN0IHI9bigyODA2KSxvPW4oODQ1MyksaT1uKDI4NTApLGE9big5NTQ0KSxzPW4oNzkxNyk7bGV0IHU7dC5Pbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXI9Y2xhc3N7YXN5bmMgY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKGUpe2NvbnN0IHQ9YXdhaXQgZmV0Y2goZSksbj1hd2FpdCB0LmFycmF5QnVmZmVyKCk7cmV0dXJuKDAsYS5jcmVhdGVTZXNzaW9uQWxsb2NhdGUpKG5ldyBVaW50OEFycmF5KG4pKX1hc3luYyBsb2FkTW9kZWwoZSx0KXtpZih1fHwoYXdhaXQoMCxhLmluaXRPcnQpKG8uZW52Lndhc20ubnVtVGhyZWFkcywoMCxzLmxvZ0xldmVsU3RyaW5nVG9FbnVtKShvLmVudi5sb2dMZXZlbCkpLHU9ITApLFwic3RyaW5nXCI9PXR5cGVvZiBlKWlmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBmZXRjaCl7Y29uc3Qgbj1hd2FpdCgwLGkucHJvbWlzaWZ5KShyLnJlYWRGaWxlKShlKTtbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0KDAsYS5jcmVhdGVTZXNzaW9uKShuLHQpfWVsc2V7Y29uc3Qgbj1hd2FpdCB0aGlzLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZShlKTtbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0KDAsYS5jcmVhdGVTZXNzaW9uRmluYWxpemUpKG4sdCl9ZWxzZVt0aGlzLnNlc3Npb25JZCx0aGlzLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lc109YXdhaXQoMCxhLmNyZWF0ZVNlc3Npb24pKGUsdCl9YXN5bmMgZGlzcG9zZSgpe3JldHVybigwLGEucmVsZWFzZVNlc3Npb24pKHRoaXMuc2Vzc2lvbklkKX1hc3luYyBydW4oZSx0LG4pe2NvbnN0IHI9W10saT1bXTtPYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKChlPT57Y29uc3QgdD1lWzBdLG49ZVsxXSxvPXRoaXMuaW5wdXROYW1lcy5pbmRleE9mKHQpO2lmKC0xPT09byl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5wdXQgJyR7dH0nYCk7ci5wdXNoKG4pLGkucHVzaChvKX0pKTtjb25zdCBzPVtdO09iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goKGU9Pntjb25zdCB0PWVbMF0sbj10aGlzLm91dHB1dE5hbWVzLmluZGV4T2YodCk7aWYoLTE9PT1uKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvdXRwdXQgJyR7dH0nYCk7cy5wdXNoKG4pfSkpO2NvbnN0IHU9YXdhaXQoMCxhLnJ1bikodGhpcy5zZXNzaW9uSWQsaSxyLm1hcCgoZT0+W2UudHlwZSxlLmRpbXMsZS5kYXRhXSkpLHMsbiksbD17fTtmb3IobGV0IGU9MDtlPHUubGVuZ3RoO2UrKylsW3RoaXMub3V0cHV0TmFtZXNbc1tlXV1dPW5ldyBvLlRlbnNvcih1W2VdWzBdLHVbZV1bMl0sdVtlXVsxXSk7cmV0dXJuIGx9c3RhcnRQcm9maWxpbmcoKXt9ZW5kUHJvZmlsaW5nKCl7KDAsYS5lbmRQcm9maWxpbmcpKHRoaXMuc2Vzc2lvbklkKX19fSw3NjIyOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnNldFNlc3Npb25PcHRpb25zPXZvaWQgMDtjb25zdCByPW4oMzg5OSksbz1uKDk0NDQpLGk9bigyNjMpO3Quc2V0U2Vzc2lvbk9wdGlvbnM9ZT0+e3ZhciB0LG4sYSxzO2NvbnN0IHU9KDAsaS5nZXRJbnN0YW5jZSkoKTtsZXQgbD0wO2NvbnN0IGM9W10scD1lfHx7fTsoZT0+e2UuZXh0cmF8fChlLmV4dHJhPXt9KSxlLmV4dHJhLnNlc3Npb258fChlLmV4dHJhLnNlc3Npb249e30pO2NvbnN0IHQ9ZS5leHRyYS5zZXNzaW9uO3QudXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseXx8KHQudXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseT1cIjFcIiksZS5leGVjdXRpb25Qcm92aWRlcnMmJmUuZXhlY3V0aW9uUHJvdmlkZXJzLnNvbWUoKGU9Plwid2ViZ3B1XCI9PT0oXCJzdHJpbmdcIj09dHlwZW9mIGU/ZTplLm5hbWUpKSkmJihlLmVuYWJsZU1lbVBhdHRlcm49ITEpfSkocCk7dHJ5e2NvbnN0IGU9KGU9Pntzd2l0Y2goZSl7Y2FzZVwiZGlzYWJsZWRcIjpyZXR1cm4gMDtjYXNlXCJiYXNpY1wiOnJldHVybiAxO2Nhc2VcImV4dGVuZGVkXCI6cmV0dXJuIDI7Y2FzZVwiYWxsXCI6cmV0dXJuIDk5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBncmFwaCBvcHRpbWl6YXRpb24gbGV2ZWw6ICR7ZX1gKX19KShudWxsIT09KHQ9cC5ncmFwaE9wdGltaXphdGlvbkxldmVsKSYmdm9pZCAwIT09dD90OlwiYWxsXCIpLGQ9KGU9Pntzd2l0Y2goZSl7Y2FzZVwic2VxdWVudGlhbFwiOnJldHVybiAwO2Nhc2VcInBhcmFsbGVsXCI6cmV0dXJuIDE7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV4ZWN1dGlvbiBtb2RlOiAke2V9YCl9fSkobnVsbCE9PShuPXAuZXhlY3V0aW9uTW9kZSkmJnZvaWQgMCE9PW4/bjpcInNlcXVlbnRpYWxcIiksZj1cInN0cmluZ1wiPT10eXBlb2YgcC5sb2dJZD8oMCxvLmFsbG9jV2FzbVN0cmluZykocC5sb2dJZCxjKTowLGg9bnVsbCE9PShhPXAubG9nU2V2ZXJpdHlMZXZlbCkmJnZvaWQgMCE9PWE/YToyO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGgpfHxoPDB8fGg+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2h9YCk7Y29uc3QgZz1udWxsIT09KHM9cC5sb2dWZXJib3NpdHlMZXZlbCkmJnZvaWQgMCE9PXM/czowO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGcpfHxnPDB8fGc+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2d9YCk7Y29uc3QgbT1cInN0cmluZ1wiPT10eXBlb2YgcC5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoPygwLG8uYWxsb2NXYXNtU3RyaW5nKShwLm9wdGltaXplZE1vZGVsRmlsZVBhdGgsYyk6MDtpZihsPXUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKGUsISFwLmVuYWJsZUNwdU1lbUFyZW5hLCEhcC5lbmFibGVNZW1QYXR0ZXJuLGQsISFwLmVuYWJsZVByb2ZpbGluZywwLGYsaCxnLG0pLDA9PT1sKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnNcIik7cmV0dXJuIHAuZXhlY3V0aW9uUHJvdmlkZXJzJiYoKGUsdCxuKT0+e2Zvcihjb25zdCByIG9mIHQpe2xldCB0PVwic3RyaW5nXCI9PXR5cGVvZiByP3I6ci5uYW1lO3N3aXRjaCh0KXtjYXNlXCJ4bm5wYWNrXCI6dD1cIlhOTlBBQ0tcIjticmVhaztjYXNlXCJ3ZWJncHVcIjp0PVwiSlNcIjticmVhaztjYXNlXCJ3YXNtXCI6Y2FzZVwiY3B1XCI6Y29udGludWU7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgRVA6ICR7dH1gKX1jb25zdCBhPSgwLG8uYWxsb2NXYXNtU3RyaW5nKSh0LG4pO2lmKDAhPT0oMCxpLmdldEluc3RhbmNlKSgpLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcihlLGEpKXRocm93IG5ldyBFcnJvcihgQ2FuJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHt0fWApfX0pKGwscC5leGVjdXRpb25Qcm92aWRlcnMsYyksdm9pZCAwIT09cC5leHRyYSYmKDAsci5pdGVyYXRlRXh0cmFPcHRpb25zKShwLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKChlLHQpPT57Y29uc3Qgbj0oMCxvLmFsbG9jV2FzbVN0cmluZykoZSxjKSxyPSgwLG8uYWxsb2NXYXNtU3RyaW5nKSh0LGMpO2lmKDAhPT11Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkobCxuLHIpKXRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7ZX0gLSAke3R9YCl9KSksW2wsY119Y2F0Y2goZSl7dGhyb3cgMCE9PWwmJnUuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhsKSxjLmZvckVhY2godS5fZnJlZSksZX19fSw5NDQ0OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmFsbG9jV2FzbVN0cmluZz12b2lkIDA7Y29uc3Qgcj1uKDI2Myk7dC5hbGxvY1dhc21TdHJpbmc9KGUsdCk9Pntjb25zdCBuPSgwLHIuZ2V0SW5zdGFuY2UpKCksbz1uLmxlbmd0aEJ5dGVzVVRGOChlKSsxLGk9bi5fbWFsbG9jKG8pO3JldHVybiBuLnN0cmluZ1RvVVRGOChlLGksbyksdC5wdXNoKGkpLGl9fSw3OTE3OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5sb2dMZXZlbFN0cmluZ1RvRW51bT10LnRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcj10LmdldFRlbnNvckVsZW1lbnRTaXplPXQudGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmc9dC50ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bT12b2lkIDAsdC50ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bT1lPT57c3dpdGNoKGUpe2Nhc2VcImludDhcIjpyZXR1cm4gMztjYXNlXCJ1aW50OFwiOnJldHVybiAyO2Nhc2VcImJvb2xcIjpyZXR1cm4gOTtjYXNlXCJpbnQxNlwiOnJldHVybiA1O2Nhc2VcInVpbnQxNlwiOnJldHVybiA0O2Nhc2VcImludDMyXCI6cmV0dXJuIDY7Y2FzZVwidWludDMyXCI6cmV0dXJuIDEyO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gMTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIDExO2Nhc2VcInN0cmluZ1wiOnJldHVybiA4O2Nhc2VcImludDY0XCI6cmV0dXJuIDc7Y2FzZVwidWludDY0XCI6cmV0dXJuIDEzO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LHQudGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmc9ZT0+e3N3aXRjaChlKXtjYXNlIDM6cmV0dXJuXCJpbnQ4XCI7Y2FzZSAyOnJldHVyblwidWludDhcIjtjYXNlIDk6cmV0dXJuXCJib29sXCI7Y2FzZSA1OnJldHVyblwiaW50MTZcIjtjYXNlIDQ6cmV0dXJuXCJ1aW50MTZcIjtjYXNlIDY6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgMTI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIDE6cmV0dXJuXCJmbG9hdDMyXCI7Y2FzZSAxMTpyZXR1cm5cImZsb2F0NjRcIjtjYXNlIDg6cmV0dXJuXCJzdHJpbmdcIjtjYXNlIDc6cmV0dXJuXCJpbnQ2NFwiO2Nhc2UgMTM6cmV0dXJuXCJ1aW50NjRcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSx0LmdldFRlbnNvckVsZW1lbnRTaXplPWU9Plt2b2lkIDAsNCwxLDEsMiwyLDQsOCx2b2lkIDAsMSwyLDgsNCw4LHZvaWQgMCx2b2lkIDAsdm9pZCAwXVtlXSx0LnRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcj1lPT57c3dpdGNoKGUpe2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6Y2FzZVwiYm9vbFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImludDhcIjpyZXR1cm4gSW50OEFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcImludDMyXCI6cmV0dXJuIEludDMyQXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke2V9YCl9fSx0LmxvZ0xldmVsU3RyaW5nVG9FbnVtPWU9Pntzd2l0Y2goZSl7Y2FzZVwidmVyYm9zZVwiOnJldHVybiAwO2Nhc2VcImluZm9cIjpyZXR1cm4gMTtjYXNlXCJ3YXJuaW5nXCI6cmV0dXJuIDI7Y2FzZVwiZXJyb3JcIjpyZXR1cm4gMztjYXNlXCJmYXRhbFwiOnJldHVybiA0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2V9YCl9fX0sMTI1OTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycz10LmVuZFByb2ZpbGluZz10LnJ1bj10LnJlbGVhc2VTZXNzaW9uPXQuY3JlYXRlU2Vzc2lvbj10LmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT10LmNyZWF0ZVNlc3Npb25BbGxvY2F0ZT10LmluaXRPcnQ9dm9pZCAwO2NvbnN0IHI9big3OTE4KSxvPW4oNzYyMiksaT1uKDk0NDQpLGE9big3OTE3KSxzPW4oMjYzKTt0LmluaXRPcnQ9KGUsdCk9Pntjb25zdCBuPSgwLHMuZ2V0SW5zdGFuY2UpKCkuX09ydEluaXQoZSx0KTtpZigwIT09bil0aHJvdyBuZXcgRXJyb3IoYENhbid0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuIGVycm9yIGNvZGUgPSAke259YCl9O2NvbnN0IHU9bmV3IE1hcDt0LmNyZWF0ZVNlc3Npb25BbGxvY2F0ZT1lPT57Y29uc3QgdD0oMCxzLmdldEluc3RhbmNlKSgpLG49dC5fbWFsbG9jKGUuYnl0ZUxlbmd0aCk7cmV0dXJuIHQuSEVBUFU4LnNldChlLG4pLFtuLGUuYnl0ZUxlbmd0aF19LHQuY3JlYXRlU2Vzc2lvbkZpbmFsaXplPShlLHQpPT57Y29uc3Qgbj0oMCxzLmdldEluc3RhbmNlKSgpO2xldCByPTAsaT0wLGE9W107dHJ5e2lmKFtpLGFdPSgwLG8uc2V0U2Vzc2lvbk9wdGlvbnMpKHQpLHI9bi5fT3J0Q3JlYXRlU2Vzc2lvbihlWzBdLGVbMV0saSksMD09PXIpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvblwiKX1maW5hbGx5e24uX2ZyZWUoZVswXSksMCE9PWkmJm4uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhpKSxhLmZvckVhY2gobi5fZnJlZSl9Y29uc3QgbD1uLl9PcnRHZXRJbnB1dENvdW50KHIpLGM9bi5fT3J0R2V0T3V0cHV0Q291bnQocikscD1bXSxkPVtdLGY9W10saD1bXTtmb3IobGV0IGU9MDtlPGw7ZSsrKXtjb25zdCB0PW4uX09ydEdldElucHV0TmFtZShyLGUpO2lmKDA9PT10KXRocm93IG5ldyBFcnJvcihcIkNhbid0IGdldCBhbiBpbnB1dCBuYW1lXCIpO2QucHVzaCh0KSxwLnB1c2gobi5VVEY4VG9TdHJpbmcodCkpfWZvcihsZXQgZT0wO2U8YztlKyspe2NvbnN0IHQ9bi5fT3J0R2V0T3V0cHV0TmFtZShyLGUpO2lmKDA9PT10KXRocm93IG5ldyBFcnJvcihcIkNhbid0IGdldCBhbiBvdXRwdXQgbmFtZVwiKTtoLnB1c2godCksZi5wdXNoKG4uVVRGOFRvU3RyaW5nKHQpKX1yZXR1cm4gdS5zZXQocixbcixkLGhdKSxbcixwLGZdfSx0LmNyZWF0ZVNlc3Npb249KGUsbik9Pntjb25zdCByPSgwLHQuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKShlKTtyZXR1cm4oMCx0LmNyZWF0ZVNlc3Npb25GaW5hbGl6ZSkocixuKX0sdC5yZWxlYXNlU2Vzc2lvbj1lPT57Y29uc3QgdD0oMCxzLmdldEluc3RhbmNlKSgpLG49dS5nZXQoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2NvbnN0IHI9blswXSxvPW5bMV0saT1uWzJdO28uZm9yRWFjaCh0Ll9PcnRGcmVlKSxpLmZvckVhY2godC5fT3J0RnJlZSksdC5fT3J0UmVsZWFzZVNlc3Npb24ociksdS5kZWxldGUoZSl9LHQucnVuPWFzeW5jKGUsdCxuLG8sbCk9Pntjb25zdCBjPSgwLHMuZ2V0SW5zdGFuY2UpKCkscD11LmdldChlKTtpZighcCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7Y29uc3QgZD1wWzBdLGY9cFsxXSxoPXBbMl0sZz10Lmxlbmd0aCxtPW8ubGVuZ3RoO2xldCBiPTAseT1bXTtjb25zdCB3PVtdLF89W107dHJ5e1tiLHldPSgwLHIuc2V0UnVuT3B0aW9ucykobCk7Zm9yKGxldCBlPTA7ZTxnO2UrKyl7Y29uc3QgdD1uW2VdWzBdLHI9bltlXVsxXSxvPW5bZV1bMl07bGV0IHMsdTtpZihBcnJheS5pc0FycmF5KG8pKXt1PTQqby5sZW5ndGgscz1jLl9tYWxsb2ModSksXy5wdXNoKHMpO2xldCBlPXMvNDtmb3IobGV0IHQ9MDt0PG8ubGVuZ3RoO3QrKyl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIG9bdF0pdGhyb3cgbmV3IFR5cGVFcnJvcihgdGVuc29yIGRhdGEgYXQgaW5kZXggJHt0fSBpcyBub3QgYSBzdHJpbmdgKTtjLkhFQVBVMzJbZSsrXT0oMCxpLmFsbG9jV2FzbVN0cmluZykob1t0XSxfKX19ZWxzZSB1PW8uYnl0ZUxlbmd0aCxzPWMuX21hbGxvYyh1KSxfLnB1c2gocyksYy5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KG8uYnVmZmVyLG8uYnl0ZU9mZnNldCx1KSxzKTtjb25zdCBsPWMuc3RhY2tTYXZlKCkscD1jLnN0YWNrQWxsb2MoNCpyLmxlbmd0aCk7dHJ5e2xldCBlPXAvNDtyLmZvckVhY2goKHQ9PmMuSEVBUDMyW2UrK109dCkpO2NvbnN0IG49Yy5fT3J0Q3JlYXRlVGVuc29yKCgwLGEudGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0pKHQpLHMsdSxwLHIubGVuZ3RoKTtpZigwPT09bil0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjcmVhdGUgYSB0ZW5zb3JcIik7dy5wdXNoKG4pfWZpbmFsbHl7Yy5zdGFja1Jlc3RvcmUobCl9fWNvbnN0IGU9Yy5zdGFja1NhdmUoKSxzPWMuc3RhY2tBbGxvYyg0KmcpLHU9Yy5zdGFja0FsbG9jKDQqZykscD1jLnN0YWNrQWxsb2MoNCptKSx2PWMuc3RhY2tBbGxvYyg0Km0pO3RyeXtsZXQgZT1zLzQsbj11LzQscj1wLzQsaT12LzQ7Zm9yKGxldCByPTA7cjxnO3IrKyljLkhFQVBVMzJbZSsrXT13W3JdLGMuSEVBUFUzMltuKytdPWZbdFtyXV07Zm9yKGxldCBlPTA7ZTxtO2UrKyljLkhFQVBVMzJbcisrXT0wLGMuSEVBUFUzMltpKytdPWhbb1tlXV07bGV0IGw9Yy5fT3J0UnVuKGQsdSxzLGcsdixtLHAsYik7Y29uc3QgeT1jLmpzZXBSdW5Qcm9taXNlO3kmJnZvaWQgMCE9PXkudGhlbiYmKGw9YXdhaXQgeSk7Y29uc3QgXz1bXTtpZigwPT09bClmb3IobGV0IGU9MDtlPG07ZSsrKXtjb25zdCB0PWMuSEVBUFUzMltwLzQrZV0sbj1jLnN0YWNrU2F2ZSgpLHI9Yy5zdGFja0FsbG9jKDE2KTtsZXQgbyxpPTA7dHJ5e2lmKGw9Yy5fT3J0R2V0VGVuc29yRGF0YSh0LHIscis0LHIrOCxyKzEyKSwwIT09bCl0aHJvdyBuZXcgRXJyb3IoYENhbid0IGFjY2VzcyBvdXRwdXQgdGVuc29yIGRhdGEuIGVycm9yIGNvZGUgPSAke2x9YCk7bGV0IGU9ci80O2NvbnN0IG49Yy5IRUFQVTMyW2UrK107aT1jLkhFQVBVMzJbZSsrXTtjb25zdCBzPWMuSEVBUFUzMltlKytdLHU9Yy5IRUFQVTMyW2UrK10scD1bXTtmb3IobGV0IGU9MDtlPHU7ZSsrKXAucHVzaChjLkhFQVBVMzJbcy80K2VdKTtjLl9PcnRGcmVlKHMpO2NvbnN0IGQ9MD09PXAubGVuZ3RoPzE6cC5yZWR1Y2UoKChlLHQpPT5lKnQpKTtpZihvPSgwLGEudGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcpKG4pLFwic3RyaW5nXCI9PT1vKXtjb25zdCBlPVtdO2xldCB0PWkvNDtmb3IobGV0IG49MDtuPGQ7bisrKXtjb25zdCByPWMuSEVBUFUzMlt0KytdLG89bj09PWQtMT92b2lkIDA6Yy5IRUFQVTMyW3RdLXI7ZS5wdXNoKGMuVVRGOFRvU3RyaW5nKHIsbykpfV8ucHVzaChbbyxwLGVdKX1lbHNle2NvbnN0IGU9bmV3KCgwLGEudGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yKShvKSkoZCk7bmV3IFVpbnQ4QXJyYXkoZS5idWZmZXIsZS5ieXRlT2Zmc2V0LGUuYnl0ZUxlbmd0aCkuc2V0KGMuSEVBUFU4LnN1YmFycmF5KGksaStlLmJ5dGVMZW5ndGgpKSxfLnB1c2goW28scCxlXSl9fWZpbmFsbHl7Yy5zdGFja1Jlc3RvcmUobiksXCJzdHJpbmdcIj09PW8mJmkmJmMuX2ZyZWUoaSksYy5fT3J0UmVsZWFzZVRlbnNvcih0KX19aWYoMD09PWwpcmV0dXJuIF87dGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS4gZXJyb3IgY29kZSA9ICR7bH0uYCl9ZmluYWxseXtjLnN0YWNrUmVzdG9yZShlKX19ZmluYWxseXt3LmZvckVhY2goYy5fT3J0UmVsZWFzZVRlbnNvciksXy5mb3JFYWNoKGMuX2ZyZWUpLGMuX09ydFJlbGVhc2VSdW5PcHRpb25zKGIpLHkuZm9yRWFjaChjLl9mcmVlKX19LHQuZW5kUHJvZmlsaW5nPWU9Pntjb25zdCB0PSgwLHMuZ2V0SW5zdGFuY2UpKCksbj11LmdldChlKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7Y29uc3Qgcj1uWzBdLG89dC5fT3J0RW5kUHJvZmlsaW5nKHIpO2lmKDA9PT1vKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGdldCBhbiBwcm9maWxlIGZpbGUgbmFtZVwiKTt0Ll9PcnRGcmVlKG8pfSx0LmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzPWU9Pntjb25zdCB0PVtdO2Zvcihjb25zdCBuIG9mIGUpe2NvbnN0IGU9blsyXTshQXJyYXkuaXNBcnJheShlKSYmZS5idWZmZXImJnQucHVzaChlLmJ1ZmZlcil9cmV0dXJuIHR9fSwyNjM6ZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQsbixyKXt2b2lkIDA9PT1yJiYocj1uKTt2YXIgbz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbik7byYmIShcImdldFwiaW4gbz8hdC5fX2VzTW9kdWxlOm8ud3JpdGFibGV8fG8uY29uZmlndXJhYmxlKXx8KG89e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbbl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixvKX06ZnVuY3Rpb24oZSx0LG4scil7dm9pZCAwPT09ciYmKHI9biksZVtyXT10W25dfSksbz10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSl9OmZ1bmN0aW9uKGUsdCl7ZS5kZWZhdWx0PXR9KSxpPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIG4gaW4gZSlcImRlZmF1bHRcIiE9PW4mJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pJiZyKHQsZSxuKTtyZXR1cm4gbyh0LGUpLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGlzcG9zZT10LmdldEluc3RhbmNlPXQuaW5pdGlhbGl6ZVdlYkFzc2VtYmx5PXZvaWQgMDtjb25zdCBhPWkobig2NDQ5KSkscz1uKDkzMiksdT1uKDM0NzQpO2xldCBsLGM9ITEscD0hMSxkPSExO3QuaW5pdGlhbGl6ZVdlYkFzc2VtYmx5PWFzeW5jIGU9PntpZihjKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtpZihwKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZGV0ZWN0ZWQuXCIpO2lmKGQpdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGZhaWxlZC5cIik7cD0hMDtjb25zdCB0PWUuaW5pdFRpbWVvdXQscj1lLm51bVRocmVhZHMsbz1lLnNpbWQsaT1yPjEmJigoKT0+e3RyeXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXImJihcInVuZGVmaW5lZFwiIT10eXBlb2YgTWVzc2FnZUNoYW5uZWwmJihuZXcgTWVzc2FnZUNoYW5uZWwpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSksV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDUsNCwxLDMsMSwxLDEwLDExLDEsOSwwLDY1LDAsMjU0LDE2LDIsMCwyNiwxMV0pKSl9Y2F0Y2goZSl7cmV0dXJuITF9fSkoKSxmPW8mJigoKT0+e3RyeXtyZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDMwLDEsMjgsMCw2NSwwLDI1MywxNSwyNTMsMTIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyNTMsMTg2LDEsMjYsMTFdKSl9Y2F0Y2goZSl7cmV0dXJuITF9fSkoKSxoPWUud2FzbVBhdGhzLGc9XCJzdHJpbmdcIj09dHlwZW9mIGg/aDp2b2lkIDAsbT0oKGUsdCk9PnQ/ZT9cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbVwiOlwib3J0LXdhc20tdGhyZWFkZWQud2FzbVwiOmU/XCJvcnQtd2FzbS1zaW1kLndhc21cIjpcIm9ydC13YXNtLndhc21cIikoZixpKSxiPVwib2JqZWN0XCI9PXR5cGVvZiBoP2hbbV06dm9pZCAwO2xldCB5PSExO2NvbnN0IHc9W107aWYodD4wJiZ3LnB1c2gobmV3IFByb21pc2UoKGU9PntzZXRUaW1lb3V0KCgoKT0+e3k9ITAsZSgpfSksdCl9KSkpLHcucHVzaChuZXcgUHJvbWlzZSgoKGUsdCk9Pntjb25zdCByPWk/dTpzLG89e2xvY2F0ZUZpbGU6KGUsdCk9PmkmJmUuZW5kc1dpdGgoXCIud29ya2VyLmpzXCIpJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgQmxvYj9VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtuKDQxNTQpXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSkpOmUuZW5kc1dpdGgoXCIud2FzbVwiKT9ifHwobnVsbCE9Zz9nOnQpK206dCtlfTtpZihpKWlmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBCbG9iKW8ubWFpblNjcmlwdFVybE9yQmxvYj1hLmpvaW4oXCIvXCIsXCJvcnQtd2FzbS10aHJlYWRlZC5qc1wiKTtlbHNle2NvbnN0IGU9YHZhciBvcnRXYXNtVGhyZWFkZWQ9KGZ1bmN0aW9uKCl7dmFyIF9zY3JpcHREaXI7cmV0dXJuICR7ci50b1N0cmluZygpfX0pKCk7YDtvLm1haW5TY3JpcHRVcmxPckJsb2I9bmV3IEJsb2IoW2VdLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KX1yKG8pLnRoZW4oKHQ9PntwPSExLGM9ITAsbD10LGUoKX0pLChlPT57cD0hMSxkPSEwLHQoZSl9KSl9KSkpLGF3YWl0IFByb21pc2UucmFjZSh3KSx5KXRocm93IG5ldyBFcnJvcihgV2ViQXNzZW1ibHkgYmFja2VuZCBpbml0aWFsaXppbmcgZmFpbGVkIGR1ZSB0byB0aW1lb3V0OiAke3R9bXNgKX0sdC5nZXRJbnN0YW5jZT0oKT0+e2lmKGMmJmwpcmV0dXJuIGw7dGhyb3cgbmV3IEVycm9yKFwiV2ViQXNzZW1ibHkgaXMgbm90IGluaXRpYWxpemVkIHlldC5cIil9LHQuZGlzcG9zZT0oKT0+e3ZhciBlOyFjfHxwfHxkfHwocD0hMCxudWxsPT09KGU9bC5QVGhyZWFkKXx8dm9pZCAwPT09ZXx8ZS50ZXJtaW5hdGVBbGxUaHJlYWRzKCksbD12b2lkIDAscD0hMSxjPSExLGQ9ITApfX0sODA1MDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7bi5kKHQse1o6KCk9Pml9KTt2YXIgcj1uKDY2MTQpLG89bi5uKHIpO2Z1bmN0aW9uIGkoKXtyZXR1cm4gbygpKCcvKiFcXG4qIE9OTlggUnVudGltZSBXZWIgdjEuMTUuMVxcbiogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXFxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXFxuKi9cXG4oKCk9Pnt2YXIgZT17ODk5OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5pdGVyYXRlRXh0cmFPcHRpb25zPXZvaWQgMCx0Lml0ZXJhdGVFeHRyYU9wdGlvbnM9KGUsbixyLGEpPT57aWYoXCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lKXtpZihyLmhhcyhlKSl0aHJvdyBuZXcgRXJyb3IoXCJDaXJjdWxhciByZWZlcmVuY2UgaW4gb3B0aW9uc1wiKTtyLmFkZChlKX1PYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKCgoW2Usb10pPT57Y29uc3QgaT1uP24rZTplO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBvKSgwLHQuaXRlcmF0ZUV4dHJhT3B0aW9ucykobyxpK1wiLlwiLHIsYSk7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2Ygb3x8XCJudW1iZXJcIj09dHlwZW9mIG8pYShpLG8udG9TdHJpbmcoKSk7ZWxzZXtpZihcImJvb2xlYW5cIiE9dHlwZW9mIG8pdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6IFwiK3R5cGVvZiBvKTthKGksbz9cIjFcIjpcIjBcIil9fSkpfX0sOTE4OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnNldFJ1bk9wdGlvbnM9dm9pZCAwO2NvbnN0IHI9big4OTkpLGE9big0NDQpLG89bigyNjMpO3Quc2V0UnVuT3B0aW9ucz1lPT57Y29uc3QgdD0oMCxvLmdldEluc3RhbmNlKSgpO2xldCBuPTA7Y29uc3QgaT1bXSxzPWV8fHt9O3RyeXtpZih2b2lkIDA9PT0obnVsbD09ZT92b2lkIDA6ZS5sb2dTZXZlcml0eUxldmVsKSlzLmxvZ1NldmVyaXR5TGV2ZWw9MjtlbHNlIGlmKFwibnVtYmVyXCIhPXR5cGVvZiBlLmxvZ1NldmVyaXR5TGV2ZWx8fCFOdW1iZXIuaXNJbnRlZ2VyKGUubG9nU2V2ZXJpdHlMZXZlbCl8fGUubG9nU2V2ZXJpdHlMZXZlbDwwfHxlLmxvZ1NldmVyaXR5TGV2ZWw+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nU2V2ZXJpdHlMZXZlbH1gKTtpZih2b2lkIDA9PT0obnVsbD09ZT92b2lkIDA6ZS5sb2dWZXJib3NpdHlMZXZlbCkpcy5sb2dWZXJib3NpdHlMZXZlbD0wO2Vsc2UgaWYoXCJudW1iZXJcIiE9dHlwZW9mIGUubG9nVmVyYm9zaXR5TGV2ZWx8fCFOdW1iZXIuaXNJbnRlZ2VyKGUubG9nVmVyYm9zaXR5TGV2ZWwpKXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dWZXJib3NpdHlMZXZlbH1gKTt2b2lkIDA9PT0obnVsbD09ZT92b2lkIDA6ZS50ZXJtaW5hdGUpJiYocy50ZXJtaW5hdGU9ITEpO2xldCBvPTA7aWYodm9pZCAwIT09KG51bGw9PWU/dm9pZCAwOmUudGFnKSYmKG89KDAsYS5hbGxvY1dhc21TdHJpbmcpKGUudGFnLGkpKSxuPXQuX09ydENyZWF0ZVJ1bk9wdGlvbnMocy5sb2dTZXZlcml0eUxldmVsLHMubG9nVmVyYm9zaXR5TGV2ZWwsISFzLnRlcm1pbmF0ZSxvKSwwPT09bil0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGNyZWF0ZSBydW4gb3B0aW9uc1wiKTtyZXR1cm4gdm9pZCAwIT09KG51bGw9PWU/dm9pZCAwOmUuZXh0cmEpJiYoMCxyLml0ZXJhdGVFeHRyYU9wdGlvbnMpKGUuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoKGUscik9Pntjb25zdCBvPSgwLGEuYWxsb2NXYXNtU3RyaW5nKShlLGkpLHM9KDAsYS5hbGxvY1dhc21TdHJpbmcpKHIsaSk7aWYoMCE9PXQuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KG4sbyxzKSl0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3Qgc2V0IGEgcnVuIGNvbmZpZyBlbnRyeTogJHtlfSAtICR7cn1gKX0pKSxbbixpXX1jYXRjaChlKXt0aHJvdyAwIT09biYmdC5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMobiksaS5mb3JFYWNoKHQuX2ZyZWUpLGV9fX0sNjIyOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnNldFNlc3Npb25PcHRpb25zPXZvaWQgMDtjb25zdCByPW4oODk5KSxhPW4oNDQ0KSxvPW4oMjYzKTt0LnNldFNlc3Npb25PcHRpb25zPWU9Pnt2YXIgdCxuLGkscztjb25zdCB1PSgwLG8uZ2V0SW5zdGFuY2UpKCk7bGV0IGM9MDtjb25zdCBsPVtdLGY9ZXx8e307KGU9PntlLmV4dHJhfHwoZS5leHRyYT17fSksZS5leHRyYS5zZXNzaW9ufHwoZS5leHRyYS5zZXNzaW9uPXt9KTtjb25zdCB0PWUuZXh0cmEuc2Vzc2lvbjt0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fCh0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpLGUuZXhlY3V0aW9uUHJvdmlkZXJzJiZlLmV4ZWN1dGlvblByb3ZpZGVycy5zb21lKChlPT5cIndlYmdwdVwiPT09KFwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZS5uYW1lKSkpJiYoZS5lbmFibGVNZW1QYXR0ZXJuPSExKX0pKGYpO3RyeXtjb25zdCBlPShlPT57c3dpdGNoKGUpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2V9YCl9fSkobnVsbCE9PSh0PWYuZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCkmJnZvaWQgMCE9PXQ/dDpcImFsbFwiKSxwPShlPT57c3dpdGNoKGUpe2Nhc2VcInNlcXVlbnRpYWxcIjpyZXR1cm4gMDtjYXNlXCJwYXJhbGxlbFwiOnJldHVybiAxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtlfWApfX0pKG51bGwhPT0obj1mLmV4ZWN1dGlvbk1vZGUpJiZ2b2lkIDAhPT1uP246XCJzZXF1ZW50aWFsXCIpLGQ9XCJzdHJpbmdcIj09dHlwZW9mIGYubG9nSWQ/KDAsYS5hbGxvY1dhc21TdHJpbmcpKGYubG9nSWQsbCk6MCxtPW51bGwhPT0oaT1mLmxvZ1NldmVyaXR5TGV2ZWwpJiZ2b2lkIDAhPT1pP2k6MjtpZighTnVtYmVyLmlzSW50ZWdlcihtKXx8bTwwfHxtPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHttfWApO2NvbnN0IGc9bnVsbCE9PShzPWYubG9nVmVyYm9zaXR5TGV2ZWwpJiZ2b2lkIDAhPT1zP3M6MDtpZighTnVtYmVyLmlzSW50ZWdlcihnKXx8ZzwwfHxnPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtnfWApO2NvbnN0IGg9XCJzdHJpbmdcIj09dHlwZW9mIGYub3B0aW1pemVkTW9kZWxGaWxlUGF0aD8oMCxhLmFsbG9jV2FzbVN0cmluZykoZi5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoLGwpOjA7aWYoYz11Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhlLCEhZi5lbmFibGVDcHVNZW1BcmVuYSwhIWYuZW5hYmxlTWVtUGF0dGVybixwLCEhZi5lbmFibGVQcm9maWxpbmcsMCxkLG0sZyxoKSwwPT09Yyl0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnNcIik7cmV0dXJuIGYuZXhlY3V0aW9uUHJvdmlkZXJzJiYoKGUsdCxuKT0+e2Zvcihjb25zdCByIG9mIHQpe2xldCB0PVwic3RyaW5nXCI9PXR5cGVvZiByP3I6ci5uYW1lO3N3aXRjaCh0KXtjYXNlXCJ4bm5wYWNrXCI6dD1cIlhOTlBBQ0tcIjticmVhaztjYXNlXCJ3ZWJncHVcIjp0PVwiSlNcIjticmVhaztjYXNlXCJ3YXNtXCI6Y2FzZVwiY3B1XCI6Y29udGludWU7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgRVA6ICR7dH1gKX1jb25zdCBpPSgwLGEuYWxsb2NXYXNtU3RyaW5nKSh0LG4pO2lmKDAhPT0oMCxvLmdldEluc3RhbmNlKSgpLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcihlLGkpKXRocm93IG5ldyBFcnJvcihgQ2FuXFwndCBhcHBlbmQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke3R9YCl9fSkoYyxmLmV4ZWN1dGlvblByb3ZpZGVycyxsKSx2b2lkIDAhPT1mLmV4dHJhJiYoMCxyLml0ZXJhdGVFeHRyYU9wdGlvbnMpKGYuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoKGUsdCk9Pntjb25zdCBuPSgwLGEuYWxsb2NXYXNtU3RyaW5nKShlLGwpLHI9KDAsYS5hbGxvY1dhc21TdHJpbmcpKHQsbCk7aWYoMCE9PXUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShjLG4scikpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke2V9IC0gJHt0fWApfSkpLFtjLGxdfWNhdGNoKGUpe3Rocm93IDAhPT1jJiZ1Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMoYyksbC5mb3JFYWNoKHUuX2ZyZWUpLGV9fX0sNDQ0OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmFsbG9jV2FzbVN0cmluZz12b2lkIDA7Y29uc3Qgcj1uKDI2Myk7dC5hbGxvY1dhc21TdHJpbmc9KGUsdCk9Pntjb25zdCBuPSgwLHIuZ2V0SW5zdGFuY2UpKCksYT1uLmxlbmd0aEJ5dGVzVVRGOChlKSsxLG89bi5fbWFsbG9jKGEpO3JldHVybiBuLnN0cmluZ1RvVVRGOChlLG8sYSksdC5wdXNoKG8pLG99fSw5MTc6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmxvZ0xldmVsU3RyaW5nVG9FbnVtPXQudGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yPXQuZ2V0VGVuc29yRWxlbWVudFNpemU9dC50ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZz10LnRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtPXZvaWQgMCx0LnRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtPWU9Pntzd2l0Y2goZSl7Y2FzZVwiaW50OFwiOnJldHVybiAzO2Nhc2VcInVpbnQ4XCI6cmV0dXJuIDI7Y2FzZVwiYm9vbFwiOnJldHVybiA5O2Nhc2VcImludDE2XCI6cmV0dXJuIDU7Y2FzZVwidWludDE2XCI6cmV0dXJuIDQ7Y2FzZVwiaW50MzJcIjpyZXR1cm4gNjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gMTI7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiAxO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gMTE7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIDg7Y2FzZVwiaW50NjRcIjpyZXR1cm4gNztjYXNlXCJ1aW50NjRcIjpyZXR1cm4gMTM7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0sdC50ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZz1lPT57c3dpdGNoKGUpe2Nhc2UgMzpyZXR1cm5cImludDhcIjtjYXNlIDI6cmV0dXJuXCJ1aW50OFwiO2Nhc2UgOTpyZXR1cm5cImJvb2xcIjtjYXNlIDU6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgNDpyZXR1cm5cInVpbnQxNlwiO2Nhc2UgNjpyZXR1cm5cImludDMyXCI7Y2FzZSAxMjpyZXR1cm5cInVpbnQzMlwiO2Nhc2UgMTpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIDExOnJldHVyblwiZmxvYXQ2NFwiO2Nhc2UgODpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgNzpyZXR1cm5cImludDY0XCI7Y2FzZSAxMzpyZXR1cm5cInVpbnQ2NFwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LHQuZ2V0VGVuc29yRWxlbWVudFNpemU9ZT0+W3ZvaWQgMCw0LDEsMSwyLDIsNCw4LHZvaWQgMCwxLDIsOCw0LDgsdm9pZCAwLHZvaWQgMCx2b2lkIDBdW2VdLHQudGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yPWU9Pntzd2l0Y2goZSl7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiBGbG9hdDMyQXJyYXk7Y2FzZVwidWludDhcIjpjYXNlXCJib29sXCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwidWludDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImludDE2XCI6cmV0dXJuIEludDE2QXJyYXk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gSW50MzJBcnJheTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIEZsb2F0NjRBcnJheTtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gVWludDMyQXJyYXk7Y2FzZVwiaW50NjRcIjpyZXR1cm4gQmlnSW50NjRBcnJheTtjYXNlXCJ1aW50NjRcIjpyZXR1cm4gQmlnVWludDY0QXJyYXk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGU6ICR7ZX1gKX19LHQubG9nTGV2ZWxTdHJpbmdUb0VudW09ZT0+e3N3aXRjaChlKXtjYXNlXCJ2ZXJib3NlXCI6cmV0dXJuIDA7Y2FzZVwiaW5mb1wiOnJldHVybiAxO2Nhc2VcIndhcm5pbmdcIjpyZXR1cm4gMjtjYXNlXCJlcnJvclwiOnJldHVybiAzO2Nhc2VcImZhdGFsXCI6cmV0dXJuIDQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7ZX1gKX19fSwyNTk6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnM9dC5lbmRQcm9maWxpbmc9dC5ydW49dC5yZWxlYXNlU2Vzc2lvbj10LmNyZWF0ZVNlc3Npb249dC5jcmVhdGVTZXNzaW9uRmluYWxpemU9dC5jcmVhdGVTZXNzaW9uQWxsb2NhdGU9dC5pbml0T3J0PXZvaWQgMDtjb25zdCByPW4oOTE4KSxhPW4oNjIyKSxvPW4oNDQ0KSxpPW4oOTE3KSxzPW4oMjYzKTt0LmluaXRPcnQ9KGUsdCk9Pntjb25zdCBuPSgwLHMuZ2V0SW5zdGFuY2UpKCkuX09ydEluaXQoZSx0KTtpZigwIT09bil0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3QgaW5pdGlhbGl6ZSBvbm54cnVudGltZS4gZXJyb3IgY29kZSA9ICR7bn1gKX07Y29uc3QgdT1uZXcgTWFwO3QuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPWU9Pntjb25zdCB0PSgwLHMuZ2V0SW5zdGFuY2UpKCksbj10Ll9tYWxsb2MoZS5ieXRlTGVuZ3RoKTtyZXR1cm4gdC5IRUFQVTguc2V0KGUsbiksW24sZS5ieXRlTGVuZ3RoXX0sdC5jcmVhdGVTZXNzaW9uRmluYWxpemU9KGUsdCk9Pntjb25zdCBuPSgwLHMuZ2V0SW5zdGFuY2UpKCk7bGV0IHI9MCxvPTAsaT1bXTt0cnl7aWYoW28saV09KDAsYS5zZXRTZXNzaW9uT3B0aW9ucykodCkscj1uLl9PcnRDcmVhdGVTZXNzaW9uKGVbMF0sZVsxXSxvKSwwPT09cil0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGNyZWF0ZSBhIHNlc3Npb25cIil9ZmluYWxseXtuLl9mcmVlKGVbMF0pLDAhPT1vJiZuLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMobyksaS5mb3JFYWNoKG4uX2ZyZWUpfWNvbnN0IGM9bi5fT3J0R2V0SW5wdXRDb3VudChyKSxsPW4uX09ydEdldE91dHB1dENvdW50KHIpLGY9W10scD1bXSxkPVtdLG09W107Zm9yKGxldCBlPTA7ZTxjO2UrKyl7Y29uc3QgdD1uLl9PcnRHZXRJbnB1dE5hbWUocixlKTtpZigwPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGdldCBhbiBpbnB1dCBuYW1lXCIpO3AucHVzaCh0KSxmLnB1c2gobi5VVEY4VG9TdHJpbmcodCkpfWZvcihsZXQgZT0wO2U8bDtlKyspe2NvbnN0IHQ9bi5fT3J0R2V0T3V0cHV0TmFtZShyLGUpO2lmKDA9PT10KXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgZ2V0IGFuIG91dHB1dCBuYW1lXCIpO20ucHVzaCh0KSxkLnB1c2gobi5VVEY4VG9TdHJpbmcodCkpfXJldHVybiB1LnNldChyLFtyLHAsbV0pLFtyLGYsZF19LHQuY3JlYXRlU2Vzc2lvbj0oZSxuKT0+e2NvbnN0IHI9KDAsdC5jcmVhdGVTZXNzaW9uQWxsb2NhdGUpKGUpO3JldHVybigwLHQuY3JlYXRlU2Vzc2lvbkZpbmFsaXplKShyLG4pfSx0LnJlbGVhc2VTZXNzaW9uPWU9Pntjb25zdCB0PSgwLHMuZ2V0SW5zdGFuY2UpKCksbj11LmdldChlKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7Y29uc3Qgcj1uWzBdLGE9blsxXSxvPW5bMl07YS5mb3JFYWNoKHQuX09ydEZyZWUpLG8uZm9yRWFjaCh0Ll9PcnRGcmVlKSx0Ll9PcnRSZWxlYXNlU2Vzc2lvbihyKSx1LmRlbGV0ZShlKX0sdC5ydW49YXN5bmMoZSx0LG4sYSxjKT0+e2NvbnN0IGw9KDAscy5nZXRJbnN0YW5jZSkoKSxmPXUuZ2V0KGUpO2lmKCFmKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtjb25zdCBwPWZbMF0sZD1mWzFdLG09ZlsyXSxnPXQubGVuZ3RoLGg9YS5sZW5ndGg7bGV0IHk9MCx2PVtdO2NvbnN0IGI9W10sdz1bXTt0cnl7W3ksdl09KDAsci5zZXRSdW5PcHRpb25zKShjKTtmb3IobGV0IGU9MDtlPGc7ZSsrKXtjb25zdCB0PW5bZV1bMF0scj1uW2VdWzFdLGE9bltlXVsyXTtsZXQgcyx1O2lmKEFycmF5LmlzQXJyYXkoYSkpe3U9NCphLmxlbmd0aCxzPWwuX21hbGxvYyh1KSx3LnB1c2gocyk7bGV0IGU9cy80O2ZvcihsZXQgdD0wO3Q8YS5sZW5ndGg7dCsrKXtpZihcInN0cmluZ1wiIT10eXBlb2YgYVt0XSl0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke3R9IGlzIG5vdCBhIHN0cmluZ2ApO2wuSEVBUFUzMltlKytdPSgwLG8uYWxsb2NXYXNtU3RyaW5nKShhW3RdLHcpfX1lbHNlIHU9YS5ieXRlTGVuZ3RoLHM9bC5fbWFsbG9jKHUpLHcucHVzaChzKSxsLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsYS5ieXRlT2Zmc2V0LHUpLHMpO2NvbnN0IGM9bC5zdGFja1NhdmUoKSxmPWwuc3RhY2tBbGxvYyg0KnIubGVuZ3RoKTt0cnl7bGV0IGU9Zi80O3IuZm9yRWFjaCgodD0+bC5IRUFQMzJbZSsrXT10KSk7Y29uc3Qgbj1sLl9PcnRDcmVhdGVUZW5zb3IoKDAsaS50ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSkodCkscyx1LGYsci5sZW5ndGgpO2lmKDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgY3JlYXRlIGEgdGVuc29yXCIpO2IucHVzaChuKX1maW5hbGx5e2wuc3RhY2tSZXN0b3JlKGMpfX1jb25zdCBlPWwuc3RhY2tTYXZlKCkscz1sLnN0YWNrQWxsb2MoNCpnKSx1PWwuc3RhY2tBbGxvYyg0KmcpLGY9bC5zdGFja0FsbG9jKDQqaCksXz1sLnN0YWNrQWxsb2MoNCpoKTt0cnl7bGV0IGU9cy80LG49dS80LHI9Zi80LG89Xy80O2ZvcihsZXQgcj0wO3I8ZztyKyspbC5IRUFQVTMyW2UrK109YltyXSxsLkhFQVBVMzJbbisrXT1kW3Rbcl1dO2ZvcihsZXQgZT0wO2U8aDtlKyspbC5IRUFQVTMyW3IrK109MCxsLkhFQVBVMzJbbysrXT1tW2FbZV1dO2xldCBjPWwuX09ydFJ1bihwLHUscyxnLF8saCxmLHkpO2NvbnN0IHY9bC5qc2VwUnVuUHJvbWlzZTt2JiZ2b2lkIDAhPT12LnRoZW4mJihjPWF3YWl0IHYpO2NvbnN0IHc9W107aWYoMD09PWMpZm9yKGxldCBlPTA7ZTxoO2UrKyl7Y29uc3QgdD1sLkhFQVBVMzJbZi80K2VdLG49bC5zdGFja1NhdmUoKSxyPWwuc3RhY2tBbGxvYygxNik7bGV0IGEsbz0wO3RyeXtpZihjPWwuX09ydEdldFRlbnNvckRhdGEodCxyLHIrNCxyKzgscisxMiksMCE9PWMpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IGFjY2VzcyBvdXRwdXQgdGVuc29yIGRhdGEuIGVycm9yIGNvZGUgPSAke2N9YCk7bGV0IGU9ci80O2NvbnN0IG49bC5IRUFQVTMyW2UrK107bz1sLkhFQVBVMzJbZSsrXTtjb25zdCBzPWwuSEVBUFUzMltlKytdLHU9bC5IRUFQVTMyW2UrK10sZj1bXTtmb3IobGV0IGU9MDtlPHU7ZSsrKWYucHVzaChsLkhFQVBVMzJbcy80K2VdKTtsLl9PcnRGcmVlKHMpO2NvbnN0IHA9MD09PWYubGVuZ3RoPzE6Zi5yZWR1Y2UoKChlLHQpPT5lKnQpKTtpZihhPSgwLGkudGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcpKG4pLFwic3RyaW5nXCI9PT1hKXtjb25zdCBlPVtdO2xldCB0PW8vNDtmb3IobGV0IG49MDtuPHA7bisrKXtjb25zdCByPWwuSEVBUFUzMlt0KytdLGE9bj09PXAtMT92b2lkIDA6bC5IRUFQVTMyW3RdLXI7ZS5wdXNoKGwuVVRGOFRvU3RyaW5nKHIsYSkpfXcucHVzaChbYSxmLGVdKX1lbHNle2NvbnN0IGU9bmV3KCgwLGkudGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yKShhKSkocCk7bmV3IFVpbnQ4QXJyYXkoZS5idWZmZXIsZS5ieXRlT2Zmc2V0LGUuYnl0ZUxlbmd0aCkuc2V0KGwuSEVBUFU4LnN1YmFycmF5KG8sbytlLmJ5dGVMZW5ndGgpKSx3LnB1c2goW2EsZixlXSl9fWZpbmFsbHl7bC5zdGFja1Jlc3RvcmUobiksXCJzdHJpbmdcIj09PWEmJm8mJmwuX2ZyZWUobyksbC5fT3J0UmVsZWFzZVRlbnNvcih0KX19aWYoMD09PWMpcmV0dXJuIHc7dGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS4gZXJyb3IgY29kZSA9ICR7Y30uYCl9ZmluYWxseXtsLnN0YWNrUmVzdG9yZShlKX19ZmluYWxseXtiLmZvckVhY2gobC5fT3J0UmVsZWFzZVRlbnNvciksdy5mb3JFYWNoKGwuX2ZyZWUpLGwuX09ydFJlbGVhc2VSdW5PcHRpb25zKHkpLHYuZm9yRWFjaChsLl9mcmVlKX19LHQuZW5kUHJvZmlsaW5nPWU9Pntjb25zdCB0PSgwLHMuZ2V0SW5zdGFuY2UpKCksbj11LmdldChlKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7Y29uc3Qgcj1uWzBdLGE9dC5fT3J0RW5kUHJvZmlsaW5nKHIpO2lmKDA9PT1hKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lXCIpO3QuX09ydEZyZWUoYSl9LHQuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnM9ZT0+e2NvbnN0IHQ9W107Zm9yKGNvbnN0IG4gb2YgZSl7Y29uc3QgZT1uWzJdOyFBcnJheS5pc0FycmF5KGUpJiZlLmJ1ZmZlciYmdC5wdXNoKGUuYnVmZmVyKX1yZXR1cm4gdH19LDI2MzpmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCxuLHIpe3ZvaWQgMD09PXImJihyPW4pO3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxuKTthJiYhKFwiZ2V0XCJpbiBhPyF0Ll9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpfHwoYT17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtuXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLGEpfTpmdW5jdGlvbihlLHQsbixyKXt2b2lkIDA9PT1yJiYocj1uKSxlW3JdPXRbbl19KSxhPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOnR9KX06ZnVuY3Rpb24oZSx0KXtlLmRlZmF1bHQ9dH0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgbiBpbiBlKVwiZGVmYXVsdFwiIT09biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbikmJnIodCxlLG4pO3JldHVybiBhKHQsZSksdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kaXNwb3NlPXQuZ2V0SW5zdGFuY2U9dC5pbml0aWFsaXplV2ViQXNzZW1ibHk9dm9pZCAwO2NvbnN0IGk9byhuKDQ0OSkpLHM9big5MzIpLHU9big0NzQpO2xldCBjLGw9ITEsZj0hMSxwPSExO3QuaW5pdGlhbGl6ZVdlYkFzc2VtYmx5PWFzeW5jIGU9PntpZihsKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtpZihmKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvIFxcJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpXFwnIGRldGVjdGVkLlwiKTtpZihwKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gXFwnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KClcXCcgZmFpbGVkLlwiKTtmPSEwO2NvbnN0IHQ9ZS5pbml0VGltZW91dCxyPWUubnVtVGhyZWFkcyxhPWUuc2ltZCxvPXI+MSYmKCgpPT57dHJ5e3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciYmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBNZXNzYWdlQ2hhbm5lbCYmKG5ldyBNZXNzYWdlQ2hhbm5lbCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpKX1jYXRjaChlKXtyZXR1cm4hMX19KSgpLGQ9YSYmKCgpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMzAsMSwyOCwwLDY1LDAsMjUzLDE1LDI1MywxMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1MywxODYsMSwyNiwxMV0pKX1jYXRjaChlKXtyZXR1cm4hMX19KSgpLG09ZS53YXNtUGF0aHMsZz1cInN0cmluZ1wiPT10eXBlb2YgbT9tOnZvaWQgMCxoPSgoZSx0KT0+dD9lP1wib3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtXCI6XCJvcnQtd2FzbS10aHJlYWRlZC53YXNtXCI6ZT9cIm9ydC13YXNtLXNpbWQud2FzbVwiOlwib3J0LXdhc20ud2FzbVwiKShkLG8pLHk9XCJvYmplY3RcIj09dHlwZW9mIG0/bVtoXTp2b2lkIDA7bGV0IHY9ITE7Y29uc3QgYj1bXTtpZih0PjAmJmIucHVzaChuZXcgUHJvbWlzZSgoZT0+e3NldFRpbWVvdXQoKCgpPT57dj0hMCxlKCl9KSx0KX0pKSksYi5wdXNoKG5ldyBQcm9taXNlKCgoZSx0KT0+e2NvbnN0IHI9bz91OnMsYT17bG9jYXRlRmlsZTooZSx0KT0+byYmZS5lbmRzV2l0aChcIi53b3JrZXIuanNcIikmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBCbG9iP1VSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW24oMTU0KV0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pKTplLmVuZHNXaXRoKFwiLndhc21cIik/eXx8KG51bGwhPWc/Zzp0KStoOnQrZX07aWYobylpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgQmxvYilhLm1haW5TY3JpcHRVcmxPckJsb2I9aS5qb2luKFwiL1wiLFwib3J0LXdhc20tdGhyZWFkZWQuanNcIik7ZWxzZXtjb25zdCBlPWB2YXIgb3J0V2FzbVRocmVhZGVkPShmdW5jdGlvbigpe3ZhciBfc2NyaXB0RGlyO3JldHVybiAke3IudG9TdHJpbmcoKX19KSgpO2A7YS5tYWluU2NyaXB0VXJsT3JCbG9iPW5ldyBCbG9iKFtlXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSl9cihhKS50aGVuKCh0PT57Zj0hMSxsPSEwLGM9dCxlKCl9KSwoZT0+e2Y9ITEscD0hMCx0KGUpfSkpfSkpKSxhd2FpdCBQcm9taXNlLnJhY2UoYiksdil0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHt0fW1zYCl9LHQuZ2V0SW5zdGFuY2U9KCk9PntpZihsJiZjKXJldHVybiBjO3Rocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuXCIpfSx0LmRpc3Bvc2U9KCk9Pnt2YXIgZTshbHx8Znx8cHx8KGY9ITAsbnVsbD09PShlPWMuUFRocmVhZCl8fHZvaWQgMD09PWV8fGUudGVybWluYXRlQWxsVGhyZWFkcygpLGM9dm9pZCAwLGY9ITEsbD0hMSxwPSEwKX19LDQ3NDooZSx0LG4pPT57dmFyIF9zY3JpcHREaXIscj0oX3NjcmlwdERpcj0oX3NjcmlwdERpcj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwKXx8XCIvaW5kZXguanNcIixmdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIFAuYnVmZmVyIT1EJiZHKFAuYnVmZmVyKSxGfWZ1bmN0aW9uIHIoKXtyZXR1cm4gUC5idWZmZXIhPUQmJkcoUC5idWZmZXIpLFV9ZnVuY3Rpb24gYSgpe3JldHVybiBQLmJ1ZmZlciE9RCYmRyhQLmJ1ZmZlciksSX1mdW5jdGlvbiBvKCl7cmV0dXJuIFAuYnVmZmVyIT1EJiZHKFAuYnVmZmVyKSxXfWZ1bmN0aW9uIGkoKXtyZXR1cm4gUC5idWZmZXIhPUQmJkcoUC5idWZmZXIpLGp9dmFyIHMsdSxjO2U9ZXx8e30sc3x8KHM9dm9pZCAwIT09ZT9lOnt9KSxzLnJlYWR5PW5ldyBQcm9taXNlKChmdW5jdGlvbihlLHQpe3U9ZSxjPXR9KSk7dmFyIGwsZixwLGQsbSxnLGg9T2JqZWN0LmFzc2lnbih7fSxzKSx5PVwiLi90aGlzLnByb2dyYW1cIix2PShlLHQpPT57dGhyb3cgdH0sYj1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93LHc9XCJmdW5jdGlvblwiPT10eXBlb2YgaW1wb3J0U2NyaXB0cyxfPVwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzJiZcIm9iamVjdFwiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyYmXCJzdHJpbmdcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSxPPXMuRU5WSVJPTk1FTlRfSVNfUFRIUkVBRHx8ITEsUz1cIlwiO2Z1bmN0aW9uIFQoZSl7cmV0dXJuIHMubG9jYXRlRmlsZT9zLmxvY2F0ZUZpbGUoZSxTKTpTK2V9aWYoXyl7bGV0IHQ7Uz13P24oOTA4KS5kaXJuYW1lKFMpK1wiL1wiOlwiLy9cIixnPSgpPT57bXx8KGQ9bigzODQpLG09big5MDgpKX0sbD1mdW5jdGlvbihlLHQpe3JldHVybiBnKCksZT1tLm5vcm1hbGl6ZShlKSxkLnJlYWRGaWxlU3luYyhlLHQ/dm9pZCAwOlwidXRmOFwiKX0scD1lPT4oKGU9bChlLCEwKSkuYnVmZmVyfHwoZT1uZXcgVWludDhBcnJheShlKSksZSksZj0oZSx0LG4pPT57ZygpLGU9bS5ub3JtYWxpemUoZSksZC5yZWFkRmlsZShlLChmdW5jdGlvbihlLHIpe2U/bihlKTp0KHIuYnVmZmVyKX0pKX0sMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYoeT1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXFxcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSxwcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIiwoZnVuY3Rpb24oZSl7aWYoIShlIGluc3RhbmNlb2YgaWUpKXRocm93IGV9KSkscHJvY2Vzcy5vbihcInVuaGFuZGxlZFJlamVjdGlvblwiLChmdW5jdGlvbihlKXt0aHJvdyBlfSkpLHY9KGUsdCk9PntpZihDKXRocm93IHByb2Nlc3MuZXhpdENvZGU9ZSx0O3QgaW5zdGFuY2VvZiBpZXx8eChcImV4aXRpbmcgZHVlIHRvIGV4Y2VwdGlvbjogXCIrdCkscHJvY2Vzcy5leGl0KGUpfSxzLmluc3BlY3Q9ZnVuY3Rpb24oKXtyZXR1cm5cIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdXCJ9O3RyeXt0PW4oOTI1KX1jYXRjaChlKXt0aHJvdyBjb25zb2xlLmVycm9yKFxcJ1RoZSBcIndvcmtlcl90aHJlYWRzXCIgbW9kdWxlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBub2RlLmpzIGJ1aWxkIC0gcGVyaGFwcyBhIG5ld2VyIHZlcnNpb24gaXMgbmVlZGVkP1xcJyksZX1uLmcuV29ya2VyPXQuV29ya2VyfWVsc2UoYnx8dykmJih3P1M9c2VsZi5sb2NhdGlvbi5ocmVmOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKFM9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLF9zY3JpcHREaXImJihTPV9zY3JpcHREaXIpLFM9MCE9PVMuaW5kZXhPZihcImJsb2I6XCIpP1Muc3Vic3RyKDAsUy5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKTpcIlwiLF98fChsPWU9Pnt2YXIgdD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHQub3BlbihcIkdFVFwiLGUsITEpLHQuc2VuZChudWxsKSx0LnJlc3BvbnNlVGV4dH0sdyYmKHA9ZT0+e3ZhciB0PW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gdC5vcGVuKFwiR0VUXCIsZSwhMSksdC5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLHQuc2VuZChudWxsKSxuZXcgVWludDhBcnJheSh0LnJlc3BvbnNlKX0pLGY9KGUsdCxuKT0+e3ZhciByPW5ldyBYTUxIdHRwUmVxdWVzdDtyLm9wZW4oXCJHRVRcIixlLCEwKSxyLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsci5vbmxvYWQ9KCk9PnsyMDA9PXIuc3RhdHVzfHwwPT1yLnN0YXR1cyYmci5yZXNwb25zZT90KHIucmVzcG9uc2UpOm4oKX0sci5vbmVycm9yPW4sci5zZW5kKG51bGwpfSkpO18mJlwidW5kZWZpbmVkXCI9PXR5cGVvZiBwZXJmb3JtYW5jZSYmKG4uZy5wZXJmb3JtYW5jZT1uKDk1MykucGVyZm9ybWFuY2UpO3ZhciBBPWNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksRT1jb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtfJiYoZygpLEE9ZT0+ZC53cml0ZVN5bmMoMSxlK1wiXFxcXG5cIiksRT1lPT5kLndyaXRlU3luYygyLGUrXCJcXFxcblwiKSk7dmFyIE0sUj1zLnByaW50fHxBLHg9cy5wcmludEVycnx8RTtPYmplY3QuYXNzaWduKHMsaCksaD1udWxsLHMudGhpc1Byb2dyYW0mJih5PXMudGhpc1Byb2dyYW0pLHMucXVpdCYmKHY9cy5xdWl0KSxzLndhc21CaW5hcnkmJihNPXMud2FzbUJpbmFyeSk7dmFyIEM9cy5ub0V4aXRSdW50aW1lfHwhMDtcIm9iamVjdFwiIT10eXBlb2YgV2ViQXNzZW1ibHkmJm5lKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgUCxrLEQsRixVLEksVyxqLEg9ITEsTD1cInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDA7ZnVuY3Rpb24gWShlLHQsbil7dmFyIHI9KHQ+Pj49MCkrbjtmb3Iobj10O2Vbbl0mJiEobj49cik7KSsrbjtpZigxNjxuLXQmJmUuYnVmZmVyJiZMKXJldHVybiBMLmRlY29kZShlLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyP2Uuc2xpY2UodCxuKTplLnN1YmFycmF5KHQsbikpO2ZvcihyPVwiXCI7dDxuOyl7dmFyIGE9ZVt0KytdO2lmKDEyOCZhKXt2YXIgbz02MyZlW3QrK107aWYoMTkyPT0oMjI0JmEpKXIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMxJmEpPDw2fG8pO2Vsc2V7dmFyIGk9NjMmZVt0KytdOzY1NTM2PihhPTIyND09KDI0MCZhKT8oMTUmYSk8PDEyfG88PDZ8aTooNyZhKTw8MTh8bzw8MTJ8aTw8Nnw2MyZlW3QrK10pP3IrPVN0cmluZy5mcm9tQ2hhckNvZGUoYSk6KGEtPTY1NTM2LHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8YT4+MTAsNTYzMjB8MTAyMyZhKSl9fWVsc2Ugcis9U3RyaW5nLmZyb21DaGFyQ29kZShhKX1yZXR1cm4gcn1mdW5jdGlvbiB6KGUsdCl7cmV0dXJuKGU+Pj49MCk/WShyKCksZSx0KTpcIlwifWZ1bmN0aW9uIEIoZSx0LG4scil7aWYoISgwPHIpKXJldHVybiAwO3ZhciBhPW4+Pj49MDtyPW4rci0xO2Zvcih2YXIgbz0wO288ZS5sZW5ndGg7KytvKXt2YXIgaT1lLmNoYXJDb2RlQXQobyk7aWYoNTUyOTY8PWkmJjU3MzQzPj1pJiYoaT02NTUzNisoKDEwMjMmaSk8PDEwKXwxMDIzJmUuY2hhckNvZGVBdCgrK28pKSwxMjc+PWkpe2lmKG4+PXIpYnJlYWs7dFtuKys+Pj4wXT1pfWVsc2V7aWYoMjA0Nz49aSl7aWYobisxPj1yKWJyZWFrO3RbbisrPj4+MF09MTkyfGk+PjZ9ZWxzZXtpZig2NTUzNT49aSl7aWYobisyPj1yKWJyZWFrO3RbbisrPj4+MF09MjI0fGk+PjEyfWVsc2V7aWYobiszPj1yKWJyZWFrO3RbbisrPj4+MF09MjQwfGk+PjE4LHRbbisrPj4+MF09MTI4fGk+PjEyJjYzfXRbbisrPj4+MF09MTI4fGk+PjYmNjN9dFtuKys+Pj4wXT0xMjh8NjMmaX19cmV0dXJuIHRbbj4+PjBdPTAsbi1hfWZ1bmN0aW9uIE4oZSl7Zm9yKHZhciB0PTAsbj0wO248ZS5sZW5ndGg7KytuKXt2YXIgcj1lLmNoYXJDb2RlQXQobik7MTI3Pj1yP3QrKzoyMDQ3Pj1yP3QrPTI6NTUyOTY8PXImJjU3MzQzPj1yPyh0Kz00LCsrbik6dCs9M31yZXR1cm4gdH1mdW5jdGlvbiBHKGUpe0Q9ZSxzLkhFQVA4PUY9bmV3IEludDhBcnJheShlKSxzLkhFQVAxNj1uZXcgSW50MTZBcnJheShlKSxzLkhFQVAzMj1JPW5ldyBJbnQzMkFycmF5KGUpLHMuSEVBUFU4PVU9bmV3IFVpbnQ4QXJyYXkoZSkscy5IRUFQVTE2PW5ldyBVaW50MTZBcnJheShlKSxzLkhFQVBVMzI9Vz1uZXcgVWludDMyQXJyYXkoZSkscy5IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkoZSkscy5IRUFQRjY0PWo9bmV3IEZsb2F0NjRBcnJheShlKX1PJiYoRD1zLmJ1ZmZlcik7dmFyIHE9cy5JTklUSUFMX01FTU9SWXx8MTY3NzcyMTY7aWYoTylQPXMud2FzbU1lbW9yeSxEPXMuYnVmZmVyO2Vsc2UgaWYocy53YXNtTWVtb3J5KVA9cy53YXNtTWVtb3J5O2Vsc2UgaWYoISgoUD1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOnEvNjU1MzYsbWF4aW11bTo2NTUzNixzaGFyZWQ6ITB9KSkuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKXRocm93IHgoXCJyZXF1ZXN0ZWQgYSBzaGFyZWQgV2ViQXNzZW1ibHkuTWVtb3J5IGJ1dCB0aGUgcmV0dXJuZWQgYnVmZmVyIGlzIG5vdCBhIFNoYXJlZEFycmF5QnVmZmVyLCBpbmRpY2F0aW5nIHRoYXQgd2hpbGUgdGhlIGJyb3dzZXIgaGFzIFNoYXJlZEFycmF5QnVmZmVyIGl0IGRvZXMgbm90IGhhdmUgV2ViQXNzZW1ibHkgdGhyZWFkcyBzdXBwb3J0IC0geW91IG1heSBuZWVkIHRvIHNldCBhIGZsYWdcIiksXyYmY29uc29sZS5sb2coXCIob24gbm9kZSB5b3UgbWF5IG5lZWQ6IC0tZXhwZXJpbWVudGFsLXdhc20tdGhyZWFkcyAtLWV4cGVyaW1lbnRhbC13YXNtLWJ1bGstbWVtb3J5IGFuZCBhbHNvIHVzZSBhIHJlY2VudCB2ZXJzaW9uKVwiKSxFcnJvcihcImJhZCBtZW1vcnlcIik7UCYmKEQ9UC5idWZmZXIpLHE9RC5ieXRlTGVuZ3RoLEcoRCk7dmFyICQsVj1bXSxKPVtdLFE9W107ZnVuY3Rpb24gWCgpe3ZhciBlPXMucHJlUnVuLnNoaWZ0KCk7Vi51bnNoaWZ0KGUpfXZhciBLLFo9MCxlZT1udWxsLHRlPW51bGw7ZnVuY3Rpb24gbmUoZSl7dGhyb3cgTz9wb3N0TWVzc2FnZSh7Y21kOlwib25BYm9ydFwiLGFyZzplfSk6cy5vbkFib3J0JiZzLm9uQWJvcnQoZSkseChlPVwiQWJvcnRlZChcIitlK1wiKVwiKSxIPSEwLGU9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihlK1wiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiKSxjKGUpLGV9ZnVuY3Rpb24gcmUoKXtyZXR1cm4gSy5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKX1mdW5jdGlvbiBhZSgpe3ZhciBlPUs7dHJ5e2lmKGU9PUsmJk0pcmV0dXJuIG5ldyBVaW50OEFycmF5KE0pO2lmKHApcmV0dXJuIHAoZSk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9Y2F0Y2goZSl7bmUoZSl9fUs9XCJvcnQtd2FzbS10aHJlYWRlZC53YXNtXCIscmUoKXx8KEs9VChLKSk7dmFyIG9lPXt9O2Z1bmN0aW9uIGllKGUpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9XCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiK2UrXCIpXCIsdGhpcy5zdGF0dXM9ZX1mdW5jdGlvbiBzZShlKXsoZT1mZS5MYVtlXSl8fG5lKCksZmUuWGEoZSl9ZnVuY3Rpb24gdWUoZSl7dmFyIHQ9ZmUubGIoKTtpZighdClyZXR1cm4gNjtmZS5SYS5wdXNoKHQpLGZlLkxhW2UuS2FdPXQsdC5LYT1lLkthO3ZhciBuPXtjbWQ6XCJydW5cIixzdGFydF9yb3V0aW5lOmUucGIsYXJnOmUuaWIscHRocmVhZF9wdHI6ZS5LYX07cmV0dXJuIHQuUWE9KCk9PntuLnRpbWU9cGVyZm9ybWFuY2Uubm93KCksdC5wb3N0TWVzc2FnZShuLGUudmIpfSx0LmxvYWRlZCYmKHQuUWEoKSxkZWxldGUgdC5RYSksMH1mdW5jdGlvbiBjZShlKXtpZihPKXJldHVybiBIZSgxLDEsZSk7Q3x8KGZlLnFiKCkscy5vbkV4aXQmJnMub25FeGl0KGUpLEg9ITApLHYoZSxuZXcgaWUoZSkpfWZ1bmN0aW9uIGxlKGUsdCl7aWYoIXQmJk8pdGhyb3cgZGUoZSksXCJ1bndpbmRcIjtjZShlKX12YXIgZmU9e09hOltdLFJhOltdLCRhOltdLExhOnt9LFVhOmZ1bmN0aW9uKCl7TyYmZmUubWIoKX0seGI6ZnVuY3Rpb24oKXt9LG1iOmZ1bmN0aW9uKCl7ZmUucmVjZWl2ZU9iamVjdFRyYW5zZmVyPWZlLm9iLGZlLnRocmVhZEluaXRUTFM9ZmUuWmEsZmUuc2V0RXhpdFN0YXR1cz1mZS5ZYSxDPSExfSxZYTpmdW5jdGlvbigpe30scWI6ZnVuY3Rpb24oKXtmb3IodmFyIGUgb2YgT2JqZWN0LnZhbHVlcyhmZS5MYSkpZmUuWGEoZSk7Zm9yKGUgb2YgZmUuT2EpZS50ZXJtaW5hdGUoKTtmZS5PYT1bXX0sWGE6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5LYTtkZWxldGUgZmUuTGFbdF0sZmUuT2EucHVzaChlKSxmZS5SYS5zcGxpY2UoZmUuUmEuaW5kZXhPZihlKSwxKSxlLkthPTAsY3QodCl9LG9iOmZ1bmN0aW9uKCl7fSxaYTpmdW5jdGlvbigpe2ZlLiRhLmZvckVhY2goKGU9PmUoKSkpfSxuYjpmdW5jdGlvbihlLHQpe2Uub25tZXNzYWdlPW49Pnt2YXIgcj0obj1uLmRhdGEpLmNtZDtpZihlLkthJiYoZmUua2I9ZS5LYSksbi50YXJnZXRUaHJlYWQmJm4udGFyZ2V0VGhyZWFkIT1ydCgpKXt2YXIgYT1mZS5MYVtuLnliXTthP2EucG9zdE1lc3NhZ2UobixuLnRyYW5zZmVyTGlzdCk6eChcXCdJbnRlcm5hbCBlcnJvciEgV29ya2VyIHNlbnQgYSBtZXNzYWdlIFwiXFwnK3IrXFwnXCIgdG8gdGFyZ2V0IHB0aHJlYWQgXFwnK24udGFyZ2V0VGhyZWFkK1wiLCBidXQgdGhhdCB0aHJlYWQgbm8gbG9uZ2VyIGV4aXN0cyFcIil9ZWxzZVwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIj09PXI/RGUobi5xdWV1ZSk6XCJzcGF3blRocmVhZFwiPT09cj91ZShuKTpcImNsZWFudXBUaHJlYWRcIj09PXI/c2Uobi50aHJlYWQpOlwia2lsbFRocmVhZFwiPT09cj8obj1uLnRocmVhZCxyPWZlLkxhW25dLGRlbGV0ZSBmZS5MYVtuXSxyLnRlcm1pbmF0ZSgpLGN0KG4pLGZlLlJhLnNwbGljZShmZS5SYS5pbmRleE9mKHIpLDEpLHIuS2E9MCk6XCJjYW5jZWxUaHJlYWRcIj09PXI/ZmUuTGFbbi50aHJlYWRdLnBvc3RNZXNzYWdlKHtjbWQ6XCJjYW5jZWxcIn0pOlwibG9hZGVkXCI9PT1yPyhlLmxvYWRlZD0hMCx0JiZ0KGUpLGUuUWEmJihlLlFhKCksZGVsZXRlIGUuUWEpKTpcInByaW50XCI9PT1yP1IoXCJUaHJlYWQgXCIrbi50aHJlYWRJZCtcIjogXCIrbi50ZXh0KTpcInByaW50RXJyXCI9PT1yP3goXCJUaHJlYWQgXCIrbi50aHJlYWRJZCtcIjogXCIrbi50ZXh0KTpcImFsZXJ0XCI9PT1yP2FsZXJ0KFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJzZXRpbW1lZGlhdGVcIj09PW4udGFyZ2V0P2UucG9zdE1lc3NhZ2Uobik6XCJvbkFib3J0XCI9PT1yP3Mub25BYm9ydCYmcy5vbkFib3J0KG4uYXJnKTpyJiZ4KFwid29ya2VyIHNlbnQgYW4gdW5rbm93biBjb21tYW5kIFwiK3IpO2ZlLmtiPXZvaWQgMH0sZS5vbmVycm9yPWU9Pnt0aHJvdyB4KFwid29ya2VyIHNlbnQgYW4gZXJyb3IhIFwiK2UuZmlsZW5hbWUrXCI6XCIrZS5saW5lbm8rXCI6IFwiK2UubWVzc2FnZSksZX0sXyYmKGUub24oXCJtZXNzYWdlXCIsKGZ1bmN0aW9uKHQpe2Uub25tZXNzYWdlKHtkYXRhOnR9KX0pKSxlLm9uKFwiZXJyb3JcIiwoZnVuY3Rpb24odCl7ZS5vbmVycm9yKHQpfSkpLGUub24oXCJkZXRhY2hlZEV4aXRcIiwoZnVuY3Rpb24oKXt9KSkpLGUucG9zdE1lc3NhZ2Uoe2NtZDpcImxvYWRcIix1cmxPckJsb2I6cy5tYWluU2NyaXB0VXJsT3JCbG9ifHxfc2NyaXB0RGlyLHdhc21NZW1vcnk6UCx3YXNtTW9kdWxlOmt9KX0saGI6ZnVuY3Rpb24oKXt2YXIgZT1UKFwib3J0LXdhc20tdGhyZWFkZWQud29ya2VyLmpzXCIpO2ZlLk9hLnB1c2gobmV3IFdvcmtlcihlKSl9LGxiOmZ1bmN0aW9uKCl7cmV0dXJuIDA9PWZlLk9hLmxlbmd0aCYmKGZlLmhiKCksZmUubmIoZmUuT2FbMF0pKSxmZS5PYS5wb3AoKX19O2Z1bmN0aW9uIHBlKGUpe2Zvcig7MDxlLmxlbmd0aDspZS5zaGlmdCgpKHMpfWZ1bmN0aW9uIGRlKGUpe2lmKE8pcmV0dXJuIEhlKDIsMCxlKTt0cnl7bGUoZSl9Y2F0Y2goZSl7ZSBpbnN0YW5jZW9mIGllfHxcInVud2luZFwiPT1lfHx2KDEsZSl9fXMuUFRocmVhZD1mZSxzLmVzdGFibGlzaFN0YWNrU3BhY2U9ZnVuY3Rpb24oKXt2YXIgZT1ydCgpLHQ9YSgpW2UrNDQ+PjI+Pj4wXTtlPWEoKVtlKzQ4Pj4yPj4+MF0sZnQodCx0LWUpLGR0KHQpfTt2YXIgbWUsZ2UsaGU9W107ZnVuY3Rpb24geWUoZSl7dGhpcy5QYT1lLTI0LHRoaXMuZ2I9ZnVuY3Rpb24oZSl7bygpW3RoaXMuUGErND4+Mj4+PjBdPWV9LHRoaXMuY2I9ZnVuY3Rpb24oZSl7bygpW3RoaXMuUGErOD4+Mj4+PjBdPWV9LHRoaXMuZWI9ZnVuY3Rpb24oKXthKClbdGhpcy5QYT4+Mj4+PjBdPTB9LHRoaXMuYmI9ZnVuY3Rpb24oKXt0KClbdGhpcy5QYSsxMj4+MD4+PjBdPTB9LHRoaXMuZmI9ZnVuY3Rpb24oKXt0KClbdGhpcy5QYSsxMz4+MD4+PjBdPTB9LHRoaXMuVWE9ZnVuY3Rpb24oZSx0KXt0aGlzLmFiKCksdGhpcy5nYihlKSx0aGlzLmNiKHQpLHRoaXMuZWIoKSx0aGlzLmJiKCksdGhpcy5mYigpfSx0aGlzLmFiPWZ1bmN0aW9uKCl7bygpW3RoaXMuUGErMTY+PjI+Pj4wXT0wfX1mdW5jdGlvbiB2ZShlLHQsbixyKXtyZXR1cm4gTz9IZSgzLDEsZSx0LG4scik6YmUoZSx0LG4scil9ZnVuY3Rpb24gYmUoZSx0LG4scil7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyKXJldHVybiB4KFwiQ3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFNoYXJlZEFycmF5QnVmZmVyLCBwdGhyZWFkcyBhcmUgbm90IGF2YWlsYWJsZSFcIiksNjt2YXIgYT1bXTtyZXR1cm4gTyYmMD09PWEubGVuZ3RoP3ZlKGUsdCxuLHIpOihlPXtwYjpuLEthOmUsaWI6cix2YjphfSxPPyhlLndiPVwic3Bhd25UaHJlYWRcIixwb3N0TWVzc2FnZShlLGEpLDApOnVlKGUpKX1mdW5jdGlvbiB3ZShlLHQsbil7cmV0dXJuIE8/SGUoNCwxLGUsdCxuKTowfWZ1bmN0aW9uIF9lKGUsdCl7aWYoTylyZXR1cm4gSGUoNSwxLGUsdCl9ZnVuY3Rpb24gT2UoZSx0KXtpZihPKXJldHVybiBIZSg2LDEsZSx0KX1mdW5jdGlvbiBTZShlLHQsbil7aWYoTylyZXR1cm4gSGUoNywxLGUsdCxuKX1mdW5jdGlvbiBUZShlLHQsbil7cmV0dXJuIE8/SGUoOCwxLGUsdCxuKTowfWZ1bmN0aW9uIEFlKGUsdCl7aWYoTylyZXR1cm4gSGUoOSwxLGUsdCl9ZnVuY3Rpb24gRWUoZSx0LG4pe2lmKE8pcmV0dXJuIEhlKDEwLDEsZSx0LG4pfWZ1bmN0aW9uIE1lKGUsdCxuLHIpe2lmKE8pcmV0dXJuIEhlKDExLDEsZSx0LG4scil9ZnVuY3Rpb24gUmUoZSx0LG4scil7aWYoTylyZXR1cm4gSGUoMTIsMSxlLHQsbixyKX1mdW5jdGlvbiB4ZShlLHQsbixyKXtpZihPKXJldHVybiBIZSgxMywxLGUsdCxuLHIpfWZ1bmN0aW9uIENlKGUpe2lmKE8pcmV0dXJuIEhlKDE0LDEsZSl9ZnVuY3Rpb24gUGUoZSx0KXtpZihPKXJldHVybiBIZSgxNSwxLGUsdCl9ZnVuY3Rpb24ga2UoZSx0LG4pe2lmKE8pcmV0dXJuIEhlKDE2LDEsZSx0LG4pfWZ1bmN0aW9uIERlKGUpe0F0b21pY3Muc3RvcmUoYSgpLGU+PjIsMSkscnQoKSYmdXQoZSksQXRvbWljcy5jb21wYXJlRXhjaGFuZ2UoYSgpLGU+PjIsMSwwKX1mdW5jdGlvbiBGZShlKXtyZXR1cm4gbygpW2U+Pj4yXSs0Mjk0OTY3Mjk2KmEoKVtlKzQ+Pj4yXX1mdW5jdGlvbiBVZShlLHQsbixyLGEsbyl7cmV0dXJuIE8/SGUoMTcsMSxlLHQsbixyLGEsbyk6LTUyfWZ1bmN0aW9uIEllKGUsdCxuLHIsYSxvKXtpZihPKXJldHVybiBIZSgxOCwxLGUsdCxuLHIsYSxvKX1mdW5jdGlvbiBXZShlKXt2YXIgbj1OKGUpKzEscj1hdChuKTtyZXR1cm4gciYmQihlLHQoKSxyLG4pLHJ9ZnVuY3Rpb24gamUoZSx0LG4pe2Z1bmN0aW9uIHIoZSl7cmV0dXJuKGU9ZS50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFxcXCgoW0EtWmEteiBdKylcXFxcKSQvKSk/ZVsxXTpcIkdNVFwifWlmKE8pcmV0dXJuIEhlKDE5LDEsZSx0LG4pO3ZhciBpPShuZXcgRGF0ZSkuZ2V0RnVsbFllYXIoKSxzPW5ldyBEYXRlKGksMCwxKSx1PW5ldyBEYXRlKGksNiwxKTtpPXMuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgYz11LmdldFRpbWV6b25lT2Zmc2V0KCksbD1NYXRoLm1heChpLGMpO2EoKVtlPj4yPj4+MF09NjAqbCxhKClbdD4+Mj4+PjBdPU51bWJlcihpIT1jKSxlPXIocyksdD1yKHUpLGU9V2UoZSksdD1XZSh0KSxjPGk/KG8oKVtuPj4yPj4+MF09ZSxvKClbbis0Pj4yPj4+MF09dCk6KG8oKVtuPj4yPj4+MF09dCxvKClbbis0Pj4yPj4+MF09ZSl9ZnVuY3Rpb24gSGUoZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoLTIscj1hcmd1bWVudHM7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PXB0KCk7cmV0dXJuIGU9ZSgpLGR0KHQpLGV9KCgoKT0+e2Zvcih2YXIgYT1tdCg4Km4pLG89YT4+MyxzPTA7czxuO3MrKyl7dmFyIHU9clsyK3NdO2koKVtvK3M+Pj4wXT11fXJldHVybiBzdChlLG4sYSx0KX0pKX1zLmludm9rZUVudHJ5UG9pbnQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj1oZVtlXTtufHwoZT49aGUubGVuZ3RoJiYoaGUubGVuZ3RoPWUrMSksaGVbZV09bj0kLmdldChlKSksZT1uKHQpLEM/ZmUuWWEoZSk6bHQoZSl9LHMuZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZT1EZSxnZT1fPygpPT57dmFyIGU9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gMWUzKmVbMF0rZVsxXS8xZTZ9Ok8/KCk9PnBlcmZvcm1hbmNlLm5vdygpLXMuX19wZXJmb3JtYW5jZV9ub3dfY2xvY2tfZHJpZnQ6KCk9PnBlcmZvcm1hbmNlLm5vdygpO3ZhciBMZSxZZT1bXSx6ZT17fTtmdW5jdGlvbiBCZSgpe2lmKCFMZSl7dmFyIGUsdD17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzooXCJvYmplY3RcIj09dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzp5fHxcIi4vdGhpcy5wcm9ncmFtXCJ9O2ZvcihlIGluIHplKXZvaWQgMD09PXplW2VdP2RlbGV0ZSB0W2VdOnRbZV09emVbZV07dmFyIG49W107Zm9yKGUgaW4gdCluLnB1c2goZStcIj1cIit0W2VdKTtMZT1ufXJldHVybiBMZX1mdW5jdGlvbiBOZShlLG4pe2lmKE8pcmV0dXJuIEhlKDIwLDEsZSxuKTt2YXIgcj0wO3JldHVybiBCZSgpLmZvckVhY2goKGZ1bmN0aW9uKGEsaSl7dmFyIHM9bityO2ZvcihpPW8oKVtlKzQqaT4+Mj4+PjBdPXMscz0wO3M8YS5sZW5ndGg7KytzKXQoKVtpKys+PjA+Pj4wXT1hLmNoYXJDb2RlQXQocyk7dCgpW2k+PjA+Pj4wXT0wLHIrPWEubGVuZ3RoKzF9KSksMH1mdW5jdGlvbiBHZShlLHQpe2lmKE8pcmV0dXJuIEhlKDIxLDEsZSx0KTt2YXIgbj1CZSgpO28oKVtlPj4yPj4+MF09bi5sZW5ndGg7dmFyIHI9MDtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbihlKXtyKz1lLmxlbmd0aCsxfSkpLG8oKVt0Pj4yPj4+MF09ciwwfWZ1bmN0aW9uIHFlKGUpe3JldHVybiBPP0hlKDIyLDEsZSk6NTJ9ZnVuY3Rpb24gJGUoZSx0LG4scil7cmV0dXJuIE8/SGUoMjMsMSxlLHQsbixyKTo1Mn1mdW5jdGlvbiBWZShlLHQsbixyLGEpe3JldHVybiBPP0hlKDI0LDEsZSx0LG4scixhKTo3MH12YXIgSmU9W251bGwsW10sW11dO2Z1bmN0aW9uIFFlKGUsdCxuLGEpe2lmKE8pcmV0dXJuIEhlKDI1LDEsZSx0LG4sYSk7Zm9yKHZhciBpPTAscz0wO3M8bjtzKyspe3ZhciB1PW8oKVt0Pj4yPj4+MF0sYz1vKClbdCs0Pj4yPj4+MF07dCs9ODtmb3IodmFyIGw9MDtsPGM7bCsrKXt2YXIgZj1yKClbdStsPj4+MF0scD1KZVtlXTswPT09Znx8MTA9PT1mPygoMT09PWU/Ujp4KShZKHAsMCkpLHAubGVuZ3RoPTApOnAucHVzaChmKX1pKz1jfXJldHVybiBvKClbYT4+Mj4+PjBdPWksMH1mdW5jdGlvbiBYZShlKXtyZXR1cm4gMD09ZSU0JiYoMCE9ZSUxMDB8fDA9PWUlNDAwKX12YXIgS2U9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxaZT1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIGV0KGUsbixyLG8pe2Z1bmN0aW9uIGkoZSx0LG4pe2ZvcihlPVwibnVtYmVyXCI9PXR5cGVvZiBlP2UudG9TdHJpbmcoKTplfHxcIlwiO2UubGVuZ3RoPHQ7KWU9blswXStlO3JldHVybiBlfWZ1bmN0aW9uIHMoZSx0KXtyZXR1cm4gaShlLHQsXCIwXCIpfWZ1bmN0aW9uIHUoZSx0KXtmdW5jdGlvbiBuKGUpe3JldHVybiAwPmU/LTE6MDxlPzE6MH12YXIgcjtyZXR1cm4gMD09PShyPW4oZS5nZXRGdWxsWWVhcigpLXQuZ2V0RnVsbFllYXIoKSkpJiYwPT09KHI9bihlLmdldE1vbnRoKCktdC5nZXRNb250aCgpKSkmJihyPW4oZS5nZXREYXRlKCktdC5nZXREYXRlKCkpKSxyfWZ1bmN0aW9uIGMoZSl7c3dpdGNoKGUuZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gZTtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gbChlKXt2YXIgdD1lLk1hO2ZvcihlPW5ldyBEYXRlKG5ldyBEYXRlKGUuTmErMTkwMCwwLDEpLmdldFRpbWUoKSk7MDx0Oyl7dmFyIG49ZS5nZXRNb250aCgpLHI9KFhlKGUuZ2V0RnVsbFllYXIoKSk/S2U6WmUpW25dO2lmKCEodD5yLWUuZ2V0RGF0ZSgpKSl7ZS5zZXREYXRlKGUuZ2V0RGF0ZSgpK3QpO2JyZWFrfXQtPXItZS5nZXREYXRlKCkrMSxlLnNldERhdGUoMSksMTE+bj9lLnNldE1vbnRoKG4rMSk6KGUuc2V0TW9udGgoMCksZS5zZXRGdWxsWWVhcihlLmdldEZ1bGxZZWFyKCkrMSkpfXJldHVybiBuPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSsxLDAsNCksdD1jKG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDQpKSxuPWMobiksMD49dSh0LGUpPzA+PXUobixlKT9lLmdldEZ1bGxZZWFyKCkrMTplLmdldEZ1bGxZZWFyKCk6ZS5nZXRGdWxsWWVhcigpLTF9dmFyIGY9YSgpW28rNDA+PjI+Pj4wXTtmb3IodmFyIHAgaW4gbz17dGI6YSgpW28+PjI+Pj4wXSxzYjphKClbbys0Pj4yPj4+MF0sU2E6YSgpW28rOD4+Mj4+PjBdLFZhOmEoKVtvKzEyPj4yPj4+MF0sVGE6YSgpW28rMTY+PjI+Pj4wXSxOYTphKClbbysyMD4+Mj4+PjBdLEphOmEoKVtvKzI0Pj4yPj4+MF0sTWE6YSgpW28rMjg+PjI+Pj4wXSx6YjphKClbbyszMj4+Mj4+PjBdLHJiOmEoKVtvKzM2Pj4yPj4+MF0sdWI6Zj96KGYpOlwiXCJ9LHI9eihyKSxmPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcIiVFY1wiOlwiJWNcIixcIiVFQ1wiOlwiJUNcIixcIiVFeFwiOlwiJW0vJWQvJXlcIixcIiVFWFwiOlwiJUg6JU06JVNcIixcIiVFeVwiOlwiJXlcIixcIiVFWVwiOlwiJVlcIixcIiVPZFwiOlwiJWRcIixcIiVPZVwiOlwiJWVcIixcIiVPSFwiOlwiJUhcIixcIiVPSVwiOlwiJUlcIixcIiVPbVwiOlwiJW1cIixcIiVPTVwiOlwiJU1cIixcIiVPU1wiOlwiJVNcIixcIiVPdVwiOlwiJXVcIixcIiVPVVwiOlwiJVVcIixcIiVPVlwiOlwiJVZcIixcIiVPd1wiOlwiJXdcIixcIiVPV1wiOlwiJVdcIixcIiVPeVwiOlwiJXlcIn0pcj1yLnJlcGxhY2UobmV3IFJlZ0V4cChwLFwiZ1wiKSxmW3BdKTt2YXIgZD1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLG09XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpO2ZvcihwIGluIGY9e1wiJWFcIjpmdW5jdGlvbihlKXtyZXR1cm4gZFtlLkphXS5zdWJzdHJpbmcoMCwzKX0sXCIlQVwiOmZ1bmN0aW9uKGUpe3JldHVybiBkW2UuSmFdfSxcIiViXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIG1bZS5UYV0uc3Vic3RyaW5nKDAsMyl9LFwiJUJcIjpmdW5jdGlvbihlKXtyZXR1cm4gbVtlLlRhXX0sXCIlQ1wiOmZ1bmN0aW9uKGUpe3JldHVybiBzKChlLk5hKzE5MDApLzEwMHwwLDIpfSxcIiVkXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHMoZS5WYSwyKX0sXCIlZVwiOmZ1bmN0aW9uKGUpe3JldHVybiBpKGUuVmEsMixcIiBcIil9LFwiJWdcIjpmdW5jdGlvbihlKXtyZXR1cm4gbChlKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlR1wiOmZ1bmN0aW9uKGUpe3JldHVybiBsKGUpfSxcIiVIXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHMoZS5TYSwyKX0sXCIlSVwiOmZ1bmN0aW9uKGUpe3JldHVybiAwPT0oZT1lLlNhKT9lPTEyOjEyPGUmJihlLT0xMikscyhlLDIpfSxcIiVqXCI6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsbj0wO248PWUuVGEtMTt0Kz0oWGUoZS5OYSsxOTAwKT9LZTpaZSlbbisrXSk7cmV0dXJuIHMoZS5WYSt0LDMpfSxcIiVtXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHMoZS5UYSsxLDIpfSxcIiVNXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHMoZS5zYiwyKX0sXCIlblwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXFxcblwifSxcIiVwXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIDA8PWUuU2EmJjEyPmUuU2E/XCJBTVwiOlwiUE1cIn0sXCIlU1wiOmZ1bmN0aW9uKGUpe3JldHVybiBzKGUudGIsMil9LFwiJXRcIjpmdW5jdGlvbigpe3JldHVyblwiXFxcXHRcIn0sXCIldVwiOmZ1bmN0aW9uKGUpe3JldHVybiBlLkphfHw3fSxcIiVVXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHMoTWF0aC5mbG9vcigoZS5NYSs3LWUuSmEpLzcpLDIpfSxcIiVWXCI6ZnVuY3Rpb24oZSl7dmFyIHQ9TWF0aC5mbG9vcigoZS5NYSs3LShlLkphKzYpJTcpLzcpO2lmKDI+PShlLkphKzM3MS1lLk1hLTIpJTcmJnQrKyx0KTUzPT10JiYoND09KG49KGUuSmErMzcxLWUuTWEpJTcpfHwzPT1uJiZYZShlLk5hKXx8KHQ9MSkpO2Vsc2V7dD01Mjt2YXIgbj0oZS5KYSs3LWUuTWEtMSklNzsoND09bnx8NT09biYmWGUoZS5OYSU0MDAtMSkpJiZ0Kyt9cmV0dXJuIHModCwyKX0sXCIld1wiOmZ1bmN0aW9uKGUpe3JldHVybiBlLkphfSxcIiVXXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHMoTWF0aC5mbG9vcigoZS5NYSs3LShlLkphKzYpJTcpLzcpLDIpfSxcIiV5XCI6ZnVuY3Rpb24oZSl7cmV0dXJuKGUuTmErMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJVlcIjpmdW5jdGlvbihlKXtyZXR1cm4gZS5OYSsxOTAwfSxcIiV6XCI6ZnVuY3Rpb24oZSl7dmFyIHQ9MDw9KGU9ZS5yYik7cmV0dXJuIGU9TWF0aC5hYnMoZSkvNjAsKHQ/XCIrXCI6XCItXCIpK1N0cmluZyhcIjAwMDBcIisoZS82MCoxMDArZSU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOmZ1bmN0aW9uKGUpe3JldHVybiBlLnVifSxcIiUlXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIiVcIn19LHI9ci5yZXBsYWNlKC8lJS9nLFwiXFxcXDBcXFxcMFwiKSxmKXIuaW5jbHVkZXMocCkmJihyPXIucmVwbGFjZShuZXcgUmVnRXhwKHAsXCJnXCIpLGZbcF0obykpKTtyZXR1cm4gcD1mdW5jdGlvbihlKXt2YXIgdD1BcnJheShOKGUpKzEpO3JldHVybiBCKGUsdCwwLHQubGVuZ3RoKSx0fShyPXIucmVwbGFjZSgvXFxcXDBcXFxcMC9nLFwiJVwiKSkscC5sZW5ndGg+bj8wOihmdW5jdGlvbihlLG4pe3QoKS5zZXQoZSxuPj4+MCl9KHAsZSkscC5sZW5ndGgtMSl9ZmUuVWEoKTt2YXIgdHQ9W251bGwsY2UsZGUsdmUsd2UsX2UsT2UsU2UsVGUsQWUsRWUsTWUsUmUseGUsQ2UsUGUsa2UsVWUsSWUsamUsTmUsR2UscWUsJGUsVmUsUWVdLG50PXtiOmZ1bmN0aW9uKGUpe3JldHVybiBhdChlKzI0KSsyNH0sYzpmdW5jdGlvbihlLHQsbil7dGhyb3cgbmV3IHllKGUpLlVhKHQsbiksZX0sTDpmdW5jdGlvbihlKXtvdChlLCF3LDEsIWIpLGZlLlphKCl9LGw6ZnVuY3Rpb24oZSl7Tz9wb3N0TWVzc2FnZSh7Y21kOlwiY2xlYW51cFRocmVhZFwiLHRocmVhZDplfSk6c2UoZSl9LEQ6YmUsaTp3ZSxSOl9lLHo6T2UsQjpTZSxUOlRlLFA6QWUsSTpFZSxPOk1lLHA6UmUsQTp4ZSx4OkNlLFE6UGUseTprZSxyOmZ1bmN0aW9uKCl7fSxqOmZ1bmN0aW9uKCl7bmUoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0sczpmdW5jdGlvbigpe25lKFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LHE6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX0sRTpmdW5jdGlvbigpe3JldHVybiAyMDk3MTUyfSxWOmZ1bmN0aW9uKCl7cmV0dXJuITB9LEY6ZnVuY3Rpb24oZSx0LG4scil7aWYoZT09dClzZXRUaW1lb3V0KCgoKT0+RGUocikpKTtlbHNlIGlmKE8pcG9zdE1lc3NhZ2Uoe3RhcmdldFRocmVhZDplLGNtZDpcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCIscXVldWU6cn0pO2Vsc2V7aWYoIShlPWZlLkxhW2VdKSlyZXR1cm47ZS5wb3N0TWVzc2FnZSh7Y21kOlwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIixxdWV1ZTpyfSl9cmV0dXJuIDF9LEs6ZnVuY3Rpb24oKXtyZXR1cm4tMX0sVzpmdW5jdGlvbihlLHQpe2U9bmV3IERhdGUoMWUzKkZlKGUpKSxhKClbdD4+Mj4+PjBdPWUuZ2V0VVRDU2Vjb25kcygpLGEoKVt0KzQ+PjI+Pj4wXT1lLmdldFVUQ01pbnV0ZXMoKSxhKClbdCs4Pj4yPj4+MF09ZS5nZXRVVENIb3VycygpLGEoKVt0KzEyPj4yPj4+MF09ZS5nZXRVVENEYXRlKCksYSgpW3QrMTY+PjI+Pj4wXT1lLmdldFVUQ01vbnRoKCksYSgpW3QrMjA+PjI+Pj4wXT1lLmdldFVUQ0Z1bGxZZWFyKCktMTkwMCxhKClbdCsyND4+Mj4+PjBdPWUuZ2V0VVRDRGF5KCksZT0oZS5nZXRUaW1lKCktRGF0ZS5VVEMoZS5nZXRVVENGdWxsWWVhcigpLDAsMSwwLDAsMCwwKSkvODY0ZTV8MCxhKClbdCsyOD4+Mj4+PjBdPWV9LFg6ZnVuY3Rpb24oZSx0KXtlPW5ldyBEYXRlKDFlMypGZShlKSksYSgpW3Q+PjI+Pj4wXT1lLmdldFNlY29uZHMoKSxhKClbdCs0Pj4yPj4+MF09ZS5nZXRNaW51dGVzKCksYSgpW3QrOD4+Mj4+PjBdPWUuZ2V0SG91cnMoKSxhKClbdCsxMj4+Mj4+PjBdPWUuZ2V0RGF0ZSgpLGEoKVt0KzE2Pj4yPj4+MF09ZS5nZXRNb250aCgpLGEoKVt0KzIwPj4yPj4+MF09ZS5nZXRGdWxsWWVhcigpLTE5MDAsYSgpW3QrMjQ+PjI+Pj4wXT1lLmdldERheSgpO3ZhciBuPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDEpLHI9KGUuZ2V0VGltZSgpLW4uZ2V0VGltZSgpKS84NjRlNXwwO2EoKVt0KzI4Pj4yPj4+MF09cixhKClbdCszNj4+Mj4+PjBdPS02MCplLmdldFRpbWV6b25lT2Zmc2V0KCkscj1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLGU9MHwociE9KG49bi5nZXRUaW1lem9uZU9mZnNldCgpKSYmZS5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbihuLHIpKSxhKClbdCszMj4+Mj4+PjBdPWV9LFk6ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IERhdGUoYSgpW2UrMjA+PjI+Pj4wXSsxOTAwLGEoKVtlKzE2Pj4yPj4+MF0sYSgpW2UrMTI+PjI+Pj4wXSxhKClbZSs4Pj4yPj4+MF0sYSgpW2UrND4+Mj4+PjBdLGEoKVtlPj4yPj4+MF0sMCksbj1hKClbZSszMj4+Mj4+PjBdLHI9dC5nZXRUaW1lem9uZU9mZnNldCgpLG89bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSksaT1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLHM9by5nZXRUaW1lem9uZU9mZnNldCgpLHU9TWF0aC5taW4ocyxpKTtyZXR1cm4gMD5uP2EoKVtlKzMyPj4yPj4+MF09TnVtYmVyKGkhPXMmJnU9PXIpOjA8biE9KHU9PXIpJiYoaT1NYXRoLm1heChzLGkpLHQuc2V0VGltZSh0LmdldFRpbWUoKSs2ZTQqKCgwPG4/dTppKS1yKSkpLGEoKVtlKzI0Pj4yPj4+MF09dC5nZXREYXkoKSxuPSh0LmdldFRpbWUoKS1vLmdldFRpbWUoKSkvODY0ZTV8MCxhKClbZSsyOD4+Mj4+PjBdPW4sYSgpW2U+PjI+Pj4wXT10LmdldFNlY29uZHMoKSxhKClbZSs0Pj4yPj4+MF09dC5nZXRNaW51dGVzKCksYSgpW2UrOD4+Mj4+PjBdPXQuZ2V0SG91cnMoKSxhKClbZSsxMj4+Mj4+PjBdPXQuZ2V0RGF0ZSgpLGEoKVtlKzE2Pj4yPj4+MF09dC5nZXRNb250aCgpLHQuZ2V0VGltZSgpLzFlM3wwfSxHOlVlLEg6SWUsWjpmdW5jdGlvbiBlKHQsbixyKXtlLmpifHwoZS5qYj0hMCxqZSh0LG4scikpfSxkOmZ1bmN0aW9uKCl7bmUoXCJcIil9LG06ZnVuY3Rpb24oKXtpZighXyYmIXcpe3ZhciBlPVwiQmxvY2tpbmcgb24gdGhlIG1haW4gdGhyZWFkIGlzIHZlcnkgZGFuZ2Vyb3VzLCBzZWUgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZy9kb2NzL3BvcnRpbmcvcHRocmVhZHMuaHRtbCNibG9ja2luZy1vbi10aGUtbWFpbi1icm93c2VyLXRocmVhZFwiO21lfHwobWU9e30pLG1lW2VdfHwobWVbZV09MSxfJiYoZT1cIndhcm5pbmc6IFwiK2UpLHgoZSkpfX0sdzpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTAxNzYwfSxmOmdlLFM6ZnVuY3Rpb24oZSx0LG4pe3IoKS5jb3B5V2l0aGluKGU+Pj4wLHQ+Pj4wLHQrbj4+PjApfSxnOmZ1bmN0aW9uKCl7cmV0dXJuIF8/big5OTMpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3l9LEo6ZnVuY3Rpb24oZSx0LG4pe1llLmxlbmd0aD10LG4+Pj0zO2Zvcih2YXIgcj0wO3I8dDtyKyspWWVbcl09aSgpW24rcj4+PjBdO3JldHVybigwPmU/b2VbLWUtMV06dHRbZV0pLmFwcGx5KG51bGwsWWUpfSx2OmZ1bmN0aW9uKGUpe3ZhciB0PXIoKS5sZW5ndGg7aWYoKGU+Pj49MCk8PXR8fDQyOTQ5MDE3NjA8ZSlyZXR1cm4hMTtmb3IodmFyIG49MTs0Pj1uO24qPTIpe3ZhciBhPXQqKDErLjIvbik7YT1NYXRoLm1pbihhLGUrMTAwNjYzMjk2KTt2YXIgbz1NYXRoO2E9TWF0aC5tYXgoZSxhKSxvPW8ubWluLmNhbGwobyw0Mjk0OTAxNzYwLGErKDY1NTM2LWElNjU1MzYpJTY1NTM2KTtlOnt0cnl7UC5ncm93KG8tRC5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTYpLEcoUC5idWZmZXIpO3ZhciBpPTE7YnJlYWsgZX1jYXRjaChlKXt9aT12b2lkIDB9aWYoaSlyZXR1cm4hMH1yZXR1cm4hMX0sVTpmdW5jdGlvbigpe3Rocm93XCJ1bndpbmRcIn0sTTpOZSxOOkdlLGs6bGUsaDpxZSxvOiRlLHQ6VmUsbjpRZSx1OmZ1bmN0aW9uIGUocixhKXtlLldhfHwoZS5XYT1mdW5jdGlvbigpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBjcnlwdG8mJlwiZnVuY3Rpb25cIj09dHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpe3ZhciBlPW5ldyBVaW50OEFycmF5KDEpO3JldHVybigpPT4oY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhlKSxlWzBdKX1pZihfKXRyeXt2YXIgdD1uKDc2MCk7cmV0dXJuKCk9PnQucmFuZG9tQnl0ZXMoMSlbMF19Y2F0Y2goZSl7fXJldHVybigpPT5uZShcInJhbmRvbURldmljZVwiKX0oKSk7Zm9yKHZhciBvPTA7bzxhO28rKyl0KClbcitvPj4wPj4+MF09ZS5XYSgpO3JldHVybiAwfSxhOlB8fHMud2FzbU1lbW9yeSxDOmV0LGU6ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIGV0KGUsdCxuLHIpfX07IWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3MuYXNtPWUuZXhwb3J0cyxmZS4kYS5wdXNoKHMuYXNtLndhKSwkPXMuYXNtLnphLEoudW5zaGlmdChzLmFzbS5fKSxrPXQsT3x8KFotLSxzLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJnMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhaKSwwPT1aJiYobnVsbCE9PWVlJiYoY2xlYXJJbnRlcnZhbChlZSksZWU9bnVsbCksdGUmJihlPXRlLHRlPW51bGwsZSgpKSkpfWZ1bmN0aW9uIHQodCl7ZSh0Lmluc3RhbmNlLHQubW9kdWxlKX1mdW5jdGlvbiBuKGUpe3JldHVybiBmdW5jdGlvbigpe2lmKCFNJiYoYnx8dykpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGZldGNoJiYhSy5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSlyZXR1cm4gZmV0Y2goSyx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24oZSl7aWYoIWUub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgXFwnXCIrSytcIlxcJ1wiO3JldHVybiBlLmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIGFlKCl9KSk7aWYoZilyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsdCl7ZihLLChmdW5jdGlvbih0KXtlKG5ldyBVaW50OEFycmF5KHQpKX0pLHQpfSkpfXJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKChmdW5jdGlvbigpe3JldHVybiBhZSgpfSkpfSgpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShlLHIpfSkpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBlfSkpLnRoZW4oZSwoZnVuY3Rpb24oZSl7eChcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK2UpLG5lKGUpfSkpfXZhciByPXthOm50fTtpZihPfHwoWisrLHMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmcy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKFopKSxzLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIHMuaW5zdGFudGlhdGVXYXNtKHIsZSl9Y2F0Y2goZSl7cmV0dXJuIHgoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIitlKSwhMX0oTXx8XCJmdW5jdGlvblwiIT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fHJlKCl8fEsuc3RhcnRzV2l0aChcImZpbGU6Ly9cIil8fF98fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGZldGNoP24odCk6ZmV0Y2goSyx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKGUscikudGhlbih0LChmdW5jdGlvbihlKXtyZXR1cm4geChcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIitlKSx4KFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksbih0KX0pKX0pKSkuY2F0Y2goYyl9KCkscy5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fX193YXNtX2NhbGxfY3RvcnM9cy5hc20uXykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRJbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEluaXQ9cy5hc20uJCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybihzLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1zLmFzbS5hYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj1mdW5jdGlvbigpe3JldHVybihzLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj1zLmFzbS5iYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PXMuYXNtLmNhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybihzLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9cy5hc20uZGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0Q3JlYXRlU2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybihzLl9PcnRDcmVhdGVTZXNzaW9uPXMuYXNtLmVhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydFJlbGVhc2VTZXNzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VTZXNzaW9uPXMuYXNtLmZhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldElucHV0Q291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0R2V0SW5wdXRDb3VudD1zLmFzbS5nYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRHZXRPdXRwdXRDb3VudD1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRPdXRwdXRDb3VudD1zLmFzbS5oYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRHZXRJbnB1dE5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0R2V0SW5wdXROYW1lPXMuYXNtLmlhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldE91dHB1dE5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0R2V0T3V0cHV0TmFtZT1zLmFzbS5qYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRGcmVlPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEZyZWU9cy5hc20ua2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0Q3JlYXRlVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydENyZWF0ZVRlbnNvcj1zLmFzbS5sYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRHZXRUZW5zb3JEYXRhPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEdldFRlbnNvckRhdGE9cy5hc20ubWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0UmVsZWFzZVRlbnNvcj1mdW5jdGlvbigpe3JldHVybihzLl9PcnRSZWxlYXNlVGVuc29yPXMuYXNtLm5hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydENyZWF0ZVJ1bk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1zLmFzbS5vYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRBZGRSdW5Db25maWdFbnRyeT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRBZGRSdW5Db25maWdFbnRyeT1zLmFzbS5wYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybihzLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1zLmFzbS5xYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRSdW49ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0UnVuPXMuYXNtLnJhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEVuZFByb2ZpbGluZz1mdW5jdGlvbigpe3JldHVybihzLl9PcnRFbmRQcm9maWxpbmc9cy5hc20uc2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIHJ0PXMuX3B0aHJlYWRfc2VsZj1mdW5jdGlvbigpe3JldHVybihydD1zLl9wdGhyZWFkX3NlbGY9cy5hc20udGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sYXQ9cy5fbWFsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKGF0PXMuX21hbGxvYz1zLmFzbS51YSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtzLl9mcmVlPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX2ZyZWU9cy5hc20udmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fX2Vtc2NyaXB0ZW5fdGxzX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fX2Vtc2NyaXB0ZW5fdGxzX2luaXQ9cy5hc20ud2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIG90PXMuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKG90PXMuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PXMuYXNtLnhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3MuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPXMuYXNtLnlhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBpdCxzdD1zLl9lbXNjcmlwdGVuX3J1bl9pbl9tYWluX3J1bnRpbWVfdGhyZWFkX2pzPWZ1bmN0aW9uKCl7cmV0dXJuKHN0PXMuX2Vtc2NyaXB0ZW5fcnVuX2luX21haW5fcnVudGltZV90aHJlYWRfanM9cy5hc20uQWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdXQ9cy5fX2Vtc2NyaXB0ZW5fcHJveHlfZXhlY3V0ZV90YXNrX3F1ZXVlPWZ1bmN0aW9uKCl7cmV0dXJuKHV0PXMuX19lbXNjcmlwdGVuX3Byb3h5X2V4ZWN1dGVfdGFza19xdWV1ZT1zLmFzbS5CYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxjdD1zLl9fZW1zY3JpcHRlbl90aHJlYWRfZnJlZV9kYXRhPWZ1bmN0aW9uKCl7cmV0dXJuKGN0PXMuX19lbXNjcmlwdGVuX3RocmVhZF9mcmVlX2RhdGE9cy5hc20uQ2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbHQ9cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4obHQ9cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9cy5hc20uRGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZnQ9cy5fZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzPWZ1bmN0aW9uKCl7cmV0dXJuKGZ0PXMuX2Vtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0cz1zLmFzbS5FYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxwdD1zLnN0YWNrU2F2ZT1mdW5jdGlvbigpe3JldHVybihwdD1zLnN0YWNrU2F2ZT1zLmFzbS5GYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxkdD1zLnN0YWNrUmVzdG9yZT1mdW5jdGlvbigpe3JldHVybihkdD1zLnN0YWNrUmVzdG9yZT1zLmFzbS5HYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxtdD1zLnN0YWNrQWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4obXQ9cy5zdGFja0FsbG9jPXMuYXNtLkhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIGd0KCl7ZnVuY3Rpb24gZSgpe2lmKCFpdCYmKGl0PSEwLHMuY2FsbGVkUnVuPSEwLCFIKSYmKE98fHBlKEopLHUocykscy5vblJ1bnRpbWVJbml0aWFsaXplZCYmcy5vblJ1bnRpbWVJbml0aWFsaXplZCgpLCFPKSl7aWYocy5wb3N0UnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBzLnBvc3RSdW4mJihzLnBvc3RSdW49W3MucG9zdFJ1bl0pO3MucG9zdFJ1bi5sZW5ndGg7KXt2YXIgZT1zLnBvc3RSdW4uc2hpZnQoKTtRLnVuc2hpZnQoZSl9cGUoUSl9fWlmKCEoMDxaKSlpZihPKXUocyksT3x8cGUoSikscG9zdE1lc3NhZ2Uoe2NtZDpcImxvYWRlZFwifSk7ZWxzZXtpZihzLnByZVJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2Ygcy5wcmVSdW4mJihzLnByZVJ1bj1bcy5wcmVSdW5dKTtzLnByZVJ1bi5sZW5ndGg7KVgoKTtwZShWKSwwPFp8fChzLnNldFN0YXR1cz8ocy5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtzLnNldFN0YXR1cyhcIlwiKX0pLDEpLGUoKX0pLDEpKTplKCkpfX1pZihzLl9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fX19jeGFfaXNfcG9pbnRlcl90eXBlPXMuYXNtLklhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuVVRGOFRvU3RyaW5nPXoscy5zdHJpbmdUb1VURjg9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBCKGUscigpLHQsbil9LHMubGVuZ3RoQnl0ZXNVVEY4PU4scy5rZWVwUnVudGltZUFsaXZlPWZ1bmN0aW9uKCl7cmV0dXJuIEN9LHMud2FzbU1lbW9yeT1QLHMuc3RhY2tTYXZlPXB0LHMuc3RhY2tSZXN0b3JlPWR0LHMuc3RhY2tBbGxvYz1tdCxzLkV4aXRTdGF0dXM9aWUscy5QVGhyZWFkPWZlLHRlPWZ1bmN0aW9uIGUoKXtpdHx8Z3QoKSxpdHx8KHRlPWUpfSxzLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHMucHJlSW5pdCYmKHMucHJlSW5pdD1bcy5wcmVJbml0XSk7MDxzLnByZUluaXQubGVuZ3RoOylzLnByZUluaXQucG9wKCkoKTtyZXR1cm4gZ3QoKSxlLnJlYWR5fSk7ZS5leHBvcnRzPXJ9LDkzMjooZSx0LG4pPT57dmFyIF9zY3JpcHREaXIscj0oX3NjcmlwdERpcj0oX3NjcmlwdERpcj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwKXx8XCIvaW5kZXguanNcIixmdW5jdGlvbihlKXt2YXIgdCxyLGE7ZT1lfHx7fSx0fHwodD12b2lkIDAhPT1lP2U6e30pLHQucmVhZHk9bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsdCl7cj1lLGE9dH0pKTt2YXIgbyxpLHMsdSxjLGwsZj1PYmplY3QuYXNzaWduKHt9LHQpLHA9XCIuL3RoaXMucHJvZ3JhbVwiLGQ9KGUsdCk9Pnt0aHJvdyB0fSxtPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3csZz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpbXBvcnRTY3JpcHRzLGg9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLHk9XCJcIjtoPyh5PWc/big5MDgpLmRpcm5hbWUoeSkrXCIvXCI6XCIvL1wiLGw9KCk9PntjfHwodT1uKDM4NCksYz1uKDkwOCkpfSxvPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGwoKSxlPWMubm9ybWFsaXplKGUpLHUucmVhZEZpbGVTeW5jKGUsdD92b2lkIDA6XCJ1dGY4XCIpfSxzPWU9PigoZT1vKGUsITApKS5idWZmZXJ8fChlPW5ldyBVaW50OEFycmF5KGUpKSxlKSxpPShlLHQsbik9PntsKCksZT1jLm5vcm1hbGl6ZShlKSx1LnJlYWRGaWxlKGUsKGZ1bmN0aW9uKGUscil7ZT9uKGUpOnQoci5idWZmZXIpfSkpfSwxPHByb2Nlc3MuYXJndi5sZW5ndGgmJihwPXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLChmdW5jdGlvbihlKXtpZighKGUgaW5zdGFuY2VvZiAkKSl0aHJvdyBlfSkpLHByb2Nlc3Mub24oXCJ1bmhhbmRsZWRSZWplY3Rpb25cIiwoZnVuY3Rpb24oZSl7dGhyb3cgZX0pKSxkPShlLHQpPT57aWYoXyl0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPWUsdDt0IGluc3RhbmNlb2YgJHx8dyhcImV4aXRpbmcgZHVlIHRvIGV4Y2VwdGlvbjogXCIrdCkscHJvY2Vzcy5leGl0KGUpfSx0Lmluc3BlY3Q9ZnVuY3Rpb24oKXtyZXR1cm5cIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdXCJ9KToobXx8ZykmJihnP3k9c2VsZi5sb2NhdGlvbi5ocmVmOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKHk9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLF9zY3JpcHREaXImJih5PV9zY3JpcHREaXIpLHk9MCE9PXkuaW5kZXhPZihcImJsb2I6XCIpP3kuc3Vic3RyKDAseS5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKTpcIlwiLG89ZT0+e3ZhciB0PW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gdC5vcGVuKFwiR0VUXCIsZSwhMSksdC5zZW5kKG51bGwpLHQucmVzcG9uc2VUZXh0fSxnJiYocz1lPT57dmFyIHQ9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB0Lm9wZW4oXCJHRVRcIixlLCExKSx0LnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsdC5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KHQucmVzcG9uc2UpfSksaT0oZSx0LG4pPT57dmFyIHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3Iub3BlbihcIkdFVFwiLGUsITApLHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixyLm9ubG9hZD0oKT0+ezIwMD09ci5zdGF0dXN8fDA9PXIuc3RhdHVzJiZyLnJlc3BvbnNlP3Qoci5yZXNwb25zZSk6bigpfSxyLm9uZXJyb3I9bixyLnNlbmQobnVsbCl9KTt2YXIgdixiPXQucHJpbnR8fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksdz10LnByaW50RXJyfHxjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtPYmplY3QuYXNzaWduKHQsZiksZj1udWxsLHQudGhpc1Byb2dyYW0mJihwPXQudGhpc1Byb2dyYW0pLHQucXVpdCYmKGQ9dC5xdWl0KSx0Lndhc21CaW5hcnkmJih2PXQud2FzbUJpbmFyeSk7dmFyIF89dC5ub0V4aXRSdW50aW1lfHwhMDtcIm9iamVjdFwiIT10eXBlb2YgV2ViQXNzZW1ibHkmJkIoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciBPLFMsVCxBLEUsTSxSPSExLHg9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwO2Z1bmN0aW9uIEMoZSx0LG4pe3ZhciByPSh0Pj4+PTApK247Zm9yKG49dDtlW25dJiYhKG4+PXIpOykrK247aWYoMTY8bi10JiZlLmJ1ZmZlciYmeClyZXR1cm4geC5kZWNvZGUoZS5zdWJhcnJheSh0LG4pKTtmb3Iocj1cIlwiO3Q8bjspe3ZhciBhPWVbdCsrXTtpZigxMjgmYSl7dmFyIG89NjMmZVt0KytdO2lmKDE5Mj09KDIyNCZhKSlyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzMSZhKTw8NnxvKTtlbHNle3ZhciBpPTYzJmVbdCsrXTs2NTUzNj4oYT0yMjQ9PSgyNDAmYSk/KDE1JmEpPDwxMnxvPDw2fGk6KDcmYSk8PDE4fG88PDEyfGk8PDZ8NjMmZVt0KytdKT9yKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpOihhLT02NTUzNixyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGE+PjEwLDU2MzIwfDEwMjMmYSkpfX1lbHNlIHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoYSl9cmV0dXJuIHJ9ZnVuY3Rpb24gUChlLHQpe3JldHVybihlPj4+PTApP0MoQSxlLHQpOlwiXCJ9ZnVuY3Rpb24gayhlLHQsbixyKXtpZighKDA8cikpcmV0dXJuIDA7dmFyIGE9bj4+Pj0wO3I9bityLTE7Zm9yKHZhciBvPTA7bzxlLmxlbmd0aDsrK28pe3ZhciBpPWUuY2hhckNvZGVBdChvKTtpZig1NTI5Njw9aSYmNTczNDM+PWkmJihpPTY1NTM2KygoMTAyMyZpKTw8MTApfDEwMjMmZS5jaGFyQ29kZUF0KCsrbykpLDEyNz49aSl7aWYobj49cilicmVhazt0W24rKz4+PjBdPWl9ZWxzZXtpZigyMDQ3Pj1pKXtpZihuKzE+PXIpYnJlYWs7dFtuKys+Pj4wXT0xOTJ8aT4+Nn1lbHNle2lmKDY1NTM1Pj1pKXtpZihuKzI+PXIpYnJlYWs7dFtuKys+Pj4wXT0yMjR8aT4+MTJ9ZWxzZXtpZihuKzM+PXIpYnJlYWs7dFtuKys+Pj4wXT0yNDB8aT4+MTgsdFtuKys+Pj4wXT0xMjh8aT4+MTImNjN9dFtuKys+Pj4wXT0xMjh8aT4+NiY2M310W24rKz4+PjBdPTEyOHw2MyZpfX1yZXR1cm4gdFtuPj4+MF09MCxuLWF9ZnVuY3Rpb24gRChlKXtmb3IodmFyIHQ9MCxuPTA7bjxlLmxlbmd0aDsrK24pe3ZhciByPWUuY2hhckNvZGVBdChuKTsxMjc+PXI/dCsrOjIwNDc+PXI/dCs9Mjo1NTI5Njw9ciYmNTczNDM+PXI/KHQrPTQsKytuKTp0Kz0zfXJldHVybiB0fWZ1bmN0aW9uIEYoKXt2YXIgZT1PLmJ1ZmZlcjtTPWUsdC5IRUFQOD1UPW5ldyBJbnQ4QXJyYXkoZSksdC5IRUFQMTY9bmV3IEludDE2QXJyYXkoZSksdC5IRUFQMzI9RT1uZXcgSW50MzJBcnJheShlKSx0LkhFQVBVOD1BPW5ldyBVaW50OEFycmF5KGUpLHQuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkoZSksdC5IRUFQVTMyPU09bmV3IFVpbnQzMkFycmF5KGUpLHQuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KGUpLHQuSEVBUEY2ND1uZXcgRmxvYXQ2NEFycmF5KGUpfXZhciBVPVtdLEk9W10sVz1bXTtmdW5jdGlvbiBqKCl7dmFyIGU9dC5wcmVSdW4uc2hpZnQoKTtVLnVuc2hpZnQoZSl9dmFyIEgsTD0wLFk9bnVsbCx6PW51bGw7ZnVuY3Rpb24gQihlKXt0aHJvdyB0Lm9uQWJvcnQmJnQub25BYm9ydChlKSx3KGU9XCJBYm9ydGVkKFwiK2UrXCIpXCIpLFI9ITAsZT1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKGUrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLGEoZSksZX1mdW5jdGlvbiBOKCl7cmV0dXJuIEguc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIil9aWYoSD1cIm9ydC13YXNtLndhc21cIiwhTigpKXt2YXIgRz1IO0g9dC5sb2NhdGVGaWxlP3QubG9jYXRlRmlsZShHLHkpOnkrR31mdW5jdGlvbiBxKCl7dmFyIGU9SDt0cnl7aWYoZT09SCYmdilyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodik7aWYocylyZXR1cm4gcyhlKTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1jYXRjaChlKXtCKGUpfX1mdW5jdGlvbiAkKGUpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9XCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiK2UrXCIpXCIsdGhpcy5zdGF0dXM9ZX1mdW5jdGlvbiBWKGUpe2Zvcig7MDxlLmxlbmd0aDspZS5zaGlmdCgpKHQpfWZ1bmN0aW9uIEooZSl7dGhpcy5zYT1lLTI0LHRoaXMuSWE9ZnVuY3Rpb24oZSl7TVt0aGlzLnNhKzQ+PjI+Pj4wXT1lfSx0aGlzLkJhPWZ1bmN0aW9uKGUpe01bdGhpcy5zYSs4Pj4yPj4+MF09ZX0sdGhpcy5HYT1mdW5jdGlvbigpe0VbdGhpcy5zYT4+Mj4+PjBdPTB9LHRoaXMuQWE9ZnVuY3Rpb24oKXtUW3RoaXMuc2ErMTI+PjA+Pj4wXT0wfSx0aGlzLkhhPWZ1bmN0aW9uKCl7VFt0aGlzLnNhKzEzPj4wPj4+MF09MH0sdGhpcy55YT1mdW5jdGlvbihlLHQpe3RoaXMuemEoKSx0aGlzLklhKGUpLHRoaXMuQmEodCksdGhpcy5HYSgpLHRoaXMuQWEoKSx0aGlzLkhhKCl9LHRoaXMuemE9ZnVuY3Rpb24oKXtNW3RoaXMuc2ErMTY+PjI+Pj4wXT0wfX1mdW5jdGlvbiBRKGUpe3ZhciB0PUQoZSkrMSxuPWllKHQpO3JldHVybiBuJiZrKGUsVCxuLHQpLG59dmFyIFg9e307ZnVuY3Rpb24gSygpe2lmKCFaKXt2YXIgZSx0PXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOihcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOnB8fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKGUgaW4gWCl2b2lkIDA9PT1YW2VdP2RlbGV0ZSB0W2VdOnRbZV09WFtlXTt2YXIgbj1bXTtmb3IoZSBpbiB0KW4ucHVzaChlK1wiPVwiK3RbZV0pO1o9bn1yZXR1cm4gWn12YXIgWixlZT1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gdGUoZSl7cmV0dXJuIDA9PWUlNCYmKDAhPWUlMTAwfHwwPT1lJTQwMCl9dmFyIG5lPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0scmU9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBhZShlLHQsbixyKXtmdW5jdGlvbiBhKGUsdCxuKXtmb3IoZT1cIm51bWJlclwiPT10eXBlb2YgZT9lLnRvU3RyaW5nKCk6ZXx8XCJcIjtlLmxlbmd0aDx0OyllPW5bMF0rZTtyZXR1cm4gZX1mdW5jdGlvbiBvKGUsdCl7cmV0dXJuIGEoZSx0LFwiMFwiKX1mdW5jdGlvbiBpKGUsdCl7ZnVuY3Rpb24gbihlKXtyZXR1cm4gMD5lPy0xOjA8ZT8xOjB9dmFyIHI7cmV0dXJuIDA9PT0ocj1uKGUuZ2V0RnVsbFllYXIoKS10LmdldEZ1bGxZZWFyKCkpKSYmMD09PShyPW4oZS5nZXRNb250aCgpLXQuZ2V0TW9udGgoKSkpJiYocj1uKGUuZ2V0RGF0ZSgpLXQuZ2V0RGF0ZSgpKSkscn1mdW5jdGlvbiBzKGUpe3N3aXRjaChlLmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIGU7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIHUoZSl7dmFyIHQ9ZS5xYTtmb3IoZT1uZXcgRGF0ZShuZXcgRGF0ZShlLnJhKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8dDspe3ZhciBuPWUuZ2V0TW9udGgoKSxyPSh0ZShlLmdldEZ1bGxZZWFyKCkpP25lOnJlKVtuXTtpZighKHQ+ci1lLmdldERhdGUoKSkpe2Uuc2V0RGF0ZShlLmdldERhdGUoKSt0KTticmVha310LT1yLWUuZ2V0RGF0ZSgpKzEsZS5zZXREYXRlKDEpLDExPm4/ZS5zZXRNb250aChuKzEpOihlLnNldE1vbnRoKDApLGUuc2V0RnVsbFllYXIoZS5nZXRGdWxsWWVhcigpKzEpKX1yZXR1cm4gbj1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCkrMSwwLDQpLHQ9cyhuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCw0KSksbj1zKG4pLDA+PWkodCxlKT8wPj1pKG4sZSk/ZS5nZXRGdWxsWWVhcigpKzE6ZS5nZXRGdWxsWWVhcigpOmUuZ2V0RnVsbFllYXIoKS0xfXZhciBjPUVbcis0MD4+Mj4+PjBdO2Zvcih2YXIgbCBpbiByPXtFYTpFW3I+PjI+Pj4wXSxEYTpFW3IrND4+Mj4+PjBdLHRhOkVbcis4Pj4yPj4+MF0sdmE6RVtyKzEyPj4yPj4+MF0sdWE6RVtyKzE2Pj4yPj4+MF0scmE6RVtyKzIwPj4yPj4+MF0sbGE6RVtyKzI0Pj4yPj4+MF0scWE6RVtyKzI4Pj4yPj4+MF0sSmE6RVtyKzMyPj4yPj4+MF0sQ2E6RVtyKzM2Pj4yPj4+MF0sRmE6Yz9QKGMpOlwiXCJ9LG49UChuKSxjPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcIiVFY1wiOlwiJWNcIixcIiVFQ1wiOlwiJUNcIixcIiVFeFwiOlwiJW0vJWQvJXlcIixcIiVFWFwiOlwiJUg6JU06JVNcIixcIiVFeVwiOlwiJXlcIixcIiVFWVwiOlwiJVlcIixcIiVPZFwiOlwiJWRcIixcIiVPZVwiOlwiJWVcIixcIiVPSFwiOlwiJUhcIixcIiVPSVwiOlwiJUlcIixcIiVPbVwiOlwiJW1cIixcIiVPTVwiOlwiJU1cIixcIiVPU1wiOlwiJVNcIixcIiVPdVwiOlwiJXVcIixcIiVPVVwiOlwiJVVcIixcIiVPVlwiOlwiJVZcIixcIiVPd1wiOlwiJXdcIixcIiVPV1wiOlwiJVdcIixcIiVPeVwiOlwiJXlcIn0pbj1uLnJlcGxhY2UobmV3IFJlZ0V4cChsLFwiZ1wiKSxjW2xdKTt2YXIgZj1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLHA9XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpO2ZvcihsIGluIGM9e1wiJWFcIjpmdW5jdGlvbihlKXtyZXR1cm4gZltlLmxhXS5zdWJzdHJpbmcoMCwzKX0sXCIlQVwiOmZ1bmN0aW9uKGUpe3JldHVybiBmW2UubGFdfSxcIiViXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHBbZS51YV0uc3Vic3RyaW5nKDAsMyl9LFwiJUJcIjpmdW5jdGlvbihlKXtyZXR1cm4gcFtlLnVhXX0sXCIlQ1wiOmZ1bmN0aW9uKGUpe3JldHVybiBvKChlLnJhKzE5MDApLzEwMHwwLDIpfSxcIiVkXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIG8oZS52YSwyKX0sXCIlZVwiOmZ1bmN0aW9uKGUpe3JldHVybiBhKGUudmEsMixcIiBcIil9LFwiJWdcIjpmdW5jdGlvbihlKXtyZXR1cm4gdShlKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlR1wiOmZ1bmN0aW9uKGUpe3JldHVybiB1KGUpfSxcIiVIXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIG8oZS50YSwyKX0sXCIlSVwiOmZ1bmN0aW9uKGUpe3JldHVybiAwPT0oZT1lLnRhKT9lPTEyOjEyPGUmJihlLT0xMiksbyhlLDIpfSxcIiVqXCI6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsbj0wO248PWUudWEtMTt0Kz0odGUoZS5yYSsxOTAwKT9uZTpyZSlbbisrXSk7cmV0dXJuIG8oZS52YSt0LDMpfSxcIiVtXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIG8oZS51YSsxLDIpfSxcIiVNXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIG8oZS5EYSwyKX0sXCIlblwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXFxcblwifSxcIiVwXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIDA8PWUudGEmJjEyPmUudGE/XCJBTVwiOlwiUE1cIn0sXCIlU1wiOmZ1bmN0aW9uKGUpe3JldHVybiBvKGUuRWEsMil9LFwiJXRcIjpmdW5jdGlvbigpe3JldHVyblwiXFxcXHRcIn0sXCIldVwiOmZ1bmN0aW9uKGUpe3JldHVybiBlLmxhfHw3fSxcIiVVXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIG8oTWF0aC5mbG9vcigoZS5xYSs3LWUubGEpLzcpLDIpfSxcIiVWXCI6ZnVuY3Rpb24oZSl7dmFyIHQ9TWF0aC5mbG9vcigoZS5xYSs3LShlLmxhKzYpJTcpLzcpO2lmKDI+PShlLmxhKzM3MS1lLnFhLTIpJTcmJnQrKyx0KTUzPT10JiYoND09KG49KGUubGErMzcxLWUucWEpJTcpfHwzPT1uJiZ0ZShlLnJhKXx8KHQ9MSkpO2Vsc2V7dD01Mjt2YXIgbj0oZS5sYSs3LWUucWEtMSklNzsoND09bnx8NT09biYmdGUoZS5yYSU0MDAtMSkpJiZ0Kyt9cmV0dXJuIG8odCwyKX0sXCIld1wiOmZ1bmN0aW9uKGUpe3JldHVybiBlLmxhfSxcIiVXXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIG8oTWF0aC5mbG9vcigoZS5xYSs3LShlLmxhKzYpJTcpLzcpLDIpfSxcIiV5XCI6ZnVuY3Rpb24oZSl7cmV0dXJuKGUucmErMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJVlcIjpmdW5jdGlvbihlKXtyZXR1cm4gZS5yYSsxOTAwfSxcIiV6XCI6ZnVuY3Rpb24oZSl7dmFyIHQ9MDw9KGU9ZS5DYSk7cmV0dXJuIGU9TWF0aC5hYnMoZSkvNjAsKHQ/XCIrXCI6XCItXCIpK1N0cmluZyhcIjAwMDBcIisoZS82MCoxMDArZSU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOmZ1bmN0aW9uKGUpe3JldHVybiBlLkZhfSxcIiUlXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIiVcIn19LG49bi5yZXBsYWNlKC8lJS9nLFwiXFxcXDBcXFxcMFwiKSxjKW4uaW5jbHVkZXMobCkmJihuPW4ucmVwbGFjZShuZXcgUmVnRXhwKGwsXCJnXCIpLGNbbF0ocikpKTtyZXR1cm4gbD1mdW5jdGlvbihlKXt2YXIgdD1BcnJheShEKGUpKzEpO3JldHVybiBrKGUsdCwwLHQubGVuZ3RoKSx0fShuPW4ucmVwbGFjZSgvXFxcXDBcXFxcMC9nLFwiJVwiKSksbC5sZW5ndGg+dD8wOihULnNldChsLGU+Pj4wKSxsLmxlbmd0aC0xKX12YXIgb2U9e2E6ZnVuY3Rpb24oZSl7cmV0dXJuIGllKGUrMjQpKzI0fSxiOmZ1bmN0aW9uKGUsdCxuKXt0aHJvdyBuZXcgSihlKS55YSh0LG4pLGV9LGc6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sSTpmdW5jdGlvbigpe30sdzpmdW5jdGlvbigpe30seTpmdW5jdGlvbigpe30sSzpmdW5jdGlvbigpe3JldHVybiAwfSxHOmZ1bmN0aW9uKCl7fSxDOmZ1bmN0aW9uKCl7fSxGOmZ1bmN0aW9uKCl7fSxrOmZ1bmN0aW9uKCl7fSx4OmZ1bmN0aW9uKCl7fSx1OmZ1bmN0aW9uKCl7fSxIOmZ1bmN0aW9uKCl7fSx2OmZ1bmN0aW9uKCl7fSxuOmZ1bmN0aW9uKCl7fSxwOmZ1bmN0aW9uKCl7QihcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxvOmZ1bmN0aW9uKCl7QihcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxsOmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9LEw6ZnVuY3Rpb24oKXtyZXR1cm4hMH0sTTpmdW5jdGlvbihlLHQpe2U9bmV3IERhdGUoMWUzKihNW2U+Pj4yXSs0Mjk0OTY3Mjk2KkVbZSs0Pj4+Ml0pKSxFW3Q+PjI+Pj4wXT1lLmdldFVUQ1NlY29uZHMoKSxFW3QrND4+Mj4+PjBdPWUuZ2V0VVRDTWludXRlcygpLEVbdCs4Pj4yPj4+MF09ZS5nZXRVVENIb3VycygpLEVbdCsxMj4+Mj4+PjBdPWUuZ2V0VVRDRGF0ZSgpLEVbdCsxNj4+Mj4+PjBdPWUuZ2V0VVRDTW9udGgoKSxFW3QrMjA+PjI+Pj4wXT1lLmdldFVUQ0Z1bGxZZWFyKCktMTkwMCxFW3QrMjQ+PjI+Pj4wXT1lLmdldFVUQ0RheSgpLEVbdCsyOD4+Mj4+PjBdPShlLmdldFRpbWUoKS1EYXRlLlVUQyhlLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwfSxOOmZ1bmN0aW9uKGUsdCl7ZT1uZXcgRGF0ZSgxZTMqKE1bZT4+PjJdKzQyOTQ5NjcyOTYqRVtlKzQ+Pj4yXSkpLEVbdD4+Mj4+PjBdPWUuZ2V0U2Vjb25kcygpLEVbdCs0Pj4yPj4+MF09ZS5nZXRNaW51dGVzKCksRVt0Kzg+PjI+Pj4wXT1lLmdldEhvdXJzKCksRVt0KzEyPj4yPj4+MF09ZS5nZXREYXRlKCksRVt0KzE2Pj4yPj4+MF09ZS5nZXRNb250aCgpLEVbdCsyMD4+Mj4+PjBdPWUuZ2V0RnVsbFllYXIoKS0xOTAwLEVbdCsyND4+Mj4+PjBdPWUuZ2V0RGF5KCk7dmFyIG49bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMSk7RVt0KzI4Pj4yPj4+MF09KGUuZ2V0VGltZSgpLW4uZ2V0VGltZSgpKS84NjRlNXwwLEVbdCszNj4+Mj4+PjBdPS02MCplLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHI9bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtuPW4uZ2V0VGltZXpvbmVPZmZzZXQoKSxFW3QrMzI+PjI+Pj4wXT0wfChyIT1uJiZlLmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKG4scikpfSxPOmZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBEYXRlKEVbZSsyMD4+Mj4+PjBdKzE5MDAsRVtlKzE2Pj4yPj4+MF0sRVtlKzEyPj4yPj4+MF0sRVtlKzg+PjI+Pj4wXSxFW2UrND4+Mj4+PjBdLEVbZT4+Mj4+PjBdLDApLG49RVtlKzMyPj4yPj4+MF0scj10LmdldFRpbWV6b25lT2Zmc2V0KCksYT1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwxKSxvPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksaT1hLmdldFRpbWV6b25lT2Zmc2V0KCkscz1NYXRoLm1pbihpLG8pO3JldHVybiAwPm4/RVtlKzMyPj4yPj4+MF09TnVtYmVyKG8hPWkmJnM9PXIpOjA8biE9KHM9PXIpJiYobz1NYXRoLm1heChpLG8pLHQuc2V0VGltZSh0LmdldFRpbWUoKSs2ZTQqKCgwPG4/czpvKS1yKSkpLEVbZSsyND4+Mj4+PjBdPXQuZ2V0RGF5KCksRVtlKzI4Pj4yPj4+MF09KHQuZ2V0VGltZSgpLWEuZ2V0VGltZSgpKS84NjRlNXwwLEVbZT4+Mj4+PjBdPXQuZ2V0U2Vjb25kcygpLEVbZSs0Pj4yPj4+MF09dC5nZXRNaW51dGVzKCksRVtlKzg+PjI+Pj4wXT10LmdldEhvdXJzKCksRVtlKzEyPj4yPj4+MF09dC5nZXREYXRlKCksRVtlKzE2Pj4yPj4+MF09dC5nZXRNb250aCgpLHQuZ2V0VGltZSgpLzFlM3wwfSx6OmZ1bmN0aW9uKCl7cmV0dXJuLTUyfSxCOmZ1bmN0aW9uKCl7fSxtOmZ1bmN0aW9uIGUodCxuLHIpe2UueGF8fChlLnhhPSEwLGZ1bmN0aW9uKGUsdCxuKXtmdW5jdGlvbiByKGUpe3JldHVybihlPWUudG9UaW1lU3RyaW5nKCkubWF0Y2goL1xcXFwoKFtBLVphLXogXSspXFxcXCkkLykpP2VbMV06XCJHTVRcIn12YXIgYT0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCksbz1uZXcgRGF0ZShhLDAsMSksaT1uZXcgRGF0ZShhLDYsMSk7YT1vLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHM9aS5nZXRUaW1lem9uZU9mZnNldCgpO0VbZT4+Mj4+PjBdPTYwKk1hdGgubWF4KGEscyksRVt0Pj4yPj4+MF09TnVtYmVyKGEhPXMpLGU9cihvKSx0PXIoaSksZT1RKGUpLHQ9USh0KSxzPGE/KE1bbj4+Mj4+PjBdPWUsTVtuKzQ+PjI+Pj4wXT10KTooTVtuPj4yPj4+MF09dCxNW24rND4+Mj4+PjBdPWUpfSh0LG4scikpfSxkOmZ1bmN0aW9uKCl7QihcIlwiKX0sdDpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTAxNzYwfSxoOmg/KCk9Pnt2YXIgZT1wcm9jZXNzLmhydGltZSgpO3JldHVybiAxZTMqZVswXStlWzFdLzFlNn06KCk9PnBlcmZvcm1hbmNlLm5vdygpLEo6ZnVuY3Rpb24oZSx0LG4pe0EuY29weVdpdGhpbihlPj4+MCx0Pj4+MCx0K24+Pj4wKX0sZjpmdW5jdGlvbihlKXt2YXIgdD1BLmxlbmd0aDtpZig0Mjk0OTAxNzYwPChlPj4+PTApKXJldHVybiExO2Zvcih2YXIgbj0xOzQ+PW47bio9Mil7dmFyIHI9dCooMSsuMi9uKTtyPU1hdGgubWluKHIsZSsxMDA2NjMyOTYpO3ZhciBhPU1hdGg7cj1NYXRoLm1heChlLHIpLGE9YS5taW4uY2FsbChhLDQyOTQ5MDE3NjAscisoNjU1MzYtciU2NTUzNiklNjU1MzYpO2U6e3RyeXtPLmdyb3coYS1TLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNiksRigpO3ZhciBvPTE7YnJlYWsgZX1jYXRjaChlKXt9bz12b2lkIDB9aWYobylyZXR1cm4hMH1yZXR1cm4hMX0sRDpmdW5jdGlvbihlLHQpe3ZhciBuPTA7cmV0dXJuIEsoKS5mb3JFYWNoKChmdW5jdGlvbihyLGEpe3ZhciBvPXQrbjtmb3IoYT1NW2UrNCphPj4yPj4+MF09byxvPTA7bzxyLmxlbmd0aDsrK28pVFthKys+PjA+Pj4wXT1yLmNoYXJDb2RlQXQobyk7VFthPj4wPj4+MF09MCxuKz1yLmxlbmd0aCsxfSkpLDB9LEU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1LKCk7TVtlPj4yPj4+MF09bi5sZW5ndGg7dmFyIHI9MDtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbihlKXtyKz1lLmxlbmd0aCsxfSkpLE1bdD4+Mj4+PjBdPXIsMH0scjpmdW5jdGlvbihlKXtffHwodC5vbkV4aXQmJnQub25FeGl0KGUpLFI9ITApLGQoZSxuZXcgJChlKSl9LGU6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LGo6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LHE6ZnVuY3Rpb24oKXtyZXR1cm4gNzB9LGk6ZnVuY3Rpb24oZSx0LG4scil7Zm9yKHZhciBhPTAsbz0wO288bjtvKyspe3ZhciBpPU1bdD4+Mj4+PjBdLHM9TVt0KzQ+PjI+Pj4wXTt0Kz04O2Zvcih2YXIgdT0wO3U8czt1Kyspe3ZhciBjPUFbaSt1Pj4+MF0sbD1lZVtlXTswPT09Y3x8MTA9PT1jPygoMT09PWU/Yjp3KShDKGwsMCkpLGwubGVuZ3RoPTApOmwucHVzaChjKX1hKz1zfXJldHVybiBNW3I+PjI+Pj4wXT1hLDB9LHM6ZnVuY3Rpb24gZSh0LHIpe2Uud2F8fChlLndhPWZ1bmN0aW9uKCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGNyeXB0byYmXCJmdW5jdGlvblwiPT10eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyl7dmFyIGU9bmV3IFVpbnQ4QXJyYXkoMSk7cmV0dXJuKCk9PihjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGUpLGVbMF0pfWlmKGgpdHJ5e3ZhciB0PW4oNzYwKTtyZXR1cm4oKT0+dC5yYW5kb21CeXRlcygxKVswXX1jYXRjaChlKXt9cmV0dXJuKCk9PkIoXCJyYW5kb21EZXZpY2VcIil9KCkpO2Zvcih2YXIgYT0wO2E8cjthKyspVFt0K2E+PjA+Pj4wXT1lLndhKCk7cmV0dXJuIDB9LEE6YWUsYzpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gYWUoZSx0LG4scil9fTshZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3QuYXNtPWUuZXhwb3J0cyxPPXQuYXNtLlAsRigpLEkudW5zaGlmdCh0LmFzbS5RKSxMLS0sdC5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZ0Lm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoTCksMD09TCYmKG51bGwhPT1ZJiYoY2xlYXJJbnRlcnZhbChZKSxZPW51bGwpLHomJihlPXosej1udWxsLGUoKSkpfWZ1bmN0aW9uIG4odCl7ZSh0Lmluc3RhbmNlKX1mdW5jdGlvbiByKGUpe3JldHVybiBmdW5jdGlvbigpe2lmKCF2JiYobXx8Zykpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGZldGNoJiYhSC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSlyZXR1cm4gZmV0Y2goSCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24oZSl7aWYoIWUub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgXFwnXCIrSCtcIlxcJ1wiO3JldHVybiBlLmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIHEoKX0pKTtpZihpKXJldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSx0KXtpKEgsKGZ1bmN0aW9uKHQpe2UobmV3IFVpbnQ4QXJyYXkodCkpfSksdCl9KSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIHEoKX0pKX0oKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoZSxvKX0pKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gZX0pKS50aGVuKGUsKGZ1bmN0aW9uKGUpe3coXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIitlKSxCKGUpfSkpfXZhciBvPXthOm9lfTtpZihMKyssdC5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZ0Lm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoTCksdC5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiB0Lmluc3RhbnRpYXRlV2FzbShvLGUpfWNhdGNoKGUpe3JldHVybiB3KFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrZSksITF9KHZ8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxOKCl8fEguc3RhcnRzV2l0aChcImZpbGU6Ly9cIil8fGh8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGZldGNoP3Iobik6ZmV0Y2goSCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKGUsbykudGhlbihuLChmdW5jdGlvbihlKXtyZXR1cm4gdyhcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIitlKSx3KFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIikscihuKX0pKX0pKSkuY2F0Y2goYSl9KCksdC5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4odC5fX193YXNtX2NhbGxfY3RvcnM9dC5hc20uUSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRJbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEluaXQ9dC5hc20uUikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz10LmFzbS5TKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPXQuYXNtLlQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT10LmFzbS5VKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9dC5hc20uVikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRDcmVhdGVTZXNzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydENyZWF0ZVNlc3Npb249dC5hc20uVykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRSZWxlYXNlU2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRSZWxlYXNlU2Vzc2lvbj10LmFzbS5YKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEdldElucHV0Q291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0R2V0SW5wdXRDb3VudD10LmFzbS5ZKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEdldE91dHB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEdldE91dHB1dENvdW50PXQuYXNtLlopLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0R2V0SW5wdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEdldElucHV0TmFtZT10LmFzbS5fKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEdldE91dHB1dE5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0R2V0T3V0cHV0TmFtZT10LmFzbS4kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0RnJlZT10LmFzbS5hYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRDcmVhdGVUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0Q3JlYXRlVGVuc29yPXQuYXNtLmJhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEdldFRlbnNvckRhdGE9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0R2V0VGVuc29yRGF0YT10LmFzbS5jYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRSZWxlYXNlVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydFJlbGVhc2VUZW5zb3I9dC5hc20uZGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRDcmVhdGVSdW5PcHRpb25zPXQuYXNtLmVhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PXQuYXNtLmZhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydFJlbGVhc2VSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydFJlbGVhc2VSdW5PcHRpb25zPXQuYXNtLmdhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydFJ1bj1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRSdW49dC5hc20uaGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0RW5kUHJvZmlsaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEVuZFByb2ZpbGluZz10LmFzbS5pYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgaWU9dC5fbWFsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKGllPXQuX21hbGxvYz10LmFzbS5qYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt0Ll9mcmVlPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX2ZyZWU9dC5hc20ua2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIHNlLHVlPXQuc3RhY2tTYXZlPWZ1bmN0aW9uKCl7cmV0dXJuKHVlPXQuc3RhY2tTYXZlPXQuYXNtLm1hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGNlPXQuc3RhY2tSZXN0b3JlPWZ1bmN0aW9uKCl7cmV0dXJuKGNlPXQuc3RhY2tSZXN0b3JlPXQuYXNtLm5hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGxlPXQuc3RhY2tBbGxvYz1mdW5jdGlvbigpe3JldHVybihsZT10LnN0YWNrQWxsb2M9dC5hc20ub2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07ZnVuY3Rpb24gZmUoKXtmdW5jdGlvbiBlKCl7aWYoIXNlJiYoc2U9ITAsdC5jYWxsZWRSdW49ITAsIVIpKXtpZihWKEkpLHIodCksdC5vblJ1bnRpbWVJbml0aWFsaXplZCYmdC5vblJ1bnRpbWVJbml0aWFsaXplZCgpLHQucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgdC5wb3N0UnVuJiYodC5wb3N0UnVuPVt0LnBvc3RSdW5dKTt0LnBvc3RSdW4ubGVuZ3RoOyl7dmFyIGU9dC5wb3N0UnVuLnNoaWZ0KCk7Vy51bnNoaWZ0KGUpfVYoVyl9fWlmKCEoMDxMKSl7aWYodC5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQucHJlUnVuJiYodC5wcmVSdW49W3QucHJlUnVuXSk7dC5wcmVSdW4ubGVuZ3RoOylqKCk7VihVKSwwPEx8fCh0LnNldFN0YXR1cz8odC5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXt0LnNldFN0YXR1cyhcIlwiKX0pLDEpLGUoKX0pLDEpKTplKCkpfX1pZih0Ll9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4odC5fX19jeGFfaXNfcG9pbnRlcl90eXBlPXQuYXNtLnBhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuVVRGOFRvU3RyaW5nPVAsdC5zdHJpbmdUb1VURjg9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBrKGUsQSx0LG4pfSx0Lmxlbmd0aEJ5dGVzVVRGOD1ELHQuc3RhY2tTYXZlPXVlLHQuc3RhY2tSZXN0b3JlPWNlLHQuc3RhY2tBbGxvYz1sZSx6PWZ1bmN0aW9uIGUoKXtzZXx8ZmUoKSxzZXx8KHo9ZSl9LHQucHJlSW5pdClmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgdC5wcmVJbml0JiYodC5wcmVJbml0PVt0LnByZUluaXRdKTswPHQucHJlSW5pdC5sZW5ndGg7KXQucHJlSW5pdC5wb3AoKSgpO3JldHVybiBmZSgpLGUucmVhZHl9KTtlLmV4cG9ydHM9cn0sMTU0OmU9PntcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9XFwnXCJ1c2Ugc3RyaWN0XCI7dmFyIGU9e30sdD1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7aWYodCl7dmFyIHI9cmVxdWlyZShcIndvcmtlcl90aHJlYWRzXCIpLGE9ci5wYXJlbnRQb3J0O2Eub24oXCJtZXNzYWdlXCIsKGU9Pm9ubWVzc2FnZSh7ZGF0YTplfSkpKTt2YXIgbz1yZXF1aXJlKFwiZnNcIik7T2JqZWN0LmFzc2lnbihnbG9iYWwse3NlbGY6Z2xvYmFsLHJlcXVpcmU6cmVxdWlyZSxNb2R1bGU6ZSxsb2NhdGlvbjp7aHJlZjpfX2ZpbGVuYW1lfSxXb3JrZXI6ci5Xb3JrZXIsaW1wb3J0U2NyaXB0czpmdW5jdGlvbihlKXsoMCxldmFsKShvLnJlYWRGaWxlU3luYyhlLFwidXRmOFwiKSl9LHBvc3RNZXNzYWdlOmZ1bmN0aW9uKGUpe2EucG9zdE1lc3NhZ2UoZSl9LHBlcmZvcm1hbmNlOmdsb2JhbC5wZXJmb3JtYW5jZXx8e25vdzpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfX19KX12YXIgcz0hMSxuPVtdLGk9ZnVuY3Rpb24oKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO3Q/by53cml0ZVN5bmMoMixlK1wiXFxcXFxcXFxuXCIpOmNvbnNvbGUuZXJyb3IoZSl9O3NlbGYuYWxlcnQ9ZnVuY3Rpb24oKXt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO3Bvc3RNZXNzYWdlKHtjbWQ6XCJhbGVydFwiLHRleHQ6dCx0aHJlYWRJZDplLl9wdGhyZWFkX3NlbGYoKX0pfSxlLmluc3RhbnRpYXRlV2FzbT0odCxyKT0+e3ZhciBhPW5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShlLndhc21Nb2R1bGUsdCk7cmV0dXJuIHIoYSksZS53YXNtTW9kdWxlPW51bGwsYS5leHBvcnRzfSxzZWxmLm9udW5oYW5kbGVkcmVqZWN0aW9uPWU9Pnt0aHJvdyBlLnJlYXNvbj8/ZX0sc2VsZi5vbm1lc3NhZ2U9dD0+e3RyeXtpZihcImxvYWRcIj09PXQuZGF0YS5jbWQpe2lmKGUud2FzbU1vZHVsZT10LmRhdGEud2FzbU1vZHVsZSxlLndhc21NZW1vcnk9dC5kYXRhLndhc21NZW1vcnksZS5idWZmZXI9ZS53YXNtTWVtb3J5LmJ1ZmZlcixlLkVOVklST05NRU5UX0lTX1BUSFJFQUQ9ITAsXCJzdHJpbmdcIj09dHlwZW9mIHQuZGF0YS51cmxPckJsb2IpaW1wb3J0U2NyaXB0cyh0LmRhdGEudXJsT3JCbG9iKTtlbHNle3ZhciByPVVSTC5jcmVhdGVPYmplY3RVUkwodC5kYXRhLnVybE9yQmxvYik7aW1wb3J0U2NyaXB0cyhyKSxVUkwucmV2b2tlT2JqZWN0VVJMKHIpfW9ydFdhc21UaHJlYWRlZChlKS50aGVuKChmdW5jdGlvbih0KXtlPXR9KSl9ZWxzZSBpZihcInJ1blwiPT09dC5kYXRhLmNtZCl7ZS5fX3BlcmZvcm1hbmNlX25vd19jbG9ja19kcmlmdD1wZXJmb3JtYW5jZS5ub3coKS10LmRhdGEudGltZSxlLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdCh0LmRhdGEucHRocmVhZF9wdHIsMCwwLDEpLGUuZXN0YWJsaXNoU3RhY2tTcGFjZSgpLGUuUFRocmVhZC5yZWNlaXZlT2JqZWN0VHJhbnNmZXIodC5kYXRhKSxlLlBUaHJlYWQudGhyZWFkSW5pdFRMUygpLHN8fChuLmZvckVhY2goKHQ9PntlLmV4ZWN1dGVOb3RpZmllZFByb3h5aW5nUXVldWUodCl9KSksbj1bXSxzPSEwKTt0cnl7ZS5pbnZva2VFbnRyeVBvaW50KHQuZGF0YS5zdGFydF9yb3V0aW5lLHQuZGF0YS5hcmcpfWNhdGNoKHQpe2lmKFwidW53aW5kXCIhPXQpe2lmKCEodCBpbnN0YW5jZW9mIGUuRXhpdFN0YXR1cykpdGhyb3cgdDtlLmtlZXBSdW50aW1lQWxpdmUoKXx8ZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQodC5zdGF0dXMpfX19ZWxzZVwiY2FuY2VsXCI9PT10LmRhdGEuY21kP2UuX3B0aHJlYWRfc2VsZigpJiZlLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdCgtMSk6XCJzZXRpbW1lZGlhdGVcIj09PXQuZGF0YS50YXJnZXR8fChcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCI9PT10LmRhdGEuY21kP3M/ZS5leGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlKHQuZGF0YS5xdWV1ZSk6bi5wdXNoKHQuZGF0YS5xdWV1ZSk6KGkoXCJ3b3JrZXIuanMgcmVjZWl2ZWQgdW5rbm93biBjb21tYW5kIFwiK3QuZGF0YS5jbWQpLGkodC5kYXRhKSkpfWNhdGNoKHQpe3Rocm93IGkoXCJ3b3JrZXIuanMgb25tZXNzYWdlKCkgY2FwdHVyZWQgYW4gdW5jYXVnaHQgZXhjZXB0aW9uOiBcIit0KSx0JiZ0LnN0YWNrJiZpKHQuc3RhY2spLGUuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkJiZlLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZCgpLHR9fTtcXFxcblxcJ30sNzYwOigpPT57fSwzODQ6KCk9Pnt9LDk5MzooKT0+e30sOTA4OigpPT57fSw5NTM6KCk9Pnt9LDkyNTooKT0+e30sNDQ5OigpPT57fX0sdD17fTtmdW5jdGlvbiBuKHIpe3ZhciBhPXRbcl07aWYodm9pZCAwIT09YSlyZXR1cm4gYS5leHBvcnRzO3ZhciBvPXRbcl09e2V4cG9ydHM6e319O3JldHVybiBlW3JdLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLG4pLG8uZXhwb3J0c31uLmc9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZ2xvYmFsVGhpcylyZXR1cm4gZ2xvYmFsVGhpczt0cnl7cmV0dXJuIHRoaXN8fG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCl9Y2F0Y2goZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdylyZXR1cm4gd2luZG93fX0oKSwoKCk9PntcInVzZSBzdHJpY3RcIjtjb25zdCBlPW4oMjU5KSx0PW4oMjYzKTtzZWxmLm9ubWVzc2FnZT1uPT57c3dpdGNoKG4uZGF0YS50eXBlKXtjYXNlXCJpbml0LXdhc21cIjooMCx0LmluaXRpYWxpemVXZWJBc3NlbWJseSkobi5kYXRhLmluKS50aGVuKCgoKT0+cG9zdE1lc3NhZ2Uoe3R5cGU6XCJpbml0LXdhc21cIn0pKSwoZT0+cG9zdE1lc3NhZ2Uoe3R5cGU6XCJpbml0LXdhc21cIixlcnI6ZX0pKSk7YnJlYWs7Y2FzZVwiaW5pdC1vcnRcIjp0cnl7Y29uc3R7bnVtVGhyZWFkczp0LGxvZ2dpbmdMZXZlbDpyfT1uLmRhdGEuaW47KDAsZS5pbml0T3J0KSh0LHIpLHBvc3RNZXNzYWdlKHt0eXBlOlwiaW5pdC1vcnRcIn0pfWNhdGNoKGUpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiaW5pdC1vcnRcIixlcnI6ZX0pfWJyZWFrO2Nhc2VcImNyZWF0ZV9hbGxvY2F0ZVwiOnRyeXtjb25zdHttb2RlbDp0fT1uLmRhdGEuaW4scj0oMCxlLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSkodCk7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVfYWxsb2NhdGVcIixvdXQ6cn0pfWNhdGNoKGUpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlX2FsbG9jYXRlXCIsZXJyOmV9KX1icmVhaztjYXNlXCJjcmVhdGVfZmluYWxpemVcIjp0cnl7Y29uc3R7bW9kZWxkYXRhOnQsb3B0aW9uczpyfT1uLmRhdGEuaW4sYT0oMCxlLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZSkodCxyKTtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZV9maW5hbGl6ZVwiLG91dDphfSl9Y2F0Y2goZSl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVfZmluYWxpemVcIixlcnI6ZX0pfWJyZWFrO2Nhc2VcImNyZWF0ZVwiOnRyeXtjb25zdHttb2RlbDp0LG9wdGlvbnM6cn09bi5kYXRhLmluLGE9KDAsZS5jcmVhdGVTZXNzaW9uKSh0LHIpO3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlXCIsb3V0OmF9KX1jYXRjaChlKXtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZVwiLGVycjplfSl9YnJlYWs7Y2FzZVwicmVsZWFzZVwiOnRyeXtjb25zdCB0PW4uZGF0YS5pbjsoMCxlLnJlbGVhc2VTZXNzaW9uKSh0KSxwb3N0TWVzc2FnZSh7dHlwZTpcInJlbGVhc2VcIn0pfWNhdGNoKGUpe3Bvc3RNZXNzYWdlKHt0eXBlOlwicmVsZWFzZVwiLGVycjplfSl9YnJlYWs7Y2FzZVwicnVuXCI6dHJ5e2NvbnN0e3Nlc3Npb25JZDp0LGlucHV0SW5kaWNlczpyLGlucHV0czphLG91dHB1dEluZGljZXM6byxvcHRpb25zOml9PW4uZGF0YS5pbjsoMCxlLnJ1bikodCxyLGEsbyxpKS50aGVuKCh0PT57cG9zdE1lc3NhZ2Uoe3R5cGU6XCJydW5cIixvdXQ6dH0sKDAsZS5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycykodCkpfSksKGU9Pntwb3N0TWVzc2FnZSh7dHlwZTpcInJ1blwiLGVycjplfSl9KSl9Y2F0Y2goZSl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJydW5cIixlcnI6ZX0pfWJyZWFrO2Nhc2VcImVuZC1wcm9maWxpbmdcIjp0cnl7Y29uc3QgdD1uLmRhdGEuaW47KDAsZS5lbmRQcm9maWxpbmcpKHQpLHBvc3RNZXNzYWdlKHt0eXBlOlwiZW5kLXByb2ZpbGluZ1wifSl9Y2F0Y2goZSl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJlbmQtcHJvZmlsaW5nXCIsZXJyOmV9KX19fX0pKCl9KSgpO1xcbicsXCJXb3JrZXJcIix2b2lkIDAsdm9pZCAwKX19LDY2MTQ6ZT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQsbixyKXt2YXIgbz1zZWxmfHx3aW5kb3c7dHJ5e3RyeXt2YXIgaTt0cnl7aT1uZXcgby5CbG9iKFtlXSl9Y2F0Y2godCl7KGk9bmV3KG8uQmxvYkJ1aWxkZXJ8fG8uV2ViS2l0QmxvYkJ1aWxkZXJ8fG8uTW96QmxvYkJ1aWxkZXJ8fG8uTVNCbG9iQnVpbGRlcikpLmFwcGVuZChlKSxpPWkuZ2V0QmxvYigpfXZhciBhPW8uVVJMfHxvLndlYmtpdFVSTCxzPWEuY3JlYXRlT2JqZWN0VVJMKGkpLHU9bmV3IG9bdF0ocyxuKTtyZXR1cm4gYS5yZXZva2VPYmplY3RVUkwocyksdX1jYXRjaChyKXtyZXR1cm4gbmV3IG9bdF0oXCJkYXRhOmFwcGxpY2F0aW9uL2phdmFzY3JpcHQsXCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChlKSksbil9fWNhdGNoKGUpe2lmKCFyKXRocm93IEVycm9yKFwiSW5saW5lIHdvcmtlciBpcyBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiBuZXcgb1t0XShyLG4pfX19LDM0NzQ6KGUsdCxuKT0+e3ZhciBfc2NyaXB0RGlyLHI9KF9zY3JpcHREaXI9KF9zY3JpcHREaXI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMCl8fFwiL2luZGV4LmpzXCIsZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBELmJ1ZmZlciE9QyYmSChELmJ1ZmZlciksUn1mdW5jdGlvbiByKCl7cmV0dXJuIEQuYnVmZmVyIT1DJiZIKEQuYnVmZmVyKSxNfWZ1bmN0aW9uIG8oKXtyZXR1cm4gRC5idWZmZXIhPUMmJkgoRC5idWZmZXIpLE59ZnVuY3Rpb24gaSgpe3JldHVybiBELmJ1ZmZlciE9QyYmSChELmJ1ZmZlciksRn1mdW5jdGlvbiBhKCl7cmV0dXJuIEQuYnVmZmVyIT1DJiZIKEQuYnVmZmVyKSxMfXZhciBzLHUsbDtlPWV8fHt9LHN8fChzPXZvaWQgMCE9PWU/ZTp7fSkscy5yZWFkeT1uZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSx0KXt1PWUsbD10fSkpO3ZhciBjLHAsZCxmLGgsZyxtPU9iamVjdC5hc3NpZ24oe30scyksYj1cIi4vdGhpcy5wcm9ncmFtXCIseT0oZSx0KT0+e3Rocm93IHR9LHc9XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyxfPVwiZnVuY3Rpb25cIj09dHlwZW9mIGltcG9ydFNjcmlwdHMsdj1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUseD1zLkVOVklST05NRU5UX0lTX1BUSFJFQUR8fCExLFQ9XCJcIjtmdW5jdGlvbiBTKGUpe3JldHVybiBzLmxvY2F0ZUZpbGU/cy5sb2NhdGVGaWxlKGUsVCk6VCtlfWlmKHYpe2xldCB0O1Q9Xz9uKDkwOCkuZGlybmFtZShUKStcIi9cIjpcIi8vXCIsZz0oKT0+e2h8fChmPW4oMTM4NCksaD1uKDkwOCkpfSxjPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGcoKSxlPWgubm9ybWFsaXplKGUpLGYucmVhZEZpbGVTeW5jKGUsdD92b2lkIDA6XCJ1dGY4XCIpfSxkPWU9PigoZT1jKGUsITApKS5idWZmZXJ8fChlPW5ldyBVaW50OEFycmF5KGUpKSxlKSxwPShlLHQsbik9PntnKCksZT1oLm5vcm1hbGl6ZShlKSxmLnJlYWRGaWxlKGUsKGZ1bmN0aW9uKGUscil7ZT9uKGUpOnQoci5idWZmZXIpfSkpfSwxPHByb2Nlc3MuYXJndi5sZW5ndGgmJihiPXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpKSxwcm9jZXNzLmFyZ3Yuc2xpY2UoMikscHJvY2Vzcy5vbihcInVuY2F1Z2h0RXhjZXB0aW9uXCIsKGZ1bmN0aW9uKGUpe2lmKCEoZSBpbnN0YW5jZW9mIGFlKSl0aHJvdyBlfSkpLHByb2Nlc3Mub24oXCJ1bmhhbmRsZWRSZWplY3Rpb25cIiwoZnVuY3Rpb24oZSl7dGhyb3cgZX0pKSx5PShlLHQpPT57aWYoUCl0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPWUsdDt0IGluc3RhbmNlb2YgYWV8fCQoXCJleGl0aW5nIGR1ZSB0byBleGNlcHRpb246IFwiK3QpLHByb2Nlc3MuZXhpdChlKX0scy5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifTt0cnl7dD1uKDk5MjUpfWNhdGNoKGUpe3Rocm93IGNvbnNvbGUuZXJyb3IoJ1RoZSBcIndvcmtlcl90aHJlYWRzXCIgbW9kdWxlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBub2RlLmpzIGJ1aWxkIC0gcGVyaGFwcyBhIG5ld2VyIHZlcnNpb24gaXMgbmVlZGVkPycpLGV9bi5nLldvcmtlcj10Lldvcmtlcn1lbHNlKHd8fF8pJiYoXz9UPXNlbGYubG9jYXRpb24uaHJlZjpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihUPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxfc2NyaXB0RGlyJiYoVD1fc2NyaXB0RGlyKSxUPTAhPT1ULmluZGV4T2YoXCJibG9iOlwiKT9ULnN1YnN0cigwLFQucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIix2fHwoYz1lPT57dmFyIHQ9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB0Lm9wZW4oXCJHRVRcIixlLCExKSx0LnNlbmQobnVsbCksdC5yZXNwb25zZVRleHR9LF8mJihkPWU9Pnt2YXIgdD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHQub3BlbihcIkdFVFwiLGUsITEpLHQucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIix0LnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkodC5yZXNwb25zZSl9KSxwPShlLHQsbik9Pnt2YXIgcj1uZXcgWE1MSHR0cFJlcXVlc3Q7ci5vcGVuKFwiR0VUXCIsZSwhMCksci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLHIub25sb2FkPSgpPT57MjAwPT1yLnN0YXR1c3x8MD09ci5zdGF0dXMmJnIucmVzcG9uc2U/dChyLnJlc3BvbnNlKTpuKCl9LHIub25lcnJvcj1uLHIuc2VuZChudWxsKX0pKTt2JiZcInVuZGVmaW5lZFwiPT10eXBlb2YgcGVyZm9ybWFuY2UmJihuLmcucGVyZm9ybWFuY2U9big2OTUzKS5wZXJmb3JtYW5jZSk7dmFyIE89Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxBPWNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO3YmJihnKCksTz1lPT5mLndyaXRlU3luYygxLGUrXCJcXG5cIiksQT1lPT5mLndyaXRlU3luYygyLGUrXCJcXG5cIikpO3ZhciBFLEk9cy5wcmludHx8TywkPXMucHJpbnRFcnJ8fEE7T2JqZWN0LmFzc2lnbihzLG0pLG09bnVsbCxzLnRoaXNQcm9ncmFtJiYoYj1zLnRoaXNQcm9ncmFtKSxzLnF1aXQmJih5PXMucXVpdCkscy53YXNtQmluYXJ5JiYoRT1zLndhc21CaW5hcnkpO3ZhciBQPXMubm9FeGl0UnVudGltZXx8ITA7XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZuZShcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIEQsayxDLFIsTSxOLEYsTCxqPSExLFU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwO2Z1bmN0aW9uIEIoZSx0LG4pe3ZhciByPSh0Pj4+PTApK247Zm9yKG49dDtlW25dJiYhKG4+PXIpOykrK247aWYoMTY8bi10JiZlLmJ1ZmZlciYmVSlyZXR1cm4gVS5kZWNvZGUoZS5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcj9lLnNsaWNlKHQsbik6ZS5zdWJhcnJheSh0LG4pKTtmb3Iocj1cIlwiO3Q8bjspe3ZhciBvPWVbdCsrXTtpZigxMjgmbyl7dmFyIGk9NjMmZVt0KytdO2lmKDE5Mj09KDIyNCZvKSlyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzMSZvKTw8NnxpKTtlbHNle3ZhciBhPTYzJmVbdCsrXTs2NTUzNj4obz0yMjQ9PSgyNDAmbyk/KDE1Jm8pPDwxMnxpPDw2fGE6KDcmbyk8PDE4fGk8PDEyfGE8PDZ8NjMmZVt0KytdKT9yKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pOihvLT02NTUzNixyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fG8+PjEwLDU2MzIwfDEwMjMmbykpfX1lbHNlIHIrPVN0cmluZy5mcm9tQ2hhckNvZGUobyl9cmV0dXJuIHJ9ZnVuY3Rpb24gRyhlLHQpe3JldHVybihlPj4+PTApP0IocigpLGUsdCk6XCJcIn1mdW5jdGlvbiBWKGUsdCxuLHIpe2lmKCEoMDxyKSlyZXR1cm4gMDt2YXIgbz1uPj4+PTA7cj1uK3ItMTtmb3IodmFyIGk9MDtpPGUubGVuZ3RoOysraSl7dmFyIGE9ZS5jaGFyQ29kZUF0KGkpO2lmKDU1Mjk2PD1hJiY1NzM0Mz49YSYmKGE9NjU1MzYrKCgxMDIzJmEpPDwxMCl8MTAyMyZlLmNoYXJDb2RlQXQoKytpKSksMTI3Pj1hKXtpZihuPj1yKWJyZWFrO3RbbisrPj4+MF09YX1lbHNle2lmKDIwNDc+PWEpe2lmKG4rMT49cilicmVhazt0W24rKz4+PjBdPTE5MnxhPj42fWVsc2V7aWYoNjU1MzU+PWEpe2lmKG4rMj49cilicmVhazt0W24rKz4+PjBdPTIyNHxhPj4xMn1lbHNle2lmKG4rMz49cilicmVhazt0W24rKz4+PjBdPTI0MHxhPj4xOCx0W24rKz4+PjBdPTEyOHxhPj4xMiY2M310W24rKz4+PjBdPTEyOHxhPj42JjYzfXRbbisrPj4+MF09MTI4fDYzJmF9fXJldHVybiB0W24+Pj4wXT0wLG4tb31mdW5jdGlvbiB6KGUpe2Zvcih2YXIgdD0wLG49MDtuPGUubGVuZ3RoOysrbil7dmFyIHI9ZS5jaGFyQ29kZUF0KG4pOzEyNz49cj90Kys6MjA0Nz49cj90Kz0yOjU1Mjk2PD1yJiY1NzM0Mz49cj8odCs9NCwrK24pOnQrPTN9cmV0dXJuIHR9ZnVuY3Rpb24gSChlKXtDPWUscy5IRUFQOD1SPW5ldyBJbnQ4QXJyYXkoZSkscy5IRUFQMTY9bmV3IEludDE2QXJyYXkoZSkscy5IRUFQMzI9Tj1uZXcgSW50MzJBcnJheShlKSxzLkhFQVBVOD1NPW5ldyBVaW50OEFycmF5KGUpLHMuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkoZSkscy5IRUFQVTMyPUY9bmV3IFVpbnQzMkFycmF5KGUpLHMuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KGUpLHMuSEVBUEY2ND1MPW5ldyBGbG9hdDY0QXJyYXkoZSl9eCYmKEM9cy5idWZmZXIpO3ZhciBXPXMuSU5JVElBTF9NRU1PUll8fDE2Nzc3MjE2O2lmKHgpRD1zLndhc21NZW1vcnksQz1zLmJ1ZmZlcjtlbHNlIGlmKHMud2FzbU1lbW9yeSlEPXMud2FzbU1lbW9yeTtlbHNlIGlmKCEoKEQ9bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpXLzY1NTM2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSkpLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSl0aHJvdyAkKFwicmVxdWVzdGVkIGEgc2hhcmVkIFdlYkFzc2VtYmx5Lk1lbW9yeSBidXQgdGhlIHJldHVybmVkIGJ1ZmZlciBpcyBub3QgYSBTaGFyZWRBcnJheUJ1ZmZlciwgaW5kaWNhdGluZyB0aGF0IHdoaWxlIHRoZSBicm93c2VyIGhhcyBTaGFyZWRBcnJheUJ1ZmZlciBpdCBkb2VzIG5vdCBoYXZlIFdlYkFzc2VtYmx5IHRocmVhZHMgc3VwcG9ydCAtIHlvdSBtYXkgbmVlZCB0byBzZXQgYSBmbGFnXCIpLHYmJmNvbnNvbGUubG9nKFwiKG9uIG5vZGUgeW91IG1heSBuZWVkOiAtLWV4cGVyaW1lbnRhbC13YXNtLXRocmVhZHMgLS1leHBlcmltZW50YWwtd2FzbS1idWxrLW1lbW9yeSBhbmQgYWxzbyB1c2UgYSByZWNlbnQgdmVyc2lvbilcIiksRXJyb3IoXCJiYWQgbWVtb3J5XCIpO0QmJihDPUQuYnVmZmVyKSxXPUMuYnl0ZUxlbmd0aCxIKEMpO3ZhciBxLEs9W10sWD1bXSxZPVtdO2Z1bmN0aW9uIEooKXt2YXIgZT1zLnByZVJ1bi5zaGlmdCgpO0sudW5zaGlmdChlKX12YXIgWixRPTAsZWU9bnVsbCx0ZT1udWxsO2Z1bmN0aW9uIG5lKGUpe3Rocm93IHg/cG9zdE1lc3NhZ2Uoe2NtZDpcIm9uQWJvcnRcIixhcmc6ZX0pOnMub25BYm9ydCYmcy5vbkFib3J0KGUpLCQoZT1cIkFib3J0ZWQoXCIrZStcIilcIiksaj0hMCxlPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoZStcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksbChlKSxlfWZ1bmN0aW9uIHJlKCl7cmV0dXJuIFouc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIil9ZnVuY3Rpb24gb2UoKXt2YXIgZT1aO3RyeXtpZihlPT1aJiZFKXJldHVybiBuZXcgVWludDhBcnJheShFKTtpZihkKXJldHVybiBkKGUpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWNhdGNoKGUpe25lKGUpfX1aPVwib3J0LXdhc20tdGhyZWFkZWQud2FzbVwiLHJlKCl8fChaPVMoWikpO3ZhciBpZT17fTtmdW5jdGlvbiBhZShlKXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPVwiUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdChcIitlK1wiKVwiLHRoaXMuc3RhdHVzPWV9ZnVuY3Rpb24gc2UoZSl7KGU9cGUuTGFbZV0pfHxuZSgpLHBlLlhhKGUpfWZ1bmN0aW9uIHVlKGUpe3ZhciB0PXBlLmxiKCk7aWYoIXQpcmV0dXJuIDY7cGUuUmEucHVzaCh0KSxwZS5MYVtlLkthXT10LHQuS2E9ZS5LYTt2YXIgbj17Y21kOlwicnVuXCIsc3RhcnRfcm91dGluZTplLnBiLGFyZzplLmliLHB0aHJlYWRfcHRyOmUuS2F9O3JldHVybiB0LlFhPSgpPT57bi50aW1lPXBlcmZvcm1hbmNlLm5vdygpLHQucG9zdE1lc3NhZ2UobixlLnZiKX0sdC5sb2FkZWQmJih0LlFhKCksZGVsZXRlIHQuUWEpLDB9ZnVuY3Rpb24gbGUoZSl7aWYoeClyZXR1cm4gamUoMSwxLGUpO1B8fChwZS5xYigpLHMub25FeGl0JiZzLm9uRXhpdChlKSxqPSEwKSx5KGUsbmV3IGFlKGUpKX1mdW5jdGlvbiBjZShlLHQpe2lmKCF0JiZ4KXRocm93IGZlKGUpLFwidW53aW5kXCI7bGUoZSl9dmFyIHBlPXtPYTpbXSxSYTpbXSwkYTpbXSxMYTp7fSxVYTpmdW5jdGlvbigpe3gmJnBlLm1iKCl9LHhiOmZ1bmN0aW9uKCl7fSxtYjpmdW5jdGlvbigpe3BlLnJlY2VpdmVPYmplY3RUcmFuc2Zlcj1wZS5vYixwZS50aHJlYWRJbml0VExTPXBlLlphLHBlLnNldEV4aXRTdGF0dXM9cGUuWWEsUD0hMX0sWWE6ZnVuY3Rpb24oKXt9LHFiOmZ1bmN0aW9uKCl7Zm9yKHZhciBlIG9mIE9iamVjdC52YWx1ZXMocGUuTGEpKXBlLlhhKGUpO2ZvcihlIG9mIHBlLk9hKWUudGVybWluYXRlKCk7cGUuT2E9W119LFhhOmZ1bmN0aW9uKGUpe3ZhciB0PWUuS2E7ZGVsZXRlIHBlLkxhW3RdLHBlLk9hLnB1c2goZSkscGUuUmEuc3BsaWNlKHBlLlJhLmluZGV4T2YoZSksMSksZS5LYT0wLGx0KHQpfSxvYjpmdW5jdGlvbigpe30sWmE6ZnVuY3Rpb24oKXtwZS4kYS5mb3JFYWNoKChlPT5lKCkpKX0sbmI6ZnVuY3Rpb24oZSx0KXtlLm9ubWVzc2FnZT1uPT57dmFyIHI9KG49bi5kYXRhKS5jbWQ7aWYoZS5LYSYmKHBlLmtiPWUuS2EpLG4udGFyZ2V0VGhyZWFkJiZuLnRhcmdldFRocmVhZCE9cnQoKSl7dmFyIG89cGUuTGFbbi55Yl07bz9vLnBvc3RNZXNzYWdlKG4sbi50cmFuc2Zlckxpc3QpOiQoJ0ludGVybmFsIGVycm9yISBXb3JrZXIgc2VudCBhIG1lc3NhZ2UgXCInK3IrJ1wiIHRvIHRhcmdldCBwdGhyZWFkICcrbi50YXJnZXRUaHJlYWQrXCIsIGJ1dCB0aGF0IHRocmVhZCBubyBsb25nZXIgZXhpc3RzIVwiKX1lbHNlXCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiPT09cj9DZShuLnF1ZXVlKTpcInNwYXduVGhyZWFkXCI9PT1yP3VlKG4pOlwiY2xlYW51cFRocmVhZFwiPT09cj9zZShuLnRocmVhZCk6XCJraWxsVGhyZWFkXCI9PT1yPyhuPW4udGhyZWFkLHI9cGUuTGFbbl0sZGVsZXRlIHBlLkxhW25dLHIudGVybWluYXRlKCksbHQobikscGUuUmEuc3BsaWNlKHBlLlJhLmluZGV4T2YociksMSksci5LYT0wKTpcImNhbmNlbFRocmVhZFwiPT09cj9wZS5MYVtuLnRocmVhZF0ucG9zdE1lc3NhZ2Uoe2NtZDpcImNhbmNlbFwifSk6XCJsb2FkZWRcIj09PXI/KGUubG9hZGVkPSEwLHQmJnQoZSksZS5RYSYmKGUuUWEoKSxkZWxldGUgZS5RYSkpOlwicHJpbnRcIj09PXI/SShcIlRocmVhZCBcIituLnRocmVhZElkK1wiOiBcIituLnRleHQpOlwicHJpbnRFcnJcIj09PXI/JChcIlRocmVhZCBcIituLnRocmVhZElkK1wiOiBcIituLnRleHQpOlwiYWxlcnRcIj09PXI/YWxlcnQoXCJUaHJlYWQgXCIrbi50aHJlYWRJZCtcIjogXCIrbi50ZXh0KTpcInNldGltbWVkaWF0ZVwiPT09bi50YXJnZXQ/ZS5wb3N0TWVzc2FnZShuKTpcIm9uQWJvcnRcIj09PXI/cy5vbkFib3J0JiZzLm9uQWJvcnQobi5hcmcpOnImJiQoXCJ3b3JrZXIgc2VudCBhbiB1bmtub3duIGNvbW1hbmQgXCIrcik7cGUua2I9dm9pZCAwfSxlLm9uZXJyb3I9ZT0+e3Rocm93ICQoXCJ3b3JrZXIgc2VudCBhbiBlcnJvciEgXCIrZS5maWxlbmFtZStcIjpcIitlLmxpbmVubytcIjogXCIrZS5tZXNzYWdlKSxlfSx2JiYoZS5vbihcIm1lc3NhZ2VcIiwoZnVuY3Rpb24odCl7ZS5vbm1lc3NhZ2Uoe2RhdGE6dH0pfSkpLGUub24oXCJlcnJvclwiLChmdW5jdGlvbih0KXtlLm9uZXJyb3IodCl9KSksZS5vbihcImRldGFjaGVkRXhpdFwiLChmdW5jdGlvbigpe30pKSksZS5wb3N0TWVzc2FnZSh7Y21kOlwibG9hZFwiLHVybE9yQmxvYjpzLm1haW5TY3JpcHRVcmxPckJsb2J8fF9zY3JpcHREaXIsd2FzbU1lbW9yeTpELHdhc21Nb2R1bGU6a30pfSxoYjpmdW5jdGlvbigpe3ZhciBlPVMoXCJvcnQtd2FzbS10aHJlYWRlZC53b3JrZXIuanNcIik7cGUuT2EucHVzaChuZXcgV29ya2VyKGUpKX0sbGI6ZnVuY3Rpb24oKXtyZXR1cm4gMD09cGUuT2EubGVuZ3RoJiYocGUuaGIoKSxwZS5uYihwZS5PYVswXSkpLHBlLk9hLnBvcCgpfX07ZnVuY3Rpb24gZGUoZSl7Zm9yKDswPGUubGVuZ3RoOyllLnNoaWZ0KCkocyl9ZnVuY3Rpb24gZmUoZSl7aWYoeClyZXR1cm4gamUoMiwwLGUpO3RyeXtjZShlKX1jYXRjaChlKXtlIGluc3RhbmNlb2YgYWV8fFwidW53aW5kXCI9PWV8fHkoMSxlKX19cy5QVGhyZWFkPXBlLHMuZXN0YWJsaXNoU3RhY2tTcGFjZT1mdW5jdGlvbigpe3ZhciBlPXJ0KCksdD1vKClbZSs0ND4+Mj4+PjBdO2U9bygpW2UrNDg+PjI+Pj4wXSxwdCh0LHQtZSksZnQodCl9O3ZhciBoZSxnZSxtZT1bXTtmdW5jdGlvbiBiZShlKXt0aGlzLlBhPWUtMjQsdGhpcy5nYj1mdW5jdGlvbihlKXtpKClbdGhpcy5QYSs0Pj4yPj4+MF09ZX0sdGhpcy5jYj1mdW5jdGlvbihlKXtpKClbdGhpcy5QYSs4Pj4yPj4+MF09ZX0sdGhpcy5lYj1mdW5jdGlvbigpe28oKVt0aGlzLlBhPj4yPj4+MF09MH0sdGhpcy5iYj1mdW5jdGlvbigpe3QoKVt0aGlzLlBhKzEyPj4wPj4+MF09MH0sdGhpcy5mYj1mdW5jdGlvbigpe3QoKVt0aGlzLlBhKzEzPj4wPj4+MF09MH0sdGhpcy5VYT1mdW5jdGlvbihlLHQpe3RoaXMuYWIoKSx0aGlzLmdiKGUpLHRoaXMuY2IodCksdGhpcy5lYigpLHRoaXMuYmIoKSx0aGlzLmZiKCl9LHRoaXMuYWI9ZnVuY3Rpb24oKXtpKClbdGhpcy5QYSsxNj4+Mj4+PjBdPTB9fWZ1bmN0aW9uIHllKGUsdCxuLHIpe3JldHVybiB4P2plKDMsMSxlLHQsbixyKTp3ZShlLHQsbixyKX1mdW5jdGlvbiB3ZShlLHQsbixyKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIpcmV0dXJuICQoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciBvPVtdO3JldHVybiB4JiYwPT09by5sZW5ndGg/eWUoZSx0LG4scik6KGU9e3BiOm4sS2E6ZSxpYjpyLHZiOm99LHg/KGUud2I9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKGUsbyksMCk6dWUoZSkpfWZ1bmN0aW9uIF9lKGUsdCxuKXtyZXR1cm4geD9qZSg0LDEsZSx0LG4pOjB9ZnVuY3Rpb24gdmUoZSx0KXtpZih4KXJldHVybiBqZSg1LDEsZSx0KX1mdW5jdGlvbiB4ZShlLHQpe2lmKHgpcmV0dXJuIGplKDYsMSxlLHQpfWZ1bmN0aW9uIFRlKGUsdCxuKXtpZih4KXJldHVybiBqZSg3LDEsZSx0LG4pfWZ1bmN0aW9uIFNlKGUsdCxuKXtyZXR1cm4geD9qZSg4LDEsZSx0LG4pOjB9ZnVuY3Rpb24gT2UoZSx0KXtpZih4KXJldHVybiBqZSg5LDEsZSx0KX1mdW5jdGlvbiBBZShlLHQsbil7aWYoeClyZXR1cm4gamUoMTAsMSxlLHQsbil9ZnVuY3Rpb24gRWUoZSx0LG4scil7aWYoeClyZXR1cm4gamUoMTEsMSxlLHQsbixyKX1mdW5jdGlvbiBJZShlLHQsbixyKXtpZih4KXJldHVybiBqZSgxMiwxLGUsdCxuLHIpfWZ1bmN0aW9uICRlKGUsdCxuLHIpe2lmKHgpcmV0dXJuIGplKDEzLDEsZSx0LG4scil9ZnVuY3Rpb24gUGUoZSl7aWYoeClyZXR1cm4gamUoMTQsMSxlKX1mdW5jdGlvbiBEZShlLHQpe2lmKHgpcmV0dXJuIGplKDE1LDEsZSx0KX1mdW5jdGlvbiBrZShlLHQsbil7aWYoeClyZXR1cm4gamUoMTYsMSxlLHQsbil9ZnVuY3Rpb24gQ2UoZSl7QXRvbWljcy5zdG9yZShvKCksZT4+MiwxKSxydCgpJiZ1dChlKSxBdG9taWNzLmNvbXBhcmVFeGNoYW5nZShvKCksZT4+MiwxLDApfWZ1bmN0aW9uIFJlKGUpe3JldHVybiBpKClbZT4+PjJdKzQyOTQ5NjcyOTYqbygpW2UrND4+PjJdfWZ1bmN0aW9uIE1lKGUsdCxuLHIsbyxpKXtyZXR1cm4geD9qZSgxNywxLGUsdCxuLHIsbyxpKTotNTJ9ZnVuY3Rpb24gTmUoZSx0LG4scixvLGkpe2lmKHgpcmV0dXJuIGplKDE4LDEsZSx0LG4scixvLGkpfWZ1bmN0aW9uIEZlKGUpe3ZhciBuPXooZSkrMSxyPW90KG4pO3JldHVybiByJiZWKGUsdCgpLHIsbikscn1mdW5jdGlvbiBMZShlLHQsbil7ZnVuY3Rpb24gcihlKXtyZXR1cm4oZT1lLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLykpP2VbMV06XCJHTVRcIn1pZih4KXJldHVybiBqZSgxOSwxLGUsdCxuKTt2YXIgYT0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCkscz1uZXcgRGF0ZShhLDAsMSksdT1uZXcgRGF0ZShhLDYsMSk7YT1zLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGw9dS5nZXRUaW1lem9uZU9mZnNldCgpLGM9TWF0aC5tYXgoYSxsKTtvKClbZT4+Mj4+PjBdPTYwKmMsbygpW3Q+PjI+Pj4wXT1OdW1iZXIoYSE9bCksZT1yKHMpLHQ9cih1KSxlPUZlKGUpLHQ9RmUodCksbDxhPyhpKClbbj4+Mj4+PjBdPWUsaSgpW24rND4+Mj4+PjBdPXQpOihpKClbbj4+Mj4+PjBdPXQsaSgpW24rND4+Mj4+PjBdPWUpfWZ1bmN0aW9uIGplKGUsdCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aC0yLHI9YXJndW1lbnRzO3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD1kdCgpO3JldHVybiBlPWUoKSxmdCh0KSxlfSgoKCk9Pntmb3IodmFyIG89aHQoOCpuKSxpPW8+PjMscz0wO3M8bjtzKyspe3ZhciB1PXJbMitzXTthKClbaStzPj4+MF09dX1yZXR1cm4gc3QoZSxuLG8sdCl9KSl9cy5pbnZva2VFbnRyeVBvaW50PWZ1bmN0aW9uKGUsdCl7dmFyIG49bWVbZV07bnx8KGU+PW1lLmxlbmd0aCYmKG1lLmxlbmd0aD1lKzEpLG1lW2VdPW49cS5nZXQoZSkpLGU9bih0KSxQP3BlLllhKGUpOmN0KGUpfSxzLmV4ZWN1dGVOb3RpZmllZFByb3h5aW5nUXVldWU9Q2UsZ2U9dj8oKT0+e3ZhciBlPXByb2Nlc3MuaHJ0aW1lKCk7cmV0dXJuIDFlMyplWzBdK2VbMV0vMWU2fTp4PygpPT5wZXJmb3JtYW5jZS5ub3coKS1zLl9fcGVyZm9ybWFuY2Vfbm93X2Nsb2NrX2RyaWZ0OigpPT5wZXJmb3JtYW5jZS5ub3coKTt2YXIgVWUsQmU9W10sR2U9e307ZnVuY3Rpb24gVmUoKXtpZighVWUpe3ZhciBlLHQ9e1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KFwib2JqZWN0XCI9PXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86Ynx8XCIuL3RoaXMucHJvZ3JhbVwifTtmb3IoZSBpbiBHZSl2b2lkIDA9PT1HZVtlXT9kZWxldGUgdFtlXTp0W2VdPUdlW2VdO3ZhciBuPVtdO2ZvcihlIGluIHQpbi5wdXNoKGUrXCI9XCIrdFtlXSk7VWU9bn1yZXR1cm4gVWV9ZnVuY3Rpb24gemUoZSxuKXtpZih4KXJldHVybiBqZSgyMCwxLGUsbik7dmFyIHI9MDtyZXR1cm4gVmUoKS5mb3JFYWNoKChmdW5jdGlvbihvLGEpe3ZhciBzPW4rcjtmb3IoYT1pKClbZSs0KmE+PjI+Pj4wXT1zLHM9MDtzPG8ubGVuZ3RoOysrcyl0KClbYSsrPj4wPj4+MF09by5jaGFyQ29kZUF0KHMpO3QoKVthPj4wPj4+MF09MCxyKz1vLmxlbmd0aCsxfSkpLDB9ZnVuY3Rpb24gSGUoZSx0KXtpZih4KXJldHVybiBqZSgyMSwxLGUsdCk7dmFyIG49VmUoKTtpKClbZT4+Mj4+PjBdPW4ubGVuZ3RoO3ZhciByPTA7cmV0dXJuIG4uZm9yRWFjaCgoZnVuY3Rpb24oZSl7cis9ZS5sZW5ndGgrMX0pKSxpKClbdD4+Mj4+PjBdPXIsMH1mdW5jdGlvbiBXZShlKXtyZXR1cm4geD9qZSgyMiwxLGUpOjUyfWZ1bmN0aW9uIHFlKGUsdCxuLHIpe3JldHVybiB4P2plKDIzLDEsZSx0LG4scik6NTJ9ZnVuY3Rpb24gS2UoZSx0LG4scixvKXtyZXR1cm4geD9qZSgyNCwxLGUsdCxuLHIsbyk6NzB9dmFyIFhlPVtudWxsLFtdLFtdXTtmdW5jdGlvbiBZZShlLHQsbixvKXtpZih4KXJldHVybiBqZSgyNSwxLGUsdCxuLG8pO2Zvcih2YXIgYT0wLHM9MDtzPG47cysrKXt2YXIgdT1pKClbdD4+Mj4+PjBdLGw9aSgpW3QrND4+Mj4+PjBdO3QrPTg7Zm9yKHZhciBjPTA7YzxsO2MrKyl7dmFyIHA9cigpW3UrYz4+PjBdLGQ9WGVbZV07MD09PXB8fDEwPT09cD8oKDE9PT1lP0k6JCkoQihkLDApKSxkLmxlbmd0aD0wKTpkLnB1c2gocCl9YSs9bH1yZXR1cm4gaSgpW28+PjI+Pj4wXT1hLDB9ZnVuY3Rpb24gSmUoZSl7cmV0dXJuIDA9PWUlNCYmKDAhPWUlMTAwfHwwPT1lJTQwMCl9dmFyIFplPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sUWU9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBldChlLG4scixpKXtmdW5jdGlvbiBhKGUsdCxuKXtmb3IoZT1cIm51bWJlclwiPT10eXBlb2YgZT9lLnRvU3RyaW5nKCk6ZXx8XCJcIjtlLmxlbmd0aDx0OyllPW5bMF0rZTtyZXR1cm4gZX1mdW5jdGlvbiBzKGUsdCl7cmV0dXJuIGEoZSx0LFwiMFwiKX1mdW5jdGlvbiB1KGUsdCl7ZnVuY3Rpb24gbihlKXtyZXR1cm4gMD5lPy0xOjA8ZT8xOjB9dmFyIHI7cmV0dXJuIDA9PT0ocj1uKGUuZ2V0RnVsbFllYXIoKS10LmdldEZ1bGxZZWFyKCkpKSYmMD09PShyPW4oZS5nZXRNb250aCgpLXQuZ2V0TW9udGgoKSkpJiYocj1uKGUuZ2V0RGF0ZSgpLXQuZ2V0RGF0ZSgpKSkscn1mdW5jdGlvbiBsKGUpe3N3aXRjaChlLmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIGU7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIGMoZSl7dmFyIHQ9ZS5NYTtmb3IoZT1uZXcgRGF0ZShuZXcgRGF0ZShlLk5hKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8dDspe3ZhciBuPWUuZ2V0TW9udGgoKSxyPShKZShlLmdldEZ1bGxZZWFyKCkpP1plOlFlKVtuXTtpZighKHQ+ci1lLmdldERhdGUoKSkpe2Uuc2V0RGF0ZShlLmdldERhdGUoKSt0KTticmVha310LT1yLWUuZ2V0RGF0ZSgpKzEsZS5zZXREYXRlKDEpLDExPm4/ZS5zZXRNb250aChuKzEpOihlLnNldE1vbnRoKDApLGUuc2V0RnVsbFllYXIoZS5nZXRGdWxsWWVhcigpKzEpKX1yZXR1cm4gbj1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCkrMSwwLDQpLHQ9bChuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCw0KSksbj1sKG4pLDA+PXUodCxlKT8wPj11KG4sZSk/ZS5nZXRGdWxsWWVhcigpKzE6ZS5nZXRGdWxsWWVhcigpOmUuZ2V0RnVsbFllYXIoKS0xfXZhciBwPW8oKVtpKzQwPj4yPj4+MF07Zm9yKHZhciBkIGluIGk9e3RiOm8oKVtpPj4yPj4+MF0sc2I6bygpW2krND4+Mj4+PjBdLFNhOm8oKVtpKzg+PjI+Pj4wXSxWYTpvKClbaSsxMj4+Mj4+PjBdLFRhOm8oKVtpKzE2Pj4yPj4+MF0sTmE6bygpW2krMjA+PjI+Pj4wXSxKYTpvKClbaSsyND4+Mj4+PjBdLE1hOm8oKVtpKzI4Pj4yPj4+MF0semI6bygpW2krMzI+PjI+Pj4wXSxyYjpvKClbaSszNj4+Mj4+PjBdLHViOnA/RyhwKTpcIlwifSxyPUcocikscD17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9KXI9ci5yZXBsYWNlKG5ldyBSZWdFeHAoZCxcImdcIikscFtkXSk7dmFyIGY9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxoPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtmb3IoZCBpbiBwPXtcIiVhXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGZbZS5KYV0uc3Vic3RyaW5nKDAsMyl9LFwiJUFcIjpmdW5jdGlvbihlKXtyZXR1cm4gZltlLkphXX0sXCIlYlwiOmZ1bmN0aW9uKGUpe3JldHVybiBoW2UuVGFdLnN1YnN0cmluZygwLDMpfSxcIiVCXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGhbZS5UYV19LFwiJUNcIjpmdW5jdGlvbihlKXtyZXR1cm4gcygoZS5OYSsxOTAwKS8xMDB8MCwyKX0sXCIlZFwiOmZ1bmN0aW9uKGUpe3JldHVybiBzKGUuVmEsMil9LFwiJWVcIjpmdW5jdGlvbihlKXtyZXR1cm4gYShlLlZhLDIsXCIgXCIpfSxcIiVnXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGMoZSkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJUdcIjpmdW5jdGlvbihlKXtyZXR1cm4gYyhlKX0sXCIlSFwiOmZ1bmN0aW9uKGUpe3JldHVybiBzKGUuU2EsMil9LFwiJUlcIjpmdW5jdGlvbihlKXtyZXR1cm4gMD09KGU9ZS5TYSk/ZT0xMjoxMjxlJiYoZS09MTIpLHMoZSwyKX0sXCIlalwiOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wLG49MDtuPD1lLlRhLTE7dCs9KEplKGUuTmErMTkwMCk/WmU6UWUpW24rK10pO3JldHVybiBzKGUuVmErdCwzKX0sXCIlbVwiOmZ1bmN0aW9uKGUpe3JldHVybiBzKGUuVGErMSwyKX0sXCIlTVwiOmZ1bmN0aW9uKGUpe3JldHVybiBzKGUuc2IsMil9LFwiJW5cIjpmdW5jdGlvbigpe3JldHVyblwiXFxuXCJ9LFwiJXBcIjpmdW5jdGlvbihlKXtyZXR1cm4gMDw9ZS5TYSYmMTI+ZS5TYT9cIkFNXCI6XCJQTVwifSxcIiVTXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHMoZS50YiwyKX0sXCIldFwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXHRcIn0sXCIldVwiOmZ1bmN0aW9uKGUpe3JldHVybiBlLkphfHw3fSxcIiVVXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHMoTWF0aC5mbG9vcigoZS5NYSs3LWUuSmEpLzcpLDIpfSxcIiVWXCI6ZnVuY3Rpb24oZSl7dmFyIHQ9TWF0aC5mbG9vcigoZS5NYSs3LShlLkphKzYpJTcpLzcpO2lmKDI+PShlLkphKzM3MS1lLk1hLTIpJTcmJnQrKyx0KTUzPT10JiYoND09KG49KGUuSmErMzcxLWUuTWEpJTcpfHwzPT1uJiZKZShlLk5hKXx8KHQ9MSkpO2Vsc2V7dD01Mjt2YXIgbj0oZS5KYSs3LWUuTWEtMSklNzsoND09bnx8NT09biYmSmUoZS5OYSU0MDAtMSkpJiZ0Kyt9cmV0dXJuIHModCwyKX0sXCIld1wiOmZ1bmN0aW9uKGUpe3JldHVybiBlLkphfSxcIiVXXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHMoTWF0aC5mbG9vcigoZS5NYSs3LShlLkphKzYpJTcpLzcpLDIpfSxcIiV5XCI6ZnVuY3Rpb24oZSl7cmV0dXJuKGUuTmErMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJVlcIjpmdW5jdGlvbihlKXtyZXR1cm4gZS5OYSsxOTAwfSxcIiV6XCI6ZnVuY3Rpb24oZSl7dmFyIHQ9MDw9KGU9ZS5yYik7cmV0dXJuIGU9TWF0aC5hYnMoZSkvNjAsKHQ/XCIrXCI6XCItXCIpK1N0cmluZyhcIjAwMDBcIisoZS82MCoxMDArZSU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOmZ1bmN0aW9uKGUpe3JldHVybiBlLnVifSxcIiUlXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIiVcIn19LHI9ci5yZXBsYWNlKC8lJS9nLFwiXFwwXFwwXCIpLHApci5pbmNsdWRlcyhkKSYmKHI9ci5yZXBsYWNlKG5ldyBSZWdFeHAoZCxcImdcIikscFtkXShpKSkpO3JldHVybiBkPWZ1bmN0aW9uKGUpe3ZhciB0PUFycmF5KHooZSkrMSk7cmV0dXJuIFYoZSx0LDAsdC5sZW5ndGgpLHR9KHI9ci5yZXBsYWNlKC9cXDBcXDAvZyxcIiVcIikpLGQubGVuZ3RoPm4/MDooZnVuY3Rpb24oZSxuKXt0KCkuc2V0KGUsbj4+PjApfShkLGUpLGQubGVuZ3RoLTEpfXBlLlVhKCk7dmFyIHR0PVtudWxsLGxlLGZlLHllLF9lLHZlLHhlLFRlLFNlLE9lLEFlLEVlLEllLCRlLFBlLERlLGtlLE1lLE5lLExlLHplLEhlLFdlLHFlLEtlLFllXSxudD17YjpmdW5jdGlvbihlKXtyZXR1cm4gb3QoZSsyNCkrMjR9LGM6ZnVuY3Rpb24oZSx0LG4pe3Rocm93IG5ldyBiZShlKS5VYSh0LG4pLGV9LEw6ZnVuY3Rpb24oZSl7aXQoZSwhXywxLCF3KSxwZS5aYSgpfSxsOmZ1bmN0aW9uKGUpe3g/cG9zdE1lc3NhZ2Uoe2NtZDpcImNsZWFudXBUaHJlYWRcIix0aHJlYWQ6ZX0pOnNlKGUpfSxEOndlLGk6X2UsUjp2ZSx6OnhlLEI6VGUsVDpTZSxQOk9lLEk6QWUsTzpFZSxwOkllLEE6JGUseDpQZSxROkRlLHk6a2UscjpmdW5jdGlvbigpe30sajpmdW5jdGlvbigpe25lKFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LHM6ZnVuY3Rpb24oKXtuZShcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxxOmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9LEU6ZnVuY3Rpb24oKXtyZXR1cm4gMjA5NzE1Mn0sVjpmdW5jdGlvbigpe3JldHVybiEwfSxGOmZ1bmN0aW9uKGUsdCxuLHIpe2lmKGU9PXQpc2V0VGltZW91dCgoKCk9PkNlKHIpKSk7ZWxzZSBpZih4KXBvc3RNZXNzYWdlKHt0YXJnZXRUaHJlYWQ6ZSxjbWQ6XCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiLHF1ZXVlOnJ9KTtlbHNle2lmKCEoZT1wZS5MYVtlXSkpcmV0dXJuO2UucG9zdE1lc3NhZ2Uoe2NtZDpcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCIscXVldWU6cn0pfXJldHVybiAxfSxLOmZ1bmN0aW9uKCl7cmV0dXJuLTF9LFc6ZnVuY3Rpb24oZSx0KXtlPW5ldyBEYXRlKDFlMypSZShlKSksbygpW3Q+PjI+Pj4wXT1lLmdldFVUQ1NlY29uZHMoKSxvKClbdCs0Pj4yPj4+MF09ZS5nZXRVVENNaW51dGVzKCksbygpW3QrOD4+Mj4+PjBdPWUuZ2V0VVRDSG91cnMoKSxvKClbdCsxMj4+Mj4+PjBdPWUuZ2V0VVRDRGF0ZSgpLG8oKVt0KzE2Pj4yPj4+MF09ZS5nZXRVVENNb250aCgpLG8oKVt0KzIwPj4yPj4+MF09ZS5nZXRVVENGdWxsWWVhcigpLTE5MDAsbygpW3QrMjQ+PjI+Pj4wXT1lLmdldFVUQ0RheSgpLGU9KGUuZ2V0VGltZSgpLURhdGUuVVRDKGUuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDAsbygpW3QrMjg+PjI+Pj4wXT1lfSxYOmZ1bmN0aW9uKGUsdCl7ZT1uZXcgRGF0ZSgxZTMqUmUoZSkpLG8oKVt0Pj4yPj4+MF09ZS5nZXRTZWNvbmRzKCksbygpW3QrND4+Mj4+PjBdPWUuZ2V0TWludXRlcygpLG8oKVt0Kzg+PjI+Pj4wXT1lLmdldEhvdXJzKCksbygpW3QrMTI+PjI+Pj4wXT1lLmdldERhdGUoKSxvKClbdCsxNj4+Mj4+PjBdPWUuZ2V0TW9udGgoKSxvKClbdCsyMD4+Mj4+PjBdPWUuZ2V0RnVsbFllYXIoKS0xOTAwLG8oKVt0KzI0Pj4yPj4+MF09ZS5nZXREYXkoKTt2YXIgbj1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwxKSxyPShlLmdldFRpbWUoKS1uLmdldFRpbWUoKSkvODY0ZTV8MDtvKClbdCsyOD4+Mj4+PjBdPXIsbygpW3QrMzY+PjI+Pj4wXT0tNjAqZS5nZXRUaW1lem9uZU9mZnNldCgpLHI9bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxlPTB8KHIhPShuPW4uZ2V0VGltZXpvbmVPZmZzZXQoKSkmJmUuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4obixyKSksbygpW3QrMzI+PjI+Pj4wXT1lfSxZOmZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBEYXRlKG8oKVtlKzIwPj4yPj4+MF0rMTkwMCxvKClbZSsxNj4+Mj4+PjBdLG8oKVtlKzEyPj4yPj4+MF0sbygpW2UrOD4+Mj4+PjBdLG8oKVtlKzQ+PjI+Pj4wXSxvKClbZT4+Mj4+PjBdLDApLG49bygpW2UrMzI+PjI+Pj4wXSxyPXQuZ2V0VGltZXpvbmVPZmZzZXQoKSxpPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDEpLGE9bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxzPWkuZ2V0VGltZXpvbmVPZmZzZXQoKSx1PU1hdGgubWluKHMsYSk7cmV0dXJuIDA+bj9vKClbZSszMj4+Mj4+PjBdPU51bWJlcihhIT1zJiZ1PT1yKTowPG4hPSh1PT1yKSYmKGE9TWF0aC5tYXgocyxhKSx0LnNldFRpbWUodC5nZXRUaW1lKCkrNmU0KigoMDxuP3U6YSktcikpKSxvKClbZSsyND4+Mj4+PjBdPXQuZ2V0RGF5KCksbj0odC5nZXRUaW1lKCktaS5nZXRUaW1lKCkpLzg2NGU1fDAsbygpW2UrMjg+PjI+Pj4wXT1uLG8oKVtlPj4yPj4+MF09dC5nZXRTZWNvbmRzKCksbygpW2UrND4+Mj4+PjBdPXQuZ2V0TWludXRlcygpLG8oKVtlKzg+PjI+Pj4wXT10LmdldEhvdXJzKCksbygpW2UrMTI+PjI+Pj4wXT10LmdldERhdGUoKSxvKClbZSsxNj4+Mj4+PjBdPXQuZ2V0TW9udGgoKSx0LmdldFRpbWUoKS8xZTN8MH0sRzpNZSxIOk5lLFo6ZnVuY3Rpb24gZSh0LG4scil7ZS5qYnx8KGUuamI9ITAsTGUodCxuLHIpKX0sZDpmdW5jdGlvbigpe25lKFwiXCIpfSxtOmZ1bmN0aW9uKCl7aWYoIXYmJiFfKXt2YXIgZT1cIkJsb2NraW5nIG9uIHRoZSBtYWluIHRocmVhZCBpcyB2ZXJ5IGRhbmdlcm91cywgc2VlIGh0dHBzOi8vZW1zY3JpcHRlbi5vcmcvZG9jcy9wb3J0aW5nL3B0aHJlYWRzLmh0bWwjYmxvY2tpbmctb24tdGhlLW1haW4tYnJvd3Nlci10aHJlYWRcIjtoZXx8KGhlPXt9KSxoZVtlXXx8KGhlW2VdPTEsdiYmKGU9XCJ3YXJuaW5nOiBcIitlKSwkKGUpKX19LHc6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sZjpnZSxTOmZ1bmN0aW9uKGUsdCxuKXtyKCkuY29weVdpdGhpbihlPj4+MCx0Pj4+MCx0K24+Pj4wKX0sZzpmdW5jdGlvbigpe3JldHVybiB2P24oMzk5MykuY3B1cygpLmxlbmd0aDpuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeX0sSjpmdW5jdGlvbihlLHQsbil7QmUubGVuZ3RoPXQsbj4+PTM7Zm9yKHZhciByPTA7cjx0O3IrKylCZVtyXT1hKClbbityPj4+MF07cmV0dXJuKDA+ZT9pZVstZS0xXTp0dFtlXSkuYXBwbHkobnVsbCxCZSl9LHY6ZnVuY3Rpb24oZSl7dmFyIHQ9cigpLmxlbmd0aDtpZigoZT4+Pj0wKTw9dHx8NDI5NDkwMTc2MDxlKXJldHVybiExO2Zvcih2YXIgbj0xOzQ+PW47bio9Mil7dmFyIG89dCooMSsuMi9uKTtvPU1hdGgubWluKG8sZSsxMDA2NjMyOTYpO3ZhciBpPU1hdGg7bz1NYXRoLm1heChlLG8pLGk9aS5taW4uY2FsbChpLDQyOTQ5MDE3NjAsbysoNjU1MzYtbyU2NTUzNiklNjU1MzYpO2U6e3RyeXtELmdyb3coaS1DLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNiksSChELmJ1ZmZlcik7dmFyIGE9MTticmVhayBlfWNhdGNoKGUpe31hPXZvaWQgMH1pZihhKXJldHVybiEwfXJldHVybiExfSxVOmZ1bmN0aW9uKCl7dGhyb3dcInVud2luZFwifSxNOnplLE46SGUsazpjZSxoOldlLG86cWUsdDpLZSxuOlllLHU6ZnVuY3Rpb24gZShyLG8pe2UuV2F8fChlLldhPWZ1bmN0aW9uKCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGNyeXB0byYmXCJmdW5jdGlvblwiPT10eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyl7dmFyIGU9bmV3IFVpbnQ4QXJyYXkoMSk7cmV0dXJuKCk9PihjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGUpLGVbMF0pfWlmKHYpdHJ5e3ZhciB0PW4oNzYwKTtyZXR1cm4oKT0+dC5yYW5kb21CeXRlcygxKVswXX1jYXRjaChlKXt9cmV0dXJuKCk9Pm5lKFwicmFuZG9tRGV2aWNlXCIpfSgpKTtmb3IodmFyIGk9MDtpPG87aSsrKXQoKVtyK2k+PjA+Pj4wXT1lLldhKCk7cmV0dXJuIDB9LGE6RHx8cy53YXNtTWVtb3J5LEM6ZXQsZTpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gZXQoZSx0LG4scil9fTshZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7cy5hc209ZS5leHBvcnRzLHBlLiRhLnB1c2gocy5hc20ud2EpLHE9cy5hc20uemEsWC51bnNoaWZ0KHMuYXNtLl8pLGs9dCx4fHwoUS0tLHMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmcy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKFEpLDA9PVEmJihudWxsIT09ZWUmJihjbGVhckludGVydmFsKGVlKSxlZT1udWxsKSx0ZSYmKGU9dGUsdGU9bnVsbCxlKCkpKSl9ZnVuY3Rpb24gdCh0KXtlKHQuaW5zdGFuY2UsdC5tb2R1bGUpfWZ1bmN0aW9uIG4oZSl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoIUUmJih3fHxfKSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZmV0Y2gmJiFaLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpKXJldHVybiBmZXRjaChaLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbihlKXtpZighZS5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnXCIrWitcIidcIjtyZXR1cm4gZS5hcnJheUJ1ZmZlcigpfSkpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBvZSgpfSkpO2lmKHApcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihlLHQpe3AoWiwoZnVuY3Rpb24odCl7ZShuZXcgVWludDhBcnJheSh0KSl9KSx0KX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gb2UoKX0pKX0oKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoZSxyKX0pKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gZX0pKS50aGVuKGUsKGZ1bmN0aW9uKGUpeyQoXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIitlKSxuZShlKX0pKX12YXIgcj17YTpudH07aWYoeHx8KFErKyxzLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJnMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhRKSkscy5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBzLmluc3RhbnRpYXRlV2FzbShyLGUpfWNhdGNoKGUpe3JldHVybiAkKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrZSksITF9KEV8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxyZSgpfHxaLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpfHx2fHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBmZXRjaD9uKHQpOmZldGNoKFose2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhlLHIpLnRoZW4odCwoZnVuY3Rpb24oZSl7cmV0dXJuICQoXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIrZSksJChcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLG4odCl9KSl9KSkpLmNhdGNoKGwpfSgpLHMuX19fd2FzbV9jYWxsX2N0b3JzPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19fd2FzbV9jYWxsX2N0b3JzPXMuYXNtLl8pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0SW5pdD1mdW5jdGlvbigpe3JldHVybihzLl9PcnRJbml0PXMuYXNtLiQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9cy5hc20uYWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9cy5hc20uYmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1zLmFzbS5jYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPXMuYXNtLmRhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydENyZWF0ZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0Q3JlYXRlU2Vzc2lvbj1zLmFzbS5lYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRSZWxlYXNlU2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybihzLl9PcnRSZWxlYXNlU2Vzc2lvbj1zLmFzbS5mYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRHZXRJbnB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEdldElucHV0Q291bnQ9cy5hc20uZ2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0T3V0cHV0Q291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0R2V0T3V0cHV0Q291bnQ9cy5hc20uaGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0SW5wdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEdldElucHV0TmFtZT1zLmFzbS5pYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRHZXRPdXRwdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEdldE91dHB1dE5hbWU9cy5hc20uamEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0RnJlZT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRGcmVlPXMuYXNtLmthKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydENyZWF0ZVRlbnNvcj1mdW5jdGlvbigpe3JldHVybihzLl9PcnRDcmVhdGVUZW5zb3I9cy5hc20ubGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0VGVuc29yRGF0YT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRUZW5zb3JEYXRhPXMuYXNtLm1hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydFJlbGVhc2VUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0UmVsZWFzZVRlbnNvcj1zLmFzbS5uYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRDcmVhdGVSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydENyZWF0ZVJ1bk9wdGlvbnM9cy5hc20ub2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0QWRkUnVuQ29uZmlnRW50cnk9cy5hc20ucGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9cy5hc20ucWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0UnVuPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJ1bj1zLmFzbS5yYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRFbmRQcm9maWxpbmc9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0RW5kUHJvZmlsaW5nPXMuYXNtLnNhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBydD1zLl9wdGhyZWFkX3NlbGY9ZnVuY3Rpb24oKXtyZXR1cm4ocnQ9cy5fcHRocmVhZF9zZWxmPXMuYXNtLnRhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG90PXMuX21hbGxvYz1mdW5jdGlvbigpe3JldHVybihvdD1zLl9tYWxsb2M9cy5hc20udWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07cy5fZnJlZT1mdW5jdGlvbigpe3JldHVybihzLl9mcmVlPXMuYXNtLnZhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX19lbXNjcmlwdGVuX3Rsc19pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19lbXNjcmlwdGVuX3Rsc19pbml0PXMuYXNtLndhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBpdD1zLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD1mdW5jdGlvbigpe3JldHVybihpdD1zLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD1zLmFzbS54YSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtzLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZD1mdW5jdGlvbigpe3JldHVybihzLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZD1zLmFzbS55YSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgYXQsc3Q9cy5fZW1zY3JpcHRlbl9ydW5faW5fbWFpbl9ydW50aW1lX3RocmVhZF9qcz1mdW5jdGlvbigpe3JldHVybihzdD1zLl9lbXNjcmlwdGVuX3J1bl9pbl9tYWluX3J1bnRpbWVfdGhyZWFkX2pzPXMuYXNtLkFhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHV0PXMuX19lbXNjcmlwdGVuX3Byb3h5X2V4ZWN1dGVfdGFza19xdWV1ZT1mdW5jdGlvbigpe3JldHVybih1dD1zLl9fZW1zY3JpcHRlbl9wcm94eV9leGVjdXRlX3Rhc2tfcXVldWU9cy5hc20uQmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbHQ9cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2ZyZWVfZGF0YT1mdW5jdGlvbigpe3JldHVybihsdD1zLl9fZW1zY3JpcHRlbl90aHJlYWRfZnJlZV9kYXRhPXMuYXNtLkNhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGN0PXMuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0PWZ1bmN0aW9uKCl7cmV0dXJuKGN0PXMuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0PXMuYXNtLkRhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHB0PXMuX2Vtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0cz1mdW5jdGlvbigpe3JldHVybihwdD1zLl9lbXNjcmlwdGVuX3N0YWNrX3NldF9saW1pdHM9cy5hc20uRWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZHQ9cy5zdGFja1NhdmU9ZnVuY3Rpb24oKXtyZXR1cm4oZHQ9cy5zdGFja1NhdmU9cy5hc20uRmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZnQ9cy5zdGFja1Jlc3RvcmU9ZnVuY3Rpb24oKXtyZXR1cm4oZnQ9cy5zdGFja1Jlc3RvcmU9cy5hc20uR2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0saHQ9cy5zdGFja0FsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKGh0PXMuc3RhY2tBbGxvYz1zLmFzbS5IYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiBndCgpe2Z1bmN0aW9uIGUoKXtpZighYXQmJihhdD0hMCxzLmNhbGxlZFJ1bj0hMCwhaikmJih4fHxkZShYKSx1KHMpLHMub25SdW50aW1lSW5pdGlhbGl6ZWQmJnMub25SdW50aW1lSW5pdGlhbGl6ZWQoKSwheCkpe2lmKHMucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2Ygcy5wb3N0UnVuJiYocy5wb3N0UnVuPVtzLnBvc3RSdW5dKTtzLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIGU9cy5wb3N0UnVuLnNoaWZ0KCk7WS51bnNoaWZ0KGUpfWRlKFkpfX1pZighKDA8USkpaWYoeCl1KHMpLHh8fGRlKFgpLHBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkZWRcIn0pO2Vsc2V7aWYocy5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHMucHJlUnVuJiYocy5wcmVSdW49W3MucHJlUnVuXSk7cy5wcmVSdW4ubGVuZ3RoOylKKCk7ZGUoSyksMDxRfHwocy5zZXRTdGF0dXM/KHMuc2V0U3RhdHVzKFwiUnVubmluZy4uLlwiKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7cy5zZXRTdGF0dXMoXCJcIil9KSwxKSxlKCl9KSwxKSk6ZSgpKX19aWYocy5fX19jeGFfaXNfcG9pbnRlcl90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1zLmFzbS5JYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLlVURjhUb1N0cmluZz1HLHMuc3RyaW5nVG9VVEY4PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gVihlLHIoKSx0LG4pfSxzLmxlbmd0aEJ5dGVzVVRGOD16LHMua2VlcFJ1bnRpbWVBbGl2ZT1mdW5jdGlvbigpe3JldHVybiBQfSxzLndhc21NZW1vcnk9RCxzLnN0YWNrU2F2ZT1kdCxzLnN0YWNrUmVzdG9yZT1mdCxzLnN0YWNrQWxsb2M9aHQscy5FeGl0U3RhdHVzPWFlLHMuUFRocmVhZD1wZSx0ZT1mdW5jdGlvbiBlKCl7YXR8fGd0KCksYXR8fCh0ZT1lKX0scy5wcmVJbml0KWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBzLnByZUluaXQmJihzLnByZUluaXQ9W3MucHJlSW5pdF0pOzA8cy5wcmVJbml0Lmxlbmd0aDspcy5wcmVJbml0LnBvcCgpKCk7cmV0dXJuIGd0KCksZS5yZWFkeX0pO2UuZXhwb3J0cz1yfSw5MzI6KGUsdCxuKT0+e3ZhciBfc2NyaXB0RGlyLHI9KF9zY3JpcHREaXI9KF9zY3JpcHREaXI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMCl8fFwiL2luZGV4LmpzXCIsZnVuY3Rpb24oZSl7dmFyIHQscixvO2U9ZXx8e30sdHx8KHQ9dm9pZCAwIT09ZT9lOnt9KSx0LnJlYWR5PW5ldyBQcm9taXNlKChmdW5jdGlvbihlLHQpe3I9ZSxvPXR9KSk7dmFyIGksYSxzLHUsbCxjLHA9T2JqZWN0LmFzc2lnbih7fSx0KSxkPVwiLi90aGlzLnByb2dyYW1cIixmPShlLHQpPT57dGhyb3cgdH0saD1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93LGc9XCJmdW5jdGlvblwiPT10eXBlb2YgaW1wb3J0U2NyaXB0cyxtPVwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzJiZcIm9iamVjdFwiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyYmXCJzdHJpbmdcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSxiPVwiXCI7bT8oYj1nP24oOTA4KS5kaXJuYW1lKGIpK1wiL1wiOlwiLy9cIixjPSgpPT57bHx8KHU9bigxMzg0KSxsPW4oOTA4KSl9LGk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gYygpLGU9bC5ub3JtYWxpemUoZSksdS5yZWFkRmlsZVN5bmMoZSx0P3ZvaWQgMDpcInV0ZjhcIil9LHM9ZT0+KChlPWkoZSwhMCkpLmJ1ZmZlcnx8KGU9bmV3IFVpbnQ4QXJyYXkoZSkpLGUpLGE9KGUsdCxuKT0+e2MoKSxlPWwubm9ybWFsaXplKGUpLHUucmVhZEZpbGUoZSwoZnVuY3Rpb24oZSxyKXtlP24oZSk6dChyLmJ1ZmZlcil9KSl9LDE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKGQ9cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSxwcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIiwoZnVuY3Rpb24oZSl7aWYoIShlIGluc3RhbmNlb2YgcSkpdGhyb3cgZX0pKSxwcm9jZXNzLm9uKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsKGZ1bmN0aW9uKGUpe3Rocm93IGV9KSksZj0oZSx0KT0+e2lmKHYpdGhyb3cgcHJvY2Vzcy5leGl0Q29kZT1lLHQ7dCBpbnN0YW5jZW9mIHF8fF8oXCJleGl0aW5nIGR1ZSB0byBleGNlcHRpb246IFwiK3QpLHByb2Nlc3MuZXhpdChlKX0sdC5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifSk6KGh8fGcpJiYoZz9iPXNlbGYubG9jYXRpb24uaHJlZjpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihiPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxfc2NyaXB0RGlyJiYoYj1fc2NyaXB0RGlyKSxiPTAhPT1iLmluZGV4T2YoXCJibG9iOlwiKT9iLnN1YnN0cigwLGIucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIixpPWU9Pnt2YXIgdD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHQub3BlbihcIkdFVFwiLGUsITEpLHQuc2VuZChudWxsKSx0LnJlc3BvbnNlVGV4dH0sZyYmKHM9ZT0+e3ZhciB0PW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gdC5vcGVuKFwiR0VUXCIsZSwhMSksdC5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLHQuc2VuZChudWxsKSxuZXcgVWludDhBcnJheSh0LnJlc3BvbnNlKX0pLGE9KGUsdCxuKT0+e3ZhciByPW5ldyBYTUxIdHRwUmVxdWVzdDtyLm9wZW4oXCJHRVRcIixlLCEwKSxyLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsci5vbmxvYWQ9KCk9PnsyMDA9PXIuc3RhdHVzfHwwPT1yLnN0YXR1cyYmci5yZXNwb25zZT90KHIucmVzcG9uc2UpOm4oKX0sci5vbmVycm9yPW4sci5zZW5kKG51bGwpfSk7dmFyIHksdz10LnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLF89dC5wcmludEVycnx8Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbih0LHApLHA9bnVsbCx0LnRoaXNQcm9ncmFtJiYoZD10LnRoaXNQcm9ncmFtKSx0LnF1aXQmJihmPXQucXVpdCksdC53YXNtQmluYXJ5JiYoeT10Lndhc21CaW5hcnkpO3ZhciB2PXQubm9FeGl0UnVudGltZXx8ITA7XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZWKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgeCxULFMsTyxBLEUsST0hMSwkPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMDtmdW5jdGlvbiBQKGUsdCxuKXt2YXIgcj0odD4+Pj0wKStuO2ZvcihuPXQ7ZVtuXSYmIShuPj1yKTspKytuO2lmKDE2PG4tdCYmZS5idWZmZXImJiQpcmV0dXJuICQuZGVjb2RlKGUuc3ViYXJyYXkodCxuKSk7Zm9yKHI9XCJcIjt0PG47KXt2YXIgbz1lW3QrK107aWYoMTI4Jm8pe3ZhciBpPTYzJmVbdCsrXTtpZigxOTI9PSgyMjQmbykpcis9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmbyk8PDZ8aSk7ZWxzZXt2YXIgYT02MyZlW3QrK107NjU1MzY+KG89MjI0PT0oMjQwJm8pPygxNSZvKTw8MTJ8aTw8NnxhOig3Jm8pPDwxOHxpPDwxMnxhPDw2fDYzJmVbdCsrXSk/cis9U3RyaW5nLmZyb21DaGFyQ29kZShvKTooby09NjU1MzYscis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxvPj4xMCw1NjMyMHwxMDIzJm8pKX19ZWxzZSByKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pfXJldHVybiByfWZ1bmN0aW9uIEQoZSx0KXtyZXR1cm4oZT4+Pj0wKT9QKE8sZSx0KTpcIlwifWZ1bmN0aW9uIGsoZSx0LG4scil7aWYoISgwPHIpKXJldHVybiAwO3ZhciBvPW4+Pj49MDtyPW4rci0xO2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7KytpKXt2YXIgYT1lLmNoYXJDb2RlQXQoaSk7aWYoNTUyOTY8PWEmJjU3MzQzPj1hJiYoYT02NTUzNisoKDEwMjMmYSk8PDEwKXwxMDIzJmUuY2hhckNvZGVBdCgrK2kpKSwxMjc+PWEpe2lmKG4+PXIpYnJlYWs7dFtuKys+Pj4wXT1hfWVsc2V7aWYoMjA0Nz49YSl7aWYobisxPj1yKWJyZWFrO3RbbisrPj4+MF09MTkyfGE+PjZ9ZWxzZXtpZig2NTUzNT49YSl7aWYobisyPj1yKWJyZWFrO3RbbisrPj4+MF09MjI0fGE+PjEyfWVsc2V7aWYobiszPj1yKWJyZWFrO3RbbisrPj4+MF09MjQwfGE+PjE4LHRbbisrPj4+MF09MTI4fGE+PjEyJjYzfXRbbisrPj4+MF09MTI4fGE+PjYmNjN9dFtuKys+Pj4wXT0xMjh8NjMmYX19cmV0dXJuIHRbbj4+PjBdPTAsbi1vfWZ1bmN0aW9uIEMoZSl7Zm9yKHZhciB0PTAsbj0wO248ZS5sZW5ndGg7KytuKXt2YXIgcj1lLmNoYXJDb2RlQXQobik7MTI3Pj1yP3QrKzoyMDQ3Pj1yP3QrPTI6NTUyOTY8PXImJjU3MzQzPj1yPyh0Kz00LCsrbik6dCs9M31yZXR1cm4gdH1mdW5jdGlvbiBSKCl7dmFyIGU9eC5idWZmZXI7VD1lLHQuSEVBUDg9Uz1uZXcgSW50OEFycmF5KGUpLHQuSEVBUDE2PW5ldyBJbnQxNkFycmF5KGUpLHQuSEVBUDMyPUE9bmV3IEludDMyQXJyYXkoZSksdC5IRUFQVTg9Tz1uZXcgVWludDhBcnJheShlKSx0LkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KGUpLHQuSEVBUFUzMj1FPW5ldyBVaW50MzJBcnJheShlKSx0LkhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheShlKSx0LkhFQVBGNjQ9bmV3IEZsb2F0NjRBcnJheShlKX12YXIgTT1bXSxOPVtdLEY9W107ZnVuY3Rpb24gTCgpe3ZhciBlPXQucHJlUnVuLnNoaWZ0KCk7TS51bnNoaWZ0KGUpfXZhciBqLFU9MCxCPW51bGwsRz1udWxsO2Z1bmN0aW9uIFYoZSl7dGhyb3cgdC5vbkFib3J0JiZ0Lm9uQWJvcnQoZSksXyhlPVwiQWJvcnRlZChcIitlK1wiKVwiKSxJPSEwLGU9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihlK1wiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiKSxvKGUpLGV9ZnVuY3Rpb24geigpe3JldHVybiBqLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpfWlmKGo9XCJvcnQtd2FzbS53YXNtXCIsIXooKSl7dmFyIEg9ajtqPXQubG9jYXRlRmlsZT90LmxvY2F0ZUZpbGUoSCxiKTpiK0h9ZnVuY3Rpb24gVygpe3ZhciBlPWo7dHJ5e2lmKGU9PWomJnkpcmV0dXJuIG5ldyBVaW50OEFycmF5KHkpO2lmKHMpcmV0dXJuIHMoZSk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9Y2F0Y2goZSl7VihlKX19ZnVuY3Rpb24gcShlKXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPVwiUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdChcIitlK1wiKVwiLHRoaXMuc3RhdHVzPWV9ZnVuY3Rpb24gSyhlKXtmb3IoOzA8ZS5sZW5ndGg7KWUuc2hpZnQoKSh0KX1mdW5jdGlvbiBYKGUpe3RoaXMuc2E9ZS0yNCx0aGlzLklhPWZ1bmN0aW9uKGUpe0VbdGhpcy5zYSs0Pj4yPj4+MF09ZX0sdGhpcy5CYT1mdW5jdGlvbihlKXtFW3RoaXMuc2ErOD4+Mj4+PjBdPWV9LHRoaXMuR2E9ZnVuY3Rpb24oKXtBW3RoaXMuc2E+PjI+Pj4wXT0wfSx0aGlzLkFhPWZ1bmN0aW9uKCl7U1t0aGlzLnNhKzEyPj4wPj4+MF09MH0sdGhpcy5IYT1mdW5jdGlvbigpe1NbdGhpcy5zYSsxMz4+MD4+PjBdPTB9LHRoaXMueWE9ZnVuY3Rpb24oZSx0KXt0aGlzLnphKCksdGhpcy5JYShlKSx0aGlzLkJhKHQpLHRoaXMuR2EoKSx0aGlzLkFhKCksdGhpcy5IYSgpfSx0aGlzLnphPWZ1bmN0aW9uKCl7RVt0aGlzLnNhKzE2Pj4yPj4+MF09MH19ZnVuY3Rpb24gWShlKXt2YXIgdD1DKGUpKzEsbj1hZSh0KTtyZXR1cm4gbiYmayhlLFMsbix0KSxufXZhciBKPXt9O2Z1bmN0aW9uIFooKXtpZighUSl7dmFyIGUsdD17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzooXCJvYmplY3RcIj09dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzpkfHxcIi4vdGhpcy5wcm9ncmFtXCJ9O2ZvcihlIGluIEopdm9pZCAwPT09SltlXT9kZWxldGUgdFtlXTp0W2VdPUpbZV07dmFyIG49W107Zm9yKGUgaW4gdCluLnB1c2goZStcIj1cIit0W2VdKTtRPW59cmV0dXJuIFF9dmFyIFEsZWU9W251bGwsW10sW11dO2Z1bmN0aW9uIHRlKGUpe3JldHVybiAwPT1lJTQmJigwIT1lJTEwMHx8MD09ZSU0MDApfXZhciBuZT1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLHJlPVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24gb2UoZSx0LG4scil7ZnVuY3Rpb24gbyhlLHQsbil7Zm9yKGU9XCJudW1iZXJcIj09dHlwZW9mIGU/ZS50b1N0cmluZygpOmV8fFwiXCI7ZS5sZW5ndGg8dDspZT1uWzBdK2U7cmV0dXJuIGV9ZnVuY3Rpb24gaShlLHQpe3JldHVybiBvKGUsdCxcIjBcIil9ZnVuY3Rpb24gYShlLHQpe2Z1bmN0aW9uIG4oZSl7cmV0dXJuIDA+ZT8tMTowPGU/MTowfXZhciByO3JldHVybiAwPT09KHI9bihlLmdldEZ1bGxZZWFyKCktdC5nZXRGdWxsWWVhcigpKSkmJjA9PT0ocj1uKGUuZ2V0TW9udGgoKS10LmdldE1vbnRoKCkpKSYmKHI9bihlLmdldERhdGUoKS10LmdldERhdGUoKSkpLHJ9ZnVuY3Rpb24gcyhlKXtzd2l0Y2goZS5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiBlO2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiB1KGUpe3ZhciB0PWUucWE7Zm9yKGU9bmV3IERhdGUobmV3IERhdGUoZS5yYSsxOTAwLDAsMSkuZ2V0VGltZSgpKTswPHQ7KXt2YXIgbj1lLmdldE1vbnRoKCkscj0odGUoZS5nZXRGdWxsWWVhcigpKT9uZTpyZSlbbl07aWYoISh0PnItZS5nZXREYXRlKCkpKXtlLnNldERhdGUoZS5nZXREYXRlKCkrdCk7YnJlYWt9dC09ci1lLmdldERhdGUoKSsxLGUuc2V0RGF0ZSgxKSwxMT5uP2Uuc2V0TW9udGgobisxKTooZS5zZXRNb250aCgwKSxlLnNldEZ1bGxZZWFyKGUuZ2V0RnVsbFllYXIoKSsxKSl9cmV0dXJuIG49bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpKzEsMCw0KSx0PXMobmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsNCkpLG49cyhuKSwwPj1hKHQsZSk/MD49YShuLGUpP2UuZ2V0RnVsbFllYXIoKSsxOmUuZ2V0RnVsbFllYXIoKTplLmdldEZ1bGxZZWFyKCktMX12YXIgbD1BW3IrNDA+PjI+Pj4wXTtmb3IodmFyIGMgaW4gcj17RWE6QVtyPj4yPj4+MF0sRGE6QVtyKzQ+PjI+Pj4wXSx0YTpBW3IrOD4+Mj4+PjBdLHZhOkFbcisxMj4+Mj4+PjBdLHVhOkFbcisxNj4+Mj4+PjBdLHJhOkFbcisyMD4+Mj4+PjBdLGxhOkFbcisyND4+Mj4+PjBdLHFhOkFbcisyOD4+Mj4+PjBdLEphOkFbciszMj4+Mj4+PjBdLENhOkFbciszNj4+Mj4+PjBdLEZhOmw/RChsKTpcIlwifSxuPUQobiksbD17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9KW49bi5yZXBsYWNlKG5ldyBSZWdFeHAoYyxcImdcIiksbFtjXSk7dmFyIHA9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxkPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtmb3IoYyBpbiBsPXtcIiVhXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHBbZS5sYV0uc3Vic3RyaW5nKDAsMyl9LFwiJUFcIjpmdW5jdGlvbihlKXtyZXR1cm4gcFtlLmxhXX0sXCIlYlwiOmZ1bmN0aW9uKGUpe3JldHVybiBkW2UudWFdLnN1YnN0cmluZygwLDMpfSxcIiVCXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGRbZS51YV19LFwiJUNcIjpmdW5jdGlvbihlKXtyZXR1cm4gaSgoZS5yYSsxOTAwKS8xMDB8MCwyKX0sXCIlZFwiOmZ1bmN0aW9uKGUpe3JldHVybiBpKGUudmEsMil9LFwiJWVcIjpmdW5jdGlvbihlKXtyZXR1cm4gbyhlLnZhLDIsXCIgXCIpfSxcIiVnXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHUoZSkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJUdcIjpmdW5jdGlvbihlKXtyZXR1cm4gdShlKX0sXCIlSFwiOmZ1bmN0aW9uKGUpe3JldHVybiBpKGUudGEsMil9LFwiJUlcIjpmdW5jdGlvbihlKXtyZXR1cm4gMD09KGU9ZS50YSk/ZT0xMjoxMjxlJiYoZS09MTIpLGkoZSwyKX0sXCIlalwiOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wLG49MDtuPD1lLnVhLTE7dCs9KHRlKGUucmErMTkwMCk/bmU6cmUpW24rK10pO3JldHVybiBpKGUudmErdCwzKX0sXCIlbVwiOmZ1bmN0aW9uKGUpe3JldHVybiBpKGUudWErMSwyKX0sXCIlTVwiOmZ1bmN0aW9uKGUpe3JldHVybiBpKGUuRGEsMil9LFwiJW5cIjpmdW5jdGlvbigpe3JldHVyblwiXFxuXCJ9LFwiJXBcIjpmdW5jdGlvbihlKXtyZXR1cm4gMDw9ZS50YSYmMTI+ZS50YT9cIkFNXCI6XCJQTVwifSxcIiVTXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGkoZS5FYSwyKX0sXCIldFwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXHRcIn0sXCIldVwiOmZ1bmN0aW9uKGUpe3JldHVybiBlLmxhfHw3fSxcIiVVXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGkoTWF0aC5mbG9vcigoZS5xYSs3LWUubGEpLzcpLDIpfSxcIiVWXCI6ZnVuY3Rpb24oZSl7dmFyIHQ9TWF0aC5mbG9vcigoZS5xYSs3LShlLmxhKzYpJTcpLzcpO2lmKDI+PShlLmxhKzM3MS1lLnFhLTIpJTcmJnQrKyx0KTUzPT10JiYoND09KG49KGUubGErMzcxLWUucWEpJTcpfHwzPT1uJiZ0ZShlLnJhKXx8KHQ9MSkpO2Vsc2V7dD01Mjt2YXIgbj0oZS5sYSs3LWUucWEtMSklNzsoND09bnx8NT09biYmdGUoZS5yYSU0MDAtMSkpJiZ0Kyt9cmV0dXJuIGkodCwyKX0sXCIld1wiOmZ1bmN0aW9uKGUpe3JldHVybiBlLmxhfSxcIiVXXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGkoTWF0aC5mbG9vcigoZS5xYSs3LShlLmxhKzYpJTcpLzcpLDIpfSxcIiV5XCI6ZnVuY3Rpb24oZSl7cmV0dXJuKGUucmErMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJVlcIjpmdW5jdGlvbihlKXtyZXR1cm4gZS5yYSsxOTAwfSxcIiV6XCI6ZnVuY3Rpb24oZSl7dmFyIHQ9MDw9KGU9ZS5DYSk7cmV0dXJuIGU9TWF0aC5hYnMoZSkvNjAsKHQ/XCIrXCI6XCItXCIpK1N0cmluZyhcIjAwMDBcIisoZS82MCoxMDArZSU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOmZ1bmN0aW9uKGUpe3JldHVybiBlLkZhfSxcIiUlXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIiVcIn19LG49bi5yZXBsYWNlKC8lJS9nLFwiXFwwXFwwXCIpLGwpbi5pbmNsdWRlcyhjKSYmKG49bi5yZXBsYWNlKG5ldyBSZWdFeHAoYyxcImdcIiksbFtjXShyKSkpO3JldHVybiBjPWZ1bmN0aW9uKGUpe3ZhciB0PUFycmF5KEMoZSkrMSk7cmV0dXJuIGsoZSx0LDAsdC5sZW5ndGgpLHR9KG49bi5yZXBsYWNlKC9cXDBcXDAvZyxcIiVcIikpLGMubGVuZ3RoPnQ/MDooUy5zZXQoYyxlPj4+MCksYy5sZW5ndGgtMSl9dmFyIGllPXthOmZ1bmN0aW9uKGUpe3JldHVybiBhZShlKzI0KSsyNH0sYjpmdW5jdGlvbihlLHQsbil7dGhyb3cgbmV3IFgoZSkueWEodCxuKSxlfSxnOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LEk6ZnVuY3Rpb24oKXt9LHc6ZnVuY3Rpb24oKXt9LHk6ZnVuY3Rpb24oKXt9LEs6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sRzpmdW5jdGlvbigpe30sQzpmdW5jdGlvbigpe30sRjpmdW5jdGlvbigpe30sazpmdW5jdGlvbigpe30seDpmdW5jdGlvbigpe30sdTpmdW5jdGlvbigpe30sSDpmdW5jdGlvbigpe30sdjpmdW5jdGlvbigpe30sbjpmdW5jdGlvbigpe30scDpmdW5jdGlvbigpe1YoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0sbzpmdW5jdGlvbigpe1YoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0sbDpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfSxMOmZ1bmN0aW9uKCl7cmV0dXJuITB9LE06ZnVuY3Rpb24oZSx0KXtlPW5ldyBEYXRlKDFlMyooRVtlPj4+Ml0rNDI5NDk2NzI5NipBW2UrND4+PjJdKSksQVt0Pj4yPj4+MF09ZS5nZXRVVENTZWNvbmRzKCksQVt0KzQ+PjI+Pj4wXT1lLmdldFVUQ01pbnV0ZXMoKSxBW3QrOD4+Mj4+PjBdPWUuZ2V0VVRDSG91cnMoKSxBW3QrMTI+PjI+Pj4wXT1lLmdldFVUQ0RhdGUoKSxBW3QrMTY+PjI+Pj4wXT1lLmdldFVUQ01vbnRoKCksQVt0KzIwPj4yPj4+MF09ZS5nZXRVVENGdWxsWWVhcigpLTE5MDAsQVt0KzI0Pj4yPj4+MF09ZS5nZXRVVENEYXkoKSxBW3QrMjg+PjI+Pj4wXT0oZS5nZXRUaW1lKCktRGF0ZS5VVEMoZS5nZXRVVENGdWxsWWVhcigpLDAsMSwwLDAsMCwwKSkvODY0ZTV8MH0sTjpmdW5jdGlvbihlLHQpe2U9bmV3IERhdGUoMWUzKihFW2U+Pj4yXSs0Mjk0OTY3Mjk2KkFbZSs0Pj4+Ml0pKSxBW3Q+PjI+Pj4wXT1lLmdldFNlY29uZHMoKSxBW3QrND4+Mj4+PjBdPWUuZ2V0TWludXRlcygpLEFbdCs4Pj4yPj4+MF09ZS5nZXRIb3VycygpLEFbdCsxMj4+Mj4+PjBdPWUuZ2V0RGF0ZSgpLEFbdCsxNj4+Mj4+PjBdPWUuZ2V0TW9udGgoKSxBW3QrMjA+PjI+Pj4wXT1lLmdldEZ1bGxZZWFyKCktMTkwMCxBW3QrMjQ+PjI+Pj4wXT1lLmdldERheSgpO3ZhciBuPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDEpO0FbdCsyOD4+Mj4+PjBdPShlLmdldFRpbWUoKS1uLmdldFRpbWUoKSkvODY0ZTV8MCxBW3QrMzY+PjI+Pj4wXT0tNjAqZS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciByPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7bj1uLmdldFRpbWV6b25lT2Zmc2V0KCksQVt0KzMyPj4yPj4+MF09MHwociE9biYmZS5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbihuLHIpKX0sTzpmdW5jdGlvbihlKXt2YXIgdD1uZXcgRGF0ZShBW2UrMjA+PjI+Pj4wXSsxOTAwLEFbZSsxNj4+Mj4+PjBdLEFbZSsxMj4+Mj4+PjBdLEFbZSs4Pj4yPj4+MF0sQVtlKzQ+PjI+Pj4wXSxBW2U+PjI+Pj4wXSwwKSxuPUFbZSszMj4+Mj4+PjBdLHI9dC5nZXRUaW1lem9uZU9mZnNldCgpLG89bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSksaT1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLGE9by5nZXRUaW1lem9uZU9mZnNldCgpLHM9TWF0aC5taW4oYSxpKTtyZXR1cm4gMD5uP0FbZSszMj4+Mj4+PjBdPU51bWJlcihpIT1hJiZzPT1yKTowPG4hPShzPT1yKSYmKGk9TWF0aC5tYXgoYSxpKSx0LnNldFRpbWUodC5nZXRUaW1lKCkrNmU0KigoMDxuP3M6aSktcikpKSxBW2UrMjQ+PjI+Pj4wXT10LmdldERheSgpLEFbZSsyOD4+Mj4+PjBdPSh0LmdldFRpbWUoKS1vLmdldFRpbWUoKSkvODY0ZTV8MCxBW2U+PjI+Pj4wXT10LmdldFNlY29uZHMoKSxBW2UrND4+Mj4+PjBdPXQuZ2V0TWludXRlcygpLEFbZSs4Pj4yPj4+MF09dC5nZXRIb3VycygpLEFbZSsxMj4+Mj4+PjBdPXQuZ2V0RGF0ZSgpLEFbZSsxNj4+Mj4+PjBdPXQuZ2V0TW9udGgoKSx0LmdldFRpbWUoKS8xZTN8MH0sejpmdW5jdGlvbigpe3JldHVybi01Mn0sQjpmdW5jdGlvbigpe30sbTpmdW5jdGlvbiBlKHQsbixyKXtlLnhhfHwoZS54YT0hMCxmdW5jdGlvbihlLHQsbil7ZnVuY3Rpb24gcihlKXtyZXR1cm4oZT1lLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLykpP2VbMV06XCJHTVRcIn12YXIgbz0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCksaT1uZXcgRGF0ZShvLDAsMSksYT1uZXcgRGF0ZShvLDYsMSk7bz1pLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHM9YS5nZXRUaW1lem9uZU9mZnNldCgpO0FbZT4+Mj4+PjBdPTYwKk1hdGgubWF4KG8scyksQVt0Pj4yPj4+MF09TnVtYmVyKG8hPXMpLGU9cihpKSx0PXIoYSksZT1ZKGUpLHQ9WSh0KSxzPG8/KEVbbj4+Mj4+PjBdPWUsRVtuKzQ+PjI+Pj4wXT10KTooRVtuPj4yPj4+MF09dCxFW24rND4+Mj4+PjBdPWUpfSh0LG4scikpfSxkOmZ1bmN0aW9uKCl7VihcIlwiKX0sdDpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTAxNzYwfSxoOm0/KCk9Pnt2YXIgZT1wcm9jZXNzLmhydGltZSgpO3JldHVybiAxZTMqZVswXStlWzFdLzFlNn06KCk9PnBlcmZvcm1hbmNlLm5vdygpLEo6ZnVuY3Rpb24oZSx0LG4pe08uY29weVdpdGhpbihlPj4+MCx0Pj4+MCx0K24+Pj4wKX0sZjpmdW5jdGlvbihlKXt2YXIgdD1PLmxlbmd0aDtpZig0Mjk0OTAxNzYwPChlPj4+PTApKXJldHVybiExO2Zvcih2YXIgbj0xOzQ+PW47bio9Mil7dmFyIHI9dCooMSsuMi9uKTtyPU1hdGgubWluKHIsZSsxMDA2NjMyOTYpO3ZhciBvPU1hdGg7cj1NYXRoLm1heChlLHIpLG89by5taW4uY2FsbChvLDQyOTQ5MDE3NjAscisoNjU1MzYtciU2NTUzNiklNjU1MzYpO2U6e3RyeXt4Lmdyb3coby1ULmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNiksUigpO3ZhciBpPTE7YnJlYWsgZX1jYXRjaChlKXt9aT12b2lkIDB9aWYoaSlyZXR1cm4hMH1yZXR1cm4hMX0sRDpmdW5jdGlvbihlLHQpe3ZhciBuPTA7cmV0dXJuIFooKS5mb3JFYWNoKChmdW5jdGlvbihyLG8pe3ZhciBpPXQrbjtmb3Iobz1FW2UrNCpvPj4yPj4+MF09aSxpPTA7aTxyLmxlbmd0aDsrK2kpU1tvKys+PjA+Pj4wXT1yLmNoYXJDb2RlQXQoaSk7U1tvPj4wPj4+MF09MCxuKz1yLmxlbmd0aCsxfSkpLDB9LEU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1aKCk7RVtlPj4yPj4+MF09bi5sZW5ndGg7dmFyIHI9MDtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbihlKXtyKz1lLmxlbmd0aCsxfSkpLEVbdD4+Mj4+PjBdPXIsMH0scjpmdW5jdGlvbihlKXt2fHwodC5vbkV4aXQmJnQub25FeGl0KGUpLEk9ITApLGYoZSxuZXcgcShlKSl9LGU6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LGo6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LHE6ZnVuY3Rpb24oKXtyZXR1cm4gNzB9LGk6ZnVuY3Rpb24oZSx0LG4scil7Zm9yKHZhciBvPTAsaT0wO2k8bjtpKyspe3ZhciBhPUVbdD4+Mj4+PjBdLHM9RVt0KzQ+PjI+Pj4wXTt0Kz04O2Zvcih2YXIgdT0wO3U8czt1Kyspe3ZhciBsPU9bYSt1Pj4+MF0sYz1lZVtlXTswPT09bHx8MTA9PT1sPygoMT09PWU/dzpfKShQKGMsMCkpLGMubGVuZ3RoPTApOmMucHVzaChsKX1vKz1zfXJldHVybiBFW3I+PjI+Pj4wXT1vLDB9LHM6ZnVuY3Rpb24gZSh0LHIpe2Uud2F8fChlLndhPWZ1bmN0aW9uKCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGNyeXB0byYmXCJmdW5jdGlvblwiPT10eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyl7dmFyIGU9bmV3IFVpbnQ4QXJyYXkoMSk7cmV0dXJuKCk9PihjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGUpLGVbMF0pfWlmKG0pdHJ5e3ZhciB0PW4oNzYwKTtyZXR1cm4oKT0+dC5yYW5kb21CeXRlcygxKVswXX1jYXRjaChlKXt9cmV0dXJuKCk9PlYoXCJyYW5kb21EZXZpY2VcIil9KCkpO2Zvcih2YXIgbz0wO288cjtvKyspU1t0K28+PjA+Pj4wXT1lLndhKCk7cmV0dXJuIDB9LEE6b2UsYzpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gb2UoZSx0LG4scil9fTshZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3QuYXNtPWUuZXhwb3J0cyx4PXQuYXNtLlAsUigpLE4udW5zaGlmdCh0LmFzbS5RKSxVLS0sdC5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZ0Lm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoVSksMD09VSYmKG51bGwhPT1CJiYoY2xlYXJJbnRlcnZhbChCKSxCPW51bGwpLEcmJihlPUcsRz1udWxsLGUoKSkpfWZ1bmN0aW9uIG4odCl7ZSh0Lmluc3RhbmNlKX1mdW5jdGlvbiByKGUpe3JldHVybiBmdW5jdGlvbigpe2lmKCF5JiYoaHx8Zykpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGZldGNoJiYhai5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSlyZXR1cm4gZmV0Y2goaix7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24oZSl7aWYoIWUub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiK2orXCInXCI7cmV0dXJuIGUuYXJyYXlCdWZmZXIoKX0pKS5jYXRjaCgoZnVuY3Rpb24oKXtyZXR1cm4gVygpfSkpO2lmKGEpcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihlLHQpe2EoaiwoZnVuY3Rpb24odCl7ZShuZXcgVWludDhBcnJheSh0KSl9KSx0KX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gVygpfSkpfSgpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShlLGkpfSkpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBlfSkpLnRoZW4oZSwoZnVuY3Rpb24oZSl7XyhcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK2UpLFYoZSl9KSl9dmFyIGk9e2E6aWV9O2lmKFUrKyx0Lm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJnQubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhVKSx0Lmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIHQuaW5zdGFudGlhdGVXYXNtKGksZSl9Y2F0Y2goZSl7cmV0dXJuIF8oXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIitlKSwhMX0oeXx8XCJmdW5jdGlvblwiIT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fHooKXx8ai5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8bXx8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/cihuKTpmZXRjaChqLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoZSxpKS50aGVuKG4sKGZ1bmN0aW9uKGUpe3JldHVybiBfKFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK2UpLF8oXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxyKG4pfSkpfSkpKS5jYXRjaChvKX0oKSx0Ll9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybih0Ll9fX3dhc21fY2FsbF9jdG9ycz10LmFzbS5RKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEluaXQ9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0SW5pdD10LmFzbS5SKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPXQuYXNtLlMpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9dC5hc20uVCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PXQuYXNtLlUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz10LmFzbS5WKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydENyZWF0ZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0Q3JlYXRlU2Vzc2lvbj10LmFzbS5XKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydFJlbGVhc2VTZXNzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydFJlbGVhc2VTZXNzaW9uPXQuYXNtLlgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0R2V0SW5wdXRDb3VudD1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRHZXRJbnB1dENvdW50PXQuYXNtLlkpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0R2V0T3V0cHV0Q291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0R2V0T3V0cHV0Q291bnQ9dC5hc20uWikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRHZXRJbnB1dE5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0R2V0SW5wdXROYW1lPXQuYXNtLl8pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0R2V0T3V0cHV0TmFtZT1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRHZXRPdXRwdXROYW1lPXQuYXNtLiQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0RnJlZT1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRGcmVlPXQuYXNtLmFhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydENyZWF0ZVRlbnNvcj1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRDcmVhdGVUZW5zb3I9dC5hc20uYmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0R2V0VGVuc29yRGF0YT1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRHZXRUZW5zb3JEYXRhPXQuYXNtLmNhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydFJlbGVhc2VUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0UmVsZWFzZVRlbnNvcj10LmFzbS5kYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRDcmVhdGVSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydENyZWF0ZVJ1bk9wdGlvbnM9dC5hc20uZWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0QWRkUnVuQ29uZmlnRW50cnk9dC5hc20uZmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9dC5hc20uZ2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0UnVuPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydFJ1bj10LmFzbS5oYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRFbmRQcm9maWxpbmc9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0RW5kUHJvZmlsaW5nPXQuYXNtLmlhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBhZT10Ll9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oYWU9dC5fbWFsbG9jPXQuYXNtLmphKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3QuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4odC5fZnJlZT10LmFzbS5rYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgc2UsdWU9dC5zdGFja1NhdmU9ZnVuY3Rpb24oKXtyZXR1cm4odWU9dC5zdGFja1NhdmU9dC5hc20ubWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbGU9dC5zdGFja1Jlc3RvcmU9ZnVuY3Rpb24oKXtyZXR1cm4obGU9dC5zdGFja1Jlc3RvcmU9dC5hc20ubmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sY2U9dC5zdGFja0FsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKGNlPXQuc3RhY2tBbGxvYz10LmFzbS5vYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiBwZSgpe2Z1bmN0aW9uIGUoKXtpZighc2UmJihzZT0hMCx0LmNhbGxlZFJ1bj0hMCwhSSkpe2lmKEsoTikscih0KSx0Lm9uUnVudGltZUluaXRpYWxpemVkJiZ0Lm9uUnVudGltZUluaXRpYWxpemVkKCksdC5wb3N0UnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnBvc3RSdW4mJih0LnBvc3RSdW49W3QucG9zdFJ1bl0pO3QucG9zdFJ1bi5sZW5ndGg7KXt2YXIgZT10LnBvc3RSdW4uc2hpZnQoKTtGLnVuc2hpZnQoZSl9SyhGKX19aWYoISgwPFUpKXtpZih0LnByZVJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgdC5wcmVSdW4mJih0LnByZVJ1bj1bdC5wcmVSdW5dKTt0LnByZVJ1bi5sZW5ndGg7KUwoKTtLKE0pLDA8VXx8KHQuc2V0U3RhdHVzPyh0LnNldFN0YXR1cyhcIlJ1bm5pbmcuLi5cIiksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KChmdW5jdGlvbigpe3Quc2V0U3RhdHVzKFwiXCIpfSksMSksZSgpfSksMSkpOmUoKSl9fWlmKHQuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1mdW5jdGlvbigpe3JldHVybih0Ll9fX2N4YV9pc19wb2ludGVyX3R5cGU9dC5hc20ucGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5VVEY4VG9TdHJpbmc9RCx0LnN0cmluZ1RvVVRGOD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGsoZSxPLHQsbil9LHQubGVuZ3RoQnl0ZXNVVEY4PUMsdC5zdGFja1NhdmU9dWUsdC5zdGFja1Jlc3RvcmU9bGUsdC5zdGFja0FsbG9jPWNlLEc9ZnVuY3Rpb24gZSgpe3NlfHxwZSgpLHNlfHwoRz1lKX0sdC5wcmVJbml0KWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnByZUluaXQmJih0LnByZUluaXQ9W3QucHJlSW5pdF0pOzA8dC5wcmVJbml0Lmxlbmd0aDspdC5wcmVJbml0LnBvcCgpKCk7cmV0dXJuIHBlKCksZS5yZWFkeX0pO2UuZXhwb3J0cz1yfSw0NTM3OmU9PntcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSkscj0wLG89MixpPSEwO288YXJndW1lbnRzLmxlbmd0aDspbltyKytdPWFyZ3VtZW50c1tvKytdO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24obyxhKXtuW3JdPWZ1bmN0aW9uKGUpe2lmKGkpaWYoaT0hMSxlKWEoZSk7ZWxzZXtmb3IodmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSksbj0wO248dC5sZW5ndGg7KXRbbisrXT1hcmd1bWVudHNbbl07by5hcHBseShudWxsLHQpfX07dHJ5e2UuYXBwbHkodHx8bnVsbCxuKX1jYXRjaChlKXtpJiYoaT0hMSxhKGUpKX19KSl9fSw3NDE5OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dDtuLmxlbmd0aD1mdW5jdGlvbihlKXt2YXIgdD1lLmxlbmd0aDtpZighdClyZXR1cm4gMDtmb3IodmFyIG49MDstLXQlND4xJiZcIj1cIj09PWUuY2hhckF0KHQpOykrK247cmV0dXJuIE1hdGguY2VpbCgzKmUubGVuZ3RoKS80LW59O2Zvcih2YXIgcj1uZXcgQXJyYXkoNjQpLG89bmV3IEFycmF5KDEyMyksaT0wO2k8NjQ7KW9bcltpXT1pPDI2P2krNjU6aTw1Mj9pKzcxOmk8NjI/aS00OmktNTl8NDNdPWkrKztuLmVuY29kZT1mdW5jdGlvbihlLHQsbil7Zm9yKHZhciBvLGk9bnVsbCxhPVtdLHM9MCx1PTA7dDxuOyl7dmFyIGw9ZVt0KytdO3N3aXRjaCh1KXtjYXNlIDA6YVtzKytdPXJbbD4+Ml0sbz0oMyZsKTw8NCx1PTE7YnJlYWs7Y2FzZSAxOmFbcysrXT1yW298bD4+NF0sbz0oMTUmbCk8PDIsdT0yO2JyZWFrO2Nhc2UgMjphW3MrK109cltvfGw+PjZdLGFbcysrXT1yWzYzJmxdLHU9MH1zPjgxOTEmJigoaXx8KGk9W10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGEpKSxzPTApfXJldHVybiB1JiYoYVtzKytdPXJbb10sYVtzKytdPTYxLDE9PT11JiYoYVtzKytdPTYxKSksaT8ocyYmaS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGEuc2xpY2UoMCxzKSkpLGkuam9pbihcIlwiKSk6U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsYS5zbGljZSgwLHMpKX07dmFyIGE9XCJpbnZhbGlkIGVuY29kaW5nXCI7bi5kZWNvZGU9ZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgcixpPW4scz0wLHU9MDt1PGUubGVuZ3RoOyl7dmFyIGw9ZS5jaGFyQ29kZUF0KHUrKyk7aWYoNjE9PT1sJiZzPjEpYnJlYWs7aWYodm9pZCAwPT09KGw9b1tsXSkpdGhyb3cgRXJyb3IoYSk7c3dpdGNoKHMpe2Nhc2UgMDpyPWwscz0xO2JyZWFrO2Nhc2UgMTp0W24rK109cjw8MnwoNDgmbCk+PjQscj1sLHM9MjticmVhaztjYXNlIDI6dFtuKytdPSgxNSZyKTw8NHwoNjAmbCk+PjIscj1sLHM9MzticmVhaztjYXNlIDM6dFtuKytdPSgzJnIpPDw2fGwscz0wfX1pZigxPT09cyl0aHJvdyBFcnJvcihhKTtyZXR1cm4gbi1pfSxuLnRlc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvLnRlc3QoZSl9fSw5MjExOmU9PntcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KCl7dGhpcy5fbGlzdGVuZXJzPXt9fWUuZXhwb3J0cz10LHQucHJvdG90eXBlLm9uPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4odGhpcy5fbGlzdGVuZXJzW2VdfHwodGhpcy5fbGlzdGVuZXJzW2VdPVtdKSkucHVzaCh7Zm46dCxjdHg6bnx8dGhpc30pLHRoaXN9LHQucHJvdG90eXBlLm9mZj1mdW5jdGlvbihlLHQpe2lmKHZvaWQgMD09PWUpdGhpcy5fbGlzdGVuZXJzPXt9O2Vsc2UgaWYodm9pZCAwPT09dCl0aGlzLl9saXN0ZW5lcnNbZV09W107ZWxzZSBmb3IodmFyIG49dGhpcy5fbGlzdGVuZXJzW2VdLHI9MDtyPG4ubGVuZ3RoOyluW3JdLmZuPT09dD9uLnNwbGljZShyLDEpOisrcjtyZXR1cm4gdGhpc30sdC5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLl9saXN0ZW5lcnNbZV07aWYodCl7Zm9yKHZhciBuPVtdLHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7KW4ucHVzaChhcmd1bWVudHNbcisrXSk7Zm9yKHI9MDtyPHQubGVuZ3RoOyl0W3JdLmZuLmFwcGx5KHRbcisrXS5jdHgsbil9cmV0dXJuIHRoaXN9fSw5NDU6ZT0+e1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHQoZSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEZsb2F0MzJBcnJheT9mdW5jdGlvbigpe3ZhciB0PW5ldyBGbG9hdDMyQXJyYXkoWy0wXSksbj1uZXcgVWludDhBcnJheSh0LmJ1ZmZlcikscj0xMjg9PT1uWzNdO2Z1bmN0aW9uIG8oZSxyLG8pe3RbMF09ZSxyW29dPW5bMF0scltvKzFdPW5bMV0scltvKzJdPW5bMl0scltvKzNdPW5bM119ZnVuY3Rpb24gaShlLHIsbyl7dFswXT1lLHJbb109blszXSxyW28rMV09blsyXSxyW28rMl09blsxXSxyW28rM109blswXX1mdW5jdGlvbiBhKGUscil7cmV0dXJuIG5bMF09ZVtyXSxuWzFdPWVbcisxXSxuWzJdPWVbcisyXSxuWzNdPWVbciszXSx0WzBdfWZ1bmN0aW9uIHMoZSxyKXtyZXR1cm4gblszXT1lW3JdLG5bMl09ZVtyKzFdLG5bMV09ZVtyKzJdLG5bMF09ZVtyKzNdLHRbMF19ZS53cml0ZUZsb2F0TEU9cj9vOmksZS53cml0ZUZsb2F0QkU9cj9pOm8sZS5yZWFkRmxvYXRMRT1yP2E6cyxlLnJlYWRGbG9hdEJFPXI/czphfSgpOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLHQsbixyKXt2YXIgbz10PDA/MTowO2lmKG8mJih0PS10KSwwPT09dCllKDEvdD4wPzA6MjE0NzQ4MzY0OCxuLHIpO2Vsc2UgaWYoaXNOYU4odCkpZSgyMTQzMjg5MzQ0LG4scik7ZWxzZSBpZih0PjM0MDI4MjM0NjYzODUyODg2ZTIyKWUoKG88PDMxfDIxMzkwOTUwNDApPj4+MCxuLHIpO2Vsc2UgaWYodDwxMTc1NDk0MzUwODIyMjg3NWUtNTQpZSgobzw8MzF8TWF0aC5yb3VuZCh0LzE0MDEyOTg0NjQzMjQ4MTdlLTYwKSk+Pj4wLG4scik7ZWxzZXt2YXIgaT1NYXRoLmZsb29yKE1hdGgubG9nKHQpL01hdGguTE4yKTtlKChvPDwzMXxpKzEyNzw8MjN8ODM4ODYwNyZNYXRoLnJvdW5kKHQqTWF0aC5wb3coMiwtaSkqODM4ODYwOCkpPj4+MCxuLHIpfX1mdW5jdGlvbiBhKGUsdCxuKXt2YXIgcj1lKHQsbiksbz0yKihyPj4zMSkrMSxpPXI+Pj4yMyYyNTUsYT04Mzg4NjA3JnI7cmV0dXJuIDI1NT09PWk/YT9OYU46byooMS8wKTowPT09aT8xNDAxMjk4NDY0MzI0ODE3ZS02MCpvKmE6bypNYXRoLnBvdygyLGktMTUwKSooYSs4Mzg4NjA4KX1lLndyaXRlRmxvYXRMRT10LmJpbmQobnVsbCxuKSxlLndyaXRlRmxvYXRCRT10LmJpbmQobnVsbCxyKSxlLnJlYWRGbG9hdExFPWEuYmluZChudWxsLG8pLGUucmVhZEZsb2F0QkU9YS5iaW5kKG51bGwsaSl9KCksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEZsb2F0NjRBcnJheT9mdW5jdGlvbigpe3ZhciB0PW5ldyBGbG9hdDY0QXJyYXkoWy0wXSksbj1uZXcgVWludDhBcnJheSh0LmJ1ZmZlcikscj0xMjg9PT1uWzddO2Z1bmN0aW9uIG8oZSxyLG8pe3RbMF09ZSxyW29dPW5bMF0scltvKzFdPW5bMV0scltvKzJdPW5bMl0scltvKzNdPW5bM10scltvKzRdPW5bNF0scltvKzVdPW5bNV0scltvKzZdPW5bNl0scltvKzddPW5bN119ZnVuY3Rpb24gaShlLHIsbyl7dFswXT1lLHJbb109bls3XSxyW28rMV09bls2XSxyW28rMl09bls1XSxyW28rM109bls0XSxyW28rNF09blszXSxyW28rNV09blsyXSxyW28rNl09blsxXSxyW28rN109blswXX1mdW5jdGlvbiBhKGUscil7cmV0dXJuIG5bMF09ZVtyXSxuWzFdPWVbcisxXSxuWzJdPWVbcisyXSxuWzNdPWVbciszXSxuWzRdPWVbcis0XSxuWzVdPWVbcis1XSxuWzZdPWVbcis2XSxuWzddPWVbcis3XSx0WzBdfWZ1bmN0aW9uIHMoZSxyKXtyZXR1cm4gbls3XT1lW3JdLG5bNl09ZVtyKzFdLG5bNV09ZVtyKzJdLG5bNF09ZVtyKzNdLG5bM109ZVtyKzRdLG5bMl09ZVtyKzVdLG5bMV09ZVtyKzZdLG5bMF09ZVtyKzddLHRbMF19ZS53cml0ZURvdWJsZUxFPXI/bzppLGUud3JpdGVEb3VibGVCRT1yP2k6byxlLnJlYWREb3VibGVMRT1yP2E6cyxlLnJlYWREb3VibGVCRT1yP3M6YX0oKTpmdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSx0LG4scixvLGkpe3ZhciBhPXI8MD8xOjA7aWYoYSYmKHI9LXIpLDA9PT1yKWUoMCxvLGkrdCksZSgxL3I+MD8wOjIxNDc0ODM2NDgsbyxpK24pO2Vsc2UgaWYoaXNOYU4ocikpZSgwLG8saSt0KSxlKDIxNDY5NTkzNjAsbyxpK24pO2Vsc2UgaWYocj4xNzk3NjkzMTM0ODYyMzE1N2UyOTIpZSgwLG8saSt0KSxlKChhPDwzMXwyMTQ2NDM1MDcyKT4+PjAsbyxpK24pO2Vsc2V7dmFyIHM7aWYocjwyMjI1MDczODU4NTA3MjAxNGUtMzI0KWUoKHM9ci81ZS0zMjQpPj4+MCxvLGkrdCksZSgoYTw8MzF8cy80Mjk0OTY3Mjk2KT4+PjAsbyxpK24pO2Vsc2V7dmFyIHU9TWF0aC5mbG9vcihNYXRoLmxvZyhyKS9NYXRoLkxOMik7MTAyND09PXUmJih1PTEwMjMpLGUoNDUwMzU5OTYyNzM3MDQ5Nioocz1yKk1hdGgucG93KDIsLXUpKT4+PjAsbyxpK3QpLGUoKGE8PDMxfHUrMTAyMzw8MjB8MTA0ODU3NipzJjEwNDg1NzUpPj4+MCxvLGkrbil9fX1mdW5jdGlvbiBhKGUsdCxuLHIsbyl7dmFyIGk9ZShyLG8rdCksYT1lKHIsbytuKSxzPTIqKGE+PjMxKSsxLHU9YT4+PjIwJjIwNDcsbD00Mjk0OTY3Mjk2KigxMDQ4NTc1JmEpK2k7cmV0dXJuIDIwNDc9PT11P2w/TmFOOnMqKDEvMCk6MD09PXU/NWUtMzI0KnMqbDpzKk1hdGgucG93KDIsdS0xMDc1KSoobCs0NTAzNTk5NjI3MzcwNDk2KX1lLndyaXRlRG91YmxlTEU9dC5iaW5kKG51bGwsbiwwLDQpLGUud3JpdGVEb3VibGVCRT10LmJpbmQobnVsbCxyLDQsMCksZS5yZWFkRG91YmxlTEU9YS5iaW5kKG51bGwsbywwLDQpLGUucmVhZERvdWJsZUJFPWEuYmluZChudWxsLGksNCwwKX0oKSxlfWZ1bmN0aW9uIG4oZSx0LG4pe3Rbbl09MjU1JmUsdFtuKzFdPWU+Pj44JjI1NSx0W24rMl09ZT4+PjE2JjI1NSx0W24rM109ZT4+PjI0fWZ1bmN0aW9uIHIoZSx0LG4pe3Rbbl09ZT4+PjI0LHRbbisxXT1lPj4+MTYmMjU1LHRbbisyXT1lPj4+OCYyNTUsdFtuKzNdPTI1NSZlfWZ1bmN0aW9uIG8oZSx0KXtyZXR1cm4oZVt0XXxlW3QrMV08PDh8ZVt0KzJdPDwxNnxlW3QrM108PDI0KT4+PjB9ZnVuY3Rpb24gaShlLHQpe3JldHVybihlW3RdPDwyNHxlW3QrMV08PDE2fGVbdCsyXTw8OHxlW3QrM10pPj4+MH1lLmV4cG9ydHM9dCh0KX0sNzE5OTptb2R1bGU9PntcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpbnF1aXJlKG1vZHVsZU5hbWUpe3RyeXt2YXIgbW9kPWV2YWwoXCJxdWlyZVwiLnJlcGxhY2UoL14vLFwicmVcIikpKG1vZHVsZU5hbWUpO2lmKG1vZCYmKG1vZC5sZW5ndGh8fE9iamVjdC5rZXlzKG1vZCkubGVuZ3RoKSlyZXR1cm4gbW9kfWNhdGNoKGUpe31yZXR1cm4gbnVsbH1tb2R1bGUuZXhwb3J0cz1pbnF1aXJlfSw2NjYyOmU9PntcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPW58fDgxOTIsbz1yPj4+MSxpPW51bGwsYT1yO3JldHVybiBmdW5jdGlvbihuKXtpZihuPDF8fG4+bylyZXR1cm4gZShuKTthK24+ciYmKGk9ZShyKSxhPTApO3ZhciBzPXQuY2FsbChpLGEsYSs9bik7cmV0dXJuIDcmYSYmKGE9MSsoN3xhKSksc319fSw0OTk3OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dDtuLmxlbmd0aD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MCxuPTAscj0wO3I8ZS5sZW5ndGg7KytyKShuPWUuY2hhckNvZGVBdChyKSk8MTI4P3QrPTE6bjwyMDQ4P3QrPTI6NTUyOTY9PSg2NDUxMiZuKSYmNTYzMjA9PSg2NDUxMiZlLmNoYXJDb2RlQXQocisxKSk/KCsrcix0Kz00KTp0Kz0zO3JldHVybiB0fSxuLnJlYWQ9ZnVuY3Rpb24oZSx0LG4pe2lmKG4tdDwxKXJldHVyblwiXCI7Zm9yKHZhciByLG89bnVsbCxpPVtdLGE9MDt0PG47KShyPWVbdCsrXSk8MTI4P2lbYSsrXT1yOnI+MTkxJiZyPDIyND9pW2ErK109KDMxJnIpPDw2fDYzJmVbdCsrXTpyPjIzOSYmcjwzNjU/KHI9KCg3JnIpPDwxOHwoNjMmZVt0KytdKTw8MTJ8KDYzJmVbdCsrXSk8PDZ8NjMmZVt0KytdKS02NTUzNixpW2ErK109NTUyOTYrKHI+PjEwKSxpW2ErK109NTYzMjArKDEwMjMmcikpOmlbYSsrXT0oMTUmcik8PDEyfCg2MyZlW3QrK10pPDw2fDYzJmVbdCsrXSxhPjgxOTEmJigob3x8KG89W10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGkpKSxhPTApO3JldHVybiBvPyhhJiZvLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsaS5zbGljZSgwLGEpKSksby5qb2luKFwiXCIpKTpTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxpLnNsaWNlKDAsYSkpfSxuLndyaXRlPWZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIHIsbyxpPW4sYT0wO2E8ZS5sZW5ndGg7KythKShyPWUuY2hhckNvZGVBdChhKSk8MTI4P3RbbisrXT1yOnI8MjA0OD8odFtuKytdPXI+PjZ8MTkyLHRbbisrXT02MyZyfDEyOCk6NTUyOTY9PSg2NDUxMiZyKSYmNTYzMjA9PSg2NDUxMiYobz1lLmNoYXJDb2RlQXQoYSsxKSkpPyhyPTY1NTM2KygoMTAyMyZyKTw8MTApKygxMDIzJm8pLCsrYSx0W24rK109cj4+MTh8MjQwLHRbbisrXT1yPj4xMiY2M3wxMjgsdFtuKytdPXI+PjYmNjN8MTI4LHRbbisrXT02MyZyfDEyOCk6KHRbbisrXT1yPj4xMnwyMjQsdFtuKytdPXI+PjYmNjN8MTI4LHRbbisrXT02MyZyfDEyOCk7cmV0dXJuIG4taX19LDM0NDI6KGUsdCk9PntcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITA7dmFyIG49ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe2lmKCF0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50OyBgdmFsdWVgIGhhcyBubyB2YWx1ZS5cIik7dGhpcy52YWx1ZT1lLkVNUFRZLHQmJmUuaXNHdWlkKHQpJiYodGhpcy52YWx1ZT10KX1yZXR1cm4gZS5pc0d1aWQ9ZnVuY3Rpb24odCl7dmFyIG49dC50b1N0cmluZygpO3JldHVybiB0JiYodCBpbnN0YW5jZW9mIGV8fGUudmFsaWRhdG9yLnRlc3QobikpfSxlLmNyZWF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgZShbZS5nZW4oMiksZS5nZW4oMSksZS5nZW4oMSksZS5nZW4oMSksZS5nZW4oMyldLmpvaW4oXCItXCIpKX0sZS5jcmVhdGVFbXB0eT1mdW5jdGlvbigpe3JldHVybiBuZXcgZShcImVtcHR5Z3VpZFwiKX0sZS5wYXJzZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUucmF3PWZ1bmN0aW9uKCl7cmV0dXJuW2UuZ2VuKDIpLGUuZ2VuKDEpLGUuZ2VuKDEpLGUuZ2VuKDEpLGUuZ2VuKDMpXS5qb2luKFwiLVwiKX0sZS5nZW49ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVwiXCIsbj0wO248ZTtuKyspdCs9KDY1NTM2KigxK01hdGgucmFuZG9tKCkpfDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7cmV0dXJuIHR9LGUucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbih0KXtyZXR1cm4gZS5pc0d1aWQodCkmJnRoaXMudmFsdWU9PT10LnRvU3RyaW5nKCl9LGUucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZT09PWUuRU1QVFl9LGUucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWV9LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnt2YWx1ZTp0aGlzLnZhbHVlfX0sZS52YWxpZGF0b3I9bmV3IFJlZ0V4cChcIl5bYS16MC05XXs4fS1bYS16MC05XXs0fS1bYS16MC05XXs0fS1bYS16MC05XXs0fS1bYS16MC05XXsxMn0kXCIsXCJpXCIpLGUuRU1QVFk9XCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIixlfSgpO3QuR3VpZD1ufSwzNzIwOmU9PntlLmV4cG9ydHM9bjt2YXIgdD1udWxsO3RyeXt0PW5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDEzLDIsOTYsMCwxLDEyNyw5Niw0LDEyNywxMjcsMTI3LDEyNywxLDEyNywzLDcsNiwwLDEsMSwxLDEsMSw2LDYsMSwxMjcsMSw2NSwwLDExLDcsNTAsNiwzLDEwOSwxMTcsMTA4LDAsMSw1LDEwMCwxMDUsMTE4LDk1LDExNSwwLDIsNSwxMDAsMTA1LDExOCw5NSwxMTcsMCwzLDUsMTE0LDEwMSwxMDksOTUsMTE1LDAsNCw1LDExNCwxMDEsMTA5LDk1LDExNywwLDUsOCwxMDMsMTAxLDExNiw5NSwxMDQsMTA1LDEwMywxMDQsMCwwLDEwLDE5MSwxLDYsNCwwLDM1LDAsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTI2LDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEyNywzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMSwzNiwxLDEsMTI2LDMyLDAsMTczLDMyLDEsMTczLDY2LDMyLDEzNCwxMzIsMzIsMiwxNzMsMzIsMywxNzMsNjYsMzIsMTM0LDEzMiwxMjgsMzQsNCw2NiwzMiwxMzUsMTY3LDM2LDAsMzIsNCwxNjcsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTI5LDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEzMCwzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMV0pKSx7fSkuZXhwb3J0c31jYXRjaChlKXt9ZnVuY3Rpb24gbihlLHQsbil7dGhpcy5sb3c9MHxlLHRoaXMuaGlnaD0wfHQsdGhpcy51bnNpZ25lZD0hIW59ZnVuY3Rpb24gcihlKXtyZXR1cm4hMD09PShlJiZlLl9faXNMb25nX18pfW4ucHJvdG90eXBlLl9faXNMb25nX18sT2JqZWN0LmRlZmluZVByb3BlcnR5KG4ucHJvdG90eXBlLFwiX19pc0xvbmdfX1wiLHt2YWx1ZTohMH0pLG4uaXNMb25nPXI7dmFyIG89e30saT17fTtmdW5jdGlvbiBhKGUsdCl7dmFyIG4scixhO3JldHVybiB0PyhhPTA8PShlPj4+PTApJiZlPDI1NikmJihyPWlbZV0pP3I6KG49dShlLCgwfGUpPDA/LTE6MCwhMCksYSYmKGlbZV09biksbik6KGE9LTEyODw9KGV8PTApJiZlPDEyOCkmJihyPW9bZV0pP3I6KG49dShlLGU8MD8tMTowLCExKSxhJiYob1tlXT1uKSxuKX1mdW5jdGlvbiBzKGUsdCl7aWYoaXNOYU4oZSkpcmV0dXJuIHQ/YjptO2lmKHQpe2lmKGU8MClyZXR1cm4gYjtpZihlPj1mKXJldHVybiB4fWVsc2V7aWYoZTw9LWgpcmV0dXJuIFQ7aWYoZSsxPj1oKXJldHVybiB2fXJldHVybiBlPDA/cygtZSx0KS5uZWcoKTp1KGUlZHwwLGUvZHwwLHQpfWZ1bmN0aW9uIHUoZSx0LHIpe3JldHVybiBuZXcgbihlLHQscil9bi5mcm9tSW50PWEsbi5mcm9tTnVtYmVyPXMsbi5mcm9tQml0cz11O3ZhciBsPU1hdGgucG93O2Z1bmN0aW9uIGMoZSx0LG4pe2lmKDA9PT1lLmxlbmd0aCl0aHJvdyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtpZihcIk5hTlwiPT09ZXx8XCJJbmZpbml0eVwiPT09ZXx8XCIrSW5maW5pdHlcIj09PWV8fFwiLUluZmluaXR5XCI9PT1lKXJldHVybiBtO2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0PyhuPXQsdD0hMSk6dD0hIXQsKG49bnx8MTApPDJ8fDM2PG4pdGhyb3cgUmFuZ2VFcnJvcihcInJhZGl4XCIpO3ZhciByO2lmKChyPWUuaW5kZXhPZihcIi1cIikpPjApdGhyb3cgRXJyb3IoXCJpbnRlcmlvciBoeXBoZW5cIik7aWYoMD09PXIpcmV0dXJuIGMoZS5zdWJzdHJpbmcoMSksdCxuKS5uZWcoKTtmb3IodmFyIG89cyhsKG4sOCkpLGk9bSxhPTA7YTxlLmxlbmd0aDthKz04KXt2YXIgdT1NYXRoLm1pbig4LGUubGVuZ3RoLWEpLHA9cGFyc2VJbnQoZS5zdWJzdHJpbmcoYSxhK3UpLG4pO2lmKHU8OCl7dmFyIGQ9cyhsKG4sdSkpO2k9aS5tdWwoZCkuYWRkKHMocCkpfWVsc2UgaT0oaT1pLm11bChvKSkuYWRkKHMocCkpfXJldHVybiBpLnVuc2lnbmVkPXQsaX1mdW5jdGlvbiBwKGUsdCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGU/cyhlLHQpOlwic3RyaW5nXCI9PXR5cGVvZiBlP2MoZSx0KTp1KGUubG93LGUuaGlnaCxcImJvb2xlYW5cIj09dHlwZW9mIHQ/dDplLnVuc2lnbmVkKX1uLmZyb21TdHJpbmc9YyxuLmZyb21WYWx1ZT1wO3ZhciBkPTQyOTQ5NjcyOTYsZj1kKmQsaD1mLzIsZz1hKDE8PDI0KSxtPWEoMCk7bi5aRVJPPW07dmFyIGI9YSgwLCEwKTtuLlVaRVJPPWI7dmFyIHk9YSgxKTtuLk9ORT15O3ZhciB3PWEoMSwhMCk7bi5VT05FPXc7dmFyIF89YSgtMSk7bi5ORUdfT05FPV87dmFyIHY9dSgtMSwyMTQ3NDgzNjQ3LCExKTtuLk1BWF9WQUxVRT12O3ZhciB4PXUoLTEsLTEsITApO24uTUFYX1VOU0lHTkVEX1ZBTFVFPXg7dmFyIFQ9dSgwLC0yMTQ3NDgzNjQ4LCExKTtuLk1JTl9WQUxVRT1UO3ZhciBTPW4ucHJvdG90eXBlO1MudG9JbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD90aGlzLmxvdz4+PjA6dGhpcy5sb3d9LFMudG9OdW1iZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD8odGhpcy5oaWdoPj4+MCkqZCsodGhpcy5sb3c+Pj4wKTp0aGlzLmhpZ2gqZCsodGhpcy5sb3c+Pj4wKX0sUy50b1N0cmluZz1mdW5jdGlvbihlKXtpZigoZT1lfHwxMCk8Mnx8MzY8ZSl0aHJvdyBSYW5nZUVycm9yKFwicmFkaXhcIik7aWYodGhpcy5pc1plcm8oKSlyZXR1cm5cIjBcIjtpZih0aGlzLmlzTmVnYXRpdmUoKSl7aWYodGhpcy5lcShUKSl7dmFyIHQ9cyhlKSxuPXRoaXMuZGl2KHQpLHI9bi5tdWwodCkuc3ViKHRoaXMpO3JldHVybiBuLnRvU3RyaW5nKGUpK3IudG9JbnQoKS50b1N0cmluZyhlKX1yZXR1cm5cIi1cIit0aGlzLm5lZygpLnRvU3RyaW5nKGUpfWZvcih2YXIgbz1zKGwoZSw2KSx0aGlzLnVuc2lnbmVkKSxpPXRoaXMsYT1cIlwiOzspe3ZhciB1PWkuZGl2KG8pLGM9KGkuc3ViKHUubXVsKG8pKS50b0ludCgpPj4+MCkudG9TdHJpbmcoZSk7aWYoKGk9dSkuaXNaZXJvKCkpcmV0dXJuIGMrYTtmb3IoO2MubGVuZ3RoPDY7KWM9XCIwXCIrYzthPVwiXCIrYythfX0sUy5nZXRIaWdoQml0cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhpZ2h9LFMuZ2V0SGlnaEJpdHNVbnNpZ25lZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhpZ2g+Pj4wfSxTLmdldExvd0JpdHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sb3d9LFMuZ2V0TG93Qml0c1Vuc2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubG93Pj4+MH0sUy5nZXROdW1CaXRzQWJzPWZ1bmN0aW9uKCl7aWYodGhpcy5pc05lZ2F0aXZlKCkpcmV0dXJuIHRoaXMuZXEoVCk/NjQ6dGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7Zm9yKHZhciBlPTAhPXRoaXMuaGlnaD90aGlzLmhpZ2g6dGhpcy5sb3csdD0zMTt0PjAmJjA9PShlJjE8PHQpO3QtLSk7cmV0dXJuIDAhPXRoaXMuaGlnaD90KzMzOnQrMX0sUy5pc1plcm89ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuaGlnaCYmMD09PXRoaXMubG93fSxTLmVxej1TLmlzWmVybyxTLmlzTmVnYXRpdmU9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy51bnNpZ25lZCYmdGhpcy5oaWdoPDB9LFMuaXNQb3NpdGl2ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkfHx0aGlzLmhpZ2g+PTB9LFMuaXNPZGQ9ZnVuY3Rpb24oKXtyZXR1cm4gMT09KDEmdGhpcy5sb3cpfSxTLmlzRXZlbj1mdW5jdGlvbigpe3JldHVybiAwPT0oMSZ0aGlzLmxvdyl9LFMuZXF1YWxzPWZ1bmN0aW9uKGUpe3JldHVybiByKGUpfHwoZT1wKGUpKSwodGhpcy51bnNpZ25lZD09PWUudW5zaWduZWR8fHRoaXMuaGlnaD4+PjMxIT0xfHxlLmhpZ2g+Pj4zMSE9MSkmJnRoaXMuaGlnaD09PWUuaGlnaCYmdGhpcy5sb3c9PT1lLmxvd30sUy5lcT1TLmVxdWFscyxTLm5vdEVxdWFscz1mdW5jdGlvbihlKXtyZXR1cm4hdGhpcy5lcShlKX0sUy5uZXE9Uy5ub3RFcXVhbHMsUy5uZT1TLm5vdEVxdWFscyxTLmxlc3NUaGFuPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNvbXAoZSk8MH0sUy5sdD1TLmxlc3NUaGFuLFMubGVzc1RoYW5PckVxdWFsPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNvbXAoZSk8PTB9LFMubHRlPVMubGVzc1RoYW5PckVxdWFsLFMubGU9Uy5sZXNzVGhhbk9yRXF1YWwsUy5ncmVhdGVyVGhhbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jb21wKGUpPjB9LFMuZ3Q9Uy5ncmVhdGVyVGhhbixTLmdyZWF0ZXJUaGFuT3JFcXVhbD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jb21wKGUpPj0wfSxTLmd0ZT1TLmdyZWF0ZXJUaGFuT3JFcXVhbCxTLmdlPVMuZ3JlYXRlclRoYW5PckVxdWFsLFMuY29tcGFyZT1mdW5jdGlvbihlKXtpZihyKGUpfHwoZT1wKGUpKSx0aGlzLmVxKGUpKXJldHVybiAwO3ZhciB0PXRoaXMuaXNOZWdhdGl2ZSgpLG49ZS5pc05lZ2F0aXZlKCk7cmV0dXJuIHQmJiFuPy0xOiF0JiZuPzE6dGhpcy51bnNpZ25lZD9lLmhpZ2g+Pj4wPnRoaXMuaGlnaD4+PjB8fGUuaGlnaD09PXRoaXMuaGlnaCYmZS5sb3c+Pj4wPnRoaXMubG93Pj4+MD8tMToxOnRoaXMuc3ViKGUpLmlzTmVnYXRpdmUoKT8tMToxfSxTLmNvbXA9Uy5jb21wYXJlLFMubmVnYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMudW5zaWduZWQmJnRoaXMuZXEoVCk/VDp0aGlzLm5vdCgpLmFkZCh5KX0sUy5uZWc9Uy5uZWdhdGUsUy5hZGQ9ZnVuY3Rpb24oZSl7cihlKXx8KGU9cChlKSk7dmFyIHQ9dGhpcy5oaWdoPj4+MTYsbj02NTUzNSZ0aGlzLmhpZ2gsbz10aGlzLmxvdz4+PjE2LGk9NjU1MzUmdGhpcy5sb3csYT1lLmhpZ2g+Pj4xNixzPTY1NTM1JmUuaGlnaCxsPWUubG93Pj4+MTYsYz0wLGQ9MCxmPTAsaD0wO3JldHVybiBmKz0oaCs9aSsoNjU1MzUmZS5sb3cpKT4+PjE2LGQrPShmKz1vK2wpPj4+MTYsYys9KGQrPW4rcyk+Pj4xNixjKz10K2EsdSgoZiY9NjU1MzUpPDwxNnwoaCY9NjU1MzUpLChjJj02NTUzNSk8PDE2fChkJj02NTUzNSksdGhpcy51bnNpZ25lZCl9LFMuc3VidHJhY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHIoZSl8fChlPXAoZSkpLHRoaXMuYWRkKGUubmVnKCkpfSxTLnN1Yj1TLnN1YnRyYWN0LFMubXVsdGlwbHk9ZnVuY3Rpb24oZSl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gbTtpZihyKGUpfHwoZT1wKGUpKSx0KXJldHVybiB1KHQubXVsKHRoaXMubG93LHRoaXMuaGlnaCxlLmxvdyxlLmhpZ2gpLHQuZ2V0X2hpZ2goKSx0aGlzLnVuc2lnbmVkKTtpZihlLmlzWmVybygpKXJldHVybiBtO2lmKHRoaXMuZXEoVCkpcmV0dXJuIGUuaXNPZGQoKT9UOm07aWYoZS5lcShUKSlyZXR1cm4gdGhpcy5pc09kZCgpP1Q6bTtpZih0aGlzLmlzTmVnYXRpdmUoKSlyZXR1cm4gZS5pc05lZ2F0aXZlKCk/dGhpcy5uZWcoKS5tdWwoZS5uZWcoKSk6dGhpcy5uZWcoKS5tdWwoZSkubmVnKCk7aWYoZS5pc05lZ2F0aXZlKCkpcmV0dXJuIHRoaXMubXVsKGUubmVnKCkpLm5lZygpO2lmKHRoaXMubHQoZykmJmUubHQoZykpcmV0dXJuIHModGhpcy50b051bWJlcigpKmUudG9OdW1iZXIoKSx0aGlzLnVuc2lnbmVkKTt2YXIgbj10aGlzLmhpZ2g+Pj4xNixvPTY1NTM1JnRoaXMuaGlnaCxpPXRoaXMubG93Pj4+MTYsYT02NTUzNSZ0aGlzLmxvdyxsPWUuaGlnaD4+PjE2LGM9NjU1MzUmZS5oaWdoLGQ9ZS5sb3c+Pj4xNixmPTY1NTM1JmUubG93LGg9MCxiPTAseT0wLHc9MDtyZXR1cm4geSs9KHcrPWEqZik+Pj4xNixiKz0oeSs9aSpmKT4+PjE2LHkmPTY1NTM1LGIrPSh5Kz1hKmQpPj4+MTYsaCs9KGIrPW8qZik+Pj4xNixiJj02NTUzNSxoKz0oYis9aSpkKT4+PjE2LGImPTY1NTM1LGgrPShiKz1hKmMpPj4+MTYsaCs9bipmK28qZCtpKmMrYSpsLHUoKHkmPTY1NTM1KTw8MTZ8KHcmPTY1NTM1KSwoaCY9NjU1MzUpPDwxNnwoYiY9NjU1MzUpLHRoaXMudW5zaWduZWQpfSxTLm11bD1TLm11bHRpcGx5LFMuZGl2aWRlPWZ1bmN0aW9uKGUpe2lmKHIoZSl8fChlPXAoZSkpLGUuaXNaZXJvKCkpdGhyb3cgRXJyb3IoXCJkaXZpc2lvbiBieSB6ZXJvXCIpO3ZhciBuLG8saTtpZih0KXJldHVybiB0aGlzLnVuc2lnbmVkfHwtMjE0NzQ4MzY0OCE9PXRoaXMuaGlnaHx8LTEhPT1lLmxvd3x8LTEhPT1lLmhpZ2g/dSgodGhpcy51bnNpZ25lZD90LmRpdl91OnQuZGl2X3MpKHRoaXMubG93LHRoaXMuaGlnaCxlLmxvdyxlLmhpZ2gpLHQuZ2V0X2hpZ2goKSx0aGlzLnVuc2lnbmVkKTp0aGlzO2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIHRoaXMudW5zaWduZWQ/YjptO2lmKHRoaXMudW5zaWduZWQpe2lmKGUudW5zaWduZWR8fChlPWUudG9VbnNpZ25lZCgpKSxlLmd0KHRoaXMpKXJldHVybiBiO2lmKGUuZ3QodGhpcy5zaHJ1KDEpKSlyZXR1cm4gdztpPWJ9ZWxzZXtpZih0aGlzLmVxKFQpKXJldHVybiBlLmVxKHkpfHxlLmVxKF8pP1Q6ZS5lcShUKT95OihuPXRoaXMuc2hyKDEpLmRpdihlKS5zaGwoMSkpLmVxKG0pP2UuaXNOZWdhdGl2ZSgpP3k6Xzoobz10aGlzLnN1YihlLm11bChuKSksaT1uLmFkZChvLmRpdihlKSkpO2lmKGUuZXEoVCkpcmV0dXJuIHRoaXMudW5zaWduZWQ/YjptO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiBlLmlzTmVnYXRpdmUoKT90aGlzLm5lZygpLmRpdihlLm5lZygpKTp0aGlzLm5lZygpLmRpdihlKS5uZWcoKTtpZihlLmlzTmVnYXRpdmUoKSlyZXR1cm4gdGhpcy5kaXYoZS5uZWcoKSkubmVnKCk7aT1tfWZvcihvPXRoaXM7by5ndGUoZSk7KXtuPU1hdGgubWF4KDEsTWF0aC5mbG9vcihvLnRvTnVtYmVyKCkvZS50b051bWJlcigpKSk7Zm9yKHZhciBhPU1hdGguY2VpbChNYXRoLmxvZyhuKS9NYXRoLkxOMiksYz1hPD00OD8xOmwoMixhLTQ4KSxkPXMobiksZj1kLm11bChlKTtmLmlzTmVnYXRpdmUoKXx8Zi5ndChvKTspZj0oZD1zKG4tPWMsdGhpcy51bnNpZ25lZCkpLm11bChlKTtkLmlzWmVybygpJiYoZD15KSxpPWkuYWRkKGQpLG89by5zdWIoZil9cmV0dXJuIGl9LFMuZGl2PVMuZGl2aWRlLFMubW9kdWxvPWZ1bmN0aW9uKGUpe3JldHVybiByKGUpfHwoZT1wKGUpKSx0P3UoKHRoaXMudW5zaWduZWQ/dC5yZW1fdTp0LnJlbV9zKSh0aGlzLmxvdyx0aGlzLmhpZ2gsZS5sb3csZS5oaWdoKSx0LmdldF9oaWdoKCksdGhpcy51bnNpZ25lZCk6dGhpcy5zdWIodGhpcy5kaXYoZSkubXVsKGUpKX0sUy5tb2Q9Uy5tb2R1bG8sUy5yZW09Uy5tb2R1bG8sUy5ub3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdSh+dGhpcy5sb3csfnRoaXMuaGlnaCx0aGlzLnVuc2lnbmVkKX0sUy5hbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHIoZSl8fChlPXAoZSkpLHUodGhpcy5sb3cmZS5sb3csdGhpcy5oaWdoJmUuaGlnaCx0aGlzLnVuc2lnbmVkKX0sUy5vcj1mdW5jdGlvbihlKXtyZXR1cm4gcihlKXx8KGU9cChlKSksdSh0aGlzLmxvd3xlLmxvdyx0aGlzLmhpZ2h8ZS5oaWdoLHRoaXMudW5zaWduZWQpfSxTLnhvcj1mdW5jdGlvbihlKXtyZXR1cm4gcihlKXx8KGU9cChlKSksdSh0aGlzLmxvd15lLmxvdyx0aGlzLmhpZ2heZS5oaWdoLHRoaXMudW5zaWduZWQpfSxTLnNoaWZ0TGVmdD1mdW5jdGlvbihlKXtyZXR1cm4gcihlKSYmKGU9ZS50b0ludCgpKSwwPT0oZSY9NjMpP3RoaXM6ZTwzMj91KHRoaXMubG93PDxlLHRoaXMuaGlnaDw8ZXx0aGlzLmxvdz4+PjMyLWUsdGhpcy51bnNpZ25lZCk6dSgwLHRoaXMubG93PDxlLTMyLHRoaXMudW5zaWduZWQpfSxTLnNobD1TLnNoaWZ0TGVmdCxTLnNoaWZ0UmlnaHQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHIoZSkmJihlPWUudG9JbnQoKSksMD09KGUmPTYzKT90aGlzOmU8MzI/dSh0aGlzLmxvdz4+PmV8dGhpcy5oaWdoPDwzMi1lLHRoaXMuaGlnaD4+ZSx0aGlzLnVuc2lnbmVkKTp1KHRoaXMuaGlnaD4+ZS0zMix0aGlzLmhpZ2g+PTA/MDotMSx0aGlzLnVuc2lnbmVkKX0sUy5zaHI9Uy5zaGlmdFJpZ2h0LFMuc2hpZnRSaWdodFVuc2lnbmVkPWZ1bmN0aW9uKGUpe2lmKHIoZSkmJihlPWUudG9JbnQoKSksMD09KGUmPTYzKSlyZXR1cm4gdGhpczt2YXIgdD10aGlzLmhpZ2g7cmV0dXJuIGU8MzI/dSh0aGlzLmxvdz4+PmV8dDw8MzItZSx0Pj4+ZSx0aGlzLnVuc2lnbmVkKTp1KDMyPT09ZT90OnQ+Pj5lLTMyLDAsdGhpcy51bnNpZ25lZCl9LFMuc2hydT1TLnNoaWZ0UmlnaHRVbnNpZ25lZCxTLnNocl91PVMuc2hpZnRSaWdodFVuc2lnbmVkLFMudG9TaWduZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD91KHRoaXMubG93LHRoaXMuaGlnaCwhMSk6dGhpc30sUy50b1Vuc2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5zaWduZWQ/dGhpczp1KHRoaXMubG93LHRoaXMuaGlnaCwhMCl9LFMudG9CeXRlcz1mdW5jdGlvbihlKXtyZXR1cm4gZT90aGlzLnRvQnl0ZXNMRSgpOnRoaXMudG9CeXRlc0JFKCl9LFMudG9CeXRlc0xFPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5oaWdoLHQ9dGhpcy5sb3c7cmV0dXJuWzI1NSZ0LHQ+Pj44JjI1NSx0Pj4+MTYmMjU1LHQ+Pj4yNCwyNTUmZSxlPj4+OCYyNTUsZT4+PjE2JjI1NSxlPj4+MjRdfSxTLnRvQnl0ZXNCRT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuaGlnaCx0PXRoaXMubG93O3JldHVybltlPj4+MjQsZT4+PjE2JjI1NSxlPj4+OCYyNTUsMjU1JmUsdD4+PjI0LHQ+Pj4xNiYyNTUsdD4+PjgmMjU1LDI1NSZ0XX0sbi5mcm9tQnl0ZXM9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiByP24uZnJvbUJ5dGVzTEUoZSx0KTpuLmZyb21CeXRlc0JFKGUsdCl9LG4uZnJvbUJ5dGVzTEU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IG4oZVswXXxlWzFdPDw4fGVbMl08PDE2fGVbM108PDI0LGVbNF18ZVs1XTw8OHxlWzZdPDwxNnxlWzddPDwyNCx0KX0sbi5mcm9tQnl0ZXNCRT1mdW5jdGlvbihlLHQpe3JldHVybiBuZXcgbihlWzRdPDwyNHxlWzVdPDwxNnxlWzZdPDw4fGVbN10sZVswXTw8MjR8ZVsxXTw8MTZ8ZVsyXTw8OHxlWzNdLHQpfX0sMTQ0NjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHIsbyxpLGE9bigyMTAwKSxzPWEuUmVhZGVyLHU9YS5Xcml0ZXIsbD1hLnV0aWwsYz1hLnJvb3RzLmRlZmF1bHR8fChhLnJvb3RzLmRlZmF1bHQ9e30pO2Mub25ueD0oKGk9e30pLlZlcnNpb249KHI9e30sKG89T2JqZWN0LmNyZWF0ZShyKSlbclswXT1cIl9TVEFSVF9WRVJTSU9OXCJdPTAsb1tyWzFdPVwiSVJfVkVSU0lPTl8yMDE3XzEwXzEwXCJdPTEsb1tyWzJdPVwiSVJfVkVSU0lPTl8yMDE3XzEwXzMwXCJdPTIsb1tyWzNdPVwiSVJfVkVSU0lPTl8yMDE3XzExXzNcIl09MyxvW3JbNF09XCJJUl9WRVJTSU9OXzIwMTlfMV8yMlwiXT00LG9bcls1XT1cIklSX1ZFUlNJT05cIl09NSxvKSxpLkF0dHJpYnV0ZVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZih0aGlzLmZsb2F0cz1bXSx0aGlzLmludHM9W10sdGhpcy5zdHJpbmdzPVtdLHRoaXMudGVuc29ycz1bXSx0aGlzLmdyYXBocz1bXSxlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxuPTA7bjx0Lmxlbmd0aDsrK24pbnVsbCE9ZVt0W25dXSYmKHRoaXNbdFtuXV09ZVt0W25dXSl9cmV0dXJuIGUucHJvdG90eXBlLm5hbWU9XCJcIixlLnByb3RvdHlwZS5yZWZBdHRyTmFtZT1cIlwiLGUucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLGUucHJvdG90eXBlLnR5cGU9MCxlLnByb3RvdHlwZS5mPTAsZS5wcm90b3R5cGUuaT1sLkxvbmc/bC5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCxlLnByb3RvdHlwZS5zPWwubmV3QnVmZmVyKFtdKSxlLnByb3RvdHlwZS50PW51bGwsZS5wcm90b3R5cGUuZz1udWxsLGUucHJvdG90eXBlLmZsb2F0cz1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuaW50cz1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuc3RyaW5ncz1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUudGVuc29ycz1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuZ3JhcGhzPWwuZW1wdHlBcnJheSxlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7aWYodHx8KHQ9dS5jcmVhdGUoKSksbnVsbCE9ZS5uYW1lJiZlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmdC51aW50MzIoMTApLnN0cmluZyhlLm5hbWUpLG51bGwhPWUuZiYmZS5oYXNPd25Qcm9wZXJ0eShcImZcIikmJnQudWludDMyKDIxKS5mbG9hdChlLmYpLG51bGwhPWUuaSYmZS5oYXNPd25Qcm9wZXJ0eShcImlcIikmJnQudWludDMyKDI0KS5pbnQ2NChlLmkpLG51bGwhPWUucyYmZS5oYXNPd25Qcm9wZXJ0eShcInNcIikmJnQudWludDMyKDM0KS5ieXRlcyhlLnMpLG51bGwhPWUudCYmZS5oYXNPd25Qcm9wZXJ0eShcInRcIikmJmMub25ueC5UZW5zb3JQcm90by5lbmNvZGUoZS50LHQudWludDMyKDQyKS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPWUuZyYmZS5oYXNPd25Qcm9wZXJ0eShcImdcIikmJmMub25ueC5HcmFwaFByb3RvLmVuY29kZShlLmcsdC51aW50MzIoNTApLmZvcmsoKSkubGRlbGltKCksbnVsbCE9ZS5mbG9hdHMmJmUuZmxvYXRzLmxlbmd0aCl7dC51aW50MzIoNTgpLmZvcmsoKTtmb3IodmFyIG49MDtuPGUuZmxvYXRzLmxlbmd0aDsrK24pdC5mbG9hdChlLmZsb2F0c1tuXSk7dC5sZGVsaW0oKX1pZihudWxsIT1lLmludHMmJmUuaW50cy5sZW5ndGgpe2Zvcih0LnVpbnQzMig2NikuZm9yaygpLG49MDtuPGUuaW50cy5sZW5ndGg7KytuKXQuaW50NjQoZS5pbnRzW25dKTt0LmxkZWxpbSgpfWlmKG51bGwhPWUuc3RyaW5ncyYmZS5zdHJpbmdzLmxlbmd0aClmb3Iobj0wO248ZS5zdHJpbmdzLmxlbmd0aDsrK24pdC51aW50MzIoNzQpLmJ5dGVzKGUuc3RyaW5nc1tuXSk7aWYobnVsbCE9ZS50ZW5zb3JzJiZlLnRlbnNvcnMubGVuZ3RoKWZvcihuPTA7bjxlLnRlbnNvcnMubGVuZ3RoOysrbiljLm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKGUudGVuc29yc1tuXSx0LnVpbnQzMig4MikuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT1lLmdyYXBocyYmZS5ncmFwaHMubGVuZ3RoKWZvcihuPTA7bjxlLmdyYXBocy5sZW5ndGg7KytuKWMub25ueC5HcmFwaFByb3RvLmVuY29kZShlLmdyYXBoc1tuXSx0LnVpbnQzMig5MCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gbnVsbCE9ZS5kb2NTdHJpbmcmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJnQudWludDMyKDEwNikuc3RyaW5nKGUuZG9jU3RyaW5nKSxudWxsIT1lLnR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpJiZ0LnVpbnQzMigxNjApLmludDMyKGUudHlwZSksbnVsbCE9ZS5yZWZBdHRyTmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcInJlZkF0dHJOYW1lXCIpJiZ0LnVpbnQzMigxNzApLnN0cmluZyhlLnJlZkF0dHJOYW1lKSx0fSxlLmVuY29kZURlbGltaXRlZD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVuY29kZShlLHQpLmxkZWxpbSgpfSxlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiBzfHwoZT1zLmNyZWF0ZShlKSk7Zm9yKHZhciBuPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyBjLm9ubnguQXR0cmlidXRlUHJvdG87ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci5uYW1lPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyMTpyLnJlZkF0dHJOYW1lPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSAxMzpyLmRvY1N0cmluZz1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMjA6ci50eXBlPWUuaW50MzIoKTticmVhaztjYXNlIDI6ci5mPWUuZmxvYXQoKTticmVhaztjYXNlIDM6ci5pPWUuaW50NjQoKTticmVhaztjYXNlIDQ6ci5zPWUuYnl0ZXMoKTticmVhaztjYXNlIDU6ci50PWMub25ueC5UZW5zb3JQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDY6ci5nPWMub25ueC5HcmFwaFByb3RvLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2Nhc2UgNzppZihyLmZsb2F0cyYmci5mbG9hdHMubGVuZ3RofHwoci5mbG9hdHM9W10pLDI9PSg3Jm8pKWZvcih2YXIgaT1lLnVpbnQzMigpK2UucG9zO2UucG9zPGk7KXIuZmxvYXRzLnB1c2goZS5mbG9hdCgpKTtlbHNlIHIuZmxvYXRzLnB1c2goZS5mbG9hdCgpKTticmVhaztjYXNlIDg6aWYoci5pbnRzJiZyLmludHMubGVuZ3RofHwoci5pbnRzPVtdKSwyPT0oNyZvKSlmb3IoaT1lLnVpbnQzMigpK2UucG9zO2UucG9zPGk7KXIuaW50cy5wdXNoKGUuaW50NjQoKSk7ZWxzZSByLmludHMucHVzaChlLmludDY0KCkpO2JyZWFrO2Nhc2UgOTpyLnN0cmluZ3MmJnIuc3RyaW5ncy5sZW5ndGh8fChyLnN0cmluZ3M9W10pLHIuc3RyaW5ncy5wdXNoKGUuYnl0ZXMoKSk7YnJlYWs7Y2FzZSAxMDpyLnRlbnNvcnMmJnIudGVuc29ycy5sZW5ndGh8fChyLnRlbnNvcnM9W10pLHIudGVuc29ycy5wdXNoKGMub25ueC5UZW5zb3JQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxMTpyLmdyYXBocyYmci5ncmFwaHMubGVuZ3RofHwoci5ncmFwaHM9W10pLHIuZ3JhcGhzLnB1c2goYy5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm8pfX1yZXR1cm4gcn0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBzfHwoZT1uZXcgcyhlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5uYW1lJiZlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmIWwuaXNTdHJpbmcoZS5uYW1lKSlyZXR1cm5cIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPWUucmVmQXR0ck5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJyZWZBdHRyTmFtZVwiKSYmIWwuaXNTdHJpbmcoZS5yZWZBdHRyTmFtZSkpcmV0dXJuXCJyZWZBdHRyTmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5kb2NTdHJpbmcmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJiFsLmlzU3RyaW5nKGUuZG9jU3RyaW5nKSlyZXR1cm5cImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS50eXBlJiZlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSlzd2l0Y2goZS50eXBlKXtkZWZhdWx0OnJldHVyblwidHlwZTogZW51bSB2YWx1ZSBleHBlY3RlZFwiO2Nhc2UgMDpjYXNlIDE6Y2FzZSAyOmNhc2UgMzpjYXNlIDQ6Y2FzZSA1OmNhc2UgNjpjYXNlIDc6Y2FzZSA4OmNhc2UgOTpjYXNlIDEwOn1pZihudWxsIT1lLmYmJmUuaGFzT3duUHJvcGVydHkoXCJmXCIpJiZcIm51bWJlclwiIT10eXBlb2YgZS5mKXJldHVyblwiZjogbnVtYmVyIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5pJiZlLmhhc093blByb3BlcnR5KFwiaVwiKSYmIShsLmlzSW50ZWdlcihlLmkpfHxlLmkmJmwuaXNJbnRlZ2VyKGUuaS5sb3cpJiZsLmlzSW50ZWdlcihlLmkuaGlnaCkpKXJldHVyblwiaTogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5zJiZlLmhhc093blByb3BlcnR5KFwic1wiKSYmIShlLnMmJlwibnVtYmVyXCI9PXR5cGVvZiBlLnMubGVuZ3RofHxsLmlzU3RyaW5nKGUucykpKXJldHVyblwiczogYnVmZmVyIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS50JiZlLmhhc093blByb3BlcnR5KFwidFwiKSYmKG49Yy5vbm54LlRlbnNvclByb3RvLnZlcmlmeShlLnQpKSlyZXR1cm5cInQuXCIrbjtpZihudWxsIT1lLmcmJmUuaGFzT3duUHJvcGVydHkoXCJnXCIpJiYobj1jLm9ubnguR3JhcGhQcm90by52ZXJpZnkoZS5nKSkpcmV0dXJuXCJnLlwiK247aWYobnVsbCE9ZS5mbG9hdHMmJmUuaGFzT3duUHJvcGVydHkoXCJmbG9hdHNcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuZmxvYXRzKSlyZXR1cm5cImZsb2F0czogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHQ9MDt0PGUuZmxvYXRzLmxlbmd0aDsrK3QpaWYoXCJudW1iZXJcIiE9dHlwZW9mIGUuZmxvYXRzW3RdKXJldHVyblwiZmxvYXRzOiBudW1iZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPWUuaW50cyYmZS5oYXNPd25Qcm9wZXJ0eShcImludHNcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuaW50cykpcmV0dXJuXCJpbnRzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLmludHMubGVuZ3RoOysrdClpZighKGwuaXNJbnRlZ2VyKGUuaW50c1t0XSl8fGUuaW50c1t0XSYmbC5pc0ludGVnZXIoZS5pbnRzW3RdLmxvdykmJmwuaXNJbnRlZ2VyKGUuaW50c1t0XS5oaWdoKSkpcmV0dXJuXCJpbnRzOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPWUuc3RyaW5ncyYmZS5oYXNPd25Qcm9wZXJ0eShcInN0cmluZ3NcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuc3RyaW5ncykpcmV0dXJuXCJzdHJpbmdzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLnN0cmluZ3MubGVuZ3RoOysrdClpZighKGUuc3RyaW5nc1t0XSYmXCJudW1iZXJcIj09dHlwZW9mIGUuc3RyaW5nc1t0XS5sZW5ndGh8fGwuaXNTdHJpbmcoZS5zdHJpbmdzW3RdKSkpcmV0dXJuXCJzdHJpbmdzOiBidWZmZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPWUudGVuc29ycyYmZS5oYXNPd25Qcm9wZXJ0eShcInRlbnNvcnNcIikpe2lmKCFBcnJheS5pc0FycmF5KGUudGVuc29ycykpcmV0dXJuXCJ0ZW5zb3JzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLnRlbnNvcnMubGVuZ3RoOysrdClpZihuPWMub25ueC5UZW5zb3JQcm90by52ZXJpZnkoZS50ZW5zb3JzW3RdKSlyZXR1cm5cInRlbnNvcnMuXCIrbn1pZihudWxsIT1lLmdyYXBocyYmZS5oYXNPd25Qcm9wZXJ0eShcImdyYXBoc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5ncmFwaHMpKXJldHVyblwiZ3JhcGhzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLmdyYXBocy5sZW5ndGg7Kyt0KXt2YXIgbjtpZihuPWMub25ueC5HcmFwaFByb3RvLnZlcmlmeShlLmdyYXBoc1t0XSkpcmV0dXJuXCJncmFwaHMuXCIrbn19cmV0dXJuIG51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54LkF0dHJpYnV0ZVByb3RvKXJldHVybiBlO3ZhciB0PW5ldyBjLm9ubnguQXR0cmlidXRlUHJvdG87c3dpdGNoKG51bGwhPWUubmFtZSYmKHQubmFtZT1TdHJpbmcoZS5uYW1lKSksbnVsbCE9ZS5yZWZBdHRyTmFtZSYmKHQucmVmQXR0ck5hbWU9U3RyaW5nKGUucmVmQXR0ck5hbWUpKSxudWxsIT1lLmRvY1N0cmluZyYmKHQuZG9jU3RyaW5nPVN0cmluZyhlLmRvY1N0cmluZykpLGUudHlwZSl7Y2FzZVwiVU5ERUZJTkVEXCI6Y2FzZSAwOnQudHlwZT0wO2JyZWFrO2Nhc2VcIkZMT0FUXCI6Y2FzZSAxOnQudHlwZT0xO2JyZWFrO2Nhc2VcIklOVFwiOmNhc2UgMjp0LnR5cGU9MjticmVhaztjYXNlXCJTVFJJTkdcIjpjYXNlIDM6dC50eXBlPTM7YnJlYWs7Y2FzZVwiVEVOU09SXCI6Y2FzZSA0OnQudHlwZT00O2JyZWFrO2Nhc2VcIkdSQVBIXCI6Y2FzZSA1OnQudHlwZT01O2JyZWFrO2Nhc2VcIkZMT0FUU1wiOmNhc2UgNjp0LnR5cGU9NjticmVhaztjYXNlXCJJTlRTXCI6Y2FzZSA3OnQudHlwZT03O2JyZWFrO2Nhc2VcIlNUUklOR1NcIjpjYXNlIDg6dC50eXBlPTg7YnJlYWs7Y2FzZVwiVEVOU09SU1wiOmNhc2UgOTp0LnR5cGU9OTticmVhaztjYXNlXCJHUkFQSFNcIjpjYXNlIDEwOnQudHlwZT0xMH1pZihudWxsIT1lLmYmJih0LmY9TnVtYmVyKGUuZikpLG51bGwhPWUuaSYmKGwuTG9uZz8odC5pPWwuTG9uZy5mcm9tVmFsdWUoZS5pKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIGUuaT90Lmk9cGFyc2VJbnQoZS5pLDEwKTpcIm51bWJlclwiPT10eXBlb2YgZS5pP3QuaT1lLmk6XCJvYmplY3RcIj09dHlwZW9mIGUuaSYmKHQuaT1uZXcgbC5Mb25nQml0cyhlLmkubG93Pj4+MCxlLmkuaGlnaD4+PjApLnRvTnVtYmVyKCkpKSxudWxsIT1lLnMmJihcInN0cmluZ1wiPT10eXBlb2YgZS5zP2wuYmFzZTY0LmRlY29kZShlLnMsdC5zPWwubmV3QnVmZmVyKGwuYmFzZTY0Lmxlbmd0aChlLnMpKSwwKTplLnMubGVuZ3RoJiYodC5zPWUucykpLG51bGwhPWUudCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUudCl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by50OiBvYmplY3QgZXhwZWN0ZWRcIik7dC50PWMub25ueC5UZW5zb3JQcm90by5mcm9tT2JqZWN0KGUudCl9aWYobnVsbCE9ZS5nKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5nKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmc6IG9iamVjdCBleHBlY3RlZFwiKTt0Lmc9Yy5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdChlLmcpfWlmKGUuZmxvYXRzKXtpZighQXJyYXkuaXNBcnJheShlLmZsb2F0cykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uZmxvYXRzOiBhcnJheSBleHBlY3RlZFwiKTt0LmZsb2F0cz1bXTtmb3IodmFyIG49MDtuPGUuZmxvYXRzLmxlbmd0aDsrK24pdC5mbG9hdHNbbl09TnVtYmVyKGUuZmxvYXRzW25dKX1pZihlLmludHMpe2lmKCFBcnJheS5pc0FycmF5KGUuaW50cykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uaW50czogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuaW50cz1bXSxuPTA7bjxlLmludHMubGVuZ3RoOysrbilsLkxvbmc/KHQuaW50c1tuXT1sLkxvbmcuZnJvbVZhbHVlKGUuaW50c1tuXSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLmludHNbbl0/dC5pbnRzW25dPXBhcnNlSW50KGUuaW50c1tuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUuaW50c1tuXT90LmludHNbbl09ZS5pbnRzW25dOlwib2JqZWN0XCI9PXR5cGVvZiBlLmludHNbbl0mJih0LmludHNbbl09bmV3IGwuTG9uZ0JpdHMoZS5pbnRzW25dLmxvdz4+PjAsZS5pbnRzW25dLmhpZ2g+Pj4wKS50b051bWJlcigpKX1pZihlLnN0cmluZ3Mpe2lmKCFBcnJheS5pc0FycmF5KGUuc3RyaW5ncykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uc3RyaW5nczogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuc3RyaW5ncz1bXSxuPTA7bjxlLnN0cmluZ3MubGVuZ3RoOysrbilcInN0cmluZ1wiPT10eXBlb2YgZS5zdHJpbmdzW25dP2wuYmFzZTY0LmRlY29kZShlLnN0cmluZ3Nbbl0sdC5zdHJpbmdzW25dPWwubmV3QnVmZmVyKGwuYmFzZTY0Lmxlbmd0aChlLnN0cmluZ3Nbbl0pKSwwKTplLnN0cmluZ3Nbbl0ubGVuZ3RoJiYodC5zdHJpbmdzW25dPWUuc3RyaW5nc1tuXSl9aWYoZS50ZW5zb3JzKXtpZighQXJyYXkuaXNBcnJheShlLnRlbnNvcnMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnRlbnNvcnM6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LnRlbnNvcnM9W10sbj0wO248ZS50ZW5zb3JzLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLnRlbnNvcnNbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udGVuc29yczogb2JqZWN0IGV4cGVjdGVkXCIpO3QudGVuc29yc1tuXT1jLm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChlLnRlbnNvcnNbbl0pfX1pZihlLmdyYXBocyl7aWYoIUFycmF5LmlzQXJyYXkoZS5ncmFwaHMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmdyYXBoczogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuZ3JhcGhzPVtdLG49MDtuPGUuZ3JhcGhzLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLmdyYXBoc1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5ncmFwaHM6IG9iamVjdCBleHBlY3RlZFwiKTt0LmdyYXBoc1tuXT1jLm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KGUuZ3JhcGhzW25dKX19cmV0dXJuIHR9LGUudG9PYmplY3Q9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSk7dmFyIG49e307aWYoKHQuYXJyYXlzfHx0LmRlZmF1bHRzKSYmKG4uZmxvYXRzPVtdLG4uaW50cz1bXSxuLnN0cmluZ3M9W10sbi50ZW5zb3JzPVtdLG4uZ3JhcGhzPVtdKSx0LmRlZmF1bHRzKXtpZihuLm5hbWU9XCJcIixuLmY9MCxsLkxvbmcpe3ZhciByPW5ldyBsLkxvbmcoMCwwLCExKTtuLmk9dC5sb25ncz09PVN0cmluZz9yLnRvU3RyaW5nKCk6dC5sb25ncz09PU51bWJlcj9yLnRvTnVtYmVyKCk6cn1lbHNlIG4uaT10LmxvbmdzPT09U3RyaW5nP1wiMFwiOjA7dC5ieXRlcz09PVN0cmluZz9uLnM9XCJcIjoobi5zPVtdLHQuYnl0ZXMhPT1BcnJheSYmKG4ucz1sLm5ld0J1ZmZlcihuLnMpKSksbi50PW51bGwsbi5nPW51bGwsbi5kb2NTdHJpbmc9XCJcIixuLnR5cGU9dC5lbnVtcz09PVN0cmluZz9cIlVOREVGSU5FRFwiOjAsbi5yZWZBdHRyTmFtZT1cIlwifWlmKG51bGwhPWUubmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJihuLm5hbWU9ZS5uYW1lKSxudWxsIT1lLmYmJmUuaGFzT3duUHJvcGVydHkoXCJmXCIpJiYobi5mPXQuanNvbiYmIWlzRmluaXRlKGUuZik/U3RyaW5nKGUuZik6ZS5mKSxudWxsIT1lLmkmJmUuaGFzT3duUHJvcGVydHkoXCJpXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIGUuaT9uLmk9dC5sb25ncz09PVN0cmluZz9TdHJpbmcoZS5pKTplLmk6bi5pPXQubG9uZ3M9PT1TdHJpbmc/bC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUuaSk6dC5sb25ncz09PU51bWJlcj9uZXcgbC5Mb25nQml0cyhlLmkubG93Pj4+MCxlLmkuaGlnaD4+PjApLnRvTnVtYmVyKCk6ZS5pKSxudWxsIT1lLnMmJmUuaGFzT3duUHJvcGVydHkoXCJzXCIpJiYobi5zPXQuYnl0ZXM9PT1TdHJpbmc/bC5iYXNlNjQuZW5jb2RlKGUucywwLGUucy5sZW5ndGgpOnQuYnl0ZXM9PT1BcnJheT9BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLnMpOmUucyksbnVsbCE9ZS50JiZlLmhhc093blByb3BlcnR5KFwidFwiKSYmKG4udD1jLm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QoZS50LHQpKSxudWxsIT1lLmcmJmUuaGFzT3duUHJvcGVydHkoXCJnXCIpJiYobi5nPWMub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KGUuZyx0KSksZS5mbG9hdHMmJmUuZmxvYXRzLmxlbmd0aCl7bi5mbG9hdHM9W107Zm9yKHZhciBvPTA7bzxlLmZsb2F0cy5sZW5ndGg7KytvKW4uZmxvYXRzW29dPXQuanNvbiYmIWlzRmluaXRlKGUuZmxvYXRzW29dKT9TdHJpbmcoZS5mbG9hdHNbb10pOmUuZmxvYXRzW29dfWlmKGUuaW50cyYmZS5pbnRzLmxlbmd0aClmb3Iobi5pbnRzPVtdLG89MDtvPGUuaW50cy5sZW5ndGg7KytvKVwibnVtYmVyXCI9PXR5cGVvZiBlLmludHNbb10/bi5pbnRzW29dPXQubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKGUuaW50c1tvXSk6ZS5pbnRzW29dOm4uaW50c1tvXT10LmxvbmdzPT09U3RyaW5nP2wuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlLmludHNbb10pOnQubG9uZ3M9PT1OdW1iZXI/bmV3IGwuTG9uZ0JpdHMoZS5pbnRzW29dLmxvdz4+PjAsZS5pbnRzW29dLmhpZ2g+Pj4wKS50b051bWJlcigpOmUuaW50c1tvXTtpZihlLnN0cmluZ3MmJmUuc3RyaW5ncy5sZW5ndGgpZm9yKG4uc3RyaW5ncz1bXSxvPTA7bzxlLnN0cmluZ3MubGVuZ3RoOysrbyluLnN0cmluZ3Nbb109dC5ieXRlcz09PVN0cmluZz9sLmJhc2U2NC5lbmNvZGUoZS5zdHJpbmdzW29dLDAsZS5zdHJpbmdzW29dLmxlbmd0aCk6dC5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUuc3RyaW5nc1tvXSk6ZS5zdHJpbmdzW29dO2lmKGUudGVuc29ycyYmZS50ZW5zb3JzLmxlbmd0aClmb3Iobi50ZW5zb3JzPVtdLG89MDtvPGUudGVuc29ycy5sZW5ndGg7KytvKW4udGVuc29yc1tvXT1jLm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QoZS50ZW5zb3JzW29dLHQpO2lmKGUuZ3JhcGhzJiZlLmdyYXBocy5sZW5ndGgpZm9yKG4uZ3JhcGhzPVtdLG89MDtvPGUuZ3JhcGhzLmxlbmd0aDsrK28pbi5ncmFwaHNbb109Yy5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QoZS5ncmFwaHNbb10sdCk7cmV0dXJuIG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9ZS5kb2NTdHJpbmcpLG51bGwhPWUudHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikmJihuLnR5cGU9dC5lbnVtcz09PVN0cmluZz9jLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVtlLnR5cGVdOmUudHlwZSksbnVsbCE9ZS5yZWZBdHRyTmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcInJlZkF0dHJOYW1lXCIpJiYobi5yZWZBdHRyTmFtZT1lLnJlZkF0dHJOYW1lKSxufSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sZS5BdHRyaWJ1dGVUeXBlPWZ1bmN0aW9uKCl7dmFyIGU9e30sdD1PYmplY3QuY3JlYXRlKGUpO3JldHVybiB0W2VbMF09XCJVTkRFRklORURcIl09MCx0W2VbMV09XCJGTE9BVFwiXT0xLHRbZVsyXT1cIklOVFwiXT0yLHRbZVszXT1cIlNUUklOR1wiXT0zLHRbZVs0XT1cIlRFTlNPUlwiXT00LHRbZVs1XT1cIkdSQVBIXCJdPTUsdFtlWzZdPVwiRkxPQVRTXCJdPTYsdFtlWzddPVwiSU5UU1wiXT03LHRbZVs4XT1cIlNUUklOR1NcIl09OCx0W2VbOV09XCJURU5TT1JTXCJdPTksdFtlWzEwXT1cIkdSQVBIU1wiXT0xMCx0fSgpLGV9KCksaS5WYWx1ZUluZm9Qcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYoZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXJldHVybiBlLnByb3RvdHlwZS5uYW1lPVwiXCIsZS5wcm90b3R5cGUudHlwZT1udWxsLGUucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8KHQ9dS5jcmVhdGUoKSksbnVsbCE9ZS5uYW1lJiZlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmdC51aW50MzIoMTApLnN0cmluZyhlLm5hbWUpLG51bGwhPWUudHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikmJmMub25ueC5UeXBlUHJvdG8uZW5jb2RlKGUudHlwZSx0LnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKSxudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmdC51aW50MzIoMjYpLnN0cmluZyhlLmRvY1N0cmluZyksdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2Ygc3x8KGU9cy5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54LlZhbHVlSW5mb1Byb3RvO2UucG9zPG47KXt2YXIgbz1lLnVpbnQzMigpO3N3aXRjaChvPj4+Myl7Y2FzZSAxOnIubmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMjpyLnR5cGU9Yy5vbm54LlR5cGVQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDM6ci5kb2NTdHJpbmc9ZS5zdHJpbmcoKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZvKX19cmV0dXJuIHJ9LGUuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2Ygc3x8KGU9bmV3IHMoZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LGUudmVyaWZ5PWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZSlyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPWUubmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFsLmlzU3RyaW5nKGUubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLnR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKXt2YXIgdD1jLm9ubnguVHlwZVByb3RvLnZlcmlmeShlLnR5cGUpO2lmKHQpcmV0dXJuXCJ0eXBlLlwiK3R9cmV0dXJuIG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhbC5pc1N0cmluZyhlLmRvY1N0cmluZyk/XCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54LlZhbHVlSW5mb1Byb3RvKXJldHVybiBlO3ZhciB0PW5ldyBjLm9ubnguVmFsdWVJbmZvUHJvdG87aWYobnVsbCE9ZS5uYW1lJiYodC5uYW1lPVN0cmluZyhlLm5hbWUpKSxudWxsIT1lLnR5cGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLnR5cGUpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVmFsdWVJbmZvUHJvdG8udHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO3QudHlwZT1jLm9ubnguVHlwZVByb3RvLmZyb21PYmplY3QoZS50eXBlKX1yZXR1cm4gbnVsbCE9ZS5kb2NTdHJpbmcmJih0LmRvY1N0cmluZz1TdHJpbmcoZS5kb2NTdHJpbmcpKSx0fSxlLnRvT2JqZWN0PWZ1bmN0aW9uKGUsdCl7dHx8KHQ9e30pO3ZhciBuPXt9O3JldHVybiB0LmRlZmF1bHRzJiYobi5uYW1lPVwiXCIsbi50eXBlPW51bGwsbi5kb2NTdHJpbmc9XCJcIiksbnVsbCE9ZS5uYW1lJiZlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmKG4ubmFtZT1lLm5hbWUpLG51bGwhPWUudHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikmJihuLnR5cGU9Yy5vbm54LlR5cGVQcm90by50b09iamVjdChlLnR5cGUsdCkpLG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9ZS5kb2NTdHJpbmcpLG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSxlfSgpLGkuTm9kZVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZih0aGlzLmlucHV0PVtdLHRoaXMub3V0cHV0PVtdLHRoaXMuYXR0cmlidXRlPVtdLGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLG49MDtuPHQubGVuZ3RoOysrbiludWxsIT1lW3Rbbl1dJiYodGhpc1t0W25dXT1lW3Rbbl1dKX1yZXR1cm4gZS5wcm90b3R5cGUuaW5wdXQ9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLm91dHB1dD1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUubmFtZT1cIlwiLGUucHJvdG90eXBlLm9wVHlwZT1cIlwiLGUucHJvdG90eXBlLmRvbWFpbj1cIlwiLGUucHJvdG90eXBlLmF0dHJpYnV0ZT1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsZS5jcmVhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpfSxlLmVuY29kZT1mdW5jdGlvbihlLHQpe2lmKHR8fCh0PXUuY3JlYXRlKCkpLG51bGwhPWUuaW5wdXQmJmUuaW5wdXQubGVuZ3RoKWZvcih2YXIgbj0wO248ZS5pbnB1dC5sZW5ndGg7KytuKXQudWludDMyKDEwKS5zdHJpbmcoZS5pbnB1dFtuXSk7aWYobnVsbCE9ZS5vdXRwdXQmJmUub3V0cHV0Lmxlbmd0aClmb3Iobj0wO248ZS5vdXRwdXQubGVuZ3RoOysrbil0LnVpbnQzMigxOCkuc3RyaW5nKGUub3V0cHV0W25dKTtpZihudWxsIT1lLm5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiZ0LnVpbnQzMigyNikuc3RyaW5nKGUubmFtZSksbnVsbCE9ZS5vcFR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJvcFR5cGVcIikmJnQudWludDMyKDM0KS5zdHJpbmcoZS5vcFR5cGUpLG51bGwhPWUuYXR0cmlidXRlJiZlLmF0dHJpYnV0ZS5sZW5ndGgpZm9yKG49MDtuPGUuYXR0cmlidXRlLmxlbmd0aDsrK24pYy5vbm54LkF0dHJpYnV0ZVByb3RvLmVuY29kZShlLmF0dHJpYnV0ZVtuXSx0LnVpbnQzMig0MikuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gbnVsbCE9ZS5kb2NTdHJpbmcmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJnQudWludDMyKDUwKS5zdHJpbmcoZS5kb2NTdHJpbmcpLG51bGwhPWUuZG9tYWluJiZlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiZ0LnVpbnQzMig1OCkuc3RyaW5nKGUuZG9tYWluKSx0fSxlLmVuY29kZURlbGltaXRlZD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVuY29kZShlLHQpLmxkZWxpbSgpfSxlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiBzfHwoZT1zLmNyZWF0ZShlKSk7Zm9yKHZhciBuPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyBjLm9ubnguTm9kZVByb3RvO2UucG9zPG47KXt2YXIgbz1lLnVpbnQzMigpO3N3aXRjaChvPj4+Myl7Y2FzZSAxOnIuaW5wdXQmJnIuaW5wdXQubGVuZ3RofHwoci5pbnB1dD1bXSksci5pbnB1dC5wdXNoKGUuc3RyaW5nKCkpO2JyZWFrO2Nhc2UgMjpyLm91dHB1dCYmci5vdXRwdXQubGVuZ3RofHwoci5vdXRwdXQ9W10pLHIub3V0cHV0LnB1c2goZS5zdHJpbmcoKSk7YnJlYWs7Y2FzZSAzOnIubmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgNDpyLm9wVHlwZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgNzpyLmRvbWFpbj1lLnN0cmluZygpO2JyZWFrO2Nhc2UgNTpyLmF0dHJpYnV0ZSYmci5hdHRyaWJ1dGUubGVuZ3RofHwoci5hdHRyaWJ1dGU9W10pLHIuYXR0cmlidXRlLnB1c2goYy5vbm54LkF0dHJpYnV0ZVByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVhaztjYXNlIDY6ci5kb2NTdHJpbmc9ZS5zdHJpbmcoKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZvKX19cmV0dXJuIHJ9LGUuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2Ygc3x8KGU9bmV3IHMoZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LGUudmVyaWZ5PWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZSlyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPWUuaW5wdXQmJmUuaGFzT3duUHJvcGVydHkoXCJpbnB1dFwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5pbnB1dCkpcmV0dXJuXCJpbnB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHQ9MDt0PGUuaW5wdXQubGVuZ3RoOysrdClpZighbC5pc1N0cmluZyhlLmlucHV0W3RdKSlyZXR1cm5cImlucHV0OiBzdHJpbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPWUub3V0cHV0JiZlLmhhc093blByb3BlcnR5KFwib3V0cHV0XCIpKXtpZighQXJyYXkuaXNBcnJheShlLm91dHB1dCkpcmV0dXJuXCJvdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHQ9MDt0PGUub3V0cHV0Lmxlbmd0aDsrK3QpaWYoIWwuaXNTdHJpbmcoZS5vdXRwdXRbdF0pKXJldHVyblwib3V0cHV0OiBzdHJpbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPWUubmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFsLmlzU3RyaW5nKGUubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLm9wVHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm9wVHlwZVwiKSYmIWwuaXNTdHJpbmcoZS5vcFR5cGUpKXJldHVyblwib3BUeXBlOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmRvbWFpbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmIWwuaXNTdHJpbmcoZS5kb21haW4pKXJldHVyblwiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmF0dHJpYnV0ZSYmZS5oYXNPd25Qcm9wZXJ0eShcImF0dHJpYnV0ZVwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5hdHRyaWJ1dGUpKXJldHVyblwiYXR0cmlidXRlOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLmF0dHJpYnV0ZS5sZW5ndGg7Kyt0KXt2YXIgbj1jLm9ubnguQXR0cmlidXRlUHJvdG8udmVyaWZ5KGUuYXR0cmlidXRlW3RdKTtpZihuKXJldHVyblwiYXR0cmlidXRlLlwiK259fXJldHVybiBudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmIWwuaXNTdHJpbmcoZS5kb2NTdHJpbmcpP1wiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5Ob2RlUHJvdG8pcmV0dXJuIGU7dmFyIHQ9bmV3IGMub25ueC5Ob2RlUHJvdG87aWYoZS5pbnB1dCl7aWYoIUFycmF5LmlzQXJyYXkoZS5pbnB1dCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLmlucHV0OiBhcnJheSBleHBlY3RlZFwiKTt0LmlucHV0PVtdO2Zvcih2YXIgbj0wO248ZS5pbnB1dC5sZW5ndGg7KytuKXQuaW5wdXRbbl09U3RyaW5nKGUuaW5wdXRbbl0pfWlmKGUub3V0cHV0KXtpZighQXJyYXkuaXNBcnJheShlLm91dHB1dCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQub3V0cHV0PVtdLG49MDtuPGUub3V0cHV0Lmxlbmd0aDsrK24pdC5vdXRwdXRbbl09U3RyaW5nKGUub3V0cHV0W25dKX1pZihudWxsIT1lLm5hbWUmJih0Lm5hbWU9U3RyaW5nKGUubmFtZSkpLG51bGwhPWUub3BUeXBlJiYodC5vcFR5cGU9U3RyaW5nKGUub3BUeXBlKSksbnVsbCE9ZS5kb21haW4mJih0LmRvbWFpbj1TdHJpbmcoZS5kb21haW4pKSxlLmF0dHJpYnV0ZSl7aWYoIUFycmF5LmlzQXJyYXkoZS5hdHRyaWJ1dGUpKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk5vZGVQcm90by5hdHRyaWJ1dGU6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LmF0dHJpYnV0ZT1bXSxuPTA7bjxlLmF0dHJpYnV0ZS5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5hdHRyaWJ1dGVbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLmF0dHJpYnV0ZTogb2JqZWN0IGV4cGVjdGVkXCIpO3QuYXR0cmlidXRlW25dPWMub25ueC5BdHRyaWJ1dGVQcm90by5mcm9tT2JqZWN0KGUuYXR0cmlidXRlW25dKX19cmV0dXJuIG51bGwhPWUuZG9jU3RyaW5nJiYodC5kb2NTdHJpbmc9U3RyaW5nKGUuZG9jU3RyaW5nKSksdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtpZigodC5hcnJheXN8fHQuZGVmYXVsdHMpJiYobi5pbnB1dD1bXSxuLm91dHB1dD1bXSxuLmF0dHJpYnV0ZT1bXSksdC5kZWZhdWx0cyYmKG4ubmFtZT1cIlwiLG4ub3BUeXBlPVwiXCIsbi5kb2NTdHJpbmc9XCJcIixuLmRvbWFpbj1cIlwiKSxlLmlucHV0JiZlLmlucHV0Lmxlbmd0aCl7bi5pbnB1dD1bXTtmb3IodmFyIHI9MDtyPGUuaW5wdXQubGVuZ3RoOysrciluLmlucHV0W3JdPWUuaW5wdXRbcl19aWYoZS5vdXRwdXQmJmUub3V0cHV0Lmxlbmd0aClmb3Iobi5vdXRwdXQ9W10scj0wO3I8ZS5vdXRwdXQubGVuZ3RoOysrciluLm91dHB1dFtyXT1lLm91dHB1dFtyXTtpZihudWxsIT1lLm5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYobi5uYW1lPWUubmFtZSksbnVsbCE9ZS5vcFR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJvcFR5cGVcIikmJihuLm9wVHlwZT1lLm9wVHlwZSksZS5hdHRyaWJ1dGUmJmUuYXR0cmlidXRlLmxlbmd0aClmb3Iobi5hdHRyaWJ1dGU9W10scj0wO3I8ZS5hdHRyaWJ1dGUubGVuZ3RoOysrciluLmF0dHJpYnV0ZVtyXT1jLm9ubnguQXR0cmlidXRlUHJvdG8udG9PYmplY3QoZS5hdHRyaWJ1dGVbcl0sdCk7cmV0dXJuIG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9ZS5kb2NTdHJpbmcpLG51bGwhPWUuZG9tYWluJiZlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYobi5kb21haW49ZS5kb21haW4pLG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSxlfSgpLGkuTW9kZWxQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYodGhpcy5vcHNldEltcG9ydD1bXSx0aGlzLm1ldGFkYXRhUHJvcHM9W10sZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXJldHVybiBlLnByb3RvdHlwZS5pclZlcnNpb249bC5Mb25nP2wuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsZS5wcm90b3R5cGUub3BzZXRJbXBvcnQ9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLnByb2R1Y2VyTmFtZT1cIlwiLGUucHJvdG90eXBlLnByb2R1Y2VyVmVyc2lvbj1cIlwiLGUucHJvdG90eXBlLmRvbWFpbj1cIlwiLGUucHJvdG90eXBlLm1vZGVsVmVyc2lvbj1sLkxvbmc/bC5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCxlLnByb3RvdHlwZS5kb2NTdHJpbmc9XCJcIixlLnByb3RvdHlwZS5ncmFwaD1udWxsLGUucHJvdG90eXBlLm1ldGFkYXRhUHJvcHM9bC5lbXB0eUFycmF5LGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtpZih0fHwodD11LmNyZWF0ZSgpKSxudWxsIT1lLmlyVmVyc2lvbiYmZS5oYXNPd25Qcm9wZXJ0eShcImlyVmVyc2lvblwiKSYmdC51aW50MzIoOCkuaW50NjQoZS5pclZlcnNpb24pLG51bGwhPWUucHJvZHVjZXJOYW1lJiZlLmhhc093blByb3BlcnR5KFwicHJvZHVjZXJOYW1lXCIpJiZ0LnVpbnQzMigxOCkuc3RyaW5nKGUucHJvZHVjZXJOYW1lKSxudWxsIT1lLnByb2R1Y2VyVmVyc2lvbiYmZS5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyVmVyc2lvblwiKSYmdC51aW50MzIoMjYpLnN0cmluZyhlLnByb2R1Y2VyVmVyc2lvbiksbnVsbCE9ZS5kb21haW4mJmUuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJnQudWludDMyKDM0KS5zdHJpbmcoZS5kb21haW4pLG51bGwhPWUubW9kZWxWZXJzaW9uJiZlLmhhc093blByb3BlcnR5KFwibW9kZWxWZXJzaW9uXCIpJiZ0LnVpbnQzMig0MCkuaW50NjQoZS5tb2RlbFZlcnNpb24pLG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiZ0LnVpbnQzMig1MCkuc3RyaW5nKGUuZG9jU3RyaW5nKSxudWxsIT1lLmdyYXBoJiZlLmhhc093blByb3BlcnR5KFwiZ3JhcGhcIikmJmMub25ueC5HcmFwaFByb3RvLmVuY29kZShlLmdyYXBoLHQudWludDMyKDU4KS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPWUub3BzZXRJbXBvcnQmJmUub3BzZXRJbXBvcnQubGVuZ3RoKWZvcih2YXIgbj0wO248ZS5vcHNldEltcG9ydC5sZW5ndGg7KytuKWMub25ueC5PcGVyYXRvclNldElkUHJvdG8uZW5jb2RlKGUub3BzZXRJbXBvcnRbbl0sdC51aW50MzIoNjYpLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9ZS5tZXRhZGF0YVByb3BzJiZlLm1ldGFkYXRhUHJvcHMubGVuZ3RoKWZvcihuPTA7bjxlLm1ldGFkYXRhUHJvcHMubGVuZ3RoOysrbiljLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUoZS5tZXRhZGF0YVByb3BzW25dLHQudWludDMyKDExNCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2Ygc3x8KGU9cy5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54Lk1vZGVsUHJvdG87ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci5pclZlcnNpb249ZS5pbnQ2NCgpO2JyZWFrO2Nhc2UgODpyLm9wc2V0SW1wb3J0JiZyLm9wc2V0SW1wb3J0Lmxlbmd0aHx8KHIub3BzZXRJbXBvcnQ9W10pLHIub3BzZXRJbXBvcnQucHVzaChjLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVhaztjYXNlIDI6ci5wcm9kdWNlck5hbWU9ZS5zdHJpbmcoKTticmVhaztjYXNlIDM6ci5wcm9kdWNlclZlcnNpb249ZS5zdHJpbmcoKTticmVhaztjYXNlIDQ6ci5kb21haW49ZS5zdHJpbmcoKTticmVhaztjYXNlIDU6ci5tb2RlbFZlcnNpb249ZS5pbnQ2NCgpO2JyZWFrO2Nhc2UgNjpyLmRvY1N0cmluZz1lLnN0cmluZygpO2JyZWFrO2Nhc2UgNzpyLmdyYXBoPWMub25ueC5HcmFwaFByb3RvLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2Nhc2UgMTQ6ci5tZXRhZGF0YVByb3BzJiZyLm1ldGFkYXRhUHJvcHMubGVuZ3RofHwoci5tZXRhZGF0YVByb3BzPVtdKSxyLm1ldGFkYXRhUHJvcHMucHVzaChjLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbyl9fXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHN8fChlPW5ldyBzKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWUpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmlyVmVyc2lvbiYmZS5oYXNPd25Qcm9wZXJ0eShcImlyVmVyc2lvblwiKSYmIShsLmlzSW50ZWdlcihlLmlyVmVyc2lvbil8fGUuaXJWZXJzaW9uJiZsLmlzSW50ZWdlcihlLmlyVmVyc2lvbi5sb3cpJiZsLmlzSW50ZWdlcihlLmlyVmVyc2lvbi5oaWdoKSkpcmV0dXJuXCJpclZlcnNpb246IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO2lmKG51bGwhPWUub3BzZXRJbXBvcnQmJmUuaGFzT3duUHJvcGVydHkoXCJvcHNldEltcG9ydFwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5vcHNldEltcG9ydCkpcmV0dXJuXCJvcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHQ9MDt0PGUub3BzZXRJbXBvcnQubGVuZ3RoOysrdClpZihuPWMub25ueC5PcGVyYXRvclNldElkUHJvdG8udmVyaWZ5KGUub3BzZXRJbXBvcnRbdF0pKXJldHVyblwib3BzZXRJbXBvcnQuXCIrbn1pZihudWxsIT1lLnByb2R1Y2VyTmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyTmFtZVwiKSYmIWwuaXNTdHJpbmcoZS5wcm9kdWNlck5hbWUpKXJldHVyblwicHJvZHVjZXJOYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLnByb2R1Y2VyVmVyc2lvbiYmZS5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyVmVyc2lvblwiKSYmIWwuaXNTdHJpbmcoZS5wcm9kdWNlclZlcnNpb24pKXJldHVyblwicHJvZHVjZXJWZXJzaW9uOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmRvbWFpbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmIWwuaXNTdHJpbmcoZS5kb21haW4pKXJldHVyblwiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLm1vZGVsVmVyc2lvbiYmZS5oYXNPd25Qcm9wZXJ0eShcIm1vZGVsVmVyc2lvblwiKSYmIShsLmlzSW50ZWdlcihlLm1vZGVsVmVyc2lvbil8fGUubW9kZWxWZXJzaW9uJiZsLmlzSW50ZWdlcihlLm1vZGVsVmVyc2lvbi5sb3cpJiZsLmlzSW50ZWdlcihlLm1vZGVsVmVyc2lvbi5oaWdoKSkpcmV0dXJuXCJtb2RlbFZlcnNpb246IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO2lmKG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhbC5pc1N0cmluZyhlLmRvY1N0cmluZykpcmV0dXJuXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPWUuZ3JhcGgmJmUuaGFzT3duUHJvcGVydHkoXCJncmFwaFwiKSYmKG49Yy5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KGUuZ3JhcGgpKSlyZXR1cm5cImdyYXBoLlwiK247aWYobnVsbCE9ZS5tZXRhZGF0YVByb3BzJiZlLmhhc093blByb3BlcnR5KFwibWV0YWRhdGFQcm9wc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5tZXRhZGF0YVByb3BzKSlyZXR1cm5cIm1ldGFkYXRhUHJvcHM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHQ9MDt0PGUubWV0YWRhdGFQcm9wcy5sZW5ndGg7Kyt0KXt2YXIgbjtpZihuPWMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShlLm1ldGFkYXRhUHJvcHNbdF0pKXJldHVyblwibWV0YWRhdGFQcm9wcy5cIitufX1yZXR1cm4gbnVsbH0sZS5mcm9tT2JqZWN0PWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBjLm9ubnguTW9kZWxQcm90bylyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54Lk1vZGVsUHJvdG87aWYobnVsbCE9ZS5pclZlcnNpb24mJihsLkxvbmc/KHQuaXJWZXJzaW9uPWwuTG9uZy5mcm9tVmFsdWUoZS5pclZlcnNpb24pKS51bnNpZ25lZD0hMTpcInN0cmluZ1wiPT10eXBlb2YgZS5pclZlcnNpb24/dC5pclZlcnNpb249cGFyc2VJbnQoZS5pclZlcnNpb24sMTApOlwibnVtYmVyXCI9PXR5cGVvZiBlLmlyVmVyc2lvbj90LmlyVmVyc2lvbj1lLmlyVmVyc2lvbjpcIm9iamVjdFwiPT10eXBlb2YgZS5pclZlcnNpb24mJih0LmlyVmVyc2lvbj1uZXcgbC5Mb25nQml0cyhlLmlyVmVyc2lvbi5sb3c+Pj4wLGUuaXJWZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpKSksZS5vcHNldEltcG9ydCl7aWYoIUFycmF5LmlzQXJyYXkoZS5vcHNldEltcG9ydCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIik7dC5vcHNldEltcG9ydD1bXTtmb3IodmFyIG49MDtuPGUub3BzZXRJbXBvcnQubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUub3BzZXRJbXBvcnRbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogb2JqZWN0IGV4cGVjdGVkXCIpO3Qub3BzZXRJbXBvcnRbbl09Yy5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5mcm9tT2JqZWN0KGUub3BzZXRJbXBvcnRbbl0pfX1pZihudWxsIT1lLnByb2R1Y2VyTmFtZSYmKHQucHJvZHVjZXJOYW1lPVN0cmluZyhlLnByb2R1Y2VyTmFtZSkpLG51bGwhPWUucHJvZHVjZXJWZXJzaW9uJiYodC5wcm9kdWNlclZlcnNpb249U3RyaW5nKGUucHJvZHVjZXJWZXJzaW9uKSksbnVsbCE9ZS5kb21haW4mJih0LmRvbWFpbj1TdHJpbmcoZS5kb21haW4pKSxudWxsIT1lLm1vZGVsVmVyc2lvbiYmKGwuTG9uZz8odC5tb2RlbFZlcnNpb249bC5Mb25nLmZyb21WYWx1ZShlLm1vZGVsVmVyc2lvbikpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLm1vZGVsVmVyc2lvbj90Lm1vZGVsVmVyc2lvbj1wYXJzZUludChlLm1vZGVsVmVyc2lvbiwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUubW9kZWxWZXJzaW9uP3QubW9kZWxWZXJzaW9uPWUubW9kZWxWZXJzaW9uOlwib2JqZWN0XCI9PXR5cGVvZiBlLm1vZGVsVmVyc2lvbiYmKHQubW9kZWxWZXJzaW9uPW5ldyBsLkxvbmdCaXRzKGUubW9kZWxWZXJzaW9uLmxvdz4+PjAsZS5tb2RlbFZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCkpKSxudWxsIT1lLmRvY1N0cmluZyYmKHQuZG9jU3RyaW5nPVN0cmluZyhlLmRvY1N0cmluZykpLG51bGwhPWUuZ3JhcGgpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLmdyYXBoKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8uZ3JhcGg6IG9iamVjdCBleHBlY3RlZFwiKTt0LmdyYXBoPWMub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3QoZS5ncmFwaCl9aWYoZS5tZXRhZGF0YVByb3BzKXtpZighQXJyYXkuaXNBcnJheShlLm1ldGFkYXRhUHJvcHMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8ubWV0YWRhdGFQcm9wczogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQubWV0YWRhdGFQcm9wcz1bXSxuPTA7bjxlLm1ldGFkYXRhUHJvcHMubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUubWV0YWRhdGFQcm9wc1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLm1ldGFkYXRhUHJvcHM6IG9iamVjdCBleHBlY3RlZFwiKTt0Lm1ldGFkYXRhUHJvcHNbbl09Yy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdChlLm1ldGFkYXRhUHJvcHNbbl0pfX1yZXR1cm4gdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtpZigodC5hcnJheXN8fHQuZGVmYXVsdHMpJiYobi5vcHNldEltcG9ydD1bXSxuLm1ldGFkYXRhUHJvcHM9W10pLHQuZGVmYXVsdHMpe2lmKGwuTG9uZyl7dmFyIHI9bmV3IGwuTG9uZygwLDAsITEpO24uaXJWZXJzaW9uPXQubG9uZ3M9PT1TdHJpbmc/ci50b1N0cmluZygpOnQubG9uZ3M9PT1OdW1iZXI/ci50b051bWJlcigpOnJ9ZWxzZSBuLmlyVmVyc2lvbj10LmxvbmdzPT09U3RyaW5nP1wiMFwiOjA7bi5wcm9kdWNlck5hbWU9XCJcIixuLnByb2R1Y2VyVmVyc2lvbj1cIlwiLG4uZG9tYWluPVwiXCIsbC5Mb25nPyhyPW5ldyBsLkxvbmcoMCwwLCExKSxuLm1vZGVsVmVyc2lvbj10LmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTp0LmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyKTpuLm1vZGVsVmVyc2lvbj10LmxvbmdzPT09U3RyaW5nP1wiMFwiOjAsbi5kb2NTdHJpbmc9XCJcIixuLmdyYXBoPW51bGx9aWYobnVsbCE9ZS5pclZlcnNpb24mJmUuaGFzT3duUHJvcGVydHkoXCJpclZlcnNpb25cIikmJihcIm51bWJlclwiPT10eXBlb2YgZS5pclZlcnNpb24/bi5pclZlcnNpb249dC5sb25ncz09PVN0cmluZz9TdHJpbmcoZS5pclZlcnNpb24pOmUuaXJWZXJzaW9uOm4uaXJWZXJzaW9uPXQubG9uZ3M9PT1TdHJpbmc/bC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUuaXJWZXJzaW9uKTp0LmxvbmdzPT09TnVtYmVyP25ldyBsLkxvbmdCaXRzKGUuaXJWZXJzaW9uLmxvdz4+PjAsZS5pclZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCk6ZS5pclZlcnNpb24pLG51bGwhPWUucHJvZHVjZXJOYW1lJiZlLmhhc093blByb3BlcnR5KFwicHJvZHVjZXJOYW1lXCIpJiYobi5wcm9kdWNlck5hbWU9ZS5wcm9kdWNlck5hbWUpLG51bGwhPWUucHJvZHVjZXJWZXJzaW9uJiZlLmhhc093blByb3BlcnR5KFwicHJvZHVjZXJWZXJzaW9uXCIpJiYobi5wcm9kdWNlclZlcnNpb249ZS5wcm9kdWNlclZlcnNpb24pLG51bGwhPWUuZG9tYWluJiZlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYobi5kb21haW49ZS5kb21haW4pLG51bGwhPWUubW9kZWxWZXJzaW9uJiZlLmhhc093blByb3BlcnR5KFwibW9kZWxWZXJzaW9uXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIGUubW9kZWxWZXJzaW9uP24ubW9kZWxWZXJzaW9uPXQubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKGUubW9kZWxWZXJzaW9uKTplLm1vZGVsVmVyc2lvbjpuLm1vZGVsVmVyc2lvbj10LmxvbmdzPT09U3RyaW5nP2wuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlLm1vZGVsVmVyc2lvbik6dC5sb25ncz09PU51bWJlcj9uZXcgbC5Mb25nQml0cyhlLm1vZGVsVmVyc2lvbi5sb3c+Pj4wLGUubW9kZWxWZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpOmUubW9kZWxWZXJzaW9uKSxudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmKG4uZG9jU3RyaW5nPWUuZG9jU3RyaW5nKSxudWxsIT1lLmdyYXBoJiZlLmhhc093blByb3BlcnR5KFwiZ3JhcGhcIikmJihuLmdyYXBoPWMub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KGUuZ3JhcGgsdCkpLGUub3BzZXRJbXBvcnQmJmUub3BzZXRJbXBvcnQubGVuZ3RoKXtuLm9wc2V0SW1wb3J0PVtdO2Zvcih2YXIgbz0wO288ZS5vcHNldEltcG9ydC5sZW5ndGg7KytvKW4ub3BzZXRJbXBvcnRbb109Yy5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by50b09iamVjdChlLm9wc2V0SW1wb3J0W29dLHQpfWlmKGUubWV0YWRhdGFQcm9wcyYmZS5tZXRhZGF0YVByb3BzLmxlbmd0aClmb3Iobi5tZXRhZGF0YVByb3BzPVtdLG89MDtvPGUubWV0YWRhdGFQcm9wcy5sZW5ndGg7KytvKW4ubWV0YWRhdGFQcm9wc1tvXT1jLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdChlLm1ldGFkYXRhUHJvcHNbb10sdCk7cmV0dXJuIG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSxlfSgpLGkuU3RyaW5nU3RyaW5nRW50cnlQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYoZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXJldHVybiBlLnByb3RvdHlwZS5rZXk9XCJcIixlLnByb3RvdHlwZS52YWx1ZT1cIlwiLGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8KHQ9dS5jcmVhdGUoKSksbnVsbCE9ZS5rZXkmJmUuaGFzT3duUHJvcGVydHkoXCJrZXlcIikmJnQudWludDMyKDEwKS5zdHJpbmcoZS5rZXkpLG51bGwhPWUudmFsdWUmJmUuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSYmdC51aW50MzIoMTgpLnN0cmluZyhlLnZhbHVlKSx0fSxlLmVuY29kZURlbGltaXRlZD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVuY29kZShlLHQpLmxkZWxpbSgpfSxlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiBzfHwoZT1zLmNyZWF0ZShlKSk7Zm9yKHZhciBuPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyBjLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90bztlLnBvczxuOyl7dmFyIG89ZS51aW50MzIoKTtzd2l0Y2gobz4+PjMpe2Nhc2UgMTpyLmtleT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMjpyLnZhbHVlPWUuc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbyl9fXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHN8fChlPW5ldyBzKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtyZXR1cm5cIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWU/XCJvYmplY3QgZXhwZWN0ZWRcIjpudWxsIT1lLmtleSYmZS5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSYmIWwuaXNTdHJpbmcoZS5rZXkpP1wia2V5OiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsIT1lLnZhbHVlJiZlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikmJiFsLmlzU3RyaW5nKGUudmFsdWUpP1widmFsdWU6IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8pcmV0dXJuIGU7dmFyIHQ9bmV3IGMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvO3JldHVybiBudWxsIT1lLmtleSYmKHQua2V5PVN0cmluZyhlLmtleSkpLG51bGwhPWUudmFsdWUmJih0LnZhbHVlPVN0cmluZyhlLnZhbHVlKSksdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtyZXR1cm4gdC5kZWZhdWx0cyYmKG4ua2V5PVwiXCIsbi52YWx1ZT1cIlwiKSxudWxsIT1lLmtleSYmZS5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSYmKG4ua2V5PWUua2V5KSxudWxsIT1lLnZhbHVlJiZlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikmJihuLnZhbHVlPWUudmFsdWUpLG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSxlfSgpLGkuVGVuc29yQW5ub3RhdGlvbj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYodGhpcy5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPVtdLGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLG49MDtuPHQubGVuZ3RoOysrbiludWxsIT1lW3Rbbl1dJiYodGhpc1t0W25dXT1lW3Rbbl1dKX1yZXR1cm4gZS5wcm90b3R5cGUudGVuc29yTmFtZT1cIlwiLGUucHJvdG90eXBlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9bC5lbXB0eUFycmF5LGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtpZih0fHwodD11LmNyZWF0ZSgpKSxudWxsIT1lLnRlbnNvck5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JOYW1lXCIpJiZ0LnVpbnQzMigxMCkuc3RyaW5nKGUudGVuc29yTmFtZSksbnVsbCE9ZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzJiZlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoKWZvcih2YXIgbj0wO248ZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK24pYy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlKGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXSx0LnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2Ygc3x8KGU9cy5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54LlRlbnNvckFubm90YXRpb247ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci50ZW5zb3JOYW1lPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyOnIucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmci5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aHx8KHIucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1bXSksci5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLnB1c2goYy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm8pfX1yZXR1cm4gcn0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBzfHwoZT1uZXcgcyhlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9ZS50ZW5zb3JOYW1lJiZlLmhhc093blByb3BlcnR5KFwidGVuc29yTmFtZVwiKSYmIWwuaXNTdHJpbmcoZS50ZW5zb3JOYW1lKSlyZXR1cm5cInRlbnNvck5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPWUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmZS5oYXNPd25Qcm9wZXJ0eShcInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNcIikpe2lmKCFBcnJheS5pc0FycmF5KGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcykpcmV0dXJuXCJxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgdD0wO3Q8ZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK3Qpe3ZhciBuPWMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbdF0pO2lmKG4pcmV0dXJuXCJxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLlwiK259fXJldHVybiBudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5UZW5zb3JBbm5vdGF0aW9uKXJldHVybiBlO3ZhciB0PW5ldyBjLm9ubnguVGVuc29yQW5ub3RhdGlvbjtpZihudWxsIT1lLnRlbnNvck5hbWUmJih0LnRlbnNvck5hbWU9U3RyaW5nKGUudGVuc29yTmFtZSkpLGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyl7aWYoIUFycmF5LmlzQXJyYXkoZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JBbm5vdGF0aW9uLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM6IGFycmF5IGV4cGVjdGVkXCIpO3QucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1bXTtmb3IodmFyIG49MDtuPGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvckFubm90YXRpb24ucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lczogb2JqZWN0IGV4cGVjdGVkXCIpO3QucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXT1jLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXSl9fXJldHVybiB0fSxlLnRvT2JqZWN0PWZ1bmN0aW9uKGUsdCl7dHx8KHQ9e30pO3ZhciBuPXt9O2lmKCh0LmFycmF5c3x8dC5kZWZhdWx0cykmJihuLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9W10pLHQuZGVmYXVsdHMmJihuLnRlbnNvck5hbWU9XCJcIiksbnVsbCE9ZS50ZW5zb3JOYW1lJiZlLmhhc093blByb3BlcnR5KFwidGVuc29yTmFtZVwiKSYmKG4udGVuc29yTmFtZT1lLnRlbnNvck5hbWUpLGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aCl7bi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPVtdO2Zvcih2YXIgcj0wO3I8ZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK3Ipbi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW3JdPWMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tyXSx0KX1yZXR1cm4gbn0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LGV9KCksaS5HcmFwaFByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZih0aGlzLm5vZGU9W10sdGhpcy5pbml0aWFsaXplcj1bXSx0aGlzLmlucHV0PVtdLHRoaXMub3V0cHV0PVtdLHRoaXMudmFsdWVJbmZvPVtdLHRoaXMucXVhbnRpemF0aW9uQW5ub3RhdGlvbj1bXSxlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxuPTA7bjx0Lmxlbmd0aDsrK24pbnVsbCE9ZVt0W25dXSYmKHRoaXNbdFtuXV09ZVt0W25dXSl9cmV0dXJuIGUucHJvdG90eXBlLm5vZGU9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLm5hbWU9XCJcIixlLnByb3RvdHlwZS5pbml0aWFsaXplcj1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsZS5wcm90b3R5cGUuaW5wdXQ9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLm91dHB1dD1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUudmFsdWVJbmZvPWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uPWwuZW1wdHlBcnJheSxlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7aWYodHx8KHQ9dS5jcmVhdGUoKSksbnVsbCE9ZS5ub2RlJiZlLm5vZGUubGVuZ3RoKWZvcih2YXIgbj0wO248ZS5ub2RlLmxlbmd0aDsrK24pYy5vbm54Lk5vZGVQcm90by5lbmNvZGUoZS5ub2RlW25dLHQudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPWUubmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJnQudWludDMyKDE4KS5zdHJpbmcoZS5uYW1lKSxudWxsIT1lLmluaXRpYWxpemVyJiZlLmluaXRpYWxpemVyLmxlbmd0aClmb3Iobj0wO248ZS5pbml0aWFsaXplci5sZW5ndGg7KytuKWMub25ueC5UZW5zb3JQcm90by5lbmNvZGUoZS5pbml0aWFsaXplcltuXSx0LnVpbnQzMig0MikuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmdC51aW50MzIoODIpLnN0cmluZyhlLmRvY1N0cmluZyksbnVsbCE9ZS5pbnB1dCYmZS5pbnB1dC5sZW5ndGgpZm9yKG49MDtuPGUuaW5wdXQubGVuZ3RoOysrbiljLm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKGUuaW5wdXRbbl0sdC51aW50MzIoOTApLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9ZS5vdXRwdXQmJmUub3V0cHV0Lmxlbmd0aClmb3Iobj0wO248ZS5vdXRwdXQubGVuZ3RoOysrbiljLm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKGUub3V0cHV0W25dLHQudWludDMyKDk4KS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPWUudmFsdWVJbmZvJiZlLnZhbHVlSW5mby5sZW5ndGgpZm9yKG49MDtuPGUudmFsdWVJbmZvLmxlbmd0aDsrK24pYy5vbm54LlZhbHVlSW5mb1Byb3RvLmVuY29kZShlLnZhbHVlSW5mb1tuXSx0LnVpbnQzMigxMDYpLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9ZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uJiZlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoKWZvcihuPTA7bjxlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOysrbiljLm9ubnguVGVuc29yQW5ub3RhdGlvbi5lbmNvZGUoZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW25dLHQudWludDMyKDExNCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2Ygc3x8KGU9cy5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54LkdyYXBoUHJvdG87ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci5ub2RlJiZyLm5vZGUubGVuZ3RofHwoci5ub2RlPVtdKSxyLm5vZGUucHVzaChjLm9ubnguTm9kZVByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVhaztjYXNlIDI6ci5uYW1lPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSA1OnIuaW5pdGlhbGl6ZXImJnIuaW5pdGlhbGl6ZXIubGVuZ3RofHwoci5pbml0aWFsaXplcj1bXSksci5pbml0aWFsaXplci5wdXNoKGMub25ueC5UZW5zb3JQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxMDpyLmRvY1N0cmluZz1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMTE6ci5pbnB1dCYmci5pbnB1dC5sZW5ndGh8fChyLmlucHV0PVtdKSxyLmlucHV0LnB1c2goYy5vbm54LlZhbHVlSW5mb1Byb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVhaztjYXNlIDEyOnIub3V0cHV0JiZyLm91dHB1dC5sZW5ndGh8fChyLm91dHB1dD1bXSksci5vdXRwdXQucHVzaChjLm9ubnguVmFsdWVJbmZvUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMTM6ci52YWx1ZUluZm8mJnIudmFsdWVJbmZvLmxlbmd0aHx8KHIudmFsdWVJbmZvPVtdKSxyLnZhbHVlSW5mby5wdXNoKGMub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxNDpyLnF1YW50aXphdGlvbkFubm90YXRpb24mJnIucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGh8fChyLnF1YW50aXphdGlvbkFubm90YXRpb249W10pLHIucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5wdXNoKGMub25ueC5UZW5zb3JBbm5vdGF0aW9uLmRlY29kZShlLGUudWludDMyKCkpKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZvKX19cmV0dXJuIHJ9LGUuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2Ygc3x8KGU9bmV3IHMoZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LGUudmVyaWZ5PWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZSlyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPWUubm9kZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm5vZGVcIikpe2lmKCFBcnJheS5pc0FycmF5KGUubm9kZSkpcmV0dXJuXCJub2RlOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgdD0wO3Q8ZS5ub2RlLmxlbmd0aDsrK3QpaWYobj1jLm9ubnguTm9kZVByb3RvLnZlcmlmeShlLm5vZGVbdF0pKXJldHVyblwibm9kZS5cIitufWlmKG51bGwhPWUubmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFsLmlzU3RyaW5nKGUubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmluaXRpYWxpemVyJiZlLmhhc093blByb3BlcnR5KFwiaW5pdGlhbGl6ZXJcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuaW5pdGlhbGl6ZXIpKXJldHVyblwiaW5pdGlhbGl6ZXI6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHQ9MDt0PGUuaW5pdGlhbGl6ZXIubGVuZ3RoOysrdClpZihuPWMub25ueC5UZW5zb3JQcm90by52ZXJpZnkoZS5pbml0aWFsaXplclt0XSkpcmV0dXJuXCJpbml0aWFsaXplci5cIitufWlmKG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhbC5pc1N0cmluZyhlLmRvY1N0cmluZykpcmV0dXJuXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPWUuaW5wdXQmJmUuaGFzT3duUHJvcGVydHkoXCJpbnB1dFwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5pbnB1dCkpcmV0dXJuXCJpbnB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5pbnB1dC5sZW5ndGg7Kyt0KWlmKG49Yy5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeShlLmlucHV0W3RdKSlyZXR1cm5cImlucHV0LlwiK259aWYobnVsbCE9ZS5vdXRwdXQmJmUuaGFzT3duUHJvcGVydHkoXCJvdXRwdXRcIikpe2lmKCFBcnJheS5pc0FycmF5KGUub3V0cHV0KSlyZXR1cm5cIm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5vdXRwdXQubGVuZ3RoOysrdClpZihuPWMub25ueC5WYWx1ZUluZm9Qcm90by52ZXJpZnkoZS5vdXRwdXRbdF0pKXJldHVyblwib3V0cHV0LlwiK259aWYobnVsbCE9ZS52YWx1ZUluZm8mJmUuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZUluZm9cIikpe2lmKCFBcnJheS5pc0FycmF5KGUudmFsdWVJbmZvKSlyZXR1cm5cInZhbHVlSW5mbzogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS52YWx1ZUluZm8ubGVuZ3RoOysrdClpZihuPWMub25ueC5WYWx1ZUluZm9Qcm90by52ZXJpZnkoZS52YWx1ZUluZm9bdF0pKXJldHVyblwidmFsdWVJbmZvLlwiK259aWYobnVsbCE9ZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uJiZlLmhhc093blByb3BlcnR5KFwicXVhbnRpemF0aW9uQW5ub3RhdGlvblwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uKSlyZXR1cm5cInF1YW50aXphdGlvbkFubm90YXRpb246IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHQ9MDt0PGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGg7Kyt0KXt2YXIgbjtpZihuPWMub25ueC5UZW5zb3JBbm5vdGF0aW9uLnZlcmlmeShlLnF1YW50aXphdGlvbkFubm90YXRpb25bdF0pKXJldHVyblwicXVhbnRpemF0aW9uQW5ub3RhdGlvbi5cIitufX1yZXR1cm4gbnVsbH0sZS5mcm9tT2JqZWN0PWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBjLm9ubnguR3JhcGhQcm90bylyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54LkdyYXBoUHJvdG87aWYoZS5ub2RlKXtpZighQXJyYXkuaXNBcnJheShlLm5vZGUpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ubm9kZTogYXJyYXkgZXhwZWN0ZWRcIik7dC5ub2RlPVtdO2Zvcih2YXIgbj0wO248ZS5ub2RlLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLm5vZGVbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5ub2RlOiBvYmplY3QgZXhwZWN0ZWRcIik7dC5ub2RlW25dPWMub25ueC5Ob2RlUHJvdG8uZnJvbU9iamVjdChlLm5vZGVbbl0pfX1pZihudWxsIT1lLm5hbWUmJih0Lm5hbWU9U3RyaW5nKGUubmFtZSkpLGUuaW5pdGlhbGl6ZXIpe2lmKCFBcnJheS5pc0FycmF5KGUuaW5pdGlhbGl6ZXIpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5pdGlhbGl6ZXI6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LmluaXRpYWxpemVyPVtdLG49MDtuPGUuaW5pdGlhbGl6ZXIubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuaW5pdGlhbGl6ZXJbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbml0aWFsaXplcjogb2JqZWN0IGV4cGVjdGVkXCIpO3QuaW5pdGlhbGl6ZXJbbl09Yy5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3QoZS5pbml0aWFsaXplcltuXSl9fWlmKG51bGwhPWUuZG9jU3RyaW5nJiYodC5kb2NTdHJpbmc9U3RyaW5nKGUuZG9jU3RyaW5nKSksZS5pbnB1dCl7aWYoIUFycmF5LmlzQXJyYXkoZS5pbnB1dCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbnB1dDogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuaW5wdXQ9W10sbj0wO248ZS5pbnB1dC5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5pbnB1dFtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLmlucHV0OiBvYmplY3QgZXhwZWN0ZWRcIik7dC5pbnB1dFtuXT1jLm9ubnguVmFsdWVJbmZvUHJvdG8uZnJvbU9iamVjdChlLmlucHV0W25dKX19aWYoZS5vdXRwdXQpe2lmKCFBcnJheS5pc0FycmF5KGUub3V0cHV0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQub3V0cHV0PVtdLG49MDtuPGUub3V0cHV0Lmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLm91dHB1dFtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm91dHB1dDogb2JqZWN0IGV4cGVjdGVkXCIpO3Qub3V0cHV0W25dPWMub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KGUub3V0cHV0W25dKX19aWYoZS52YWx1ZUluZm8pe2lmKCFBcnJheS5pc0FycmF5KGUudmFsdWVJbmZvKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnZhbHVlSW5mbzogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQudmFsdWVJbmZvPVtdLG49MDtuPGUudmFsdWVJbmZvLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLnZhbHVlSW5mb1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnZhbHVlSW5mbzogb2JqZWN0IGV4cGVjdGVkXCIpO3QudmFsdWVJbmZvW25dPWMub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KGUudmFsdWVJbmZvW25dKX19aWYoZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uKXtpZighQXJyYXkuaXNBcnJheShlLnF1YW50aXphdGlvbkFubm90YXRpb24pKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ucXVhbnRpemF0aW9uQW5ub3RhdGlvbjogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbj1bXSxuPTA7bjxlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbltuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnF1YW50aXphdGlvbkFubm90YXRpb246IG9iamVjdCBleHBlY3RlZFwiKTt0LnF1YW50aXphdGlvbkFubm90YXRpb25bbl09Yy5vbm54LlRlbnNvckFubm90YXRpb24uZnJvbU9iamVjdChlLnF1YW50aXphdGlvbkFubm90YXRpb25bbl0pfX1yZXR1cm4gdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtpZigodC5hcnJheXN8fHQuZGVmYXVsdHMpJiYobi5ub2RlPVtdLG4uaW5pdGlhbGl6ZXI9W10sbi5pbnB1dD1bXSxuLm91dHB1dD1bXSxuLnZhbHVlSW5mbz1bXSxuLnF1YW50aXphdGlvbkFubm90YXRpb249W10pLHQuZGVmYXVsdHMmJihuLm5hbWU9XCJcIixuLmRvY1N0cmluZz1cIlwiKSxlLm5vZGUmJmUubm9kZS5sZW5ndGgpe24ubm9kZT1bXTtmb3IodmFyIHI9MDtyPGUubm9kZS5sZW5ndGg7KytyKW4ubm9kZVtyXT1jLm9ubnguTm9kZVByb3RvLnRvT2JqZWN0KGUubm9kZVtyXSx0KX1pZihudWxsIT1lLm5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYobi5uYW1lPWUubmFtZSksZS5pbml0aWFsaXplciYmZS5pbml0aWFsaXplci5sZW5ndGgpZm9yKG4uaW5pdGlhbGl6ZXI9W10scj0wO3I8ZS5pbml0aWFsaXplci5sZW5ndGg7KytyKW4uaW5pdGlhbGl6ZXJbcl09Yy5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KGUuaW5pdGlhbGl6ZXJbcl0sdCk7aWYobnVsbCE9ZS5kb2NTdHJpbmcmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz1lLmRvY1N0cmluZyksZS5pbnB1dCYmZS5pbnB1dC5sZW5ndGgpZm9yKG4uaW5wdXQ9W10scj0wO3I8ZS5pbnB1dC5sZW5ndGg7KytyKW4uaW5wdXRbcl09Yy5vbm54LlZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0KGUuaW5wdXRbcl0sdCk7aWYoZS5vdXRwdXQmJmUub3V0cHV0Lmxlbmd0aClmb3Iobi5vdXRwdXQ9W10scj0wO3I8ZS5vdXRwdXQubGVuZ3RoOysrciluLm91dHB1dFtyXT1jLm9ubnguVmFsdWVJbmZvUHJvdG8udG9PYmplY3QoZS5vdXRwdXRbcl0sdCk7aWYoZS52YWx1ZUluZm8mJmUudmFsdWVJbmZvLmxlbmd0aClmb3Iobi52YWx1ZUluZm89W10scj0wO3I8ZS52YWx1ZUluZm8ubGVuZ3RoOysrciluLnZhbHVlSW5mb1tyXT1jLm9ubnguVmFsdWVJbmZvUHJvdG8udG9PYmplY3QoZS52YWx1ZUluZm9bcl0sdCk7aWYoZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uJiZlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoKWZvcihuLnF1YW50aXphdGlvbkFubm90YXRpb249W10scj0wO3I8ZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsrK3Ipbi5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW3JdPWMub25ueC5UZW5zb3JBbm5vdGF0aW9uLnRvT2JqZWN0KGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbltyXSx0KTtyZXR1cm4gbn0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LGV9KCksaS5UZW5zb3JQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYodGhpcy5kaW1zPVtdLHRoaXMuZmxvYXREYXRhPVtdLHRoaXMuaW50MzJEYXRhPVtdLHRoaXMuc3RyaW5nRGF0YT1bXSx0aGlzLmludDY0RGF0YT1bXSx0aGlzLmV4dGVybmFsRGF0YT1bXSx0aGlzLmRvdWJsZURhdGE9W10sdGhpcy51aW50NjREYXRhPVtdLGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLG49MDtuPHQubGVuZ3RoOysrbiludWxsIT1lW3Rbbl1dJiYodGhpc1t0W25dXT1lW3Rbbl1dKX1yZXR1cm4gZS5wcm90b3R5cGUuZGltcz1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuZGF0YVR5cGU9MCxlLnByb3RvdHlwZS5zZWdtZW50PW51bGwsZS5wcm90b3R5cGUuZmxvYXREYXRhPWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5pbnQzMkRhdGE9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLnN0cmluZ0RhdGE9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLmludDY0RGF0YT1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUubmFtZT1cIlwiLGUucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLGUucHJvdG90eXBlLnJhd0RhdGE9bC5uZXdCdWZmZXIoW10pLGUucHJvdG90eXBlLmV4dGVybmFsRGF0YT1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuZGF0YUxvY2F0aW9uPTAsZS5wcm90b3R5cGUuZG91YmxlRGF0YT1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUudWludDY0RGF0YT1sLmVtcHR5QXJyYXksZS5jcmVhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpfSxlLmVuY29kZT1mdW5jdGlvbihlLHQpe2lmKHR8fCh0PXUuY3JlYXRlKCkpLG51bGwhPWUuZGltcyYmZS5kaW1zLmxlbmd0aCl7dC51aW50MzIoMTApLmZvcmsoKTtmb3IodmFyIG49MDtuPGUuZGltcy5sZW5ndGg7KytuKXQuaW50NjQoZS5kaW1zW25dKTt0LmxkZWxpbSgpfWlmKG51bGwhPWUuZGF0YVR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJkYXRhVHlwZVwiKSYmdC51aW50MzIoMTYpLmludDMyKGUuZGF0YVR5cGUpLG51bGwhPWUuc2VnbWVudCYmZS5oYXNPd25Qcm9wZXJ0eShcInNlZ21lbnRcIikmJmMub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmVuY29kZShlLnNlZ21lbnQsdC51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCksbnVsbCE9ZS5mbG9hdERhdGEmJmUuZmxvYXREYXRhLmxlbmd0aCl7Zm9yKHQudWludDMyKDM0KS5mb3JrKCksbj0wO248ZS5mbG9hdERhdGEubGVuZ3RoOysrbil0LmZsb2F0KGUuZmxvYXREYXRhW25dKTt0LmxkZWxpbSgpfWlmKG51bGwhPWUuaW50MzJEYXRhJiZlLmludDMyRGF0YS5sZW5ndGgpe2Zvcih0LnVpbnQzMig0MikuZm9yaygpLG49MDtuPGUuaW50MzJEYXRhLmxlbmd0aDsrK24pdC5pbnQzMihlLmludDMyRGF0YVtuXSk7dC5sZGVsaW0oKX1pZihudWxsIT1lLnN0cmluZ0RhdGEmJmUuc3RyaW5nRGF0YS5sZW5ndGgpZm9yKG49MDtuPGUuc3RyaW5nRGF0YS5sZW5ndGg7KytuKXQudWludDMyKDUwKS5ieXRlcyhlLnN0cmluZ0RhdGFbbl0pO2lmKG51bGwhPWUuaW50NjREYXRhJiZlLmludDY0RGF0YS5sZW5ndGgpe2Zvcih0LnVpbnQzMig1OCkuZm9yaygpLG49MDtuPGUuaW50NjREYXRhLmxlbmd0aDsrK24pdC5pbnQ2NChlLmludDY0RGF0YVtuXSk7dC5sZGVsaW0oKX1pZihudWxsIT1lLm5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiZ0LnVpbnQzMig2Nikuc3RyaW5nKGUubmFtZSksbnVsbCE9ZS5yYXdEYXRhJiZlLmhhc093blByb3BlcnR5KFwicmF3RGF0YVwiKSYmdC51aW50MzIoNzQpLmJ5dGVzKGUucmF3RGF0YSksbnVsbCE9ZS5kb3VibGVEYXRhJiZlLmRvdWJsZURhdGEubGVuZ3RoKXtmb3IodC51aW50MzIoODIpLmZvcmsoKSxuPTA7bjxlLmRvdWJsZURhdGEubGVuZ3RoOysrbil0LmRvdWJsZShlLmRvdWJsZURhdGFbbl0pO3QubGRlbGltKCl9aWYobnVsbCE9ZS51aW50NjREYXRhJiZlLnVpbnQ2NERhdGEubGVuZ3RoKXtmb3IodC51aW50MzIoOTApLmZvcmsoKSxuPTA7bjxlLnVpbnQ2NERhdGEubGVuZ3RoOysrbil0LnVpbnQ2NChlLnVpbnQ2NERhdGFbbl0pO3QubGRlbGltKCl9aWYobnVsbCE9ZS5kb2NTdHJpbmcmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJnQudWludDMyKDk4KS5zdHJpbmcoZS5kb2NTdHJpbmcpLG51bGwhPWUuZXh0ZXJuYWxEYXRhJiZlLmV4dGVybmFsRGF0YS5sZW5ndGgpZm9yKG49MDtuPGUuZXh0ZXJuYWxEYXRhLmxlbmd0aDsrK24pYy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlKGUuZXh0ZXJuYWxEYXRhW25dLHQudWludDMyKDEwNikuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gbnVsbCE9ZS5kYXRhTG9jYXRpb24mJmUuaGFzT3duUHJvcGVydHkoXCJkYXRhTG9jYXRpb25cIikmJnQudWludDMyKDExMikuaW50MzIoZS5kYXRhTG9jYXRpb24pLHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIHN8fChlPXMuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5UZW5zb3JQcm90bztlLnBvczxuOyl7dmFyIG89ZS51aW50MzIoKTtzd2l0Y2gobz4+PjMpe2Nhc2UgMTppZihyLmRpbXMmJnIuZGltcy5sZW5ndGh8fChyLmRpbXM9W10pLDI9PSg3Jm8pKWZvcih2YXIgaT1lLnVpbnQzMigpK2UucG9zO2UucG9zPGk7KXIuZGltcy5wdXNoKGUuaW50NjQoKSk7ZWxzZSByLmRpbXMucHVzaChlLmludDY0KCkpO2JyZWFrO2Nhc2UgMjpyLmRhdGFUeXBlPWUuaW50MzIoKTticmVhaztjYXNlIDM6ci5zZWdtZW50PWMub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2Nhc2UgNDppZihyLmZsb2F0RGF0YSYmci5mbG9hdERhdGEubGVuZ3RofHwoci5mbG9hdERhdGE9W10pLDI9PSg3Jm8pKWZvcihpPWUudWludDMyKCkrZS5wb3M7ZS5wb3M8aTspci5mbG9hdERhdGEucHVzaChlLmZsb2F0KCkpO2Vsc2Ugci5mbG9hdERhdGEucHVzaChlLmZsb2F0KCkpO2JyZWFrO2Nhc2UgNTppZihyLmludDMyRGF0YSYmci5pbnQzMkRhdGEubGVuZ3RofHwoci5pbnQzMkRhdGE9W10pLDI9PSg3Jm8pKWZvcihpPWUudWludDMyKCkrZS5wb3M7ZS5wb3M8aTspci5pbnQzMkRhdGEucHVzaChlLmludDMyKCkpO2Vsc2Ugci5pbnQzMkRhdGEucHVzaChlLmludDMyKCkpO2JyZWFrO2Nhc2UgNjpyLnN0cmluZ0RhdGEmJnIuc3RyaW5nRGF0YS5sZW5ndGh8fChyLnN0cmluZ0RhdGE9W10pLHIuc3RyaW5nRGF0YS5wdXNoKGUuYnl0ZXMoKSk7YnJlYWs7Y2FzZSA3OmlmKHIuaW50NjREYXRhJiZyLmludDY0RGF0YS5sZW5ndGh8fChyLmludDY0RGF0YT1bXSksMj09KDcmbykpZm9yKGk9ZS51aW50MzIoKStlLnBvcztlLnBvczxpOylyLmludDY0RGF0YS5wdXNoKGUuaW50NjQoKSk7ZWxzZSByLmludDY0RGF0YS5wdXNoKGUuaW50NjQoKSk7YnJlYWs7Y2FzZSA4OnIubmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMTI6ci5kb2NTdHJpbmc9ZS5zdHJpbmcoKTticmVhaztjYXNlIDk6ci5yYXdEYXRhPWUuYnl0ZXMoKTticmVhaztjYXNlIDEzOnIuZXh0ZXJuYWxEYXRhJiZyLmV4dGVybmFsRGF0YS5sZW5ndGh8fChyLmV4dGVybmFsRGF0YT1bXSksci5leHRlcm5hbERhdGEucHVzaChjLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxNDpyLmRhdGFMb2NhdGlvbj1lLmludDMyKCk7YnJlYWs7Y2FzZSAxMDppZihyLmRvdWJsZURhdGEmJnIuZG91YmxlRGF0YS5sZW5ndGh8fChyLmRvdWJsZURhdGE9W10pLDI9PSg3Jm8pKWZvcihpPWUudWludDMyKCkrZS5wb3M7ZS5wb3M8aTspci5kb3VibGVEYXRhLnB1c2goZS5kb3VibGUoKSk7ZWxzZSByLmRvdWJsZURhdGEucHVzaChlLmRvdWJsZSgpKTticmVhaztjYXNlIDExOmlmKHIudWludDY0RGF0YSYmci51aW50NjREYXRhLmxlbmd0aHx8KHIudWludDY0RGF0YT1bXSksMj09KDcmbykpZm9yKGk9ZS51aW50MzIoKStlLnBvcztlLnBvczxpOylyLnVpbnQ2NERhdGEucHVzaChlLnVpbnQ2NCgpKTtlbHNlIHIudWludDY0RGF0YS5wdXNoKGUudWludDY0KCkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm8pfX1yZXR1cm4gcn0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBzfHwoZT1uZXcgcyhlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5kaW1zJiZlLmhhc093blByb3BlcnR5KFwiZGltc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5kaW1zKSlyZXR1cm5cImRpbXM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciB0PTA7dDxlLmRpbXMubGVuZ3RoOysrdClpZighKGwuaXNJbnRlZ2VyKGUuZGltc1t0XSl8fGUuZGltc1t0XSYmbC5pc0ludGVnZXIoZS5kaW1zW3RdLmxvdykmJmwuaXNJbnRlZ2VyKGUuZGltc1t0XS5oaWdoKSkpcmV0dXJuXCJkaW1zOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPWUuZGF0YVR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJkYXRhVHlwZVwiKSYmIWwuaXNJbnRlZ2VyKGUuZGF0YVR5cGUpKXJldHVyblwiZGF0YVR5cGU6IGludGVnZXIgZXhwZWN0ZWRcIjtpZihudWxsIT1lLnNlZ21lbnQmJmUuaGFzT3duUHJvcGVydHkoXCJzZWdtZW50XCIpJiYobj1jLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC52ZXJpZnkoZS5zZWdtZW50KSkpcmV0dXJuXCJzZWdtZW50LlwiK247aWYobnVsbCE9ZS5mbG9hdERhdGEmJmUuaGFzT3duUHJvcGVydHkoXCJmbG9hdERhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuZmxvYXREYXRhKSlyZXR1cm5cImZsb2F0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5mbG9hdERhdGEubGVuZ3RoOysrdClpZihcIm51bWJlclwiIT10eXBlb2YgZS5mbG9hdERhdGFbdF0pcmV0dXJuXCJmbG9hdERhdGE6IG51bWJlcltdIGV4cGVjdGVkXCJ9aWYobnVsbCE9ZS5pbnQzMkRhdGEmJmUuaGFzT3duUHJvcGVydHkoXCJpbnQzMkRhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuaW50MzJEYXRhKSlyZXR1cm5cImludDMyRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5pbnQzMkRhdGEubGVuZ3RoOysrdClpZighbC5pc0ludGVnZXIoZS5pbnQzMkRhdGFbdF0pKXJldHVyblwiaW50MzJEYXRhOiBpbnRlZ2VyW10gZXhwZWN0ZWRcIn1pZihudWxsIT1lLnN0cmluZ0RhdGEmJmUuaGFzT3duUHJvcGVydHkoXCJzdHJpbmdEYXRhXCIpKXtpZighQXJyYXkuaXNBcnJheShlLnN0cmluZ0RhdGEpKXJldHVyblwic3RyaW5nRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5zdHJpbmdEYXRhLmxlbmd0aDsrK3QpaWYoIShlLnN0cmluZ0RhdGFbdF0mJlwibnVtYmVyXCI9PXR5cGVvZiBlLnN0cmluZ0RhdGFbdF0ubGVuZ3RofHxsLmlzU3RyaW5nKGUuc3RyaW5nRGF0YVt0XSkpKXJldHVyblwic3RyaW5nRGF0YTogYnVmZmVyW10gZXhwZWN0ZWRcIn1pZihudWxsIT1lLmludDY0RGF0YSYmZS5oYXNPd25Qcm9wZXJ0eShcImludDY0RGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5pbnQ2NERhdGEpKXJldHVyblwiaW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLmludDY0RGF0YS5sZW5ndGg7Kyt0KWlmKCEobC5pc0ludGVnZXIoZS5pbnQ2NERhdGFbdF0pfHxlLmludDY0RGF0YVt0XSYmbC5pc0ludGVnZXIoZS5pbnQ2NERhdGFbdF0ubG93KSYmbC5pc0ludGVnZXIoZS5pbnQ2NERhdGFbdF0uaGlnaCkpKXJldHVyblwiaW50NjREYXRhOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPWUubmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFsLmlzU3RyaW5nKGUubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmIWwuaXNTdHJpbmcoZS5kb2NTdHJpbmcpKXJldHVyblwiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLnJhd0RhdGEmJmUuaGFzT3duUHJvcGVydHkoXCJyYXdEYXRhXCIpJiYhKGUucmF3RGF0YSYmXCJudW1iZXJcIj09dHlwZW9mIGUucmF3RGF0YS5sZW5ndGh8fGwuaXNTdHJpbmcoZS5yYXdEYXRhKSkpcmV0dXJuXCJyYXdEYXRhOiBidWZmZXIgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmV4dGVybmFsRGF0YSYmZS5oYXNPd25Qcm9wZXJ0eShcImV4dGVybmFsRGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5leHRlcm5hbERhdGEpKXJldHVyblwiZXh0ZXJuYWxEYXRhOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLmV4dGVybmFsRGF0YS5sZW5ndGg7Kyt0KXt2YXIgbjtpZihuPWMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShlLmV4dGVybmFsRGF0YVt0XSkpcmV0dXJuXCJleHRlcm5hbERhdGEuXCIrbn19aWYobnVsbCE9ZS5kYXRhTG9jYXRpb24mJmUuaGFzT3duUHJvcGVydHkoXCJkYXRhTG9jYXRpb25cIikpc3dpdGNoKGUuZGF0YUxvY2F0aW9uKXtkZWZhdWx0OnJldHVyblwiZGF0YUxvY2F0aW9uOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7Y2FzZSAwOmNhc2UgMTp9aWYobnVsbCE9ZS5kb3VibGVEYXRhJiZlLmhhc093blByb3BlcnR5KFwiZG91YmxlRGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5kb3VibGVEYXRhKSlyZXR1cm5cImRvdWJsZURhdGE6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHQ9MDt0PGUuZG91YmxlRGF0YS5sZW5ndGg7Kyt0KWlmKFwibnVtYmVyXCIhPXR5cGVvZiBlLmRvdWJsZURhdGFbdF0pcmV0dXJuXCJkb3VibGVEYXRhOiBudW1iZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPWUudWludDY0RGF0YSYmZS5oYXNPd25Qcm9wZXJ0eShcInVpbnQ2NERhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KGUudWludDY0RGF0YSkpcmV0dXJuXCJ1aW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLnVpbnQ2NERhdGEubGVuZ3RoOysrdClpZighKGwuaXNJbnRlZ2VyKGUudWludDY0RGF0YVt0XSl8fGUudWludDY0RGF0YVt0XSYmbC5pc0ludGVnZXIoZS51aW50NjREYXRhW3RdLmxvdykmJmwuaXNJbnRlZ2VyKGUudWludDY0RGF0YVt0XS5oaWdoKSkpcmV0dXJuXCJ1aW50NjREYXRhOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifXJldHVybiBudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5UZW5zb3JQcm90bylyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54LlRlbnNvclByb3RvO2lmKGUuZGltcyl7aWYoIUFycmF5LmlzQXJyYXkoZS5kaW1zKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5kaW1zOiBhcnJheSBleHBlY3RlZFwiKTt0LmRpbXM9W107Zm9yKHZhciBuPTA7bjxlLmRpbXMubGVuZ3RoOysrbilsLkxvbmc/KHQuZGltc1tuXT1sLkxvbmcuZnJvbVZhbHVlKGUuZGltc1tuXSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLmRpbXNbbl0/dC5kaW1zW25dPXBhcnNlSW50KGUuZGltc1tuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUuZGltc1tuXT90LmRpbXNbbl09ZS5kaW1zW25dOlwib2JqZWN0XCI9PXR5cGVvZiBlLmRpbXNbbl0mJih0LmRpbXNbbl09bmV3IGwuTG9uZ0JpdHMoZS5kaW1zW25dLmxvdz4+PjAsZS5kaW1zW25dLmhpZ2g+Pj4wKS50b051bWJlcigpKX1pZihudWxsIT1lLmRhdGFUeXBlJiYodC5kYXRhVHlwZT0wfGUuZGF0YVR5cGUpLG51bGwhPWUuc2VnbWVudCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuc2VnbWVudCl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5zZWdtZW50OiBvYmplY3QgZXhwZWN0ZWRcIik7dC5zZWdtZW50PWMub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmZyb21PYmplY3QoZS5zZWdtZW50KX1pZihlLmZsb2F0RGF0YSl7aWYoIUFycmF5LmlzQXJyYXkoZS5mbG9hdERhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmZsb2F0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuZmxvYXREYXRhPVtdLG49MDtuPGUuZmxvYXREYXRhLmxlbmd0aDsrK24pdC5mbG9hdERhdGFbbl09TnVtYmVyKGUuZmxvYXREYXRhW25dKX1pZihlLmludDMyRGF0YSl7aWYoIUFycmF5LmlzQXJyYXkoZS5pbnQzMkRhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmludDMyRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuaW50MzJEYXRhPVtdLG49MDtuPGUuaW50MzJEYXRhLmxlbmd0aDsrK24pdC5pbnQzMkRhdGFbbl09MHxlLmludDMyRGF0YVtuXX1pZihlLnN0cmluZ0RhdGEpe2lmKCFBcnJheS5pc0FycmF5KGUuc3RyaW5nRGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uc3RyaW5nRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuc3RyaW5nRGF0YT1bXSxuPTA7bjxlLnN0cmluZ0RhdGEubGVuZ3RoOysrbilcInN0cmluZ1wiPT10eXBlb2YgZS5zdHJpbmdEYXRhW25dP2wuYmFzZTY0LmRlY29kZShlLnN0cmluZ0RhdGFbbl0sdC5zdHJpbmdEYXRhW25dPWwubmV3QnVmZmVyKGwuYmFzZTY0Lmxlbmd0aChlLnN0cmluZ0RhdGFbbl0pKSwwKTplLnN0cmluZ0RhdGFbbl0ubGVuZ3RoJiYodC5zdHJpbmdEYXRhW25dPWUuc3RyaW5nRGF0YVtuXSl9aWYoZS5pbnQ2NERhdGEpe2lmKCFBcnJheS5pc0FycmF5KGUuaW50NjREYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5pbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LmludDY0RGF0YT1bXSxuPTA7bjxlLmludDY0RGF0YS5sZW5ndGg7KytuKWwuTG9uZz8odC5pbnQ2NERhdGFbbl09bC5Mb25nLmZyb21WYWx1ZShlLmludDY0RGF0YVtuXSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLmludDY0RGF0YVtuXT90LmludDY0RGF0YVtuXT1wYXJzZUludChlLmludDY0RGF0YVtuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUuaW50NjREYXRhW25dP3QuaW50NjREYXRhW25dPWUuaW50NjREYXRhW25dOlwib2JqZWN0XCI9PXR5cGVvZiBlLmludDY0RGF0YVtuXSYmKHQuaW50NjREYXRhW25dPW5ldyBsLkxvbmdCaXRzKGUuaW50NjREYXRhW25dLmxvdz4+PjAsZS5pbnQ2NERhdGFbbl0uaGlnaD4+PjApLnRvTnVtYmVyKCkpfWlmKG51bGwhPWUubmFtZSYmKHQubmFtZT1TdHJpbmcoZS5uYW1lKSksbnVsbCE9ZS5kb2NTdHJpbmcmJih0LmRvY1N0cmluZz1TdHJpbmcoZS5kb2NTdHJpbmcpKSxudWxsIT1lLnJhd0RhdGEmJihcInN0cmluZ1wiPT10eXBlb2YgZS5yYXdEYXRhP2wuYmFzZTY0LmRlY29kZShlLnJhd0RhdGEsdC5yYXdEYXRhPWwubmV3QnVmZmVyKGwuYmFzZTY0Lmxlbmd0aChlLnJhd0RhdGEpKSwwKTplLnJhd0RhdGEubGVuZ3RoJiYodC5yYXdEYXRhPWUucmF3RGF0YSkpLGUuZXh0ZXJuYWxEYXRhKXtpZighQXJyYXkuaXNBcnJheShlLmV4dGVybmFsRGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZXh0ZXJuYWxEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IodC5leHRlcm5hbERhdGE9W10sbj0wO248ZS5leHRlcm5hbERhdGEubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuZXh0ZXJuYWxEYXRhW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmV4dGVybmFsRGF0YTogb2JqZWN0IGV4cGVjdGVkXCIpO3QuZXh0ZXJuYWxEYXRhW25dPWMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3QoZS5leHRlcm5hbERhdGFbbl0pfX1zd2l0Y2goZS5kYXRhTG9jYXRpb24pe2Nhc2VcIkRFRkFVTFRcIjpjYXNlIDA6dC5kYXRhTG9jYXRpb249MDticmVhaztjYXNlXCJFWFRFUk5BTFwiOmNhc2UgMTp0LmRhdGFMb2NhdGlvbj0xfWlmKGUuZG91YmxlRGF0YSl7aWYoIUFycmF5LmlzQXJyYXkoZS5kb3VibGVEYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5kb3VibGVEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IodC5kb3VibGVEYXRhPVtdLG49MDtuPGUuZG91YmxlRGF0YS5sZW5ndGg7KytuKXQuZG91YmxlRGF0YVtuXT1OdW1iZXIoZS5kb3VibGVEYXRhW25dKX1pZihlLnVpbnQ2NERhdGEpe2lmKCFBcnJheS5pc0FycmF5KGUudWludDY0RGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8udWludDY0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQudWludDY0RGF0YT1bXSxuPTA7bjxlLnVpbnQ2NERhdGEubGVuZ3RoOysrbilsLkxvbmc/KHQudWludDY0RGF0YVtuXT1sLkxvbmcuZnJvbVZhbHVlKGUudWludDY0RGF0YVtuXSkpLnVuc2lnbmVkPSEwOlwic3RyaW5nXCI9PXR5cGVvZiBlLnVpbnQ2NERhdGFbbl0/dC51aW50NjREYXRhW25dPXBhcnNlSW50KGUudWludDY0RGF0YVtuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUudWludDY0RGF0YVtuXT90LnVpbnQ2NERhdGFbbl09ZS51aW50NjREYXRhW25dOlwib2JqZWN0XCI9PXR5cGVvZiBlLnVpbnQ2NERhdGFbbl0mJih0LnVpbnQ2NERhdGFbbl09bmV3IGwuTG9uZ0JpdHMoZS51aW50NjREYXRhW25dLmxvdz4+PjAsZS51aW50NjREYXRhW25dLmhpZ2g+Pj4wKS50b051bWJlcighMCkpfXJldHVybiB0fSxlLnRvT2JqZWN0PWZ1bmN0aW9uKGUsdCl7dHx8KHQ9e30pO3ZhciBuPXt9O2lmKCh0LmFycmF5c3x8dC5kZWZhdWx0cykmJihuLmRpbXM9W10sbi5mbG9hdERhdGE9W10sbi5pbnQzMkRhdGE9W10sbi5zdHJpbmdEYXRhPVtdLG4uaW50NjREYXRhPVtdLG4uZG91YmxlRGF0YT1bXSxuLnVpbnQ2NERhdGE9W10sbi5leHRlcm5hbERhdGE9W10pLHQuZGVmYXVsdHMmJihuLmRhdGFUeXBlPTAsbi5zZWdtZW50PW51bGwsbi5uYW1lPVwiXCIsdC5ieXRlcz09PVN0cmluZz9uLnJhd0RhdGE9XCJcIjoobi5yYXdEYXRhPVtdLHQuYnl0ZXMhPT1BcnJheSYmKG4ucmF3RGF0YT1sLm5ld0J1ZmZlcihuLnJhd0RhdGEpKSksbi5kb2NTdHJpbmc9XCJcIixuLmRhdGFMb2NhdGlvbj10LmVudW1zPT09U3RyaW5nP1wiREVGQVVMVFwiOjApLGUuZGltcyYmZS5kaW1zLmxlbmd0aCl7bi5kaW1zPVtdO2Zvcih2YXIgcj0wO3I8ZS5kaW1zLmxlbmd0aDsrK3IpXCJudW1iZXJcIj09dHlwZW9mIGUuZGltc1tyXT9uLmRpbXNbcl09dC5sb25ncz09PVN0cmluZz9TdHJpbmcoZS5kaW1zW3JdKTplLmRpbXNbcl06bi5kaW1zW3JdPXQubG9uZ3M9PT1TdHJpbmc/bC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUuZGltc1tyXSk6dC5sb25ncz09PU51bWJlcj9uZXcgbC5Mb25nQml0cyhlLmRpbXNbcl0ubG93Pj4+MCxlLmRpbXNbcl0uaGlnaD4+PjApLnRvTnVtYmVyKCk6ZS5kaW1zW3JdfWlmKG51bGwhPWUuZGF0YVR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJkYXRhVHlwZVwiKSYmKG4uZGF0YVR5cGU9ZS5kYXRhVHlwZSksbnVsbCE9ZS5zZWdtZW50JiZlLmhhc093blByb3BlcnR5KFwic2VnbWVudFwiKSYmKG4uc2VnbWVudD1jLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC50b09iamVjdChlLnNlZ21lbnQsdCkpLGUuZmxvYXREYXRhJiZlLmZsb2F0RGF0YS5sZW5ndGgpZm9yKG4uZmxvYXREYXRhPVtdLHI9MDtyPGUuZmxvYXREYXRhLmxlbmd0aDsrK3Ipbi5mbG9hdERhdGFbcl09dC5qc29uJiYhaXNGaW5pdGUoZS5mbG9hdERhdGFbcl0pP1N0cmluZyhlLmZsb2F0RGF0YVtyXSk6ZS5mbG9hdERhdGFbcl07aWYoZS5pbnQzMkRhdGEmJmUuaW50MzJEYXRhLmxlbmd0aClmb3Iobi5pbnQzMkRhdGE9W10scj0wO3I8ZS5pbnQzMkRhdGEubGVuZ3RoOysrciluLmludDMyRGF0YVtyXT1lLmludDMyRGF0YVtyXTtpZihlLnN0cmluZ0RhdGEmJmUuc3RyaW5nRGF0YS5sZW5ndGgpZm9yKG4uc3RyaW5nRGF0YT1bXSxyPTA7cjxlLnN0cmluZ0RhdGEubGVuZ3RoOysrciluLnN0cmluZ0RhdGFbcl09dC5ieXRlcz09PVN0cmluZz9sLmJhc2U2NC5lbmNvZGUoZS5zdHJpbmdEYXRhW3JdLDAsZS5zdHJpbmdEYXRhW3JdLmxlbmd0aCk6dC5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUuc3RyaW5nRGF0YVtyXSk6ZS5zdHJpbmdEYXRhW3JdO2lmKGUuaW50NjREYXRhJiZlLmludDY0RGF0YS5sZW5ndGgpZm9yKG4uaW50NjREYXRhPVtdLHI9MDtyPGUuaW50NjREYXRhLmxlbmd0aDsrK3IpXCJudW1iZXJcIj09dHlwZW9mIGUuaW50NjREYXRhW3JdP24uaW50NjREYXRhW3JdPXQubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKGUuaW50NjREYXRhW3JdKTplLmludDY0RGF0YVtyXTpuLmludDY0RGF0YVtyXT10LmxvbmdzPT09U3RyaW5nP2wuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlLmludDY0RGF0YVtyXSk6dC5sb25ncz09PU51bWJlcj9uZXcgbC5Mb25nQml0cyhlLmludDY0RGF0YVtyXS5sb3c+Pj4wLGUuaW50NjREYXRhW3JdLmhpZ2g+Pj4wKS50b051bWJlcigpOmUuaW50NjREYXRhW3JdO2lmKG51bGwhPWUubmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJihuLm5hbWU9ZS5uYW1lKSxudWxsIT1lLnJhd0RhdGEmJmUuaGFzT3duUHJvcGVydHkoXCJyYXdEYXRhXCIpJiYobi5yYXdEYXRhPXQuYnl0ZXM9PT1TdHJpbmc/bC5iYXNlNjQuZW5jb2RlKGUucmF3RGF0YSwwLGUucmF3RGF0YS5sZW5ndGgpOnQuYnl0ZXM9PT1BcnJheT9BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLnJhd0RhdGEpOmUucmF3RGF0YSksZS5kb3VibGVEYXRhJiZlLmRvdWJsZURhdGEubGVuZ3RoKWZvcihuLmRvdWJsZURhdGE9W10scj0wO3I8ZS5kb3VibGVEYXRhLmxlbmd0aDsrK3Ipbi5kb3VibGVEYXRhW3JdPXQuanNvbiYmIWlzRmluaXRlKGUuZG91YmxlRGF0YVtyXSk/U3RyaW5nKGUuZG91YmxlRGF0YVtyXSk6ZS5kb3VibGVEYXRhW3JdO2lmKGUudWludDY0RGF0YSYmZS51aW50NjREYXRhLmxlbmd0aClmb3Iobi51aW50NjREYXRhPVtdLHI9MDtyPGUudWludDY0RGF0YS5sZW5ndGg7KytyKVwibnVtYmVyXCI9PXR5cGVvZiBlLnVpbnQ2NERhdGFbcl0/bi51aW50NjREYXRhW3JdPXQubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKGUudWludDY0RGF0YVtyXSk6ZS51aW50NjREYXRhW3JdOm4udWludDY0RGF0YVtyXT10LmxvbmdzPT09U3RyaW5nP2wuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlLnVpbnQ2NERhdGFbcl0pOnQubG9uZ3M9PT1OdW1iZXI/bmV3IGwuTG9uZ0JpdHMoZS51aW50NjREYXRhW3JdLmxvdz4+PjAsZS51aW50NjREYXRhW3JdLmhpZ2g+Pj4wKS50b051bWJlcighMCk6ZS51aW50NjREYXRhW3JdO2lmKG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9ZS5kb2NTdHJpbmcpLGUuZXh0ZXJuYWxEYXRhJiZlLmV4dGVybmFsRGF0YS5sZW5ndGgpZm9yKG4uZXh0ZXJuYWxEYXRhPVtdLHI9MDtyPGUuZXh0ZXJuYWxEYXRhLmxlbmd0aDsrK3Ipbi5leHRlcm5hbERhdGFbcl09Yy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QoZS5leHRlcm5hbERhdGFbcl0sdCk7cmV0dXJuIG51bGwhPWUuZGF0YUxvY2F0aW9uJiZlLmhhc093blByb3BlcnR5KFwiZGF0YUxvY2F0aW9uXCIpJiYobi5kYXRhTG9jYXRpb249dC5lbnVtcz09PVN0cmluZz9jLm9ubnguVGVuc29yUHJvdG8uRGF0YUxvY2F0aW9uW2UuZGF0YUxvY2F0aW9uXTplLmRhdGFMb2NhdGlvbiksbn0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LGUuRGF0YVR5cGU9ZnVuY3Rpb24oKXt2YXIgZT17fSx0PU9iamVjdC5jcmVhdGUoZSk7cmV0dXJuIHRbZVswXT1cIlVOREVGSU5FRFwiXT0wLHRbZVsxXT1cIkZMT0FUXCJdPTEsdFtlWzJdPVwiVUlOVDhcIl09Mix0W2VbM109XCJJTlQ4XCJdPTMsdFtlWzRdPVwiVUlOVDE2XCJdPTQsdFtlWzVdPVwiSU5UMTZcIl09NSx0W2VbNl09XCJJTlQzMlwiXT02LHRbZVs3XT1cIklOVDY0XCJdPTcsdFtlWzhdPVwiU1RSSU5HXCJdPTgsdFtlWzldPVwiQk9PTFwiXT05LHRbZVsxMF09XCJGTE9BVDE2XCJdPTEwLHRbZVsxMV09XCJET1VCTEVcIl09MTEsdFtlWzEyXT1cIlVJTlQzMlwiXT0xMix0W2VbMTNdPVwiVUlOVDY0XCJdPTEzLHRbZVsxNF09XCJDT01QTEVYNjRcIl09MTQsdFtlWzE1XT1cIkNPTVBMRVgxMjhcIl09MTUsdFtlWzE2XT1cIkJGTE9BVDE2XCJdPTE2LHR9KCksZS5TZWdtZW50PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZihlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxuPTA7bjx0Lmxlbmd0aDsrK24pbnVsbCE9ZVt0W25dXSYmKHRoaXNbdFtuXV09ZVt0W25dXSl9cmV0dXJuIGUucHJvdG90eXBlLmJlZ2luPWwuTG9uZz9sLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLGUucHJvdG90eXBlLmVuZD1sLkxvbmc/bC5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCxlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fCh0PXUuY3JlYXRlKCkpLG51bGwhPWUuYmVnaW4mJmUuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSYmdC51aW50MzIoOCkuaW50NjQoZS5iZWdpbiksbnVsbCE9ZS5lbmQmJmUuaGFzT3duUHJvcGVydHkoXCJlbmRcIikmJnQudWludDMyKDE2KS5pbnQ2NChlLmVuZCksdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2Ygc3x8KGU9cy5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQ7ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci5iZWdpbj1lLmludDY0KCk7YnJlYWs7Y2FzZSAyOnIuZW5kPWUuaW50NjQoKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZvKX19cmV0dXJuIHJ9LGUuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2Ygc3x8KGU9bmV3IHMoZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LGUudmVyaWZ5PWZ1bmN0aW9uKGUpe3JldHVyblwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZT9cIm9iamVjdCBleHBlY3RlZFwiOm51bGwhPWUuYmVnaW4mJmUuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSYmIShsLmlzSW50ZWdlcihlLmJlZ2luKXx8ZS5iZWdpbiYmbC5pc0ludGVnZXIoZS5iZWdpbi5sb3cpJiZsLmlzSW50ZWdlcihlLmJlZ2luLmhpZ2gpKT9cImJlZ2luOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjpudWxsIT1lLmVuZCYmZS5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSYmIShsLmlzSW50ZWdlcihlLmVuZCl8fGUuZW5kJiZsLmlzSW50ZWdlcihlLmVuZC5sb3cpJiZsLmlzSW50ZWdlcihlLmVuZC5oaWdoKSk/XCJlbmQ6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiOm51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQpcmV0dXJuIGU7dmFyIHQ9bmV3IGMub25ueC5UZW5zb3JQcm90by5TZWdtZW50O3JldHVybiBudWxsIT1lLmJlZ2luJiYobC5Mb25nPyh0LmJlZ2luPWwuTG9uZy5mcm9tVmFsdWUoZS5iZWdpbikpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLmJlZ2luP3QuYmVnaW49cGFyc2VJbnQoZS5iZWdpbiwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUuYmVnaW4/dC5iZWdpbj1lLmJlZ2luOlwib2JqZWN0XCI9PXR5cGVvZiBlLmJlZ2luJiYodC5iZWdpbj1uZXcgbC5Mb25nQml0cyhlLmJlZ2luLmxvdz4+PjAsZS5iZWdpbi5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLG51bGwhPWUuZW5kJiYobC5Mb25nPyh0LmVuZD1sLkxvbmcuZnJvbVZhbHVlKGUuZW5kKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIGUuZW5kP3QuZW5kPXBhcnNlSW50KGUuZW5kLDEwKTpcIm51bWJlclwiPT10eXBlb2YgZS5lbmQ/dC5lbmQ9ZS5lbmQ6XCJvYmplY3RcIj09dHlwZW9mIGUuZW5kJiYodC5lbmQ9bmV3IGwuTG9uZ0JpdHMoZS5lbmQubG93Pj4+MCxlLmVuZC5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLHR9LGUudG9PYmplY3Q9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSk7dmFyIG49e307aWYodC5kZWZhdWx0cyl7aWYobC5Mb25nKXt2YXIgcj1uZXcgbC5Mb25nKDAsMCwhMSk7bi5iZWdpbj10LmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTp0LmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyfWVsc2Ugbi5iZWdpbj10LmxvbmdzPT09U3RyaW5nP1wiMFwiOjA7bC5Mb25nPyhyPW5ldyBsLkxvbmcoMCwwLCExKSxuLmVuZD10LmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTp0LmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyKTpuLmVuZD10LmxvbmdzPT09U3RyaW5nP1wiMFwiOjB9cmV0dXJuIG51bGwhPWUuYmVnaW4mJmUuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiBlLmJlZ2luP24uYmVnaW49dC5sb25ncz09PVN0cmluZz9TdHJpbmcoZS5iZWdpbik6ZS5iZWdpbjpuLmJlZ2luPXQubG9uZ3M9PT1TdHJpbmc/bC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUuYmVnaW4pOnQubG9uZ3M9PT1OdW1iZXI/bmV3IGwuTG9uZ0JpdHMoZS5iZWdpbi5sb3c+Pj4wLGUuYmVnaW4uaGlnaD4+PjApLnRvTnVtYmVyKCk6ZS5iZWdpbiksbnVsbCE9ZS5lbmQmJmUuaGFzT3duUHJvcGVydHkoXCJlbmRcIikmJihcIm51bWJlclwiPT10eXBlb2YgZS5lbmQ/bi5lbmQ9dC5sb25ncz09PVN0cmluZz9TdHJpbmcoZS5lbmQpOmUuZW5kOm4uZW5kPXQubG9uZ3M9PT1TdHJpbmc/bC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUuZW5kKTp0LmxvbmdzPT09TnVtYmVyP25ldyBsLkxvbmdCaXRzKGUuZW5kLmxvdz4+PjAsZS5lbmQuaGlnaD4+PjApLnRvTnVtYmVyKCk6ZS5lbmQpLG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSxlfSgpLGUuRGF0YUxvY2F0aW9uPWZ1bmN0aW9uKCl7dmFyIGU9e30sdD1PYmplY3QuY3JlYXRlKGUpO3JldHVybiB0W2VbMF09XCJERUZBVUxUXCJdPTAsdFtlWzFdPVwiRVhURVJOQUxcIl09MSx0fSgpLGV9KCksaS5UZW5zb3JTaGFwZVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZih0aGlzLmRpbT1bXSxlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxuPTA7bjx0Lmxlbmd0aDsrK24pbnVsbCE9ZVt0W25dXSYmKHRoaXNbdFtuXV09ZVt0W25dXSl9cmV0dXJuIGUucHJvdG90eXBlLmRpbT1sLmVtcHR5QXJyYXksZS5jcmVhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpfSxlLmVuY29kZT1mdW5jdGlvbihlLHQpe2lmKHR8fCh0PXUuY3JlYXRlKCkpLG51bGwhPWUuZGltJiZlLmRpbS5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLmRpbS5sZW5ndGg7KytuKWMub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi5lbmNvZGUoZS5kaW1bbl0sdC51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7cmV0dXJuIHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIHN8fChlPXMuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5UZW5zb3JTaGFwZVByb3RvO2UucG9zPG47KXt2YXIgbz1lLnVpbnQzMigpO28+Pj4zPT0xPyhyLmRpbSYmci5kaW0ubGVuZ3RofHwoci5kaW09W10pLHIuZGltLnB1c2goYy5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLmRlY29kZShlLGUudWludDMyKCkpKSk6ZS5za2lwVHlwZSg3Jm8pfXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHN8fChlPW5ldyBzKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWUpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmRpbSYmZS5oYXNPd25Qcm9wZXJ0eShcImRpbVwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5kaW0pKXJldHVyblwiZGltOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgdD0wO3Q8ZS5kaW0ubGVuZ3RoOysrdCl7dmFyIG49Yy5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnZlcmlmeShlLmRpbVt0XSk7aWYobilyZXR1cm5cImRpbS5cIitufX1yZXR1cm4gbnVsbH0sZS5mcm9tT2JqZWN0PWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBjLm9ubnguVGVuc29yU2hhcGVQcm90bylyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54LlRlbnNvclNoYXBlUHJvdG87aWYoZS5kaW0pe2lmKCFBcnJheS5pc0FycmF5KGUuZGltKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JTaGFwZVByb3RvLmRpbTogYXJyYXkgZXhwZWN0ZWRcIik7dC5kaW09W107Zm9yKHZhciBuPTA7bjxlLmRpbS5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5kaW1bbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yU2hhcGVQcm90by5kaW06IG9iamVjdCBleHBlY3RlZFwiKTt0LmRpbVtuXT1jLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24uZnJvbU9iamVjdChlLmRpbVtuXSl9fXJldHVybiB0fSxlLnRvT2JqZWN0PWZ1bmN0aW9uKGUsdCl7dHx8KHQ9e30pO3ZhciBuPXt9O2lmKCh0LmFycmF5c3x8dC5kZWZhdWx0cykmJihuLmRpbT1bXSksZS5kaW0mJmUuZGltLmxlbmd0aCl7bi5kaW09W107Zm9yKHZhciByPTA7cjxlLmRpbS5sZW5ndGg7KytyKW4uZGltW3JdPWMub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi50b09iamVjdChlLmRpbVtyXSx0KX1yZXR1cm4gbn0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LGUuRGltZW5zaW9uPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZihlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxuPTA7bjx0Lmxlbmd0aDsrK24pbnVsbCE9ZVt0W25dXSYmKHRoaXNbdFtuXV09ZVt0W25dXSl9dmFyIHQ7cmV0dXJuIGUucHJvdG90eXBlLmRpbVZhbHVlPWwuTG9uZz9sLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLGUucHJvdG90eXBlLmRpbVBhcmFtPVwiXCIsZS5wcm90b3R5cGUuZGVub3RhdGlvbj1cIlwiLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcInZhbHVlXCIse2dldDpsLm9uZU9mR2V0dGVyKHQ9W1wiZGltVmFsdWVcIixcImRpbVBhcmFtXCJdKSxzZXQ6bC5vbmVPZlNldHRlcih0KX0pLGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8KHQ9dS5jcmVhdGUoKSksbnVsbCE9ZS5kaW1WYWx1ZSYmZS5oYXNPd25Qcm9wZXJ0eShcImRpbVZhbHVlXCIpJiZ0LnVpbnQzMig4KS5pbnQ2NChlLmRpbVZhbHVlKSxudWxsIT1lLmRpbVBhcmFtJiZlLmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikmJnQudWludDMyKDE4KS5zdHJpbmcoZS5kaW1QYXJhbSksbnVsbCE9ZS5kZW5vdGF0aW9uJiZlLmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmdC51aW50MzIoMjYpLnN0cmluZyhlLmRlbm90YXRpb24pLHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIHN8fChlPXMuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbjtlLnBvczxuOyl7dmFyIG89ZS51aW50MzIoKTtzd2l0Y2gobz4+PjMpe2Nhc2UgMTpyLmRpbVZhbHVlPWUuaW50NjQoKTticmVhaztjYXNlIDI6ci5kaW1QYXJhbT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMzpyLmRlbm90YXRpb249ZS5zdHJpbmcoKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZvKX19cmV0dXJuIHJ9LGUuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2Ygc3x8KGU9bmV3IHMoZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LGUudmVyaWZ5PWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZSlyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO3ZhciB0PXt9O2lmKG51bGwhPWUuZGltVmFsdWUmJmUuaGFzT3duUHJvcGVydHkoXCJkaW1WYWx1ZVwiKSYmKHQudmFsdWU9MSwhKGwuaXNJbnRlZ2VyKGUuZGltVmFsdWUpfHxlLmRpbVZhbHVlJiZsLmlzSW50ZWdlcihlLmRpbVZhbHVlLmxvdykmJmwuaXNJbnRlZ2VyKGUuZGltVmFsdWUuaGlnaCkpKSlyZXR1cm5cImRpbVZhbHVlOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmRpbVBhcmFtJiZlLmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikpe2lmKDE9PT10LnZhbHVlKXJldHVyblwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO2lmKHQudmFsdWU9MSwhbC5pc1N0cmluZyhlLmRpbVBhcmFtKSlyZXR1cm5cImRpbVBhcmFtOiBzdHJpbmcgZXhwZWN0ZWRcIn1yZXR1cm4gbnVsbCE9ZS5kZW5vdGF0aW9uJiZlLmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmIWwuaXNTdHJpbmcoZS5kZW5vdGF0aW9uKT9cImRlbm90YXRpb246IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uKXJldHVybiBlO3ZhciB0PW5ldyBjLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb247cmV0dXJuIG51bGwhPWUuZGltVmFsdWUmJihsLkxvbmc/KHQuZGltVmFsdWU9bC5Mb25nLmZyb21WYWx1ZShlLmRpbVZhbHVlKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIGUuZGltVmFsdWU/dC5kaW1WYWx1ZT1wYXJzZUludChlLmRpbVZhbHVlLDEwKTpcIm51bWJlclwiPT10eXBlb2YgZS5kaW1WYWx1ZT90LmRpbVZhbHVlPWUuZGltVmFsdWU6XCJvYmplY3RcIj09dHlwZW9mIGUuZGltVmFsdWUmJih0LmRpbVZhbHVlPW5ldyBsLkxvbmdCaXRzKGUuZGltVmFsdWUubG93Pj4+MCxlLmRpbVZhbHVlLmhpZ2g+Pj4wKS50b051bWJlcigpKSksbnVsbCE9ZS5kaW1QYXJhbSYmKHQuZGltUGFyYW09U3RyaW5nKGUuZGltUGFyYW0pKSxudWxsIT1lLmRlbm90YXRpb24mJih0LmRlbm90YXRpb249U3RyaW5nKGUuZGVub3RhdGlvbikpLHR9LGUudG9PYmplY3Q9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSk7dmFyIG49e307cmV0dXJuIHQuZGVmYXVsdHMmJihuLmRlbm90YXRpb249XCJcIiksbnVsbCE9ZS5kaW1WYWx1ZSYmZS5oYXNPd25Qcm9wZXJ0eShcImRpbVZhbHVlXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIGUuZGltVmFsdWU/bi5kaW1WYWx1ZT10LmxvbmdzPT09U3RyaW5nP1N0cmluZyhlLmRpbVZhbHVlKTplLmRpbVZhbHVlOm4uZGltVmFsdWU9dC5sb25ncz09PVN0cmluZz9sLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZS5kaW1WYWx1ZSk6dC5sb25ncz09PU51bWJlcj9uZXcgbC5Mb25nQml0cyhlLmRpbVZhbHVlLmxvdz4+PjAsZS5kaW1WYWx1ZS5oaWdoPj4+MCkudG9OdW1iZXIoKTplLmRpbVZhbHVlLHQub25lb2ZzJiYobi52YWx1ZT1cImRpbVZhbHVlXCIpKSxudWxsIT1lLmRpbVBhcmFtJiZlLmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikmJihuLmRpbVBhcmFtPWUuZGltUGFyYW0sdC5vbmVvZnMmJihuLnZhbHVlPVwiZGltUGFyYW1cIikpLG51bGwhPWUuZGVub3RhdGlvbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikmJihuLmRlbm90YXRpb249ZS5kZW5vdGF0aW9uKSxufSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sZX0oKSxlfSgpLGkuVHlwZVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZihlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxuPTA7bjx0Lmxlbmd0aDsrK24pbnVsbCE9ZVt0W25dXSYmKHRoaXNbdFtuXV09ZVt0W25dXSl9dmFyIHQ7cmV0dXJuIGUucHJvdG90eXBlLnRlbnNvclR5cGU9bnVsbCxlLnByb3RvdHlwZS5kZW5vdGF0aW9uPVwiXCIsT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwidmFsdWVcIix7Z2V0Omwub25lT2ZHZXR0ZXIodD1bXCJ0ZW5zb3JUeXBlXCJdKSxzZXQ6bC5vbmVPZlNldHRlcih0KX0pLGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8KHQ9dS5jcmVhdGUoKSksbnVsbCE9ZS50ZW5zb3JUeXBlJiZlLmhhc093blByb3BlcnR5KFwidGVuc29yVHlwZVwiKSYmYy5vbm54LlR5cGVQcm90by5UZW5zb3IuZW5jb2RlKGUudGVuc29yVHlwZSx0LnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKSxudWxsIT1lLmRlbm90YXRpb24mJmUuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpJiZ0LnVpbnQzMig1MCkuc3RyaW5nKGUuZGVub3RhdGlvbiksdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2Ygc3x8KGU9cy5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54LlR5cGVQcm90bztlLnBvczxuOyl7dmFyIG89ZS51aW50MzIoKTtzd2l0Y2gobz4+PjMpe2Nhc2UgMTpyLnRlbnNvclR5cGU9Yy5vbm54LlR5cGVQcm90by5UZW5zb3IuZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7Y2FzZSA2OnIuZGVub3RhdGlvbj1lLnN0cmluZygpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm8pfX1yZXR1cm4gcn0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBzfHwoZT1uZXcgcyhlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9ZS50ZW5zb3JUeXBlJiZlLmhhc093blByb3BlcnR5KFwidGVuc29yVHlwZVwiKSl7dmFyIHQ9Yy5vbm54LlR5cGVQcm90by5UZW5zb3IudmVyaWZ5KGUudGVuc29yVHlwZSk7aWYodClyZXR1cm5cInRlbnNvclR5cGUuXCIrdH1yZXR1cm4gbnVsbCE9ZS5kZW5vdGF0aW9uJiZlLmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmIWwuaXNTdHJpbmcoZS5kZW5vdGF0aW9uKT9cImRlbm90YXRpb246IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54LlR5cGVQcm90bylyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54LlR5cGVQcm90bztpZihudWxsIT1lLnRlbnNvclR5cGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLnRlbnNvclR5cGUpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLnRlbnNvclR5cGU6IG9iamVjdCBleHBlY3RlZFwiKTt0LnRlbnNvclR5cGU9Yy5vbm54LlR5cGVQcm90by5UZW5zb3IuZnJvbU9iamVjdChlLnRlbnNvclR5cGUpfXJldHVybiBudWxsIT1lLmRlbm90YXRpb24mJih0LmRlbm90YXRpb249U3RyaW5nKGUuZGVub3RhdGlvbikpLHR9LGUudG9PYmplY3Q9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSk7dmFyIG49e307cmV0dXJuIHQuZGVmYXVsdHMmJihuLmRlbm90YXRpb249XCJcIiksbnVsbCE9ZS50ZW5zb3JUeXBlJiZlLmhhc093blByb3BlcnR5KFwidGVuc29yVHlwZVwiKSYmKG4udGVuc29yVHlwZT1jLm9ubnguVHlwZVByb3RvLlRlbnNvci50b09iamVjdChlLnRlbnNvclR5cGUsdCksdC5vbmVvZnMmJihuLnZhbHVlPVwidGVuc29yVHlwZVwiKSksbnVsbCE9ZS5kZW5vdGF0aW9uJiZlLmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmKG4uZGVub3RhdGlvbj1lLmRlbm90YXRpb24pLG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSxlLlRlbnNvcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYoZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXJldHVybiBlLnByb3RvdHlwZS5lbGVtVHlwZT0wLGUucHJvdG90eXBlLnNoYXBlPW51bGwsZS5jcmVhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpfSxlLmVuY29kZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHwodD11LmNyZWF0ZSgpKSxudWxsIT1lLmVsZW1UeXBlJiZlLmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikmJnQudWludDMyKDgpLmludDMyKGUuZWxlbVR5cGUpLG51bGwhPWUuc2hhcGUmJmUuaGFzT3duUHJvcGVydHkoXCJzaGFwZVwiKSYmYy5vbm54LlRlbnNvclNoYXBlUHJvdG8uZW5jb2RlKGUuc2hhcGUsdC51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCksdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2Ygc3x8KGU9cy5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54LlR5cGVQcm90by5UZW5zb3I7ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci5lbGVtVHlwZT1lLmludDMyKCk7YnJlYWs7Y2FzZSAyOnIuc2hhcGU9Yy5vbm54LlRlbnNvclNoYXBlUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbyl9fXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHN8fChlPW5ldyBzKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWUpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmVsZW1UeXBlJiZlLmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikmJiFsLmlzSW50ZWdlcihlLmVsZW1UeXBlKSlyZXR1cm5cImVsZW1UeXBlOiBpbnRlZ2VyIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5zaGFwZSYmZS5oYXNPd25Qcm9wZXJ0eShcInNoYXBlXCIpKXt2YXIgdD1jLm9ubnguVGVuc29yU2hhcGVQcm90by52ZXJpZnkoZS5zaGFwZSk7aWYodClyZXR1cm5cInNoYXBlLlwiK3R9cmV0dXJuIG51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54LlR5cGVQcm90by5UZW5zb3IpcmV0dXJuIGU7dmFyIHQ9bmV3IGMub25ueC5UeXBlUHJvdG8uVGVuc29yO2lmKG51bGwhPWUuZWxlbVR5cGUmJih0LmVsZW1UeXBlPTB8ZS5lbGVtVHlwZSksbnVsbCE9ZS5zaGFwZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuc2hhcGUpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLlRlbnNvci5zaGFwZTogb2JqZWN0IGV4cGVjdGVkXCIpO3Quc2hhcGU9Yy5vbm54LlRlbnNvclNoYXBlUHJvdG8uZnJvbU9iamVjdChlLnNoYXBlKX1yZXR1cm4gdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtyZXR1cm4gdC5kZWZhdWx0cyYmKG4uZWxlbVR5cGU9MCxuLnNoYXBlPW51bGwpLG51bGwhPWUuZWxlbVR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSYmKG4uZWxlbVR5cGU9ZS5lbGVtVHlwZSksbnVsbCE9ZS5zaGFwZSYmZS5oYXNPd25Qcm9wZXJ0eShcInNoYXBlXCIpJiYobi5zaGFwZT1jLm9ubnguVGVuc29yU2hhcGVQcm90by50b09iamVjdChlLnNoYXBlLHQpKSxufSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sZX0oKSxlfSgpLGkuT3BlcmF0b3JTZXRJZFByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZihlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxuPTA7bjx0Lmxlbmd0aDsrK24pbnVsbCE9ZVt0W25dXSYmKHRoaXNbdFtuXV09ZVt0W25dXSl9cmV0dXJuIGUucHJvdG90eXBlLmRvbWFpbj1cIlwiLGUucHJvdG90eXBlLnZlcnNpb249bC5Mb25nP2wuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsZS5jcmVhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpfSxlLmVuY29kZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHwodD11LmNyZWF0ZSgpKSxudWxsIT1lLmRvbWFpbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmdC51aW50MzIoMTApLnN0cmluZyhlLmRvbWFpbiksbnVsbCE9ZS52ZXJzaW9uJiZlLmhhc093blByb3BlcnR5KFwidmVyc2lvblwiKSYmdC51aW50MzIoMTYpLmludDY0KGUudmVyc2lvbiksdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2Ygc3x8KGU9cy5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54Lk9wZXJhdG9yU2V0SWRQcm90bztlLnBvczxuOyl7dmFyIG89ZS51aW50MzIoKTtzd2l0Y2gobz4+PjMpe2Nhc2UgMTpyLmRvbWFpbj1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMjpyLnZlcnNpb249ZS5pbnQ2NCgpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm8pfX1yZXR1cm4gcn0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBzfHwoZT1uZXcgcyhlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24oZSl7cmV0dXJuXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lP1wib2JqZWN0IGV4cGVjdGVkXCI6bnVsbCE9ZS5kb21haW4mJmUuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJiFsLmlzU3RyaW5nKGUuZG9tYWluKT9cImRvbWFpbjogc3RyaW5nIGV4cGVjdGVkXCI6bnVsbCE9ZS52ZXJzaW9uJiZlLmhhc093blByb3BlcnR5KFwidmVyc2lvblwiKSYmIShsLmlzSW50ZWdlcihlLnZlcnNpb24pfHxlLnZlcnNpb24mJmwuaXNJbnRlZ2VyKGUudmVyc2lvbi5sb3cpJiZsLmlzSW50ZWdlcihlLnZlcnNpb24uaGlnaCkpP1widmVyc2lvbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI6bnVsbH0sZS5mcm9tT2JqZWN0PWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBjLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvKXJldHVybiBlO3ZhciB0PW5ldyBjLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvO3JldHVybiBudWxsIT1lLmRvbWFpbiYmKHQuZG9tYWluPVN0cmluZyhlLmRvbWFpbikpLG51bGwhPWUudmVyc2lvbiYmKGwuTG9uZz8odC52ZXJzaW9uPWwuTG9uZy5mcm9tVmFsdWUoZS52ZXJzaW9uKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIGUudmVyc2lvbj90LnZlcnNpb249cGFyc2VJbnQoZS52ZXJzaW9uLDEwKTpcIm51bWJlclwiPT10eXBlb2YgZS52ZXJzaW9uP3QudmVyc2lvbj1lLnZlcnNpb246XCJvYmplY3RcIj09dHlwZW9mIGUudmVyc2lvbiYmKHQudmVyc2lvbj1uZXcgbC5Mb25nQml0cyhlLnZlcnNpb24ubG93Pj4+MCxlLnZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCkpKSx0fSxlLnRvT2JqZWN0PWZ1bmN0aW9uKGUsdCl7dHx8KHQ9e30pO3ZhciBuPXt9O2lmKHQuZGVmYXVsdHMpaWYobi5kb21haW49XCJcIixsLkxvbmcpe3ZhciByPW5ldyBsLkxvbmcoMCwwLCExKTtuLnZlcnNpb249dC5sb25ncz09PVN0cmluZz9yLnRvU3RyaW5nKCk6dC5sb25ncz09PU51bWJlcj9yLnRvTnVtYmVyKCk6cn1lbHNlIG4udmVyc2lvbj10LmxvbmdzPT09U3RyaW5nP1wiMFwiOjA7cmV0dXJuIG51bGwhPWUuZG9tYWluJiZlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYobi5kb21haW49ZS5kb21haW4pLG51bGwhPWUudmVyc2lvbiYmZS5oYXNPd25Qcm9wZXJ0eShcInZlcnNpb25cIikmJihcIm51bWJlclwiPT10eXBlb2YgZS52ZXJzaW9uP24udmVyc2lvbj10LmxvbmdzPT09U3RyaW5nP1N0cmluZyhlLnZlcnNpb24pOmUudmVyc2lvbjpuLnZlcnNpb249dC5sb25ncz09PVN0cmluZz9sLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZS52ZXJzaW9uKTp0LmxvbmdzPT09TnVtYmVyP25ldyBsLkxvbmdCaXRzKGUudmVyc2lvbi5sb3c+Pj4wLGUudmVyc2lvbi5oaWdoPj4+MCkudG9OdW1iZXIoKTplLnZlcnNpb24pLG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSxlfSgpLGkpLGUuZXhwb3J0cz1jfSwyMTAwOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9big5NDgyKX0sOTQ4MjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dDtmdW5jdGlvbiBvKCl7ci51dGlsLl9jb25maWd1cmUoKSxyLldyaXRlci5fY29uZmlndXJlKHIuQnVmZmVyV3JpdGVyKSxyLlJlYWRlci5fY29uZmlndXJlKHIuQnVmZmVyUmVhZGVyKX1yLmJ1aWxkPVwibWluaW1hbFwiLHIuV3JpdGVyPW4oMTE3Myksci5CdWZmZXJXcml0ZXI9bigzMTU1KSxyLlJlYWRlcj1uKDE0MDgpLHIuQnVmZmVyUmVhZGVyPW4oNTkzKSxyLnV0aWw9big5NjkzKSxyLnJwYz1uKDU5OTQpLHIucm9vdHM9big1MDU0KSxyLmNvbmZpZ3VyZT1vLG8oKX0sMTQwODooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXU7dmFyIHIsbz1uKDk2OTMpLGk9by5Mb25nQml0cyxhPW8udXRmODtmdW5jdGlvbiBzKGUsdCl7cmV0dXJuIFJhbmdlRXJyb3IoXCJpbmRleCBvdXQgb2YgcmFuZ2U6IFwiK2UucG9zK1wiICsgXCIrKHR8fDEpK1wiID4gXCIrZS5sZW4pfWZ1bmN0aW9uIHUoZSl7dGhpcy5idWY9ZSx0aGlzLnBvcz0wLHRoaXMubGVuPWUubGVuZ3RofXZhciBsLGM9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4QXJyYXk/ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIG5ldyB1KGUpO3Rocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIil9OmZ1bmN0aW9uKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIG5ldyB1KGUpO3Rocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIil9LHA9ZnVuY3Rpb24oKXtyZXR1cm4gby5CdWZmZXI/ZnVuY3Rpb24oZSl7cmV0dXJuKHUuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBvLkJ1ZmZlci5pc0J1ZmZlcihlKT9uZXcgcihlKTpjKGUpfSkoZSl9OmN9O2Z1bmN0aW9uIGQoKXt2YXIgZT1uZXcgaSgwLDApLHQ9MDtpZighKHRoaXMubGVuLXRoaXMucG9zPjQpKXtmb3IoO3Q8MzsrK3Qpe2lmKHRoaXMucG9zPj10aGlzLmxlbil0aHJvdyBzKHRoaXMpO2lmKGUubG89KGUubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KnQpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGV9cmV0dXJuIGUubG89KGUubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvcysrXSk8PDcqdCk+Pj4wLGV9Zm9yKDt0PDQ7Kyt0KWlmKGUubG89KGUubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KnQpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGU7aWYoZS5sbz0oZS5sb3woMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDI4KT4+PjAsZS5oaT0oZS5oaXwoMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk+PjQpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGU7aWYodD0wLHRoaXMubGVuLXRoaXMucG9zPjQpe2Zvcig7dDw1OysrdClpZihlLmhpPShlLmhpfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8Nyp0KzMpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGV9ZWxzZSBmb3IoO3Q8NTsrK3Qpe2lmKHRoaXMucG9zPj10aGlzLmxlbil0aHJvdyBzKHRoaXMpO2lmKGUuaGk9KGUuaGl8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KnQrMyk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gZX10aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpfWZ1bmN0aW9uIGYoZSx0KXtyZXR1cm4oZVt0LTRdfGVbdC0zXTw8OHxlW3QtMl08PDE2fGVbdC0xXTw8MjQpPj4+MH1mdW5jdGlvbiBoKCl7aWYodGhpcy5wb3MrOD50aGlzLmxlbil0aHJvdyBzKHRoaXMsOCk7cmV0dXJuIG5ldyBpKGYodGhpcy5idWYsdGhpcy5wb3MrPTQpLGYodGhpcy5idWYsdGhpcy5wb3MrPTQpKX11LmNyZWF0ZT1wKCksdS5wcm90b3R5cGUuX3NsaWNlPW8uQXJyYXkucHJvdG90eXBlLnN1YmFycmF5fHxvLkFycmF5LnByb3RvdHlwZS5zbGljZSx1LnByb3RvdHlwZS51aW50MzI9KGw9NDI5NDk2NzI5NSxmdW5jdGlvbigpe2lmKGw9KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGw7aWYobD0obHwoMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDcpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGw7aWYobD0obHwoMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDE0KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBsO2lmKGw9KGx8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDwyMSk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gbDtpZihsPShsfCgxNSZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDwyOCk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gbDtpZigodGhpcy5wb3MrPTUpPnRoaXMubGVuKXRocm93IHRoaXMucG9zPXRoaXMubGVuLHModGhpcywxMCk7cmV0dXJuIGx9KSx1LnByb3RvdHlwZS5pbnQzMj1mdW5jdGlvbigpe3JldHVybiAwfHRoaXMudWludDMyKCl9LHUucHJvdG90eXBlLnNpbnQzMj1mdW5jdGlvbigpe3ZhciBlPXRoaXMudWludDMyKCk7cmV0dXJuIGU+Pj4xXi0oMSZlKXwwfSx1LnByb3RvdHlwZS5ib29sPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPT10aGlzLnVpbnQzMigpfSx1LnByb3RvdHlwZS5maXhlZDMyPWZ1bmN0aW9uKCl7aWYodGhpcy5wb3MrND50aGlzLmxlbil0aHJvdyBzKHRoaXMsNCk7cmV0dXJuIGYodGhpcy5idWYsdGhpcy5wb3MrPTQpfSx1LnByb3RvdHlwZS5zZml4ZWQzMj1mdW5jdGlvbigpe2lmKHRoaXMucG9zKzQ+dGhpcy5sZW4pdGhyb3cgcyh0aGlzLDQpO3JldHVybiAwfGYodGhpcy5idWYsdGhpcy5wb3MrPTQpfSx1LnByb3RvdHlwZS5mbG9hdD1mdW5jdGlvbigpe2lmKHRoaXMucG9zKzQ+dGhpcy5sZW4pdGhyb3cgcyh0aGlzLDQpO3ZhciBlPW8uZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsdGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9NCxlfSx1LnByb3RvdHlwZS5kb3VibGU9ZnVuY3Rpb24oKXtpZih0aGlzLnBvcys4PnRoaXMubGVuKXRocm93IHModGhpcyw0KTt2YXIgZT1vLmZsb2F0LnJlYWREb3VibGVMRSh0aGlzLmJ1Zix0aGlzLnBvcyk7cmV0dXJuIHRoaXMucG9zKz04LGV9LHUucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy51aW50MzIoKSx0PXRoaXMucG9zLG49dGhpcy5wb3MrZTtpZihuPnRoaXMubGVuKXRocm93IHModGhpcyxlKTtyZXR1cm4gdGhpcy5wb3MrPWUsQXJyYXkuaXNBcnJheSh0aGlzLmJ1Zik/dGhpcy5idWYuc2xpY2UodCxuKTp0PT09bj9uZXcgdGhpcy5idWYuY29uc3RydWN0b3IoMCk6dGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1Zix0LG4pfSx1LnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmJ5dGVzKCk7cmV0dXJuIGEucmVhZChlLDAsZS5sZW5ndGgpfSx1LnByb3RvdHlwZS5za2lwPWZ1bmN0aW9uKGUpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXtpZih0aGlzLnBvcytlPnRoaXMubGVuKXRocm93IHModGhpcyxlKTt0aGlzLnBvcys9ZX1lbHNlIGRve2lmKHRoaXMucG9zPj10aGlzLmxlbil0aHJvdyBzKHRoaXMpfXdoaWxlKDEyOCZ0aGlzLmJ1Zlt0aGlzLnBvcysrXSk7cmV0dXJuIHRoaXN9LHUucHJvdG90eXBlLnNraXBUeXBlPWZ1bmN0aW9uKGUpe3N3aXRjaChlKXtjYXNlIDA6dGhpcy5za2lwKCk7YnJlYWs7Y2FzZSAxOnRoaXMuc2tpcCg4KTticmVhaztjYXNlIDI6dGhpcy5za2lwKHRoaXMudWludDMyKCkpO2JyZWFrO2Nhc2UgMzpmb3IoOzQhPShlPTcmdGhpcy51aW50MzIoKSk7KXRoaXMuc2tpcFR5cGUoZSk7YnJlYWs7Y2FzZSA1OnRoaXMuc2tpcCg0KTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIrZStcIiBhdCBvZmZzZXQgXCIrdGhpcy5wb3MpfXJldHVybiB0aGlzfSx1Ll9jb25maWd1cmU9ZnVuY3Rpb24oZSl7cj1lLHUuY3JlYXRlPXAoKSxyLl9jb25maWd1cmUoKTt2YXIgdD1vLkxvbmc/XCJ0b0xvbmdcIjpcInRvTnVtYmVyXCI7by5tZXJnZSh1LnByb3RvdHlwZSx7aW50NjQ6ZnVuY3Rpb24oKXtyZXR1cm4gZC5jYWxsKHRoaXMpW3RdKCExKX0sdWludDY0OmZ1bmN0aW9uKCl7cmV0dXJuIGQuY2FsbCh0aGlzKVt0XSghMCl9LHNpbnQ2NDpmdW5jdGlvbigpe3JldHVybiBkLmNhbGwodGhpcykuenpEZWNvZGUoKVt0XSghMSl9LGZpeGVkNjQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5jYWxsKHRoaXMpW3RdKCEwKX0sc2ZpeGVkNjQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5jYWxsKHRoaXMpW3RdKCExKX19KX19LDU5MzooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWk7dmFyIHI9bigxNDA4KTsoaS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPWk7dmFyIG89big5NjkzKTtmdW5jdGlvbiBpKGUpe3IuY2FsbCh0aGlzLGUpfWkuX2NvbmZpZ3VyZT1mdW5jdGlvbigpe28uQnVmZmVyJiYoaS5wcm90b3R5cGUuX3NsaWNlPW8uQnVmZmVyLnByb3RvdHlwZS5zbGljZSl9LGkucHJvdG90eXBlLnN0cmluZz1mdW5jdGlvbigpe3ZhciBlPXRoaXMudWludDMyKCk7cmV0dXJuIHRoaXMuYnVmLnV0ZjhTbGljZT90aGlzLmJ1Zi51dGY4U2xpY2UodGhpcy5wb3MsdGhpcy5wb3M9TWF0aC5taW4odGhpcy5wb3MrZSx0aGlzLmxlbikpOnRoaXMuYnVmLnRvU3RyaW5nKFwidXRmLThcIix0aGlzLnBvcyx0aGlzLnBvcz1NYXRoLm1pbih0aGlzLnBvcytlLHRoaXMubGVuKSl9LGkuX2NvbmZpZ3VyZSgpfSw1MDU0OmU9PntcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9e319LDU5OTQ6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO3QuU2VydmljZT1uKDc5NDgpfSw3OTQ4OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9bzt2YXIgcj1uKDk2OTMpO2Z1bmN0aW9uIG8oZSx0LG4pe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7ci5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSx0aGlzLnJwY0ltcGw9ZSx0aGlzLnJlcXVlc3REZWxpbWl0ZWQ9Qm9vbGVhbih0KSx0aGlzLnJlc3BvbnNlRGVsaW1pdGVkPUJvb2xlYW4obil9KG8ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3I9byxvLnByb3RvdHlwZS5ycGNDYWxsPWZ1bmN0aW9uIGUodCxuLG8saSxhKXtpZighaSl0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0IG11c3QgYmUgc3BlY2lmaWVkXCIpO3ZhciBzPXRoaXM7aWYoIWEpcmV0dXJuIHIuYXNQcm9taXNlKGUscyx0LG4sbyxpKTtpZihzLnJwY0ltcGwpdHJ5e3JldHVybiBzLnJwY0ltcGwodCxuW3MucmVxdWVzdERlbGltaXRlZD9cImVuY29kZURlbGltaXRlZFwiOlwiZW5jb2RlXCJdKGkpLmZpbmlzaCgpLChmdW5jdGlvbihlLG4pe2lmKGUpcmV0dXJuIHMuZW1pdChcImVycm9yXCIsZSx0KSxhKGUpO2lmKG51bGwhPT1uKXtpZighKG4gaW5zdGFuY2VvZiBvKSl0cnl7bj1vW3MucmVzcG9uc2VEZWxpbWl0ZWQ/XCJkZWNvZGVEZWxpbWl0ZWRcIjpcImRlY29kZVwiXShuKX1jYXRjaChlKXtyZXR1cm4gcy5lbWl0KFwiZXJyb3JcIixlLHQpLGEoZSl9cmV0dXJuIHMuZW1pdChcImRhdGFcIixuLHQpLGEobnVsbCxuKX1zLmVuZCghMCl9KSl9Y2F0Y2goZSl7cmV0dXJuIHMuZW1pdChcImVycm9yXCIsZSx0KSx2b2lkIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7YShlKX0pLDApfWVsc2Ugc2V0VGltZW91dCgoZnVuY3Rpb24oKXthKEVycm9yKFwiYWxyZWFkeSBlbmRlZFwiKSl9KSwwKX0sby5wcm90b3R5cGUuZW5kPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJwY0ltcGwmJihlfHx0aGlzLnJwY0ltcGwobnVsbCxudWxsLG51bGwpLHRoaXMucnBjSW1wbD1udWxsLHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKSksdGhpc319LDE5NDU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1vO3ZhciByPW4oOTY5Myk7ZnVuY3Rpb24gbyhlLHQpe3RoaXMubG89ZT4+PjAsdGhpcy5oaT10Pj4+MH12YXIgaT1vLnplcm89bmV3IG8oMCwwKTtpLnRvTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuIDB9LGkuenpFbmNvZGU9aS56ekRlY29kZT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxpLmxlbmd0aD1mdW5jdGlvbigpe3JldHVybiAxfTt2YXIgYT1vLnplcm9IYXNoPVwiXFwwXFwwXFwwXFwwXFwwXFwwXFwwXFwwXCI7by5mcm9tTnVtYmVyPWZ1bmN0aW9uKGUpe2lmKDA9PT1lKXJldHVybiBpO3ZhciB0PWU8MDt0JiYoZT0tZSk7dmFyIG49ZT4+PjAscj0oZS1uKS80Mjk0OTY3Mjk2Pj4+MDtyZXR1cm4gdCYmKHI9fnI+Pj4wLG49fm4+Pj4wLCsrbj40Mjk0OTY3Mjk1JiYobj0wLCsrcj40Mjk0OTY3Mjk1JiYocj0wKSkpLG5ldyBvKG4scil9LG8uZnJvbT1mdW5jdGlvbihlKXtpZihcIm51bWJlclwiPT10eXBlb2YgZSlyZXR1cm4gby5mcm9tTnVtYmVyKGUpO2lmKHIuaXNTdHJpbmcoZSkpe2lmKCFyLkxvbmcpcmV0dXJuIG8uZnJvbU51bWJlcihwYXJzZUludChlLDEwKSk7ZT1yLkxvbmcuZnJvbVN0cmluZyhlKX1yZXR1cm4gZS5sb3d8fGUuaGlnaD9uZXcgbyhlLmxvdz4+PjAsZS5oaWdoPj4+MCk6aX0sby5wcm90b3R5cGUudG9OdW1iZXI9ZnVuY3Rpb24oZSl7aWYoIWUmJnRoaXMuaGk+Pj4zMSl7dmFyIHQ9MSt+dGhpcy5sbz4+PjAsbj1+dGhpcy5oaT4+PjA7cmV0dXJuIHR8fChuPW4rMT4+PjApLC0odCs0Mjk0OTY3Mjk2Km4pfXJldHVybiB0aGlzLmxvKzQyOTQ5NjcyOTYqdGhpcy5oaX0sby5wcm90b3R5cGUudG9Mb25nPWZ1bmN0aW9uKGUpe3JldHVybiByLkxvbmc/bmV3IHIuTG9uZygwfHRoaXMubG8sMHx0aGlzLmhpLEJvb2xlYW4oZSkpOntsb3c6MHx0aGlzLmxvLGhpZ2g6MHx0aGlzLmhpLHVuc2lnbmVkOkJvb2xlYW4oZSl9fTt2YXIgcz1TdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQ7by5mcm9tSGFzaD1mdW5jdGlvbihlKXtyZXR1cm4gZT09PWE/aTpuZXcgbygocy5jYWxsKGUsMCl8cy5jYWxsKGUsMSk8PDh8cy5jYWxsKGUsMik8PDE2fHMuY2FsbChlLDMpPDwyNCk+Pj4wLChzLmNhbGwoZSw0KXxzLmNhbGwoZSw1KTw8OHxzLmNhbGwoZSw2KTw8MTZ8cy5jYWxsKGUsNyk8PDI0KT4+PjApfSxvLnByb3RvdHlwZS50b0hhc2g9ZnVuY3Rpb24oKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUmdGhpcy5sbyx0aGlzLmxvPj4+OCYyNTUsdGhpcy5sbz4+PjE2JjI1NSx0aGlzLmxvPj4+MjQsMjU1JnRoaXMuaGksdGhpcy5oaT4+PjgmMjU1LHRoaXMuaGk+Pj4xNiYyNTUsdGhpcy5oaT4+PjI0KX0sby5wcm90b3R5cGUuenpFbmNvZGU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmhpPj4zMTtyZXR1cm4gdGhpcy5oaT0oKHRoaXMuaGk8PDF8dGhpcy5sbz4+PjMxKV5lKT4+PjAsdGhpcy5sbz0odGhpcy5sbzw8MV5lKT4+PjAsdGhpc30sby5wcm90b3R5cGUuenpEZWNvZGU9ZnVuY3Rpb24oKXt2YXIgZT0tKDEmdGhpcy5sbyk7cmV0dXJuIHRoaXMubG89KCh0aGlzLmxvPj4+MXx0aGlzLmhpPDwzMSleZSk+Pj4wLHRoaXMuaGk9KHRoaXMuaGk+Pj4xXmUpPj4+MCx0aGlzfSxvLnByb3RvdHlwZS5sZW5ndGg9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmxvLHQ9KHRoaXMubG8+Pj4yOHx0aGlzLmhpPDw0KT4+PjAsbj10aGlzLmhpPj4+MjQ7cmV0dXJuIDA9PT1uPzA9PT10P2U8MTYzODQ/ZTwxMjg/MToyOmU8MjA5NzE1Mj8zOjQ6dDwxNjM4ND90PDEyOD81OjY6dDwyMDk3MTUyPzc6ODpuPDEyOD85OjEwfX0sOTY5MzpmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dDtmdW5jdGlvbiBvKGUsdCxuKXtmb3IodmFyIHI9T2JqZWN0LmtleXModCksbz0wO288ci5sZW5ndGg7KytvKXZvaWQgMCE9PWVbcltvXV0mJm58fChlW3Jbb11dPXRbcltvXV0pO3JldHVybiBlfWZ1bmN0aW9uIGkoZSl7ZnVuY3Rpb24gdChlLG4pe2lmKCEodGhpcyBpbnN0YW5jZW9mIHQpKXJldHVybiBuZXcgdChlLG4pO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwibWVzc2FnZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZX19KSxFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT9FcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLHQpOk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwic3RhY2tcIix7dmFsdWU6KG5ldyBFcnJvcikuc3RhY2t8fFwiXCJ9KSxuJiZvKHRoaXMsbil9cmV0dXJuKHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSkuY29uc3RydWN0b3I9dCxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJuYW1lXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBlfX0pLHQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZStcIjogXCIrdGhpcy5tZXNzYWdlfSx0fXIuYXNQcm9taXNlPW4oNDUzNyksci5iYXNlNjQ9big3NDE5KSxyLkV2ZW50RW1pdHRlcj1uKDkyMTEpLHIuZmxvYXQ9big5NDUpLHIuaW5xdWlyZT1uKDcxOTkpLHIudXRmOD1uKDQ5OTcpLHIucG9vbD1uKDY2NjIpLHIuTG9uZ0JpdHM9bigxOTQ1KSxyLmlzTm9kZT1Cb29sZWFuKHZvaWQgMCE9PW4uZyYmbi5nJiZuLmcucHJvY2VzcyYmbi5nLnByb2Nlc3MudmVyc2lvbnMmJm4uZy5wcm9jZXNzLnZlcnNpb25zLm5vZGUpLHIuZ2xvYmFsPXIuaXNOb2RlJiZuLmd8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvd3x8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGZ8fHRoaXMsci5lbXB0eUFycmF5PU9iamVjdC5mcmVlemU/T2JqZWN0LmZyZWV6ZShbXSk6W10sci5lbXB0eU9iamVjdD1PYmplY3QuZnJlZXplP09iamVjdC5mcmVlemUoe30pOnt9LHIuaXNJbnRlZ2VyPU51bWJlci5pc0ludGVnZXJ8fGZ1bmN0aW9uKGUpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBlJiZpc0Zpbml0ZShlKSYmTWF0aC5mbG9vcihlKT09PWV9LHIuaXNTdHJpbmc9ZnVuY3Rpb24oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGV8fGUgaW5zdGFuY2VvZiBTdHJpbmd9LHIuaXNPYmplY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlfSxyLmlzc2V0PXIuaXNTZXQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lW3RdO3JldHVybiEobnVsbD09bnx8IWUuaGFzT3duUHJvcGVydHkodCkpJiYoXCJvYmplY3RcIiE9dHlwZW9mIG58fChBcnJheS5pc0FycmF5KG4pP24ubGVuZ3RoOk9iamVjdC5rZXlzKG4pLmxlbmd0aCk+MCl9LHIuQnVmZmVyPWZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXIuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7cmV0dXJuIGUucHJvdG90eXBlLnV0ZjhXcml0ZT9lOm51bGx9Y2F0Y2goZSl7cmV0dXJuIG51bGx9fSgpLHIuX0J1ZmZlcl9mcm9tPW51bGwsci5fQnVmZmVyX2FsbG9jVW5zYWZlPW51bGwsci5uZXdCdWZmZXI9ZnVuY3Rpb24oZSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGU/ci5CdWZmZXI/ci5fQnVmZmVyX2FsbG9jVW5zYWZlKGUpOm5ldyByLkFycmF5KGUpOnIuQnVmZmVyP3IuX0J1ZmZlcl9mcm9tKGUpOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBVaW50OEFycmF5P2U6bmV3IFVpbnQ4QXJyYXkoZSl9LHIuQXJyYXk9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4QXJyYXk/VWludDhBcnJheTpBcnJheSxyLkxvbmc9ci5nbG9iYWwuZGNvZGVJTyYmci5nbG9iYWwuZGNvZGVJTy5Mb25nfHxyLmdsb2JhbC5Mb25nfHxyLmlucXVpcmUoXCJsb25nXCIpLHIua2V5MlJlPS9edHJ1ZXxmYWxzZXwwfDEkLyxyLmtleTMyUmU9L14tPyg/OjB8WzEtOV1bMC05XSopJC8sci5rZXk2NFJlPS9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLyxyLmxvbmdUb0hhc2g9ZnVuY3Rpb24oZSl7cmV0dXJuIGU/ci5Mb25nQml0cy5mcm9tKGUpLnRvSGFzaCgpOnIuTG9uZ0JpdHMuemVyb0hhc2h9LHIubG9uZ0Zyb21IYXNoPWZ1bmN0aW9uKGUsdCl7dmFyIG49ci5Mb25nQml0cy5mcm9tSGFzaChlKTtyZXR1cm4gci5Mb25nP3IuTG9uZy5mcm9tQml0cyhuLmxvLG4uaGksdCk6bi50b051bWJlcihCb29sZWFuKHQpKX0sci5tZXJnZT1vLHIubGNGaXJzdD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKStlLnN1YnN0cmluZygxKX0sci5uZXdFcnJvcj1pLHIuUHJvdG9jb2xFcnJvcj1pKFwiUHJvdG9jb2xFcnJvclwiKSxyLm9uZU9mR2V0dGVyPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD17fSxuPTA7bjxlLmxlbmd0aDsrK24pdFtlW25dXT0xO3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgZT1PYmplY3Qua2V5cyh0aGlzKSxuPWUubGVuZ3RoLTE7bj4tMTstLW4paWYoMT09PXRbZVtuXV0mJnZvaWQgMCE9PXRoaXNbZVtuXV0mJm51bGwhPT10aGlzW2Vbbl1dKXJldHVybiBlW25dfX0sci5vbmVPZlNldHRlcj1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDsrK24pZVtuXSE9PXQmJmRlbGV0ZSB0aGlzW2Vbbl1dfX0sci50b0pTT05PcHRpb25zPXtsb25nczpTdHJpbmcsZW51bXM6U3RyaW5nLGJ5dGVzOlN0cmluZyxqc29uOiEwfSxyLl9jb25maWd1cmU9ZnVuY3Rpb24oKXt2YXIgZT1yLkJ1ZmZlcjtlPyhyLl9CdWZmZXJfZnJvbT1lLmZyb20hPT1VaW50OEFycmF5LmZyb20mJmUuZnJvbXx8ZnVuY3Rpb24odCxuKXtyZXR1cm4gbmV3IGUodCxuKX0sci5fQnVmZmVyX2FsbG9jVW5zYWZlPWUuYWxsb2NVbnNhZmV8fGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0pOnIuX0J1ZmZlcl9mcm9tPXIuX0J1ZmZlcl9hbGxvY1Vuc2FmZT1udWxsfX0sMTE3MzooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXA7dmFyIHIsbz1uKDk2OTMpLGk9by5Mb25nQml0cyxhPW8uYmFzZTY0LHM9by51dGY4O2Z1bmN0aW9uIHUoZSx0LG4pe3RoaXMuZm49ZSx0aGlzLmxlbj10LHRoaXMubmV4dD12b2lkIDAsdGhpcy52YWw9bn1mdW5jdGlvbiBsKCl7fWZ1bmN0aW9uIGMoZSl7dGhpcy5oZWFkPWUuaGVhZCx0aGlzLnRhaWw9ZS50YWlsLHRoaXMubGVuPWUubGVuLHRoaXMubmV4dD1lLnN0YXRlc31mdW5jdGlvbiBwKCl7dGhpcy5sZW49MCx0aGlzLmhlYWQ9bmV3IHUobCwwLDApLHRoaXMudGFpbD10aGlzLmhlYWQsdGhpcy5zdGF0ZXM9bnVsbH12YXIgZD1mdW5jdGlvbigpe3JldHVybiBvLkJ1ZmZlcj9mdW5jdGlvbigpe3JldHVybihwLmNyZWF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgcn0pKCl9OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBwfX07ZnVuY3Rpb24gZihlLHQsbil7dFtuXT0yNTUmZX1mdW5jdGlvbiBoKGUsdCl7dGhpcy5sZW49ZSx0aGlzLm5leHQ9dm9pZCAwLHRoaXMudmFsPXR9ZnVuY3Rpb24gZyhlLHQsbil7Zm9yKDtlLmhpOyl0W24rK109MTI3JmUubG98MTI4LGUubG89KGUubG8+Pj43fGUuaGk8PDI1KT4+PjAsZS5oaT4+Pj03O2Zvcig7ZS5sbz4xMjc7KXRbbisrXT0xMjcmZS5sb3wxMjgsZS5sbz1lLmxvPj4+Nzt0W24rK109ZS5sb31mdW5jdGlvbiBtKGUsdCxuKXt0W25dPTI1NSZlLHRbbisxXT1lPj4+OCYyNTUsdFtuKzJdPWU+Pj4xNiYyNTUsdFtuKzNdPWU+Pj4yNH1wLmNyZWF0ZT1kKCkscC5hbGxvYz1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IG8uQXJyYXkoZSl9LG8uQXJyYXkhPT1BcnJheSYmKHAuYWxsb2M9by5wb29sKHAuYWxsb2Msby5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpKSxwLnByb3RvdHlwZS5fcHVzaD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIHRoaXMudGFpbD10aGlzLnRhaWwubmV4dD1uZXcgdShlLHQsbiksdGhpcy5sZW4rPXQsdGhpc30saC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh1LnByb3RvdHlwZSksaC5wcm90b3R5cGUuZm49ZnVuY3Rpb24oZSx0LG4pe2Zvcig7ZT4xMjc7KXRbbisrXT0xMjcmZXwxMjgsZT4+Pj03O3Rbbl09ZX0scC5wcm90b3R5cGUudWludDMyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxlbis9KHRoaXMudGFpbD10aGlzLnRhaWwubmV4dD1uZXcgaCgoZT4+Pj0wKTwxMjg/MTplPDE2Mzg0PzI6ZTwyMDk3MTUyPzM6ZTwyNjg0MzU0NTY/NDo1LGUpKS5sZW4sdGhpc30scC5wcm90b3R5cGUuaW50MzI9ZnVuY3Rpb24oZSl7cmV0dXJuIGU8MD90aGlzLl9wdXNoKGcsMTAsaS5mcm9tTnVtYmVyKGUpKTp0aGlzLnVpbnQzMihlKX0scC5wcm90b3R5cGUuc2ludDMyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnVpbnQzMigoZTw8MV5lPj4zMSk+Pj4wKX0scC5wcm90b3R5cGUudWludDY0PWZ1bmN0aW9uKGUpe3ZhciB0PWkuZnJvbShlKTtyZXR1cm4gdGhpcy5fcHVzaChnLHQubGVuZ3RoKCksdCl9LHAucHJvdG90eXBlLmludDY0PXAucHJvdG90eXBlLnVpbnQ2NCxwLnByb3RvdHlwZS5zaW50NjQ9ZnVuY3Rpb24oZSl7dmFyIHQ9aS5mcm9tKGUpLnp6RW5jb2RlKCk7cmV0dXJuIHRoaXMuX3B1c2goZyx0Lmxlbmd0aCgpLHQpfSxwLnByb3RvdHlwZS5ib29sPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9wdXNoKGYsMSxlPzE6MCl9LHAucHJvdG90eXBlLmZpeGVkMzI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX3B1c2gobSw0LGU+Pj4wKX0scC5wcm90b3R5cGUuc2ZpeGVkMzI9cC5wcm90b3R5cGUuZml4ZWQzMixwLnByb3RvdHlwZS5maXhlZDY0PWZ1bmN0aW9uKGUpe3ZhciB0PWkuZnJvbShlKTtyZXR1cm4gdGhpcy5fcHVzaChtLDQsdC5sbykuX3B1c2gobSw0LHQuaGkpfSxwLnByb3RvdHlwZS5zZml4ZWQ2ND1wLnByb3RvdHlwZS5maXhlZDY0LHAucHJvdG90eXBlLmZsb2F0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9wdXNoKG8uZmxvYXQud3JpdGVGbG9hdExFLDQsZSl9LHAucHJvdG90eXBlLmRvdWJsZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fcHVzaChvLmZsb2F0LndyaXRlRG91YmxlTEUsOCxlKX07dmFyIGI9by5BcnJheS5wcm90b3R5cGUuc2V0P2Z1bmN0aW9uKGUsdCxuKXt0LnNldChlLG4pfTpmdW5jdGlvbihlLHQsbil7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDsrK3IpdFtuK3JdPWVbcl19O3AucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKGUpe3ZhciB0PWUubGVuZ3RoPj4+MDtpZighdClyZXR1cm4gdGhpcy5fcHVzaChmLDEsMCk7aWYoby5pc1N0cmluZyhlKSl7dmFyIG49cC5hbGxvYyh0PWEubGVuZ3RoKGUpKTthLmRlY29kZShlLG4sMCksZT1ufXJldHVybiB0aGlzLnVpbnQzMih0KS5fcHVzaChiLHQsZSl9LHAucHJvdG90eXBlLnN0cmluZz1mdW5jdGlvbihlKXt2YXIgdD1zLmxlbmd0aChlKTtyZXR1cm4gdD90aGlzLnVpbnQzMih0KS5fcHVzaChzLndyaXRlLHQsZSk6dGhpcy5fcHVzaChmLDEsMCl9LHAucHJvdG90eXBlLmZvcms9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZXM9bmV3IGModGhpcyksdGhpcy5oZWFkPXRoaXMudGFpbD1uZXcgdShsLDAsMCksdGhpcy5sZW49MCx0aGlzfSxwLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlcz8odGhpcy5oZWFkPXRoaXMuc3RhdGVzLmhlYWQsdGhpcy50YWlsPXRoaXMuc3RhdGVzLnRhaWwsdGhpcy5sZW49dGhpcy5zdGF0ZXMubGVuLHRoaXMuc3RhdGVzPXRoaXMuc3RhdGVzLm5leHQpOih0aGlzLmhlYWQ9dGhpcy50YWlsPW5ldyB1KGwsMCwwKSx0aGlzLmxlbj0wKSx0aGlzfSxwLnByb3RvdHlwZS5sZGVsaW09ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmhlYWQsdD10aGlzLnRhaWwsbj10aGlzLmxlbjtyZXR1cm4gdGhpcy5yZXNldCgpLnVpbnQzMihuKSxuJiYodGhpcy50YWlsLm5leHQ9ZS5uZXh0LHRoaXMudGFpbD10LHRoaXMubGVuKz1uKSx0aGlzfSxwLnByb3RvdHlwZS5maW5pc2g9ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy5oZWFkLm5leHQsdD10aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSxuPTA7ZTspZS5mbihlLnZhbCx0LG4pLG4rPWUubGVuLGU9ZS5uZXh0O3JldHVybiB0fSxwLl9jb25maWd1cmU9ZnVuY3Rpb24oZSl7cj1lLHAuY3JlYXRlPWQoKSxyLl9jb25maWd1cmUoKX19LDMxNTU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1pO3ZhciByPW4oMTE3Myk7KGkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1pO3ZhciBvPW4oOTY5Myk7ZnVuY3Rpb24gaSgpe3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBhKGUsdCxuKXtlLmxlbmd0aDw0MD9vLnV0Zjgud3JpdGUoZSx0LG4pOnQudXRmOFdyaXRlP3QudXRmOFdyaXRlKGUsbik6dC53cml0ZShlLG4pfWkuX2NvbmZpZ3VyZT1mdW5jdGlvbigpe2kuYWxsb2M9by5fQnVmZmVyX2FsbG9jVW5zYWZlLGkud3JpdGVCeXRlc0J1ZmZlcj1vLkJ1ZmZlciYmby5CdWZmZXIucHJvdG90eXBlIGluc3RhbmNlb2YgVWludDhBcnJheSYmXCJzZXRcIj09PW8uQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZT9mdW5jdGlvbihlLHQsbil7dC5zZXQoZSxuKX06ZnVuY3Rpb24oZSx0LG4pe2lmKGUuY29weSllLmNvcHkodCxuLDAsZS5sZW5ndGgpO2Vsc2UgZm9yKHZhciByPTA7cjxlLmxlbmd0aDspdFtuKytdPWVbcisrXX19LGkucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKGUpe28uaXNTdHJpbmcoZSkmJihlPW8uX0J1ZmZlcl9mcm9tKGUsXCJiYXNlNjRcIikpO3ZhciB0PWUubGVuZ3RoPj4+MDtyZXR1cm4gdGhpcy51aW50MzIodCksdCYmdGhpcy5fcHVzaChpLndyaXRlQnl0ZXNCdWZmZXIsdCxlKSx0aGlzfSxpLnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24oZSl7dmFyIHQ9by5CdWZmZXIuYnl0ZUxlbmd0aChlKTtyZXR1cm4gdGhpcy51aW50MzIodCksdCYmdGhpcy5fcHVzaChhLHQsZSksdGhpc30saS5fY29uZmlndXJlKCl9LDQxNTQ6ZT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz0nXCJ1c2Ugc3RyaWN0XCI7dmFyIGU9e30sdD1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7aWYodCl7dmFyIHI9cmVxdWlyZShcIndvcmtlcl90aHJlYWRzXCIpLGE9ci5wYXJlbnRQb3J0O2Eub24oXCJtZXNzYWdlXCIsKGU9Pm9ubWVzc2FnZSh7ZGF0YTplfSkpKTt2YXIgbz1yZXF1aXJlKFwiZnNcIik7T2JqZWN0LmFzc2lnbihnbG9iYWwse3NlbGY6Z2xvYmFsLHJlcXVpcmU6cmVxdWlyZSxNb2R1bGU6ZSxsb2NhdGlvbjp7aHJlZjpfX2ZpbGVuYW1lfSxXb3JrZXI6ci5Xb3JrZXIsaW1wb3J0U2NyaXB0czpmdW5jdGlvbihlKXsoMCxldmFsKShvLnJlYWRGaWxlU3luYyhlLFwidXRmOFwiKSl9LHBvc3RNZXNzYWdlOmZ1bmN0aW9uKGUpe2EucG9zdE1lc3NhZ2UoZSl9LHBlcmZvcm1hbmNlOmdsb2JhbC5wZXJmb3JtYW5jZXx8e25vdzpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfX19KX12YXIgcz0hMSxuPVtdLGk9ZnVuY3Rpb24oKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO3Q/by53cml0ZVN5bmMoMixlK1wiXFxcXG5cIik6Y29uc29sZS5lcnJvcihlKX07c2VsZi5hbGVydD1mdW5jdGlvbigpe3ZhciB0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIiBcIik7cG9zdE1lc3NhZ2Uoe2NtZDpcImFsZXJ0XCIsdGV4dDp0LHRocmVhZElkOmUuX3B0aHJlYWRfc2VsZigpfSl9LGUuaW5zdGFudGlhdGVXYXNtPSh0LHIpPT57dmFyIGE9bmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKGUud2FzbU1vZHVsZSx0KTtyZXR1cm4gcihhKSxlLndhc21Nb2R1bGU9bnVsbCxhLmV4cG9ydHN9LHNlbGYub251bmhhbmRsZWRyZWplY3Rpb249ZT0+e3Rocm93IGUucmVhc29uPz9lfSxzZWxmLm9ubWVzc2FnZT10PT57dHJ5e2lmKFwibG9hZFwiPT09dC5kYXRhLmNtZCl7aWYoZS53YXNtTW9kdWxlPXQuZGF0YS53YXNtTW9kdWxlLGUud2FzbU1lbW9yeT10LmRhdGEud2FzbU1lbW9yeSxlLmJ1ZmZlcj1lLndhc21NZW1vcnkuYnVmZmVyLGUuRU5WSVJPTk1FTlRfSVNfUFRIUkVBRD0hMCxcInN0cmluZ1wiPT10eXBlb2YgdC5kYXRhLnVybE9yQmxvYilpbXBvcnRTY3JpcHRzKHQuZGF0YS51cmxPckJsb2IpO2Vsc2V7dmFyIHI9VVJMLmNyZWF0ZU9iamVjdFVSTCh0LmRhdGEudXJsT3JCbG9iKTtpbXBvcnRTY3JpcHRzKHIpLFVSTC5yZXZva2VPYmplY3RVUkwocil9b3J0V2FzbVRocmVhZGVkKGUpLnRoZW4oKGZ1bmN0aW9uKHQpe2U9dH0pKX1lbHNlIGlmKFwicnVuXCI9PT10LmRhdGEuY21kKXtlLl9fcGVyZm9ybWFuY2Vfbm93X2Nsb2NrX2RyaWZ0PXBlcmZvcm1hbmNlLm5vdygpLXQuZGF0YS50aW1lLGUuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0KHQuZGF0YS5wdGhyZWFkX3B0ciwwLDAsMSksZS5lc3RhYmxpc2hTdGFja1NwYWNlKCksZS5QVGhyZWFkLnJlY2VpdmVPYmplY3RUcmFuc2Zlcih0LmRhdGEpLGUuUFRocmVhZC50aHJlYWRJbml0VExTKCksc3x8KG4uZm9yRWFjaCgodD0+e2UuZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZSh0KX0pKSxuPVtdLHM9ITApO3RyeXtlLmludm9rZUVudHJ5UG9pbnQodC5kYXRhLnN0YXJ0X3JvdXRpbmUsdC5kYXRhLmFyZyl9Y2F0Y2godCl7aWYoXCJ1bndpbmRcIiE9dCl7aWYoISh0IGluc3RhbmNlb2YgZS5FeGl0U3RhdHVzKSl0aHJvdyB0O2Uua2VlcFJ1bnRpbWVBbGl2ZSgpfHxlLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdCh0LnN0YXR1cyl9fX1lbHNlXCJjYW5jZWxcIj09PXQuZGF0YS5jbWQ/ZS5fcHRocmVhZF9zZWxmKCkmJmUuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0KC0xKTpcInNldGltbWVkaWF0ZVwiPT09dC5kYXRhLnRhcmdldHx8KFwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIj09PXQuZGF0YS5jbWQ/cz9lLmV4ZWN1dGVOb3RpZmllZFByb3h5aW5nUXVldWUodC5kYXRhLnF1ZXVlKTpuLnB1c2godC5kYXRhLnF1ZXVlKTooaShcIndvcmtlci5qcyByZWNlaXZlZCB1bmtub3duIGNvbW1hbmQgXCIrdC5kYXRhLmNtZCksaSh0LmRhdGEpKSl9Y2F0Y2godCl7dGhyb3cgaShcIndvcmtlci5qcyBvbm1lc3NhZ2UoKSBjYXB0dXJlZCBhbiB1bmNhdWdodCBleGNlcHRpb246IFwiK3QpLHQmJnQuc3RhY2smJmkodC5zdGFjayksZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQmJmUuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkKCksdH19O1xcbid9LDcwNjc6KCk9Pnt9LDEyOTY6KCk9Pnt9LDc2MDooKT0+e30sMTM4NDooKT0+e30sMzk5MzooKT0+e30sOTA4OigpPT57fSw2OTUzOigpPT57fSw5OTI1OigpPT57fSwyODA2OigpPT57fSw2NDQ5OigpPT57fSwyODUwOigpPT57fSw1MzgxOigpPT57fSw1Njg2OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtuLnIodCksbi5kKHQse2ZsYXRidWZmZXJzOigpPT5yfSk7dmFyIHI9e307ci5PZmZzZXQsci5UYWJsZSxyLlNJWkVPRl9TSE9SVD0yLHIuU0laRU9GX0lOVD00LHIuRklMRV9JREVOVElGSUVSX0xFTkdUSD00LHIuU0laRV9QUkVGSVhfTEVOR1RIPTQsci5FbmNvZGluZz17VVRGOF9CWVRFUzoxLFVURjE2X1NUUklORzoyfSxyLmludDMyPW5ldyBJbnQzMkFycmF5KDIpLHIuZmxvYXQzMj1uZXcgRmxvYXQzMkFycmF5KHIuaW50MzIuYnVmZmVyKSxyLmZsb2F0NjQ9bmV3IEZsb2F0NjRBcnJheShyLmludDMyLmJ1ZmZlciksci5pc0xpdHRsZUVuZGlhbj0xPT09bmV3IFVpbnQxNkFycmF5KG5ldyBVaW50OEFycmF5KFsxLDBdKS5idWZmZXIpWzBdLHIuTG9uZz1mdW5jdGlvbihlLHQpe3RoaXMubG93PTB8ZSx0aGlzLmhpZ2g9MHx0fSxyLkxvbmcuY3JlYXRlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDA9PWUmJjA9PXQ/ci5Mb25nLlpFUk86bmV3IHIuTG9uZyhlLHQpfSxyLkxvbmcucHJvdG90eXBlLnRvRmxvYXQ2ND1mdW5jdGlvbigpe3JldHVybih0aGlzLmxvdz4+PjApKzQyOTQ5NjcyOTYqdGhpcy5oaWdofSxyLkxvbmcucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5sb3c9PWUubG93JiZ0aGlzLmhpZ2g9PWUuaGlnaH0sci5Mb25nLlpFUk89bmV3IHIuTG9uZygwLDApLHIuQnVpbGRlcj1mdW5jdGlvbihlKXtpZihlKXQ9ZTtlbHNlIHZhciB0PTEwMjQ7dGhpcy5iYj1yLkJ5dGVCdWZmZXIuYWxsb2NhdGUodCksdGhpcy5zcGFjZT10LHRoaXMubWluYWxpZ249MSx0aGlzLnZ0YWJsZT1udWxsLHRoaXMudnRhYmxlX2luX3VzZT0wLHRoaXMuaXNOZXN0ZWQ9ITEsdGhpcy5vYmplY3Rfc3RhcnQ9MCx0aGlzLnZ0YWJsZXM9W10sdGhpcy52ZWN0b3JfbnVtX2VsZW1zPTAsdGhpcy5mb3JjZV9kZWZhdWx0cz0hMX0sci5CdWlsZGVyLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuYmIuY2xlYXIoKSx0aGlzLnNwYWNlPXRoaXMuYmIuY2FwYWNpdHkoKSx0aGlzLm1pbmFsaWduPTEsdGhpcy52dGFibGU9bnVsbCx0aGlzLnZ0YWJsZV9pbl91c2U9MCx0aGlzLmlzTmVzdGVkPSExLHRoaXMub2JqZWN0X3N0YXJ0PTAsdGhpcy52dGFibGVzPVtdLHRoaXMudmVjdG9yX251bV9lbGVtcz0wLHRoaXMuZm9yY2VfZGVmYXVsdHM9ITF9LHIuQnVpbGRlci5wcm90b3R5cGUuZm9yY2VEZWZhdWx0cz1mdW5jdGlvbihlKXt0aGlzLmZvcmNlX2RlZmF1bHRzPWV9LHIuQnVpbGRlci5wcm90b3R5cGUuZGF0YUJ1ZmZlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJifSxyLkJ1aWxkZXIucHJvdG90eXBlLmFzVWludDhBcnJheT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJiLmJ5dGVzKCkuc3ViYXJyYXkodGhpcy5iYi5wb3NpdGlvbigpLHRoaXMuYmIucG9zaXRpb24oKSt0aGlzLm9mZnNldCgpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5wcmVwPWZ1bmN0aW9uKGUsdCl7ZT50aGlzLm1pbmFsaWduJiYodGhpcy5taW5hbGlnbj1lKTtmb3IodmFyIG49MSt+KHRoaXMuYmIuY2FwYWNpdHkoKS10aGlzLnNwYWNlK3QpJmUtMTt0aGlzLnNwYWNlPG4rZSt0Oyl7dmFyIG89dGhpcy5iYi5jYXBhY2l0eSgpO3RoaXMuYmI9ci5CdWlsZGVyLmdyb3dCeXRlQnVmZmVyKHRoaXMuYmIpLHRoaXMuc3BhY2UrPXRoaXMuYmIuY2FwYWNpdHkoKS1vfXRoaXMucGFkKG4pfSxyLkJ1aWxkZXIucHJvdG90eXBlLnBhZD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MDt0PGU7dCsrKXRoaXMuYmIud3JpdGVJbnQ4KC0tdGhpcy5zcGFjZSwwKX0sci5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24oZSl7dGhpcy5iYi53cml0ZUludDgodGhpcy5zcGFjZS09MSxlKX0sci5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDE2PWZ1bmN0aW9uKGUpe3RoaXMuYmIud3JpdGVJbnQxNih0aGlzLnNwYWNlLT0yLGUpfSxyLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlSW50MzI9ZnVuY3Rpb24oZSl7dGhpcy5iYi53cml0ZUludDMyKHRoaXMuc3BhY2UtPTQsZSl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQ2ND1mdW5jdGlvbihlKXt0aGlzLmJiLndyaXRlSW50NjQodGhpcy5zcGFjZS09OCxlKX0sci5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUZsb2F0MzI9ZnVuY3Rpb24oZSl7dGhpcy5iYi53cml0ZUZsb2F0MzIodGhpcy5zcGFjZS09NCxlKX0sci5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUZsb2F0NjQ9ZnVuY3Rpb24oZSl7dGhpcy5iYi53cml0ZUZsb2F0NjQodGhpcy5zcGFjZS09OCxlKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRJbnQ4PWZ1bmN0aW9uKGUpe3RoaXMucHJlcCgxLDApLHRoaXMud3JpdGVJbnQ4KGUpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDE2PWZ1bmN0aW9uKGUpe3RoaXMucHJlcCgyLDApLHRoaXMud3JpdGVJbnQxNihlKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRJbnQzMj1mdW5jdGlvbihlKXt0aGlzLnByZXAoNCwwKSx0aGlzLndyaXRlSW50MzIoZSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50NjQ9ZnVuY3Rpb24oZSl7dGhpcy5wcmVwKDgsMCksdGhpcy53cml0ZUludDY0KGUpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZsb2F0MzI9ZnVuY3Rpb24oZSl7dGhpcy5wcmVwKDQsMCksdGhpcy53cml0ZUZsb2F0MzIoZSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmxvYXQ2ND1mdW5jdGlvbihlKXt0aGlzLnByZXAoOCwwKSx0aGlzLndyaXRlRmxvYXQ2NChlKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDg9ZnVuY3Rpb24oZSx0LG4peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHx0IT1uKSYmKHRoaXMuYWRkSW50OCh0KSx0aGlzLnNsb3QoZSkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkSW50MTY9ZnVuY3Rpb24oZSx0LG4peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHx0IT1uKSYmKHRoaXMuYWRkSW50MTYodCksdGhpcy5zbG90KGUpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDMyPWZ1bmN0aW9uKGUsdCxuKXsodGhpcy5mb3JjZV9kZWZhdWx0c3x8dCE9bikmJih0aGlzLmFkZEludDMyKHQpLHRoaXMuc2xvdChlKSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQ2ND1mdW5jdGlvbihlLHQsbil7IXRoaXMuZm9yY2VfZGVmYXVsdHMmJnQuZXF1YWxzKG4pfHwodGhpcy5hZGRJbnQ2NCh0KSx0aGlzLnNsb3QoZSkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkRmxvYXQzMj1mdW5jdGlvbihlLHQsbil7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fHQhPW4pJiYodGhpcy5hZGRGbG9hdDMyKHQpLHRoaXMuc2xvdChlKSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRGbG9hdDY0PWZ1bmN0aW9uKGUsdCxuKXsodGhpcy5mb3JjZV9kZWZhdWx0c3x8dCE9bikmJih0aGlzLmFkZEZsb2F0NjQodCksdGhpcy5zbG90KGUpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZE9mZnNldD1mdW5jdGlvbihlLHQsbil7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fHQhPW4pJiYodGhpcy5hZGRPZmZzZXQodCksdGhpcy5zbG90KGUpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZFN0cnVjdD1mdW5jdGlvbihlLHQsbil7dCE9biYmKHRoaXMubmVzdGVkKHQpLHRoaXMuc2xvdChlKSl9LHIuQnVpbGRlci5wcm90b3R5cGUubmVzdGVkPWZ1bmN0aW9uKGUpe2lmKGUhPXRoaXMub2Zmc2V0KCkpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IHN0cnVjdCBtdXN0IGJlIHNlcmlhbGl6ZWQgaW5saW5lLlwiKX0sci5CdWlsZGVyLnByb3RvdHlwZS5ub3ROZXN0ZWQ9ZnVuY3Rpb24oKXtpZih0aGlzLmlzTmVzdGVkKXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBvYmplY3Qgc2VyaWFsaXphdGlvbiBtdXN0IG5vdCBiZSBuZXN0ZWQuXCIpfSxyLkJ1aWxkZXIucHJvdG90eXBlLnNsb3Q9ZnVuY3Rpb24oZSl7dGhpcy52dGFibGVbZV09dGhpcy5vZmZzZXQoKX0sci5CdWlsZGVyLnByb3RvdHlwZS5vZmZzZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYi5jYXBhY2l0eSgpLXRoaXMuc3BhY2V9LHIuQnVpbGRlci5ncm93Qnl0ZUJ1ZmZlcj1mdW5jdGlvbihlKXt2YXIgdD1lLmNhcGFjaXR5KCk7aWYoMzIyMTIyNTQ3MiZ0KXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBjYW5ub3QgZ3JvdyBidWZmZXIgYmV5b25kIDIgZ2lnYWJ5dGVzLlwiKTt2YXIgbj10PDwxLG89ci5CeXRlQnVmZmVyLmFsbG9jYXRlKG4pO3JldHVybiBvLnNldFBvc2l0aW9uKG4tdCksby5ieXRlcygpLnNldChlLmJ5dGVzKCksbi10KSxvfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZE9mZnNldD1mdW5jdGlvbihlKXt0aGlzLnByZXAoci5TSVpFT0ZfSU5ULDApLHRoaXMud3JpdGVJbnQzMih0aGlzLm9mZnNldCgpLWUrci5TSVpFT0ZfSU5UKX0sci5CdWlsZGVyLnByb3RvdHlwZS5zdGFydE9iamVjdD1mdW5jdGlvbihlKXt0aGlzLm5vdE5lc3RlZCgpLG51bGw9PXRoaXMudnRhYmxlJiYodGhpcy52dGFibGU9W10pLHRoaXMudnRhYmxlX2luX3VzZT1lO2Zvcih2YXIgdD0wO3Q8ZTt0KyspdGhpcy52dGFibGVbdF09MDt0aGlzLmlzTmVzdGVkPSEwLHRoaXMub2JqZWN0X3N0YXJ0PXRoaXMub2Zmc2V0KCl9LHIuQnVpbGRlci5wcm90b3R5cGUuZW5kT2JqZWN0PWZ1bmN0aW9uKCl7aWYobnVsbD09dGhpcy52dGFibGV8fCF0aGlzLmlzTmVzdGVkKXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBlbmRPYmplY3QgY2FsbGVkIHdpdGhvdXQgc3RhcnRPYmplY3RcIik7dGhpcy5hZGRJbnQzMigwKTtmb3IodmFyIGU9dGhpcy5vZmZzZXQoKSx0PXRoaXMudnRhYmxlX2luX3VzZS0xO3Q+PTAmJjA9PXRoaXMudnRhYmxlW3RdO3QtLSk7Zm9yKHZhciBuPXQrMTt0Pj0wO3QtLSl0aGlzLmFkZEludDE2KDAhPXRoaXMudnRhYmxlW3RdP2UtdGhpcy52dGFibGVbdF06MCk7dGhpcy5hZGRJbnQxNihlLXRoaXMub2JqZWN0X3N0YXJ0KTt2YXIgbz0obisyKSpyLlNJWkVPRl9TSE9SVDt0aGlzLmFkZEludDE2KG8pO3ZhciBpPTAsYT10aGlzLnNwYWNlO2U6Zm9yKHQ9MDt0PHRoaXMudnRhYmxlcy5sZW5ndGg7dCsrKXt2YXIgcz10aGlzLmJiLmNhcGFjaXR5KCktdGhpcy52dGFibGVzW3RdO2lmKG89PXRoaXMuYmIucmVhZEludDE2KHMpKXtmb3IodmFyIHU9ci5TSVpFT0ZfU0hPUlQ7dTxvO3UrPXIuU0laRU9GX1NIT1JUKWlmKHRoaXMuYmIucmVhZEludDE2KGErdSkhPXRoaXMuYmIucmVhZEludDE2KHMrdSkpY29udGludWUgZTtpPXRoaXMudnRhYmxlc1t0XTticmVha319cmV0dXJuIGk/KHRoaXMuc3BhY2U9dGhpcy5iYi5jYXBhY2l0eSgpLWUsdGhpcy5iYi53cml0ZUludDMyKHRoaXMuc3BhY2UsaS1lKSk6KHRoaXMudnRhYmxlcy5wdXNoKHRoaXMub2Zmc2V0KCkpLHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLmJiLmNhcGFjaXR5KCktZSx0aGlzLm9mZnNldCgpLWUpKSx0aGlzLmlzTmVzdGVkPSExLGV9LHIuQnVpbGRlci5wcm90b3R5cGUuZmluaXNoPWZ1bmN0aW9uKGUsdCxuKXt2YXIgbz1uP3IuU0laRV9QUkVGSVhfTEVOR1RIOjA7aWYodCl7dmFyIGk9dDtpZih0aGlzLnByZXAodGhpcy5taW5hbGlnbixyLlNJWkVPRl9JTlQrci5GSUxFX0lERU5USUZJRVJfTEVOR1RIK28pLGkubGVuZ3RoIT1yLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IGZpbGUgaWRlbnRpZmllciBtdXN0IGJlIGxlbmd0aCBcIityLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpO2Zvcih2YXIgYT1yLkZJTEVfSURFTlRJRklFUl9MRU5HVEgtMTthPj0wO2EtLSl0aGlzLndyaXRlSW50OChpLmNoYXJDb2RlQXQoYSkpfXRoaXMucHJlcCh0aGlzLm1pbmFsaWduLHIuU0laRU9GX0lOVCtvKSx0aGlzLmFkZE9mZnNldChlKSxvJiZ0aGlzLmFkZEludDMyKHRoaXMuYmIuY2FwYWNpdHkoKS10aGlzLnNwYWNlKSx0aGlzLmJiLnNldFBvc2l0aW9uKHRoaXMuc3BhY2UpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmZpbmlzaFNpemVQcmVmaXhlZD1mdW5jdGlvbihlLHQpe3RoaXMuZmluaXNoKGUsdCwhMCl9LHIuQnVpbGRlci5wcm90b3R5cGUucmVxdWlyZWRGaWVsZD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMuYmIuY2FwYWNpdHkoKS1lLHI9bi10aGlzLmJiLnJlYWRJbnQzMihuKTtpZigwPT10aGlzLmJiLnJlYWRJbnQxNihyK3QpKXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBmaWVsZCBcIit0K1wiIG11c3QgYmUgc2V0XCIpfSxyLkJ1aWxkZXIucHJvdG90eXBlLnN0YXJ0VmVjdG9yPWZ1bmN0aW9uKGUsdCxuKXt0aGlzLm5vdE5lc3RlZCgpLHRoaXMudmVjdG9yX251bV9lbGVtcz10LHRoaXMucHJlcChyLlNJWkVPRl9JTlQsZSp0KSx0aGlzLnByZXAobixlKnQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmVuZFZlY3Rvcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLndyaXRlSW50MzIodGhpcy52ZWN0b3JfbnVtX2VsZW1zKSx0aGlzLm9mZnNldCgpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmNyZWF0ZVN0cmluZz1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgVWludDhBcnJheSl2YXIgdD1lO2Vsc2V7dD1bXTtmb3IodmFyIG49MDtuPGUubGVuZ3RoOyl7dmFyIHIsbz1lLmNoYXJDb2RlQXQobisrKTsocj1vPDU1Mjk2fHxvPj01NjMyMD9vOihvPDwxMCkrZS5jaGFyQ29kZUF0KG4rKykrLTU2NjEzODg4KTwxMjg/dC5wdXNoKHIpOihyPDIwNDg/dC5wdXNoKHI+PjYmMzF8MTkyKToocjw2NTUzNj90LnB1c2gocj4+MTImMTV8MjI0KTp0LnB1c2gocj4+MTgmN3wyNDAscj4+MTImNjN8MTI4KSx0LnB1c2gocj4+NiY2M3wxMjgpKSx0LnB1c2goNjMmcnwxMjgpKX19dGhpcy5hZGRJbnQ4KDApLHRoaXMuc3RhcnRWZWN0b3IoMSx0Lmxlbmd0aCwxKSx0aGlzLmJiLnNldFBvc2l0aW9uKHRoaXMuc3BhY2UtPXQubGVuZ3RoKSxuPTA7Zm9yKHZhciBpPXRoaXMuc3BhY2UsYT10aGlzLmJiLmJ5dGVzKCk7bjx0Lmxlbmd0aDtuKyspYVtpKytdPXRbbl07cmV0dXJuIHRoaXMuZW5kVmVjdG9yKCl9LHIuQnVpbGRlci5wcm90b3R5cGUuY3JlYXRlTG9uZz1mdW5jdGlvbihlLHQpe3JldHVybiByLkxvbmcuY3JlYXRlKGUsdCl9LHIuQnl0ZUJ1ZmZlcj1mdW5jdGlvbihlKXt0aGlzLmJ5dGVzXz1lLHRoaXMucG9zaXRpb25fPTB9LHIuQnl0ZUJ1ZmZlci5hbGxvY2F0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHIuQnl0ZUJ1ZmZlcihuZXcgVWludDhBcnJheShlKSl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLnBvc2l0aW9uXz0wfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnl0ZXNffSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnBvc2l0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9zaXRpb25ffSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnNldFBvc2l0aW9uPWZ1bmN0aW9uKGUpe3RoaXMucG9zaXRpb25fPWV9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuY2FwYWNpdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ieXRlc18ubGVuZ3RofSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlYWRVaW50OChlKTw8MjQ+PjI0fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50OD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5ieXRlc19bZV19LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlYWRVaW50MTYoZSk8PDE2Pj4xNn0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmJ5dGVzX1tlXXx0aGlzLmJ5dGVzX1tlKzFdPDw4fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5ieXRlc19bZV18dGhpcy5ieXRlc19bZSsxXTw8OHx0aGlzLmJ5dGVzX1tlKzJdPDwxNnx0aGlzLmJ5dGVzX1tlKzNdPDwyNH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlYWRJbnQzMihlKT4+PjB9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDY0PWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgci5Mb25nKHRoaXMucmVhZEludDMyKGUpLHRoaXMucmVhZEludDMyKGUrNCkpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50NjQ9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyByLkxvbmcodGhpcy5yZWFkVWludDMyKGUpLHRoaXMucmVhZFVpbnQzMihlKzQpKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXQzMj1mdW5jdGlvbihlKXtyZXR1cm4gci5pbnQzMlswXT10aGlzLnJlYWRJbnQzMihlKSxyLmZsb2F0MzJbMF19LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0NjQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHIuaW50MzJbci5pc0xpdHRsZUVuZGlhbj8wOjFdPXRoaXMucmVhZEludDMyKGUpLHIuaW50MzJbci5pc0xpdHRsZUVuZGlhbj8xOjBdPXRoaXMucmVhZEludDMyKGUrNCksci5mbG9hdDY0WzBdfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbihlLHQpe3RoaXMuYnl0ZXNfW2VdPXR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50OD1mdW5jdGlvbihlLHQpe3RoaXMuYnl0ZXNfW2VdPXR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNj1mdW5jdGlvbihlLHQpe3RoaXMuYnl0ZXNfW2VdPXQsdGhpcy5ieXRlc19bZSsxXT10Pj44fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2PWZ1bmN0aW9uKGUsdCl7dGhpcy5ieXRlc19bZV09dCx0aGlzLmJ5dGVzX1tlKzFdPXQ+Pjh9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMj1mdW5jdGlvbihlLHQpe3RoaXMuYnl0ZXNfW2VdPXQsdGhpcy5ieXRlc19bZSsxXT10Pj44LHRoaXMuYnl0ZXNfW2UrMl09dD4+MTYsdGhpcy5ieXRlc19bZSszXT10Pj4yNH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMj1mdW5jdGlvbihlLHQpe3RoaXMuYnl0ZXNfW2VdPXQsdGhpcy5ieXRlc19bZSsxXT10Pj44LHRoaXMuYnl0ZXNfW2UrMl09dD4+MTYsdGhpcy5ieXRlc19bZSszXT10Pj4yNH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDY0PWZ1bmN0aW9uKGUsdCl7dGhpcy53cml0ZUludDMyKGUsdC5sb3cpLHRoaXMud3JpdGVJbnQzMihlKzQsdC5oaWdoKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ2ND1mdW5jdGlvbihlLHQpe3RoaXMud3JpdGVVaW50MzIoZSx0LmxvdyksdGhpcy53cml0ZVVpbnQzMihlKzQsdC5oaWdoKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0MzI9ZnVuY3Rpb24oZSx0KXtyLmZsb2F0MzJbMF09dCx0aGlzLndyaXRlSW50MzIoZSxyLmludDMyWzBdKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0NjQ9ZnVuY3Rpb24oZSx0KXtyLmZsb2F0NjRbMF09dCx0aGlzLndyaXRlSW50MzIoZSxyLmludDMyW3IuaXNMaXR0bGVFbmRpYW4/MDoxXSksdGhpcy53cml0ZUludDMyKGUrNCxyLmludDMyW3IuaXNMaXR0bGVFbmRpYW4/MTowXSl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuZ2V0QnVmZmVySWRlbnRpZmllcj1mdW5jdGlvbigpe2lmKHRoaXMuYnl0ZXNfLmxlbmd0aDx0aGlzLnBvc2l0aW9uXytyLlNJWkVPRl9JTlQrci5GSUxFX0lERU5USUZJRVJfTEVOR1RIKXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBCeXRlQnVmZmVyIGlzIHRvbyBzaG9ydCB0byBjb250YWluIGFuIGlkZW50aWZpZXIuXCIpO2Zvcih2YXIgZT1cIlwiLHQ9MDt0PHIuRklMRV9JREVOVElGSUVSX0xFTkdUSDt0KyspZSs9U3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRJbnQ4KHRoaXMucG9zaXRpb25fK3IuU0laRU9GX0lOVCt0KSk7cmV0dXJuIGV9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19vZmZzZXQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLXRoaXMucmVhZEludDMyKGUpO3JldHVybiB0PHRoaXMucmVhZEludDE2KG4pP3RoaXMucmVhZEludDE2KG4rdCk6MH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3VuaW9uPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuYmJfcG9zPXQrdGhpcy5yZWFkSW50MzIodCksZS5iYj10aGlzLGV9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19zdHJpbmc9ZnVuY3Rpb24oZSx0KXtlKz10aGlzLnJlYWRJbnQzMihlKTt2YXIgbj10aGlzLnJlYWRJbnQzMihlKSxvPVwiXCIsaT0wO2lmKGUrPXIuU0laRU9GX0lOVCx0PT09ci5FbmNvZGluZy5VVEY4X0JZVEVTKXJldHVybiB0aGlzLmJ5dGVzXy5zdWJhcnJheShlLGUrbik7Zm9yKDtpPG47KXt2YXIgYSxzPXRoaXMucmVhZFVpbnQ4KGUraSsrKTtpZihzPDE5MilhPXM7ZWxzZXt2YXIgdT10aGlzLnJlYWRVaW50OChlK2krKyk7aWYoczwyMjQpYT0oMzEmcyk8PDZ8NjMmdTtlbHNle3ZhciBsPXRoaXMucmVhZFVpbnQ4KGUraSsrKTthPXM8MjQwPygxNSZzKTw8MTJ8KDYzJnUpPDw2fDYzJmw6KDcmcyk8PDE4fCg2MyZ1KTw8MTJ8KDYzJmwpPDw2fDYzJnRoaXMucmVhZFVpbnQ4KGUraSsrKX19YTw2NTUzNj9vKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpOihhLT02NTUzNixvKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2KyhhPj4xMCksNTYzMjArKDEwMjMmYSkpKX1yZXR1cm4gb30sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX2luZGlyZWN0PWZ1bmN0aW9uKGUpe3JldHVybiBlK3RoaXMucmVhZEludDMyKGUpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fdmVjdG9yPWZ1bmN0aW9uKGUpe3JldHVybiBlK3RoaXMucmVhZEludDMyKGUpK3IuU0laRU9GX0lOVH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3ZlY3Rvcl9sZW49ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVhZEludDMyKGUrdGhpcy5yZWFkSW50MzIoZSkpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9faGFzX2lkZW50aWZpZXI9ZnVuY3Rpb24oZSl7aWYoZS5sZW5ndGghPXIuRklMRV9JREVOVElGSUVSX0xFTkdUSCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogZmlsZSBpZGVudGlmaWVyIG11c3QgYmUgbGVuZ3RoIFwiK3IuRklMRV9JREVOVElGSUVSX0xFTkdUSCk7Zm9yKHZhciB0PTA7dDxyLkZJTEVfSURFTlRJRklFUl9MRU5HVEg7dCsrKWlmKGUuY2hhckNvZGVBdCh0KSE9dGhpcy5yZWFkSW50OCh0aGlzLnBvc2l0aW9uXytyLlNJWkVPRl9JTlQrdCkpcmV0dXJuITE7cmV0dXJuITB9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuY3JlYXRlTG9uZz1mdW5jdGlvbihlLHQpe3JldHVybiByLkxvbmcuY3JlYXRlKGUsdCl9fX0sX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fPXt9O2Z1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18oZSl7dmFyIHQ9X193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW2VdO2lmKHZvaWQgMCE9PXQpcmV0dXJuIHQuZXhwb3J0czt2YXIgbj1fX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bZV09e2V4cG9ydHM6e319O3JldHVybiBfX3dlYnBhY2tfbW9kdWxlc19fW2VdLmNhbGwobi5leHBvcnRzLG4sbi5leHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pLG4uZXhwb3J0c31fX3dlYnBhY2tfcmVxdWlyZV9fLm49ZT0+e3ZhciB0PWUmJmUuX19lc01vZHVsZT8oKT0+ZS5kZWZhdWx0OigpPT5lO3JldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fLmQodCx7YTp0fSksdH0sX193ZWJwYWNrX3JlcXVpcmVfXy5kPShlLHQpPT57Zm9yKHZhciBuIGluIHQpX193ZWJwYWNrX3JlcXVpcmVfXy5vKHQsbikmJiFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZSxuKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7ZW51bWVyYWJsZTohMCxnZXQ6dFtuXX0pfSxfX3dlYnBhY2tfcmVxdWlyZV9fLmc9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZ2xvYmFsVGhpcylyZXR1cm4gZ2xvYmFsVGhpczt0cnl7cmV0dXJuIHRoaXN8fG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCl9Y2F0Y2goZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdylyZXR1cm4gd2luZG93fX0oKSxfX3dlYnBhY2tfcmVxdWlyZV9fLm89KGUsdCk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpLF9fd2VicGFja19yZXF1aXJlX18ucj1lPT57XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX07dmFyIF9fd2VicGFja19leHBvcnRzX189X193ZWJwYWNrX3JlcXVpcmVfXygxMDU3KTtyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfX30pKCkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ydC5taW4uanMubWFwIiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiXFxuICAgIHpvb21BbmRQYW49XFxcIm1hZ25pZnlcXFwiIHZpZXdCb3g9XFxcIjAgMCA3NjggNzY3Ljk5OTk5NFxcXCJcXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pZFlNaWQgbWVldFxcXCIgdmVyc2lvbj1cXFwiMS4wXFxcIj5cXG4gICAgPHBhdGggY2xhc3M9XFxcImNpcmNsZVxcXCIgZmlsbD1cXFwiIzQxOGEyZlxcXCJcXG4gICAgICAgIGQ9XFxcIk0gNzY3Ljk4ODI4MSAzODMuOTg0Mzc1IEMgNzY3Ljk4ODI4MSA1OTYuMDU4NTk0IDU5Ni4wNjY0MDYgNzY3Ljk4MDQ2OSAzODMuOTk2MDk0IDc2Ny45ODA0NjkgQyAxNzEuOTIxODc1IDc2Ny45ODA0NjkgMCA1OTYuMDU4NTk0IDAgMzgzLjk4NDM3NSBDIDAgMTcxLjkxMDE1NiAxNzEuOTIxODc1IC0wLjAwNzgxMjUgMzgzLjk5NjA5NCAtMC4wMDc4MTI1IEMgNTk2LjA2NjQwNiAtMC4wMDc4MTI1IDc2Ny45ODgyODEgMTcxLjkxMDE1NiA3NjcuOTg4MjgxIDM4My45ODQzNzUgXFxcIlxcbiAgICAgICAgZmlsbC1vcGFjaXR5PVxcXCIxXFxcIiBmaWxsLXJ1bGU9XFxcIm5vbnplcm9cXFwiIC8+XFxuICAgIDxwYXRoIGNsYXNzPVxcXCJwaG9uZS1yZWNlaXZlclxcXCIgZmlsbD1cXFwiI2ZmZmZmZlxcXCJcXG4gICAgICAgIGQ9XFxcIk0gMjE1LjcyNjU2MiAxOTkuNzczNDM4IEMgMjE5Ljc0NjA5NCAxOTQuODM1OTM4IDIzMC4wMjM0MzggMTgzLjYyNSAyNDMuNjQ0NTMxIDE4My43Njk1MzEgQyAyNDQuNDA2MjUgMTgzLjc3NzM0NCAyNDUuMzAwNzgxIDE4My44MDg1OTQgMjQ2LjM0Mzc1IDE4My45MTQwNjIgQyAyNDYuMzQzNzUgMTgzLjkxNDA2MiAyNDguNDkyMTg4IDE4NC4xNDQ1MzEgMjUwLjYxMzI4MSAxODQuNzAzMTI1IEMgMjY4LjI5Mjk2OSAxODkuNDEwMTU2IDI5OS45MjE4NzUgMjI0LjMwNDY4OCAyOTkuOTIxODc1IDIyNC4zMDQ2ODggQyAzMjYuOTI1NzgxIDI1NC4wOTM3NSAzMzQuNzIyNjU2IDI1NS41MzEyNSAzMzQuNjM2NzE5IDI2Ni41IEMgMzM0LjU1MDc4MSAyNzYuNzc3MzQ0IDMyOC4xNDA2MjUgMjg0LjcxODc1IDMxNi4yNTM5MDYgMjk2LjU2NjQwNiBDIDI4NC41NjY0MDYgMzI4LjE0ODQzOCAyNzcuODA4NTk0IDMzMC41MzEyNSAyNzUuMzUxNTYyIDM0MC40MjE4NzUgQyAyNzMuOTAyMzQ0IDM0Ni4yMzQzNzUgMjY5LjUzOTA2MiAzNTcuNTExNzE5IDI4OS4xMDU0NjkgMzc5LjM1NTQ2OSBDIDMxOC4yODkwNjIgNDExLjkyOTY4OCAzODguMTg3NSA0NzguNDM3NSAzOTQuMzAwNzgxIDQ4Mi41MTU2MjUgQyA0MDAuNDAyMzQ0IDQ4Ni41ODU5MzggNDIyLjEyMTA5NCA1MDAuODMyMDMxIDQ1MS4zMDA3ODEgNDc0LjM3MTA5NCBDIDQ3MS4yMjY1NjIgNDU2LjMwNDY4OCA0ODAuNzE0ODQ0IDQzNS4wNjY0MDYgNDk0Ljg3NSA0MzMuNzg1MTU2IEMgNTAyLjM2MzI4MSA0MzMuMDg5ODQ0IDUwNy44Nzg5MDYgNDM3LjYxMzI4MSA1MTkuMTY3OTY5IDQ0Ny4yMjI2NTYgQyA1ODUuODg2NzE5IDUwMy45NzY1NjIgNTg2Ljg3MTA5NCA1MTMuOTMzNTk0IDU4Ni4zMTI1IDUxOS44MjQyMTkgQyA1ODUuMzU1NDY5IDUzMC4wMTE3MTkgNTgwLjc1IDUzOS4yMTA5MzggNTY1LjMxNjQwNiA1NTAuMzgyODEyIEMgNTI1Ljk1MzEyNSA1NzguODc4OTA2IDUwOC4zMTI1IDYwMy45OTIxODggNDI4LjIzNDM3NSA1NzAuNzQyMTg4IEMgMzQ4LjE1MjM0NCA1MzcuNDg0Mzc1IDI2My45OTYwOTQgNDUzLjMzNTkzOCAyNDAuMjQyMTg4IDQxNy4zNTkzNzUgQyAyMTYuNDg4MjgxIDM4MS4zOTA2MjUgMTc5LjE2MDE1NiAzMjYuNDIxODc1IDE4MS44Nzg5MDYgMjg4LjQxNDA2MiBDIDE4My43Njk1MzEgMjYxLjk4MDQ2OSAxOTEuODY3MTg4IDIzOC44NjMyODEgMTkxLjg2NzE4OCAyMzguODYzMjgxIEMgMTk5LjA5NzY1NiAyMjAuODgyODEyIDIwOC43MTg3NSAyMDcuODc4OTA2IDIxNS43MjY1NjIgMTk5Ljc3MzQzOCBcXFwiXFxuICAgICAgICBmaWxsLW9wYWNpdHk9XFxcIjFcXFwiIGZpbGwtcnVsZT1cXFwibm9uemVyb1xcXCIgLz5cXG48L3N2Zz5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIjw/eG1sIHZlcnNpb249XFxcIjEuMFxcXCIgZW5jb2Rpbmc9XFxcIlVURi04XFxcIj8+XFxuPHN2ZyBpZD1cXFwiTGF5ZXJfMVxcXCIgZGF0YS1uYW1lPVxcXCJMYXllciAxXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCA2NC4wNiA2NC4zM1xcXCI+XFxuICA8ZGVmcz5cXG4gICAgPHN0eWxlPlxcbiAgICAgIC5pbm5lciB7XFxuICAgICAgICBmaWxsOiAjMjQzODFiO1xcbiAgICAgIH1cXG5cXG4gICAgICAuaW5uZXIsIC5vdXRlciB7XFxuICAgICAgICBzdHJva2Utd2lkdGg6IDBweDtcXG4gICAgICB9XFxuXFxuICAgICAgLm91dGVyIHtcXG4gICAgICAgIGZpbGw6ICNkZmQ3YzI7XFxuICAgICAgfVxcbiAgICA8L3N0eWxlPlxcbiAgPC9kZWZzPlxcbiAgPHBhdGggY2xhc3M9XFxcIm91dGVyXFxcIiBkPVxcXCJtMzEuNzEsNjQuMzJDMTQuNzcsNjQuNDYtLjQ0LDQ5LjkzLDAsMzEuMzMuNDEsMTQuNDcsMTQuMjktLjMyLDMyLjcsMGMxNi45MS4zLDMxLjgsMTQuMzIsMzEuMzYsMzMuMTQtLjM5LDE2Ljc2LTE0LjQ5LDMxLjU1LTMyLjM0LDMxLjE4Wm0xMC42Ny0yMy4xOWMuMDYtLjctLjQxLTEuMTItLjg0LTEuNTUtMi0yLTMuOTQtNC4wNy02LjAyLTUuOTctMS4xNC0xLjA0LTEuMzItMS42OC0uMDYtMi44MiwyLjEzLTEuOTMsNC4wNy00LjA4LDYuMS02LjEyLjc4LS43OSwxLjMxLTEuNjQuMzQtMi41Ni0uOTItLjg3LTEuNzItLjI4LTIuNDMuNDUtMi4xNywyLjIxLTQuMzksNC4zOS02LjUyLDYuNjUtLjcyLjc3LTEuMTYuNy0xLjg0LS4wMi0yLjA2LTIuMTctNC4xOS00LjI4LTYuMjktNi40MS0uNzYtLjc3LTEuNTktMS42OC0yLjY2LS42My0xLjE0LDEuMTItLjE5LDEuOTguNjIsMi43OSwyLjA3LDIuMDksNC4wOSw0LjIyLDYuMiw2LjI2Ljc3Ljc1LjgyLDEuMi4wMiwxLjk3LTIuMjEsMi4xLTQuMzMsNC4zLTYuNDksNi40NS0uNzkuNzgtMS4zLDEuNjUtLjMyLDIuNTYuOTIuODUsMS43MS4yNiwyLjQzLS40NywyLjExLTIuMTIsNC4yOC00LjE5LDYuMzMtNi4zOC44OC0uOTQsMS4zNy0uODYsMi4yMS4wMywyLjEzLDIuMjYsNC4zNyw0LjQxLDYuNTcsNi42LjUxLjUxLDEuMDkuNzgsMS44LjQ4LjU2LS4yNC44NS0uNjguODctMS4zWlxcXCIvPlxcbiAgPHBhdGggY2xhc3M9XFxcImlubmVyXFxcIiBkPVxcXCJtNDIuNDcsNDEuMjdjLS4wMi42Mi0uMzIsMS4wNi0uODcsMS4zLS43MS4zMS0xLjI5LjAzLTEuOC0uNDgtMi4yLTIuMi00LjQ0LTQuMzUtNi41Ny02LjYtLjg0LS44OS0xLjMzLS45Ni0yLjIxLS4wMy0yLjA0LDIuMTktNC4yMiw0LjI1LTYuMzMsNi4zOC0uNzIuNzItMS41MSwxLjMyLTIuNDMuNDctLjk4LS45MS0uNDctMS43OC4zMi0yLjU2LDIuMTYtMi4xNSw0LjI4LTQuMzUsNi40OS02LjQ1LjgxLS43Ny43Ni0xLjIyLS4wMi0xLjk3LTIuMTEtMi4wNC00LjEzLTQuMTctNi4yLTYuMjYtLjgtLjgxLTEuNzUtMS42Ny0uNjItMi43OSwxLjA3LTEuMDUsMS45LS4xNCwyLjY2LjYzLDIuMSwyLjEzLDQuMjMsNC4yNCw2LjI5LDYuNDEuNjkuNzMsMS4xMi43OSwxLjg0LjAyLDIuMTMtMi4yNiw0LjM1LTQuNDMsNi41Mi02LjY1LjcyLS43MywxLjUxLTEuMzEsMi40My0uNDUuOTcuOTIuNDQsMS43OC0uMzQsMi41Ni0yLjAzLDIuMDQtMy45Nyw0LjE5LTYuMSw2LjEyLTEuMjUsMS4xNC0xLjA4LDEuNzguMDYsMi44MiwyLjA5LDEuOTEsNC4wMiwzLjk3LDYuMDIsNS45Ny40My40My45Ljg1Ljg0LDEuNTVaXFxcIi8+XFxuPC9zdmc+XCI7IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiXFxuICAgIHpvb21BbmRQYW49XFxcIm1hZ25pZnlcXFwiIHZpZXdCb3g9XFxcIjAgMCA3NjggNzY3Ljk5OTk5NFxcXCJcXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pZFlNaWQgbWVldFxcXCIgdmVyc2lvbj1cXFwiMS4wXFxcIj5cXG4gICAgPHBhdGggZmlsbD1cXFwiIzc3NmQ2ZFxcXCJcXG4gICAgICAgIGQ9XFxcIk0gNzY4IDM4NCBDIDc2OCA1OTYuMDc0MjE5IDU5Ni4wNzQyMTkgNzY4IDM4NCA3NjggQyAxNzEuOTI1NzgxIDc2OCAwIDU5Ni4wNzQyMTkgMCAzODQgQyAwIDE3MS45MjU3ODEgMTcxLjkyNTc4MSAwIDM4NCAwIEMgNTk2LjA3NDIxOSAwIDc2OCAxNzEuOTI1NzgxIDc2OCAzODQgXFxcIlxcbiAgICAgICAgZmlsbC1vcGFjaXR5PVxcXCIxXFxcIiBmaWxsLXJ1bGU9XFxcIm5vbnplcm9cXFwiIC8+XFxuICAgIDxwYXRoIGZpbGw9XFxcIiNmZmZmZmZcXFwiXFxuICAgICAgICBkPVxcXCJNIDE1My42OTUzMTIgNDE4Ljk2ODc1IEMgMTUzLjcxODc1IDQxOC45NzI2NTYgMTY3Ljc3MzQzOCA0NTUuMTA1NDY5IDE4My42MzY3MTkgNDY0LjUwNzgxMiBDIDE5My45MjU3ODEgNDcwLjU4NTkzOCAyMDIuNTIzNDM4IDQ2Ny4zMjAzMTIgMjEzLjYyNSA0NjIuMDg1OTM4IEMgMjM1LjIzNDM3NSA0NTEuODkwNjI1IDI1Ny4zNDc2NTYgNDQyLjQ3NjU2MiAyODAuNDgwNDY5IDQzNS45NTMxMjUgQyAyODYuODU1NDY5IDQzNC4xNTIzNDQgMjkwLjgzMjAzMSA0MjcuODkwNjI1IDI4OS4yNjU2MjUgNDIxLjcyMjY1NiBDIDI4Ni40MDIzNDQgNDEwLjY4NzUgMjgzLjQ4MDQ2OSAzOTkuNjYwMTU2IDI4MC41MDc4MTIgMzg4LjY0NDUzMSBDIDI3OC44MDg1OTQgMzgyLjUxMTcxOSAyODMuNTIzNDM4IDM3NS45ODgyODEgMjkxLjE0ODQzOCAzNzQuMzYzMjgxIEMgMzIwLjI4MTI1IDM2OC4xMjg5MDYgMzUwLjE1MjM0NCAzNjQuOTIxODc1IDM4MC4wMzkwNjIgMzY0Ljc2OTUzMSBDIDM4MS4zNTkzNzUgMzY0Ljc2OTUzMSAzODYuNjQwNjI1IDM2NC43Njk1MzEgMzg3Ljk2MDkzOCAzNjQuNzY5NTMxIEMgNDE3Ljg0NzY1NiAzNjQuOTIxODc1IDQ0Ny43MTQ4NDQgMzY4LjEyODkwNiA0NzYuODUxNTYyIDM3NC4zNjMyODEgQyA0ODQuNDc2NTYyIDM3NS45ODgyODEgNDg5LjE5MTQwNiAzODIuNTExNzE5IDQ4Ny40OTIxODggMzg4LjY0NDUzMSBDIDQ4NC41MTk1MzEgMzk5LjY2MDE1NiA0ODEuNTk3NjU2IDQxMC42ODc1IDQ3OC43MzQzNzUgNDIxLjcyMjY1NiBDIDQ3Ny4xNjc5NjkgNDI3Ljg5MDYyNSA0ODEuMTQ0NTMxIDQzNC4xNTIzNDQgNDg3LjUxOTUzMSA0MzUuOTUzMTI1IEMgNTEwLjY1MjM0NCA0NDIuNDc2NTYyIDUzMi43NjU2MjUgNDUxLjg5MDYyNSA1NTQuMzc1IDQ2Mi4wODU5MzggQyA1NjUuNDc2NTYyIDQ2Ny4zMjAzMTIgNTc0LjA3NDIxOSA0NzAuNTg1OTM4IDU4NC4zNjMyODEgNDY0LjUwNzgxMiBDIDYwMC4yMjY1NjIgNDU1LjEwNTQ2OSA2MTQuMjgxMjUgNDE4Ljk3MjY1NiA2MTQuMzA0Njg4IDQxOC45Njg3NSBDIDYyNy42NjQwNjIgMzkwLjczMDQ2OSA2MTkuMDQyOTY5IDM1OS4xMTcxODggNTgyLjE2Nzk2OSAzNDIuNTUwNzgxIEMgNTE5Ljk2MDkzOCAzMTQuODM5ODQ0IDQ1Ny4zMjAzMTIgMzAwLjY0MDYyNSAzODguMTQwNjI1IDMwMC4yMDMxMjUgQyAzODYuNzY1NjI1IDMwMC4yMDMxMjUgMzgxLjIzODI4MSAzMDAuMjAzMTI1IDM3OS44NTU0NjkgMzAwLjIwMzEyNSBDIDMxMC42Nzk2ODggMzAwLjY0MDYyNSAyNDguMDM5MDYyIDMxNC44Mzk4NDQgMTg1LjgzMjAzMSAzNDIuNTUwNzgxIEMgMTQ4Ljk0OTIxOSAzNTkuMTE3MTg4IDE0MC4zMzU5MzggMzkwLjczMDQ2OSAxNTMuNjk1MzEyIDQxOC45Njg3NSBcXFwiXFxuICAgICAgICBmaWxsLW9wYWNpdHk9XFxcIjFcXFwiIGZpbGwtcnVsZT1cXFwibm9uemVyb1xcXCIgLz5cXG48L3N2Zz5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCJcXG4gICAgem9vbUFuZFBhbj1cXFwibWFnbmlmeVxcXCIgdmlld0JveD1cXFwiMCAwIDc2OCA3NjcuOTk5OTk0XFxcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVxcXCJ4TWlkWU1pZCBtZWV0XFxcIlxcbiAgICB2ZXJzaW9uPVxcXCIxLjBcXFwiPlxcbiAgICA8cGF0aCBmaWxsPVxcXCIjZTRkOGMxXFxcIiBjbGFzcz1cXFwib3V0ZXJcXFwiXFxuICAgICAgICBkPVxcXCJNIDc2OC4xMzI4MTIgMzc5LjUzNTE1NiBDIDc2OC4xMzI4MTIgMTY5LjA4OTg0NCA1OTcuNTIzNDM4IC0xLjQ5NjA5NCAzODcuMDUwNzgxIC0xLjQ5NjA5NCBDIDE3Ni42MDkzNzUgLTEuNDk2MDk0IDUuOTk2MDk0IDE2OS4wODk4NDQgNS45OTYwOTQgMzc5LjUzNTE1NiBDIDUuOTk2MDk0IDU4OS45NDkyMTkgMTc2LjYwOTM3NSA3NjAuNTM5MDYyIDM4Ny4wNTA3ODEgNzYwLjUzOTA2MiBDIDU5Ny41MjM0MzggNzYwLjUzOTA2MiA3NjguMTMyODEyIDU4OS45NDkyMTkgNzY4LjEzMjgxMiAzNzkuNTM1MTU2IFxcXCJcXG4gICAgICAgIGZpbGwtb3BhY2l0eT1cXFwiMVxcXCIgZmlsbC1ydWxlPVxcXCJub256ZXJvXFxcIiAvPlxcbiAgICA8cGF0aCBmaWxsPVxcXCIjNzc2ZDZkXFxcIiBjbGFzcz1cXFwiaW5uZXJcXFwiXFxuICAgICAgICBkPVxcXCJNIDUzOC45OTYwOTQgMjIzLjE1MjM0NCBMIDMwNi41MzUxNTYgMjI5Ljg1NTQ2OSBMIDUzOC45OTYwOTQgNDU1LjY5NTMxMiBaIE0gNTM4Ljk5NjA5NCAyMjMuMTUyMzQ0IFxcXCJcXG4gICAgICAgIGZpbGwtb3BhY2l0eT1cXFwiMVxcXCIgZmlsbC1ydWxlPVxcXCJub256ZXJvXFxcIiAvPlxcbiAgICA8cGF0aCBmaWxsPVxcXCIjNzc2ZDZkXFxcIiBjbGFzcz1cXFwiaW5uZXJcXFwiXFxuICAgICAgICBkPVxcXCJNIDIzNS4xMDU0NjkgNTM1Ljg5MDYyNSBMIDQ2Ny41OTc2NTYgNTI5LjE4NzUgTCAyMzUuMTA1NDY5IDMwMy4zNDM3NSBaIE0gMjM1LjEwNTQ2OSA1MzUuODkwNjI1IFxcXCJcXG4gICAgICAgIGZpbGwtb3BhY2l0eT1cXFwiMVxcXCIgZmlsbC1ydWxlPVxcXCJub256ZXJvXFxcIiAvPlxcbjwvc3ZnPlwiOyIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB3aWR0aD1cXFwiNTAwXFxcIiB6b29tQW5kUGFuPVxcXCJtYWduaWZ5XFxcIiB2aWV3Qm94PVxcXCIwIDAgMzc1IDM3NC45OTk5OTFcXFwiIGhlaWdodD1cXFwiNTAwXFxcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVxcXCJ4TWlkWU1pZCBtZWV0XFxcIiB2ZXJzaW9uPVxcXCIxLjBcXFwiPjxwYXRoIGZpbGw9XFxcIiM3NzZkNmRcXFwiIGQ9XFxcIk0gMjM5LjcyMjY1NiAxMjYuNDQxNDA2IEwgMjM5LjcyMjY1NiAxMjIuMzAwNzgxIEMgMjM5LjcyMjY1NiA5My41MDc4MTIgMjE2LjI5Njg3NSA3MC4wNzgxMjUgMTg3LjUgNzAuMDc4MTI1IEMgMTU4LjcwMzEyNSA3MC4wNzgxMjUgMTM1LjI3NzM0NCA5My41MDc4MTIgMTM1LjI3NzM0NCAxMjIuMzAwNzgxIEwgMTM1LjI3NzM0NCAxODcuOTUzMTI1IEMgMTM1LjI3NzM0NCAxOTkuOTg4MjgxIDEzOS40MTAxNTYgMjExLjA1MDc4MSAxNDYuMjczNDM4IDIxOS44OTA2MjUgWiBNIDIzOS43MjI2NTYgMTI2LjQ0MTQwNiBcXFwiIGZpbGwtb3BhY2l0eT1cXFwiMVxcXCIgZmlsbC1ydWxlPVxcXCJub256ZXJvXFxcIi8+PHBhdGggZmlsbD1cXFwiIzc3NmQ2ZFxcXCIgZD1cXFwiTSAxNTUuMDQ2ODc1IDIyOC43OTI5NjkgQyAxNjMuOTY0ODQ0IDIzNS44OTg0MzggMTc1LjIzNDM3NSAyNDAuMTc1NzgxIDE4Ny41IDI0MC4xNzU3ODEgQyAyMTYuMjk2ODc1IDI0MC4xNzU3ODEgMjM5LjcyMjY1NiAyMTYuNzUgMjM5LjcyMjY1NiAxODcuOTUzMTI1IEwgMjM5LjcyMjY1NiAxNDQuMTEzMjgxIFogTSAxNTUuMDQ2ODc1IDIyOC43OTI5NjkgXFxcIiBmaWxsLW9wYWNpdHk9XFxcIjFcXFwiIGZpbGwtcnVsZT1cXFwibm9uemVyb1xcXCIvPjxwYXRoIGZpbGw9XFxcIiM3NzZkNmRcXFwiIGQ9XFxcIk0gMTg3LjUgMCBDIDgzLjk0NTMxMiAwIDAgODMuOTQ1MzEyIDAgMTg3LjUgQyAwIDI5MS4wNTQ2ODggODMuOTQ1MzEyIDM3NSAxODcuNSAzNzUgQyAyOTEuMDU0Njg4IDM3NSAzNzUgMjkxLjA1NDY4OCAzNzUgMTg3LjUgQyAzNzUgODMuOTQ1MzEyIDI5MS4wNTQ2ODggMCAxODcuNSAwIFogTSAyODcuNDg0Mzc1IDk2LjM1NTQ2OSBMIDI1NC42NDA2MjUgMTI5LjE5NTMxMiBMIDI1NC42NDA2MjUgMTg3Ljk1MzEyNSBDIDI1NC42NDA2MjUgMjI0Ljk3NjU2MiAyMjQuNTIzNDM4IDI1NS4wOTc2NTYgMTg3LjUgMjU1LjA5NzY1NiBDIDE3MS4xMTcxODggMjU1LjA5NzY1NiAxNTYuMTA1NDY5IDI0OS4xODM1OTQgMTQ0LjQzNzUgMjM5LjQwMjM0NCBMIDEzOC4xMDkzNzUgMjQ1LjczMDQ2OSBDIDE1MS40MTc5NjkgMjU3LjEyMTA5NCAxNjguNjUyMzQ0IDI2NC4wNDY4NzUgMTg3LjUgMjY0LjA0Njg3NSBDIDIyOS40NTcwMzEgMjY0LjA0Njg3NSAyNjMuNTkzNzUgMjI5LjkxNDA2MiAyNjMuNTkzNzUgMTg3Ljk1MzEyNSBDIDI2My41OTM3NSAxODMuODMyMDMxIDI2Ni45MzM1OTQgMTgwLjQ5NjA5NCAyNzEuMDU0Njg4IDE4MC40OTYwOTQgQyAyNzUuMTc1NzgxIDE4MC40OTYwOTQgMjc4LjUxNTYyNSAxODMuODM1OTM4IDI3OC41MTU2MjUgMTg3Ljk1MzEyNSBDIDI3OC41MTU2MjUgMjM1LjYyNSAyNDEuNjY3OTY5IDI3NC44MjgxMjUgMTk0Ljk2MDkzOCAyNzguNjQwNjI1IEwgMTk0Ljk2MDkzOCAzMDQuOTIxODc1IEwgMjIwLjEyMTA5NCAzMDQuOTIxODc1IEMgMjI0LjI0MjE4OCAzMDQuOTIxODc1IDIyNy41ODIwMzEgMzA4LjI2MTcxOSAyMjcuNTgyMDMxIDMxMi4zODI4MTIgQyAyMjcuNTgyMDMxIDMxNi41IDIyNC4yNDIxODggMzE5LjgzOTg0NCAyMjAuMTIxMDk0IDMxOS44Mzk4NDQgTCAxNTQuODc1IDMxOS44Mzk4NDQgQyAxNTAuNzU3ODEyIDMxOS44Mzk4NDQgMTQ3LjQxNzk2OSAzMTYuNSAxNDcuNDE3OTY5IDMxMi4zODI4MTIgQyAxNDcuNDE3OTY5IDMwOC4yNjE3MTkgMTUwLjc1NzgxMiAzMDQuOTIxODc1IDE1NC44NzUgMzA0LjkyMTg3NSBMIDE4MC4wMzkwNjIgMzA0LjkyMTg3NSBMIDE4MC4wMzkwNjIgMjc4LjYzNjcxOSBDIDE2MC4wMDc4MTIgMjc3LjAwMzkwNiAxNDEuODE2NDA2IDI2OC44MjQyMTkgMTI3LjU0Mjk2OSAyNTYuMjk2ODc1IEwgOTYuMzUxNTYyIDI4Ny40ODQzNzUgQyA5NS4xMzI4MTIgMjg4LjcwMzEyNSA5My41MzEyNSAyODkuMzE2NDA2IDkxLjkzMzU5NCAyODkuMzE2NDA2IEMgOTAuMzM1OTM4IDI4OS4zMTY0MDYgODguNzM0Mzc1IDI4OC43MDMxMjUgODcuNTE1NjI1IDI4Ny40ODQzNzUgQyA4NS4wNzQyMTkgMjg1LjA0Mjk2OSA4NS4wNzQyMTkgMjgxLjA4NTkzOCA4Ny41MTU2MjUgMjc4LjY0NDUzMSBMIDExOC43NjE3MTkgMjQ3LjM5ODQzOCBDIDEwNC45Mjk2ODggMjMxLjQzNzUgOTYuNDg0Mzc1IDIxMC42ODc1IDk2LjQ4NDM3NSAxODcuOTUzMTI1IEMgOTYuNDg0Mzc1IDE4My44MzIwMzEgOTkuODI0MjE5IDE4MC40OTYwOTQgMTAzLjk0MTQwNiAxODAuNDk2MDk0IEMgMTA4LjA2MjUgMTgwLjQ5NjA5NCAxMTEuNDAyMzQ0IDE4My44MzU5MzggMTExLjQwMjM0NCAxODcuOTUzMTI1IEMgMTExLjQwMjM0NCAyMDYuNTc0MjE5IDExOC4xNDg0MzggMjIzLjYyODkwNiAxMjkuMjkyOTY5IDIzNi44NjcxODggTCAxMzUuNjI4OTA2IDIzMC41MzEyNSBDIDEyNi4wODk4NDQgMjE4LjkzNzUgMTIwLjM1NTQ2OSAyMDQuMTA1NDY5IDEyMC4zNTU0NjkgMTg3Ljk1MzEyNSBMIDEyMC4zNTU0NjkgMTIyLjMwMDc4MSBDIDEyMC4zNTU0NjkgODUuMjgxMjUgMTUwLjQ3NjU2MiA1NS4xNjAxNTYgMTg3LjQ5NjA5NCA1NS4xNjAxNTYgQyAyMjEuMTI4OTA2IDU1LjE2MDE1NiAyNDguOTgwNDY5IDgwLjAzOTA2MiAyNTMuODE2NDA2IDExMi4zNDM3NSBMIDI3OC42NDA2MjUgODcuNTE1NjI1IEMgMjgxLjA4MjAzMSA4NS4wNzgxMjUgMjg1LjAzOTA2MiA4NS4wNzgxMjUgMjg3LjQ4MDQ2OSA4Ny41MTU2MjUgQyAyODkuOTI1NzgxIDg5Ljk1NzAzMSAyODkuOTI1NzgxIDkzLjkxNDA2MiAyODcuNDg0Mzc1IDk2LjM1NTQ2OSBaIE0gMjg3LjQ4NDM3NSA5Ni4zNTU0NjkgXFxcIiBmaWxsLW9wYWNpdHk9XFxcIjFcXFwiIGZpbGwtcnVsZT1cXFwibm9uemVyb1xcXCIvPjwvc3ZnPlwiOyIsImV4cG9ydCBkZWZhdWx0IFwiPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiPz5cXG48c3ZnIGlkPVxcXCJMYXllcl8xXFxcIiBkYXRhLW5hbWU9XFxcIkxheWVyIDFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmlld0JveD1cXFwiMCAwIDMwNyA2NDBcXFwiPlxcbiAgPGRlZnM+XFxuICAgIDxzdHlsZT5cXG4gICAgICAuaW5uZXJtb3N0LCAuc2Vjb25kLCAudGhpcmQsIC5mb3VydGgsIC5maWZ0aCwgLm91dGVybW9zdCB7XFxuICAgICAgICBzdHJva2Utd2lkdGg6IDBweDtcXG4gICAgICB9XFxuICAgICAgXFxuICAgICAgLm91dGVybW9zdCB7XFxuICAgICAgICBmaWxsOiAjZTRmMmQxO1xcbiAgICAgIH1cXG5cXG4gICAgICAuc2Vjb25kIHtcXG4gICAgICAgIGZpbGw6ICNjY2U4YjU7XFxuICAgICAgfVxcblxcbiAgICAgIC50aGlyZCB7XFxuICAgICAgICBmaWxsOiAjYjNkYjk1O1xcbiAgICAgIH1cXG5cXG4gICAgICAuZm91cnRoIHtcXG4gICAgICAgIGZpbGw6ICM5YmQwNzg7XFxuICAgICAgfVxcblxcbiAgICAgIC5maWZ0aCB7XFxuICAgICAgICBmaWxsOiAjODNjNTVjO1xcbiAgICAgIH1cXG5cXG4gICAgICAuaW5uZXJtb3N0IHtcXG4gICAgICAgIGZpbGw6ICM0MjhhMmY7XFxuICAgICAgfVxcbiAgICA8L3N0eWxlPlxcbiAgPC9kZWZzPlxcbiAgPHBhdGggY2xhc3M9XFxcIm91dGVybW9zdFxcXCIgZD1cXFwibTMwNi45LDMyMGMwLDEwNS4zLS4wMiwyMTAuNi4xLDMxNS45MSwwLDMuNDItLjY3LDQuMS00LjA5LDQuMDktOTkuNi0uMTItMTk5LjIxLS4xMi0yOTguODEsMEMuNjcsNjQwLDAsNjM5LjMzLDAsNjM1LjkxLjExLDQyNS4zLjExLDIxNC43LDAsNC4wOSwwLC42Ny42NywwLDQuMDksMCwxMDMuNy4xMiwyMDMuMy4xMiwzMDIuOTEsMGMzLjQyLDAsNC4xLjY3LDQuMDksNC4wOS0uMTIsMTA1LjMtLjEsMjEwLjYtLjEsMzE1LjkxWlxcXCIvPlxcbiAgPHBhdGggY2xhc3M9XFxcInNlY29uZFxcXCIgZD1cXFwibTI3NS45MiwzMjNjMCw4Ny42MywwLDE3NS4yNywwLDI2Mi45LDAsNy4yNC0uNTUsNy45My03Ljg2LDcuOTgtMTQuNjYuMDktMjkuMzEuMDMtNDMuOTcuMDMtNjAuOTYsMC0xMjEuOTIsMC0xODIuODgsMHEtNy4xMywwLTcuMTQtNy4yNGMwLTE3Ni4xLDAtMzUyLjIxLDAtNTI4LjMxcTAtNy4yNiw3LjEyLTcuMjZjNzUuNzgsMCwxNTEuNTYsMCwyMjcuMzUsMHE3LjM4LDAsNy4zOCw3LjVjMCw4OC4xMywwLDE3Ni4yNywwLDI2NC40WlxcXCIvPlxcbiAgPHBhdGggY2xhc3M9XFxcInRoaXJkXFxcIiBkPVxcXCJtNjguMDYsMzIyLjI0YzAtNjkuNDcsMC0xMzguOTQsMC0yMDguNDEsMC04Ljk5LDEuMzMtMTAuMTMsMTAuNDktOS4xMiwxLjk4LjIyLDMuOTguMzIsNS45Ny4zMiw0Ni4xMy4wMiw5Mi4yNi4wMiwxMzguMzksMCwzLjQ4LDAsNi45Mi0uMjMsMTAuNDEtLjY3LDUuNS0uNyw4Ljc0LjQ2LDguNzMsNy4yNS0uMTgsMTM4Ljk0LS4xMywyNzcuODgtLjEzLDQxNi44MSwwLC4zMywwLC42NywwLDFxLS4xNCwxMC41MS0xMC4zOSwxMC41MWMtNTIuMTMsMC0xMDQuMjUsMC0xNTYuMzgsMHEtNy4wOSwwLTcuMDktNy4yOGMwLTcwLjE0LDAtMTQwLjI3LDAtMjEwLjQxWlxcXCIvPlxcbiAgPHBhdGggY2xhc3M9XFxcImZvdXJ0aFxcXCIgZD1cXFwibTEwMy4wMiwzMjIuNWMwLTUyLjQ2LDAtMTA0LjkxLDAtMTU3LjM3LDAtNi42OC4zNi03LjA2LDcuMDctNy4wNiwzMC4zLS4wMSw2MC42LjA3LDkwLjktLjA5LDQuNTQtLjAyLDYuMDgsMS4zMyw2LjA3LDUuOTgtLjEsMTA1LjU4LS4xLDIxMS4xNiwwLDMxNi43NCwwLDQuMTgtMS4yNyw1LjM3LTUuMzgsNS4zNS0yOS4zLS4xNS01OC42LS4wOC04Ny45LS4wOHEtMTAuNzYsMC0xMC43Ni0xMS4wOWMwLTUwLjc5LDAtMTAxLjU4LDAtMTUyLjM3WlxcXCIvPlxcbiAgPHBhdGggY2xhc3M9XFxcImZpZnRoXFxcIiBkPVxcXCJtMTczLDMyMi4yYzAsMzUuMjksMCw3MC41OCwwLDEwNS44OHEwLDYuODktNi45OSw2LjljLTguMTUsMC0xNi4zMS0uMTMtMjQuNDYuMDYtMy40Ny4wOC00LjY4LTEuMDktNC42MS00LjU5LjE4LTkuNjUuMDYtMTkuMzEuMDYtMjguOTYsMC01OC4yNi0uMDEtMTE2LjUzLjAyLTE3NC43OSwwLTQuNzYtMS4xMi05LjQ2LS4xNC0xNC4zLjUxLTIuNTQsMS4zOS0zLjM4LDMuOC0zLjM2LDguODIuMDYsMTcuNjQuMTQsMjYuNDYtLjAyLDQuNTktLjA5LDUuOTUsMS44NSw1Ljk0LDYuMzMtLjE0LDM1LjYyLS4wOCw3MS4yNS0uMDgsMTA2Ljg3WlxcXCIvPlxcbiAgPHBhdGggY2xhc3M9XFxcImlubmVybW9zdFxcXCIgZD1cXFwibTE1MS4wNCwzMjIuMDFjMC05Ljk5LjA3LTE5Ljk3LS4wNS0yOS45Ni0uMDQtMi45My44My00LjE4LDMuOTUtNC4xOCwzLjA2LDAsNC4wMywxLjEyLDQuMDIsNC4xMS0uMDksMTkuOTctLjA4LDM5Ljk0LjAxLDU5LjkxLjAxLDIuOTYtLjg0LDQuMTYtMy45Niw0LjE0LTMuMDMtLjAxLTQuMDgtMS4wNC00LjAzLTQuMDguMTQtOS45OC4wNS0xOS45Ny4wNS0yOS45NlpcXFwiLz5cXG48L3N2Zz5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2ZXJzaW9uPVxcXCIxLjBcXFwiIHZpZXdCb3g9XFxcIjAgMCA1Ni4yNSAzMFxcXCIgY2xhc3M9XFxcIndhdmVmb3JtXFxcIj5cXG4gICAgPGRlZnM+XFxuICAgICAgICA8Y2xpcFBhdGggaWQ9XFxcImFcXFwiPlxcbiAgICAgICAgICAgIDxwYXRoIGQ9XFxcIk0uNTQgMTJIM3Y1SC41NFptMCAwXFxcIi8+XFxuICAgICAgICA8L2NsaXBQYXRoPlxcbiAgICAgICAgPGNsaXBQYXRoIGlkPVxcXCJiXFxcIj5cXG4gICAgICAgICAgICA8cGF0aCBkPVxcXCJNMjUgMi4yaDJ2MjQuNjhoLTJabTAgMFxcXCIvPlxcbiAgICAgICAgPC9jbGlwUGF0aD5cXG4gICAgICAgIDxjbGlwUGF0aCBpZD1cXFwiY1xcXCI+XFxuICAgICAgICAgICAgPHBhdGggZD1cXFwiTTUzIDEyaDEuOTh2NUg1M1ptMCAwXFxcIi8+XFxuICAgICAgICA8L2NsaXBQYXRoPlxcbiAgICA8L2RlZnM+XFxuICAgIDxnIGNsaXAtcGF0aD1cXFwidXJsKCNhKVxcXCI+XFxuICAgICAgICA8cGF0aCBkPVxcXCJNMS40OCAxMi43MWMtLjUgMC0uOS40LS45Ljl2MS44NWEuOS45IDAgMCAwIDEuOCAwdi0xLjg0YzAtLjUtLjQtLjktLjktLjlabTAgMFxcXCIvPlxcbiAgICA8L2c+XFxuICAgIDxwYXRoIGQ9XFxcIk00Ljk4IDYuNjNjLS41IDAtLjkuNC0uOS45djE0LjAxYS45LjkgMCAwIDAgMS44MSAwdi0xNGMwLS41LS40LS45Mi0uOS0uOTJabTMuNTEgMy4xYS45LjkgMCAwIDAtLjkuOTF2Ny43OWEuOS45IDAgMCAwIDEuOCAwdi03Ljc5YzAtLjUtLjQtLjktLjktLjlaTTEyIDMuODNhLjkuOSAwIDAgMC0uOTEuOXYxOS42YS45LjkgMCAwIDAgMS44IDBWNC43NGMwLS41LS40LS45LS45LS45Wm0zLjUgOC4yOWEuOS45IDAgMCAwLS45MS45djMuMDNhLjkuOSAwIDAgMCAxLjgxIDB2LTMuMDNjMC0uNS0uNC0uOS0uOS0uOVpNMTkgNi44Yy0uNSAwLS45LjQtLjkuOXYxMy42OGEuOS45IDAgMCAwIDEuOCAwVjcuN2MwLS41LS40LS45LS45LS45Wm0zLjU4LTIuOTdoLS4wMWMtLjUgMC0uOS40LS45LjlsLS4xMyAxOS42YzAgLjUuNC45LjkuOTEuNSAwIC45LS40LjktLjlsLjE0LTE5LjZhLjkuOSAwIDAgMC0uOS0uOVptMCAwXFxcIi8+XFxuICAgIDxnIGNsaXAtcGF0aD1cXFwidXJsKCNiKVxcXCI+XFxuICAgICAgICA8cGF0aCBkPVxcXCJNMjYgMi4yYy0uNSAwLS45LjQtLjkuOXYyMi44NmEuOS45IDAgMSAwIDEuODEgMFYzLjExYS45LjkgMCAwIDAtLjktLjkxWm0wIDBcXFwiLz5cXG4gICAgPC9nPlxcbiAgICA8cGF0aCBkPVxcXCJNMjkuNTIgNy43MWEuOS45IDAgMCAwLS45MS45djExLjg1YS45LjkgMCAwIDAgMS44MSAwVjguNjJjMC0uNS0uNC0uOS0uOS0uOVptMy41IDIuOTNhLjkuOSAwIDAgMC0uOS45MXY1Ljk3YS45LjkgMCAwIDAgMS44IDB2LTUuOTdjMC0uNS0uNC0uOS0uOS0uOVptMy41LTUuNzhjLS41IDAtLjkuNC0uOS45djE3LjU1YS45LjkgMCAwIDAgMS44MSAwVjUuNzZjMC0uNS0uNC0uOS0uOS0uOVptMy41MSAzLjM0Yy0uNSAwLS45LjQtLjkuOXYxMC44N2EuOS45IDAgMCAwIDEuOCAwVjkuMWEuOS45IDAgMCAwLS45LS45MVptMy41IDMuMDhjLS41IDAtLjkuNC0uOS45MXY0LjdhLjkuOSAwIDEgMCAxLjggMHYtNC43YS45LjkgMCAwIDAtLjktLjlabTMuNTEtNy40NWEuOS45IDAgMCAwLS45MS45djE5LjZhLjkuOSAwIDAgMCAxLjgxIDBWNC43NGMwLS41LS40LS45LS45LS45Wm0zLjUgNS41N2EuOS45IDAgMCAwLS45LjkxdjguNDVhLjkuOSAwIDAgMCAxLjggMHYtOC40NWMwLS41LS40LS45LS45LS45Wm0wIDBcXFwiLz5cXG4gICAgPGcgY2xpcC1wYXRoPVxcXCJ1cmwoI2MpXFxcIj5cXG4gICAgICAgIDxwYXRoIGQ9XFxcIk01NC4wNCAxMi45NmEuOS45IDAgMCAwLS45LjkxdjEuMzNhLjkuOSAwIDEgMCAxLjggMHYtMS4zMmEuOS45IDAgMCAwLS45LS45MlptMCAwXFxcIi8+XFxuICAgIDwvZz5cXG48L3N2Zz5cIjsiLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vcmVjdGFuZ2xlcy5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3JlY3RhbmdsZXMuY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLnVzZVsyXSEuL2NvbW1vbi5zY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5cbiAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG4gICAgXG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbM10udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS51c2VbMl0hLi9jb21tb24uc2Nzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiIsIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbM10udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS51c2VbMl0hLi9kZXNrdG9wLnNjc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLnVzZVsyXSEuL2Rlc2t0b3Auc2Nzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiIsIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbM10udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS51c2VbMl0hLi9tb2JpbGUuc2Nzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xuXG4gICAgICBvcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xuICAgIFxub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbM10udXNlWzJdIS4vbW9iaWxlLnNjc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRPTS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdLFxuICAgICAgc3VwcG9ydHM6IGl0ZW1bNF0sXG4gICAgICBsYXllcjogaXRlbVs1XVxuICAgIH07XG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcbiAgdmFyIHVwZGF0ZXIgPSBmdW5jdGlvbiB1cGRhdGVyKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXAgJiYgbmV3T2JqLnN1cHBvcnRzID09PSBvYmouc3VwcG9ydHMgJiYgbmV3T2JqLmxheWVyID09PSBvYmoubGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdXBkYXRlcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcbiAgICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZW1vID0ge307XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gZ2V0VGFyZ2V0KHRhcmdldCkge1xuICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcblxuICAgIC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgfVxuICByZXR1cm4gbWVtb1t0YXJnZXRdO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydEJ5U2VsZWN0b3IoaW5zZXJ0LCBzdHlsZSkge1xuICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGluc2VydCk7XG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgfVxuICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBvcHRpb25zLnNldEF0dHJpYnV0ZXMoZWxlbWVudCwgb3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgb3B0aW9ucy5pbnNlcnQoZWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydFN0eWxlRWxlbWVudDsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGVFbGVtZW50KSB7XG4gIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IFwiXCI7XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChvYmouc3VwcG9ydHMsIFwiKSB7XCIpO1xuICB9XG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIkBsYXllclwiLmNvbmNhdChvYmoubGF5ZXIubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChvYmoubGF5ZXIpIDogXCJcIiwgXCIge1wiKTtcbiAgfVxuICBjc3MgKz0gb2JqLmNzcztcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfVxuXG4gIC8vIEZvciBvbGQgSUVcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlRWxlbWVudC5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB7XG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHt9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgIH07XG4gIH1cbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGRvbUFQSTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCkge1xuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlVGFnVHJhbnNmb3JtOyIsImltcG9ydCB7IGVuY29kZVdBViB9IGZyb20gXCIuL1dhdkVuY29kZXJcIjtcblxuLyoqXG4gKiBDb252ZXJ0IGEgRmxvYXQzMkFycmF5IG9mIGF1ZGlvIHNhbXBsZXMgdG8gYSBXQVYgYXJyYXkgYnVmZmVyXG4gKiBAcGFyYW0gYXVkaW9EYXRhIC0gVGhlIGF1ZGlvIHNhbXBsZXNcbiAqIEByZXR1cm5zIC0gVGhlIGF1ZGlvIGluIFdBViBmb3JtYXQgYXMgYW4gQXJyYXlCdWZmZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb1dhdkJ1ZmZlcihhdWRpb0RhdGE6IEZsb2F0MzJBcnJheSk6IEFycmF5QnVmZmVyIHtcbiAgY29uc3QgYXJyYXlCdWZmZXIgPSBlbmNvZGVXQVYoYXVkaW9EYXRhKTtcbiAgcmV0dXJuIGFycmF5QnVmZmVyO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBGbG9hdDMyQXJyYXkgb2YgYXVkaW8gc2FtcGxlcyB0byBhIFdBViBCbG9iXG4gKiBAcGFyYW0gYXVkaW9EYXRhIC0gVGhlIGF1ZGlvIHNhbXBsZXNcbiAqIEByZXR1cm5zIC0gVGhlIGF1ZGlvIGluIFdBViBmb3JtYXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb1dhdkJsb2IoYXVkaW9EYXRhOiBGbG9hdDMyQXJyYXkpOiBCbG9iIHtcbiAgY29uc3QgYXJyYXlCdWZmZXIgPSBjb252ZXJ0VG9XYXZCdWZmZXIoYXVkaW9EYXRhKTtcbiAgcmV0dXJuIG5ldyBCbG9iKFthcnJheUJ1ZmZlcl0sIHsgdHlwZTogXCJhdWRpby93YXZcIiB9KTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBhcHBlbmRDaGlsZChcbiAgcGFyZW50OiBFbGVtZW50LFxuICBjaGlsZDogTm9kZSxcbiAgcG9zaXRpb246IG51bWJlciA9IDBcbik6IHZvaWQge1xuICAvLyBDaGVjayBpZiBhIGNvbnRhaW5lciBpcyBwcm92aWRlZC5cbiAgaWYgKHBhcmVudCkge1xuICAgIC8vIElmIHBvc2l0aW9uIGlzIDAsIHNpbXBseSBhcHBlbmQgdGhlIGJ1dHRvbiBhcyB0aGUgbGFzdCBjaGlsZC5cbiAgICBpZiAocG9zaXRpb24gPT09IDApIHtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgaW5kZXggb2YgdGhlIHJlZmVyZW5jZSBub2RlIGZvciBpbnNlcnRCZWZvcmUoKS5cbiAgICAgIGNvbnN0IHJlZmVyZW5jZUluZGV4ID0gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCArIHBvc2l0aW9uO1xuICAgICAgY29uc3QgcmVmZXJlbmNlTm9kZSA9IHBhcmVudC5jaGlsZHJlbltyZWZlcmVuY2VJbmRleF07XG5cbiAgICAgIC8vIElmIGEgcmVmZXJlbmNlIG5vZGUgZXhpc3RzLCBpbnNlcnQgdGhlIGJ1dHRvbiBiZWZvcmUgaXQuXG4gICAgICBpZiAocmVmZXJlbmNlTm9kZSkge1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCByZWZlcmVuY2VOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIG5vdCwgYXBwZW5kIHRoZSBidXR0b24gYXMgdGhlIGxhc3QgY2hpbGQuXG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIG5vIGNvbnRhaW5lciBpcyBwcm92aWRlZCwgYXBwZW5kIHRoZSBidXR0b24gdG8gdGhlIGJvZHkuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IHNldFByb21wdFRleHQgfSBmcm9tIFwiLi9UcmFuc2NyaXB0aW9uTW9kdWxlXCI7XG5cbmludGVyZmFjZSBSZXN0b3JlUG9pbnQge1xuICBwcm9tcHQ6IHN0cmluZztcbiAgYXVkaW9JbnB1dEVuYWJsZWQ6IGJvb2xlYW47XG4gIGF1ZGlvT3V0cHV0RW5hYmxlZDogYm9vbGVhbjtcbiAgY3JlYXRpb25UaW1lOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBSZXN0b3JlUG9pbnRBdXRvRGF0ZSB7XG4gIHByb21wdDogc3RyaW5nO1xuICBhdWRpb0lucHV0RW5hYmxlZDogYm9vbGVhbjtcbiAgYXVkaW9PdXRwdXRFbmFibGVkOiBib29sZWFuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWJtaXRFcnJvckhhbmRsZXIge1xuICBwcml2YXRlIHJlc3RvcmVQb2ludEtleTogc3RyaW5nO1xuICBwcml2YXRlIGF1ZGlvT3V0cHV0U3RhdHVzOiBib29sZWFuID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gSW5pdGlhbGlzZSBwcm9wZXJ0aWVzIGlmIG5lZWRlZFxuICAgIHRoaXMucmVzdG9yZVBvaW50S2V5ID0gXCJyZXN0b3JlUG9pbnRcIjtcbiAgfVxuXG4gIGluaXRBdWRpb091dHB1dExpc3RlbmVyKCk6IHZvaWQge1xuICAgIGNvbnN0IGF1ZGlvT3V0cHV0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICBcInNheXBpLWF1ZGlvLW91dHB1dC1idXR0b25cIlxuICAgICk7XG4gICAgaWYgKGF1ZGlvT3V0cHV0QnV0dG9uKSB7XG4gICAgICBhdWRpb091dHB1dEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgIHRoaXMuaGFuZGxlQXVkaW9PdXRwdXRDbGljay5iaW5kKHRoaXMpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEV2ZW50IGhhbmRsZXJcbiAgcHJpdmF0ZSBoYW5kbGVBdWRpb091dHB1dENsaWNrKCk6IHZvaWQge1xuICAgIHRoaXMuYXVkaW9PdXRwdXRTdGF0dXMgPSAhdGhpcy5hdWRpb091dHB1dFN0YXR1czsgLy8gVG9nZ2xlIHRoZSBzdGF0ZVxuICB9XG5cbiAgLy8gMS4gRGV0ZWN0IHdoZW4gYSBzdWJtaXQgZXJyb3Igb2NjdXJzXG4gIGRldGVjdFN1Ym1pdEVycm9yKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHN1Ym1pdEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgXCJzYXlwaS1zdWJtaXRCdXR0b25cIlxuICAgICkgYXMgSFRNTEJ1dHRvbkVsZW1lbnQgfCBudWxsO1xuICAgIGNvbnN0IHRleHRhcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICBcInNheXBpLXByb21wdFwiXG4gICAgKSBhcyBIVE1MVGV4dEFyZWFFbGVtZW50IHwgbnVsbDtcbiAgICBpZiAoc3VibWl0QnV0dG9uICYmIHRleHRhcmVhKSB7XG4gICAgICBpZiAoc3VibWl0QnV0dG9uLmRpc2FibGVkICYmIHRleHRhcmVhLnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIDIuIENyZWF0ZSBhIFwicmVzdG9yZSBwb2ludFwiIGNhcHR1cmluZyBhcHBsaWNhdGlvbiBzdGF0ZVxuICBjcmVhdGVSZXN0b3JlUG9pbnQoe1xuICAgIHByb21wdDogbWVzc2FnZSxcbiAgICBhdWRpb0lucHV0RW5hYmxlZDogYXVkaW9JbnB1dFN0YXR1cyxcbiAgICBhdWRpb091dHB1dEVuYWJsZWQ6IGF1ZGlvT3V0cHV0U3RhdHVzLFxuICB9OiBSZXN0b3JlUG9pbnRBdXRvRGF0ZSk6IHZvaWQge1xuICAgIGNvbnN0IHJlc3RvcmVQb2ludDogUmVzdG9yZVBvaW50ID0ge1xuICAgICAgcHJvbXB0OiBtZXNzYWdlLFxuICAgICAgYXVkaW9JbnB1dEVuYWJsZWQ6IGF1ZGlvSW5wdXRTdGF0dXMsXG4gICAgICBhdWRpb091dHB1dEVuYWJsZWQ6IGF1ZGlvT3V0cHV0U3RhdHVzLFxuICAgICAgY3JlYXRpb25UaW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfTtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnJlc3RvcmVQb2ludEtleSwgSlNPTi5zdHJpbmdpZnkocmVzdG9yZVBvaW50KSk7XG4gIH1cblxuICAvLyAzLiBQcm9ncmFtbWF0aWNhbGx5IHJlbG9hZCB0aGUgcGFnZVxuICByZWxvYWRQYWdlKCk6IHZvaWQge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfVxuXG4gIGhhbmRsZVN1Ym1pdEVycm9yKCk6IHZvaWQge1xuICAgIGNvbnN0IHRleHRhcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICBcInNheXBpLXByb21wdFwiXG4gICAgKSBhcyBIVE1MVGV4dEFyZWFFbGVtZW50IHwgbnVsbDtcbiAgICBjb25zdCBwcm9tcHQgPSB0ZXh0YXJlYSA/IHRleHRhcmVhLnZhbHVlIDogXCJcIjtcblxuICAgIGxldCBhdWRpb0lucHV0U3RhdHVzID0gdHJ1ZTtcbiAgICBjb25zdCBjYWxsQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzYXlwaS1jYWxsQnV0dG9uXCIpO1xuICAgIGlmIChjYWxsQnV0dG9uKSB7XG4gICAgICBhdWRpb0lucHV0U3RhdHVzID0gY2FsbEJ1dHRvbi5jbGFzc0xpc3QuY29udGFpbnMoXCJhY3RpdmVcIik7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coXCJDcmVhdGluZyByZXN0b3JlIHBvaW50XCIpO1xuICAgIHRoaXMuY3JlYXRlUmVzdG9yZVBvaW50KHtcbiAgICAgIHByb21wdDogcHJvbXB0LFxuICAgICAgYXVkaW9JbnB1dEVuYWJsZWQ6IGF1ZGlvSW5wdXRTdGF0dXMsXG4gICAgICBhdWRpb091dHB1dEVuYWJsZWQ6IHRoaXMuYXVkaW9PdXRwdXRTdGF0dXMsXG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coXCJSZWxvYWRpbmcgcGFnZVwiKTtcbiAgICB0aGlzLnJlbG9hZFBhZ2UoKTtcbiAgfVxuXG4gIC8vIDQuIE9uIGxvYWQsIGNoZWNrIGZvciBhIHJlc3RvcmUgcG9pbnRcbiAgY2hlY2tGb3JSZXN0b3JlUG9pbnQoKTogdm9pZCB7XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMucmVzdG9yZVBvaW50S2V5KTtcbiAgICBpZiAoc3RvcmVkRGF0YSkge1xuICAgICAgY29uc3QgcmVzdG9yZVBvaW50OiBSZXN0b3JlUG9pbnQgPSBKU09OLnBhcnNlKHN0b3JlZERhdGEpO1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgcmVzdG9yZVRpbWUgPSBuZXcgRGF0ZShyZXN0b3JlUG9pbnQuY3JlYXRpb25UaW1lKTtcblxuICAgICAgY29uc3QgdGltZURpZmZlcmVuY2UgPVxuICAgICAgICAoY3VycmVudFRpbWUuZ2V0VGltZSgpIC0gcmVzdG9yZVRpbWUuZ2V0VGltZSgpKSAvICgxMDAwICogNjApOyAvLyBpbiBtaW51dGVzXG5cbiAgICAgIGlmICh0aW1lRGlmZmVyZW5jZSA8PSA1KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUmVzdG9yaW5nIGFwcGxpY2F0aW9uIHN0YXRlXCIsIHJlc3RvcmVQb2ludCk7XG4gICAgICAgIHNldFByb21wdFRleHQocmVzdG9yZVBvaW50LnByb21wdCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVBdWRpb0lucHV0KHJlc3RvcmVQb2ludC5hdWRpb0lucHV0RW5hYmxlZCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVBdWRpb091dHB1dChyZXN0b3JlUG9pbnQuYXVkaW9PdXRwdXRFbmFibGVkKTtcbiAgICAgICAgLy8gRGVsZXRlIHRoZSBleGVjdXRlZCByZXN0b3JlIHBvaW50XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMucmVzdG9yZVBvaW50S2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhY3RpdmF0ZUF1ZGlvSW5wdXQoZW5hYmxlOiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKGVuYWJsZSkge1xuICAgICAgY29uc3QgY2FsbEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2F5cGktY2FsbEJ1dHRvblwiKTtcbiAgICAgIGlmIChjYWxsQnV0dG9uKSB7XG4gICAgICAgIGNhbGxCdXR0b24uY2xpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhY3RpdmF0ZUF1ZGlvT3V0cHV0KGVuYWJsZTogYm9vbGVhbik6IHZvaWQge1xuICAgIGlmIChlbmFibGUpIHtcbiAgICAgIGNvbnN0IGF1ZGlvT3V0cHV0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAgIFwic2F5cGktYXVkaW8tb3V0cHV0LWJ1dHRvblwiXG4gICAgICApO1xuICAgICAgaWYgKGF1ZGlvT3V0cHV0QnV0dG9uKSB7XG4gICAgICAgIGF1ZGlvT3V0cHV0QnV0dG9uLmNsaWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIFNpbmdsZXRvblxuZXhwb3J0IGNvbnN0IHN1Ym1pdEVycm9ySGFuZGxlciA9IG5ldyBTdWJtaXRFcnJvckhhbmRsZXIoKTtcbiIsImltcG9ydCB7IGNvbmZpZyB9IGZyb20gXCIuL0NvbmZpZ01vZHVsZS5qc1wiO1xuaW1wb3J0IFN0YXRlTWFjaGluZVNlcnZpY2UgZnJvbSBcIi4vU3RhdGVNYWNoaW5lU2VydmljZS5qc1wiO1xuaW1wb3J0IHsgaXNNb2JpbGVWaWV3IH0gZnJvbSBcIi4vVXNlckFnZW50TW9kdWxlLmpzXCI7XG5pbXBvcnQgRXZlbnRCdXMgZnJvbSBcIi4vRXZlbnRCdXMuanNcIjtcbmltcG9ydCBFdmVudE1vZHVsZSBmcm9tIFwiLi9FdmVudE1vZHVsZS5qc1wiO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIi4vTG9nZ2luZ01vZHVsZS5qc1wiO1xuXG4vLyBEZWZpbmUgdGhlIHNoYXBlIG9mIHRoZSByZXNwb25zZSBKU09OIG9iamVjdFxuaW50ZXJmYWNlIFRyYW5zY3JpcHRpb25SZXNwb25zZSB7XG4gIHRleHQ6IHN0cmluZztcbiAgc2VxdWVuY2VOdW1iZXI6IG51bWJlcjtcbiAgcEZpbmlzaGVkU3BlYWtpbmc/OiBudW1iZXI7XG4gIHRlbXBvPzogbnVtYmVyO1xufVxuXG5jb25zdCBrbm93bk5ldHdvcmtFcnJvck1lc3NhZ2VzID0gW1xuICBcIkZhaWxlZCB0byBmZXRjaFwiLCAvLyBDaHJvbWl1bS1iYXNlZCBicm93c2Vyc1xuICBcIkxvYWQgZmFpbGVkXCIsIC8vIFNhZmFyaVxuICBcIk5ldHdvcmtFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gZmV0Y2ggcmVzb3VyY2UuXCIsIC8vIEZpcmVmb3hcbiAgLy8gQWRkIG1vcmUga25vd24gZXJyb3IgbWVzc2FnZXMgaGVyZVxuXTtcblxuLy8gdGltZW91dCBmb3IgdHJhbnNjcmlwdGlvbiByZXF1ZXN0c1xuY29uc3QgVElNRU9VVF9NUyA9IDMwMDAwOyAvLyAzMCBzZWNvbmRzXG5cbi8vIHRyYWNrIHNlcXVlbmNlIG51bWJlcnMgZm9yIGluLWZsaWdodCB0cmFuc2NyaXB0aW9uIHJlcXVlc3RzXG5sZXQgc2VxdWVuY2VOdW0gPSAwO1xuY29uc3Qgc2VxdWVuY2VOdW1zUGVuZGluZ1RyYW5zY3JpcHRpb246IFNldDx7XG4gIHNlcTogbnVtYmVyO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbn0+ID0gbmV3IFNldCgpO1xuXG5mdW5jdGlvbiBjaGVja0ZvckV4cGlyZWRFbnRyaWVzKCkge1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICBzZXF1ZW5jZU51bXNQZW5kaW5nVHJhbnNjcmlwdGlvbi5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgIGlmIChub3cgLSBlbnRyeS50aW1lc3RhbXAgPiBUSU1FT1VUX01TKSB7XG4gICAgICBzZXF1ZW5jZU51bXNQZW5kaW5nVHJhbnNjcmlwdGlvbi5kZWxldGUoZW50cnkpO1xuICAgICAgbG9nZ2VyLmluZm8oYFRyYW5zY3JpcHRpb24gcmVxdWVzdCAke2VudHJ5LnNlcX0gdGltZWQgb3V0YCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNjcmlwdGlvblNlbnQoKTogdm9pZCB7XG4gIHNlcXVlbmNlTnVtKys7XG4gIHNlcXVlbmNlTnVtc1BlbmRpbmdUcmFuc2NyaXB0aW9uLmFkZCh7XG4gICAgc2VxOiBzZXF1ZW5jZU51bSxcbiAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFuc2NyaXB0aW9uUmVjZWl2ZWQoc2VxOiBudW1iZXIpOiB2b2lkIHtcbiAgLy8gZGVsZXRlIGVudHJ5IHdpdGggbWF0Y2hpbmcgc2VxdWVuY2UgbnVtYmVyXG4gIHNlcXVlbmNlTnVtc1BlbmRpbmdUcmFuc2NyaXB0aW9uLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgaWYgKGVudHJ5LnNlcSA9PT0gc2VxKSB7XG4gICAgICBzZXF1ZW5jZU51bXNQZW5kaW5nVHJhbnNjcmlwdGlvbi5kZWxldGUoZW50cnkpO1xuICAgICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgICBgVHJhbnNjcmlwdGlvbiByZXNwb25zZSAke3NlcX0gcmVjZWl2ZWQgYWZ0ZXIgJHtcbiAgICAgICAgICAoRGF0ZS5ub3coKSAtIGVudHJ5LnRpbWVzdGFtcCkgLyAxMDAwXG4gICAgICAgIH1zYFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUcmFuc2NyaXB0aW9uUGVuZGluZygpOiBib29sZWFuIHtcbiAgY2hlY2tGb3JFeHBpcmVkRW50cmllcygpO1xuICByZXR1cm4gc2VxdWVuY2VOdW1zUGVuZGluZ1RyYW5zY3JpcHRpb24uc2l6ZSA+IDA7XG59XG5cbi8vIGNhbGwgYWZ0ZXIgY29tcGxldGVkIHVzZXIgaW5wdXQgaXMgc3VibWl0dGVkXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJQZW5kaW5nVHJhbnNjcmlwdGlvbnMoKTogdm9pZCB7XG4gIHNlcXVlbmNlTnVtc1BlbmRpbmdUcmFuc2NyaXB0aW9uLmNsZWFyKCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGxvYWRBdWRpb1dpdGhSZXRyeShcbiAgYXVkaW9CbG9iOiBCbG9iLFxuICBhdWRpb0R1cmF0aW9uTWlsbGlzOiBudW1iZXIsXG4gIHByZWNlZGluZ1RyYW5zY3JpcHRzOiBSZWNvcmQ8bnVtYmVyLCBzdHJpbmc+ID0ge30sXG4gIG1heFJldHJpZXM6IG51bWJlciA9IDNcbik6IFByb21pc2U8dm9pZD4ge1xuICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gIGxldCBkZWxheSA9IDEwMDA7IC8vIGluaXRpYWwgZGVsYXkgb2YgMSBzZWNvbmRcblxuICBjb25zdCBzbGVlcCA9IChtczogbnVtYmVyKSA9PlxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG5cbiAgd2hpbGUgKHJldHJ5Q291bnQgPCBtYXhSZXRyaWVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRyYW5zY3JpcHRpb25TZW50KCk7XG4gICAgICBhd2FpdCB1cGxvYWRBdWRpbyhhdWRpb0Jsb2IsIGF1ZGlvRHVyYXRpb25NaWxsaXMsIHByZWNlZGluZ1RyYW5zY3JpcHRzKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gY2hlY2sgZm9yIHRpbWVvdXQgZXJyb3JzICgzMHMgb24gSGVyb2t1KVxuICAgICAgaWYgKFxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJlxuICAgICAgICBrbm93bk5ldHdvcmtFcnJvck1lc3NhZ2VzLmluY2x1ZGVzKGVycm9yLm1lc3NhZ2UpXG4gICAgICApIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgYEF0dGVtcHQgJHtyZXRyeUNvdW50ICsgMX0vJHttYXhSZXRyaWVzfSBmYWlsZWQuIFJldHJ5aW5nIGluICR7XG4gICAgICAgICAgICBkZWxheSAvIDEwMDBcbiAgICAgICAgICB9IHNlY29uZHMuLi5gXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IHNsZWVwKGRlbGF5KTtcblxuICAgICAgICAvLyBFeHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICAgIGRlbGF5ICo9IDI7XG5cbiAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgZXJyb3I6IFwiLCBlcnJvcik7XG4gICAgICAgIFN0YXRlTWFjaGluZVNlcnZpY2UuYWN0b3Iuc2VuZChcInNheXBpOnRyYW5zY3JpYmVGYWlsZWRcIiwge1xuICAgICAgICAgIGRldGFpbDogZXJyb3IsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc29sZS5lcnJvcihcIk1heCByZXRyaWVzIHJlYWNoZWQuIEdpdmluZyB1cC5cIik7XG4gIFN0YXRlTWFjaGluZVNlcnZpY2UuYWN0b3Iuc2VuZChcInNheXBpOnRyYW5zY3JpYmVGYWlsZWRcIiwge1xuICAgIGRldGFpbDogbmV3IEVycm9yKFwiTWF4IHJldHJpZXMgcmVhY2hlZFwiKSxcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEF1ZGlvKFxuICBhdWRpb0Jsb2I6IEJsb2IsXG4gIGF1ZGlvRHVyYXRpb25NaWxsaXM6IG51bWJlcixcbiAgcHJlY2VkaW5nVHJhbnNjcmlwdHM6IFJlY29yZDxudW1iZXIsIHN0cmluZz4gPSB7fVxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBPYmplY3QuZW50cmllcyhwcmVjZWRpbmdUcmFuc2NyaXB0cykubWFwKFxuICAgICAgKFtzZXEsIGNvbnRlbnRdKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICBzZXF1ZW5jZU51bWJlcjogTnVtYmVyKHNlcSksIC8vIENvbnZlcnQgdGhlIHN0cmluZyB0byBhIG51bWJlclxuICAgICAgICB9O1xuICAgICAgfVxuICAgICk7XG5cbiAgICBjb25zdCBmb3JtRGF0YSA9IGNvbnN0cnVjdFRyYW5zY3JpcHRpb25Gb3JtRGF0YShcbiAgICAgIGF1ZGlvQmxvYixcbiAgICAgIGF1ZGlvRHVyYXRpb25NaWxsaXMgLyAxMDAwLFxuICAgICAgbWVzc2FnZXNcbiAgICApO1xuICAgIGNvbnN0IGxhbmd1YWdlID0gbmF2aWdhdG9yLmxhbmd1YWdlO1xuXG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB7IHNpZ25hbCB9ID0gY29udHJvbGxlcjtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCBUSU1FT1VUX01TKTtcblxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGNvbnN0IHJlc3BvbnNlOiBSZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgYCR7Y29uZmlnLmFwaVNlcnZlclVybH0vdHJhbnNjcmliZT9sYW5ndWFnZT0ke2xhbmd1YWdlfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICBzaWduYWwsXG4gICAgICB9XG4gICAgKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZUpzb246IFRyYW5zY3JpcHRpb25SZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zdCBzZXEgPSByZXNwb25zZUpzb24uc2VxdWVuY2VOdW1iZXI7XG4gICAgaWYgKHNlcSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0cmFuc2NyaXB0aW9uUmVjZWl2ZWQoc2VxKTtcbiAgICB9XG4gICAgY29uc3QgZW5kVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGNvbnN0IHRyYW5zY3JpcHRpb25EdXJhdGlvbk1pbGxpcyA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgY29uc3QgdHJhbnNjcmlwdCA9IHJlc3BvbnNlSnNvbi50ZXh0O1xuICAgIGNvbnN0IHdjID0gdHJhbnNjcmlwdC5zcGxpdChcIiBcIikubGVuZ3RoO1xuICAgIGNvbnN0IHBheWxvYWQ6IFRyYW5zY3JpcHRpb25SZXNwb25zZSA9IHtcbiAgICAgIHRleHQ6IHRyYW5zY3JpcHQsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogc2VxLFxuICAgIH07XG4gICAgaWYgKHJlc3BvbnNlSnNvbi5oYXNPd25Qcm9wZXJ0eShcInBGaW5pc2hlZFNwZWFraW5nXCIpKSB7XG4gICAgICBwYXlsb2FkLnBGaW5pc2hlZFNwZWFraW5nID0gcmVzcG9uc2VKc29uLnBGaW5pc2hlZFNwZWFraW5nO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2VKc29uLmhhc093blByb3BlcnR5KFwidGVtcG9cIikpIHtcbiAgICAgIHBheWxvYWQudGVtcG8gPSByZXNwb25zZUpzb24udGVtcG87XG4gICAgfVxuXG4gICAgbG9nZ2VyLmluZm8oXG4gICAgICBgVHJhbnNjcmliZWQgJHtNYXRoLnJvdW5kKFxuICAgICAgICBhdWRpb0R1cmF0aW9uTWlsbGlzIC8gMTAwMFxuICAgICAgKX1zIG9mIGF1ZGlvIGludG8gJHt3Y30gd29yZHMgaW4gJHtNYXRoLnJvdW5kKFxuICAgICAgICB0cmFuc2NyaXB0aW9uRHVyYXRpb25NaWxsaXMgLyAxMDAwXG4gICAgICApfXNgXG4gICAgKTtcblxuICAgIGlmIChyZXNwb25zZUpzb24udGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgIFN0YXRlTWFjaGluZVNlcnZpY2UuYWN0b3Iuc2VuZChcInNheXBpOnRyYW5zY3JpYmVkRW1wdHlcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFN0YXRlTWFjaGluZVNlcnZpY2UuYWN0b3Iuc2VuZChcInNheXBpOnRyYW5zY3JpYmVkXCIsIHBheWxvYWQpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGZXRjaCBhYm9ydGVkIGR1ZSB0byB0aW1lb3V0XCIsIGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkOlwiLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJTb21ldGhpbmcgdGhyb3duIHRoYXQgaXMgbm90IGFuIEVycm9yIG9iamVjdDpcIiwgZXJyb3IpO1xuICAgIH1cblxuICAgIC8vIHJlLXRocm93IHRoZSBlcnJvciBpZiB5b3VyIGxvZ2ljIHJlcXVpcmVzIGl0XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0VHJhbnNjcmlwdGlvbkZvcm1EYXRhKFxuICBhdWRpb0Jsb2I6IEJsb2IsXG4gIGF1ZGlvRHVyYXRpb25TZWNvbmRzOiBudW1iZXIsXG4gIG1lc3NhZ2VzOiB7IHJvbGU6IHN0cmluZzsgY29udGVudDogc3RyaW5nOyBzZXF1ZW5jZU51bWJlcj86IG51bWJlciB9W11cbikge1xuICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICBsZXQgYXVkaW9GaWxlbmFtZSA9IFwiYXVkaW8ud2VibVwiO1xuXG4gIGlmIChhdWRpb0Jsb2IudHlwZSA9PT0gXCJhdWRpby9tcDRcIikge1xuICAgIGF1ZGlvRmlsZW5hbWUgPSBcImF1ZGlvLm1wNFwiO1xuICB9IGVsc2UgaWYgKGF1ZGlvQmxvYi50eXBlID09PSBcImF1ZGlvL3dhdlwiKSB7XG4gICAgYXVkaW9GaWxlbmFtZSA9IFwiYXVkaW8ud2F2XCI7XG4gIH1cblxuICBsb2dnZXIuaW5mbyhcbiAgICBgVHJhbnNjcmliaW5nIGF1ZGlvIEJsb2Igd2l0aCBNSU1FIHR5cGU6ICR7YXVkaW9CbG9iLnR5cGV9LCBzaXplOiAkeyhcbiAgICAgIGF1ZGlvQmxvYi5zaXplIC8gMTAyNFxuICAgICkudG9GaXhlZCgyKX1rYmBcbiAgKTtcblxuICAvLyBBZGQgdGhlIGF1ZGlvIGJsb2IgdG8gdGhlIEZvcm1EYXRhIG9iamVjdFxuICBmb3JtRGF0YS5hcHBlbmQoXCJhdWRpb1wiLCBhdWRpb0Jsb2IsIGF1ZGlvRmlsZW5hbWUpO1xuICBmb3JtRGF0YS5hcHBlbmQoXCJkdXJhdGlvblwiLCBhdWRpb0R1cmF0aW9uU2Vjb25kcy50b1N0cmluZygpKTtcbiAgZm9ybURhdGEuYXBwZW5kKFwic2VxdWVuY2VOdW1iZXJcIiwgc2VxdWVuY2VOdW0udG9TdHJpbmcoKSk7XG4gIGZvcm1EYXRhLmFwcGVuZChcIm1lc3NhZ2VzXCIsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2VzKSk7XG4gIHJldHVybiBmb3JtRGF0YTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFByb21wdFRleHQodHJhbnNjcmlwdDogc3RyaW5nKTogdm9pZCB7XG4gIGxvZ2dlci5pbmZvKGBNZXJnZWQgdHJhbnNjcmlwdDogJHt0cmFuc2NyaXB0fWApO1xuICBjb25zdCB0ZXh0YXJlYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgIFwic2F5cGktcHJvbXB0XCJcbiAgKSBhcyBIVE1MVGV4dEFyZWFFbGVtZW50O1xuICBpZiAoaXNNb2JpbGVWaWV3KCkpIHtcbiAgICAvLyBpZiB0cmFuc2NyaXB0IGlzID4gMTAwMCBjaGFyYWN0ZXJzLCB0cnVuY2F0ZSBpdCB0byA5OTkgY2hhcmFjdGVycyBwbHVzIGFuIGVsbGlwc2lzXG4gICAgaWYgKHRyYW5zY3JpcHQubGVuZ3RoID4gMTAwMCkge1xuICAgICAgdHJhbnNjcmlwdCA9IGAke3RyYW5zY3JpcHQuc3Vic3RyaW5nKDAsIDk5OSl94oCmYDtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFRyYW5zY3JpcHQgd2FzIHRvbyBsb25nIGZvciBQaS4gVHJ1bmNhdGVkIHRvIDk5OSBjaGFyYWN0ZXJzLCBsb3NpbmcgdGhlIGZvbGxvd2luZyB0ZXh0OiAuLi4gJHt0cmFuc2NyaXB0LnN1YnN0cmluZyhcbiAgICAgICAgICA5OTlcbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH1cbiAgICBFdmVudE1vZHVsZS5zZXROYXRpdmVWYWx1ZSh0ZXh0YXJlYSwgdHJhbnNjcmlwdCk7XG4gICAgRXZlbnRCdXMuZW1pdChcInNheXBpOmF1dG9TdWJtaXRcIik7XG4gIH0gZWxzZSB7XG4gICAgRXZlbnRNb2R1bGUuc2ltdWxhdGVUeXBpbmcodGV4dGFyZWEsIGAke3RyYW5zY3JpcHR9IGApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVRyYW5zY3JpcHRzKHRyYW5zY3JpcHRzOiBSZWNvcmQ8bnVtYmVyLCBzdHJpbmc+KTogc3RyaW5nIHtcbiAgY29uc3Qgc29ydGVkS2V5cyA9IE9iamVjdC5rZXlzKHRyYW5zY3JpcHRzKVxuICAgIC5tYXAoTnVtYmVyKVxuICAgIC5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG5cbiAgY29uc3Qgc29ydGVkVHJhbnNjcmlwdHM6IHN0cmluZ1tdID0gW107XG5cbiAgZm9yIChjb25zdCBrZXkgb2Ygc29ydGVkS2V5cykge1xuICAgIHNvcnRlZFRyYW5zY3JpcHRzLnB1c2godHJhbnNjcmlwdHNba2V5XS50cmltKCkpO1xuICB9XG5cbiAgcmV0dXJuIHNvcnRlZFRyYW5zY3JpcHRzLmpvaW4oXCIgXCIpO1xufVxuIiwiLy8gTW9zdCBvZiB0aGUgY29kZSBoZXJlIGNvbWUgZnJvbSByaWNreTAxMjMvdmFkLXdlYlxuLy8gV2hvIGluIHR1cm4gY29waWVkIGl0IGZyb20gbGludG8tYWkvV2ViVm9pY2VTREtcblxuZXhwb3J0IGZ1bmN0aW9uIG1pbkZyYW1lc0ZvclRhcmdldE1TKFxuICB0YXJnZXREdXJhdGlvbjogbnVtYmVyLFxuICBmcmFtZVNhbXBsZXM6IG51bWJlcixcbiAgc3IgPSAxNjAwMFxuKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGguY2VpbCgodGFyZ2V0RHVyYXRpb24gKiBzcikgLyAxMDAwIC8gZnJhbWVTYW1wbGVzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5QnVmZmVyVG9CYXNlNjQoYnVmZmVyOiBBcnJheUJ1ZmZlcikge1xuICB2YXIgYmluYXJ5ID0gXCJcIjtcbiAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgdmFyIGxlbiA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSBhcyBudW1iZXIpO1xuICB9XG4gIHJldHVybiBidG9hKGJpbmFyeSk7XG59XG5cbi8qXG4gIFRoaXMgcmVzdCBvZiB0aGlzIHdhcyBtb3N0bHkgY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xpbnRvLWFpL1dlYlZvaWNlU0RLXG4gICovXG5cbi8vIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBlbmNvZGUgdGhlIEZsb2F0MzJBcnJheSBhdWRpbyBkYXRhIHByb2R1Y2VkIGZyb20gYSBNaWNWQURcbi8vIGFzIGEgV0FWIGZpbGUgYXVkaW8gYnVmZmVyXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlV0FWKFxuICBzYW1wbGVzOiBGbG9hdDMyQXJyYXksXG4gIGZvcm1hdDogbnVtYmVyID0gMyxcbiAgc2FtcGxlUmF0ZTogbnVtYmVyID0gMTYwMDAsXG4gIG51bUNoYW5uZWxzOiBudW1iZXIgPSAxLFxuICBiaXREZXB0aDogbnVtYmVyID0gMzJcbikge1xuICB2YXIgYnl0ZXNQZXJTYW1wbGUgPSBiaXREZXB0aCAvIDg7XG4gIHZhciBibG9ja0FsaWduID0gbnVtQ2hhbm5lbHMgKiBieXRlc1BlclNhbXBsZTtcbiAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig0NCArIHNhbXBsZXMubGVuZ3RoICogYnl0ZXNQZXJTYW1wbGUpO1xuICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAvKiBSSUZGIGlkZW50aWZpZXIgKi9cbiAgd3JpdGVTdHJpbmcodmlldywgMCwgXCJSSUZGXCIpO1xuICAvKiBSSUZGIGNodW5rIGxlbmd0aCAqL1xuICB2aWV3LnNldFVpbnQzMig0LCAzNiArIHNhbXBsZXMubGVuZ3RoICogYnl0ZXNQZXJTYW1wbGUsIHRydWUpO1xuICAvKiBSSUZGIHR5cGUgKi9cbiAgd3JpdGVTdHJpbmcodmlldywgOCwgXCJXQVZFXCIpO1xuICAvKiBmb3JtYXQgY2h1bmsgaWRlbnRpZmllciAqL1xuICB3cml0ZVN0cmluZyh2aWV3LCAxMiwgXCJmbXQgXCIpO1xuICAvKiBmb3JtYXQgY2h1bmsgbGVuZ3RoICovXG4gIHZpZXcuc2V0VWludDMyKDE2LCAxNiwgdHJ1ZSk7XG4gIC8qIHNhbXBsZSBmb3JtYXQgKHJhdykgKi9cbiAgdmlldy5zZXRVaW50MTYoMjAsIGZvcm1hdCwgdHJ1ZSk7XG4gIC8qIGNoYW5uZWwgY291bnQgKi9cbiAgdmlldy5zZXRVaW50MTYoMjIsIG51bUNoYW5uZWxzLCB0cnVlKTtcbiAgLyogc2FtcGxlIHJhdGUgKi9cbiAgdmlldy5zZXRVaW50MzIoMjQsIHNhbXBsZVJhdGUsIHRydWUpO1xuICAvKiBieXRlIHJhdGUgKHNhbXBsZSByYXRlICogYmxvY2sgYWxpZ24pICovXG4gIHZpZXcuc2V0VWludDMyKDI4LCBzYW1wbGVSYXRlICogYmxvY2tBbGlnbiwgdHJ1ZSk7XG4gIC8qIGJsb2NrIGFsaWduIChjaGFubmVsIGNvdW50ICogYnl0ZXMgcGVyIHNhbXBsZSkgKi9cbiAgdmlldy5zZXRVaW50MTYoMzIsIGJsb2NrQWxpZ24sIHRydWUpO1xuICAvKiBiaXRzIHBlciBzYW1wbGUgKi9cbiAgdmlldy5zZXRVaW50MTYoMzQsIGJpdERlcHRoLCB0cnVlKTtcbiAgLyogZGF0YSBjaHVuayBpZGVudGlmaWVyICovXG4gIHdyaXRlU3RyaW5nKHZpZXcsIDM2LCBcImRhdGFcIik7XG4gIC8qIGRhdGEgY2h1bmsgbGVuZ3RoICovXG4gIHZpZXcuc2V0VWludDMyKDQwLCBzYW1wbGVzLmxlbmd0aCAqIGJ5dGVzUGVyU2FtcGxlLCB0cnVlKTtcbiAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgIC8vIFJhdyBQQ01cbiAgICBmbG9hdFRvMTZCaXRQQ00odmlldywgNDQsIHNhbXBsZXMpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlRmxvYXQzMih2aWV3LCA0NCwgc2FtcGxlcyk7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gaW50ZXJsZWF2ZShpbnB1dEw6IEZsb2F0MzJBcnJheSwgaW5wdXRSOiBGbG9hdDMyQXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGlucHV0TC5sZW5ndGggKyBpbnB1dFIubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgaW5wdXRJbmRleCA9IDA7XG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleCsrXSA9IGlucHV0TFtpbnB1dEluZGV4XSBhcyBudW1iZXI7XG4gICAgcmVzdWx0W2luZGV4KytdID0gaW5wdXRSW2lucHV0SW5kZXhdIGFzIG51bWJlcjtcbiAgICBpbnB1dEluZGV4Kys7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdDMyKG91dHB1dDogRGF0YVZpZXcsIG9mZnNldDogbnVtYmVyLCBpbnB1dDogRmxvYXQzMkFycmF5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyssIG9mZnNldCArPSA0KSB7XG4gICAgb3V0cHV0LnNldEZsb2F0MzIob2Zmc2V0LCBpbnB1dFtpXSBhcyBudW1iZXIsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsb2F0VG8xNkJpdFBDTShcbiAgb3V0cHV0OiBEYXRhVmlldyxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIGlucHV0OiBGbG9hdDMyQXJyYXlcbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrLCBvZmZzZXQgKz0gMikge1xuICAgIHZhciBzID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIGlucHV0W2ldIGFzIG51bWJlcikpO1xuICAgIG91dHB1dC5zZXRJbnQxNihvZmZzZXQsIHMgPCAwID8gcyAqIDB4ODAwMCA6IHMgKiAweDdmZmYsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nKHZpZXc6IERhdGFWaWV3LCBvZmZzZXQ6IG51bWJlciwgc3RyaW5nOiBzdHJpbmcpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIGksIHN0cmluZy5jaGFyQ29kZUF0KGkpKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgTWljVkFELCBSZWFsVGltZVZBRE9wdGlvbnMgfSBmcm9tIFwiQHJpY2t5MDEyMy92YWQtd2ViXCI7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tIFwiLi4vQ29uZmlnTW9kdWxlXCI7XG5pbXBvcnQgeyBzZXR1cEludGVyY2VwdG9ycyB9IGZyb20gXCIuLi9SZXF1ZXN0SW50ZXJjZXB0b3JcIjtcbmltcG9ydCB7IGNvbnZlcnRUb1dhdkJsb2IgfSBmcm9tIFwiLi4vQXVkaW9FbmNvZGVyXCI7XG5pbXBvcnQgeyBjcmVhdGVNYWNoaW5lLCBhc3NpZ24gfSBmcm9tIFwieHN0YXRlXCI7XG5pbXBvcnQgRXZlbnRCdXMgZnJvbSBcIi4uL0V2ZW50QnVzLmpzXCI7XG5cbi8vIEFzc3VtaW5nIGNvbmZpZy5hcHBTZXJ2ZXJVcmwgaXMgb2YgdHlwZSBzdHJpbmcuXG5jb25zdCBmdWxsV29ya2xldFVSTDogc3RyaW5nID0gYCR7Y29uZmlnLmFwcFNlcnZlclVybH0vdmFkLndvcmtsZXQuYnVuZGxlLm1pbi5qc2A7XG5cbi8vIEFzc3VtaW5nIEV2ZW50QnVzIGlzIGEgcHJvcGVydHkgb2YgV2luZG93IGFuZCBpcyBvZiB0eXBlIGFueVxuLy8gWW91IG1pZ2h0IHdhbnQgdG8gcHJvdmlkZSBhIG1vcmUgc3BlY2lmaWMgdHlwZSBpZiBhdmFpbGFibGVcbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgRXZlbnRCdXM6IGFueTtcbiAgfVxufVxuXG5sZXQgYXVkaW9NaW1lVHlwZTogc3RyaW5nID0gXCJhdWRpby93YXZcIjtcbmxldCBzcGVlY2hTdGFydFRpbWU6IG51bWJlciA9IDA7XG5jb25zdCB0aHJlc2hvbGQ6IG51bWJlciA9IDEwMDA7IC8vIDEwMDAgbXMgPSAxIHNlY29uZCwgYWJvdXQgdGhlIGxlbmd0aCBvZiBcIkhleSwgUGlcIlxuXG5zZXR1cEludGVyY2VwdG9ycygpO1xuXG4vLyBWYXJpYWJsZSB0byBob2xkIHRoZSBtaWNyb3Bob25lIGluc3RhbmNlLiBOb3cgaGFzIGEgc3BlY2lmaWMgdHlwZS5cbmxldCBtaWNyb3Bob25lOiBNaWNWQUQgfCBudWxsID0gbnVsbDtcblxuLy8gRGVmaW5lIHRoZSBjYWxsYmFja3MgbWFudWFsbHkgaWYgdGhleSBhcmUgbm90IGV4cG9ydGVkXG5pbnRlcmZhY2UgTXlSZWFsVGltZVZBRENhbGxiYWNrcyB7XG4gIG9uU3BlZWNoU3RhcnQ/OiAoKSA9PiBhbnk7XG4gIG9uU3BlZWNoRW5kPzogKGF1ZGlvOiBGbG9hdDMyQXJyYXkpID0+IGFueTtcbiAgb25WQURNaXNmaXJlPzogKCkgPT4gYW55O1xufVxuXG4vLyBPcHRpb25zIGZvciBNaWNWQURcbmNvbnN0IG1pY1ZBRE9wdGlvbnM6IFBhcnRpYWw8UmVhbFRpbWVWQURPcHRpb25zPiAmIE15UmVhbFRpbWVWQURDYWxsYmFja3MgPSB7XG4gIHdvcmtsZXRVUkw6IGZ1bGxXb3JrbGV0VVJMLFxuICBwb3NpdGl2ZVNwZWVjaFRocmVzaG9sZDogMC44LFxuICBtaW5TcGVlY2hGcmFtZXM6IDUsXG4gIHByZVNwZWVjaFBhZEZyYW1lczogMTAsXG4gIG9uU3BlZWNoU3RhcnQ6ICgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIlNwZWVjaCBzdGFydGVkXCIpO1xuICAgIHNwZWVjaFN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgRXZlbnRCdXMuZW1pdChcInNheXBpOnVzZXJTcGVha2luZ1wiKTtcbiAgfSxcbiAgb25TcGVlY2hFbmQ6IChyYXdBdWRpb0RhdGE6IEZsb2F0MzJBcnJheSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiU3BlZWNoIGVuZGVkXCIpO1xuICAgIGNvbnN0IHNwZWVjaFN0b3BUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBzcGVlY2hEdXJhdGlvbiA9IHNwZWVjaFN0b3BUaW1lIC0gc3BlZWNoU3RhcnRUaW1lO1xuICAgIGNvbnN0IGF1ZGlvQmxvYiA9IGNvbnZlcnRUb1dhdkJsb2IocmF3QXVkaW9EYXRhKTtcbiAgICBFdmVudEJ1cy5lbWl0KFwiYXVkaW86ZGF0YWF2YWlsYWJsZVwiLCB7XG4gICAgICBibG9iOiBhdWRpb0Jsb2IsXG4gICAgICBkdXJhdGlvbjogc3BlZWNoRHVyYXRpb24sXG4gICAgfSk7XG4gIH0sXG4gIG9uVkFETWlzZmlyZTogKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiQ2FuY2VsbGVkLiBBdWRpbyB3YXMgbm90IHNwZWVjaC5cIik7XG4gICAgRXZlbnRCdXMuZW1pdChcInNheXBpOnVzZXJTdG9wcGVkU3BlYWtpbmdcIiwgeyBkdXJhdGlvbjogMCB9KTtcbiAgfSxcbn07XG5cbi8vIFRoZSBjYWxsYmFjayB0eXBlIGNhbiBiZSBtb3JlIHNwZWNpZmljIGJhc2VkIG9uIHlvdXIgdXNhZ2VcbmFzeW5jIGZ1bmN0aW9uIHNldHVwUmVjb3JkaW5nKGNhbGxiYWNrPzogKCkgPT4gdm9pZCk6IFByb21pc2U8dm9pZD4ge1xuICBpZiAobWljcm9waG9uZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xuICAgICAgYXVkaW86IHtcbiAgICAgICAgY2hhbm5lbENvdW50OiAxLFxuICAgICAgICBlY2hvQ2FuY2VsbGF0aW9uOiB0cnVlLFxuICAgICAgICBhdXRvR2FpbkNvbnRyb2w6IHRydWUsXG4gICAgICAgIG5vaXNlU3VwcHJlc3Npb246IHRydWUsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgbWljcm9waG9uZSA9IGF3YWl0IE1pY1ZBRC5uZXcoe1xuICAgICAgLi4ubWljVkFET3B0aW9ucyxcbiAgICAgIHN0cmVhbSxcbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJWQUQgZmFpbGVkIHRvIGxvYWRcIiwgZXJyKTtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgYEFwcGxpY2F0aW9uIHNlcnZlciBhdCAke2NvbmZpZy5hcHBTZXJ2ZXJVcmx9IG1heSBiZSB1bmF2YWlsYWJsZS4gUGxlYXNlIG1ha2Ugc3VyZSBpdCBpcyBydW5uaW5nLmBcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRlYXJEb3duUmVjb3JkaW5nKCk6IHZvaWQge1xuICBpZiAobWljcm9waG9uZSkge1xuICAgIG1pY3JvcGhvbmUucGF1c2UoKTtcbiAgfVxuICBtaWNyb3Bob25lID0gbnVsbDtcbn1cblxuaW50ZXJmYWNlIEF1ZGlvSW5wdXRDb250ZXh0IHtcbiAgd2FpdGluZ1RvU3RvcDogYm9vbGVhbjtcbiAgd2FpdGluZ1RvU3RhcnQ6IGJvb2xlYW47XG4gIHJlY29yZGluZ1N0YXJ0VGltZTogbnVtYmVyO1xufVxuXG50eXBlIEF1ZGlvSW5wdXRFdmVudCA9XG4gIHwgeyB0eXBlOiBcImFjcXVpcmVcIiB9XG4gIHwgeyB0eXBlOiBcInJlbGVhc2VcIiB9XG4gIHwgeyB0eXBlOiBcInN0YXJ0XCIgfVxuICB8IHsgdHlwZTogXCJzdG9wUmVxdWVzdGVkXCIgfVxuICB8IHsgdHlwZTogXCJkYXRhQXZhaWxhYmxlXCI7IGJsb2I6IEJsb2I7IGR1cmF0aW9uOiBudW1iZXIgfVxuICB8IHsgdHlwZTogXCJzdG9wXCIgfVxuICB8IHsgdHlwZTogXCJlcnJvci5wbGF0Zm9ybVwiOyBkYXRhOiBhbnkgfTtcblxuZXhwb3J0IGNvbnN0IGF1ZGlvSW5wdXRNYWNoaW5lID0gY3JlYXRlTWFjaGluZTxcbiAgQXVkaW9JbnB1dENvbnRleHQsXG4gIEF1ZGlvSW5wdXRFdmVudFxuPihcbiAge1xuICAgIC8qKiBAeHN0YXRlLWxheW91dCBONElncGdKZzVtRE9JQzVRRU1DdUVDV0I3QWtnT3dBZFVBWEFPZ0Njd0FiTVpXU0FZbVFHTUJIVkRTZ2JRQVlCZFJLQUpaWUdZdGp5Q1FBRDBRQkdBR3dCbVVnRlllRzFVb0NjMmdDeEtBN0hKNEtBTkNBQ2VpSlhJQWNwQlllMEs3YnBhc01IdHFnTDYrTE5FeGNRaEpTRm5aT0REd29CZ2dzUERCU2FJQTNMQUJySktEc2ZDSXlDSTV5YUtnRVZLeG1aSEVFM2o0YXFXRlJLc2trR1VSVkFDWUxhd1E3UFZWU1JWTWVPeVU5YlNWbGJYOUE5QnpRLUxaQzRvWXdjbklzY2xJQ0trcUFNdzJBVzNEWmtMend4YWlZMHJ3MGlxYWF1cGFHc1FrcFdRUTVReFYxVFIxOUl4TTVpc2lIYTdYNm9JVXFsVUNuMExsMFgybUlHeXB6Q0JVNGpFb05Eb1lFZVFoRUx3U2Iza1h6VUdoNFdsMEJtTXBpNmlEc2NsSVkxMDJoNFJuYVBHMGluYWlPUnVWUkYwb0VHU0VCb0RGZ3hHUTVHSXVKQXp5YVJJKzdVK0F4NGNsVUl5aGhsWkkxcFBWNnBDVW9QR2VrTWhqc1RqVlBKT2ZJV2tVRkZEQXpBMm1CaVl1SVdBSUFDVXdPdzRNUklESzVhOFd1ODVPMXRJWURYWjJuWU9jTkZNNWRWcitwODRXYlZMcDJuMHJjRWJlYzdaQUhVN3lDN1loQktzZ0FJSXBaQVlIWUFJeG9nZng4cEQ4ajBrTklHcnNMamNZYmtTbDFzWWN2V1VDbkhlbnNwcW1BU1Ixdm0rY0toWUlZRHdwWUF5dTZDRzZQYzNHc0hRTzlqQTRGQnp3NXl0WFl2dHBkZHBRVkdZNGJQQVoyZ3B1YlBlUXUwZmFWMnZpcHVQVGlDdHExckJzbTM0ZW9Xd1BWb0VHUFJ3ejEwVDVobXZJY3dWSU84NFgwT1JPUk1PUWN6bU01djBMY1VQUlhDQUdEM0FsbWtQZVJ0VFVOVlZIc09ROUEwZHBEQ0Jib1dRY1p3ZkEwQXhGRmpQREVUd0xBSURnS1JQenlTRDkwSk5zRUFBV2c0eEJGUHdsRXlFeFdoNkFnYVNxSVZQUk9tQkQ1bVBnaGlGQ1F3RWZGVXZOdjJLSFRXeG9oQS1uUTg4ZUdNSndPV2NWUmRTTkFac05OSlFoalZld3JLLUFWSURzNkQzbGZCbDJLaFA1T1VoWVpkVThGUlV4aGJEVkVuUzBQM25RaXdxRkRBUlRBQ0xaSWN1UUJ4VVU5bUlVUHBYSzBOeGIxYzBnZUtaWnd0U3drSzhvTElWS0dMVXNTdW9tRG1QcFp6N0haRmlKall2UmJ4TVVoejFhaU1PVW5UcitXNnJaVnczTGNCb1ZBTHRHYXlFS1VReEs3Q0hMUUJrTk5yVlI0STA5QlcyMGx5RkVpQ0RJN2E1S3ZQYm9YYUNZN0VZbU5Nb003bzNEME9iZEhVQUtzM1ZXeC1IOElBICovXG4gICAgaWQ6IFwiYXVkaW9JbnB1dFwiLFxuICAgIGluaXRpYWw6IFwicmVsZWFzZWRcIixcbiAgICBjb250ZXh0OiB7XG4gICAgICB3YWl0aW5nVG9TdG9wOiBmYWxzZSxcbiAgICAgIHdhaXRpbmdUb1N0YXJ0OiBmYWxzZSxcbiAgICAgIHJlY29yZGluZ1N0YXJ0VGltZTogMCxcbiAgICB9LFxuICAgIHN0YXRlczoge1xuICAgICAgcmVsZWFzZWQ6IHtcbiAgICAgICAgb246IHtcbiAgICAgICAgICBhY3F1aXJlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiYWNxdWlyaW5nXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBhY3F1aXJpbmc6IHtcbiAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgXCJBY3F1aXJpbmcgdGhlIG1pY3JvcGhvbmUuIFdhaXRzIHVudGlsIGFzeW5jaHJvbm91cyBjYWxsIGhhcyBjb21wbGV0ZWQuXCIsXG4gICAgICAgIGludm9rZToge1xuICAgICAgICAgIHNyYzogXCJhY3F1aXJlTWljcm9waG9uZVwiLFxuICAgICAgICAgIG9uRG9uZToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcImFjcXVpcmVkXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkVycm9yOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwicmVsZWFzZWRcIixcbiAgICAgICAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJsb2dFcnJvclwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBhY3Rpb25zOiBhc3NpZ24oeyB3YWl0aW5nVG9TdGFydDogdHJ1ZSB9KSxcbiAgICAgICAgICAgIGludGVybmFsOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgYWNxdWlyZWQ6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTWljcm9waG9uZSBhY3F1aXJlZCBhbmQgcmVhZHkgdG8gc3RhcnQgcmVjb3JkaW5nLlwiLFxuICAgICAgICBpbml0aWFsOiBcImlkbGVcIixcbiAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgaWRsZToge1xuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IFwicmVjb3JkaW5nXCIsXG4gICAgICAgICAgICAgICAgY29uZDogXCJtaWNyb3Bob25lQWNxdWlyZWRcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbHdheXM6IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcInJlY29yZGluZ1wiLFxuICAgICAgICAgICAgICBjb25kOiBcInBlbmRpbmdTdGFydFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlY29yZGluZzoge1xuICAgICAgICAgICAgZW50cnk6IFtcInN0YXJ0UmVjb3JkaW5nXCIsIGFzc2lnbih7IHdhaXRpbmdUb1N0YXJ0OiBmYWxzZSB9KV0sXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBzdG9wUmVxdWVzdGVkOiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBcInBlbmRpbmdTdG9wXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGRhdGFBdmFpbGFibGU6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInNlbmREYXRhXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwZW5kaW5nU3RvcDoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgICAgIFwiV2FpdGluZyBmb3IgdGhlIG1lZGlhIHJlY29yZGluZyBkZXZpY2UgdG8gc3RvcCByZWNvcmRpbmcuXCIsXG4gICAgICAgICAgICBlbnRyeToge1xuICAgICAgICAgICAgICB0eXBlOiBcInByZXBhcmVTdG9wXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWZ0ZXI6IHtcbiAgICAgICAgICAgICAgXCI1MDAwXCI6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiI2F1ZGlvSW5wdXQuYWNxdWlyZWQuc3RvcHBlZFwiLFxuICAgICAgICAgICAgICAgICAgYWN0aW9uczogW1wic3RvcElmV2FpdGluZ1wiXSxcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlN0b3AgZXZlbnR1YWxseVwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaW50ZXJuYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgc3RvcDoge1xuICAgICAgICAgICAgICAgIHRhcmdldDogXCJzdG9wcGVkXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiU3RvcCBpbW1lZGlhdGVseVwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkYXRhQXZhaWxhYmxlOiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBcInN0b3BwZWRcIixcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJzdG9wSWZXYWl0aW5nXCIsIFwic2VuZERhdGFcIl0sXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiU3RvcCBhZnRlciBmaW5hbCBhdWRpbyBkYXRhIGNvbGxlY3RlZFwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0b3BwZWQ6IHtcbiAgICAgICAgICAgIGVudHJ5OiBhc3NpZ24oeyB3YWl0aW5nVG9TdG9wOiBmYWxzZSB9KSxcbiAgICAgICAgICAgIGFsd2F5czoge1xuICAgICAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIHJlbGVhc2U6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJyZWxlYXNlZFwiLFxuICAgICAgICAgICAgYWN0aW9uczoge1xuICAgICAgICAgICAgICB0eXBlOiBcInJlbGVhc2VNaWNyb3Bob25lXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgcHJlZGljdGFibGVBY3Rpb25Bcmd1bWVudHM6IHRydWUsXG4gICAgcHJlc2VydmVBY3Rpb25PcmRlcjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGFjdGlvbnM6IHtcbiAgICAgIHN0YXJ0UmVjb3JkaW5nOiAoY29udGV4dCwgZXZlbnQpID0+IHtcbiAgICAgICAgY29udGV4dC5yZWNvcmRpbmdTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIC8vIFN0YXJ0IHJlY29yZGluZ1xuICAgICAgICBpZiAobWljcm9waG9uZSAmJiBtaWNyb3Bob25lLmxpc3RlbmluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBtaWNyb3Bob25lLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHByZXBhcmVTdG9wOiAoY29udGV4dCwgZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKG1pY3JvcGhvbmUgJiYgbWljcm9waG9uZS5saXN0ZW5pbmcgPT09IHRydWUpIHtcbiAgICAgICAgICBjb250ZXh0LndhaXRpbmdUb1N0b3AgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBzZW5kRGF0YTogKFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBldmVudDogeyB0eXBlOiBcImRhdGFBdmFpbGFibGVcIjsgYmxvYjogQmxvYjsgZHVyYXRpb246IG51bWJlciB9XG4gICAgICApID0+IHtcbiAgICAgICAgY29uc3QgeyBibG9iLCBkdXJhdGlvbiB9ID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IHNpemVJbktiID0gKGJsb2Iuc2l6ZSAvIDEwMjQpLnRvRml4ZWQoMik7IC8vIENvbnZlcnQgdG8ga2lsb2J5dGVzIGFuZCBrZWVwIDIgZGVjaW1hbCBwbGFjZXNcbiAgICAgICAgY29uc29sZS5sb2coYFVwbG9hZGluZyAke3NpemVJbktifWtiIG9mIGF1ZGlvIGRhdGFgKTtcblxuICAgICAgICAvLyBVc2UgdGhlIGR1cmF0aW9uIGRpcmVjdGx5IGZyb20gdGhlIGV2ZW50XG4gICAgICAgIGNvbnN0IHNwZWVjaER1cmF0aW9uID0gZHVyYXRpb247XG5cbiAgICAgICAgaWYgKE51bWJlcihzaXplSW5LYikgPiAwKSB7XG4gICAgICAgICAgLy8gVXBsb2FkIHRoZSBhdWRpbyB0byB0aGUgc2VydmVyIGZvciB0cmFuc2NyaXB0aW9uXG4gICAgICAgICAgRXZlbnRCdXMuZW1pdChcInNheXBpOnVzZXJTdG9wcGVkU3BlYWtpbmdcIiwge1xuICAgICAgICAgICAgZHVyYXRpb246IHNwZWVjaER1cmF0aW9uLFxuICAgICAgICAgICAgYmxvYixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgc3RvcElmV2FpdGluZzogKFNheVBpQ29udGV4dCkgPT4ge1xuICAgICAgICBpZiAoU2F5UGlDb250ZXh0LndhaXRpbmdUb1N0b3AgPT09IHRydWUpIHtcbiAgICAgICAgICBtaWNyb3Bob25lPy5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICByZWxlYXNlTWljcm9waG9uZTogKGNvbnRleHQsIGV2ZW50KSA9PiB7XG4gICAgICAgIHRlYXJEb3duUmVjb3JkaW5nKCk7XG4gICAgICB9LFxuXG4gICAgICBsb2dFcnJvcjogKGNvbnRleHQsIGV2ZW50OiB7IHR5cGU6IFwiZXJyb3IucGxhdGZvcm1cIjsgZGF0YTogYW55IH0pID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFjcXVpcmluZyBtaWNyb3Bob25lOiBcIiwgZXZlbnQuZGF0YSk7XG4gICAgICB9LFxuICAgIH0sXG4gICAgc2VydmljZXM6IHtcbiAgICAgIGFjcXVpcmVNaWNyb3Bob25lOiAoY29udGV4dCwgZXZlbnQpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBzZXR1cFJlY29yZGluZygoKSA9PiB7XG4gICAgICAgICAgICBpZiAobWljcm9waG9uZSkge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiRmFpbGVkIHRvIGFjcXVpcmUgbWljcm9waG9uZSByZXNvdXJjZS5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICBndWFyZHM6IHtcbiAgICAgIG1pY3JvcGhvbmVBY3F1aXJlZDogKGNvbnRleHQsIGV2ZW50KSA9PiB7XG4gICAgICAgIHJldHVybiBtaWNyb3Bob25lICE9PSBudWxsO1xuICAgICAgfSxcbiAgICAgIHBlbmRpbmdTdGFydDogKGNvbnRleHQsIGV2ZW50KSA9PiB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LndhaXRpbmdUb1N0YXJ0ID09PSB0cnVlO1xuICAgICAgfSxcbiAgICB9LFxuICAgIGRlbGF5czoge30sXG4gIH1cbik7XG4iLCJpbXBvcnQgeyBidXR0b25Nb2R1bGUgfSBmcm9tIFwiLi4vQnV0dG9uTW9kdWxlLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVNYWNoaW5lLCBUeXBlc3RhdGUsIGFzc2lnbiB9IGZyb20gXCJ4c3RhdGVcIjtcbmltcG9ydCBBbmltYXRpb25Nb2R1bGUgZnJvbSBcIi4uL0FuaW1hdGlvbk1vZHVsZS5qc1wiO1xuaW1wb3J0IHsgaXNNb2JpbGVWaWV3IH0gZnJvbSBcIi4uL1VzZXJBZ2VudE1vZHVsZS5qc1wiO1xuaW1wb3J0IHtcbiAgdXBsb2FkQXVkaW9XaXRoUmV0cnksXG4gIHNldFByb21wdFRleHQsXG4gIGlzVHJhbnNjcmlwdGlvblBlbmRpbmcsXG4gIGNsZWFyUGVuZGluZ1RyYW5zY3JpcHRpb25zLFxuICBtZXJnZVRyYW5zY3JpcHRzLFxufSBmcm9tIFwiLi4vVHJhbnNjcmlwdGlvbk1vZHVsZVwiO1xuaW1wb3J0IEV2ZW50QnVzIGZyb20gXCIuLi9FdmVudEJ1c1wiO1xuXG50eXBlIFNheVBpVHJhbnNjcmliZWRFdmVudCA9IHtcbiAgdHlwZTogXCJzYXlwaTp0cmFuc2NyaWJlZFwiO1xuICB0ZXh0OiBzdHJpbmc7XG4gIHNlcXVlbmNlTnVtYmVyOiBudW1iZXI7XG4gIHBGaW5pc2hlZFNwZWFraW5nPzogbnVtYmVyO1xuICB0ZW1wbz86IG51bWJlcjtcbn07XG5cbnR5cGUgU2F5UGlTcGVlY2hTdG9wcGVkRXZlbnQgPSB7XG4gIHR5cGU6IFwic2F5cGk6dXNlclN0b3BwZWRTcGVha2luZ1wiO1xuICBkdXJhdGlvbjogbnVtYmVyO1xuICBibG9iPzogQmxvYjtcbn07XG5cbnR5cGUgU2F5UGlFdmVudCA9XG4gIHwgeyB0eXBlOiBcInNheXBpOnVzZXJTcGVha2luZ1wiIH1cbiAgfCBTYXlQaVNwZWVjaFN0b3BwZWRFdmVudFxuICB8IHsgdHlwZTogXCJzYXlwaTp1c2VyRmluaXNoZWRTcGVha2luZ1wiIH1cbiAgfCBTYXlQaVRyYW5zY3JpYmVkRXZlbnRcbiAgfCB7IHR5cGU6IFwic2F5cGk6dHJhbnNjcmliZUZhaWxlZFwiIH1cbiAgfCB7IHR5cGU6IFwic2F5cGk6dHJhbnNjcmliZWRFbXB0eVwiIH1cbiAgfCB7IHR5cGU6IFwic2F5cGk6cGlTcGVha2luZ1wiIH1cbiAgfCB7IHR5cGU6IFwic2F5cGk6cGlTdG9wcGVkU3BlYWtpbmdcIiB9XG4gIHwgeyB0eXBlOiBcInNheXBpOnBpRmluaXNoZWRTcGVha2luZ1wiIH1cbiAgfCB7IHR5cGU6IFwic2F5cGk6c3VibWl0XCIgfVxuICB8IHsgdHlwZTogXCJzYXlwaTpjYWxsXCIgfVxuICB8IHsgdHlwZTogXCJzYXlwaTpoYW5ndXBcIiB9O1xuXG5pbnRlcmZhY2UgU2F5UGlDb250ZXh0IHtcbiAgdHJhbnNjcmlwdGlvbnM6IFJlY29yZDxudW1iZXIsIHN0cmluZz47XG4gIGxhc3RTdGF0ZTogXCJpbmFjdGl2ZVwiIHwgXCJsaXN0ZW5pbmdcIjtcbiAgdGltZVVzZXJTdG9wcGVkU3BlYWtpbmc6IG51bWJlcjtcbn1cblxuLy8gRGVmaW5lIHRoZSBzdGF0ZSBzY2hlbWFcbnR5cGUgU2F5UGlTdGF0ZVNjaGVtYSA9IHtcbiAgc3RhdGVzOiB7XG4gICAgaW5hY3RpdmU6IHt9O1xuICAgIGVycm9yczoge1xuICAgICAgc3RhdGVzOiB7XG4gICAgICAgIHRyYW5zY3JpYmVGYWlsZWQ6IHt9O1xuICAgICAgICBtaWNFcnJvcjoge307XG4gICAgICB9O1xuICAgIH07XG4gICAgbGlzdGVuaW5nOiB7XG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgcmVjb3JkaW5nOiB7XG4gICAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgICB1c2VyU3BlYWtpbmc6IHt9O1xuICAgICAgICAgICAgbm90U3BlYWtpbmc6IHt9O1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnZlcnRpbmc6IHtcbiAgICAgICAgICBzdGF0ZXM6IHtcbiAgICAgICAgICAgIHRyYW5zY3JpYmluZzoge307XG4gICAgICAgICAgICBhY2N1bXVsYXRpbmc6IHt9O1xuICAgICAgICAgICAgc3VibWl0dGluZzoge307XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgICByZXNwb25kaW5nOiB7XG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgcGlTcGVha2luZzoge307XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59O1xuXG5pbnRlcmZhY2UgU2F5UGlUeXBlc3RhdGUgZXh0ZW5kcyBUeXBlc3RhdGU8U2F5UGlDb250ZXh0PiB7XG4gIHZhbHVlOiBcImxpc3RlbmluZ1wiIHwgXCJpbmFjdGl2ZVwiIHwgXCJlcnJvcnNcIiB8IFwicmVzcG9uZGluZ1wiO1xuICBjb250ZXh0OiBTYXlQaUNvbnRleHQ7XG59XG5cbi8qIGhlbHBlciBmdW5jdGlvbnMgKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVEZWxheShcbiAgdGltZVVzZXJTdG9wcGVkU3BlYWtpbmc6IG51bWJlcixcbiAgcHJvYmFiaWxpdHlGaW5pc2hlZDogbnVtYmVyLFxuICB0ZW1wbzogbnVtYmVyLFxuICBtYXhEZWxheTogbnVtYmVyXG4pOiBudW1iZXIge1xuICAvLyBHZXQgdGhlIGN1cnJlbnQgdGltZSAoaW4gbWlsbGlzZWNvbmRzKVxuICBjb25zdCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSB1c2VyIHN0b3BwZWQgc3BlYWtpbmcgKGluIG1pbGxpc2Vjb25kcylcbiAgY29uc3QgdGltZUVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRpbWVVc2VyU3RvcHBlZFNwZWFraW5nO1xuXG4gIC8vIFdlIGludmVydCB0aGUgdGVtcG8gYmVjYXVzZSBhIGZhc3RlciBzcGVlY2ggKHRlbXBvIGFwcHJvYWNoaW5nIDEpIHNob3VsZCByZWR1Y2UgdGhlIGRlbGF5XG4gIGxldCB0ZW1wb0ZhY3RvciA9IDEgLSB0ZW1wbztcblxuICAvLyBDYWxjdWxhdGUgdGhlIGNvbWJpbmVkIHByb2JhYmlsaXR5IGZhY3RvclxuICBsZXQgY29tYmluZWRQcm9iYWJpbGl0eSA9IHByb2JhYmlsaXR5RmluaXNoZWQgKiB0ZW1wb0ZhY3RvcjtcblxuICAvLyBUaGUgY29tYmluZWQgZmFjdG9yIGluZmx1ZW5jZXMgdGhlIGluaXRpYWwgZGVsYXlcbiAgY29uc3QgaW5pdGlhbERlbGF5ID0gY29tYmluZWRQcm9iYWJpbGl0eSAqIG1heERlbGF5O1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgZmluYWwgZGVsYXkgYWZ0ZXIgYWNjb3VudGluZyBmb3IgdGhlIHRpbWUgYWxyZWFkeSBlbGFwc2VkXG4gIGNvbnN0IGZpbmFsRGVsYXkgPSBNYXRoLm1heChpbml0aWFsRGVsYXkgLSB0aW1lRWxhcHNlZCwgMCk7XG4gIHJldHVybiBmaW5hbERlbGF5O1xufVxuXG4vKiBleHRlcm5hbCBhY3Rpb25zICovXG5jb25zdCBjbGVhclRyYW5zY3JpcHRzID0gYXNzaWduKHtcbiAgdHJhbnNjcmlwdGlvbnM6ICgpID0+ICh7fSksXG59KTtcblxuZXhwb3J0IGNvbnN0IG1hY2hpbmUgPSBjcmVhdGVNYWNoaW5lPFNheVBpQ29udGV4dCwgU2F5UGlFdmVudCwgU2F5UGlUeXBlc3RhdGU+KFxuICB7XG4gICAgY29udGV4dDoge1xuICAgICAgdHJhbnNjcmlwdGlvbnM6IHt9LFxuICAgICAgbGFzdFN0YXRlOiBcImluYWN0aXZlXCIsXG4gICAgICB0aW1lVXNlclN0b3BwZWRTcGVha2luZzogMCxcbiAgICB9LFxuICAgIGlkOiBcInNheVBpXCIsXG4gICAgaW5pdGlhbDogXCJpbmFjdGl2ZVwiLFxuICAgIHN0YXRlczoge1xuICAgICAgaW5hY3RpdmU6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFwiSWRsZSBzdGF0ZSwgbm90IGxpc3RlbmluZyBvciBzcGVha2luZy4gUHJpdmFjeSBtb2RlLlwiLFxuICAgICAgICBleGl0OiBhc3NpZ24oeyBsYXN0U3RhdGU6IFwiaW5hY3RpdmVcIiB9KSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBcInNheXBpOmNhbGxcIjoge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIiNzYXlQaS5saXN0ZW5pbmcucmVjb3JkaW5nXCIsXG4gICAgICAgICAgICBhY3Rpb25zOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNhbGxTdGFydGVkXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0YXJ0UmVjb3JkaW5nXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgICAgICdFbmFibGUgdGhlIFZBRCBtaWNyb3Bob25lLlxcbkFrYSBcImNhbGxcIiBQaS5cXG5TdGFydHMgYWN0aXZlIGxpc3RlbmluZy4nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzYXlwaTpwaVNwZWFraW5nXCI6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCIjc2F5UGkucmVzcG9uZGluZy5waVNwZWFraW5nXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBlcnJvcnM6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRXJyb3IgcGFyZW50IHN0YXRlLlwiLFxuICAgICAgICBhZnRlcjoge1xuICAgICAgICAgIFwiMTAwMDBcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0YXJnZXQ6IFwiI3NheVBpLmxpc3RlbmluZ1wiLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbXSxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiUmVzZXQgdG8gdGhlIGlkbGUgc3RhdGUgYW5kIGNsZWFyIGVycm9ycy5cIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGludGVybmFsOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgaW5pdGlhbDogXCJ0cmFuc2NyaWJlRmFpbGVkXCIsXG4gICAgICAgIHN0YXRlczoge1xuICAgICAgICAgIHRyYW5zY3JpYmVGYWlsZWQ6IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSAvdHJhbnNjcmliZSBBUEkgcmVzcG9uZGVkIHdpdGggYW4gZXJyb3IuXCIsXG4gICAgICAgICAgICBlbnRyeToge1xuICAgICAgICAgICAgICB0eXBlOiBcInN0YXJ0QW5pbWF0aW9uXCIsXG4gICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogXCJlcnJvclwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4aXQ6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzdG9wQW5pbWF0aW9uXCIsXG4gICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogXCJlcnJvclwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5cGU6IFwiZmluYWxcIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1pY0Vycm9yOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJObyBhdWRpbyBpbnB1dCBkZXRlY3RlZFwiLFxuICAgICAgICAgICAgZW50cnk6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzaG93Tm90aWZpY2F0aW9uXCIsXG4gICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGljb246IFwibXV0ZWQtbWljcm9waG9uZVwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4aXQ6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJkaXNtaXNzTm90aWZpY2F0aW9uXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZTogXCJmaW5hbFwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgbGlzdGVuaW5nOiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgIFwiQWN0aXZlbHkgbGlzdGVuaW5nIGZvciB1c2VyIGlucHV0LiBTaW11bHRhbmVvdXNseSByZWNvcmRpbmcgYW5kIHRyYW5zY3JpYmluZyB1c2VyIHNwZWVjaC4gR2VudGxlIHB1bHNpbmcgYW5pbWF0aW9uLlwiLFxuICAgICAgICBlbnRyeTogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwic3RvcEFsbEFuaW1hdGlvbnNcIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYWNxdWlyZU1pY3JvcGhvbmVcIixcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBleGl0OiBhc3NpZ24oeyBsYXN0U3RhdGU6IFwibGlzdGVuaW5nXCIgfSksXG4gICAgICAgIHN0YXRlczoge1xuICAgICAgICAgIHJlY29yZGluZzoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgICAgIFwiTWljcm9waG9uZSBpcyBvbiBhbmQgVkFEIGlzIGFjdGl2ZWx5IGxpc3RlbmluZyBmb3IgdXNlciBzcGVlY2guXCIsXG4gICAgICAgICAgICBpbml0aWFsOiBcIm5vdFNwZWFraW5nXCIsXG4gICAgICAgICAgICBzdGF0ZXM6IHtcbiAgICAgICAgICAgICAgbm90U3BlYWtpbmc6IHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICAgICAgIFwiTWljcm9waG9uZSBpcyByZWNvcmRpbmcgYnV0IG5vIHNwZWVjaCBpcyBkZXRlY3RlZC5cIixcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgXCJzYXlwaTp1c2VyRmluaXNoZWRTcGVha2luZ1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogXCIjc2F5UGkuaW5hY3RpdmVcIixcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcInNheXBpOnVzZXJTcGVha2luZ1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogXCJ1c2VyU3BlYWtpbmdcIixcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdXNlclNwZWFraW5nOiB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgICAgICAgICBcIlVzZXIgaXMgc3BlYWtpbmcgYW5kIGJlaW5nIHJlY29yZGVkIGJ5IHRoZSBtaWNyb3Bob25lLlxcbldhdmVmb3JtIGFuaW1hdGlvbi5cIixcbiAgICAgICAgICAgICAgICBlbnRyeToge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGFydEFuaW1hdGlvblwiLFxuICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogXCJ1c2VyU3BlYWtpbmdcIixcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleGl0OiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInN0b3BBbmltYXRpb25cIixcbiAgICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb246IFwidXNlclNwZWFraW5nXCIsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgIFwic2F5cGk6dXNlclN0b3BwZWRTcGVha2luZ1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibm90U3BlYWtpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiI3NheVBpLmxpc3RlbmluZy5jb252ZXJ0aW5nLnRyYW5zY3JpYmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgY29uZDogXCJoYXNBdWRpb1wiLFxuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVVc2VyU3RvcHBlZFNwZWFraW5nOiAoKSA9PiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRyYW5zY3JpYmVBdWRpb1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcIm5vdFNwZWFraW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgY29uZDogXCJoYXNOb0F1ZGlvXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgXCJzYXlwaTpoYW5ndXBcIjoge1xuICAgICAgICAgICAgICAgIHRhcmdldDogXCIjc2F5UGkuaW5hY3RpdmVcIixcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RvcFJlY29yZGluZ1wiLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWxlYXNlTWljcm9waG9uZVwiLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjYWxsRW5kZWRcIixcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICAgICAgICdEaXNhYmxlIHRoZSBWQUQgbWljcm9waG9uZS5cXG4gICAgQWthIFwiY2FsbFwiIFBpLlxcbiAgICBTdG9wcyBhY3RpdmUgbGlzdGVuaW5nLicsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29udmVydGluZzoge1xuICAgICAgICAgICAgaW5pdGlhbDogXCJhY2N1bXVsYXRpbmdcIixcbiAgICAgICAgICAgIHN0YXRlczoge1xuICAgICAgICAgICAgICBhY2N1bXVsYXRpbmc6IHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICAgICAgIFwiQWNjdW11bGF0aW5nIGFuZCBhc3NlbWJsaW5nIGF1ZGlvIHRyYW5zY3JpcHRpb25zIGludG8gYSBjb2hlc2l2ZSBwcm9tcHQuXFxuU3VibWl0cyBhIHByb21wdCB3aGVuIGEgdGhyZXNob2xkIGlzIHJlYWNoZWQuXCIsXG4gICAgICAgICAgICAgICAgYWZ0ZXI6IHtcbiAgICAgICAgICAgICAgICAgIHN1Ym1pc3Npb25EZWxheToge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwic3VibWl0dGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBjb25kOiBcInN1Ym1pc3Npb25Db25kaXRpb25zTWV0XCIsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlN1Ym1pdCBjb21iaW5lZCB0cmFuc2NyaXB0IHRvIFBpLlwiLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICBcInNheXBpOnRyYW5zY3JpYmVkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcImFjY3VtdWxhdGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJoYW5kbGVUcmFuc2NyaXB0aW9uUmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgICAgICAgICAgICAgXCJUcmFuc2NyaWJlZCBzcGVlY2ggdG8gdGV4dCAob3V0IG9mIHNlcXVlbmNlIHJlc3BvbnNlKS5cIixcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcInNheXBpOnRyYW5zY3JpYmVGYWlsZWRcIjoge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiI3NheVBpLmVycm9ycy50cmFuc2NyaWJlRmFpbGVkXCIsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgIFwiT3V0IG9mIHNlcXVlbmNlIGVycm9yIHJlc3BvbnNlIGZyb20gdGhlIC90cmFuc2NyaWJlIEFQSVwiLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwic2F5cGk6dHJhbnNjcmliZWRFbXB0eVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogXCIjc2F5UGkuZXJyb3JzLm1pY0Vycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgIFwiT3V0IG9mIHNlcXVlbmNlIGVtcHR5IHJlc3BvbnNlIGZyb20gdGhlIC90cmFuc2NyaWJlIEFQSVwiLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdWJtaXR0aW5nOiB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiU3VibWl0dGluZyBwcm9tcHQgdG8gUGkuXCIsXG4gICAgICAgICAgICAgICAgZW50cnk6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwibWVyZ2VBbmRTdWJtaXRUcmFuc2NyaXB0XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleGl0OiBbY2xlYXJUcmFuc2NyaXB0cywgY2xlYXJQZW5kaW5nVHJhbnNjcmlwdGlvbnNdLFxuICAgICAgICAgICAgICAgIGFsd2F5czoge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcImFjY3VtdWxhdGluZ1wiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRyYW5zY3JpYmluZzoge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgICAgICAgXCJUcmFuc2NyaWJpbmcgYXVkaW8gdG8gdGV4dC5cXG5DYXJkIGZsaXAgYW5pbWF0aW9uLlwiLFxuICAgICAgICAgICAgICAgIGVudHJ5OiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInN0YXJ0QW5pbWF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uOiBcInRyYW5zY3JpYmluZ1wiLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV4aXQ6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RvcEFuaW1hdGlvblwiLFxuICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogXCJ0cmFuc2NyaWJpbmdcIixcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgXCJzYXlwaTp0cmFuc2NyaWJlZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogXCJhY2N1bXVsYXRpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaGFuZGxlVHJhbnNjcmlwdGlvblJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlN1Y2Nlc3NmdWxseSB0cmFuc2NyaWJlZCB1c2VyIGF1ZGlvIHRvIHRleHQuXCIsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJzYXlwaTp0cmFuc2NyaWJlRmFpbGVkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNzYXlQaS5lcnJvcnMudHJhbnNjcmliZUZhaWxlZFwiLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIGVycm9yIHJlc3BvbnNlIGZyb20gdGhlIC90cmFuc2NyaWJlIEFQSVwiLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwic2F5cGk6dHJhbnNjcmliZWRFbXB0eVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogXCIjc2F5UGkuZXJyb3JzLm1pY0Vycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gZW1wdHkgcmVzcG9uc2UgZnJvbSB0aGUgL3RyYW5zY3JpYmUgQVBJIChubyBzcGVlY2ggZGV0ZWN0ZWQpXCIsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgXCJzYXlwaTpwaVNwZWFraW5nXCI6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCIjc2F5UGkucmVzcG9uZGluZy5waVNwZWFraW5nXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogXCJwYXJhbGxlbFwiLFxuICAgICAgfSxcbiAgICAgIHJlc3BvbmRpbmc6IHtcbiAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgXCJQaSBpcyByZXNwb25kaW5nLiBTeW50aGVzaXNlZCBzcGVlY2ggaXMgcGxheWluZyBvciB3YWl0aW5nIHRvIHBsYXkuXCIsXG4gICAgICAgIGVudHJ5OiB7XG4gICAgICAgICAgdHlwZTogXCJkaXNhYmxlQ2FsbEJ1dHRvblwiLFxuICAgICAgICB9LFxuICAgICAgICBleGl0OiB7XG4gICAgICAgICAgdHlwZTogXCJlbmFibGVDYWxsQnV0dG9uXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWw6IFwicGlTcGVha2luZ1wiLFxuICAgICAgICBzdGF0ZXM6IHtcbiAgICAgICAgICBwaVNwZWFraW5nOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICAgXCJQaSdzIHN5bnRoZXNpc2VkIHNwZWVjaCBhdWRpbyBpcyBwbGF5aW5nLlxcblBsYXlmdWwgYW5pbWF0aW9uLlwiLFxuICAgICAgICAgICAgZW50cnk6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzdGFydEFuaW1hdGlvblwiLFxuICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb246IFwicGlTcGVha2luZ1wiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4aXQ6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzdG9wQW5pbWF0aW9uXCIsXG4gICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogXCJwaVNwZWFraW5nXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgXCJzYXlwaTpwaVN0b3BwZWRTcGVha2luZ1wiOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNzYXlQaS5saXN0ZW5pbmdcIixcbiAgICAgICAgICAgICAgICAgIGNvbmQ6IFwid2FzTGlzdGVuaW5nXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiI3NheVBpLmluYWN0aXZlXCIsXG4gICAgICAgICAgICAgICAgICBjb25kOiBcIndhc0luYWN0aXZlXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXCJzYXlwaTp1c2VyU3BlYWtpbmdcIjoge1xuICAgICAgICAgICAgICAgIHRhcmdldDogXCIjc2F5UGkubGlzdGVuaW5nLnJlY29yZGluZy51c2VyU3BlYWtpbmdcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJzYXlwaTpwaUZpbmlzaGVkU3BlYWtpbmdcIjoge1xuICAgICAgICAgICAgICAgIHRhcmdldDogXCIjc2F5UGkubGlzdGVuaW5nXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgcHJlZGljdGFibGVBY3Rpb25Bcmd1bWVudHM6IHRydWUsXG4gICAgcHJlc2VydmVBY3Rpb25PcmRlcjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGFjdGlvbnM6IHtcbiAgICAgIHN0b3BBbGxBbmltYXRpb25zOiAoY29udGV4dCwgZXZlbnQpID0+IHtcbiAgICAgICAgQW5pbWF0aW9uTW9kdWxlLnN0b3BBbGxBbmltYXRpb25zKCk7XG4gICAgICB9LFxuXG4gICAgICBzdGFydEFuaW1hdGlvbjogKGNvbnRleHQsIGV2ZW50LCB7IGFjdGlvbiB9KSA9PiB7XG4gICAgICAgIEFuaW1hdGlvbk1vZHVsZS5zdGFydEFuaW1hdGlvbihhY3Rpb24ucGFyYW1zLmFuaW1hdGlvbik7XG4gICAgICB9LFxuXG4gICAgICBzdG9wQW5pbWF0aW9uOiAoY29udGV4dCwgZXZlbnQsIHsgYWN0aW9uIH0pID0+IHtcbiAgICAgICAgQW5pbWF0aW9uTW9kdWxlLnN0b3BBbmltYXRpb24oYWN0aW9uLnBhcmFtcy5hbmltYXRpb24pO1xuICAgICAgfSxcblxuICAgICAgdHJhbnNjcmliZUF1ZGlvOiAoXG4gICAgICAgIGNvbnRleHQ6IFNheVBpQ29udGV4dCxcbiAgICAgICAgZXZlbnQ6IFNheVBpU3BlZWNoU3RvcHBlZEV2ZW50XG4gICAgICApID0+IHtcbiAgICAgICAgY29uc3QgYXVkaW9CbG9iID0gZXZlbnQuYmxvYjtcbiAgICAgICAgaWYgKGF1ZGlvQmxvYikge1xuICAgICAgICAgIHVwbG9hZEF1ZGlvV2l0aFJldHJ5KFxuICAgICAgICAgICAgYXVkaW9CbG9iLFxuICAgICAgICAgICAgZXZlbnQuZHVyYXRpb24sXG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zY3JpcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgaGFuZGxlVHJhbnNjcmlwdGlvblJlc3BvbnNlOiAoXG4gICAgICAgIFNheVBpQ29udGV4dCxcbiAgICAgICAgZXZlbnQ6IFNheVBpVHJhbnNjcmliZWRFdmVudFxuICAgICAgKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiaGFuZGxlVHJhbnNjcmlwdGlvblJlc3BvbnNlXCIsIGV2ZW50KTtcbiAgICAgICAgY29uc3QgdHJhbnNjcmlwdGlvbiA9IGV2ZW50LnRleHQ7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyID0gZXZlbnQuc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgIFNheVBpQ29udGV4dC50cmFuc2NyaXB0aW9uc1tzZXF1ZW5jZU51bWJlcl0gPSB0cmFuc2NyaXB0aW9uO1xuICAgICAgfSxcblxuICAgICAgYWNxdWlyZU1pY3JvcGhvbmU6IChjb250ZXh0LCBldmVudCkgPT4ge1xuICAgICAgICAvLyB3YXJtdXAgdGhlIG1pY3JvcGhvbmUgb24gaWRsZSBpbiBtb2JpbGUgdmlldyxcbiAgICAgICAgLy8gc2luY2UgdGhlcmUncyBubyBtb3VzZW92ZXIgZXZlbnQgdG8gdHJpZ2dlciBpdFxuICAgICAgICBpZiAoaXNNb2JpbGVWaWV3KCkpIHtcbiAgICAgICAgICBFdmVudEJ1cy5lbWl0KFwiYXVkaW86c2V0dXBSZWNvcmRpbmdcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHN0YXJ0UmVjb3JkaW5nOiAoY29udGV4dCwgZXZlbnQpID0+IHtcbiAgICAgICAgRXZlbnRCdXMuZW1pdChcImF1ZGlvOnN0YXJ0UmVjb3JkaW5nXCIpO1xuICAgICAgfSxcblxuICAgICAgc3RvcFJlY29yZGluZzogKGNvbnRleHQsIGV2ZW50KSA9PiB7XG4gICAgICAgIEV2ZW50QnVzLmVtaXQoXCJhdWRpbzpzdG9wUmVjb3JkaW5nXCIpO1xuICAgICAgfSxcblxuICAgICAgc2hvd05vdGlmaWNhdGlvbjogKGNvbnRleHQsIGV2ZW50LCB7IGFjdGlvbiB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGljb24gPSBhY3Rpb24ucGFyYW1zLmljb247XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhY3Rpb24ucGFyYW1zLm1lc3NhZ2U7XG4gICAgICAgIGJ1dHRvbk1vZHVsZS5zaG93Tm90aWZpY2F0aW9uKHsgaWNvbiwgbWVzc2FnZSB9KTtcbiAgICAgIH0sXG5cbiAgICAgIGRpc21pc3NOb3RpZmljYXRpb246ICgpID0+IHtcbiAgICAgICAgYnV0dG9uTW9kdWxlLmRpc21pc3NOb3RpZmljYXRpb24oKTtcbiAgICAgIH0sXG5cbiAgICAgIG1lcmdlQW5kU3VibWl0VHJhbnNjcmlwdDogKGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgcHJvbXB0ID0gbWVyZ2VUcmFuc2NyaXB0cyhjb250ZXh0LnRyYW5zY3JpcHRpb25zKS50cmltKCk7XG4gICAgICAgIGlmIChwcm9tcHQpIHNldFByb21wdFRleHQocHJvbXB0KTtcbiAgICAgIH0sXG5cbiAgICAgIGNhbGxTdGFydGVkOiAoKSA9PiB7XG4gICAgICAgIGJ1dHRvbk1vZHVsZS5jYWxsQWN0aXZlKCk7XG4gICAgICB9LFxuICAgICAgY2FsbEVuZGVkOiAoKSA9PiB7XG4gICAgICAgIGJ1dHRvbk1vZHVsZS5jYWxsSW5hY3RpdmUoKTtcbiAgICAgIH0sXG4gICAgICBkaXNhYmxlQ2FsbEJ1dHRvbjogKCkgPT4ge1xuICAgICAgICBidXR0b25Nb2R1bGUuZGlzYWJsZUNhbGxCdXR0b24oKTtcbiAgICAgIH0sXG4gICAgICBlbmFibGVDYWxsQnV0dG9uOiAoKSA9PiB7XG4gICAgICAgIGJ1dHRvbk1vZHVsZS5lbmFibGVDYWxsQnV0dG9uKCk7XG4gICAgICB9LFxuICAgIH0sXG4gICAgc2VydmljZXM6IHt9LFxuICAgIGd1YXJkczoge1xuICAgICAgaGFzQXVkaW86IChjb250ZXh0OiBTYXlQaUNvbnRleHQsIGV2ZW50OiBTYXlQaUV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBcInNheXBpOnVzZXJTdG9wcGVkU3BlYWtpbmdcIikge1xuICAgICAgICAgIGV2ZW50ID0gZXZlbnQgYXMgU2F5UGlTcGVlY2hTdG9wcGVkRXZlbnQ7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50LmJsb2IgIT09IHVuZGVmaW5lZCAmJiBldmVudC5kdXJhdGlvbiA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGhhc05vQXVkaW86IChjb250ZXh0OiBTYXlQaUNvbnRleHQsIGV2ZW50OiBTYXlQaUV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBcInNheXBpOnVzZXJTdG9wcGVkU3BlYWtpbmdcIikge1xuICAgICAgICAgIGV2ZW50ID0gZXZlbnQgYXMgU2F5UGlTcGVlY2hTdG9wcGVkRXZlbnQ7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGV2ZW50LmJsb2IgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgZXZlbnQuYmxvYi5zaXplID09PSAwIHx8XG4gICAgICAgICAgICBldmVudC5kdXJhdGlvbiA9PT0gMFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHN1Ym1pc3Npb25Db25kaXRpb25zTWV0OiAoXG4gICAgICAgIGNvbnRleHQ6IFNheVBpQ29udGV4dCxcbiAgICAgICAgZXZlbnQ6IFNheVBpRXZlbnQsXG4gICAgICAgIG1ldGFcbiAgICAgICkgPT4ge1xuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSBtZXRhO1xuICAgICAgICBjb25zdCBhbGxvd2VkU3RhdGUgPSAhKFxuICAgICAgICAgIHN0YXRlLm1hdGNoZXMoXCJsaXN0ZW5pbmcucmVjb3JkaW5nLnVzZXJTcGVha2luZ1wiKSB8fFxuICAgICAgICAgIHN0YXRlLm1hdGNoZXMoXCJsaXN0ZW5pbmcuY29udmVydGluZy50cmFuc2NyaWJpbmdcIilcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgZW1wdHkgPSBPYmplY3Qua2V5cyhjb250ZXh0LnRyYW5zY3JpcHRpb25zKS5sZW5ndGggPT09IDA7XG4gICAgICAgIGNvbnN0IHBlbmRpbmcgPSBpc1RyYW5zY3JpcHRpb25QZW5kaW5nKCk7XG4gICAgICAgIGNvbnN0IHJlYWR5ID0gYWxsb3dlZFN0YXRlICYmICFlbXB0eSAmJiAhcGVuZGluZztcbiAgICAgICAgcmV0dXJuIHJlYWR5O1xuICAgICAgfSxcbiAgICAgIHdhc0xpc3RlbmluZzogKGNvbnRleHQ6IFNheVBpQ29udGV4dCkgPT4ge1xuICAgICAgICByZXR1cm4gY29udGV4dC5sYXN0U3RhdGUgPT09IFwibGlzdGVuaW5nXCI7XG4gICAgICB9LFxuICAgICAgd2FzSW5hY3RpdmU6IChjb250ZXh0OiBTYXlQaUNvbnRleHQpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQubGFzdFN0YXRlID09PSBcImluYWN0aXZlXCI7XG4gICAgICB9LFxuICAgIH0sXG4gICAgZGVsYXlzOiB7XG4gICAgICBzdWJtaXNzaW9uRGVsYXk6IChjb250ZXh0OiBTYXlQaUNvbnRleHQsIGV2ZW50OiBTYXlQaUV2ZW50KSA9PiB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBldmVudCBpcyBhIHRyYW5zY3JpcHRpb24gZXZlbnRcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgIT09IFwic2F5cGk6dHJhbnNjcmliZWRcIikge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV2ZW50ID0gZXZlbnQgYXMgU2F5UGlUcmFuc2NyaWJlZEV2ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWF4RGVsYXkgPSAxMDAwMDsgLy8gMTAgc2Vjb25kcyBpbiBtaWxsaXNlY29uZHNcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGluaXRpYWwgZGVsYXkgYmFzZWQgb24gcEZpbmlzaGVkU3BlYWtpbmdcbiAgICAgICAgbGV0IHByb2JhYmlsaXR5RmluaXNoZWQgPSAxO1xuICAgICAgICBpZiAoZXZlbnQucEZpbmlzaGVkU3BlYWtpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb2JhYmlsaXR5RmluaXNoZWQgPSBldmVudC5wRmluaXNoZWRTcGVha2luZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluY29ycG9yYXRlIHRoZSB0ZW1wbyBpbnRvIHRoZSBkZWxheSwgZGVmYXVsdGluZyB0byAwLjUgKGF2ZXJhZ2UgdGVtcG8pIGlmIHVuZGVmaW5lZFxuICAgICAgICBsZXQgdGVtcG8gPSBldmVudC50ZW1wbyAhPT0gdW5kZWZpbmVkID8gZXZlbnQudGVtcG8gOiAwLjU7XG5cbiAgICAgICAgY29uc3QgZmluYWxEZWxheSA9IGNhbGN1bGF0ZURlbGF5KFxuICAgICAgICAgIGNvbnRleHQudGltZVVzZXJTdG9wcGVkU3BlYWtpbmcsXG4gICAgICAgICAgcHJvYmFiaWxpdHlGaW5pc2hlZCxcbiAgICAgICAgICB0ZW1wbyxcbiAgICAgICAgICBtYXhEZWxheVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIFwiV2FpdGluZyBmb3JcIixcbiAgICAgICAgICAoZmluYWxEZWxheSAvIDEwMDApLnRvRml4ZWQoMSksXG4gICAgICAgICAgXCJzZWNvbmRzIGJlZm9yZSBzdWJtaXR0aW5nXCJcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gZmluYWxEZWxheTtcbiAgICAgIH0sXG4gICAgfSxcbiAgfVxuKTtcbiIsImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAnLi9fdmlydHVhbC9fdHNsaWIuanMnO1xuaW1wb3J0IHsgc3ltYm9sT2JzZXJ2YWJsZSwgdG9JbnZva2VTb3VyY2UsIG1hcENvbnRleHQsIGlzTWFjaGluZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgcHJvdmlkZSB9IGZyb20gJy4vc2VydmljZVNjb3BlLmpzJztcblxuZnVuY3Rpb24gY3JlYXRlTnVsbEFjdG9yKGlkKSB7XG4gIHZhciBfYTtcblxuICByZXR1cm4gX2EgPSB7XG4gICAgaWQ6IGlkLFxuICAgIHNlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfSxcbiAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFNuYXBzaG90OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogaWRcbiAgICAgIH07XG4gICAgfVxuICB9LCBfYVtzeW1ib2xPYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSwgX2E7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIGRlZmVycmVkIGFjdG9yIHRoYXQgaXMgYWJsZSB0byBiZSBpbnZva2VkIGdpdmVuIHRoZSBwcm92aWRlZFxyXG4gKiBpbnZvY2F0aW9uIGluZm9ybWF0aW9uIGluIGl0cyBgLm1ldGFgIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0gaW52b2tlRGVmaW5pdGlvbiBUaGUgbWV0YSBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gaW52b2tlIHRoZSBhY3Rvci5cclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUludm9jYWJsZUFjdG9yKGludm9rZURlZmluaXRpb24sIG1hY2hpbmUsIGNvbnRleHQsIF9ldmVudCkge1xuICB2YXIgX2E7XG5cbiAgdmFyIGludm9rZVNyYyA9IHRvSW52b2tlU291cmNlKGludm9rZURlZmluaXRpb24uc3JjKTtcbiAgdmFyIHNlcnZpY2VDcmVhdG9yID0gKF9hID0gbWFjaGluZSA9PT0gbnVsbCB8fCBtYWNoaW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYWNoaW5lLm9wdGlvbnMuc2VydmljZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtpbnZva2VTcmMudHlwZV07XG4gIHZhciByZXNvbHZlZERhdGEgPSBpbnZva2VEZWZpbml0aW9uLmRhdGEgPyBtYXBDb250ZXh0KGludm9rZURlZmluaXRpb24uZGF0YSwgY29udGV4dCwgX2V2ZW50KSA6IHVuZGVmaW5lZDtcbiAgdmFyIHRlbXBBY3RvciA9IHNlcnZpY2VDcmVhdG9yID8gY3JlYXRlRGVmZXJyZWRBY3RvcihzZXJ2aWNlQ3JlYXRvciwgaW52b2tlRGVmaW5pdGlvbi5pZCwgcmVzb2x2ZWREYXRhKSA6IGNyZWF0ZU51bGxBY3RvcihpbnZva2VEZWZpbml0aW9uLmlkKTsgLy8gQHRzLWlnbm9yZVxuXG4gIHRlbXBBY3Rvci5tZXRhID0gaW52b2tlRGVmaW5pdGlvbjtcbiAgcmV0dXJuIHRlbXBBY3Rvcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkQWN0b3IoZW50aXR5LCBpZCwgZGF0YSkge1xuICB2YXIgdGVtcEFjdG9yID0gY3JlYXRlTnVsbEFjdG9yKGlkKTsgLy8gQHRzLWlnbm9yZVxuXG4gIHRlbXBBY3Rvci5kZWZlcnJlZCA9IHRydWU7XG5cbiAgaWYgKGlzTWFjaGluZShlbnRpdHkpKSB7XG4gICAgLy8gXCJtdXRlXCIgdGhlIGV4aXN0aW5nIHNlcnZpY2Ugc2NvcGUgc28gcG90ZW50aWFsIHNwYXduZWQgYWN0b3JzIHdpdGhpbiB0aGUgYC5pbml0aWFsU3RhdGVgIHN0YXkgZGVmZXJyZWQgaGVyZVxuICAgIHZhciBpbml0aWFsU3RhdGVfMSA9IHRlbXBBY3Rvci5zdGF0ZSA9IHByb3ZpZGUodW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKGRhdGEgPyBlbnRpdHkud2l0aENvbnRleHQoZGF0YSkgOiBlbnRpdHkpLmluaXRpYWxTdGF0ZTtcbiAgICB9KTtcblxuICAgIHRlbXBBY3Rvci5nZXRTbmFwc2hvdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbml0aWFsU3RhdGVfMTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRlbXBBY3Rvcjtcbn1cbmZ1bmN0aW9uIGlzQWN0b3IoaXRlbSkge1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgaXRlbS5zZW5kID09PSAnZnVuY3Rpb24nO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc1NwYXduZWRBY3RvcihpdGVtKSB7XG4gIHJldHVybiBpc0FjdG9yKGl0ZW0pICYmICdpZCcgaW4gaXRlbTtcbn0gLy8gVE9ETzogcmVmYWN0b3IgdGhlIHJldHVybiB0eXBlLCB0aGlzIGNvdWxkIGJlIHdyaXR0ZW4gaW4gYSBiZXR0ZXIgd2F5IGJ1dCBpdCdzIGJlc3QgdG8gYXZvaWQgdW5uZWNjZXNzYXJ5IGJyZWFraW5nIGNoYW5nZXMgbm93XG5cbmZ1bmN0aW9uIHRvQWN0b3JSZWYoYWN0b3JSZWZMaWtlKSB7XG4gIHZhciBfYTtcblxuICByZXR1cm4gX19hc3NpZ24oKF9hID0ge1xuICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgaWQ6ICdhbm9ueW1vdXMnLFxuICAgIGdldFNuYXBzaG90OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSwgX2Fbc3ltYm9sT2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sIF9hKSwgYWN0b3JSZWZMaWtlKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRGVmZXJyZWRBY3RvciwgY3JlYXRlSW52b2NhYmxlQWN0b3IsIGNyZWF0ZU51bGxBY3RvciwgaXNBY3RvciwgaXNTcGF3bmVkQWN0b3IsIHRvQWN0b3JSZWYgfTtcbiIsImltcG9ydCB7IFN0YXRlTm9kZSB9IGZyb20gJy4vU3RhdGVOb2RlLmpzJztcbmltcG9ydCB7IElTX1BST0RVQ1RJT04gfSBmcm9tICcuL2Vudmlyb25tZW50LmpzJztcblxudmFyIHdhcm5lZCA9IGZhbHNlO1xuZnVuY3Rpb24gTWFjaGluZShjb25maWcsIG9wdGlvbnMsIGluaXRpYWxDb250ZXh0KSB7XG4gIGlmIChpbml0aWFsQ29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgaW5pdGlhbENvbnRleHQgPSBjb25maWcuY29udGV4dDtcbiAgfVxuXG4gIHJldHVybiBuZXcgU3RhdGVOb2RlKGNvbmZpZywgb3B0aW9ucywgaW5pdGlhbENvbnRleHQpO1xufVxuZnVuY3Rpb24gY3JlYXRlTWFjaGluZShjb25maWcsIG9wdGlvbnMpIHtcbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmICEoJ3ByZWRpY3RhYmxlQWN0aW9uQXJndW1lbnRzJyBpbiBjb25maWcpICYmICF3YXJuZWQpIHtcbiAgICB3YXJuZWQgPSB0cnVlO1xuICAgIGNvbnNvbGUud2FybignSXQgaXMgaGlnaGx5IHJlY29tbWVuZGVkIHRvIHNldCBgcHJlZGljdGFibGVBY3Rpb25Bcmd1bWVudHNgIHRvIGB0cnVlYCB3aGVuIHVzaW5nIGBjcmVhdGVNYWNoaW5lYC4gaHR0cHM6Ly94c3RhdGUuanMub3JnL2RvY3MvZ3VpZGVzL2FjdGlvbnMuaHRtbCcpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTdGF0ZU5vZGUoY29uZmlnLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IHsgTWFjaGluZSwgY3JlYXRlTWFjaGluZSB9O1xuIiwiaW1wb3J0IHsgX19hc3NpZ24sIF9fc3ByZWFkQXJyYXksIF9fcmVhZCwgX19yZXN0IH0gZnJvbSAnLi9fdmlydHVhbC9fdHNsaWIuanMnO1xuaW1wb3J0IHsgRU1QVFlfQUNUSVZJVFlfTUFQIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgaXNTdHJpbmcsIG1hdGNoZXNTdGF0ZSwgd2FybiB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgZ2V0TWV0YSwgbmV4dEV2ZW50cyB9IGZyb20gJy4vc3RhdGVVdGlscy5qcyc7XG5pbXBvcnQgeyBpbml0RXZlbnQgfSBmcm9tICcuL2FjdGlvbnMuanMnO1xuaW1wb3J0IHsgSVNfUFJPRFVDVElPTiB9IGZyb20gJy4vZW52aXJvbm1lbnQuanMnO1xuXG5mdW5jdGlvbiBzdGF0ZVZhbHVlc0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nKGEpIHx8IGlzU3RyaW5nKGIpKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cblxuICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gIHJldHVybiBhS2V5cy5sZW5ndGggPT09IGJLZXlzLmxlbmd0aCAmJiBhS2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHN0YXRlVmFsdWVzRXF1YWwoYVtrZXldLCBiW2tleV0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzU3RhdGVDb25maWcoc3RhdGUpIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZSAhPT0gJ29iamVjdCcgfHwgc3RhdGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gJ3ZhbHVlJyBpbiBzdGF0ZSAmJiAnX2V2ZW50JyBpbiBzdGF0ZTtcbn1cbi8qKlxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGlzU3RhdGVDb25maWcob2JqZWN0KWAgb3IgYHN0YXRlIGluc3RhbmNlb2YgU3RhdGVgIGluc3RlYWQuXHJcbiAqL1xuXG52YXIgaXNTdGF0ZSA9IGlzU3RhdGVDb25maWc7XG5mdW5jdGlvbiBiaW5kQWN0aW9uVG9TdGF0ZShhY3Rpb24sIHN0YXRlKSB7XG4gIHZhciBleGVjID0gYWN0aW9uLmV4ZWM7XG5cbiAgdmFyIGJvdW5kQWN0aW9uID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGFjdGlvbiksIHtcbiAgICBleGVjOiBleGVjICE9PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZXhlYyhzdGF0ZS5jb250ZXh0LCBzdGF0ZS5ldmVudCwge1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICBfZXZlbnQ6IHN0YXRlLl9ldmVudFxuICAgICAgfSk7XG4gICAgfSA6IHVuZGVmaW5lZFxuICB9KTtcblxuICByZXR1cm4gYm91bmRBY3Rpb247XG59XG5cbnZhciBTdGF0ZSA9XG4vKiNfX1BVUkVfXyovXG5cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBTdGF0ZSBpbnN0YW5jZS5cclxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHN0YXRlIHZhbHVlXHJcbiAgICogQHBhcmFtIGNvbnRleHQgVGhlIGV4dGVuZGVkIHN0YXRlXHJcbiAgICogQHBhcmFtIGhpc3RvcnlWYWx1ZSBUaGUgdHJlZSByZXByZXNlbnRpbmcgaGlzdG9yaWNhbCB2YWx1ZXMgb2YgdGhlIHN0YXRlIG5vZGVzXHJcbiAgICogQHBhcmFtIGhpc3RvcnkgVGhlIHByZXZpb3VzIHN0YXRlXHJcbiAgICogQHBhcmFtIGFjdGlvbnMgQW4gYXJyYXkgb2YgYWN0aW9uIG9iamVjdHMgdG8gZXhlY3V0ZSBhcyBzaWRlLWVmZmVjdHNcclxuICAgKiBAcGFyYW0gYWN0aXZpdGllcyBBIG1hcHBpbmcgb2YgYWN0aXZpdGllcyBhbmQgd2hldGhlciB0aGV5IGFyZSBzdGFydGVkIChgdHJ1ZWApIG9yIHN0b3BwZWQgKGBmYWxzZWApLlxyXG4gICAqIEBwYXJhbSBtZXRhXHJcbiAgICogQHBhcmFtIGV2ZW50cyBJbnRlcm5hbCBldmVudCBxdWV1ZS4gU2hvdWxkIGJlIGVtcHR5IHdpdGggcnVuLXRvLWNvbXBsZXRpb24gc2VtYW50aWNzLlxyXG4gICAqIEBwYXJhbSBjb25maWd1cmF0aW9uXHJcbiAgICovXG4gIGZ1bmN0aW9uIFN0YXRlKGNvbmZpZykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX2E7XG5cbiAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICB0aGlzLmFjdGl2aXRpZXMgPSBFTVBUWV9BQ1RJVklUWV9NQVA7XG4gICAgdGhpcy5tZXRhID0ge307XG4gICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICB0aGlzLnZhbHVlID0gY29uZmlnLnZhbHVlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbmZpZy5jb250ZXh0O1xuICAgIHRoaXMuX2V2ZW50ID0gY29uZmlnLl9ldmVudDtcbiAgICB0aGlzLl9zZXNzaW9uaWQgPSBjb25maWcuX3Nlc3Npb25pZDtcbiAgICB0aGlzLmV2ZW50ID0gdGhpcy5fZXZlbnQuZGF0YTtcbiAgICB0aGlzLmhpc3RvcnlWYWx1ZSA9IGNvbmZpZy5oaXN0b3J5VmFsdWU7XG4gICAgdGhpcy5oaXN0b3J5ID0gY29uZmlnLmhpc3Rvcnk7XG4gICAgdGhpcy5hY3Rpb25zID0gY29uZmlnLmFjdGlvbnMgfHwgW107XG4gICAgdGhpcy5hY3Rpdml0aWVzID0gY29uZmlnLmFjdGl2aXRpZXMgfHwgRU1QVFlfQUNUSVZJVFlfTUFQO1xuICAgIHRoaXMubWV0YSA9IGdldE1ldGEoY29uZmlnLmNvbmZpZ3VyYXRpb24pO1xuICAgIHRoaXMuZXZlbnRzID0gY29uZmlnLmV2ZW50cyB8fCBbXTtcbiAgICB0aGlzLm1hdGNoZXMgPSB0aGlzLm1hdGNoZXMuYmluZCh0aGlzKTtcbiAgICB0aGlzLnRvU3RyaW5ncyA9IHRoaXMudG9TdHJpbmdzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlnLmNvbmZpZ3VyYXRpb247XG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IGNvbmZpZy50cmFuc2l0aW9ucztcbiAgICB0aGlzLmNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuICAgIHRoaXMuZG9uZSA9ICEhY29uZmlnLmRvbmU7XG4gICAgdGhpcy50YWdzID0gKF9hID0gQXJyYXkuaXNBcnJheShjb25maWcudGFncykgPyBuZXcgU2V0KGNvbmZpZy50YWdzKSA6IGNvbmZpZy50YWdzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgU2V0KCk7XG4gICAgdGhpcy5tYWNoaW5lID0gY29uZmlnLm1hY2hpbmU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduZXh0RXZlbnRzJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXh0RXZlbnRzKF90aGlzLmNvbmZpZ3VyYXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgU3RhdGUgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBgc3RhdGVWYWx1ZWAgYW5kIGBjb250ZXh0YC5cclxuICAgKiBAcGFyYW0gc3RhdGVWYWx1ZVxyXG4gICAqIEBwYXJhbSBjb250ZXh0XHJcbiAgICovXG5cblxuICBTdGF0ZS5mcm9tID0gZnVuY3Rpb24gKHN0YXRlVmFsdWUsIGNvbnRleHQpIHtcbiAgICBpZiAoc3RhdGVWYWx1ZSBpbnN0YW5jZW9mIFN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGVWYWx1ZS5jb250ZXh0ICE9PSBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdGUoe1xuICAgICAgICAgIHZhbHVlOiBzdGF0ZVZhbHVlLnZhbHVlLFxuICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgX2V2ZW50OiBzdGF0ZVZhbHVlLl9ldmVudCxcbiAgICAgICAgICBfc2Vzc2lvbmlkOiBudWxsLFxuICAgICAgICAgIGhpc3RvcnlWYWx1ZTogc3RhdGVWYWx1ZS5oaXN0b3J5VmFsdWUsXG4gICAgICAgICAgaGlzdG9yeTogc3RhdGVWYWx1ZS5oaXN0b3J5LFxuICAgICAgICAgIGFjdGlvbnM6IFtdLFxuICAgICAgICAgIGFjdGl2aXRpZXM6IHN0YXRlVmFsdWUuYWN0aXZpdGllcyxcbiAgICAgICAgICBtZXRhOiB7fSxcbiAgICAgICAgICBldmVudHM6IFtdLFxuICAgICAgICAgIGNvbmZpZ3VyYXRpb246IFtdLFxuICAgICAgICAgIHRyYW5zaXRpb25zOiBbXSxcbiAgICAgICAgICBjaGlsZHJlbjoge31cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGF0ZVZhbHVlO1xuICAgIH1cblxuICAgIHZhciBfZXZlbnQgPSBpbml0RXZlbnQ7XG4gICAgcmV0dXJuIG5ldyBTdGF0ZSh7XG4gICAgICB2YWx1ZTogc3RhdGVWYWx1ZSxcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfZXZlbnQ6IF9ldmVudCxcbiAgICAgIF9zZXNzaW9uaWQ6IG51bGwsXG4gICAgICBoaXN0b3J5VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGhpc3Rvcnk6IHVuZGVmaW5lZCxcbiAgICAgIGFjdGlvbnM6IFtdLFxuICAgICAgYWN0aXZpdGllczogdW5kZWZpbmVkLFxuICAgICAgbWV0YTogdW5kZWZpbmVkLFxuICAgICAgZXZlbnRzOiBbXSxcbiAgICAgIGNvbmZpZ3VyYXRpb246IFtdLFxuICAgICAgdHJhbnNpdGlvbnM6IFtdLFxuICAgICAgY2hpbGRyZW46IHt9XG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgU3RhdGUgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBgY29uZmlnYC5cclxuICAgKiBAcGFyYW0gY29uZmlnIFRoZSBzdGF0ZSBjb25maWdcclxuICAgKi9cblxuXG4gIFN0YXRlLmNyZWF0ZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICByZXR1cm4gbmV3IFN0YXRlKGNvbmZpZyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgYFN0YXRlYCBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIGBzdGF0ZVZhbHVlYCBhbmQgYGNvbnRleHRgIHdpdGggbm8gYWN0aW9ucyAoc2lkZS1lZmZlY3RzKS5cclxuICAgKiBAcGFyYW0gc3RhdGVWYWx1ZVxyXG4gICAqIEBwYXJhbSBjb250ZXh0XHJcbiAgICovXG5cblxuICBTdGF0ZS5pbmVydCA9IGZ1bmN0aW9uIChzdGF0ZVZhbHVlLCBjb250ZXh0KSB7XG4gICAgaWYgKHN0YXRlVmFsdWUgaW5zdGFuY2VvZiBTdGF0ZSkge1xuICAgICAgaWYgKCFzdGF0ZVZhbHVlLmFjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZVZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2V2ZW50ID0gaW5pdEV2ZW50O1xuICAgICAgcmV0dXJuIG5ldyBTdGF0ZSh7XG4gICAgICAgIHZhbHVlOiBzdGF0ZVZhbHVlLnZhbHVlLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICBfZXZlbnQ6IF9ldmVudCxcbiAgICAgICAgX3Nlc3Npb25pZDogbnVsbCxcbiAgICAgICAgaGlzdG9yeVZhbHVlOiBzdGF0ZVZhbHVlLmhpc3RvcnlWYWx1ZSxcbiAgICAgICAgaGlzdG9yeTogc3RhdGVWYWx1ZS5oaXN0b3J5LFxuICAgICAgICBhY3Rpdml0aWVzOiBzdGF0ZVZhbHVlLmFjdGl2aXRpZXMsXG4gICAgICAgIGNvbmZpZ3VyYXRpb246IHN0YXRlVmFsdWUuY29uZmlndXJhdGlvbixcbiAgICAgICAgdHJhbnNpdGlvbnM6IFtdLFxuICAgICAgICBjaGlsZHJlbjoge31cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBTdGF0ZS5mcm9tKHN0YXRlVmFsdWUsIGNvbnRleHQpO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgc3RyaW5nIGxlYWYgc3RhdGUgbm9kZSBwYXRocy5cclxuICAgKiBAcGFyYW0gc3RhdGVWYWx1ZVxyXG4gICAqIEBwYXJhbSBkZWxpbWl0ZXIgVGhlIGNoYXJhY3RlcihzKSB0aGF0IHNlcGFyYXRlIGVhY2ggc3VicGF0aCBpbiB0aGUgc3RyaW5nIHN0YXRlIG5vZGUgcGF0aC5cclxuICAgKi9cblxuXG4gIFN0YXRlLnByb3RvdHlwZS50b1N0cmluZ3MgPSBmdW5jdGlvbiAoc3RhdGVWYWx1ZSwgZGVsaW1pdGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChzdGF0ZVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHN0YXRlVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChkZWxpbWl0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgZGVsaW1pdGVyID0gJy4nO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyhzdGF0ZVZhbHVlKSkge1xuICAgICAgcmV0dXJuIFtzdGF0ZVZhbHVlXTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVLZXlzID0gT2JqZWN0LmtleXMoc3RhdGVWYWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlS2V5cy5jb25jYXQuYXBwbHkodmFsdWVLZXlzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQodmFsdWVLZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gX3RoaXMudG9TdHJpbmdzKHN0YXRlVmFsdWVba2V5XSwgZGVsaW1pdGVyKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIGtleSArIGRlbGltaXRlciArIHM7XG4gICAgICB9KTtcbiAgICB9KSksIGZhbHNlKSk7XG4gIH07XG5cbiAgU3RhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EgPSB0aGlzO1xuICAgICAgICBfYS5jb25maWd1cmF0aW9uO1xuICAgICAgICBfYS50cmFuc2l0aW9ucztcbiAgICAgICAgdmFyIHRhZ3MgPSBfYS50YWdzO1xuICAgICAgICBfYS5tYWNoaW5lO1xuICAgICAgICB2YXIganNvblZhbHVlcyA9IF9fcmVzdChfYSwgW1wiY29uZmlndXJhdGlvblwiLCBcInRyYW5zaXRpb25zXCIsIFwidGFnc1wiLCBcIm1hY2hpbmVcIl0pO1xuXG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBqc29uVmFsdWVzKSwge1xuICAgICAgdGFnczogQXJyYXkuZnJvbSh0YWdzKVxuICAgIH0pO1xuICB9O1xuXG4gIFN0YXRlLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKHBhcmVudFN0YXRlVmFsdWUpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0YXRlKHBhcmVudFN0YXRlVmFsdWUsIHRoaXMudmFsdWUpO1xuICB9O1xuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBjdXJyZW50IHN0YXRlIGNvbmZpZ3VyYXRpb24gaGFzIGEgc3RhdGUgbm9kZSB3aXRoIHRoZSBzcGVjaWZpZWQgYHRhZ2AuXHJcbiAgICogQHBhcmFtIHRhZ1xyXG4gICAqL1xuXG5cbiAgU3RhdGUucHJvdG90eXBlLmhhc1RhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmhhcyh0YWcpO1xuICB9O1xuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgc2VuZGluZyB0aGUgYGV2ZW50YCB3aWxsIGNhdXNlIGEgbm9uLWZvcmJpZGRlbiB0cmFuc2l0aW9uXHJcbiAgICogdG8gYmUgc2VsZWN0ZWQsIGV2ZW4gaWYgdGhlIHRyYW5zaXRpb25zIGhhdmUgbm8gYWN0aW9ucyBub3JcclxuICAgKiBjaGFuZ2UgdGhlIHN0YXRlIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byB0ZXN0XHJcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgZXZlbnQgd2lsbCBjYXVzZSBhIHRyYW5zaXRpb25cclxuICAgKi9cblxuXG4gIFN0YXRlLnByb3RvdHlwZS5jYW4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX2E7XG5cbiAgICBpZiAoSVNfUFJPRFVDVElPTikge1xuICAgICAgd2FybighIXRoaXMubWFjaGluZSwgXCJzdGF0ZS5jYW4oLi4uKSB1c2VkIG91dHNpZGUgb2YgYSBtYWNoaW5lLWNyZWF0ZWQgU3RhdGUgb2JqZWN0OyB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZS5cIik7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gKF9hID0gdGhpcy5tYWNoaW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0VHJhbnNpdGlvbkRhdGEodGhpcywgZXZlbnQpO1xuICAgIHJldHVybiAhISh0cmFuc2l0aW9uRGF0YSA9PT0gbnVsbCB8fCB0cmFuc2l0aW9uRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhbnNpdGlvbkRhdGEudHJhbnNpdGlvbnMubGVuZ3RoKSAmJiAvLyBDaGVjayB0aGF0IGF0IGxlYXN0IG9uZSB0cmFuc2l0aW9uIGlzIG5vdCBmb3JiaWRkZW5cbiAgICB0cmFuc2l0aW9uRGF0YS50cmFuc2l0aW9ucy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdC50YXJnZXQgIT09IHVuZGVmaW5lZCB8fCB0LmFjdGlvbnMubGVuZ3RoO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBTdGF0ZTtcbn0oKTtcblxuZXhwb3J0IHsgU3RhdGUsIGJpbmRBY3Rpb25Ub1N0YXRlLCBpc1N0YXRlLCBpc1N0YXRlQ29uZmlnLCBzdGF0ZVZhbHVlc0VxdWFsIH07XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiwgX19zcHJlYWRBcnJheSwgX19yZWFkLCBfX3ZhbHVlcywgX19yZXN0IH0gZnJvbSAnLi9fdmlydHVhbC9fdHNsaWIuanMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiwgbWFwVmFsdWVzLCBpc0FycmF5LCBmbGF0dGVuLCB0b0FycmF5LCB0b1N0YXRlVmFsdWUsIGlzU3RyaW5nLCBnZXRFdmVudFR5cGUsIHRvU0NYTUxFdmVudCwgbWF0Y2hlc1N0YXRlLCBwYXRoLCBldmFsdWF0ZUd1YXJkLCBtYXBDb250ZXh0LCBpc1JhaXNhYmxlQWN0aW9uLCBwYXRoVG9TdGF0ZVZhbHVlLCBpc0J1aWx0SW5FdmVudCwgcGFydGl0aW9uLCB1cGRhdGVIaXN0b3J5VmFsdWUsIHRvU3RhdGVQYXRoLCBtYXBGaWx0ZXJWYWx1ZXMsIHdhcm4sIHRvU3RhdGVQYXRocywgbmVzdGVkUGF0aCwgbm9ybWFsaXplVGFyZ2V0LCB0b0d1YXJkLCB0b1RyYW5zaXRpb25Db25maWdBcnJheSwgaXNNYWNoaW5lLCBjcmVhdGVJbnZva2VJZCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgU3RhdGUsIHN0YXRlVmFsdWVzRXF1YWwgfSBmcm9tICcuL1N0YXRlLmpzJztcbmltcG9ydCB7IHN0YXJ0IGFzIHN0YXJ0JDEsIHN0b3AgYXMgc3RvcCQxLCBpbnZva2UsIHVwZGF0ZSwgbnVsbEV2ZW50IH0gZnJvbSAnLi9hY3Rpb25UeXBlcy5qcyc7XG5pbXBvcnQgeyBkb25lLCBzdGFydCwgdG9BY3Rpb25PYmplY3RzLCByYWlzZSwgc3RvcCwgcmVzb2x2ZUFjdGlvbnMsIGRvbmVJbnZva2UsIGVycm9yLCB0b0FjdGlvbk9iamVjdCwgdG9BY3Rpdml0eURlZmluaXRpb24sIGFmdGVyLCBzZW5kLCBjYW5jZWwsIGluaXRFdmVudCB9IGZyb20gJy4vYWN0aW9ucy5qcyc7XG5pbXBvcnQgeyBJU19QUk9EVUNUSU9OIH0gZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5pbXBvcnQgeyBTVEFURV9ERUxJTUlURVIgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBnZXRBbGxTdGF0ZU5vZGVzLCBnZXRDb25maWd1cmF0aW9uLCBpc0luRmluYWxTdGF0ZSwgZ2V0VGFnc0Zyb21Db25maWd1cmF0aW9uLCBoYXMsIGdldENoaWxkcmVuLCBnZXRWYWx1ZSwgaXNMZWFmTm9kZSwgZ2V0QWxsQ2hpbGRyZW4gfSBmcm9tICcuL3N0YXRlVXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSW52b2NhYmxlQWN0b3IgfSBmcm9tICcuL0FjdG9yLmpzJztcbmltcG9ydCB7IHRvSW52b2tlRGVmaW5pdGlvbiB9IGZyb20gJy4vaW52b2tlVXRpbHMuanMnO1xuXG52YXIgTlVMTF9FVkVOVCA9ICcnO1xudmFyIFNUQVRFX0lERU5USUZJRVIgPSAnIyc7XG52YXIgV0lMRENBUkQgPSAnKic7XG52YXIgRU1QVFlfT0JKRUNUID0ge307XG5cbnZhciBpc1N0YXRlSWQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHJbMF0gPT09IFNUQVRFX0lERU5USUZJRVI7XG59O1xuXG52YXIgY3JlYXRlRGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgYWN0aW9uczoge30sXG4gICAgZ3VhcmRzOiB7fSxcbiAgICBzZXJ2aWNlczoge30sXG4gICAgYWN0aXZpdGllczoge30sXG4gICAgZGVsYXlzOiB7fVxuICB9O1xufTtcblxudmFyIHZhbGlkYXRlQXJyYXlpZmllZFRyYW5zaXRpb25zID0gZnVuY3Rpb24gKHN0YXRlTm9kZSwgZXZlbnQsIHRyYW5zaXRpb25zKSB7XG4gIHZhciBoYXNOb25MYXN0VW5ndWFyZGVkVGFyZ2V0ID0gdHJhbnNpdGlvbnMuc2xpY2UoMCwgLTEpLnNvbWUoZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gISgnY29uZCcgaW4gdHJhbnNpdGlvbikgJiYgISgnaW4nIGluIHRyYW5zaXRpb24pICYmIChpc1N0cmluZyh0cmFuc2l0aW9uLnRhcmdldCkgfHwgaXNNYWNoaW5lKHRyYW5zaXRpb24udGFyZ2V0KSk7XG4gIH0pO1xuICB2YXIgZXZlbnRUZXh0ID0gZXZlbnQgPT09IE5VTExfRVZFTlQgPyAndGhlIHRyYW5zaWVudCBldmVudCcgOiBcImV2ZW50ICdcIi5jb25jYXQoZXZlbnQsIFwiJ1wiKTtcbiAgd2FybighaGFzTm9uTGFzdFVuZ3VhcmRlZFRhcmdldCwgXCJPbmUgb3IgbW9yZSB0cmFuc2l0aW9ucyBmb3IgXCIuY29uY2F0KGV2ZW50VGV4dCwgXCIgb24gc3RhdGUgJ1wiKS5jb25jYXQoc3RhdGVOb2RlLmlkLCBcIicgYXJlIHVucmVhY2hhYmxlLiBcIikgKyBcIk1ha2Ugc3VyZSB0aGF0IHRoZSBkZWZhdWx0IHRyYW5zaXRpb24gaXMgdGhlIGxhc3Qgb25lIGRlZmluZWQuXCIpO1xufTtcblxudmFyIFN0YXRlTm9kZSA9XG4vKiNfX1BVUkVfXyovXG5cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RhdGVOb2RlKFxuICAvKipcclxuICAgKiBUaGUgcmF3IGNvbmZpZyB1c2VkIHRvIGNyZWF0ZSB0aGUgbWFjaGluZS5cclxuICAgKi9cbiAgY29uZmlnLCBvcHRpb25zLFxuICAvKipcclxuICAgKiBUaGUgaW5pdGlhbCBleHRlbmRlZCBzdGF0ZVxyXG4gICAqL1xuICBfY29udGV4dCwgLy8gVE9ETzogdGhpcyBpcyB1bnNhZmUsIGJ1dCB3ZSdyZSByZW1vdmluZyBpdCBpbiB2NSBhbnl3YXlcbiAgX3N0YXRlSW5mbykge1xuICAgIGlmIChfY29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICBfY29udGV4dCA9ICdjb250ZXh0JyBpbiBjb25maWcgPyBjb25maWcuY29udGV4dCA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF9hO1xuXG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5fY29udGV4dCA9IF9jb250ZXh0O1xuICAgIC8qKlxyXG4gICAgICogVGhlIG9yZGVyIHRoaXMgc3RhdGUgbm9kZSBhcHBlYXJzLiBDb3JyZXNwb25kcyB0byB0aGUgaW1wbGljaXQgU0NYTUwgZG9jdW1lbnQgb3JkZXIuXHJcbiAgICAgKi9cblxuICAgIHRoaXMub3JkZXIgPSAtMTtcbiAgICB0aGlzLl9feHN0YXRlbm9kZSA9IHRydWU7XG4gICAgdGhpcy5fX2NhY2hlID0ge1xuICAgICAgZXZlbnRzOiB1bmRlZmluZWQsXG4gICAgICByZWxhdGl2ZVZhbHVlOiBuZXcgTWFwKCksXG4gICAgICBpbml0aWFsU3RhdGVWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgaW5pdGlhbFN0YXRlOiB1bmRlZmluZWQsXG4gICAgICBvbjogdW5kZWZpbmVkLFxuICAgICAgdHJhbnNpdGlvbnM6IHVuZGVmaW5lZCxcbiAgICAgIGNhbmRpZGF0ZXM6IHt9LFxuICAgICAgZGVsYXllZFRyYW5zaXRpb25zOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHRoaXMuaWRNYXAgPSB7fTtcbiAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGNyZWF0ZURlZmF1bHRPcHRpb25zKCksIG9wdGlvbnMpO1xuICAgIHRoaXMucGFyZW50ID0gX3N0YXRlSW5mbyA9PT0gbnVsbCB8fCBfc3RhdGVJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGVJbmZvLnBhcmVudDtcbiAgICB0aGlzLmtleSA9IHRoaXMuY29uZmlnLmtleSB8fCAoX3N0YXRlSW5mbyA9PT0gbnVsbCB8fCBfc3RhdGVJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGVJbmZvLmtleSkgfHwgdGhpcy5jb25maWcuaWQgfHwgJyhtYWNoaW5lKSc7XG4gICAgdGhpcy5tYWNoaW5lID0gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5tYWNoaW5lIDogdGhpcztcbiAgICB0aGlzLnBhdGggPSB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBhdGguY29uY2F0KHRoaXMua2V5KSA6IFtdO1xuICAgIHRoaXMuZGVsaW1pdGVyID0gdGhpcy5jb25maWcuZGVsaW1pdGVyIHx8ICh0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmRlbGltaXRlciA6IFNUQVRFX0RFTElNSVRFUik7XG4gICAgdGhpcy5pZCA9IHRoaXMuY29uZmlnLmlkIHx8IF9fc3ByZWFkQXJyYXkoW3RoaXMubWFjaGluZS5rZXldLCBfX3JlYWQodGhpcy5wYXRoKSwgZmFsc2UpLmpvaW4odGhpcy5kZWxpbWl0ZXIpO1xuICAgIHRoaXMudmVyc2lvbiA9IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQudmVyc2lvbiA6IHRoaXMuY29uZmlnLnZlcnNpb247XG4gICAgdGhpcy50eXBlID0gdGhpcy5jb25maWcudHlwZSB8fCAodGhpcy5jb25maWcucGFyYWxsZWwgPyAncGFyYWxsZWwnIDogdGhpcy5jb25maWcuc3RhdGVzICYmIE9iamVjdC5rZXlzKHRoaXMuY29uZmlnLnN0YXRlcykubGVuZ3RoID8gJ2NvbXBvdW5kJyA6IHRoaXMuY29uZmlnLmhpc3RvcnkgPyAnaGlzdG9yeScgOiAnYXRvbWljJyk7XG4gICAgdGhpcy5zY2hlbWEgPSB0aGlzLnBhcmVudCA/IHRoaXMubWFjaGluZS5zY2hlbWEgOiAoX2EgPSB0aGlzLmNvbmZpZy5zY2hlbWEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSB0aGlzLmNvbmZpZy5kZXNjcmlwdGlvbjtcblxuICAgIGlmICghSVNfUFJPRFVDVElPTikge1xuICAgICAgd2FybighKCdwYXJhbGxlbCcgaW4gdGhpcy5jb25maWcpLCBcIlRoZSBcXFwicGFyYWxsZWxcXFwiIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDQuMS4gXCIuY29uY2F0KHRoaXMuY29uZmlnLnBhcmFsbGVsID8gXCJSZXBsYWNlIHdpdGggYHR5cGU6ICdwYXJhbGxlbCdgXCIgOiBcIlVzZSBgdHlwZTogJ1wiLmNvbmNhdCh0aGlzLnR5cGUsIFwiJ2BcIiksIFwiIGluIHRoZSBjb25maWcgZm9yIHN0YXRlIG5vZGUgJ1wiKS5jb25jYXQodGhpcy5pZCwgXCInIGluc3RlYWQuXCIpKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRpYWwgPSB0aGlzLmNvbmZpZy5pbml0aWFsO1xuICAgIHRoaXMuc3RhdGVzID0gdGhpcy5jb25maWcuc3RhdGVzID8gbWFwVmFsdWVzKHRoaXMuY29uZmlnLnN0YXRlcywgZnVuY3Rpb24gKHN0YXRlQ29uZmlnLCBrZXkpIHtcbiAgICAgIHZhciBfYTtcblxuICAgICAgdmFyIHN0YXRlTm9kZSA9IG5ldyBTdGF0ZU5vZGUoc3RhdGVDb25maWcsIHt9LCB1bmRlZmluZWQsIHtcbiAgICAgICAgcGFyZW50OiBfdGhpcyxcbiAgICAgICAga2V5OiBrZXlcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmFzc2lnbihfdGhpcy5pZE1hcCwgX19hc3NpZ24oKF9hID0ge30sIF9hW3N0YXRlTm9kZS5pZF0gPSBzdGF0ZU5vZGUsIF9hKSwgc3RhdGVOb2RlLmlkTWFwKSk7XG4gICAgICByZXR1cm4gc3RhdGVOb2RlO1xuICAgIH0pIDogRU1QVFlfT0JKRUNUOyAvLyBEb2N1bWVudCBvcmRlclxuXG4gICAgdmFyIG9yZGVyID0gMDtcblxuICAgIGZ1bmN0aW9uIGRmcyhzdGF0ZU5vZGUpIHtcbiAgICAgIHZhciBlXzEsIF9hO1xuXG4gICAgICBzdGF0ZU5vZGUub3JkZXIgPSBvcmRlcisrO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKGdldEFsbENoaWxkcmVuKHN0YXRlTm9kZSkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gX2MudmFsdWU7XG4gICAgICAgICAgZGZzKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgICAgZV8xID0ge1xuICAgICAgICAgIGVycm9yOiBlXzFfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGZzKHRoaXMpOyAvLyBIaXN0b3J5IGNvbmZpZ1xuXG4gICAgdGhpcy5oaXN0b3J5ID0gdGhpcy5jb25maWcuaGlzdG9yeSA9PT0gdHJ1ZSA/ICdzaGFsbG93JyA6IHRoaXMuY29uZmlnLmhpc3RvcnkgfHwgZmFsc2U7XG4gICAgdGhpcy5fdHJhbnNpZW50ID0gISF0aGlzLmNvbmZpZy5hbHdheXMgfHwgKCF0aGlzLmNvbmZpZy5vbiA/IGZhbHNlIDogQXJyYXkuaXNBcnJheSh0aGlzLmNvbmZpZy5vbikgPyB0aGlzLmNvbmZpZy5vbi5zb21lKGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIGV2ZW50ID0gX2EuZXZlbnQ7XG4gICAgICByZXR1cm4gZXZlbnQgPT09IE5VTExfRVZFTlQ7XG4gICAgfSkgOiBOVUxMX0VWRU5UIGluIHRoaXMuY29uZmlnLm9uKTtcbiAgICB0aGlzLnN0cmljdCA9ICEhdGhpcy5jb25maWcuc3RyaWN0OyAvLyBUT0RPOiBkZXByZWNhdGUgKGVudHJ5KVxuXG4gICAgdGhpcy5vbkVudHJ5ID0gdG9BcnJheSh0aGlzLmNvbmZpZy5lbnRyeSB8fCB0aGlzLmNvbmZpZy5vbkVudHJ5KS5tYXAoZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgcmV0dXJuIHRvQWN0aW9uT2JqZWN0KGFjdGlvbik7XG4gICAgfSk7IC8vIFRPRE86IGRlcHJlY2F0ZSAoZXhpdClcblxuICAgIHRoaXMub25FeGl0ID0gdG9BcnJheSh0aGlzLmNvbmZpZy5leGl0IHx8IHRoaXMuY29uZmlnLm9uRXhpdCkubWFwKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIHJldHVybiB0b0FjdGlvbk9iamVjdChhY3Rpb24pO1xuICAgIH0pO1xuICAgIHRoaXMubWV0YSA9IHRoaXMuY29uZmlnLm1ldGE7XG4gICAgdGhpcy5kb25lRGF0YSA9IHRoaXMudHlwZSA9PT0gJ2ZpbmFsJyA/IHRoaXMuY29uZmlnLmRhdGEgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbnZva2UgPSB0b0FycmF5KHRoaXMuY29uZmlnLmludm9rZSkubWFwKGZ1bmN0aW9uIChpbnZva2VDb25maWcsIGkpIHtcbiAgICAgIHZhciBfYSwgX2I7XG5cbiAgICAgIGlmIChpc01hY2hpbmUoaW52b2tlQ29uZmlnKSkge1xuICAgICAgICB2YXIgaW52b2tlSWQgPSBjcmVhdGVJbnZva2VJZChfdGhpcy5pZCwgaSk7XG4gICAgICAgIF90aGlzLm1hY2hpbmUub3B0aW9ucy5zZXJ2aWNlcyA9IF9fYXNzaWduKChfYSA9IHt9LCBfYVtpbnZva2VJZF0gPSBpbnZva2VDb25maWcsIF9hKSwgX3RoaXMubWFjaGluZS5vcHRpb25zLnNlcnZpY2VzKTtcbiAgICAgICAgcmV0dXJuIHRvSW52b2tlRGVmaW5pdGlvbih7XG4gICAgICAgICAgc3JjOiBpbnZva2VJZCxcbiAgICAgICAgICBpZDogaW52b2tlSWRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGludm9rZUNvbmZpZy5zcmMpKSB7XG4gICAgICAgIHZhciBpbnZva2VJZCA9IGludm9rZUNvbmZpZy5pZCB8fCBjcmVhdGVJbnZva2VJZChfdGhpcy5pZCwgaSk7XG4gICAgICAgIHJldHVybiB0b0ludm9rZURlZmluaXRpb24oX19hc3NpZ24oX19hc3NpZ24oe30sIGludm9rZUNvbmZpZyksIHtcbiAgICAgICAgICBpZDogaW52b2tlSWQsXG4gICAgICAgICAgc3JjOiBpbnZva2VDb25maWcuc3JjXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNYWNoaW5lKGludm9rZUNvbmZpZy5zcmMpIHx8IGlzRnVuY3Rpb24oaW52b2tlQ29uZmlnLnNyYykpIHtcbiAgICAgICAgdmFyIGludm9rZUlkID0gaW52b2tlQ29uZmlnLmlkIHx8IGNyZWF0ZUludm9rZUlkKF90aGlzLmlkLCBpKTtcbiAgICAgICAgX3RoaXMubWFjaGluZS5vcHRpb25zLnNlcnZpY2VzID0gX19hc3NpZ24oKF9iID0ge30sIF9iW2ludm9rZUlkXSA9IGludm9rZUNvbmZpZy5zcmMsIF9iKSwgX3RoaXMubWFjaGluZS5vcHRpb25zLnNlcnZpY2VzKTtcbiAgICAgICAgcmV0dXJuIHRvSW52b2tlRGVmaW5pdGlvbihfX2Fzc2lnbihfX2Fzc2lnbih7XG4gICAgICAgICAgaWQ6IGludm9rZUlkXG4gICAgICAgIH0sIGludm9rZUNvbmZpZyksIHtcbiAgICAgICAgICBzcmM6IGludm9rZUlkXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbnZva2VTb3VyY2UgPSBpbnZva2VDb25maWcuc3JjO1xuICAgICAgICByZXR1cm4gdG9JbnZva2VEZWZpbml0aW9uKF9fYXNzaWduKF9fYXNzaWduKHtcbiAgICAgICAgICBpZDogY3JlYXRlSW52b2tlSWQoX3RoaXMuaWQsIGkpXG4gICAgICAgIH0sIGludm9rZUNvbmZpZyksIHtcbiAgICAgICAgICBzcmM6IGludm9rZVNvdXJjZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hY3Rpdml0aWVzID0gdG9BcnJheSh0aGlzLmNvbmZpZy5hY3Rpdml0aWVzKS5jb25jYXQodGhpcy5pbnZva2UpLm1hcChmdW5jdGlvbiAoYWN0aXZpdHkpIHtcbiAgICAgIHJldHVybiB0b0FjdGl2aXR5RGVmaW5pdGlvbihhY3Rpdml0eSk7XG4gICAgfSk7XG4gICAgdGhpcy50cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy50YWdzID0gdG9BcnJheSh0aGlzLmNvbmZpZy50YWdzKTsgLy8gVE9ETzogdGhpcyBpcyB0aGUgcmVhbCBmaXggZm9yIGluaXRpYWxpemF0aW9uIG9uY2VcbiAgICAvLyBzdGF0ZSBub2RlIGdldHRlcnMgYXJlIGRlcHJlY2F0ZWRcbiAgICAvLyBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgLy8gICB0aGlzLl9pbml0KCk7XG4gICAgLy8gfVxuICB9XG5cbiAgU3RhdGVOb2RlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fX2NhY2hlLnRyYW5zaXRpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ2V0QWxsU3RhdGVOb2Rlcyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZU5vZGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZU5vZGUub247XG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIENsb25lcyB0aGlzIHN0YXRlIG1hY2hpbmUgd2l0aCBjdXN0b20gb3B0aW9ucyBhbmQgY29udGV4dC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgKGFjdGlvbnMsIGd1YXJkcywgYWN0aXZpdGllcywgc2VydmljZXMpIHRvIHJlY3Vyc2l2ZWx5IG1lcmdlIHdpdGggdGhlIGV4aXN0aW5nIG9wdGlvbnMuXHJcbiAgICogQHBhcmFtIGNvbnRleHQgQ3VzdG9tIGNvbnRleHQgKHdpbGwgb3ZlcnJpZGUgcHJlZGVmaW5lZCBjb250ZXh0KVxyXG4gICAqL1xuXG5cbiAgU3RhdGVOb2RlLnByb3RvdHlwZS53aXRoQ29uZmlnID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGFjdGlvbnMgPSBfYS5hY3Rpb25zLFxuICAgICAgICBhY3Rpdml0aWVzID0gX2EuYWN0aXZpdGllcyxcbiAgICAgICAgZ3VhcmRzID0gX2EuZ3VhcmRzLFxuICAgICAgICBzZXJ2aWNlcyA9IF9hLnNlcnZpY2VzLFxuICAgICAgICBkZWxheXMgPSBfYS5kZWxheXM7XG4gICAgcmV0dXJuIG5ldyBTdGF0ZU5vZGUodGhpcy5jb25maWcsIHtcbiAgICAgIGFjdGlvbnM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBhY3Rpb25zKSwgb3B0aW9ucy5hY3Rpb25zKSxcbiAgICAgIGFjdGl2aXRpZXM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBhY3Rpdml0aWVzKSwgb3B0aW9ucy5hY3Rpdml0aWVzKSxcbiAgICAgIGd1YXJkczogX19hc3NpZ24oX19hc3NpZ24oe30sIGd1YXJkcyksIG9wdGlvbnMuZ3VhcmRzKSxcbiAgICAgIHNlcnZpY2VzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc2VydmljZXMpLCBvcHRpb25zLnNlcnZpY2VzKSxcbiAgICAgIGRlbGF5czogX19hc3NpZ24oX19hc3NpZ24oe30sIGRlbGF5cyksIG9wdGlvbnMuZGVsYXlzKVxuICAgIH0sIGNvbnRleHQgIT09IG51bGwgJiYgY29udGV4dCAhPT0gdm9pZCAwID8gY29udGV4dCA6IHRoaXMuY29udGV4dCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIENsb25lcyB0aGlzIHN0YXRlIG1hY2hpbmUgd2l0aCBjdXN0b20gY29udGV4dC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBjb250ZXh0IEN1c3RvbSBjb250ZXh0ICh3aWxsIG92ZXJyaWRlIHByZWRlZmluZWQgY29udGV4dCwgbm90IHJlY3Vyc2l2ZSlcclxuICAgKi9cblxuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUud2l0aENvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgU3RhdGVOb2RlKHRoaXMuY29uZmlnLCB0aGlzLm9wdGlvbnMsIGNvbnRleHQpO1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZU5vZGUucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odGhpcy5fY29udGV4dCkgPyB0aGlzLl9jb250ZXh0KCkgOiB0aGlzLl9jb250ZXh0O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVOb2RlLnByb3RvdHlwZSwgXCJkZWZpbml0aW9uXCIsIHtcbiAgICAvKipcclxuICAgICAqIFRoZSB3ZWxsLXN0cnVjdHVyZWQgc3RhdGUgbm9kZSBkZWZpbml0aW9uLlxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxuICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgaW5pdGlhbDogdGhpcy5pbml0aWFsLFxuICAgICAgICBoaXN0b3J5OiB0aGlzLmhpc3RvcnksXG4gICAgICAgIHN0YXRlczogbWFwVmFsdWVzKHRoaXMuc3RhdGVzLCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUuZGVmaW5pdGlvbjtcbiAgICAgICAgfSksXG4gICAgICAgIG9uOiB0aGlzLm9uLFxuICAgICAgICB0cmFuc2l0aW9uczogdGhpcy50cmFuc2l0aW9ucyxcbiAgICAgICAgZW50cnk6IHRoaXMub25FbnRyeSxcbiAgICAgICAgZXhpdDogdGhpcy5vbkV4aXQsXG4gICAgICAgIGFjdGl2aXRpZXM6IHRoaXMuYWN0aXZpdGllcyB8fCBbXSxcbiAgICAgICAgbWV0YTogdGhpcy5tZXRhLFxuICAgICAgICBvcmRlcjogdGhpcy5vcmRlciB8fCAtMSxcbiAgICAgICAgZGF0YTogdGhpcy5kb25lRGF0YSxcbiAgICAgICAgaW52b2tlOiB0aGlzLmludm9rZSxcbiAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICAgIHRhZ3M6IHRoaXMudGFnc1xuICAgICAgfTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uO1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZU5vZGUucHJvdG90eXBlLCBcIm9uXCIsIHtcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXBwaW5nIG9mIGV2ZW50cyB0byB0cmFuc2l0aW9ucy5cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX19jYWNoZS5vbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLm9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJhbnNpdGlvbnMgPSB0aGlzLnRyYW5zaXRpb25zO1xuICAgICAgcmV0dXJuIHRoaXMuX19jYWNoZS5vbiA9IHRyYW5zaXRpb25zLnJlZHVjZShmdW5jdGlvbiAobWFwLCB0cmFuc2l0aW9uKSB7XG4gICAgICAgIG1hcFt0cmFuc2l0aW9uLmV2ZW50VHlwZV0gPSBtYXBbdHJhbnNpdGlvbi5ldmVudFR5cGVdIHx8IFtdO1xuICAgICAgICBtYXBbdHJhbnNpdGlvbi5ldmVudFR5cGVdLnB1c2godHJhbnNpdGlvbik7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9LCB7fSk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZU5vZGUucHJvdG90eXBlLCBcImFmdGVyXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fY2FjaGUuZGVsYXllZFRyYW5zaXRpb25zIHx8ICh0aGlzLl9fY2FjaGUuZGVsYXllZFRyYW5zaXRpb25zID0gdGhpcy5nZXREZWxheWVkVHJhbnNpdGlvbnMoKSwgdGhpcy5fX2NhY2hlLmRlbGF5ZWRUcmFuc2l0aW9ucyk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZU5vZGUucHJvdG90eXBlLCBcInRyYW5zaXRpb25zXCIsIHtcbiAgICAvKipcclxuICAgICAqIEFsbCB0aGUgdHJhbnNpdGlvbnMgdGhhdCBjYW4gYmUgdGFrZW4gZnJvbSB0aGlzIHN0YXRlIG5vZGUuXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fY2FjaGUudHJhbnNpdGlvbnMgfHwgKHRoaXMuX19jYWNoZS50cmFuc2l0aW9ucyA9IHRoaXMuZm9ybWF0VHJhbnNpdGlvbnMoKSwgdGhpcy5fX2NhY2hlLnRyYW5zaXRpb25zKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLmdldENhbmRpZGF0ZXMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgaWYgKHRoaXMuX19jYWNoZS5jYW5kaWRhdGVzW2V2ZW50TmFtZV0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9fY2FjaGUuY2FuZGlkYXRlc1tldmVudE5hbWVdO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2llbnQgPSBldmVudE5hbWUgPT09IE5VTExfRVZFTlQ7XG4gICAgdmFyIGNhbmRpZGF0ZXMgPSB0aGlzLnRyYW5zaXRpb25zLmZpbHRlcihmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICAgICAgdmFyIHNhbWVFdmVudFR5cGUgPSB0cmFuc2l0aW9uLmV2ZW50VHlwZSA9PT0gZXZlbnROYW1lOyAvLyBudWxsIGV2ZW50cyBzaG91bGQgb25seSBtYXRjaCBhZ2FpbnN0IGV2ZW50bGVzcyB0cmFuc2l0aW9uc1xuXG4gICAgICByZXR1cm4gdHJhbnNpZW50ID8gc2FtZUV2ZW50VHlwZSA6IHNhbWVFdmVudFR5cGUgfHwgdHJhbnNpdGlvbi5ldmVudFR5cGUgPT09IFdJTERDQVJEO1xuICAgIH0pO1xuICAgIHRoaXMuX19jYWNoZS5jYW5kaWRhdGVzW2V2ZW50TmFtZV0gPSBjYW5kaWRhdGVzO1xuICAgIHJldHVybiBjYW5kaWRhdGVzO1xuICB9O1xuICAvKipcclxuICAgKiBBbGwgZGVsYXllZCB0cmFuc2l0aW9ucyBmcm9tIHRoZSBjb25maWcuXHJcbiAgICovXG5cblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLmdldERlbGF5ZWRUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGFmdGVyQ29uZmlnID0gdGhpcy5jb25maWcuYWZ0ZXI7XG5cbiAgICBpZiAoIWFmdGVyQ29uZmlnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIG11dGF0ZUVudHJ5RXhpdCA9IGZ1bmN0aW9uIChkZWxheSwgaSkge1xuICAgICAgdmFyIGRlbGF5UmVmID0gaXNGdW5jdGlvbihkZWxheSkgPyBcIlwiLmNvbmNhdChfdGhpcy5pZCwgXCI6ZGVsYXlbXCIpLmNvbmNhdChpLCBcIl1cIikgOiBkZWxheTtcbiAgICAgIHZhciBldmVudFR5cGUgPSBhZnRlcihkZWxheVJlZiwgX3RoaXMuaWQpO1xuXG4gICAgICBfdGhpcy5vbkVudHJ5LnB1c2goc2VuZChldmVudFR5cGUsIHtcbiAgICAgICAgZGVsYXk6IGRlbGF5XG4gICAgICB9KSk7XG5cbiAgICAgIF90aGlzLm9uRXhpdC5wdXNoKGNhbmNlbChldmVudFR5cGUpKTtcblxuICAgICAgcmV0dXJuIGV2ZW50VHlwZTtcbiAgICB9O1xuXG4gICAgdmFyIGRlbGF5ZWRUcmFuc2l0aW9ucyA9IGlzQXJyYXkoYWZ0ZXJDb25maWcpID8gYWZ0ZXJDb25maWcubWFwKGZ1bmN0aW9uICh0cmFuc2l0aW9uLCBpKSB7XG4gICAgICB2YXIgZXZlbnRUeXBlID0gbXV0YXRlRW50cnlFeGl0KHRyYW5zaXRpb24uZGVsYXksIGkpO1xuICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0cmFuc2l0aW9uKSwge1xuICAgICAgICBldmVudDogZXZlbnRUeXBlXG4gICAgICB9KTtcbiAgICB9KSA6IGZsYXR0ZW4oT2JqZWN0LmtleXMoYWZ0ZXJDb25maWcpLm1hcChmdW5jdGlvbiAoZGVsYXksIGkpIHtcbiAgICAgIHZhciBjb25maWdUcmFuc2l0aW9uID0gYWZ0ZXJDb25maWdbZGVsYXldO1xuICAgICAgdmFyIHJlc29sdmVkVHJhbnNpdGlvbiA9IGlzU3RyaW5nKGNvbmZpZ1RyYW5zaXRpb24pID8ge1xuICAgICAgICB0YXJnZXQ6IGNvbmZpZ1RyYW5zaXRpb25cbiAgICAgIH0gOiBjb25maWdUcmFuc2l0aW9uO1xuICAgICAgdmFyIHJlc29sdmVkRGVsYXkgPSAhaXNOYU4oK2RlbGF5KSA/ICtkZWxheSA6IGRlbGF5O1xuICAgICAgdmFyIGV2ZW50VHlwZSA9IG11dGF0ZUVudHJ5RXhpdChyZXNvbHZlZERlbGF5LCBpKTtcbiAgICAgIHJldHVybiB0b0FycmF5KHJlc29sdmVkVHJhbnNpdGlvbikubWFwKGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdHJhbnNpdGlvbiksIHtcbiAgICAgICAgICBldmVudDogZXZlbnRUeXBlLFxuICAgICAgICAgIGRlbGF5OiByZXNvbHZlZERlbGF5XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSkpO1xuICAgIHJldHVybiBkZWxheWVkVHJhbnNpdGlvbnMubWFwKGZ1bmN0aW9uIChkZWxheWVkVHJhbnNpdGlvbikge1xuICAgICAgdmFyIGRlbGF5ID0gZGVsYXllZFRyYW5zaXRpb24uZGVsYXk7XG4gICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIF90aGlzLmZvcm1hdFRyYW5zaXRpb24oZGVsYXllZFRyYW5zaXRpb24pKSwge1xuICAgICAgICBkZWxheTogZGVsYXlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSBub2RlcyByZXByZXNlbnRlZCBieSB0aGUgY3VycmVudCBzdGF0ZSB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdmFsdWUgb3IgU3RhdGUgaW5zdGFuY2VcclxuICAgKi9cblxuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuZ2V0U3RhdGVOb2RlcyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIXN0YXRlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlVmFsdWUgPSBzdGF0ZSBpbnN0YW5jZW9mIFN0YXRlID8gc3RhdGUudmFsdWUgOiB0b1N0YXRlVmFsdWUoc3RhdGUsIHRoaXMuZGVsaW1pdGVyKTtcblxuICAgIGlmIChpc1N0cmluZyhzdGF0ZVZhbHVlKSkge1xuICAgICAgdmFyIGluaXRpYWxTdGF0ZVZhbHVlID0gdGhpcy5nZXRTdGF0ZU5vZGUoc3RhdGVWYWx1ZSkuaW5pdGlhbDtcbiAgICAgIHJldHVybiBpbml0aWFsU3RhdGVWYWx1ZSAhPT0gdW5kZWZpbmVkID8gdGhpcy5nZXRTdGF0ZU5vZGVzKChfYSA9IHt9LCBfYVtzdGF0ZVZhbHVlXSA9IGluaXRpYWxTdGF0ZVZhbHVlLCBfYSkpIDogW3RoaXMsIHRoaXMuc3RhdGVzW3N0YXRlVmFsdWVdXTtcbiAgICB9XG5cbiAgICB2YXIgc3ViU3RhdGVLZXlzID0gT2JqZWN0LmtleXMoc3RhdGVWYWx1ZSk7XG4gICAgdmFyIHN1YlN0YXRlTm9kZXMgPSBbdGhpc107XG4gICAgc3ViU3RhdGVOb2Rlcy5wdXNoLmFwcGx5KHN1YlN0YXRlTm9kZXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChmbGF0dGVuKHN1YlN0YXRlS2V5cy5tYXAoZnVuY3Rpb24gKHN1YlN0YXRlS2V5KSB7XG4gICAgICByZXR1cm4gX3RoaXMuZ2V0U3RhdGVOb2RlKHN1YlN0YXRlS2V5KS5nZXRTdGF0ZU5vZGVzKHN0YXRlVmFsdWVbc3ViU3RhdGVLZXldKTtcbiAgICB9KSkpLCBmYWxzZSkpO1xuICAgIHJldHVybiBzdWJTdGF0ZU5vZGVzO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIHN0YXRlIG5vZGUgZXhwbGljaXRseSBoYW5kbGVzIHRoZSBnaXZlbiBldmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgaW4gcXVlc3Rpb25cclxuICAgKi9cblxuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuaGFuZGxlcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBldmVudFR5cGUgPSBnZXRFdmVudFR5cGUoZXZlbnQpO1xuICAgIHJldHVybiB0aGlzLmV2ZW50cy5pbmNsdWRlcyhldmVudFR5cGUpO1xuICB9O1xuICAvKipcclxuICAgKiBSZXNvbHZlcyB0aGUgZ2l2ZW4gYHN0YXRlYCB0byBhIG5ldyBgU3RhdGVgIGluc3RhbmNlIHJlbGF0aXZlIHRvIHRoaXMgbWFjaGluZS5cclxuICAgKlxyXG4gICAqIFRoaXMgZW5zdXJlcyB0aGF0IGAuZXZlbnRzYCBhbmQgYC5uZXh0RXZlbnRzYCByZXByZXNlbnQgdGhlIGNvcnJlY3QgdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0byByZXNvbHZlXHJcbiAgICovXG5cblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLnJlc29sdmVTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHZhciBzdGF0ZUZyb21Db25maWcgPSBzdGF0ZSBpbnN0YW5jZW9mIFN0YXRlID8gc3RhdGUgOiBTdGF0ZS5jcmVhdGUoc3RhdGUpO1xuICAgIHZhciBjb25maWd1cmF0aW9uID0gQXJyYXkuZnJvbShnZXRDb25maWd1cmF0aW9uKFtdLCB0aGlzLmdldFN0YXRlTm9kZXMoc3RhdGVGcm9tQ29uZmlnLnZhbHVlKSkpO1xuICAgIHJldHVybiBuZXcgU3RhdGUoX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlRnJvbUNvbmZpZyksIHtcbiAgICAgIHZhbHVlOiB0aGlzLnJlc29sdmUoc3RhdGVGcm9tQ29uZmlnLnZhbHVlKSxcbiAgICAgIGNvbmZpZ3VyYXRpb246IGNvbmZpZ3VyYXRpb24sXG4gICAgICBkb25lOiBpc0luRmluYWxTdGF0ZShjb25maWd1cmF0aW9uLCB0aGlzKSxcbiAgICAgIHRhZ3M6IGdldFRhZ3NGcm9tQ29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKSxcbiAgICAgIG1hY2hpbmU6IHRoaXMubWFjaGluZVxuICAgIH0pKTtcbiAgfTtcblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLnRyYW5zaXRpb25MZWFmTm9kZSA9IGZ1bmN0aW9uIChzdGF0ZVZhbHVlLCBzdGF0ZSwgX2V2ZW50KSB7XG4gICAgdmFyIHN0YXRlTm9kZSA9IHRoaXMuZ2V0U3RhdGVOb2RlKHN0YXRlVmFsdWUpO1xuICAgIHZhciBuZXh0ID0gc3RhdGVOb2RlLm5leHQoc3RhdGUsIF9ldmVudCk7XG5cbiAgICBpZiAoIW5leHQgfHwgIW5leHQudHJhbnNpdGlvbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0KHN0YXRlLCBfZXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0O1xuICB9O1xuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUudHJhbnNpdGlvbkNvbXBvdW5kTm9kZSA9IGZ1bmN0aW9uIChzdGF0ZVZhbHVlLCBzdGF0ZSwgX2V2ZW50KSB7XG4gICAgdmFyIHN1YlN0YXRlS2V5cyA9IE9iamVjdC5rZXlzKHN0YXRlVmFsdWUpO1xuICAgIHZhciBzdGF0ZU5vZGUgPSB0aGlzLmdldFN0YXRlTm9kZShzdWJTdGF0ZUtleXNbMF0pO1xuXG4gICAgdmFyIG5leHQgPSBzdGF0ZU5vZGUuX3RyYW5zaXRpb24oc3RhdGVWYWx1ZVtzdWJTdGF0ZUtleXNbMF1dLCBzdGF0ZSwgX2V2ZW50KTtcblxuICAgIGlmICghbmV4dCB8fCAhbmV4dC50cmFuc2l0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5leHQoc3RhdGUsIF9ldmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH07XG5cbiAgU3RhdGVOb2RlLnByb3RvdHlwZS50cmFuc2l0aW9uUGFyYWxsZWxOb2RlID0gZnVuY3Rpb24gKHN0YXRlVmFsdWUsIHN0YXRlLCBfZXZlbnQpIHtcbiAgICB2YXIgZV8yLCBfYTtcblxuICAgIHZhciB0cmFuc2l0aW9uTWFwID0ge307XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhzdGF0ZVZhbHVlKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIHN1YlN0YXRlS2V5ID0gX2MudmFsdWU7XG4gICAgICAgIHZhciBzdWJTdGF0ZVZhbHVlID0gc3RhdGVWYWx1ZVtzdWJTdGF0ZUtleV07XG5cbiAgICAgICAgaWYgKCFzdWJTdGF0ZVZhbHVlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3ViU3RhdGVOb2RlID0gdGhpcy5nZXRTdGF0ZU5vZGUoc3ViU3RhdGVLZXkpO1xuXG4gICAgICAgIHZhciBuZXh0ID0gc3ViU3RhdGVOb2RlLl90cmFuc2l0aW9uKHN1YlN0YXRlVmFsdWUsIHN0YXRlLCBfZXZlbnQpO1xuXG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgdHJhbnNpdGlvbk1hcFtzdWJTdGF0ZUtleV0gPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZV8yXzEpIHtcbiAgICAgIGVfMiA9IHtcbiAgICAgICAgZXJyb3I6IGVfMl8xXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlVHJhbnNpdGlvbnMgPSBPYmplY3Qua2V5cyh0cmFuc2l0aW9uTWFwKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHRyYW5zaXRpb25NYXBba2V5XTtcbiAgICB9KTtcbiAgICB2YXIgZW5hYmxlZFRyYW5zaXRpb25zID0gZmxhdHRlbihzdGF0ZVRyYW5zaXRpb25zLm1hcChmdW5jdGlvbiAoc3QpIHtcbiAgICAgIHJldHVybiBzdC50cmFuc2l0aW9ucztcbiAgICB9KSk7XG4gICAgdmFyIHdpbGxUcmFuc2l0aW9uID0gc3RhdGVUcmFuc2l0aW9ucy5zb21lKGZ1bmN0aW9uIChzdCkge1xuICAgICAgcmV0dXJuIHN0LnRyYW5zaXRpb25zLmxlbmd0aCA+IDA7XG4gICAgfSk7XG5cbiAgICBpZiAoIXdpbGxUcmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0KHN0YXRlLCBfZXZlbnQpO1xuICAgIH1cblxuICAgIHZhciBjb25maWd1cmF0aW9uID0gZmxhdHRlbihPYmplY3Qua2V5cyh0cmFuc2l0aW9uTWFwKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHRyYW5zaXRpb25NYXBba2V5XS5jb25maWd1cmF0aW9uO1xuICAgIH0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNpdGlvbnM6IGVuYWJsZWRUcmFuc2l0aW9ucyxcbiAgICAgIGV4aXRTZXQ6IGZsYXR0ZW4oc3RhdGVUcmFuc2l0aW9ucy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuZXhpdFNldDtcbiAgICAgIH0pKSxcbiAgICAgIGNvbmZpZ3VyYXRpb246IGNvbmZpZ3VyYXRpb24sXG4gICAgICBzb3VyY2U6IHN0YXRlLFxuICAgICAgYWN0aW9uczogZmxhdHRlbihPYmplY3Qua2V5cyh0cmFuc2l0aW9uTWFwKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdHJhbnNpdGlvbk1hcFtrZXldLmFjdGlvbnM7XG4gICAgICB9KSlcbiAgICB9O1xuICB9O1xuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuX3RyYW5zaXRpb24gPSBmdW5jdGlvbiAoc3RhdGVWYWx1ZSwgc3RhdGUsIF9ldmVudCkge1xuICAgIC8vIGxlYWYgbm9kZVxuICAgIGlmIChpc1N0cmluZyhzdGF0ZVZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbkxlYWZOb2RlKHN0YXRlVmFsdWUsIHN0YXRlLCBfZXZlbnQpO1xuICAgIH0gLy8gaGllcmFyY2hpY2FsIG5vZGVcblxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHN0YXRlVmFsdWUpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbkNvbXBvdW5kTm9kZShzdGF0ZVZhbHVlLCBzdGF0ZSwgX2V2ZW50KTtcbiAgICB9IC8vIG9ydGhvZ29uYWwgbm9kZVxuXG5cbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uUGFyYWxsZWxOb2RlKHN0YXRlVmFsdWUsIHN0YXRlLCBfZXZlbnQpO1xuICB9O1xuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuZ2V0VHJhbnNpdGlvbkRhdGEgPSBmdW5jdGlvbiAoc3RhdGUsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb24oc3RhdGUudmFsdWUsIHN0YXRlLCB0b1NDWE1MRXZlbnQoZXZlbnQpKTtcbiAgfTtcblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoc3RhdGUsIF9ldmVudCkge1xuICAgIHZhciBlXzMsIF9hO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBldmVudE5hbWUgPSBfZXZlbnQubmFtZTtcbiAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgIHZhciBuZXh0U3RhdGVOb2RlcyA9IFtdO1xuICAgIHZhciBzZWxlY3RlZFRyYW5zaXRpb247XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLmdldENhbmRpZGF0ZXMoZXZlbnROYW1lKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IF9jLnZhbHVlO1xuICAgICAgICB2YXIgY29uZCA9IGNhbmRpZGF0ZS5jb25kLFxuICAgICAgICAgICAgc3RhdGVJbiA9IGNhbmRpZGF0ZS5pbjtcbiAgICAgICAgdmFyIHJlc29sdmVkQ29udGV4dCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICAgIHZhciBpc0luU3RhdGUgPSBzdGF0ZUluID8gaXNTdHJpbmcoc3RhdGVJbikgJiYgaXNTdGF0ZUlkKHN0YXRlSW4pID8gLy8gQ2hlY2sgaWYgaW4gc3RhdGUgYnkgSURcbiAgICAgICAgc3RhdGUubWF0Y2hlcyh0b1N0YXRlVmFsdWUodGhpcy5nZXRTdGF0ZU5vZGVCeUlkKHN0YXRlSW4pLnBhdGgsIHRoaXMuZGVsaW1pdGVyKSkgOiAvLyBDaGVjayBpZiBpbiBzdGF0ZSBieSByZWxhdGl2ZSBncmFuZHBhcmVudFxuICAgICAgICBtYXRjaGVzU3RhdGUodG9TdGF0ZVZhbHVlKHN0YXRlSW4sIHRoaXMuZGVsaW1pdGVyKSwgcGF0aCh0aGlzLnBhdGguc2xpY2UoMCwgLTIpKShzdGF0ZS52YWx1ZSkpIDogdHJ1ZTtcbiAgICAgICAgdmFyIGd1YXJkUGFzc2VkID0gZmFsc2U7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBndWFyZFBhc3NlZCA9ICFjb25kIHx8IGV2YWx1YXRlR3VhcmQodGhpcy5tYWNoaW5lLCBjb25kLCByZXNvbHZlZENvbnRleHQsIF9ldmVudCwgc3RhdGUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZXZhbHVhdGUgZ3VhcmQgJ1wiLmNvbmNhdChjb25kLm5hbWUgfHwgY29uZC50eXBlLCBcIicgaW4gdHJhbnNpdGlvbiBmb3IgZXZlbnQgJ1wiKS5jb25jYXQoZXZlbnROYW1lLCBcIicgaW4gc3RhdGUgbm9kZSAnXCIpLmNvbmNhdCh0aGlzLmlkLCBcIic6XFxuXCIpLmNvbmNhdChlcnIubWVzc2FnZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGd1YXJkUGFzc2VkICYmIGlzSW5TdGF0ZSkge1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUudGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5leHRTdGF0ZU5vZGVzID0gY2FuZGlkYXRlLnRhcmdldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhY3Rpb25zLnB1c2guYXBwbHkoYWN0aW9ucywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGNhbmRpZGF0ZS5hY3Rpb25zKSwgZmFsc2UpKTtcbiAgICAgICAgICBzZWxlY3RlZFRyYW5zaXRpb24gPSBjYW5kaWRhdGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzNfMSkge1xuICAgICAgZV8zID0ge1xuICAgICAgICBlcnJvcjogZV8zXzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNlbGVjdGVkVHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoIW5leHRTdGF0ZU5vZGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhbnNpdGlvbnM6IFtzZWxlY3RlZFRyYW5zaXRpb25dLFxuICAgICAgICBleGl0U2V0OiBbXSxcbiAgICAgICAgY29uZmlndXJhdGlvbjogc3RhdGUudmFsdWUgPyBbdGhpc10gOiBbXSxcbiAgICAgICAgc291cmNlOiBzdGF0ZSxcbiAgICAgICAgYWN0aW9uczogYWN0aW9uc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYWxsTmV4dFN0YXRlTm9kZXMgPSBmbGF0dGVuKG5leHRTdGF0ZU5vZGVzLm1hcChmdW5jdGlvbiAoc3RhdGVOb2RlKSB7XG4gICAgICByZXR1cm4gX3RoaXMuZ2V0UmVsYXRpdmVTdGF0ZU5vZGVzKHN0YXRlTm9kZSwgc3RhdGUuaGlzdG9yeVZhbHVlKTtcbiAgICB9KSk7XG4gICAgdmFyIGlzSW50ZXJuYWwgPSAhIXNlbGVjdGVkVHJhbnNpdGlvbi5pbnRlcm5hbDtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNpdGlvbnM6IFtzZWxlY3RlZFRyYW5zaXRpb25dLFxuICAgICAgZXhpdFNldDogaXNJbnRlcm5hbCA/IFtdIDogZmxhdHRlbihuZXh0U3RhdGVOb2Rlcy5tYXAoZnVuY3Rpb24gKHRhcmdldE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmdldFBvdGVudGlhbGx5UmVlbnRlcmluZ05vZGVzKHRhcmdldE5vZGUpO1xuICAgICAgfSkpLFxuICAgICAgY29uZmlndXJhdGlvbjogYWxsTmV4dFN0YXRlTm9kZXMsXG4gICAgICBzb3VyY2U6IHN0YXRlLFxuICAgICAgYWN0aW9uczogYWN0aW9uc1xuICAgIH07XG4gIH07IC8vIGV2ZW4gdGhvdWdoIHRoZSBuYW1lIG9mIHRoaXMgZnVuY3Rpb24gbWVudGlvbnMgcmVlbnRyeSBub2Rlc1xuICAvLyB3ZSBhcmUgcHVzaGluZyBpdHMgcmVzdWx0IGludG8gYGV4aXRTZXRgXG4gIC8vIHRoYXQncyBiZWNhdXNlIHdoYXQgd2UgZXhpdCBtaWdodCBiZSByZWVudGVyZWQgKGl0J3MgYW4gaW52YXJpYW50IG9mIHJlZW50cmFuY3kpXG5cblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLmdldFBvdGVudGlhbGx5UmVlbnRlcmluZ05vZGVzID0gZnVuY3Rpb24gKHRhcmdldE5vZGUpIHtcbiAgICBpZiAodGhpcy5vcmRlciA8IHRhcmdldE5vZGUub3JkZXIpIHtcbiAgICAgIHJldHVybiBbdGhpc107XG4gICAgfVxuXG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIG1hcmtlciA9IHRoaXM7XG4gICAgdmFyIHBvc3NpYmxlQW5jZXN0b3IgPSB0YXJnZXROb2RlO1xuXG4gICAgd2hpbGUgKG1hcmtlciAmJiBtYXJrZXIgIT09IHBvc3NpYmxlQW5jZXN0b3IpIHtcbiAgICAgIG5vZGVzLnB1c2gobWFya2VyKTtcbiAgICAgIG1hcmtlciA9IG1hcmtlci5wYXJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlciAhPT0gcG9zc2libGVBbmNlc3Rvcikge1xuICAgICAgLy8gd2UgbmV2ZXIgZ290IHRvIGBwb3NzaWJsZUFuY2VzdG9yYCwgdGhlcmVmb3JlIHRoZSBpbml0aWFsIGBtYXJrZXJgIFwiZXNjYXBlc1wiIGl0XG4gICAgICAvLyBpdCdzIGluIGEgZGlmZmVyZW50IHBhcnQgb2YgdGhlIHRyZWUgc28gbm8gc3RhdGVzIHdpbGwgYmUgcmVlbnRlcmVkIGZvciBzdWNoIGFuIGV4dGVybmFsIHRyYW5zaXRpb25cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBub2Rlcy5wdXNoKHBvc3NpYmxlQW5jZXN0b3IpO1xuICAgIHJldHVybiBub2RlcztcbiAgfTtcblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLmdldEFjdGlvbnMgPSBmdW5jdGlvbiAocmVzb2x2ZWRDb25maWcsIGlzRG9uZSwgdHJhbnNpdGlvbiwgY3VycmVudENvbnRleHQsIF9ldmVudCwgcHJldlN0YXRlLCBwcmVkaWN0YWJsZUV4ZWMpIHtcbiAgICB2YXIgZV80LCBfYSwgZV81LCBfYjtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgcHJldkNvbmZpZyA9IHByZXZTdGF0ZSA/IGdldENvbmZpZ3VyYXRpb24oW10sIHRoaXMuZ2V0U3RhdGVOb2RlcyhwcmV2U3RhdGUudmFsdWUpKSA6IFtdO1xuICAgIHZhciBlbnRyeVNldCA9IG5ldyBTZXQoKTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKEFycmF5LmZyb20ocmVzb2x2ZWRDb25maWcpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgICAgfSkpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgIHZhciBzbiA9IF9kLnZhbHVlO1xuXG4gICAgICAgIGlmICghaGFzKHByZXZDb25maWcsIHNuKSB8fCBoYXModHJhbnNpdGlvbi5leGl0U2V0LCBzbikgfHwgc24ucGFyZW50ICYmIGVudHJ5U2V0Lmhhcyhzbi5wYXJlbnQpKSB7XG4gICAgICAgICAgZW50cnlTZXQuYWRkKHNuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfNF8xKSB7XG4gICAgICBlXzQgPSB7XG4gICAgICAgIGVycm9yOiBlXzRfMVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBwcmV2Q29uZmlnXzEgPSBfX3ZhbHVlcyhwcmV2Q29uZmlnKSwgcHJldkNvbmZpZ18xXzEgPSBwcmV2Q29uZmlnXzEubmV4dCgpOyAhcHJldkNvbmZpZ18xXzEuZG9uZTsgcHJldkNvbmZpZ18xXzEgPSBwcmV2Q29uZmlnXzEubmV4dCgpKSB7XG4gICAgICAgIHZhciBzbiA9IHByZXZDb25maWdfMV8xLnZhbHVlO1xuXG4gICAgICAgIGlmICghaGFzKHJlc29sdmVkQ29uZmlnLCBzbikgfHwgaGFzKHRyYW5zaXRpb24uZXhpdFNldCwgc24ucGFyZW50KSkge1xuICAgICAgICAgIHRyYW5zaXRpb24uZXhpdFNldC5wdXNoKHNuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfNV8xKSB7XG4gICAgICBlXzUgPSB7XG4gICAgICAgIGVycm9yOiBlXzVfMVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHByZXZDb25maWdfMV8xICYmICFwcmV2Q29uZmlnXzFfMS5kb25lICYmIChfYiA9IHByZXZDb25maWdfMS5yZXR1cm4pKSBfYi5jYWxsKHByZXZDb25maWdfMSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJhbnNpdGlvbi5leGl0U2V0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBiLm9yZGVyIC0gYS5vcmRlcjtcbiAgICB9KTtcbiAgICB2YXIgZW50cnlTdGF0ZXMgPSBBcnJheS5mcm9tKGVudHJ5U2V0KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gICAgfSk7XG4gICAgdmFyIGV4aXRTdGF0ZXMgPSBuZXcgU2V0KHRyYW5zaXRpb24uZXhpdFNldCk7XG4gICAgdmFyIGRvbmVFdmVudHMgPSBmbGF0dGVuKGVudHJ5U3RhdGVzLm1hcChmdW5jdGlvbiAoc24pIHtcbiAgICAgIHZhciBldmVudHMgPSBbXTtcblxuICAgICAgaWYgKHNuLnR5cGUgIT09ICdmaW5hbCcpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudCA9IHNuLnBhcmVudDtcblxuICAgICAgaWYgKCFwYXJlbnQucGFyZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudHM7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50cy5wdXNoKGRvbmUoc24uaWQsIHNuLmRvbmVEYXRhKSwgLy8gVE9ETzogZGVwcmVjYXRlIC0gZmluYWwgc3RhdGVzIHNob3VsZCBub3QgZW1pdCBkb25lIGV2ZW50cyBmb3IgdGhlaXIgb3duIHN0YXRlLlxuICAgICAgZG9uZShwYXJlbnQuaWQsIHNuLmRvbmVEYXRhID8gbWFwQ29udGV4dChzbi5kb25lRGF0YSwgY3VycmVudENvbnRleHQsIF9ldmVudCkgOiB1bmRlZmluZWQpKTtcbiAgICAgIHZhciBncmFuZHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG5cbiAgICAgIGlmIChncmFuZHBhcmVudC50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgICAgIGlmIChnZXRDaGlsZHJlbihncmFuZHBhcmVudCkuZXZlcnkoZnVuY3Rpb24gKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gaXNJbkZpbmFsU3RhdGUodHJhbnNpdGlvbi5jb25maWd1cmF0aW9uLCBwYXJlbnROb2RlKTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBldmVudHMucHVzaChkb25lKGdyYW5kcGFyZW50LmlkKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICB9KSk7XG4gICAgdmFyIGVudHJ5QWN0aW9ucyA9IGVudHJ5U3RhdGVzLm1hcChmdW5jdGlvbiAoc3RhdGVOb2RlKSB7XG4gICAgICB2YXIgZW50cnlBY3Rpb25zID0gc3RhdGVOb2RlLm9uRW50cnk7XG4gICAgICB2YXIgaW52b2tlQWN0aW9ucyA9IHN0YXRlTm9kZS5hY3Rpdml0aWVzLm1hcChmdW5jdGlvbiAoYWN0aXZpdHkpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0KGFjdGl2aXR5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2VudHJ5JyxcbiAgICAgICAgYWN0aW9uczogdG9BY3Rpb25PYmplY3RzKHByZWRpY3RhYmxlRXhlYyA/IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGVudHJ5QWN0aW9ucyksIGZhbHNlKSwgX19yZWFkKGludm9rZUFjdGlvbnMpLCBmYWxzZSkgOiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChpbnZva2VBY3Rpb25zKSwgZmFsc2UpLCBfX3JlYWQoZW50cnlBY3Rpb25zKSwgZmFsc2UpLCBfdGhpcy5tYWNoaW5lLm9wdGlvbnMuYWN0aW9ucylcbiAgICAgIH07XG4gICAgfSkuY29uY2F0KHtcbiAgICAgIHR5cGU6ICdzdGF0ZV9kb25lJyxcbiAgICAgIGFjdGlvbnM6IGRvbmVFdmVudHMubWFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gcmFpc2UoZXZlbnQpO1xuICAgICAgfSlcbiAgICB9KTtcbiAgICB2YXIgZXhpdEFjdGlvbnMgPSBBcnJheS5mcm9tKGV4aXRTdGF0ZXMpLm1hcChmdW5jdGlvbiAoc3RhdGVOb2RlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZXhpdCcsXG4gICAgICAgIGFjdGlvbnM6IHRvQWN0aW9uT2JqZWN0cyhfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChzdGF0ZU5vZGUub25FeGl0KSwgZmFsc2UpLCBfX3JlYWQoc3RhdGVOb2RlLmFjdGl2aXRpZXMubWFwKGZ1bmN0aW9uIChhY3Rpdml0eSkge1xuICAgICAgICAgIHJldHVybiBzdG9wKGFjdGl2aXR5KTtcbiAgICAgICAgfSkpLCBmYWxzZSksIF90aGlzLm1hY2hpbmUub3B0aW9ucy5hY3Rpb25zKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgYWN0aW9ucyA9IGV4aXRBY3Rpb25zLmNvbmNhdCh7XG4gICAgICB0eXBlOiAndHJhbnNpdGlvbicsXG4gICAgICBhY3Rpb25zOiB0b0FjdGlvbk9iamVjdHModHJhbnNpdGlvbi5hY3Rpb25zLCB0aGlzLm1hY2hpbmUub3B0aW9ucy5hY3Rpb25zKVxuICAgIH0pLmNvbmNhdChlbnRyeUFjdGlvbnMpO1xuXG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgdmFyIHN0b3BBY3Rpb25zID0gdG9BY3Rpb25PYmplY3RzKGZsYXR0ZW4oX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHJlc29sdmVkQ29uZmlnKSwgZmFsc2UpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIub3JkZXIgLSBhLm9yZGVyO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChzdGF0ZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlTm9kZS5vbkV4aXQ7XG4gICAgICB9KSksIHRoaXMubWFjaGluZS5vcHRpb25zLmFjdGlvbnMpLmZpbHRlcihmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhaXNSYWlzYWJsZUFjdGlvbihhY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWN0aW9ucy5jb25jYXQoe1xuICAgICAgICB0eXBlOiAnc3RvcCcsXG4gICAgICAgIGFjdGlvbnM6IHN0b3BBY3Rpb25zXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9ucztcbiAgfTtcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyB0aGUgbmV4dCBzdGF0ZSBnaXZlbiB0aGUgY3VycmVudCBgc3RhdGVgIGFuZCBzZW50IGBldmVudGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc3RhdGUgVGhlIGN1cnJlbnQgU3RhdGUgaW5zdGFuY2Ugb3Igc3RhdGUgdmFsdWVcclxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRoYXQgd2FzIHNlbnQgYXQgdGhlIGN1cnJlbnQgc3RhdGVcclxuICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IChleHRlbmRlZCBzdGF0ZSkgb2YgdGhlIGN1cnJlbnQgc3RhdGVcclxuICAgKi9cblxuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUudHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChzdGF0ZSwgZXZlbnQsIGNvbnRleHQsIGV4ZWMpIHtcbiAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgc3RhdGUgPSB0aGlzLmluaXRpYWxTdGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgX2V2ZW50ID0gdG9TQ1hNTEV2ZW50KGV2ZW50KTtcblxuICAgIHZhciBjdXJyZW50U3RhdGU7XG5cbiAgICBpZiAoc3RhdGUgaW5zdGFuY2VvZiBTdGF0ZSkge1xuICAgICAgY3VycmVudFN0YXRlID0gY29udGV4dCA9PT0gdW5kZWZpbmVkID8gc3RhdGUgOiB0aGlzLnJlc29sdmVTdGF0ZShTdGF0ZS5mcm9tKHN0YXRlLCBjb250ZXh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXNvbHZlZFN0YXRlVmFsdWUgPSBpc1N0cmluZyhzdGF0ZSkgPyB0aGlzLnJlc29sdmUocGF0aFRvU3RhdGVWYWx1ZSh0aGlzLmdldFJlc29sdmVkUGF0aChzdGF0ZSkpKSA6IHRoaXMucmVzb2x2ZShzdGF0ZSk7XG4gICAgICB2YXIgcmVzb2x2ZWRDb250ZXh0ID0gY29udGV4dCAhPT0gbnVsbCAmJiBjb250ZXh0ICE9PSB2b2lkIDAgPyBjb250ZXh0IDogdGhpcy5tYWNoaW5lLmNvbnRleHQ7XG4gICAgICBjdXJyZW50U3RhdGUgPSB0aGlzLnJlc29sdmVTdGF0ZShTdGF0ZS5mcm9tKHJlc29sdmVkU3RhdGVWYWx1ZSwgcmVzb2x2ZWRDb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKCFJU19QUk9EVUNUSU9OICYmIF9ldmVudC5uYW1lID09PSBXSUxEQ0FSRCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gZXZlbnQgY2Fubm90IGhhdmUgdGhlIHdpbGRjYXJkIHR5cGUgKCdcIi5jb25jYXQoV0lMRENBUkQsIFwiJylcIikpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0cmljdCkge1xuICAgICAgaWYgKCF0aGlzLmV2ZW50cy5pbmNsdWRlcyhfZXZlbnQubmFtZSkgJiYgIWlzQnVpbHRJbkV2ZW50KF9ldmVudC5uYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNoaW5lICdcIi5jb25jYXQodGhpcy5pZCwgXCInIGRvZXMgbm90IGFjY2VwdCBldmVudCAnXCIpLmNvbmNhdChfZXZlbnQubmFtZSwgXCInXCIpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3RhdGVUcmFuc2l0aW9uID0gdGhpcy5fdHJhbnNpdGlvbihjdXJyZW50U3RhdGUudmFsdWUsIGN1cnJlbnRTdGF0ZSwgX2V2ZW50KSB8fCB7XG4gICAgICB0cmFuc2l0aW9uczogW10sXG4gICAgICBjb25maWd1cmF0aW9uOiBbXSxcbiAgICAgIGV4aXRTZXQ6IFtdLFxuICAgICAgc291cmNlOiBjdXJyZW50U3RhdGUsXG4gICAgICBhY3Rpb25zOiBbXVxuICAgIH07XG4gICAgdmFyIHByZXZDb25maWcgPSBnZXRDb25maWd1cmF0aW9uKFtdLCB0aGlzLmdldFN0YXRlTm9kZXMoY3VycmVudFN0YXRlLnZhbHVlKSk7XG4gICAgdmFyIHJlc29sdmVkQ29uZmlnID0gc3RhdGVUcmFuc2l0aW9uLmNvbmZpZ3VyYXRpb24ubGVuZ3RoID8gZ2V0Q29uZmlndXJhdGlvbihwcmV2Q29uZmlnLCBzdGF0ZVRyYW5zaXRpb24uY29uZmlndXJhdGlvbikgOiBwcmV2Q29uZmlnO1xuICAgIHN0YXRlVHJhbnNpdGlvbi5jb25maWd1cmF0aW9uID0gX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHJlc29sdmVkQ29uZmlnKSwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVUcmFuc2l0aW9uKHN0YXRlVHJhbnNpdGlvbiwgY3VycmVudFN0YXRlLCBjdXJyZW50U3RhdGUuY29udGV4dCwgZXhlYywgX2V2ZW50KTtcbiAgfTtcblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLnJlc29sdmVSYWlzZWRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHN0YXRlLCBfZXZlbnQsIG9yaWdpbmFsRXZlbnQsIHByZWRpY3RhYmxlRXhlYykge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBjdXJyZW50QWN0aW9ucyA9IHN0YXRlLmFjdGlvbnM7XG4gICAgc3RhdGUgPSB0aGlzLnRyYW5zaXRpb24oc3RhdGUsIF9ldmVudCwgdW5kZWZpbmVkLCBwcmVkaWN0YWJsZUV4ZWMpOyAvLyBTYXZlIG9yaWdpbmFsIGV2ZW50IHRvIHN0YXRlXG4gICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgdGhlIHJhaXNlZCBldmVudCEgRGVsZXRlIGluIFY1IChicmVha2luZylcblxuICAgIHN0YXRlLl9ldmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gICAgc3RhdGUuZXZlbnQgPSBvcmlnaW5hbEV2ZW50LmRhdGE7XG5cbiAgICAoX2EgPSBzdGF0ZS5hY3Rpb25zKS51bnNoaWZ0LmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoY3VycmVudEFjdGlvbnMpLCBmYWxzZSkpO1xuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9O1xuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUucmVzb2x2ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoc3RhdGVUcmFuc2l0aW9uLCBjdXJyZW50U3RhdGUsIGNvbnRleHQsIHByZWRpY3RhYmxlRXhlYywgX2V2ZW50KSB7XG4gICAgdmFyIGVfNiwgX2EsIGVfNywgX2I7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKF9ldmVudCA9PT0gdm9pZCAwKSB7XG4gICAgICBfZXZlbnQgPSBpbml0RXZlbnQ7XG4gICAgfVxuXG4gICAgdmFyIGNvbmZpZ3VyYXRpb24gPSBzdGF0ZVRyYW5zaXRpb24uY29uZmlndXJhdGlvbjsgLy8gVHJhbnNpdGlvbiB3aWxsIFwiYXBwbHlcIiBpZjpcbiAgICAvLyAtIHRoaXMgaXMgdGhlIGluaXRpYWwgc3RhdGUgKHRoZXJlIGlzIG5vIGN1cnJlbnQgc3RhdGUpXG4gICAgLy8gLSBPUiB0aGVyZSBhcmUgdHJhbnNpdGlvbnNcblxuICAgIHZhciB3aWxsVHJhbnNpdGlvbiA9ICFjdXJyZW50U3RhdGUgfHwgc3RhdGVUcmFuc2l0aW9uLnRyYW5zaXRpb25zLmxlbmd0aCA+IDA7XG4gICAgdmFyIHJlc29sdmVkQ29uZmlndXJhdGlvbiA9IHdpbGxUcmFuc2l0aW9uID8gc3RhdGVUcmFuc2l0aW9uLmNvbmZpZ3VyYXRpb24gOiBjdXJyZW50U3RhdGUgPyBjdXJyZW50U3RhdGUuY29uZmlndXJhdGlvbiA6IFtdO1xuICAgIHZhciBpc0RvbmUgPSBpc0luRmluYWxTdGF0ZShyZXNvbHZlZENvbmZpZ3VyYXRpb24sIHRoaXMpO1xuICAgIHZhciByZXNvbHZlZFN0YXRlVmFsdWUgPSB3aWxsVHJhbnNpdGlvbiA/IGdldFZhbHVlKHRoaXMubWFjaGluZSwgY29uZmlndXJhdGlvbikgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGhpc3RvcnlWYWx1ZSA9IGN1cnJlbnRTdGF0ZSA/IGN1cnJlbnRTdGF0ZS5oaXN0b3J5VmFsdWUgPyBjdXJyZW50U3RhdGUuaGlzdG9yeVZhbHVlIDogc3RhdGVUcmFuc2l0aW9uLnNvdXJjZSA/IHRoaXMubWFjaGluZS5oaXN0b3J5VmFsdWUoY3VycmVudFN0YXRlLnZhbHVlKSA6IHVuZGVmaW5lZCA6IHVuZGVmaW5lZDtcbiAgICB2YXIgYWN0aW9uQmxvY2tzID0gdGhpcy5nZXRBY3Rpb25zKG5ldyBTZXQocmVzb2x2ZWRDb25maWd1cmF0aW9uKSwgaXNEb25lLCBzdGF0ZVRyYW5zaXRpb24sIGNvbnRleHQsIF9ldmVudCwgY3VycmVudFN0YXRlLCBwcmVkaWN0YWJsZUV4ZWMpO1xuICAgIHZhciBhY3Rpdml0aWVzID0gY3VycmVudFN0YXRlID8gX19hc3NpZ24oe30sIGN1cnJlbnRTdGF0ZS5hY3Rpdml0aWVzKSA6IHt9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIGFjdGlvbkJsb2Nrc18xID0gX192YWx1ZXMoYWN0aW9uQmxvY2tzKSwgYWN0aW9uQmxvY2tzXzFfMSA9IGFjdGlvbkJsb2Nrc18xLm5leHQoKTsgIWFjdGlvbkJsb2Nrc18xXzEuZG9uZTsgYWN0aW9uQmxvY2tzXzFfMSA9IGFjdGlvbkJsb2Nrc18xLm5leHQoKSkge1xuICAgICAgICB2YXIgYmxvY2sgPSBhY3Rpb25CbG9ja3NfMV8xLnZhbHVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2MgPSAoZV83ID0gdm9pZCAwLCBfX3ZhbHVlcyhibG9jay5hY3Rpb25zKSksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBfZC52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSBzdGFydCQxKSB7XG4gICAgICAgICAgICAgIGFjdGl2aXRpZXNbYWN0aW9uLmFjdGl2aXR5LmlkIHx8IGFjdGlvbi5hY3Rpdml0eS50eXBlXSA9IGFjdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uLnR5cGUgPT09IHN0b3AkMSkge1xuICAgICAgICAgICAgICBhY3Rpdml0aWVzW2FjdGlvbi5hY3Rpdml0eS5pZCB8fCBhY3Rpb24uYWN0aXZpdHkudHlwZV0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVfN18xKSB7XG4gICAgICAgICAgZV83ID0ge1xuICAgICAgICAgICAgZXJyb3I6IGVfN18xXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYiA9IF9jLnJldHVybikpIF9iLmNhbGwoX2MpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZV83KSB0aHJvdyBlXzcuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZV82XzEpIHtcbiAgICAgIGVfNiA9IHtcbiAgICAgICAgZXJyb3I6IGVfNl8xXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoYWN0aW9uQmxvY2tzXzFfMSAmJiAhYWN0aW9uQmxvY2tzXzFfMS5kb25lICYmIChfYSA9IGFjdGlvbkJsb2Nrc18xLnJldHVybikpIF9hLmNhbGwoYWN0aW9uQmxvY2tzXzEpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVfNikgdGhyb3cgZV82LmVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfZSA9IF9fcmVhZChyZXNvbHZlQWN0aW9ucyh0aGlzLCBjdXJyZW50U3RhdGUsIGNvbnRleHQsIF9ldmVudCwgYWN0aW9uQmxvY2tzLCBwcmVkaWN0YWJsZUV4ZWMsIHRoaXMubWFjaGluZS5jb25maWcucHJlZGljdGFibGVBY3Rpb25Bcmd1bWVudHMgfHwgdGhpcy5tYWNoaW5lLmNvbmZpZy5wcmVzZXJ2ZUFjdGlvbk9yZGVyKSwgMiksXG4gICAgICAgIHJlc29sdmVkQWN0aW9ucyA9IF9lWzBdLFxuICAgICAgICB1cGRhdGVkQ29udGV4dCA9IF9lWzFdO1xuXG4gICAgdmFyIF9mID0gX19yZWFkKHBhcnRpdGlvbihyZXNvbHZlZEFjdGlvbnMsIGlzUmFpc2FibGVBY3Rpb24pLCAyKSxcbiAgICAgICAgcmFpc2VkRXZlbnRzID0gX2ZbMF0sXG4gICAgICAgIG5vblJhaXNlZEFjdGlvbnMgPSBfZlsxXTtcblxuICAgIHZhciBpbnZva2VBY3Rpb25zID0gcmVzb2x2ZWRBY3Rpb25zLmZpbHRlcihmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICB2YXIgX2E7XG5cbiAgICAgIHJldHVybiBhY3Rpb24udHlwZSA9PT0gc3RhcnQkMSAmJiAoKF9hID0gYWN0aW9uLmFjdGl2aXR5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IGludm9rZTtcbiAgICB9KTtcbiAgICB2YXIgY2hpbGRyZW4gPSBpbnZva2VBY3Rpb25zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhY3Rpb24pIHtcbiAgICAgIGFjY1thY3Rpb24uYWN0aXZpdHkuaWRdID0gY3JlYXRlSW52b2NhYmxlQWN0b3IoYWN0aW9uLmFjdGl2aXR5LCBfdGhpcy5tYWNoaW5lLCB1cGRhdGVkQ29udGV4dCwgX2V2ZW50KTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgY3VycmVudFN0YXRlID8gX19hc3NpZ24oe30sIGN1cnJlbnRTdGF0ZS5jaGlsZHJlbikgOiB7fSk7XG4gICAgdmFyIG5leHRTdGF0ZSA9IG5ldyBTdGF0ZSh7XG4gICAgICB2YWx1ZTogcmVzb2x2ZWRTdGF0ZVZhbHVlIHx8IGN1cnJlbnRTdGF0ZS52YWx1ZSxcbiAgICAgIGNvbnRleHQ6IHVwZGF0ZWRDb250ZXh0LFxuICAgICAgX2V2ZW50OiBfZXZlbnQsXG4gICAgICAvLyBQZXJzaXN0IF9zZXNzaW9uaWQgYmV0d2VlbiBzdGF0ZXNcbiAgICAgIF9zZXNzaW9uaWQ6IGN1cnJlbnRTdGF0ZSA/IGN1cnJlbnRTdGF0ZS5fc2Vzc2lvbmlkIDogbnVsbCxcbiAgICAgIGhpc3RvcnlWYWx1ZTogcmVzb2x2ZWRTdGF0ZVZhbHVlID8gaGlzdG9yeVZhbHVlID8gdXBkYXRlSGlzdG9yeVZhbHVlKGhpc3RvcnlWYWx1ZSwgcmVzb2x2ZWRTdGF0ZVZhbHVlKSA6IHVuZGVmaW5lZCA6IGN1cnJlbnRTdGF0ZSA/IGN1cnJlbnRTdGF0ZS5oaXN0b3J5VmFsdWUgOiB1bmRlZmluZWQsXG4gICAgICBoaXN0b3J5OiAhcmVzb2x2ZWRTdGF0ZVZhbHVlIHx8IHN0YXRlVHJhbnNpdGlvbi5zb3VyY2UgPyBjdXJyZW50U3RhdGUgOiB1bmRlZmluZWQsXG4gICAgICBhY3Rpb25zOiByZXNvbHZlZFN0YXRlVmFsdWUgPyBub25SYWlzZWRBY3Rpb25zIDogW10sXG4gICAgICBhY3Rpdml0aWVzOiByZXNvbHZlZFN0YXRlVmFsdWUgPyBhY3Rpdml0aWVzIDogY3VycmVudFN0YXRlID8gY3VycmVudFN0YXRlLmFjdGl2aXRpZXMgOiB7fSxcbiAgICAgIGV2ZW50czogW10sXG4gICAgICBjb25maWd1cmF0aW9uOiByZXNvbHZlZENvbmZpZ3VyYXRpb24sXG4gICAgICB0cmFuc2l0aW9uczogc3RhdGVUcmFuc2l0aW9uLnRyYW5zaXRpb25zLFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgZG9uZTogaXNEb25lLFxuICAgICAgdGFnczogZ2V0VGFnc0Zyb21Db25maWd1cmF0aW9uKHJlc29sdmVkQ29uZmlndXJhdGlvbiksXG4gICAgICBtYWNoaW5lOiB0aGlzXG4gICAgfSk7XG4gICAgdmFyIGRpZFVwZGF0ZUNvbnRleHQgPSBjb250ZXh0ICE9PSB1cGRhdGVkQ29udGV4dDtcbiAgICBuZXh0U3RhdGUuY2hhbmdlZCA9IF9ldmVudC5uYW1lID09PSB1cGRhdGUgfHwgZGlkVXBkYXRlQ29udGV4dDsgLy8gRGlzcG9zZSBvZiBwZW51bHRpbWF0ZSBoaXN0b3JpZXMgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcblxuICAgIHZhciBoaXN0b3J5ID0gbmV4dFN0YXRlLmhpc3Rvcnk7XG5cbiAgICBpZiAoaGlzdG9yeSkge1xuICAgICAgZGVsZXRlIGhpc3RvcnkuaGlzdG9yeTtcbiAgICB9IC8vIFRoZXJlIGFyZSB0cmFuc2llbnQgdHJhbnNpdGlvbnMgaWYgdGhlIG1hY2hpbmUgaXMgbm90IGluIGEgZmluYWwgc3RhdGVcbiAgICAvLyBhbmQgaWYgc29tZSBvZiB0aGUgc3RhdGUgbm9kZXMgaGF2ZSB0cmFuc2llbnQgKFwiYWx3YXlzXCIpIHRyYW5zaXRpb25zLlxuXG5cbiAgICB2YXIgaGFzQWx3YXlzVHJhbnNpdGlvbnMgPSAhaXNEb25lICYmICh0aGlzLl90cmFuc2llbnQgfHwgY29uZmlndXJhdGlvbi5zb21lKGZ1bmN0aW9uIChzdGF0ZU5vZGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZU5vZGUuX3RyYW5zaWVudDtcbiAgICB9KSk7IC8vIElmIHRoZXJlIGFyZSBubyBlbmFibGVkIHRyYW5zaXRpb25zLCBjaGVjayBpZiB0aGVyZSBhcmUgdHJhbnNpZW50IHRyYW5zaXRpb25zLlxuICAgIC8vIElmIHRoZXJlIGFyZSB0cmFuc2llbnQgdHJhbnNpdGlvbnMsIGNvbnRpbnVlIGNoZWNraW5nIGZvciBtb3JlIHRyYW5zaXRpb25zXG4gICAgLy8gYmVjYXVzZSBhbiB0cmFuc2llbnQgdHJhbnNpdGlvbiBzaG91bGQgYmUgdHJpZ2dlcmVkIGV2ZW4gaWYgdGhlcmUgYXJlIG5vXG4gICAgLy8gZW5hYmxlZCB0cmFuc2l0aW9ucy5cbiAgICAvL1xuICAgIC8vIElmIHdlJ3JlIGFscmVhZHkgd29ya2luZyBvbiBhbiB0cmFuc2llbnQgdHJhbnNpdGlvbiB0aGVuIHN0b3AgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLlxuICAgIC8vXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGVyZSBhcmUgbm8gZW5hYmxlZCBub3IgdHJhbnNpZW50IHRyYW5zaXRpb25zLCB3ZSBhcmUgZG9uZS5cblxuICAgIGlmICghd2lsbFRyYW5zaXRpb24gJiYgKCFoYXNBbHdheXNUcmFuc2l0aW9ucyB8fCBfZXZlbnQubmFtZSA9PT0gTlVMTF9FVkVOVCkpIHtcbiAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlTmV4dFN0YXRlID0gbmV4dFN0YXRlO1xuXG4gICAgaWYgKCFpc0RvbmUpIHtcbiAgICAgIGlmIChoYXNBbHdheXNUcmFuc2l0aW9ucykge1xuICAgICAgICBtYXliZU5leHRTdGF0ZSA9IHRoaXMucmVzb2x2ZVJhaXNlZFRyYW5zaXRpb24obWF5YmVOZXh0U3RhdGUsIHtcbiAgICAgICAgICB0eXBlOiBudWxsRXZlbnRcbiAgICAgICAgfSwgX2V2ZW50LCBwcmVkaWN0YWJsZUV4ZWMpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAocmFpc2VkRXZlbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgcmFpc2VkRXZlbnQgPSByYWlzZWRFdmVudHMuc2hpZnQoKTtcbiAgICAgICAgbWF5YmVOZXh0U3RhdGUgPSB0aGlzLnJlc29sdmVSYWlzZWRUcmFuc2l0aW9uKG1heWJlTmV4dFN0YXRlLCByYWlzZWRFdmVudC5fZXZlbnQsIF9ldmVudCwgcHJlZGljdGFibGVFeGVjKTtcbiAgICAgIH1cbiAgICB9IC8vIERldGVjdCBpZiBzdGF0ZSBjaGFuZ2VkXG5cblxuICAgIHZhciBjaGFuZ2VkID0gbWF5YmVOZXh0U3RhdGUuY2hhbmdlZCB8fCAoaGlzdG9yeSA/ICEhbWF5YmVOZXh0U3RhdGUuYWN0aW9ucy5sZW5ndGggfHwgZGlkVXBkYXRlQ29udGV4dCB8fCB0eXBlb2YgaGlzdG9yeS52YWx1ZSAhPT0gdHlwZW9mIG1heWJlTmV4dFN0YXRlLnZhbHVlIHx8ICFzdGF0ZVZhbHVlc0VxdWFsKG1heWJlTmV4dFN0YXRlLnZhbHVlLCBoaXN0b3J5LnZhbHVlKSA6IHVuZGVmaW5lZCk7XG4gICAgbWF5YmVOZXh0U3RhdGUuY2hhbmdlZCA9IGNoYW5nZWQ7IC8vIFByZXNlcnZlIG9yaWdpbmFsIGhpc3RvcnkgYWZ0ZXIgcmFpc2VkIGV2ZW50c1xuXG4gICAgbWF5YmVOZXh0U3RhdGUuaGlzdG9yeSA9IGhpc3Rvcnk7XG4gICAgcmV0dXJuIG1heWJlTmV4dFN0YXRlO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBjaGlsZCBzdGF0ZSBub2RlIGZyb20gaXRzIHJlbGF0aXZlIGBzdGF0ZUtleWAsIG9yIHRocm93cy5cclxuICAgKi9cblxuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuZ2V0U3RhdGVOb2RlID0gZnVuY3Rpb24gKHN0YXRlS2V5KSB7XG4gICAgaWYgKGlzU3RhdGVJZChzdGF0ZUtleSkpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hY2hpbmUuZ2V0U3RhdGVOb2RlQnlJZChzdGF0ZUtleSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN0YXRlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJldHJpZXZlIGNoaWxkIHN0YXRlICdcIi5jb25jYXQoc3RhdGVLZXksIFwiJyBmcm9tICdcIikuY29uY2F0KHRoaXMuaWQsIFwiJzsgbm8gY2hpbGQgc3RhdGVzIGV4aXN0LlwiKSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuc3RhdGVzW3N0YXRlS2V5XTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBzdGF0ZSAnXCIuY29uY2F0KHN0YXRlS2V5LCBcIicgZG9lcyBub3QgZXhpc3Qgb24gJ1wiKS5jb25jYXQodGhpcy5pZCwgXCInXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSBub2RlIHdpdGggdGhlIGdpdmVuIGBzdGF0ZUlkYCwgb3IgdGhyb3dzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHN0YXRlSWQgVGhlIHN0YXRlIElELiBUaGUgcHJlZml4IFwiI1wiIGlzIHJlbW92ZWQuXHJcbiAgICovXG5cblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLmdldFN0YXRlTm9kZUJ5SWQgPSBmdW5jdGlvbiAoc3RhdGVJZCkge1xuICAgIHZhciByZXNvbHZlZFN0YXRlSWQgPSBpc1N0YXRlSWQoc3RhdGVJZCkgPyBzdGF0ZUlkLnNsaWNlKFNUQVRFX0lERU5USUZJRVIubGVuZ3RoKSA6IHN0YXRlSWQ7XG5cbiAgICBpZiAocmVzb2x2ZWRTdGF0ZUlkID09PSB0aGlzLmlkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgc3RhdGVOb2RlID0gdGhpcy5tYWNoaW5lLmlkTWFwW3Jlc29sdmVkU3RhdGVJZF07XG5cbiAgICBpZiAoIXN0YXRlTm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgc3RhdGUgbm9kZSAnI1wiLmNvbmNhdChyZXNvbHZlZFN0YXRlSWQsIFwiJyBkb2VzIG5vdCBleGlzdCBvbiBtYWNoaW5lICdcIikuY29uY2F0KHRoaXMuaWQsIFwiJ1wiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlTm9kZTtcbiAgfTtcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgcmVsYXRpdmUgc3RhdGUgbm9kZSBmcm9tIHRoZSBnaXZlbiBgc3RhdGVQYXRoYCwgb3IgdGhyb3dzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHN0YXRlUGF0aCBUaGUgc3RyaW5nIG9yIHN0cmluZyBhcnJheSByZWxhdGl2ZSBwYXRoIHRvIHRoZSBzdGF0ZSBub2RlLlxyXG4gICAqL1xuXG5cbiAgU3RhdGVOb2RlLnByb3RvdHlwZS5nZXRTdGF0ZU5vZGVCeVBhdGggPSBmdW5jdGlvbiAoc3RhdGVQYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZVBhdGggPT09ICdzdHJpbmcnICYmIGlzU3RhdGVJZChzdGF0ZVBhdGgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZU5vZGVCeUlkKHN0YXRlUGF0aC5zbGljZSgxKSk7XG4gICAgICB9IGNhdGNoIChlKSB7Ly8gdHJ5IGluZGl2aWR1YWwgcGF0aHNcbiAgICAgICAgLy8gdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyYXlTdGF0ZVBhdGggPSB0b1N0YXRlUGF0aChzdGF0ZVBhdGgsIHRoaXMuZGVsaW1pdGVyKS5zbGljZSgpO1xuICAgIHZhciBjdXJyZW50U3RhdGVOb2RlID0gdGhpcztcblxuICAgIHdoaWxlIChhcnJheVN0YXRlUGF0aC5sZW5ndGgpIHtcbiAgICAgIHZhciBrZXkgPSBhcnJheVN0YXRlUGF0aC5zaGlmdCgpO1xuXG4gICAgICBpZiAoIWtleS5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRTdGF0ZU5vZGUgPSBjdXJyZW50U3RhdGVOb2RlLmdldFN0YXRlTm9kZShrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50U3RhdGVOb2RlO1xuICB9O1xuICAvKipcclxuICAgKiBSZXNvbHZlcyBhIHBhcnRpYWwgc3RhdGUgdmFsdWUgd2l0aCBpdHMgZnVsbCByZXByZXNlbnRhdGlvbiBpbiB0aGlzIG1hY2hpbmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc3RhdGVWYWx1ZSBUaGUgcGFydGlhbCBzdGF0ZSB2YWx1ZSB0byByZXNvbHZlLlxyXG4gICAqL1xuXG5cbiAgU3RhdGVOb2RlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHN0YXRlVmFsdWUpIHtcbiAgICB2YXIgX2E7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCFzdGF0ZVZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsU3RhdGVWYWx1ZSB8fCBFTVBUWV9PQkpFQ1Q7IC8vIFRPRE86IHR5cGUtc3BlY2lmaWMgcHJvcGVydGllc1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlICdwYXJhbGxlbCc6XG4gICAgICAgIHJldHVybiBtYXBWYWx1ZXModGhpcy5pbml0aWFsU3RhdGVWYWx1ZSwgZnVuY3Rpb24gKHN1YlN0YXRlVmFsdWUsIHN1YlN0YXRlS2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHN1YlN0YXRlVmFsdWUgPyBfdGhpcy5nZXRTdGF0ZU5vZGUoc3ViU3RhdGVLZXkpLnJlc29sdmUoc3RhdGVWYWx1ZVtzdWJTdGF0ZUtleV0gfHwgc3ViU3RhdGVWYWx1ZSkgOiBFTVBUWV9PQkpFQ1Q7XG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdjb21wb3VuZCc6XG4gICAgICAgIGlmIChpc1N0cmluZyhzdGF0ZVZhbHVlKSkge1xuICAgICAgICAgIHZhciBzdWJTdGF0ZU5vZGUgPSB0aGlzLmdldFN0YXRlTm9kZShzdGF0ZVZhbHVlKTtcblxuICAgICAgICAgIGlmIChzdWJTdGF0ZU5vZGUudHlwZSA9PT0gJ3BhcmFsbGVsJyB8fCBzdWJTdGF0ZU5vZGUudHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgICAgICAgcmV0dXJuIF9hID0ge30sIF9hW3N0YXRlVmFsdWVdID0gc3ViU3RhdGVOb2RlLmluaXRpYWxTdGF0ZVZhbHVlLCBfYTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RhdGVWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghT2JqZWN0LmtleXMoc3RhdGVWYWx1ZSkubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFN0YXRlVmFsdWUgfHwge307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFwVmFsdWVzKHN0YXRlVmFsdWUsIGZ1bmN0aW9uIChzdWJTdGF0ZVZhbHVlLCBzdWJTdGF0ZUtleSkge1xuICAgICAgICAgIHJldHVybiBzdWJTdGF0ZVZhbHVlID8gX3RoaXMuZ2V0U3RhdGVOb2RlKHN1YlN0YXRlS2V5KS5yZXNvbHZlKHN1YlN0YXRlVmFsdWUpIDogRU1QVFlfT0JKRUNUO1xuICAgICAgICB9KTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0YXRlVmFsdWUgfHwgRU1QVFlfT0JKRUNUO1xuICAgIH1cbiAgfTtcblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLmdldFJlc29sdmVkUGF0aCA9IGZ1bmN0aW9uIChzdGF0ZUlkZW50aWZpZXIpIHtcbiAgICBpZiAoaXNTdGF0ZUlkKHN0YXRlSWRlbnRpZmllcikpIHtcbiAgICAgIHZhciBzdGF0ZU5vZGUgPSB0aGlzLm1hY2hpbmUuaWRNYXBbc3RhdGVJZGVudGlmaWVyLnNsaWNlKFNUQVRFX0lERU5USUZJRVIubGVuZ3RoKV07XG5cbiAgICAgIGlmICghc3RhdGVOb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHN0YXRlIG5vZGUgJ1wiLmNvbmNhdChzdGF0ZUlkZW50aWZpZXIsIFwiJ1wiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGF0ZU5vZGUucGF0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9TdGF0ZVBhdGgoc3RhdGVJZGVudGlmaWVyLCB0aGlzLmRlbGltaXRlcik7XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlTm9kZS5wcm90b3R5cGUsIFwiaW5pdGlhbFN0YXRlVmFsdWVcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hO1xuXG4gICAgICBpZiAodGhpcy5fX2NhY2hlLmluaXRpYWxTdGF0ZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY2FjaGUuaW5pdGlhbFN0YXRlVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbml0aWFsU3RhdGVWYWx1ZTtcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgICBpbml0aWFsU3RhdGVWYWx1ZSA9IG1hcEZpbHRlclZhbHVlcyh0aGlzLnN0YXRlcywgZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmluaXRpYWxTdGF0ZVZhbHVlIHx8IEVNUFRZX09CSkVDVDtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHN0YXRlTm9kZSkge1xuICAgICAgICAgIHJldHVybiAhKHN0YXRlTm9kZS50eXBlID09PSAnaGlzdG9yeScpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbml0aWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlc1t0aGlzLmluaXRpYWxdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5pdGlhbCBzdGF0ZSAnXCIuY29uY2F0KHRoaXMuaW5pdGlhbCwgXCInIG5vdCBmb3VuZCBvbiAnXCIpLmNvbmNhdCh0aGlzLmtleSwgXCInXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXRpYWxTdGF0ZVZhbHVlID0gaXNMZWFmTm9kZSh0aGlzLnN0YXRlc1t0aGlzLmluaXRpYWxdKSA/IHRoaXMuaW5pdGlhbCA6IChfYSA9IHt9LCBfYVt0aGlzLmluaXRpYWxdID0gdGhpcy5zdGF0ZXNbdGhpcy5pbml0aWFsXS5pbml0aWFsU3RhdGVWYWx1ZSwgX2EpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGZpbml0ZSBzdGF0ZSB2YWx1ZSBvZiBhIG1hY2hpbmUgd2l0aG91dCBjaGlsZCBzdGF0ZXMgaXMganVzdCBhbiBlbXB0eSBvYmplY3RcbiAgICAgICAgaW5pdGlhbFN0YXRlVmFsdWUgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fX2NhY2hlLmluaXRpYWxTdGF0ZVZhbHVlID0gaW5pdGlhbFN0YXRlVmFsdWU7XG4gICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLmluaXRpYWxTdGF0ZVZhbHVlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlVmFsdWUsIGNvbnRleHQpIHtcbiAgICB0aGlzLl9pbml0KCk7IC8vIFRPRE86IHRoaXMgc2hvdWxkIGJlIGluIHRoZSBjb25zdHJ1Y3RvciAoc2VlIG5vdGUgaW4gY29uc3RydWN0b3IpXG5cblxuICAgIHZhciBjb25maWd1cmF0aW9uID0gdGhpcy5nZXRTdGF0ZU5vZGVzKHN0YXRlVmFsdWUpO1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVUcmFuc2l0aW9uKHtcbiAgICAgIGNvbmZpZ3VyYXRpb246IGNvbmZpZ3VyYXRpb24sXG4gICAgICBleGl0U2V0OiBbXSxcbiAgICAgIHRyYW5zaXRpb25zOiBbXSxcbiAgICAgIHNvdXJjZTogdW5kZWZpbmVkLFxuICAgICAgYWN0aW9uczogW11cbiAgICB9LCB1bmRlZmluZWQsIGNvbnRleHQgIT09IG51bGwgJiYgY29udGV4dCAhPT0gdm9pZCAwID8gY29udGV4dCA6IHRoaXMubWFjaGluZS5jb250ZXh0LCB1bmRlZmluZWQpO1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZU5vZGUucHJvdG90eXBlLCBcImluaXRpYWxTdGF0ZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5pdGlhbCBTdGF0ZSBpbnN0YW5jZSwgd2hpY2ggaW5jbHVkZXMgYWxsIGFjdGlvbnMgdG8gYmUgZXhlY3V0ZWQgZnJvbVxyXG4gICAgICogZW50ZXJpbmcgdGhlIGluaXRpYWwgc3RhdGUuXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbml0aWFsU3RhdGVWYWx1ZSA9IHRoaXMuaW5pdGlhbFN0YXRlVmFsdWU7XG5cbiAgICAgIGlmICghaW5pdGlhbFN0YXRlVmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJldHJpZXZlIGluaXRpYWwgc3RhdGUgZnJvbSBzaW1wbGUgc3RhdGUgJ1wiLmNvbmNhdCh0aGlzLmlkLCBcIicuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5pdGlhbFN0YXRlKGluaXRpYWxTdGF0ZVZhbHVlKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlTm9kZS5wcm90b3R5cGUsIFwidGFyZ2V0XCIsIHtcbiAgICAvKipcclxuICAgICAqIFRoZSB0YXJnZXQgc3RhdGUgdmFsdWUgb2YgdGhlIGhpc3Rvcnkgc3RhdGUgbm9kZSwgaWYgaXQgZXhpc3RzLiBUaGlzIHJlcHJlc2VudHMgdGhlXHJcbiAgICAgKiBkZWZhdWx0IHN0YXRlIHZhbHVlIHRvIHRyYW5zaXRpb24gdG8gaWYgbm8gaGlzdG9yeSB2YWx1ZSBleGlzdHMgeWV0LlxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGFyZ2V0O1xuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAnaGlzdG9yeScpIHtcbiAgICAgICAgdmFyIGhpc3RvcnlDb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICBpZiAoaXNTdHJpbmcoaGlzdG9yeUNvbmZpZy50YXJnZXQpKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gaXNTdGF0ZUlkKGhpc3RvcnlDb25maWcudGFyZ2V0KSA/IHBhdGhUb1N0YXRlVmFsdWUodGhpcy5tYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQoaGlzdG9yeUNvbmZpZy50YXJnZXQpLnBhdGguc2xpY2UodGhpcy5wYXRoLmxlbmd0aCAtIDEpKSA6IGhpc3RvcnlDb25maWcudGFyZ2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldCA9IGhpc3RvcnlDb25maWcudGFyZ2V0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGxlYWYgbm9kZXMgZnJvbSBhIHN0YXRlIHBhdGggcmVsYXRpdmUgdG8gdGhpcyBzdGF0ZSBub2RlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHJlbGF0aXZlU3RhdGVJZCBUaGUgcmVsYXRpdmUgc3RhdGUgcGF0aCB0byByZXRyaWV2ZSB0aGUgc3RhdGUgbm9kZXNcclxuICAgKiBAcGFyYW0gaGlzdG9yeSBUaGUgcHJldmlvdXMgc3RhdGUgdG8gcmV0cmlldmUgaGlzdG9yeVxyXG4gICAqIEBwYXJhbSByZXNvbHZlIFdoZXRoZXIgc3RhdGUgbm9kZXMgc2hvdWxkIHJlc29sdmUgdG8gaW5pdGlhbCBjaGlsZCBzdGF0ZSBub2Rlc1xyXG4gICAqL1xuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuZ2V0UmVsYXRpdmVTdGF0ZU5vZGVzID0gZnVuY3Rpb24gKHJlbGF0aXZlU3RhdGVJZCwgaGlzdG9yeVZhbHVlLCByZXNvbHZlKSB7XG4gICAgaWYgKHJlc29sdmUgPT09IHZvaWQgMCkge1xuICAgICAgcmVzb2x2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc29sdmUgPyByZWxhdGl2ZVN0YXRlSWQudHlwZSA9PT0gJ2hpc3RvcnknID8gcmVsYXRpdmVTdGF0ZUlkLnJlc29sdmVIaXN0b3J5KGhpc3RvcnlWYWx1ZSkgOiByZWxhdGl2ZVN0YXRlSWQuaW5pdGlhbFN0YXRlTm9kZXMgOiBbcmVsYXRpdmVTdGF0ZUlkXTtcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVOb2RlLnByb3RvdHlwZSwgXCJpbml0aWFsU3RhdGVOb2Rlc1wiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoaXNMZWFmTm9kZSh0aGlzKSkge1xuICAgICAgICByZXR1cm4gW3RoaXNdO1xuICAgICAgfSAvLyBDYXNlIHdoZW4gc3RhdGUgbm9kZSBpcyBjb21wb3VuZCBidXQgbm8gaW5pdGlhbCBzdGF0ZSBpcyBkZWZpbmVkXG5cblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NvbXBvdW5kJyAmJiAhdGhpcy5pbml0aWFsKSB7XG4gICAgICAgIGlmICghSVNfUFJPRFVDVElPTikge1xuICAgICAgICAgIHdhcm4oZmFsc2UsIFwiQ29tcG91bmQgc3RhdGUgbm9kZSAnXCIuY29uY2F0KHRoaXMuaWQsIFwiJyBoYXMgbm8gaW5pdGlhbCBzdGF0ZS5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluaXRpYWxTdGF0ZU5vZGVQYXRocyA9IHRvU3RhdGVQYXRocyh0aGlzLmluaXRpYWxTdGF0ZVZhbHVlKTtcbiAgICAgIHJldHVybiBmbGF0dGVuKGluaXRpYWxTdGF0ZU5vZGVQYXRocy5tYXAoZnVuY3Rpb24gKGluaXRpYWxQYXRoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5nZXRGcm9tUmVsYXRpdmVQYXRoKGluaXRpYWxQYXRoKTtcbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXHJcbiAgICogUmV0cmlldmVzIHN0YXRlIG5vZGVzIGZyb20gYSByZWxhdGl2ZSBwYXRoIHRvIHRoaXMgc3RhdGUgbm9kZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSByZWxhdGl2ZVBhdGggVGhlIHJlbGF0aXZlIHBhdGggZnJvbSB0aGlzIHN0YXRlIG5vZGVcclxuICAgKiBAcGFyYW0gaGlzdG9yeVZhbHVlXHJcbiAgICovXG5cbiAgU3RhdGVOb2RlLnByb3RvdHlwZS5nZXRGcm9tUmVsYXRpdmVQYXRoID0gZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCkge1xuICAgIGlmICghcmVsYXRpdmVQYXRoLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSBfX3JlYWQocmVsYXRpdmVQYXRoKSxcbiAgICAgICAgc3RhdGVLZXkgPSBfYVswXSxcbiAgICAgICAgY2hpbGRTdGF0ZVBhdGggPSBfYS5zbGljZSgxKTtcblxuICAgIGlmICghdGhpcy5zdGF0ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXRyaWV2ZSBzdWJQYXRoICdcIi5jb25jYXQoc3RhdGVLZXksIFwiJyBmcm9tIG5vZGUgd2l0aCBubyBzdGF0ZXNcIikpO1xuICAgIH1cblxuICAgIHZhciBjaGlsZFN0YXRlTm9kZSA9IHRoaXMuZ2V0U3RhdGVOb2RlKHN0YXRlS2V5KTtcblxuICAgIGlmIChjaGlsZFN0YXRlTm9kZS50eXBlID09PSAnaGlzdG9yeScpIHtcbiAgICAgIHJldHVybiBjaGlsZFN0YXRlTm9kZS5yZXNvbHZlSGlzdG9yeSgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zdGF0ZXNbc3RhdGVLZXldKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBzdGF0ZSAnXCIuY29uY2F0KHN0YXRlS2V5LCBcIicgZG9lcyBub3QgZXhpc3Qgb24gJ1wiKS5jb25jYXQodGhpcy5pZCwgXCInXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdGF0ZXNbc3RhdGVLZXldLmdldEZyb21SZWxhdGl2ZVBhdGgoY2hpbGRTdGF0ZVBhdGgpO1xuICB9O1xuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuaGlzdG9yeVZhbHVlID0gZnVuY3Rpb24gKHJlbGF0aXZlU3RhdGVWYWx1ZSkge1xuICAgIGlmICghT2JqZWN0LmtleXModGhpcy5zdGF0ZXMpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudDogcmVsYXRpdmVTdGF0ZVZhbHVlIHx8IHRoaXMuaW5pdGlhbFN0YXRlVmFsdWUsXG4gICAgICBzdGF0ZXM6IG1hcEZpbHRlclZhbHVlcyh0aGlzLnN0YXRlcywgZnVuY3Rpb24gKHN0YXRlTm9kZSwga2V5KSB7XG4gICAgICAgIGlmICghcmVsYXRpdmVTdGF0ZVZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlTm9kZS5oaXN0b3J5VmFsdWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdWJTdGF0ZVZhbHVlID0gaXNTdHJpbmcocmVsYXRpdmVTdGF0ZVZhbHVlKSA/IHVuZGVmaW5lZCA6IHJlbGF0aXZlU3RhdGVWYWx1ZVtrZXldO1xuICAgICAgICByZXR1cm4gc3RhdGVOb2RlLmhpc3RvcnlWYWx1ZShzdWJTdGF0ZVZhbHVlIHx8IHN0YXRlTm9kZS5pbml0aWFsU3RhdGVWYWx1ZSk7XG4gICAgICB9LCBmdW5jdGlvbiAoc3RhdGVOb2RlKSB7XG4gICAgICAgIHJldHVybiAhc3RhdGVOb2RlLmhpc3Rvcnk7XG4gICAgICB9KVxuICAgIH07XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlc29sdmVzIHRvIHRoZSBoaXN0b3JpY2FsIHZhbHVlKHMpIG9mIHRoZSBwYXJlbnQgc3RhdGUgbm9kZSxcclxuICAgKiByZXByZXNlbnRlZCBieSBzdGF0ZSBub2Rlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBoaXN0b3J5VmFsdWVcclxuICAgKi9cblxuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUucmVzb2x2ZUhpc3RvcnkgPSBmdW5jdGlvbiAoaGlzdG9yeVZhbHVlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdoaXN0b3J5Jykge1xuICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cbiAgICBpZiAoIWhpc3RvcnlWYWx1ZSkge1xuICAgICAgdmFyIGhpc3RvcnlUYXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgIHJldHVybiBoaXN0b3J5VGFyZ2V0ID8gZmxhdHRlbih0b1N0YXRlUGF0aHMoaGlzdG9yeVRhcmdldCkubWFwKGZ1bmN0aW9uIChyZWxhdGl2ZUNoaWxkUGF0aCkge1xuICAgICAgICByZXR1cm4gcGFyZW50LmdldEZyb21SZWxhdGl2ZVBhdGgocmVsYXRpdmVDaGlsZFBhdGgpO1xuICAgICAgfSkpIDogcGFyZW50LmluaXRpYWxTdGF0ZU5vZGVzO1xuICAgIH1cblxuICAgIHZhciBzdWJIaXN0b3J5VmFsdWUgPSBuZXN0ZWRQYXRoKHBhcmVudC5wYXRoLCAnc3RhdGVzJykoaGlzdG9yeVZhbHVlKS5jdXJyZW50O1xuXG4gICAgaWYgKGlzU3RyaW5nKHN1Ykhpc3RvcnlWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBbcGFyZW50LmdldFN0YXRlTm9kZShzdWJIaXN0b3J5VmFsdWUpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmxhdHRlbih0b1N0YXRlUGF0aHMoc3ViSGlzdG9yeVZhbHVlKS5tYXAoZnVuY3Rpb24gKHN1YlN0YXRlUGF0aCkge1xuICAgICAgcmV0dXJuIF90aGlzLmhpc3RvcnkgPT09ICdkZWVwJyA/IHBhcmVudC5nZXRGcm9tUmVsYXRpdmVQYXRoKHN1YlN0YXRlUGF0aCkgOiBbcGFyZW50LnN0YXRlc1tzdWJTdGF0ZVBhdGhbMF1dXTtcbiAgICB9KSk7XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlTm9kZS5wcm90b3R5cGUsIFwic3RhdGVJZHNcIiwge1xuICAgIC8qKlxyXG4gICAgICogQWxsIHRoZSBzdGF0ZSBub2RlIElEcyBvZiB0aGlzIHN0YXRlIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50IHN0YXRlIG5vZGVzLlxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgY2hpbGRTdGF0ZUlkcyA9IGZsYXR0ZW4oT2JqZWN0LmtleXModGhpcy5zdGF0ZXMpLm1hcChmdW5jdGlvbiAoc3RhdGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnN0YXRlc1tzdGF0ZUtleV0uc3RhdGVJZHM7XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gW3RoaXMuaWRdLmNvbmNhdChjaGlsZFN0YXRlSWRzKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlTm9kZS5wcm90b3R5cGUsIFwiZXZlbnRzXCIsIHtcbiAgICAvKipcclxuICAgICAqIEFsbCB0aGUgZXZlbnQgdHlwZXMgYWNjZXB0ZWQgYnkgdGhpcyBzdGF0ZSBub2RlIGFuZCBpdHMgZGVzY2VuZGFudHMuXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlXzgsIF9hLCBlXzksIF9iO1xuXG4gICAgICBpZiAodGhpcy5fX2NhY2hlLmV2ZW50cykge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLmV2ZW50cztcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlcyA9IHRoaXMuc3RhdGVzO1xuICAgICAgdmFyIGV2ZW50cyA9IG5ldyBTZXQodGhpcy5vd25FdmVudHMpO1xuXG4gICAgICBpZiAoc3RhdGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhzdGF0ZXMpKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlSWQgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0YXRlc1tzdGF0ZUlkXTtcblxuICAgICAgICAgICAgaWYgKHN0YXRlLnN0YXRlcykge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9lID0gKGVfOSA9IHZvaWQgMCwgX192YWx1ZXMoc3RhdGUuZXZlbnRzKSksIF9mID0gX2UubmV4dCgpOyAhX2YuZG9uZTsgX2YgPSBfZS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBldmVudF8xID0gX2YudmFsdWU7XG4gICAgICAgICAgICAgICAgICBldmVudHMuYWRkKFwiXCIuY29uY2F0KGV2ZW50XzEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVfOV8xKSB7XG4gICAgICAgICAgICAgICAgZV85ID0ge1xuICAgICAgICAgICAgICAgICAgZXJyb3I6IGVfOV8xXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfYiA9IF9lLnJldHVybikpIF9iLmNhbGwoX2UpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZV85KSB0aHJvdyBlXzkuZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlXzhfMSkge1xuICAgICAgICAgIGVfOCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBlXzhfMVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGVfOCkgdGhyb3cgZV84LmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLmV2ZW50cyA9IEFycmF5LmZyb20oZXZlbnRzKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlTm9kZS5wcm90b3R5cGUsIFwib3duRXZlbnRzXCIsIHtcbiAgICAvKipcclxuICAgICAqIEFsbCB0aGUgZXZlbnRzIHRoYXQgaGF2ZSB0cmFuc2l0aW9ucyBkaXJlY3RseSBmcm9tIHRoaXMgc3RhdGUgbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBFeGNsdWRlcyBhbnkgaW5lcnQgZXZlbnRzLlxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZXZlbnRzID0gbmV3IFNldCh0aGlzLnRyYW5zaXRpb25zLmZpbHRlcihmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gISghdHJhbnNpdGlvbi50YXJnZXQgJiYgIXRyYW5zaXRpb24uYWN0aW9ucy5sZW5ndGggJiYgdHJhbnNpdGlvbi5pbnRlcm5hbCk7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zaXRpb24uZXZlbnRUeXBlO1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZXZlbnRzKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLnJlc29sdmVUYXJnZXQgPSBmdW5jdGlvbiAoX3RhcmdldCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoX3RhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhbiB1bmRlZmluZWQgdGFyZ2V0IHNpZ25hbHMgdGhhdCB0aGUgc3RhdGUgbm9kZSBzaG91bGQgbm90IHRyYW5zaXRpb24gZnJvbSB0aGF0IHN0YXRlIHdoZW4gcmVjZWl2aW5nIHRoYXQgZXZlbnRcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90YXJnZXQubWFwKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGlmICghaXNTdHJpbmcodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNJbnRlcm5hbFRhcmdldCA9IHRhcmdldFswXSA9PT0gX3RoaXMuZGVsaW1pdGVyOyAvLyBJZiBpbnRlcm5hbCB0YXJnZXQgaXMgZGVmaW5lZCBvbiBtYWNoaW5lLFxuICAgICAgLy8gZG8gbm90IGluY2x1ZGUgbWFjaGluZSBrZXkgb24gdGFyZ2V0XG5cbiAgICAgIGlmIChpc0ludGVybmFsVGFyZ2V0ICYmICFfdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmdldFN0YXRlTm9kZUJ5UGF0aCh0YXJnZXQuc2xpY2UoMSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzb2x2ZWRUYXJnZXQgPSBpc0ludGVybmFsVGFyZ2V0ID8gX3RoaXMua2V5ICsgdGFyZ2V0IDogdGFyZ2V0O1xuXG4gICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHRhcmdldFN0YXRlTm9kZSA9IF90aGlzLnBhcmVudC5nZXRTdGF0ZU5vZGVCeVBhdGgocmVzb2x2ZWRUYXJnZXQpO1xuXG4gICAgICAgICAgcmV0dXJuIHRhcmdldFN0YXRlTm9kZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0cmFuc2l0aW9uIGRlZmluaXRpb24gZm9yIHN0YXRlIG5vZGUgJ1wiLmNvbmNhdChfdGhpcy5pZCwgXCInOlxcblwiKS5jb25jYXQoZXJyLm1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmdldFN0YXRlTm9kZUJ5UGF0aChyZXNvbHZlZFRhcmdldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgU3RhdGVOb2RlLnByb3RvdHlwZS5mb3JtYXRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHRyYW5zaXRpb25Db25maWcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG5vcm1hbGl6ZWRUYXJnZXQgPSBub3JtYWxpemVUYXJnZXQodHJhbnNpdGlvbkNvbmZpZy50YXJnZXQpO1xuICAgIHZhciBpbnRlcm5hbCA9ICdpbnRlcm5hbCcgaW4gdHJhbnNpdGlvbkNvbmZpZyA/IHRyYW5zaXRpb25Db25maWcuaW50ZXJuYWwgOiBub3JtYWxpemVkVGFyZ2V0ID8gbm9ybWFsaXplZFRhcmdldC5zb21lKGZ1bmN0aW9uIChfdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gaXNTdHJpbmcoX3RhcmdldCkgJiYgX3RhcmdldFswXSA9PT0gX3RoaXMuZGVsaW1pdGVyO1xuICAgIH0pIDogdHJ1ZTtcbiAgICB2YXIgZ3VhcmRzID0gdGhpcy5tYWNoaW5lLm9wdGlvbnMuZ3VhcmRzO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLnJlc29sdmVUYXJnZXQobm9ybWFsaXplZFRhcmdldCk7XG5cbiAgICB2YXIgdHJhbnNpdGlvbiA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0cmFuc2l0aW9uQ29uZmlnKSwge1xuICAgICAgYWN0aW9uczogdG9BY3Rpb25PYmplY3RzKHRvQXJyYXkodHJhbnNpdGlvbkNvbmZpZy5hY3Rpb25zKSksXG4gICAgICBjb25kOiB0b0d1YXJkKHRyYW5zaXRpb25Db25maWcuY29uZCwgZ3VhcmRzKSxcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgaW50ZXJuYWw6IGludGVybmFsLFxuICAgICAgZXZlbnRUeXBlOiB0cmFuc2l0aW9uQ29uZmlnLmV2ZW50LFxuICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdHJhbnNpdGlvbiksIHtcbiAgICAgICAgICB0YXJnZXQ6IHRyYW5zaXRpb24udGFyZ2V0ID8gdHJhbnNpdGlvbi50YXJnZXQubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gXCIjXCIuY29uY2F0KHQuaWQpO1xuICAgICAgICAgIH0pIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHNvdXJjZTogXCIjXCIuY29uY2F0KF90aGlzLmlkKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0cmFuc2l0aW9uO1xuICB9O1xuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuZm9ybWF0VHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVfMTAsIF9hO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvbkNvbmZpZztcblxuICAgIGlmICghdGhpcy5jb25maWcub24pIHtcbiAgICAgIG9uQ29uZmlnID0gW107XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY29uZmlnLm9uKSkge1xuICAgICAgb25Db25maWcgPSB0aGlzLmNvbmZpZy5vbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9iID0gdGhpcy5jb25maWcub24sXG4gICAgICAgICAgX2MgPSBXSUxEQ0FSRCxcbiAgICAgICAgICBfZCA9IF9iW19jXSxcbiAgICAgICAgICB3aWxkY2FyZENvbmZpZ3MgPSBfZCA9PT0gdm9pZCAwID8gW10gOiBfZCxcbiAgICAgICAgICBzdHJpY3RUcmFuc2l0aW9uQ29uZmlnc18xID0gX19yZXN0KF9iLCBbdHlwZW9mIF9jID09PSBcInN5bWJvbFwiID8gX2MgOiBfYyArIFwiXCJdKTtcblxuICAgICAgb25Db25maWcgPSBmbGF0dGVuKE9iamVjdC5rZXlzKHN0cmljdFRyYW5zaXRpb25Db25maWdzXzEpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghSVNfUFJPRFVDVElPTiAmJiBrZXkgPT09IE5VTExfRVZFTlQpIHtcbiAgICAgICAgICB3YXJuKGZhbHNlLCBcIkVtcHR5IHN0cmluZyB0cmFuc2l0aW9uIGNvbmZpZ3MgKGUuZy4sIGB7IG9uOiB7ICcnOiAuLi4gfX1gKSBmb3IgdHJhbnNpZW50IHRyYW5zaXRpb25zIGFyZSBkZXByZWNhdGVkLiBTcGVjaWZ5IHRoZSB0cmFuc2l0aW9uIGluIHRoZSBgeyBhbHdheXM6IC4uLiB9YCBwcm9wZXJ0eSBpbnN0ZWFkLiBcIiArIFwiUGxlYXNlIGNoZWNrIHRoZSBgb25gIGNvbmZpZ3VyYXRpb24gZm9yIFxcXCIjXCIuY29uY2F0KF90aGlzLmlkLCBcIlxcXCIuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0cmFuc2l0aW9uQ29uZmlnQXJyYXkgPSB0b1RyYW5zaXRpb25Db25maWdBcnJheShrZXksIHN0cmljdFRyYW5zaXRpb25Db25maWdzXzFba2V5XSk7XG5cbiAgICAgICAgaWYgKCFJU19QUk9EVUNUSU9OKSB7XG4gICAgICAgICAgdmFsaWRhdGVBcnJheWlmaWVkVHJhbnNpdGlvbnMoX3RoaXMsIGtleSwgdHJhbnNpdGlvbkNvbmZpZ0FycmF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmFuc2l0aW9uQ29uZmlnQXJyYXk7XG4gICAgICB9KS5jb25jYXQodG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkoV0lMRENBUkQsIHdpbGRjYXJkQ29uZmlncykpKTtcbiAgICB9XG5cbiAgICB2YXIgZXZlbnRsZXNzQ29uZmlnID0gdGhpcy5jb25maWcuYWx3YXlzID8gdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkoJycsIHRoaXMuY29uZmlnLmFsd2F5cykgOiBbXTtcbiAgICB2YXIgZG9uZUNvbmZpZyA9IHRoaXMuY29uZmlnLm9uRG9uZSA/IHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KFN0cmluZyhkb25lKHRoaXMuaWQpKSwgdGhpcy5jb25maWcub25Eb25lKSA6IFtdO1xuXG4gICAgaWYgKCFJU19QUk9EVUNUSU9OKSB7XG4gICAgICB3YXJuKCEodGhpcy5jb25maWcub25Eb25lICYmICF0aGlzLnBhcmVudCksIFwiUm9vdCBub2RlcyBjYW5ub3QgaGF2ZSBhbiBcXFwiLm9uRG9uZVxcXCIgdHJhbnNpdGlvbi4gUGxlYXNlIGNoZWNrIHRoZSBjb25maWcgb2YgXFxcIlwiLmNvbmNhdCh0aGlzLmlkLCBcIlxcXCIuXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgaW52b2tlQ29uZmlnID0gZmxhdHRlbih0aGlzLmludm9rZS5tYXAoZnVuY3Rpb24gKGludm9rZURlZikge1xuICAgICAgdmFyIHNldHRsZVRyYW5zaXRpb25zID0gW107XG5cbiAgICAgIGlmIChpbnZva2VEZWYub25Eb25lKSB7XG4gICAgICAgIHNldHRsZVRyYW5zaXRpb25zLnB1c2guYXBwbHkoc2V0dGxlVHJhbnNpdGlvbnMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZCh0b1RyYW5zaXRpb25Db25maWdBcnJheShTdHJpbmcoZG9uZUludm9rZShpbnZva2VEZWYuaWQpKSwgaW52b2tlRGVmLm9uRG9uZSkpLCBmYWxzZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW52b2tlRGVmLm9uRXJyb3IpIHtcbiAgICAgICAgc2V0dGxlVHJhbnNpdGlvbnMucHVzaC5hcHBseShzZXR0bGVUcmFuc2l0aW9ucywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KFN0cmluZyhlcnJvcihpbnZva2VEZWYuaWQpKSwgaW52b2tlRGVmLm9uRXJyb3IpKSwgZmFsc2UpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldHRsZVRyYW5zaXRpb25zO1xuICAgIH0pKTtcbiAgICB2YXIgZGVsYXllZFRyYW5zaXRpb25zID0gdGhpcy5hZnRlcjtcbiAgICB2YXIgZm9ybWF0dGVkVHJhbnNpdGlvbnMgPSBmbGF0dGVuKF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChkb25lQ29uZmlnKSwgZmFsc2UpLCBfX3JlYWQoaW52b2tlQ29uZmlnKSwgZmFsc2UpLCBfX3JlYWQob25Db25maWcpLCBmYWxzZSksIF9fcmVhZChldmVudGxlc3NDb25maWcpLCBmYWxzZSkubWFwKGZ1bmN0aW9uICh0cmFuc2l0aW9uQ29uZmlnKSB7XG4gICAgICByZXR1cm4gdG9BcnJheSh0cmFuc2l0aW9uQ29uZmlnKS5tYXAoZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmZvcm1hdFRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gICAgICB9KTtcbiAgICB9KSk7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgZGVsYXllZFRyYW5zaXRpb25zXzEgPSBfX3ZhbHVlcyhkZWxheWVkVHJhbnNpdGlvbnMpLCBkZWxheWVkVHJhbnNpdGlvbnNfMV8xID0gZGVsYXllZFRyYW5zaXRpb25zXzEubmV4dCgpOyAhZGVsYXllZFRyYW5zaXRpb25zXzFfMS5kb25lOyBkZWxheWVkVHJhbnNpdGlvbnNfMV8xID0gZGVsYXllZFRyYW5zaXRpb25zXzEubmV4dCgpKSB7XG4gICAgICAgIHZhciBkZWxheWVkVHJhbnNpdGlvbiA9IGRlbGF5ZWRUcmFuc2l0aW9uc18xXzEudmFsdWU7XG4gICAgICAgIGZvcm1hdHRlZFRyYW5zaXRpb25zLnB1c2goZGVsYXllZFRyYW5zaXRpb24pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfMTBfMSkge1xuICAgICAgZV8xMCA9IHtcbiAgICAgICAgZXJyb3I6IGVfMTBfMVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGRlbGF5ZWRUcmFuc2l0aW9uc18xXzEgJiYgIWRlbGF5ZWRUcmFuc2l0aW9uc18xXzEuZG9uZSAmJiAoX2EgPSBkZWxheWVkVHJhbnNpdGlvbnNfMS5yZXR1cm4pKSBfYS5jYWxsKGRlbGF5ZWRUcmFuc2l0aW9uc18xKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzEwKSB0aHJvdyBlXzEwLmVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXR0ZWRUcmFuc2l0aW9ucztcbiAgfTtcblxuICByZXR1cm4gU3RhdGVOb2RlO1xufSgpO1xuXG5leHBvcnQgeyBTdGF0ZU5vZGUgfTtcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxuXG5leHBvcnQgeyBfX2Fzc2lnbiwgX19yZWFkLCBfX3Jlc3QsIF9fc3ByZWFkQXJyYXksIF9fdmFsdWVzIH07XG4iLCJpbXBvcnQgeyBBY3Rpb25UeXBlcyB9IGZyb20gJy4vdHlwZXMuanMnO1xuXG52YXIgc3RhcnQgPSBBY3Rpb25UeXBlcy5TdGFydDtcbnZhciBzdG9wID0gQWN0aW9uVHlwZXMuU3RvcDtcbnZhciByYWlzZSA9IEFjdGlvblR5cGVzLlJhaXNlO1xudmFyIHNlbmQgPSBBY3Rpb25UeXBlcy5TZW5kO1xudmFyIGNhbmNlbCA9IEFjdGlvblR5cGVzLkNhbmNlbDtcbnZhciBudWxsRXZlbnQgPSBBY3Rpb25UeXBlcy5OdWxsRXZlbnQ7XG52YXIgYXNzaWduID0gQWN0aW9uVHlwZXMuQXNzaWduO1xudmFyIGFmdGVyID0gQWN0aW9uVHlwZXMuQWZ0ZXI7XG52YXIgZG9uZVN0YXRlID0gQWN0aW9uVHlwZXMuRG9uZVN0YXRlO1xudmFyIGxvZyA9IEFjdGlvblR5cGVzLkxvZztcbnZhciBpbml0ID0gQWN0aW9uVHlwZXMuSW5pdDtcbnZhciBpbnZva2UgPSBBY3Rpb25UeXBlcy5JbnZva2U7XG52YXIgZXJyb3JFeGVjdXRpb24gPSBBY3Rpb25UeXBlcy5FcnJvckV4ZWN1dGlvbjtcbnZhciBlcnJvclBsYXRmb3JtID0gQWN0aW9uVHlwZXMuRXJyb3JQbGF0Zm9ybTtcbnZhciBlcnJvciA9IEFjdGlvblR5cGVzLkVycm9yQ3VzdG9tO1xudmFyIHVwZGF0ZSA9IEFjdGlvblR5cGVzLlVwZGF0ZTtcbnZhciBjaG9vc2UgPSBBY3Rpb25UeXBlcy5DaG9vc2U7XG52YXIgcHVyZSA9IEFjdGlvblR5cGVzLlB1cmU7XG5cbmV4cG9ydCB7IGFmdGVyLCBhc3NpZ24sIGNhbmNlbCwgY2hvb3NlLCBkb25lU3RhdGUsIGVycm9yLCBlcnJvckV4ZWN1dGlvbiwgZXJyb3JQbGF0Zm9ybSwgaW5pdCwgaW52b2tlLCBsb2csIG51bGxFdmVudCwgcHVyZSwgcmFpc2UsIHNlbmQsIHN0YXJ0LCBzdG9wLCB1cGRhdGUgfTtcbiIsImltcG9ydCB7IF9fYXNzaWduLCBfX3NwcmVhZEFycmF5LCBfX3JlYWQsIF9fdmFsdWVzIH0gZnJvbSAnLi9fdmlydHVhbC9fdHNsaWIuanMnO1xuaW1wb3J0IHsgU3BlY2lhbFRhcmdldHMsIEFjdGlvblR5cGVzIH0gZnJvbSAnLi90eXBlcy5qcyc7XG5pbXBvcnQgeyBpbml0LCByYWlzZSBhcyByYWlzZSQxLCBzZW5kIGFzIHNlbmQkMSwgdXBkYXRlLCBsb2cgYXMgbG9nJDEsIGNhbmNlbCBhcyBjYW5jZWwkMSwgYXNzaWduIGFzIGFzc2lnbiQxLCBlcnJvciBhcyBlcnJvciQxLCBzdG9wIGFzIHN0b3AkMSwgcHVyZSBhcyBwdXJlJDEsIGNob29zZSBhcyBjaG9vc2UkMSB9IGZyb20gJy4vYWN0aW9uVHlwZXMuanMnO1xuaW1wb3J0ICogYXMgYWN0aW9uVHlwZXMgZnJvbSAnLi9hY3Rpb25UeXBlcy5qcyc7XG5leHBvcnQgeyBhY3Rpb25UeXBlcyB9O1xuaW1wb3J0IHsgdG9TQ1hNTEV2ZW50LCBpc1N0cmluZywgaXNGdW5jdGlvbiwgdG9FdmVudE9iamVjdCwgZ2V0RXZlbnRUeXBlLCB1cGRhdGVDb250ZXh0LCBmbGF0dGVuLCBpc0FycmF5LCB0b0FycmF5LCB0b0d1YXJkLCBldmFsdWF0ZUd1YXJkLCB3YXJuIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBJU19QUk9EVUNUSU9OIH0gZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5cbnZhciBpbml0RXZlbnQgPSAvKiNfX1BVUkVfXyovdG9TQ1hNTEV2ZW50KHtcbiAgdHlwZTogaW5pdFxufSk7XG5mdW5jdGlvbiBnZXRBY3Rpb25GdW5jdGlvbihhY3Rpb25UeXBlLCBhY3Rpb25GdW5jdGlvbk1hcCkge1xuICByZXR1cm4gYWN0aW9uRnVuY3Rpb25NYXAgPyBhY3Rpb25GdW5jdGlvbk1hcFthY3Rpb25UeXBlXSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiB0b0FjdGlvbk9iamVjdChhY3Rpb24sIGFjdGlvbkZ1bmN0aW9uTWFwKSB7XG4gIHZhciBhY3Rpb25PYmplY3Q7XG5cbiAgaWYgKGlzU3RyaW5nKGFjdGlvbikgfHwgdHlwZW9mIGFjdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgZXhlYyA9IGdldEFjdGlvbkZ1bmN0aW9uKGFjdGlvbiwgYWN0aW9uRnVuY3Rpb25NYXApO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXhlYykpIHtcbiAgICAgIGFjdGlvbk9iamVjdCA9IHtcbiAgICAgICAgdHlwZTogYWN0aW9uLFxuICAgICAgICBleGVjOiBleGVjXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZXhlYykge1xuICAgICAgYWN0aW9uT2JqZWN0ID0gZXhlYztcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0aW9uT2JqZWN0ID0ge1xuICAgICAgICB0eXBlOiBhY3Rpb24sXG4gICAgICAgIGV4ZWM6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihhY3Rpb24pKSB7XG4gICAgYWN0aW9uT2JqZWN0ID0ge1xuICAgICAgLy8gQ29udmVydCBhY3Rpb24gdG8gc3RyaW5nIGlmIHVubmFtZWRcbiAgICAgIHR5cGU6IGFjdGlvbi5uYW1lIHx8IGFjdGlvbi50b1N0cmluZygpLFxuICAgICAgZXhlYzogYWN0aW9uXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXhlYyA9IGdldEFjdGlvbkZ1bmN0aW9uKGFjdGlvbi50eXBlLCBhY3Rpb25GdW5jdGlvbk1hcCk7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihleGVjKSkge1xuICAgICAgYWN0aW9uT2JqZWN0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGFjdGlvbiksIHtcbiAgICAgICAgZXhlYzogZXhlY1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChleGVjKSB7XG4gICAgICB2YXIgYWN0aW9uVHlwZSA9IGV4ZWMudHlwZSB8fCBhY3Rpb24udHlwZTtcbiAgICAgIGFjdGlvbk9iamVjdCA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBleGVjKSwgYWN0aW9uKSwge1xuICAgICAgICB0eXBlOiBhY3Rpb25UeXBlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0aW9uT2JqZWN0ID0gYWN0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhY3Rpb25PYmplY3Q7XG59XG52YXIgdG9BY3Rpb25PYmplY3RzID0gZnVuY3Rpb24gKGFjdGlvbiwgYWN0aW9uRnVuY3Rpb25NYXApIHtcbiAgaWYgKCFhY3Rpb24pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgYWN0aW9ucyA9IGlzQXJyYXkoYWN0aW9uKSA/IGFjdGlvbiA6IFthY3Rpb25dO1xuICByZXR1cm4gYWN0aW9ucy5tYXAoZnVuY3Rpb24gKHN1YkFjdGlvbikge1xuICAgIHJldHVybiB0b0FjdGlvbk9iamVjdChzdWJBY3Rpb24sIGFjdGlvbkZ1bmN0aW9uTWFwKTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gdG9BY3Rpdml0eURlZmluaXRpb24oYWN0aW9uKSB7XG4gIHZhciBhY3Rpb25PYmplY3QgPSB0b0FjdGlvbk9iamVjdChhY3Rpb24pO1xuICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe1xuICAgIGlkOiBpc1N0cmluZyhhY3Rpb24pID8gYWN0aW9uIDogYWN0aW9uT2JqZWN0LmlkXG4gIH0sIGFjdGlvbk9iamVjdCksIHtcbiAgICB0eXBlOiBhY3Rpb25PYmplY3QudHlwZVxuICB9KTtcbn1cbi8qKlxyXG4gKiBSYWlzZXMgYW4gZXZlbnQuIFRoaXMgcGxhY2VzIHRoZSBldmVudCBpbiB0aGUgaW50ZXJuYWwgZXZlbnQgcXVldWUsIHNvIHRoYXRcclxuICogdGhlIGV2ZW50IGlzIGltbWVkaWF0ZWx5IGNvbnN1bWVkIGJ5IHRoZSBtYWNoaW5lIGluIHRoZSBjdXJyZW50IHN0ZXAuXHJcbiAqXHJcbiAqIEBwYXJhbSBldmVudFR5cGUgVGhlIGV2ZW50IHRvIHJhaXNlLlxyXG4gKi9cblxuZnVuY3Rpb24gcmFpc2UoZXZlbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiByYWlzZSQxLFxuICAgIGV2ZW50OiB0eXBlb2YgZXZlbnQgPT09ICdmdW5jdGlvbicgPyBldmVudCA6IHRvRXZlbnRPYmplY3QoZXZlbnQpLFxuICAgIGRlbGF5OiBvcHRpb25zID8gb3B0aW9ucy5kZWxheSA6IHVuZGVmaW5lZCxcbiAgICBpZDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlkXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlUmFpc2UoYWN0aW9uLCBjdHgsIF9ldmVudCwgZGVsYXlzTWFwKSB7XG4gIHZhciBtZXRhID0ge1xuICAgIF9ldmVudDogX2V2ZW50XG4gIH07XG4gIHZhciByZXNvbHZlZEV2ZW50ID0gdG9TQ1hNTEV2ZW50KGlzRnVuY3Rpb24oYWN0aW9uLmV2ZW50KSA/IGFjdGlvbi5ldmVudChjdHgsIF9ldmVudC5kYXRhLCBtZXRhKSA6IGFjdGlvbi5ldmVudCk7XG4gIHZhciByZXNvbHZlZERlbGF5O1xuXG4gIGlmIChpc1N0cmluZyhhY3Rpb24uZGVsYXkpKSB7XG4gICAgdmFyIGNvbmZpZ0RlbGF5ID0gZGVsYXlzTWFwICYmIGRlbGF5c01hcFthY3Rpb24uZGVsYXldO1xuICAgIHJlc29sdmVkRGVsYXkgPSBpc0Z1bmN0aW9uKGNvbmZpZ0RlbGF5KSA/IGNvbmZpZ0RlbGF5KGN0eCwgX2V2ZW50LmRhdGEsIG1ldGEpIDogY29uZmlnRGVsYXk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWREZWxheSA9IGlzRnVuY3Rpb24oYWN0aW9uLmRlbGF5KSA/IGFjdGlvbi5kZWxheShjdHgsIF9ldmVudC5kYXRhLCBtZXRhKSA6IGFjdGlvbi5kZWxheTtcbiAgfVxuXG4gIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYWN0aW9uKSwge1xuICAgIHR5cGU6IHJhaXNlJDEsXG4gICAgX2V2ZW50OiByZXNvbHZlZEV2ZW50LFxuICAgIGRlbGF5OiByZXNvbHZlZERlbGF5XG4gIH0pO1xufVxuLyoqXHJcbiAqIFNlbmRzIGFuIGV2ZW50LiBUaGlzIHJldHVybnMgYW4gYWN0aW9uIHRoYXQgd2lsbCBiZSByZWFkIGJ5IGFuIGludGVycHJldGVyIHRvXHJcbiAqIHNlbmQgdGhlIGV2ZW50IGluIHRoZSBuZXh0IHN0ZXAsIGFmdGVyIHRoZSBjdXJyZW50IHN0ZXAgaXMgZmluaXNoZWQgZXhlY3V0aW5nLlxyXG4gKlxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBzZW5kVG8oLi4uKWAgYWN0aW9uIGNyZWF0b3IgaW5zdGVhZC5cclxuICpcclxuICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBzZW5kLlxyXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIHBhc3MgaW50byB0aGUgc2VuZCBldmVudDpcclxuICogIC0gYGlkYCAtIFRoZSB1bmlxdWUgc2VuZCBldmVudCBpZGVudGlmaWVyICh1c2VkIHdpdGggYGNhbmNlbCgpYCkuXHJcbiAqICAtIGBkZWxheWAgLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSB0aGUgc2VuZGluZyBvZiB0aGUgZXZlbnQuXHJcbiAqICAtIGB0b2AgLSBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQgKGJ5IGRlZmF1bHQsIHRoZSBtYWNoaW5lIHRoZSBldmVudCB3YXMgc2VudCBmcm9tKS5cclxuICovXG5cbmZ1bmN0aW9uIHNlbmQoZXZlbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICB0bzogb3B0aW9ucyA/IG9wdGlvbnMudG8gOiB1bmRlZmluZWQsXG4gICAgdHlwZTogc2VuZCQxLFxuICAgIGV2ZW50OiBpc0Z1bmN0aW9uKGV2ZW50KSA/IGV2ZW50IDogdG9FdmVudE9iamVjdChldmVudCksXG4gICAgZGVsYXk6IG9wdGlvbnMgPyBvcHRpb25zLmRlbGF5IDogdW5kZWZpbmVkLFxuICAgIC8vIFRPRE86IGRvbid0IGF1dG8tZ2VuZXJhdGUgSURzIGhlcmUgbGlrZSB0aGF0XG4gICAgLy8gdGhlcmUgaXMgdG9vIGJpZyBjaGFuY2Ugb2YgdGhlIElEIGNvbGxpc2lvblxuICAgIGlkOiBvcHRpb25zICYmIG9wdGlvbnMuaWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaWQgOiBpc0Z1bmN0aW9uKGV2ZW50KSA/IGV2ZW50Lm5hbWUgOiBnZXRFdmVudFR5cGUoZXZlbnQpXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlU2VuZChhY3Rpb24sIGN0eCwgX2V2ZW50LCBkZWxheXNNYXApIHtcbiAgdmFyIG1ldGEgPSB7XG4gICAgX2V2ZW50OiBfZXZlbnRcbiAgfTsgLy8gVE9ETzogaGVscGVyIGZ1bmN0aW9uIGZvciByZXNvbHZpbmcgRXhwclxuXG4gIHZhciByZXNvbHZlZEV2ZW50ID0gdG9TQ1hNTEV2ZW50KGlzRnVuY3Rpb24oYWN0aW9uLmV2ZW50KSA/IGFjdGlvbi5ldmVudChjdHgsIF9ldmVudC5kYXRhLCBtZXRhKSA6IGFjdGlvbi5ldmVudCk7XG4gIHZhciByZXNvbHZlZERlbGF5O1xuXG4gIGlmIChpc1N0cmluZyhhY3Rpb24uZGVsYXkpKSB7XG4gICAgdmFyIGNvbmZpZ0RlbGF5ID0gZGVsYXlzTWFwICYmIGRlbGF5c01hcFthY3Rpb24uZGVsYXldO1xuICAgIHJlc29sdmVkRGVsYXkgPSBpc0Z1bmN0aW9uKGNvbmZpZ0RlbGF5KSA/IGNvbmZpZ0RlbGF5KGN0eCwgX2V2ZW50LmRhdGEsIG1ldGEpIDogY29uZmlnRGVsYXk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWREZWxheSA9IGlzRnVuY3Rpb24oYWN0aW9uLmRlbGF5KSA/IGFjdGlvbi5kZWxheShjdHgsIF9ldmVudC5kYXRhLCBtZXRhKSA6IGFjdGlvbi5kZWxheTtcbiAgfVxuXG4gIHZhciByZXNvbHZlZFRhcmdldCA9IGlzRnVuY3Rpb24oYWN0aW9uLnRvKSA/IGFjdGlvbi50byhjdHgsIF9ldmVudC5kYXRhLCBtZXRhKSA6IGFjdGlvbi50bztcbiAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBhY3Rpb24pLCB7XG4gICAgdG86IHJlc29sdmVkVGFyZ2V0LFxuICAgIF9ldmVudDogcmVzb2x2ZWRFdmVudCxcbiAgICBldmVudDogcmVzb2x2ZWRFdmVudC5kYXRhLFxuICAgIGRlbGF5OiByZXNvbHZlZERlbGF5XG4gIH0pO1xufVxuLyoqXHJcbiAqIFNlbmRzIGFuIGV2ZW50IHRvIHRoaXMgbWFjaGluZSdzIHBhcmVudC5cclxuICpcclxuICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBzZW5kIHRvIHRoZSBwYXJlbnQgbWFjaGluZS5cclxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIGludG8gdGhlIHNlbmQgZXZlbnQuXHJcbiAqL1xuXG5mdW5jdGlvbiBzZW5kUGFyZW50KGV2ZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBzZW5kKGV2ZW50LCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHtcbiAgICB0bzogU3BlY2lhbFRhcmdldHMuUGFyZW50XG4gIH0pKTtcbn1cbi8qKlxyXG4gKiBTZW5kcyBhbiBldmVudCB0byBhbiBhY3Rvci5cclxuICpcclxuICogQHBhcmFtIGFjdG9yIFRoZSBgQWN0b3JSZWZgIHRvIHNlbmQgdGhlIGV2ZW50IHRvLlxyXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHNlbmQsIG9yIGFuIGV4cHJlc3Npb24gdGhhdCBldmFsdWF0ZXMgdG8gdGhlIGV2ZW50IHRvIHNlbmRcclxuICogQHBhcmFtIG9wdGlvbnMgU2VuZCBhY3Rpb24gb3B0aW9uc1xyXG4gKiBAcmV0dXJucyBBbiBYU3RhdGUgc2VuZCBhY3Rpb24gb2JqZWN0XHJcbiAqL1xuXG5mdW5jdGlvbiBzZW5kVG8oYWN0b3IsIGV2ZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBzZW5kKGV2ZW50LCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHtcbiAgICB0bzogYWN0b3JcbiAgfSkpO1xufVxuLyoqXHJcbiAqIFNlbmRzIGFuIHVwZGF0ZSBldmVudCB0byB0aGlzIG1hY2hpbmUncyBwYXJlbnQuXHJcbiAqL1xuXG5mdW5jdGlvbiBzZW5kVXBkYXRlKCkge1xuICByZXR1cm4gc2VuZFBhcmVudCh1cGRhdGUpO1xufVxuLyoqXHJcbiAqIFNlbmRzIGFuIGV2ZW50IGJhY2sgdG8gdGhlIHNlbmRlciBvZiB0aGUgb3JpZ2luYWwgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gc2VuZCBiYWNrIHRvIHRoZSBzZW5kZXJcclxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIGludG8gdGhlIHNlbmQgZXZlbnRcclxuICovXG5cbmZ1bmN0aW9uIHJlc3BvbmQoZXZlbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNlbmQoZXZlbnQsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgIHRvOiBmdW5jdGlvbiAoXywgX18sIF9hKSB7XG4gICAgICB2YXIgX2V2ZW50ID0gX2EuX2V2ZW50O1xuICAgICAgcmV0dXJuIF9ldmVudC5vcmlnaW47IC8vIFRPRE86IGhhbmRsZSB3aGVuIF9ldmVudC5vcmlnaW4gaXMgdW5kZWZpbmVkXG4gICAgfVxuICB9KSk7XG59XG5cbnZhciBkZWZhdWx0TG9nRXhwciA9IGZ1bmN0aW9uIChjb250ZXh0LCBldmVudCkge1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgZXZlbnQ6IGV2ZW50XG4gIH07XG59O1xuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBleHByIFRoZSBleHByZXNzaW9uIGZ1bmN0aW9uIHRvIGV2YWx1YXRlIHdoaWNoIHdpbGwgYmUgbG9nZ2VkLlxyXG4gKiAgVGFrZXMgaW4gMiBhcmd1bWVudHM6XHJcbiAqICAtIGBjdHhgIC0gdGhlIGN1cnJlbnQgc3RhdGUgY29udGV4dFxyXG4gKiAgLSBgZXZlbnRgIC0gdGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxyXG4gKiBAcGFyYW0gbGFiZWwgVGhlIGxhYmVsIHRvIGdpdmUgdG8gdGhlIGxvZ2dlZCBleHByZXNzaW9uLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBsb2coZXhwciwgbGFiZWwpIHtcbiAgaWYgKGV4cHIgPT09IHZvaWQgMCkge1xuICAgIGV4cHIgPSBkZWZhdWx0TG9nRXhwcjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogbG9nJDEsXG4gICAgbGFiZWw6IGxhYmVsLFxuICAgIGV4cHI6IGV4cHJcbiAgfTtcbn1cbnZhciByZXNvbHZlTG9nID0gZnVuY3Rpb24gKGFjdGlvbiwgY3R4LCBfZXZlbnQpIHtcbiAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBhY3Rpb24pLCB7XG4gICAgdmFsdWU6IGlzU3RyaW5nKGFjdGlvbi5leHByKSA/IGFjdGlvbi5leHByIDogYWN0aW9uLmV4cHIoY3R4LCBfZXZlbnQuZGF0YSwge1xuICAgICAgX2V2ZW50OiBfZXZlbnRcbiAgICB9KVxuICB9KTtcbn07XG4vKipcclxuICogQ2FuY2VscyBhbiBpbi1mbGlnaHQgYHNlbmQoLi4uKWAgYWN0aW9uLiBBIGNhbmNlbGVkIHNlbnQgYWN0aW9uIHdpbGwgbm90XHJcbiAqIGJlIGV4ZWN1dGVkLCBub3Igd2lsbCBpdHMgZXZlbnQgYmUgc2VudCwgdW5sZXNzIGl0IGhhcyBhbHJlYWR5IGJlZW4gc2VudFxyXG4gKiAoZS5nLiwgaWYgYGNhbmNlbCguLi4pYCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGBzZW5kKC4uLilgIGFjdGlvbidzIGBkZWxheWApLlxyXG4gKlxyXG4gKiBAcGFyYW0gc2VuZElkIFRoZSBgaWRgIG9mIHRoZSBgc2VuZCguLi4pYCBhY3Rpb24gdG8gY2FuY2VsLlxyXG4gKi9cblxudmFyIGNhbmNlbCA9IGZ1bmN0aW9uIChzZW5kSWQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBjYW5jZWwkMSxcbiAgICBzZW5kSWQ6IHNlbmRJZFxuICB9O1xufTtcbi8qKlxyXG4gKiBTdGFydHMgYW4gYWN0aXZpdHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBhY3Rpdml0eSBUaGUgYWN0aXZpdHkgdG8gc3RhcnQuXHJcbiAqL1xuXG5mdW5jdGlvbiBzdGFydChhY3Rpdml0eSkge1xuICB2YXIgYWN0aXZpdHlEZWYgPSB0b0FjdGl2aXR5RGVmaW5pdGlvbihhY3Rpdml0eSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQWN0aW9uVHlwZXMuU3RhcnQsXG4gICAgYWN0aXZpdHk6IGFjdGl2aXR5RGVmLFxuICAgIGV4ZWM6IHVuZGVmaW5lZFxuICB9O1xufVxuLyoqXHJcbiAqIFN0b3BzIGFuIGFjdGl2aXR5LlxyXG4gKlxyXG4gKiBAcGFyYW0gYWN0b3JSZWYgVGhlIGFjdGl2aXR5IHRvIHN0b3AuXHJcbiAqL1xuXG5mdW5jdGlvbiBzdG9wKGFjdG9yUmVmKSB7XG4gIHZhciBhY3Rpdml0eSA9IGlzRnVuY3Rpb24oYWN0b3JSZWYpID8gYWN0b3JSZWYgOiB0b0FjdGl2aXR5RGVmaW5pdGlvbihhY3RvclJlZik7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQWN0aW9uVHlwZXMuU3RvcCxcbiAgICBhY3Rpdml0eTogYWN0aXZpdHksXG4gICAgZXhlYzogdW5kZWZpbmVkXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlU3RvcChhY3Rpb24sIGNvbnRleHQsIF9ldmVudCkge1xuICB2YXIgYWN0b3JSZWZPclN0cmluZyA9IGlzRnVuY3Rpb24oYWN0aW9uLmFjdGl2aXR5KSA/IGFjdGlvbi5hY3Rpdml0eShjb250ZXh0LCBfZXZlbnQuZGF0YSkgOiBhY3Rpb24uYWN0aXZpdHk7XG4gIHZhciByZXNvbHZlZEFjdG9yUmVmID0gdHlwZW9mIGFjdG9yUmVmT3JTdHJpbmcgPT09ICdzdHJpbmcnID8ge1xuICAgIGlkOiBhY3RvclJlZk9yU3RyaW5nXG4gIH0gOiBhY3RvclJlZk9yU3RyaW5nO1xuICB2YXIgYWN0aW9uT2JqZWN0ID0ge1xuICAgIHR5cGU6IEFjdGlvblR5cGVzLlN0b3AsXG4gICAgYWN0aXZpdHk6IHJlc29sdmVkQWN0b3JSZWZcbiAgfTtcbiAgcmV0dXJuIGFjdGlvbk9iamVjdDtcbn1cbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSBjdXJyZW50IGNvbnRleHQgb2YgdGhlIG1hY2hpbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhc3NpZ25tZW50IEFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhcnRpYWwgY29udGV4dCB0byB1cGRhdGUuXHJcbiAqL1xuXG52YXIgYXNzaWduID0gZnVuY3Rpb24gKGFzc2lnbm1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBhc3NpZ24kMSxcbiAgICBhc3NpZ25tZW50OiBhc3NpZ25tZW50XG4gIH07XG59O1xuZnVuY3Rpb24gaXNBY3Rpb25PYmplY3QoYWN0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnb2JqZWN0JyAmJiAndHlwZScgaW4gYWN0aW9uO1xufVxuLyoqXHJcbiAqIFJldHVybnMgYW4gZXZlbnQgdHlwZSB0aGF0IHJlcHJlc2VudHMgYW4gaW1wbGljaXQgZXZlbnQgdGhhdFxyXG4gKiBpcyBzZW50IGFmdGVyIHRoZSBzcGVjaWZpZWQgYGRlbGF5YC5cclxuICpcclxuICogQHBhcmFtIGRlbGF5UmVmIFRoZSBkZWxheSBpbiBtaWxsaXNlY29uZHNcclxuICogQHBhcmFtIGlkIFRoZSBzdGF0ZSBub2RlIElEIHdoZXJlIHRoaXMgZXZlbnQgaXMgaGFuZGxlZFxyXG4gKi9cblxuZnVuY3Rpb24gYWZ0ZXIoZGVsYXlSZWYsIGlkKSB7XG4gIHZhciBpZFN1ZmZpeCA9IGlkID8gXCIjXCIuY29uY2F0KGlkKSA6ICcnO1xuICByZXR1cm4gXCJcIi5jb25jYXQoQWN0aW9uVHlwZXMuQWZ0ZXIsIFwiKFwiKS5jb25jYXQoZGVsYXlSZWYsIFwiKVwiKS5jb25jYXQoaWRTdWZmaXgpO1xufVxuLyoqXHJcbiAqIFJldHVybnMgYW4gZXZlbnQgdGhhdCByZXByZXNlbnRzIHRoYXQgYSBmaW5hbCBzdGF0ZSBub2RlXHJcbiAqIGhhcyBiZWVuIHJlYWNoZWQgaW4gdGhlIHBhcmVudCBzdGF0ZSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gaWQgVGhlIGZpbmFsIHN0YXRlIG5vZGUncyBwYXJlbnQgc3RhdGUgbm9kZSBgaWRgXHJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIHBhc3MgaW50byB0aGUgZXZlbnRcclxuICovXG5cbmZ1bmN0aW9uIGRvbmUoaWQsIGRhdGEpIHtcbiAgdmFyIHR5cGUgPSBcIlwiLmNvbmNhdChBY3Rpb25UeXBlcy5Eb25lU3RhdGUsIFwiLlwiKS5jb25jYXQoaWQpO1xuICB2YXIgZXZlbnRPYmplY3QgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBkYXRhOiBkYXRhXG4gIH07XG5cbiAgZXZlbnRPYmplY3QudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH07XG5cbiAgcmV0dXJuIGV2ZW50T2JqZWN0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYW4gZXZlbnQgdGhhdCByZXByZXNlbnRzIHRoYXQgYW4gaW52b2tlZCBzZXJ2aWNlIGhhcyB0ZXJtaW5hdGVkLlxyXG4gKlxyXG4gKiBBbiBpbnZva2VkIHNlcnZpY2UgaXMgdGVybWluYXRlZCB3aGVuIGl0IGhhcyByZWFjaGVkIGEgdG9wLWxldmVsIGZpbmFsIHN0YXRlIG5vZGUsXHJcbiAqIGJ1dCBub3Qgd2hlbiBpdCBpcyBjYW5jZWxlZC5cclxuICpcclxuICogQHBhcmFtIGlkIFRoZSBmaW5hbCBzdGF0ZSBub2RlIElEXHJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIHBhc3MgaW50byB0aGUgZXZlbnRcclxuICovXG5cbmZ1bmN0aW9uIGRvbmVJbnZva2UoaWQsIGRhdGEpIHtcbiAgdmFyIHR5cGUgPSBcIlwiLmNvbmNhdChBY3Rpb25UeXBlcy5Eb25lSW52b2tlLCBcIi5cIikuY29uY2F0KGlkKTtcbiAgdmFyIGV2ZW50T2JqZWN0ID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgZGF0YTogZGF0YVxuICB9O1xuXG4gIGV2ZW50T2JqZWN0LnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0eXBlO1xuICB9O1xuXG4gIHJldHVybiBldmVudE9iamVjdDtcbn1cbmZ1bmN0aW9uIGVycm9yKGlkLCBkYXRhKSB7XG4gIHZhciB0eXBlID0gXCJcIi5jb25jYXQoQWN0aW9uVHlwZXMuRXJyb3JQbGF0Zm9ybSwgXCIuXCIpLmNvbmNhdChpZCk7XG4gIHZhciBldmVudE9iamVjdCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGE6IGRhdGFcbiAgfTtcblxuICBldmVudE9iamVjdC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfTtcblxuICByZXR1cm4gZXZlbnRPYmplY3Q7XG59XG5mdW5jdGlvbiBwdXJlKGdldEFjdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBY3Rpb25UeXBlcy5QdXJlLFxuICAgIGdldDogZ2V0QWN0aW9uc1xuICB9O1xufVxuLyoqXHJcbiAqIEZvcndhcmRzIChzZW5kcykgYW4gZXZlbnQgdG8gYSBzcGVjaWZpZWQgc2VydmljZS5cclxuICpcclxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IHNlcnZpY2UgdG8gZm9yd2FyZCB0aGUgZXZlbnQgdG8uXHJcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gcGFzcyBpbnRvIHRoZSBzZW5kIGFjdGlvbiBjcmVhdG9yLlxyXG4gKi9cblxuZnVuY3Rpb24gZm9yd2FyZFRvKHRhcmdldCwgb3B0aW9ucykge1xuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgKCF0YXJnZXQgfHwgdHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB2YXIgb3JpZ2luYWxUYXJnZXRfMSA9IHRhcmdldDtcblxuICAgIHRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc29sdmVkVGFyZ2V0ID0gdHlwZW9mIG9yaWdpbmFsVGFyZ2V0XzEgPT09ICdmdW5jdGlvbicgPyBvcmlnaW5hbFRhcmdldF8xLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpIDogb3JpZ2luYWxUYXJnZXRfMTtcblxuICAgICAgaWYgKCFyZXNvbHZlZFRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gZm9yd2FyZCBldmVudCB0byB1bmRlZmluZWQgYWN0b3IuIFRoaXMgcmlza3MgYW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgc2VuZGVyLlwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc29sdmVkVGFyZ2V0O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gc2VuZChmdW5jdGlvbiAoXywgZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgIHRvOiB0YXJnZXRcbiAgfSkpO1xufVxuLyoqXHJcbiAqIEVzY2FsYXRlcyBhbiBlcnJvciBieSBzZW5kaW5nIGl0IGFzIGFuIGV2ZW50IHRvIHRoaXMgbWFjaGluZSdzIHBhcmVudC5cclxuICpcclxuICogQHBhcmFtIGVycm9yRGF0YSBUaGUgZXJyb3IgZGF0YSB0byBzZW5kLCBvciB0aGUgZXhwcmVzc2lvbiBmdW5jdGlvbiB0aGF0XHJcbiAqIHRha2VzIGluIHRoZSBgY29udGV4dGAsIGBldmVudGAsIGFuZCBgbWV0YWAsIGFuZCByZXR1cm5zIHRoZSBlcnJvciBkYXRhIHRvIHNlbmQuXHJcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gcGFzcyBpbnRvIHRoZSBzZW5kIGFjdGlvbiBjcmVhdG9yLlxyXG4gKi9cblxuZnVuY3Rpb24gZXNjYWxhdGUoZXJyb3JEYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiBzZW5kUGFyZW50KGZ1bmN0aW9uIChjb250ZXh0LCBldmVudCwgbWV0YSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBlcnJvciQxLFxuICAgICAgZGF0YTogaXNGdW5jdGlvbihlcnJvckRhdGEpID8gZXJyb3JEYXRhKGNvbnRleHQsIGV2ZW50LCBtZXRhKSA6IGVycm9yRGF0YVxuICAgIH07XG4gIH0sIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgIHRvOiBTcGVjaWFsVGFyZ2V0cy5QYXJlbnRcbiAgfSkpO1xufVxuZnVuY3Rpb24gY2hvb3NlKGNvbmRzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQWN0aW9uVHlwZXMuQ2hvb3NlLFxuICAgIGNvbmRzOiBjb25kc1xuICB9O1xufVxuXG52YXIgcGx1Y2tBc3NpZ25zID0gZnVuY3Rpb24gKGFjdGlvbkJsb2Nrcykge1xuICB2YXIgZV8xLCBfYTtcblxuICB2YXIgYXNzaWduQWN0aW9ucyA9IFtdO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgYWN0aW9uQmxvY2tzXzEgPSBfX3ZhbHVlcyhhY3Rpb25CbG9ja3MpLCBhY3Rpb25CbG9ja3NfMV8xID0gYWN0aW9uQmxvY2tzXzEubmV4dCgpOyAhYWN0aW9uQmxvY2tzXzFfMS5kb25lOyBhY3Rpb25CbG9ja3NfMV8xID0gYWN0aW9uQmxvY2tzXzEubmV4dCgpKSB7XG4gICAgICB2YXIgYmxvY2sgPSBhY3Rpb25CbG9ja3NfMV8xLnZhbHVlO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IGJsb2NrLmFjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChibG9jay5hY3Rpb25zW2ldLnR5cGUgPT09IGFzc2lnbiQxKSB7XG4gICAgICAgICAgYXNzaWduQWN0aW9ucy5wdXNoKGJsb2NrLmFjdGlvbnNbaV0pO1xuICAgICAgICAgIGJsb2NrLmFjdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICBlXzEgPSB7XG4gICAgICBlcnJvcjogZV8xXzFcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoYWN0aW9uQmxvY2tzXzFfMSAmJiAhYWN0aW9uQmxvY2tzXzFfMS5kb25lICYmIChfYSA9IGFjdGlvbkJsb2Nrc18xLnJldHVybikpIF9hLmNhbGwoYWN0aW9uQmxvY2tzXzEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFzc2lnbkFjdGlvbnM7XG59O1xuXG5mdW5jdGlvbiByZXNvbHZlQWN0aW9ucyhtYWNoaW5lLCBjdXJyZW50U3RhdGUsIGN1cnJlbnRDb250ZXh0LCBfZXZlbnQsIGFjdGlvbkJsb2NrcywgcHJlZGljdGFibGVFeGVjLCBwcmVzZXJ2ZUFjdGlvbk9yZGVyKSB7XG4gIGlmIChwcmVzZXJ2ZUFjdGlvbk9yZGVyID09PSB2b2lkIDApIHtcbiAgICBwcmVzZXJ2ZUFjdGlvbk9yZGVyID0gZmFsc2U7XG4gIH1cblxuICB2YXIgYXNzaWduQWN0aW9ucyA9IHByZXNlcnZlQWN0aW9uT3JkZXIgPyBbXSA6IHBsdWNrQXNzaWducyhhY3Rpb25CbG9ja3MpO1xuICB2YXIgdXBkYXRlZENvbnRleHQgPSBhc3NpZ25BY3Rpb25zLmxlbmd0aCA/IHVwZGF0ZUNvbnRleHQoY3VycmVudENvbnRleHQsIF9ldmVudCwgYXNzaWduQWN0aW9ucywgY3VycmVudFN0YXRlKSA6IGN1cnJlbnRDb250ZXh0O1xuICB2YXIgcHJlc2VydmVkQ29udGV4dHMgPSBwcmVzZXJ2ZUFjdGlvbk9yZGVyID8gW2N1cnJlbnRDb250ZXh0XSA6IHVuZGVmaW5lZDtcbiAgdmFyIGRlZmVycmVkVG9CbG9ja0VuZCA9IFtdO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUFjdGlvbihibG9ja1R5cGUsIGFjdGlvbk9iamVjdCkge1xuICAgIHZhciBfYTtcblxuICAgIHN3aXRjaCAoYWN0aW9uT2JqZWN0LnR5cGUpIHtcbiAgICAgIGNhc2UgcmFpc2UkMTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciByYWlzZWRBY3Rpb24gPSByZXNvbHZlUmFpc2UoYWN0aW9uT2JqZWN0LCB1cGRhdGVkQ29udGV4dCwgX2V2ZW50LCBtYWNoaW5lLm9wdGlvbnMuZGVsYXlzKTtcblxuICAgICAgICAgIGlmIChwcmVkaWN0YWJsZUV4ZWMgJiYgdHlwZW9mIHJhaXNlZEFjdGlvbi5kZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHByZWRpY3RhYmxlRXhlYyhyYWlzZWRBY3Rpb24sIHVwZGF0ZWRDb250ZXh0LCBfZXZlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByYWlzZWRBY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBzZW5kJDE6XG4gICAgICAgIHZhciBzZW5kQWN0aW9uID0gcmVzb2x2ZVNlbmQoYWN0aW9uT2JqZWN0LCB1cGRhdGVkQ29udGV4dCwgX2V2ZW50LCBtYWNoaW5lLm9wdGlvbnMuZGVsYXlzKTsgLy8gVE9ETzogZml4IEFjdGlvblR5cGVzLkluaXRcblxuICAgICAgICBpZiAoIUlTX1BST0RVQ1RJT04pIHtcbiAgICAgICAgICB2YXIgY29uZmlndXJlZERlbGF5ID0gYWN0aW9uT2JqZWN0LmRlbGF5OyAvLyB3YXJuIGFmdGVyIHJlc29sdmluZyBhcyB3ZSBjYW4gY3JlYXRlIGJldHRlciBjb250ZXh0dWFsIG1lc3NhZ2UgaGVyZVxuXG4gICAgICAgICAgd2FybighaXNTdHJpbmcoY29uZmlndXJlZERlbGF5KSB8fCB0eXBlb2Ygc2VuZEFjdGlvbi5kZWxheSA9PT0gJ251bWJlcicsIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgICAgICBcIk5vIGRlbGF5IHJlZmVyZW5jZSBmb3IgZGVsYXkgZXhwcmVzc2lvbiAnXCIuY29uY2F0KGNvbmZpZ3VyZWREZWxheSwgXCInIHdhcyBmb3VuZCBvbiBtYWNoaW5lICdcIikuY29uY2F0KG1hY2hpbmUuaWQsIFwiJ1wiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlZGljdGFibGVFeGVjICYmIHNlbmRBY3Rpb24udG8gIT09IFNwZWNpYWxUYXJnZXRzLkludGVybmFsKSB7XG4gICAgICAgICAgaWYgKGJsb2NrVHlwZSA9PT0gJ2VudHJ5Jykge1xuICAgICAgICAgICAgZGVmZXJyZWRUb0Jsb2NrRW5kLnB1c2goc2VuZEFjdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZWRpY3RhYmxlRXhlYyhzZW5kQWN0aW9uLCB1cGRhdGVkQ29udGV4dCwgX2V2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VuZEFjdGlvbjtcblxuICAgICAgY2FzZSBsb2ckMTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciByZXNvbHZlZCA9IHJlc29sdmVMb2coYWN0aW9uT2JqZWN0LCB1cGRhdGVkQ29udGV4dCwgX2V2ZW50KTtcbiAgICAgICAgICBwcmVkaWN0YWJsZUV4ZWMgPT09IG51bGwgfHwgcHJlZGljdGFibGVFeGVjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmVkaWN0YWJsZUV4ZWMocmVzb2x2ZWQsIHVwZGF0ZWRDb250ZXh0LCBfZXZlbnQpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIGNob29zZSQxOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNob29zZUFjdGlvbiA9IGFjdGlvbk9iamVjdDtcbiAgICAgICAgICB2YXIgbWF0Y2hlZEFjdGlvbnMgPSAoX2EgPSBjaG9vc2VBY3Rpb24uY29uZHMuZmluZChmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZ3VhcmQgPSB0b0d1YXJkKGNvbmRpdGlvbi5jb25kLCBtYWNoaW5lLm9wdGlvbnMuZ3VhcmRzKTtcbiAgICAgICAgICAgIHJldHVybiAhZ3VhcmQgfHwgZXZhbHVhdGVHdWFyZChtYWNoaW5lLCBndWFyZCwgdXBkYXRlZENvbnRleHQsIF9ldmVudCwgIXByZWRpY3RhYmxlRXhlYyA/IGN1cnJlbnRTdGF0ZSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3Rpb25zO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaGVkQWN0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChyZXNvbHZlQWN0aW9ucyhtYWNoaW5lLCBjdXJyZW50U3RhdGUsIHVwZGF0ZWRDb250ZXh0LCBfZXZlbnQsIFt7XG4gICAgICAgICAgICB0eXBlOiBibG9ja1R5cGUsXG4gICAgICAgICAgICBhY3Rpb25zOiB0b0FjdGlvbk9iamVjdHModG9BcnJheShtYXRjaGVkQWN0aW9ucyksIG1hY2hpbmUub3B0aW9ucy5hY3Rpb25zKVxuICAgICAgICAgIH1dLCBwcmVkaWN0YWJsZUV4ZWMsIHByZXNlcnZlQWN0aW9uT3JkZXIpLCAyKSxcbiAgICAgICAgICAgICAgcmVzb2x2ZWRBY3Rpb25zRnJvbUNob29zZSA9IF9iWzBdLFxuICAgICAgICAgICAgICByZXNvbHZlZENvbnRleHRGcm9tQ2hvb3NlID0gX2JbMV07XG5cbiAgICAgICAgICB1cGRhdGVkQ29udGV4dCA9IHJlc29sdmVkQ29udGV4dEZyb21DaG9vc2U7XG4gICAgICAgICAgcHJlc2VydmVkQ29udGV4dHMgPT09IG51bGwgfHwgcHJlc2VydmVkQ29udGV4dHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXNlcnZlZENvbnRleHRzLnB1c2godXBkYXRlZENvbnRleHQpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlZEFjdGlvbnNGcm9tQ2hvb3NlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgcHVyZSQxOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG1hdGNoZWRBY3Rpb25zID0gYWN0aW9uT2JqZWN0LmdldCh1cGRhdGVkQ29udGV4dCwgX2V2ZW50LmRhdGEpO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaGVkQWN0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfYyA9IF9fcmVhZChyZXNvbHZlQWN0aW9ucyhtYWNoaW5lLCBjdXJyZW50U3RhdGUsIHVwZGF0ZWRDb250ZXh0LCBfZXZlbnQsIFt7XG4gICAgICAgICAgICB0eXBlOiBibG9ja1R5cGUsXG4gICAgICAgICAgICBhY3Rpb25zOiB0b0FjdGlvbk9iamVjdHModG9BcnJheShtYXRjaGVkQWN0aW9ucyksIG1hY2hpbmUub3B0aW9ucy5hY3Rpb25zKVxuICAgICAgICAgIH1dLCBwcmVkaWN0YWJsZUV4ZWMsIHByZXNlcnZlQWN0aW9uT3JkZXIpLCAyKSxcbiAgICAgICAgICAgICAgcmVzb2x2ZWRBY3Rpb25zRnJvbVB1cmUgPSBfY1swXSxcbiAgICAgICAgICAgICAgcmVzb2x2ZWRDb250ZXh0ID0gX2NbMV07XG5cbiAgICAgICAgICB1cGRhdGVkQ29udGV4dCA9IHJlc29sdmVkQ29udGV4dDtcbiAgICAgICAgICBwcmVzZXJ2ZWRDb250ZXh0cyA9PT0gbnVsbCB8fCBwcmVzZXJ2ZWRDb250ZXh0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlc2VydmVkQ29udGV4dHMucHVzaCh1cGRhdGVkQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVkQWN0aW9uc0Zyb21QdXJlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2Ugc3RvcCQxOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHJlc29sdmVkID0gcmVzb2x2ZVN0b3AoYWN0aW9uT2JqZWN0LCB1cGRhdGVkQ29udGV4dCwgX2V2ZW50KTtcbiAgICAgICAgICBwcmVkaWN0YWJsZUV4ZWMgPT09IG51bGwgfHwgcHJlZGljdGFibGVFeGVjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmVkaWN0YWJsZUV4ZWMocmVzb2x2ZWQsIGN1cnJlbnRDb250ZXh0LCBfZXZlbnQpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIGFzc2lnbiQxOlxuICAgICAgICB7XG4gICAgICAgICAgdXBkYXRlZENvbnRleHQgPSB1cGRhdGVDb250ZXh0KHVwZGF0ZWRDb250ZXh0LCBfZXZlbnQsIFthY3Rpb25PYmplY3RdLCAhcHJlZGljdGFibGVFeGVjID8gY3VycmVudFN0YXRlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICBwcmVzZXJ2ZWRDb250ZXh0cyA9PT0gbnVsbCB8fCBwcmVzZXJ2ZWRDb250ZXh0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlc2VydmVkQ29udGV4dHMucHVzaCh1cGRhdGVkQ29udGV4dCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHJlc29sdmVkQWN0aW9uT2JqZWN0ID0gdG9BY3Rpb25PYmplY3QoYWN0aW9uT2JqZWN0LCBtYWNoaW5lLm9wdGlvbnMuYWN0aW9ucyk7XG4gICAgICAgIHZhciBleGVjXzEgPSByZXNvbHZlZEFjdGlvbk9iamVjdC5leGVjO1xuXG4gICAgICAgIGlmIChwcmVkaWN0YWJsZUV4ZWMpIHtcbiAgICAgICAgICBwcmVkaWN0YWJsZUV4ZWMocmVzb2x2ZWRBY3Rpb25PYmplY3QsIHVwZGF0ZWRDb250ZXh0LCBfZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4ZWNfMSAmJiBwcmVzZXJ2ZWRDb250ZXh0cykge1xuICAgICAgICAgIHZhciBjb250ZXh0SW5kZXhfMSA9IHByZXNlcnZlZENvbnRleHRzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICB2YXIgd3JhcHBlZCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXNvbHZlZEFjdGlvbk9iamVjdCksIHtcbiAgICAgICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChfY3R4KSB7XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZXhlY18xLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbcHJlc2VydmVkQ29udGV4dHNbY29udGV4dEluZGV4XzFdXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmVzb2x2ZWRBY3Rpb25PYmplY3QgPSB3cmFwcGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkQWN0aW9uT2JqZWN0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NCbG9jayhibG9jaykge1xuICAgIHZhciBlXzIsIF9hO1xuXG4gICAgdmFyIHJlc29sdmVkQWN0aW9ucyA9IFtdO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoYmxvY2suYWN0aW9ucyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIGFjdGlvbiA9IF9jLnZhbHVlO1xuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBoYW5kbGVBY3Rpb24oYmxvY2sudHlwZSwgYWN0aW9uKTtcblxuICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICByZXNvbHZlZEFjdGlvbnMgPSByZXNvbHZlZEFjdGlvbnMuY29uY2F0KHJlc29sdmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfMl8xKSB7XG4gICAgICBlXzIgPSB7XG4gICAgICAgIGVycm9yOiBlXzJfMVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlZmVycmVkVG9CbG9ja0VuZC5mb3JFYWNoKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIHByZWRpY3RhYmxlRXhlYyhhY3Rpb24sIHVwZGF0ZWRDb250ZXh0LCBfZXZlbnQpO1xuICAgIH0pO1xuICAgIGRlZmVycmVkVG9CbG9ja0VuZC5sZW5ndGggPSAwO1xuICAgIHJldHVybiByZXNvbHZlZEFjdGlvbnM7XG4gIH1cblxuICB2YXIgcmVzb2x2ZWRBY3Rpb25zID0gZmxhdHRlbihhY3Rpb25CbG9ja3MubWFwKHByb2Nlc3NCbG9jaykpO1xuICByZXR1cm4gW3Jlc29sdmVkQWN0aW9ucywgdXBkYXRlZENvbnRleHRdO1xufVxuXG5leHBvcnQgeyBhZnRlciwgYXNzaWduLCBjYW5jZWwsIGNob29zZSwgZG9uZSwgZG9uZUludm9rZSwgZXJyb3IsIGVzY2FsYXRlLCBmb3J3YXJkVG8sIGdldEFjdGlvbkZ1bmN0aW9uLCBpbml0RXZlbnQsIGlzQWN0aW9uT2JqZWN0LCBsb2csIHB1cmUsIHJhaXNlLCByZXNvbHZlQWN0aW9ucywgcmVzb2x2ZUxvZywgcmVzb2x2ZVJhaXNlLCByZXNvbHZlU2VuZCwgcmVzb2x2ZVN0b3AsIHJlc3BvbmQsIHNlbmQsIHNlbmRQYXJlbnQsIHNlbmRUbywgc2VuZFVwZGF0ZSwgc3RhcnQsIHN0b3AsIHRvQWN0aW9uT2JqZWN0LCB0b0FjdGlvbk9iamVjdHMsIHRvQWN0aXZpdHlEZWZpbml0aW9uIH07XG4iLCJpbXBvcnQgeyBlcnJvciwgZG9uZUludm9rZSB9IGZyb20gJy4vYWN0aW9ucy5qcyc7XG5pbXBvcnQgeyB0b0FjdG9yUmVmIH0gZnJvbSAnLi9BY3Rvci5qcyc7XG5pbXBvcnQgeyB0b09ic2VydmVyIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGFjdG9yIGJlaGF2aW9yIGZyb20gYSByZWR1Y2VyIGFuZCBpdHMgaW5pdGlhbCBzdGF0ZS5cclxuICpcclxuICogQHBhcmFtIHRyYW5zaXRpb24gVGhlIHB1cmUgcmVkdWNlciB0aGF0IHJldHVybnMgdGhlIG5leHQgc3RhdGUgZ2l2ZW4gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGV2ZW50LlxyXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSByZWR1Y2VyLlxyXG4gKiBAcmV0dXJucyBBbiBhY3RvciBiZWhhdmlvclxyXG4gKi9cblxuZnVuY3Rpb24gZnJvbVJlZHVjZXIodHJhbnNpdGlvbiwgaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiB7XG4gICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbixcbiAgICBpbml0aWFsU3RhdGU6IGluaXRpYWxTdGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gZnJvbVByb21pc2UocHJvbWlzZUZuKSB7XG4gIHZhciBpbml0aWFsU3RhdGUgPSB7XG4gICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgc3RhdHVzOiAncGVuZGluZydcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2l0aW9uOiBmdW5jdGlvbiAoc3RhdGUsIGV2ZW50LCBfYSkge1xuICAgICAgdmFyIHBhcmVudCA9IF9hLnBhcmVudCxcbiAgICAgICAgICBpZCA9IF9hLmlkLFxuICAgICAgICAgIG9ic2VydmVycyA9IF9hLm9ic2VydmVycztcblxuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2Z1bGZpbGwnOlxuICAgICAgICAgIHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5zZW5kKGRvbmVJbnZva2UoaWQsIGV2ZW50LmRhdGEpKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEsXG4gICAgICAgICAgICBzdGF0dXM6ICdmdWxmaWxsZWQnXG4gICAgICAgICAgfTtcblxuICAgICAgICBjYXNlICdyZWplY3QnOlxuICAgICAgICAgIHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5zZW5kKGVycm9yKGlkLCBldmVudC5lcnJvcikpO1xuICAgICAgICAgIG9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXZlbnQuZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcjogZXZlbnQuZXJyb3IsXG4gICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdGF0dXM6ICdyZWplY3RlZCdcbiAgICAgICAgICB9O1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW5pdGlhbFN0YXRlOiBpbml0aWFsU3RhdGUsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIHNlbGYgPSBfYS5zZWxmO1xuICAgICAgcHJvbWlzZUZuKCkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLnNlbmQoe1xuICAgICAgICAgIHR5cGU6ICdmdWxmaWxsJyxcbiAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBzZWxmLnNlbmQoe1xuICAgICAgICAgIHR5cGU6ICdyZWplY3QnLFxuICAgICAgICAgIGVycm9yOiByZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpbml0aWFsU3RhdGU7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc3Bhd25CZWhhdmlvcihiZWhhdmlvciwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHN0YXRlID0gYmVoYXZpb3IuaW5pdGlhbFN0YXRlO1xuICB2YXIgb2JzZXJ2ZXJzID0gbmV3IFNldCgpO1xuICB2YXIgbWFpbGJveCA9IFtdO1xuICB2YXIgZmx1c2hpbmcgPSBmYWxzZTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGZsdXNoaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmx1c2hpbmcgPSB0cnVlO1xuXG4gICAgd2hpbGUgKG1haWxib3gubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGV2ZW50XzEgPSBtYWlsYm94LnNoaWZ0KCk7XG4gICAgICBzdGF0ZSA9IGJlaGF2aW9yLnRyYW5zaXRpb24oc3RhdGUsIGV2ZW50XzEsIGFjdG9yQ3R4KTtcbiAgICAgIG9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXIubmV4dChzdGF0ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmbHVzaGluZyA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBhY3RvciA9IHRvQWN0b3JSZWYoe1xuICAgIGlkOiBvcHRpb25zLmlkLFxuICAgIHNlbmQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWFpbGJveC5wdXNoKGV2ZW50KTtcbiAgICAgIGZsdXNoKCk7XG4gICAgfSxcbiAgICBnZXRTbmFwc2hvdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAobmV4dCwgaGFuZGxlRXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSB0b09ic2VydmVyKG5leHQsIGhhbmRsZUVycm9yLCBjb21wbGV0ZSk7XG4gICAgICBvYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICAgIG9ic2VydmVyLm5leHQoc3RhdGUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICB2YXIgYWN0b3JDdHggPSB7XG4gICAgcGFyZW50OiBvcHRpb25zLnBhcmVudCxcbiAgICBzZWxmOiBhY3RvcixcbiAgICBpZDogb3B0aW9ucy5pZCB8fCAnYW5vbnltb3VzJyxcbiAgICBvYnNlcnZlcnM6IG9ic2VydmVyc1xuICB9O1xuICBzdGF0ZSA9IGJlaGF2aW9yLnN0YXJ0ID8gYmVoYXZpb3Iuc3RhcnQoYWN0b3JDdHgpIDogc3RhdGU7XG4gIHJldHVybiBhY3Rvcjtcbn1cblxuZXhwb3J0IHsgZnJvbVByb21pc2UsIGZyb21SZWR1Y2VyLCBzcGF3bkJlaGF2aW9yIH07XG4iLCJ2YXIgU1RBVEVfREVMSU1JVEVSID0gJy4nO1xudmFyIEVNUFRZX0FDVElWSVRZX01BUCA9IHt9O1xudmFyIERFRkFVTFRfR1VBUkRfVFlQRSA9ICd4c3RhdGUuZ3VhcmQnO1xudmFyIFRBUkdFVExFU1NfS0VZID0gJyc7XG5cbmV4cG9ydCB7IERFRkFVTFRfR1VBUkRfVFlQRSwgRU1QVFlfQUNUSVZJVFlfTUFQLCBTVEFURV9ERUxJTUlURVIsIFRBUkdFVExFU1NfS0VZIH07XG4iLCJpbXBvcnQgeyBJU19QUk9EVUNUSU9OIH0gZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5cbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cblxuICBpZiAoIUlTX1BST0RVQ1RJT04pIHtcbiAgICBjb25zb2xlLndhcm4oJ1hTdGF0ZSBjb3VsZCBub3QgZmluZCBhIGdsb2JhbCBvYmplY3QgaW4gdGhpcyBlbnZpcm9ubWVudC4gUGxlYXNlIGxldCB0aGUgbWFpbnRhaW5lcnMga25vdyBhbmQgcmFpc2UgYW4gaXNzdWUgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3N0YXRlbHlhaS94c3RhdGUvaXNzdWVzJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGV2VG9vbHMoKSB7XG4gIHZhciBnbG9iYWwgPSBnZXRHbG9iYWwoKTtcblxuICBpZiAoZ2xvYmFsICYmICdfX3hzdGF0ZV9fJyBpbiBnbG9iYWwpIHtcbiAgICByZXR1cm4gZ2xvYmFsLl9feHN0YXRlX187XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlclNlcnZpY2Uoc2VydmljZSkge1xuICBpZiAoIWdldEdsb2JhbCgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRldlRvb2xzID0gZ2V0RGV2VG9vbHMoKTtcblxuICBpZiAoZGV2VG9vbHMpIHtcbiAgICBkZXZUb29scy5yZWdpc3RlcihzZXJ2aWNlKTtcbiAgfVxufVxuXG5leHBvcnQgeyBnZXRHbG9iYWwsIHJlZ2lzdGVyU2VydmljZSB9O1xuIiwidmFyIElTX1BST0RVQ1RJT04gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuXG5leHBvcnQgeyBJU19QUk9EVUNUSU9OIH07XG4iLCJpbXBvcnQgeyBhc3NpZ24gYXMgYXNzaWduJDEsIGNhbmNlbCBhcyBjYW5jZWwkMSwgc2VuZCBhcyBzZW5kJDEsIHNlbmRUbyBhcyBzZW5kVG8kMSwgc2VuZFBhcmVudCBhcyBzZW5kUGFyZW50JDEsIHNlbmRVcGRhdGUgYXMgc2VuZFVwZGF0ZSQxLCBmb3J3YXJkVG8gYXMgZm9yd2FyZFRvJDEsIGRvbmVJbnZva2UgYXMgZG9uZUludm9rZSQxLCByYWlzZSBhcyByYWlzZSQxLCBsb2cgYXMgbG9nJDEsIHB1cmUgYXMgcHVyZSQxLCBjaG9vc2UgYXMgY2hvb3NlJDEsIHN0b3AgYXMgc3RvcCQxIH0gZnJvbSAnLi9hY3Rpb25zLmpzJztcbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSAnLi9hY3Rpb25zLmpzJztcbmV4cG9ydCB7IGFjdGlvbnMgfTtcbmV4cG9ydCB7IHRvQWN0b3JSZWYgfSBmcm9tICcuL0FjdG9yLmpzJztcbmV4cG9ydCB7IEludGVycHJldGVyLCBJbnRlcnByZXRlclN0YXR1cywgaW50ZXJwcmV0LCBzcGF3biB9IGZyb20gJy4vaW50ZXJwcmV0ZXIuanMnO1xuZXhwb3J0IHsgTWFjaGluZSwgY3JlYXRlTWFjaGluZSB9IGZyb20gJy4vTWFjaGluZS5qcyc7XG5leHBvcnQgeyBtYXBTdGF0ZSB9IGZyb20gJy4vbWFwU3RhdGUuanMnO1xuZXhwb3J0IHsgbWF0Y2hTdGF0ZSB9IGZyb20gJy4vbWF0Y2guanMnO1xuZXhwb3J0IHsgY3JlYXRlU2NoZW1hLCB0IH0gZnJvbSAnLi9zY2hlbWEuanMnO1xuZXhwb3J0IHsgU3RhdGUgfSBmcm9tICcuL1N0YXRlLmpzJztcbmV4cG9ydCB7IFN0YXRlTm9kZSB9IGZyb20gJy4vU3RhdGVOb2RlLmpzJztcbmV4cG9ydCB7IHNwYXduQmVoYXZpb3IgfSBmcm9tICcuL2JlaGF2aW9ycy5qcyc7XG5leHBvcnQgeyBBY3Rpb25UeXBlcywgU3BlY2lhbFRhcmdldHMgfSBmcm9tICcuL3R5cGVzLmpzJztcbmV4cG9ydCB7IG1hdGNoZXNTdGF0ZSwgdG9FdmVudE9iamVjdCwgdG9PYnNlcnZlciwgdG9TQ1hNTEV2ZW50IH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbnZhciBhc3NpZ24gPSBhc3NpZ24kMSxcbiAgICBjYW5jZWwgPSBjYW5jZWwkMSxcbiAgICBzZW5kID0gc2VuZCQxLFxuICAgIHNlbmRUbyA9IHNlbmRUbyQxLFxuICAgIHNlbmRQYXJlbnQgPSBzZW5kUGFyZW50JDEsXG4gICAgc2VuZFVwZGF0ZSA9IHNlbmRVcGRhdGUkMSxcbiAgICBmb3J3YXJkVG8gPSBmb3J3YXJkVG8kMSxcbiAgICBkb25lSW52b2tlID0gZG9uZUludm9rZSQxLFxuICAgIHJhaXNlID0gcmFpc2UkMSxcbiAgICBsb2cgPSBsb2ckMSxcbiAgICBwdXJlID0gcHVyZSQxLFxuICAgIGNob29zZSA9IGNob29zZSQxLFxuICAgIHN0b3AgPSBzdG9wJDE7XG5cbmV4cG9ydCB7IGFzc2lnbiwgY2FuY2VsLCBjaG9vc2UsIGRvbmVJbnZva2UsIGZvcndhcmRUbywgbG9nLCBwdXJlLCByYWlzZSwgc2VuZCwgc2VuZFBhcmVudCwgc2VuZFRvLCBzZW5kVXBkYXRlLCBzdG9wIH07XG4iLCJpbXBvcnQgeyBfX3ZhbHVlcywgX19zcHJlYWRBcnJheSwgX19yZWFkLCBfX2Fzc2lnbiB9IGZyb20gJy4vX3ZpcnR1YWwvX3RzbGliLmpzJztcbmltcG9ydCB7IFNwZWNpYWxUYXJnZXRzLCBBY3Rpb25UeXBlcyB9IGZyb20gJy4vdHlwZXMuanMnO1xuaW1wb3J0IHsgaXNTdGF0ZUNvbmZpZywgU3RhdGUsIGJpbmRBY3Rpb25Ub1N0YXRlIH0gZnJvbSAnLi9TdGF0ZS5qcyc7XG5pbXBvcnQgeyBlcnJvclBsYXRmb3JtLCB1cGRhdGUsIGVycm9yIGFzIGVycm9yJDEsIGxvZywgc3RvcCwgc3RhcnQsIGNhbmNlbCwgc2VuZCwgcmFpc2UgfSBmcm9tICcuL2FjdGlvblR5cGVzLmpzJztcbmltcG9ydCB7IGluaXRFdmVudCwgZG9uZUludm9rZSwgdG9BY3Rpb25PYmplY3RzLCByZXNvbHZlQWN0aW9ucywgZXJyb3IsIGdldEFjdGlvbkZ1bmN0aW9uIH0gZnJvbSAnLi9hY3Rpb25zLmpzJztcbmltcG9ydCB7IElTX1BST0RVQ1RJT04gfSBmcm9tICcuL2Vudmlyb25tZW50LmpzJztcbmltcG9ydCB7IHdhcm4sIG1hcENvbnRleHQsIHRvT2JzZXJ2ZXIsIGlzRnVuY3Rpb24sIHRvU0NYTUxFdmVudCwgZmxhdHRlbiwgaXNSYWlzYWJsZUFjdGlvbiwgaXNQcm9taXNlTGlrZSwgaXNPYnNlcnZhYmxlLCBpc01hY2hpbmUsIGlzQmVoYXZpb3IsIHJlcG9ydFVuaGFuZGxlZEV4Y2VwdGlvbk9uSW52b2NhdGlvbiwgc3ltYm9sT2JzZXJ2YWJsZSwgaXNBcnJheSwgdG9FdmVudE9iamVjdCwgaXNTdHJpbmcsIGlzQWN0b3IsIHRvSW52b2tlU291cmNlLCB1bmlxdWVJZCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgU2NoZWR1bGVyIH0gZnJvbSAnLi9zY2hlZHVsZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlRGVmZXJyZWRBY3RvciwgaXNTcGF3bmVkQWN0b3IgfSBmcm9tICcuL0FjdG9yLmpzJztcbmltcG9ydCB7IHJlZ2lzdHJ5IH0gZnJvbSAnLi9yZWdpc3RyeS5qcyc7XG5pbXBvcnQgeyBnZXRHbG9iYWwsIHJlZ2lzdGVyU2VydmljZSB9IGZyb20gJy4vZGV2VG9vbHMuanMnO1xuaW1wb3J0IHsgcHJvdmlkZSwgY29uc3VtZSB9IGZyb20gJy4vc2VydmljZVNjb3BlLmpzJztcbmltcG9ydCB7IHNwYXduQmVoYXZpb3IgfSBmcm9tICcuL2JlaGF2aW9ycy5qcyc7XG5cbnZhciBERUZBVUxUX1NQQVdOX09QVElPTlMgPSB7XG4gIHN5bmM6IGZhbHNlLFxuICBhdXRvRm9yd2FyZDogZmFsc2Vcbn07XG52YXIgSW50ZXJwcmV0ZXJTdGF0dXM7XG5cbihmdW5jdGlvbiAoSW50ZXJwcmV0ZXJTdGF0dXMpIHtcbiAgSW50ZXJwcmV0ZXJTdGF0dXNbSW50ZXJwcmV0ZXJTdGF0dXNbXCJOb3RTdGFydGVkXCJdID0gMF0gPSBcIk5vdFN0YXJ0ZWRcIjtcbiAgSW50ZXJwcmV0ZXJTdGF0dXNbSW50ZXJwcmV0ZXJTdGF0dXNbXCJSdW5uaW5nXCJdID0gMV0gPSBcIlJ1bm5pbmdcIjtcbiAgSW50ZXJwcmV0ZXJTdGF0dXNbSW50ZXJwcmV0ZXJTdGF0dXNbXCJTdG9wcGVkXCJdID0gMl0gPSBcIlN0b3BwZWRcIjtcbn0pKEludGVycHJldGVyU3RhdHVzIHx8IChJbnRlcnByZXRlclN0YXR1cyA9IHt9KSk7XG5cbnZhciBJbnRlcnByZXRlciA9XG4vKiNfX1BVUkVfXyovXG5cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBJbnRlcnByZXRlciBpbnN0YW5jZSAoaS5lLiwgc2VydmljZSkgZm9yIHRoZSBnaXZlbiBtYWNoaW5lIHdpdGggdGhlIHByb3ZpZGVkIG9wdGlvbnMsIGlmIGFueS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBtYWNoaW5lIFRoZSBtYWNoaW5lIHRvIGJlIGludGVycHJldGVkXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgSW50ZXJwcmV0ZXIgb3B0aW9uc1xyXG4gICAqL1xuICBmdW5jdGlvbiBJbnRlcnByZXRlcihtYWNoaW5lLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IEludGVycHJldGVyLmRlZmF1bHRPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLm1hY2hpbmUgPSBtYWNoaW5lO1xuICAgIHRoaXMuZGVsYXllZEV2ZW50c01hcCA9IHt9O1xuICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuY29udGV4dExpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnN0b3BMaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5kb25lTGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zZW5kTGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgc2VydmljZSBpcyBzdGFydGVkLlxyXG4gICAgICovXG5cbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0dXMgPSBJbnRlcnByZXRlclN0YXR1cy5Ob3RTdGFydGVkO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5mb3J3YXJkVG8gPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fb3V0Z29pbmdRdWV1ZSA9IFtdO1xuICAgIC8qKlxyXG4gICAgICogQWxpYXMgZm9yIEludGVycHJldGVyLnByb3RvdHlwZS5zdGFydFxyXG4gICAgICovXG5cbiAgICB0aGlzLmluaXQgPSB0aGlzLnN0YXJ0O1xuICAgIC8qKlxyXG4gICAgICogU2VuZHMgYW4gZXZlbnQgdG8gdGhlIHJ1bm5pbmcgaW50ZXJwcmV0ZXIgdG8gdHJpZ2dlciBhIHRyYW5zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQW4gYXJyYXkgb2YgZXZlbnRzIChiYXRjaGVkKSBjYW4gYmUgc2VudCBhcyB3ZWxsLCB3aGljaCB3aWxsIHNlbmQgYWxsXHJcbiAgICAgKiBiYXRjaGVkIGV2ZW50cyB0byB0aGUgcnVubmluZyBpbnRlcnByZXRlci4gVGhlIGxpc3RlbmVycyB3aWxsIGJlXHJcbiAgICAgKiBub3RpZmllZCBvbmx5ICoqb25jZSoqIHdoZW4gYWxsIGV2ZW50cyBhcmUgcHJvY2Vzc2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQocykgdG8gc2VuZFxyXG4gICAgICovXG5cbiAgICB0aGlzLnNlbmQgPSBmdW5jdGlvbiAoZXZlbnQsIHBheWxvYWQpIHtcbiAgICAgIGlmIChpc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBfdGhpcy5iYXRjaChldmVudCk7XG5cbiAgICAgICAgcmV0dXJuIF90aGlzLnN0YXRlO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2V2ZW50ID0gdG9TQ1hNTEV2ZW50KHRvRXZlbnRPYmplY3QoZXZlbnQsIHBheWxvYWQpKTtcblxuICAgICAgaWYgKF90aGlzLnN0YXR1cyA9PT0gSW50ZXJwcmV0ZXJTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIGlmICghSVNfUFJPRFVDVElPTikge1xuICAgICAgICAgIHdhcm4oZmFsc2UsIFwiRXZlbnQgXFxcIlwiLmNvbmNhdChfZXZlbnQubmFtZSwgXCJcXFwiIHdhcyBzZW50IHRvIHN0b3BwZWQgc2VydmljZSBcXFwiXCIpLmNvbmNhdChfdGhpcy5tYWNoaW5lLmlkLCBcIlxcXCIuIFRoaXMgc2VydmljZSBoYXMgYWxyZWFkeSByZWFjaGVkIGl0cyBmaW5hbCBzdGF0ZSwgYW5kIHdpbGwgbm90IHRyYW5zaXRpb24uXFxuRXZlbnQ6IFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkoX2V2ZW50LmRhdGEpKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMuc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5zdGF0dXMgIT09IEludGVycHJldGVyU3RhdHVzLlJ1bm5pbmcgJiYgIV90aGlzLm9wdGlvbnMuZGVmZXJFdmVudHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgXFxcIlwiLmNvbmNhdChfZXZlbnQubmFtZSwgXCJcXFwiIHdhcyBzZW50IHRvIHVuaW5pdGlhbGl6ZWQgc2VydmljZSBcXFwiXCIpLmNvbmNhdChfdGhpcy5tYWNoaW5lLmlkIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgICAgLCBcIlxcXCIuIE1ha2Ugc3VyZSAuc3RhcnQoKSBpcyBjYWxsZWQgZm9yIHRoaXMgc2VydmljZSwgb3Igc2V0IHsgZGVmZXJFdmVudHM6IHRydWUgfSBpbiB0aGUgc2VydmljZSBvcHRpb25zLlxcbkV2ZW50OiBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KF9ldmVudC5kYXRhKSkpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGb3J3YXJkIGNvcHkgb2YgZXZlbnQgdG8gY2hpbGQgYWN0b3JzXG4gICAgICAgIF90aGlzLmZvcndhcmQoX2V2ZW50KTtcblxuICAgICAgICB2YXIgbmV4dFN0YXRlID0gX3RoaXMuX25leHRTdGF0ZShfZXZlbnQpO1xuXG4gICAgICAgIF90aGlzLnVwZGF0ZShuZXh0U3RhdGUsIF9ldmVudCk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF90aGlzLl9zdGF0ZTsgLy8gVE9ETzogZGVwcmVjYXRlIChzaG91bGQgcmV0dXJuIHZvaWQpXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6c2VtaWNvbG9uXG4gICAgfTtcblxuICAgIHRoaXMuc2VuZFRvID0gZnVuY3Rpb24gKGV2ZW50LCB0bywgaW1tZWRpYXRlKSB7XG4gICAgICB2YXIgaXNQYXJlbnQgPSBfdGhpcy5wYXJlbnQgJiYgKHRvID09PSBTcGVjaWFsVGFyZ2V0cy5QYXJlbnQgfHwgX3RoaXMucGFyZW50LmlkID09PSB0byk7XG4gICAgICB2YXIgdGFyZ2V0ID0gaXNQYXJlbnQgPyBfdGhpcy5wYXJlbnQgOiBpc1N0cmluZyh0bykgPyB0byA9PT0gU3BlY2lhbFRhcmdldHMuSW50ZXJuYWwgPyBfdGhpcyA6IF90aGlzLmNoaWxkcmVuLmdldCh0bykgfHwgcmVnaXN0cnkuZ2V0KHRvKSA6IGlzQWN0b3IodG8pID8gdG8gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIGlmICghaXNQYXJlbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gc2VuZCBldmVudCB0byBjaGlsZCAnXCIuY29uY2F0KHRvLCBcIicgZnJvbSBzZXJ2aWNlICdcIikuY29uY2F0KF90aGlzLmlkLCBcIicuXCIpKTtcbiAgICAgICAgfSAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuXG5cbiAgICAgICAgaWYgKCFJU19QUk9EVUNUSU9OKSB7XG4gICAgICAgICAgd2FybihmYWxzZSwgXCJTZXJ2aWNlICdcIi5jb25jYXQoX3RoaXMuaWQsIFwiJyBoYXMgbm8gcGFyZW50OiB1bmFibGUgdG8gc2VuZCBldmVudCBcIikuY29uY2F0KGV2ZW50LnR5cGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCdtYWNoaW5lJyBpbiB0YXJnZXQpIHtcbiAgICAgICAgLy8gcGVyaGFwcyB0aG9zZSBldmVudHMgc2hvdWxkIGJlIHJlamVjdGVkIGluIHRoZSBwYXJlbnRcbiAgICAgICAgLy8gYnV0IGF0bSBpdCBkb2Vzbid0IGhhdmUgZWFzeSBhY2Nlc3MgdG8gYWxsIG9mIHRoZSBpbmZvcm1hdGlvbiB0aGF0IGlzIHJlcXVpcmVkIHRvIGRvIGl0IHJlbGlhYmx5XG4gICAgICAgIGlmIChfdGhpcy5zdGF0dXMgIT09IEludGVycHJldGVyU3RhdHVzLlN0b3BwZWQgfHwgX3RoaXMucGFyZW50ICE9PSB0YXJnZXQgfHwgLy8gd2UgbmVlZCB0byBzZW5kIGV2ZW50cyB0byB0aGUgcGFyZW50IGZyb20gZXhpdCBoYW5kbGVycyBvZiBhIG1hY2hpbmUgdGhhdCByZWFjaGVkIGl0cyBmaW5hbCBzdGF0ZVxuICAgICAgICBfdGhpcy5zdGF0ZS5kb25lKSB7XG4gICAgICAgICAgLy8gU2VuZCBTQ1hNTCBldmVudHMgdG8gbWFjaGluZXNcbiAgICAgICAgICB2YXIgc2N4bWxFdmVudCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBldmVudCksIHtcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50Lm5hbWUgPT09IGVycm9yJDEgPyBcIlwiLmNvbmNhdChlcnJvcihfdGhpcy5pZCkpIDogZXZlbnQubmFtZSxcbiAgICAgICAgICAgIG9yaWdpbjogX3RoaXMuc2Vzc2lvbklkXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIWltbWVkaWF0ZSAmJiBfdGhpcy5tYWNoaW5lLmNvbmZpZy5wcmVkaWN0YWJsZUFjdGlvbkFyZ3VtZW50cykge1xuICAgICAgICAgICAgX3RoaXMuX291dGdvaW5nUXVldWUucHVzaChbdGFyZ2V0LCBzY3htbEV2ZW50XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5zZW5kKHNjeG1sRXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2VuZCBub3JtYWwgZXZlbnRzIHRvIG90aGVyIHRhcmdldHNcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUgJiYgX3RoaXMubWFjaGluZS5jb25maWcucHJlZGljdGFibGVBY3Rpb25Bcmd1bWVudHMpIHtcbiAgICAgICAgICBfdGhpcy5fb3V0Z29pbmdRdWV1ZS5wdXNoKFt0YXJnZXQsIGV2ZW50LmRhdGFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXQuc2VuZChldmVudC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl9leGVjID0gZnVuY3Rpb24gKGFjdGlvbiwgY29udGV4dCwgX2V2ZW50LCBhY3Rpb25GdW5jdGlvbk1hcCkge1xuICAgICAgaWYgKGFjdGlvbkZ1bmN0aW9uTWFwID09PSB2b2lkIDApIHtcbiAgICAgICAgYWN0aW9uRnVuY3Rpb25NYXAgPSBfdGhpcy5tYWNoaW5lLm9wdGlvbnMuYWN0aW9ucztcbiAgICAgIH1cblxuICAgICAgdmFyIGFjdGlvbk9yRXhlYyA9IGFjdGlvbi5leGVjIHx8IGdldEFjdGlvbkZ1bmN0aW9uKGFjdGlvbi50eXBlLCBhY3Rpb25GdW5jdGlvbk1hcCk7XG4gICAgICB2YXIgZXhlYyA9IGlzRnVuY3Rpb24oYWN0aW9uT3JFeGVjKSA/IGFjdGlvbk9yRXhlYyA6IGFjdGlvbk9yRXhlYyA/IGFjdGlvbk9yRXhlYy5leGVjIDogYWN0aW9uLmV4ZWM7XG5cbiAgICAgIGlmIChleGVjKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGV4ZWMoY29udGV4dCwgX2V2ZW50LmRhdGEsICFfdGhpcy5tYWNoaW5lLmNvbmZpZy5wcmVkaWN0YWJsZUFjdGlvbkFyZ3VtZW50cyA/IHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgc3RhdGU6IF90aGlzLnN0YXRlLFxuICAgICAgICAgICAgX2V2ZW50OiBfZXZlbnRcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBfZXZlbnQ6IF9ldmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5wYXJlbnQuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6ICd4c3RhdGUuZXJyb3InLFxuICAgICAgICAgICAgICBkYXRhOiBlcnJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgcmFpc2U6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gaWYgcmFpc2UgYWN0aW9uIHJlYWNoZWQgdGhlIGludGVycHJldGVyIHRoZW4gaXQncyBhIGRlbGF5ZWQgb25lXG4gICAgICAgICAgICB2YXIgc2VuZEFjdGlvbl8xID0gYWN0aW9uO1xuXG4gICAgICAgICAgICBfdGhpcy5kZWZlcihzZW5kQWN0aW9uXzEpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBzZW5kOlxuICAgICAgICAgIHZhciBzZW5kQWN0aW9uID0gYWN0aW9uO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBzZW5kQWN0aW9uLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgX3RoaXMuZGVmZXIoc2VuZEFjdGlvbik7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlbmRBY3Rpb24udG8pIHtcbiAgICAgICAgICAgICAgX3RoaXMuc2VuZFRvKHNlbmRBY3Rpb24uX2V2ZW50LCBzZW5kQWN0aW9uLnRvLCBfZXZlbnQgPT09IGluaXRFdmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpcy5zZW5kKHNlbmRBY3Rpb24uX2V2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGNhbmNlbDpcbiAgICAgICAgICBfdGhpcy5jYW5jZWwoYWN0aW9uLnNlbmRJZCk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0dXMgIT09IEludGVycHJldGVyU3RhdHVzLlJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYWN0aXZpdHkgPSBhY3Rpb24uYWN0aXZpdHk7IC8vIElmIHRoZSBhY3Rpdml0eSB3aWxsIGJlIHN0b3BwZWQgcmlnaHQgYWZ0ZXIgaXQncyBzdGFydGVkXG4gICAgICAgICAgICAvLyAoc3VjaCBhcyBpbiB0cmFuc2llbnQgc3RhdGVzKVxuICAgICAgICAgICAgLy8gZG9uJ3QgYm90aGVyIHN0YXJ0aW5nIHRoZSBhY3Rpdml0eS5cblxuICAgICAgICAgICAgaWYgKCAvLyBpbiB2NCB3aXRoIGBwcmVkaWN0YWJsZUFjdGlvbkFyZ3VtZW50c2AgaW52b2tlcyBhcmUgY2FsbGVkIGVhZ2VybHkgd2hlbiB0aGUgYHRoaXMuc3RhdGVgIHN0aWxsIHBvaW50cyB0byB0aGUgcHJldmlvdXMgc3RhdGVcbiAgICAgICAgICAgICFfdGhpcy5tYWNoaW5lLmNvbmZpZy5wcmVkaWN0YWJsZUFjdGlvbkFyZ3VtZW50cyAmJiAhX3RoaXMuc3RhdGUuYWN0aXZpdGllc1thY3Rpdml0eS5pZCB8fCBhY3Rpdml0eS50eXBlXSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gLy8gSW52b2tlZCBzZXJ2aWNlc1xuXG5cbiAgICAgICAgICAgIGlmIChhY3Rpdml0eS50eXBlID09PSBBY3Rpb25UeXBlcy5JbnZva2UpIHtcbiAgICAgICAgICAgICAgdmFyIGludm9rZVNvdXJjZSA9IHRvSW52b2tlU291cmNlKGFjdGl2aXR5LnNyYyk7XG4gICAgICAgICAgICAgIHZhciBzZXJ2aWNlQ3JlYXRvciA9IF90aGlzLm1hY2hpbmUub3B0aW9ucy5zZXJ2aWNlcyA/IF90aGlzLm1hY2hpbmUub3B0aW9ucy5zZXJ2aWNlc1tpbnZva2VTb3VyY2UudHlwZV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIHZhciBpZCA9IGFjdGl2aXR5LmlkLFxuICAgICAgICAgICAgICAgICAgZGF0YSA9IGFjdGl2aXR5LmRhdGE7XG5cbiAgICAgICAgICAgICAgaWYgKCFJU19QUk9EVUNUSU9OKSB7XG4gICAgICAgICAgICAgICAgd2FybighKCdmb3J3YXJkJyBpbiBhY3Rpdml0eSksIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgICAgICAgICAgICBcImBmb3J3YXJkYCBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkIChmb3VuZCBpbiBpbnZvY2F0aW9uIG9mICdcIi5jb25jYXQoYWN0aXZpdHkuc3JjLCBcIicgaW4gaW4gbWFjaGluZSAnXCIpLmNvbmNhdChfdGhpcy5tYWNoaW5lLmlkLCBcIicpLiBcIikgKyBcIlBsZWFzZSB1c2UgYGF1dG9Gb3J3YXJkYCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBhdXRvRm9yd2FyZCA9ICdhdXRvRm9yd2FyZCcgaW4gYWN0aXZpdHkgPyBhY3Rpdml0eS5hdXRvRm9yd2FyZCA6ICEhYWN0aXZpdHkuZm9yd2FyZDtcblxuICAgICAgICAgICAgICBpZiAoIXNlcnZpY2VDcmVhdG9yKSB7XG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBpZiAoIUlTX1BST0RVQ1RJT04pIHtcbiAgICAgICAgICAgICAgICAgIHdhcm4oZmFsc2UsIFwiTm8gc2VydmljZSBmb3VuZCBmb3IgaW52b2NhdGlvbiAnXCIuY29uY2F0KGFjdGl2aXR5LnNyYywgXCInIGluIG1hY2hpbmUgJ1wiKS5jb25jYXQoX3RoaXMubWFjaGluZS5pZCwgXCInLlwiKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHJlc29sdmVkRGF0YSA9IGRhdGEgPyBtYXBDb250ZXh0KGRhdGEsIGNvbnRleHQsIF9ldmVudCkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXJ2aWNlQ3JlYXRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3YXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGlzRnVuY3Rpb24oc2VydmljZUNyZWF0b3IpID8gc2VydmljZUNyZWF0b3IoY29udGV4dCwgX2V2ZW50LmRhdGEsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiByZXNvbHZlZERhdGEsXG4gICAgICAgICAgICAgICAgc3JjOiBpbnZva2VTb3VyY2UsXG4gICAgICAgICAgICAgICAgbWV0YTogYWN0aXZpdHkubWV0YVxuICAgICAgICAgICAgICB9KSA6IHNlcnZpY2VDcmVhdG9yO1xuXG4gICAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2Fybj9cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICBpZiAoaXNNYWNoaW5lKHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSByZXNvbHZlZERhdGEgPyBzb3VyY2Uud2l0aENvbnRleHQocmVzb2x2ZWREYXRhKSA6IHNvdXJjZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgYXV0b0ZvcndhcmQ6IGF1dG9Gb3J3YXJkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF90aGlzLnNwYXduKHNvdXJjZSwgaWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXMuc3Bhd25BY3Rpdml0eShhY3Rpdml0eSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIHN0b3A6XG4gICAgICAgICAge1xuICAgICAgICAgICAgX3RoaXMuc3RvcENoaWxkKGFjdGlvbi5hY3Rpdml0eS5pZCk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIGxvZzpcbiAgICAgICAgICB2YXIgX2EgPSBhY3Rpb24sXG4gICAgICAgICAgICAgIGxhYmVsID0gX2EubGFiZWwsXG4gICAgICAgICAgICAgIHZhbHVlID0gX2EudmFsdWU7XG5cbiAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlcihsYWJlbCwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIodmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFJU19QUk9EVUNUSU9OKSB7XG4gICAgICAgICAgICB3YXJuKGZhbHNlLCBcIk5vIGltcGxlbWVudGF0aW9uIGZvdW5kIGZvciBhY3Rpb24gdHlwZSAnXCIuY29uY2F0KGFjdGlvbi50eXBlLCBcIidcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZWRPcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIEludGVycHJldGVyLmRlZmF1bHRPcHRpb25zKSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgY2xvY2sgPSByZXNvbHZlZE9wdGlvbnMuY2xvY2ssXG4gICAgICAgIGxvZ2dlciA9IHJlc29sdmVkT3B0aW9ucy5sb2dnZXIsXG4gICAgICAgIHBhcmVudCA9IHJlc29sdmVkT3B0aW9ucy5wYXJlbnQsXG4gICAgICAgIGlkID0gcmVzb2x2ZWRPcHRpb25zLmlkO1xuICAgIHZhciByZXNvbHZlZElkID0gaWQgIT09IHVuZGVmaW5lZCA/IGlkIDogbWFjaGluZS5pZDtcbiAgICB0aGlzLmlkID0gcmVzb2x2ZWRJZDtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmNsb2NrID0gY2xvY2s7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gcmVzb2x2ZWRPcHRpb25zO1xuICAgIHRoaXMuc2NoZWR1bGVyID0gbmV3IFNjaGVkdWxlcih7XG4gICAgICBkZWZlckV2ZW50czogdGhpcy5vcHRpb25zLmRlZmVyRXZlbnRzXG4gICAgfSk7XG4gICAgdGhpcy5zZXNzaW9uSWQgPSByZWdpc3RyeS5ib29rSWQoKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnRlcnByZXRlci5wcm90b3R5cGUsIFwiaW5pdGlhbFN0YXRlXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9pbml0aWFsU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXRpYWxTdGF0ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb3ZpZGUodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5faW5pdGlhbFN0YXRlID0gX3RoaXMubWFjaGluZS5pbml0aWFsU3RhdGU7XG4gICAgICAgIHJldHVybiBfdGhpcy5faW5pdGlhbFN0YXRlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnRlcnByZXRlci5wcm90b3R5cGUsIFwic3RhdGVcIiwge1xuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGAuZ2V0U25hcHNob3QoKWAgaW5zdGVhZC5cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFJU19QUk9EVUNUSU9OKSB7XG4gICAgICAgIHdhcm4odGhpcy5zdGF0dXMgIT09IEludGVycHJldGVyU3RhdHVzLk5vdFN0YXJ0ZWQsIFwiQXR0ZW1wdGVkIHRvIHJlYWQgc3RhdGUgZnJvbSB1bmluaXRpYWxpemVkIHNlcnZpY2UgJ1wiLmNvbmNhdCh0aGlzLmlkLCBcIicuIE1ha2Ugc3VyZSB0aGUgc2VydmljZSBpcyBzdGFydGVkIGZpcnN0LlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXHJcbiAgICogRXhlY3V0ZXMgdGhlIGFjdGlvbnMgb2YgdGhlIGdpdmVuIHN0YXRlLCB3aXRoIHRoYXQgc3RhdGUncyBgY29udGV4dGAgYW5kIGBldmVudGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHdob3NlIGFjdGlvbnMgd2lsbCBiZSBleGVjdXRlZFxyXG4gICAqIEBwYXJhbSBhY3Rpb25zQ29uZmlnIFRoZSBhY3Rpb24gaW1wbGVtZW50YXRpb25zIHRvIHVzZVxyXG4gICAqL1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb25zQ29uZmlnKSB7XG4gICAgdmFyIGVfMSwgX2E7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhzdGF0ZS5hY3Rpb25zKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICB2YXIgYWN0aW9uID0gX2MudmFsdWU7XG4gICAgICAgIHRoaXMuZXhlYyhhY3Rpb24sIHN0YXRlLCBhY3Rpb25zQ29uZmlnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgZV8xID0ge1xuICAgICAgICBlcnJvcjogZV8xXzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgX2V2ZW50KSB7XG4gICAgdmFyIGVfMiwgX2EsIGVfMywgX2IsIGVfNCwgX2MsIGVfNSwgX2Q7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzOyAvLyBBdHRhY2ggc2Vzc2lvbiBJRCB0byBzdGF0ZVxuXG5cbiAgICBzdGF0ZS5fc2Vzc2lvbmlkID0gdGhpcy5zZXNzaW9uSWQ7IC8vIFVwZGF0ZSBzdGF0ZVxuXG4gICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTsgLy8gRXhlY3V0ZSBhY3Rpb25zXG5cbiAgICBpZiAoKCF0aGlzLm1hY2hpbmUuY29uZmlnLnByZWRpY3RhYmxlQWN0aW9uQXJndW1lbnRzIHx8IC8vIHRoaXMgaXMgY3VycmVudGx5IHJlcXVpcmVkIHRvIGV4ZWN1dGUgaW5pdGlhbCBhY3Rpb25zIGFzIHRoZSBgaW5pdGlhbFN0YXRlYCBnZXRzIGNhY2hlZFxuICAgIC8vIHdlIGNhbid0IGp1c3QgcmVjb21wdXRlIGl0IChhbmQgZXhlY3V0ZSBhY3Rpb25zIHdoaWxlIGRvaW5nIHNvKSBiZWNhdXNlIHdlIHRyeSB0byBwcmVzZXJ2ZSBpZGVudGl0eSBvZiBhY3RvcnMgY3JlYXRlZCB3aXRoaW4gaW5pdGlhbCBhc3NpZ25zXG4gICAgX2V2ZW50ID09PSBpbml0RXZlbnQpICYmIHRoaXMub3B0aW9ucy5leGVjdXRlKSB7XG4gICAgICB0aGlzLmV4ZWN1dGUodGhpcy5zdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpdGVtID0gdm9pZCAwO1xuXG4gICAgICB3aGlsZSAoaXRlbSA9IHRoaXMuX291dGdvaW5nUXVldWUuc2hpZnQoKSkge1xuICAgICAgICBpdGVtWzBdLnNlbmQoaXRlbVsxXSk7XG4gICAgICB9XG4gICAgfSAvLyBVcGRhdGUgY2hpbGRyZW5cblxuXG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgX3RoaXMuc3RhdGUuY2hpbGRyZW5bY2hpbGQuaWRdID0gY2hpbGQ7XG4gICAgfSk7IC8vIERldiB0b29sc1xuXG4gICAgaWYgKHRoaXMuZGV2VG9vbHMpIHtcbiAgICAgIHRoaXMuZGV2VG9vbHMuc2VuZChfZXZlbnQuZGF0YSwgc3RhdGUpO1xuICAgIH0gLy8gRXhlY3V0ZSBsaXN0ZW5lcnNcblxuXG4gICAgaWYgKHN0YXRlLmV2ZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfZSA9IF9fdmFsdWVzKHRoaXMuZXZlbnRMaXN0ZW5lcnMpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGxpc3RlbmVyID0gX2YudmFsdWU7XG4gICAgICAgICAgbGlzdGVuZXIoc3RhdGUuZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzJfMSkge1xuICAgICAgICBlXzIgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfMl8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChfZiAmJiAhX2YuZG9uZSAmJiAoX2EgPSBfZS5yZXR1cm4pKSBfYS5jYWxsKF9lKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2cgPSBfX3ZhbHVlcyh0aGlzLmxpc3RlbmVycyksIF9oID0gX2cubmV4dCgpOyAhX2guZG9uZTsgX2ggPSBfZy5uZXh0KCkpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gX2gudmFsdWU7XG4gICAgICAgIGxpc3RlbmVyKHN0YXRlLCBzdGF0ZS5ldmVudCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZV8zXzEpIHtcbiAgICAgIGVfMyA9IHtcbiAgICAgICAgZXJyb3I6IGVfM18xXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoX2ggJiYgIV9oLmRvbmUgJiYgKF9iID0gX2cucmV0dXJuKSkgX2IuY2FsbChfZyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9qID0gX192YWx1ZXModGhpcy5jb250ZXh0TGlzdGVuZXJzKSwgX2sgPSBfai5uZXh0KCk7ICFfay5kb25lOyBfayA9IF9qLm5leHQoKSkge1xuICAgICAgICB2YXIgY29udGV4dExpc3RlbmVyID0gX2sudmFsdWU7XG4gICAgICAgIGNvbnRleHRMaXN0ZW5lcih0aGlzLnN0YXRlLmNvbnRleHQsIHRoaXMuc3RhdGUuaGlzdG9yeSA/IHRoaXMuc3RhdGUuaGlzdG9yeS5jb250ZXh0IDogdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzRfMSkge1xuICAgICAgZV80ID0ge1xuICAgICAgICBlcnJvcjogZV80XzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfayAmJiAhX2suZG9uZSAmJiAoX2MgPSBfai5yZXR1cm4pKSBfYy5jYWxsKF9qKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5kb25lKSB7XG4gICAgICAvLyBnZXQgZmluYWwgY2hpbGQgc3RhdGUgbm9kZVxuICAgICAgdmFyIGZpbmFsQ2hpbGRTdGF0ZU5vZGUgPSBzdGF0ZS5jb25maWd1cmF0aW9uLmZpbmQoZnVuY3Rpb24gKHNuKSB7XG4gICAgICAgIHJldHVybiBzbi50eXBlID09PSAnZmluYWwnICYmIHNuLnBhcmVudCA9PT0gX3RoaXMubWFjaGluZTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGRvbmVEYXRhID0gZmluYWxDaGlsZFN0YXRlTm9kZSAmJiBmaW5hbENoaWxkU3RhdGVOb2RlLmRvbmVEYXRhID8gbWFwQ29udGV4dChmaW5hbENoaWxkU3RhdGVOb2RlLmRvbmVEYXRhLCBzdGF0ZS5jb250ZXh0LCBfZXZlbnQpIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fZG9uZUV2ZW50ID0gZG9uZUludm9rZSh0aGlzLmlkLCBkb25lRGF0YSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9sID0gX192YWx1ZXModGhpcy5kb25lTGlzdGVuZXJzKSwgX20gPSBfbC5uZXh0KCk7ICFfbS5kb25lOyBfbSA9IF9sLm5leHQoKSkge1xuICAgICAgICAgIHZhciBsaXN0ZW5lciA9IF9tLnZhbHVlO1xuICAgICAgICAgIGxpc3RlbmVyKHRoaXMuX2RvbmVFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVfNV8xKSB7XG4gICAgICAgIGVfNSA9IHtcbiAgICAgICAgICBlcnJvcjogZV81XzFcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKF9tICYmICFfbS5kb25lICYmIChfZCA9IF9sLnJldHVybikpIF9kLmNhbGwoX2wpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zdG9wKCk7XG5cbiAgICAgIHRoaXMuX3N0b3BDaGlsZHJlbigpO1xuXG4gICAgICByZWdpc3RyeS5mcmVlKHRoaXMuc2Vzc2lvbklkKTtcbiAgICB9XG4gIH07XG4gIC8qXHJcbiAgICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgaXMgbm90aWZpZWQgd2hlbmV2ZXIgYSBzdGF0ZSB0cmFuc2l0aW9uIGhhcHBlbnMuIFRoZSBsaXN0ZW5lciBpcyBjYWxsZWQgd2l0aFxyXG4gICAqIHRoZSBuZXh0IHN0YXRlIGFuZCB0aGUgZXZlbnQgb2JqZWN0IHRoYXQgY2F1c2VkIHRoZSBzdGF0ZSB0cmFuc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBzdGF0ZSBsaXN0ZW5lclxyXG4gICAqL1xuXG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLm9uVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIHRoaXMubGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7IC8vIFNlbmQgY3VycmVudCBzdGF0ZSB0byBsaXN0ZW5lclxuXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBJbnRlcnByZXRlclN0YXR1cy5SdW5uaW5nKSB7XG4gICAgICBsaXN0ZW5lcih0aGlzLnN0YXRlLCB0aGlzLnN0YXRlLmV2ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG5leHRMaXN0ZW5lck9yT2JzZXJ2ZXIsIF8sIC8vIFRPRE86IGVycm9yIGxpc3RlbmVyXG4gIGNvbXBsZXRlTGlzdGVuZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9ic2VydmVyID0gdG9PYnNlcnZlcihuZXh0TGlzdGVuZXJPck9ic2VydmVyLCBfLCBjb21wbGV0ZUxpc3RlbmVyKTtcbiAgICB0aGlzLmxpc3RlbmVycy5hZGQob2JzZXJ2ZXIubmV4dCk7IC8vIFNlbmQgY3VycmVudCBzdGF0ZSB0byBsaXN0ZW5lclxuXG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBJbnRlcnByZXRlclN0YXR1cy5Ob3RTdGFydGVkKSB7XG4gICAgICBvYnNlcnZlci5uZXh0KHRoaXMuc3RhdGUpO1xuICAgIH1cblxuICAgIHZhciBjb21wbGV0ZU9uY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5kb25lTGlzdGVuZXJzLmRlbGV0ZShjb21wbGV0ZU9uY2UpO1xuXG4gICAgICBfdGhpcy5zdG9wTGlzdGVuZXJzLmRlbGV0ZShjb21wbGV0ZU9uY2UpO1xuXG4gICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgIH07XG5cbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEludGVycHJldGVyU3RhdHVzLlN0b3BwZWQpIHtcbiAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25Eb25lKGNvbXBsZXRlT25jZSk7XG4gICAgICB0aGlzLm9uU3RvcChjb21wbGV0ZU9uY2UpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5saXN0ZW5lcnMuZGVsZXRlKG9ic2VydmVyLm5leHQpO1xuXG4gICAgICAgIF90aGlzLmRvbmVMaXN0ZW5lcnMuZGVsZXRlKGNvbXBsZXRlT25jZSk7XG5cbiAgICAgICAgX3RoaXMuc3RvcExpc3RlbmVycy5kZWxldGUoY29tcGxldGVPbmNlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICAvKipcclxuICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgaXMgbm90aWZpZWQgd2hlbmV2ZXIgYW4gZXZlbnQgaXMgc2VudCB0byB0aGUgcnVubmluZyBpbnRlcnByZXRlci5cclxuICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGV2ZW50IGxpc3RlbmVyXHJcbiAgICovXG5cblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUub25FdmVudCA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGlzIG5vdGlmaWVkIHdoZW5ldmVyIGEgYHNlbmRgIGV2ZW50IG9jY3Vycy5cclxuICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGV2ZW50IGxpc3RlbmVyXHJcbiAgICovXG5cblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUub25TZW5kID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5zZW5kTGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIEFkZHMgYSBjb250ZXh0IGxpc3RlbmVyIHRoYXQgaXMgbm90aWZpZWQgd2hlbmV2ZXIgdGhlIHN0YXRlIGNvbnRleHQgY2hhbmdlcy5cclxuICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGNvbnRleHQgbGlzdGVuZXJcclxuICAgKi9cblxuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5vbkNoYW5nZSA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIHRoaXMuY29udGV4dExpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBBZGRzIGEgbGlzdGVuZXIgdGhhdCBpcyBub3RpZmllZCB3aGVuIHRoZSBtYWNoaW5lIGlzIHN0b3BwZWQuXHJcbiAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lclxyXG4gICAqL1xuXG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLm9uU3RvcCA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIHRoaXMuc3RvcExpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBBZGRzIGEgc3RhdGUgbGlzdGVuZXIgdGhhdCBpcyBub3RpZmllZCB3aGVuIHRoZSBzdGF0ZWNoYXJ0IGhhcyByZWFjaGVkIGl0cyBmaW5hbCBzdGF0ZS5cclxuICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIHN0YXRlIGxpc3RlbmVyXHJcbiAgICovXG5cblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUub25Eb25lID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBJbnRlcnByZXRlclN0YXR1cy5TdG9wcGVkICYmIHRoaXMuX2RvbmVFdmVudCkge1xuICAgICAgbGlzdGVuZXIodGhpcy5fZG9uZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb25lTGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgYSBsaXN0ZW5lci5cclxuICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIHJlbW92ZVxyXG4gICAqL1xuXG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIHRoaXMuc2VuZExpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIHRoaXMuc3RvcExpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIHRoaXMuZG9uZUxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIHRoaXMuY29udGV4dExpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBTdGFydHMgdGhlIGludGVycHJldGVyIGZyb20gdGhlIGdpdmVuIHN0YXRlLCBvciB0aGUgaW5pdGlhbCBzdGF0ZS5cclxuICAgKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFRoZSBzdGF0ZSB0byBzdGFydCB0aGUgc3RhdGVjaGFydCBmcm9tXHJcbiAgICovXG5cblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gSW50ZXJwcmV0ZXJTdGF0dXMuUnVubmluZykge1xuICAgICAgLy8gRG8gbm90IHJlc3RhcnQgdGhlIHNlcnZpY2UgaWYgaXQgaXMgYWxyZWFkeSBzdGFydGVkXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIHllcywgaXQncyBhIGhhY2sgYnV0IHdlIG5lZWQgdGhlIHJlbGF0ZWQgY2FjaGUgdG8gYmUgcG9wdWxhdGVkIGZvciBzb21lIHRoaW5ncyB0byB3b3JrIChsaWtlIGRlbGF5ZWQgdHJhbnNpdGlvbnMpXG4gICAgLy8gdGhpcyBpcyB1c3VhbGx5IGNhbGxlZCBieSBgbWFjaGluZS5nZXRJbml0aWFsU3RhdGVgIGJ1dCBpZiB3ZSByZWh5ZHJhdGUgZnJvbSBhIHN0YXRlIHdlIG1pZ2h0IGJ5cGFzcyB0aGlzIGNhbGxcbiAgICAvLyB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB0aGlzIG1ldGhvZCBoZXJlIGFzIGl0IHJlc29sdmVzIHRoZSBmdWxsIGluaXRpYWwgc3RhdGUgd2hpY2ggbWlnaHQgaW52b2x2ZSBjYWxsaW5nIGFzc2lnbiBhY3Rpb25zXG4gICAgLy8gYW5kIHRoYXQgY291bGQgcG90ZW50aWFsbHkgbGVhZCB0byBzb21lIHVud2FudGVkIHNpZGUtZWZmZWN0cyAoZXZlbiBzdWNoIGFzIGNyZWF0aW5nIHNvbWUgcm9ndWUgYWN0b3JzKVxuXG5cbiAgICB0aGlzLm1hY2hpbmUuX2luaXQoKTtcblxuICAgIHJlZ2lzdHJ5LnJlZ2lzdGVyKHRoaXMuc2Vzc2lvbklkLCB0aGlzKTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXR1cyA9IEludGVycHJldGVyU3RhdHVzLlJ1bm5pbmc7XG4gICAgdmFyIHJlc29sdmVkU3RhdGUgPSBpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCA/IHRoaXMuaW5pdGlhbFN0YXRlIDogcHJvdmlkZSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaXNTdGF0ZUNvbmZpZyhpbml0aWFsU3RhdGUpID8gX3RoaXMubWFjaGluZS5yZXNvbHZlU3RhdGUoaW5pdGlhbFN0YXRlKSA6IF90aGlzLm1hY2hpbmUucmVzb2x2ZVN0YXRlKFN0YXRlLmZyb20oaW5pdGlhbFN0YXRlLCBfdGhpcy5tYWNoaW5lLmNvbnRleHQpKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGV2VG9vbHMpIHtcbiAgICAgIHRoaXMuYXR0YWNoRGV2KCk7XG4gICAgfVxuXG4gICAgdGhpcy5zY2hlZHVsZXIuaW5pdGlhbGl6ZShmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy51cGRhdGUocmVzb2x2ZWRTdGF0ZSwgaW5pdEV2ZW50KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuX3N0b3BDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPOiB0aGluayBhYm91dCBjb252ZXJ0aW5nIHRob3NlIHRvIGFjdGlvbnNcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihjaGlsZC5zdG9wKSkge1xuICAgICAgICBjaGlsZC5zdG9wKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jaGlsZHJlbi5jbGVhcigpO1xuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZV82LCBfYSwgZV83LCBfYiwgZV84LCBfYywgZV85LCBfZCwgZV8xMCwgX2U7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2YgPSBfX3ZhbHVlcyh0aGlzLmxpc3RlbmVycyksIF9nID0gX2YubmV4dCgpOyAhX2cuZG9uZTsgX2cgPSBfZi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gX2cudmFsdWU7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZV82XzEpIHtcbiAgICAgIGVfNiA9IHtcbiAgICAgICAgZXJyb3I6IGVfNl8xXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoX2cgJiYgIV9nLmRvbmUgJiYgKF9hID0gX2YucmV0dXJuKSkgX2EuY2FsbChfZik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZV82KSB0aHJvdyBlXzYuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9oID0gX192YWx1ZXModGhpcy5zdG9wTGlzdGVuZXJzKSwgX2ogPSBfaC5uZXh0KCk7ICFfai5kb25lOyBfaiA9IF9oLm5leHQoKSkge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBfai52YWx1ZTsgLy8gY2FsbCBsaXN0ZW5lciwgdGhlbiByZW1vdmVcblxuICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzdfMSkge1xuICAgICAgZV83ID0ge1xuICAgICAgICBlcnJvcjogZV83XzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfaiAmJiAhX2ouZG9uZSAmJiAoX2IgPSBfaC5yZXR1cm4pKSBfYi5jYWxsKF9oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzcpIHRocm93IGVfNy5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2sgPSBfX3ZhbHVlcyh0aGlzLmNvbnRleHRMaXN0ZW5lcnMpLCBfbCA9IF9rLm5leHQoKTsgIV9sLmRvbmU7IF9sID0gX2submV4dCgpKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IF9sLnZhbHVlO1xuICAgICAgICB0aGlzLmNvbnRleHRMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzhfMSkge1xuICAgICAgZV84ID0ge1xuICAgICAgICBlcnJvcjogZV84XzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfbCAmJiAhX2wuZG9uZSAmJiAoX2MgPSBfay5yZXR1cm4pKSBfYy5jYWxsKF9rKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzgpIHRocm93IGVfOC5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX20gPSBfX3ZhbHVlcyh0aGlzLmRvbmVMaXN0ZW5lcnMpLCBfbyA9IF9tLm5leHQoKTsgIV9vLmRvbmU7IF9vID0gX20ubmV4dCgpKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IF9vLnZhbHVlO1xuICAgICAgICB0aGlzLmRvbmVMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzlfMSkge1xuICAgICAgZV85ID0ge1xuICAgICAgICBlcnJvcjogZV85XzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfbyAmJiAhX28uZG9uZSAmJiAoX2QgPSBfbS5yZXR1cm4pKSBfZC5jYWxsKF9tKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzkpIHRocm93IGVfOS5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIC8vIEludGVycHJldGVyIGFscmVhZHkgc3RvcHBlZDsgZG8gbm90aGluZ1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdHVzID0gSW50ZXJwcmV0ZXJTdGF0dXMuU3RvcHBlZDtcbiAgICB0aGlzLl9pbml0aWFsU3RhdGUgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgLy8gd2UgYXJlIGdvaW5nIHRvIHN0b3Agd2l0aGluIHRoZSBjdXJyZW50IHN5bmMgZnJhbWVcbiAgICAgIC8vIHNvIHdlIGNhbiBzYWZlbHkganVzdCBjYW5jZWwgdGhpcyBoZXJlIGFzIG5vdGhpbmcgYXN5bmMgc2hvdWxkIGJlIGZpcmVkIGFueXdheVxuICAgICAgZm9yICh2YXIgX3AgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyh0aGlzLmRlbGF5ZWRFdmVudHNNYXApKSwgX3EgPSBfcC5uZXh0KCk7ICFfcS5kb25lOyBfcSA9IF9wLm5leHQoKSkge1xuICAgICAgICB2YXIga2V5ID0gX3EudmFsdWU7XG4gICAgICAgIHRoaXMuY2xvY2suY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXllZEV2ZW50c01hcFtrZXldKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzEwXzEpIHtcbiAgICAgIGVfMTAgPSB7XG4gICAgICAgIGVycm9yOiBlXzEwXzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfcSAmJiAhX3EuZG9uZSAmJiAoX2UgPSBfcC5yZXR1cm4pKSBfZS5jYWxsKF9wKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzEwKSB0aHJvdyBlXzEwLmVycm9yO1xuICAgICAgfVxuICAgIH0gLy8gY2xlYXIgZXZlcnl0aGluZyB0aGF0IG1pZ2h0IGJlIGVucXVldWVkXG5cblxuICAgIHRoaXMuc2NoZWR1bGVyLmNsZWFyKCk7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBuZXcgU2NoZWR1bGVyKHtcbiAgICAgIGRlZmVyRXZlbnRzOiB0aGlzLm9wdGlvbnMuZGVmZXJFdmVudHNcbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogU3RvcHMgdGhlIGludGVycHJldGVyIGFuZCB1bnN1YnNjcmliZSBhbGwgbGlzdGVuZXJzLlxyXG4gICAqXHJcbiAgICogVGhpcyB3aWxsIGFsc28gbm90aWZ5IHRoZSBgb25TdG9wYCBsaXN0ZW5lcnMuXHJcbiAgICovXG5cblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPOiBhZGQgd2FybmluZyBmb3Igc3RvcHBpbmcgbm9uLXJvb3QgaW50ZXJwcmV0ZXJzXG4gICAgdmFyIF90aGlzID0gdGhpczsgLy8gZ3JhYiB0aGUgY3VycmVudCBzY2hlZHVsZXIgYXMgaXQgd2lsbCBiZSByZXBsYWNlZCBpbiBfc3RvcFxuXG5cbiAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG5cbiAgICB0aGlzLl9zdG9wKCk7IC8vIGxldCB3aGF0IGlzIGN1cnJlbnRseSBwcm9jZXNzZWQgdG8gYmUgZmluaXNoZWRcblxuXG4gICAgc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGl0IGZlZWxzIHdlaXJkIHRvIGhhbmRsZSB0aGlzIGhlcmUgYnV0IHdlIG5lZWQgdG8gaGFuZGxlIHRoaXMgZXZlbiBzbGlnaHRseSBcIm91dCBvZiBiYW5kXCJcbiAgICAgIHZhciBfZXZlbnQgPSB0b1NDWE1MRXZlbnQoe1xuICAgICAgICB0eXBlOiAneHN0YXRlLnN0b3AnXG4gICAgICB9KTtcblxuICAgICAgdmFyIG5leHRTdGF0ZSA9IHByb3ZpZGUoX3RoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV4aXRBY3Rpb25zID0gZmxhdHRlbihfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoX3RoaXMuc3RhdGUuY29uZmlndXJhdGlvbiksIGZhbHNlKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGIub3JkZXIgLSBhLm9yZGVyO1xuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHN0YXRlTm9kZSkge1xuICAgICAgICAgIHJldHVybiB0b0FjdGlvbk9iamVjdHMoc3RhdGVOb2RlLm9uRXhpdCwgX3RoaXMubWFjaGluZS5vcHRpb25zLmFjdGlvbnMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgdmFyIF9hID0gX19yZWFkKHJlc29sdmVBY3Rpb25zKF90aGlzLm1hY2hpbmUsIF90aGlzLnN0YXRlLCBfdGhpcy5zdGF0ZS5jb250ZXh0LCBfZXZlbnQsIFt7XG4gICAgICAgICAgdHlwZTogJ2V4aXQnLFxuICAgICAgICAgIGFjdGlvbnM6IGV4aXRBY3Rpb25zXG4gICAgICAgIH1dLCBfdGhpcy5tYWNoaW5lLmNvbmZpZy5wcmVkaWN0YWJsZUFjdGlvbkFyZ3VtZW50cyA/IF90aGlzLl9leGVjIDogdW5kZWZpbmVkLCBfdGhpcy5tYWNoaW5lLmNvbmZpZy5wcmVkaWN0YWJsZUFjdGlvbkFyZ3VtZW50cyB8fCBfdGhpcy5tYWNoaW5lLmNvbmZpZy5wcmVzZXJ2ZUFjdGlvbk9yZGVyKSwgMiksXG4gICAgICAgICAgICByZXNvbHZlZEFjdGlvbnMgPSBfYVswXSxcbiAgICAgICAgICAgIHVwZGF0ZWRDb250ZXh0ID0gX2FbMV07XG5cbiAgICAgICAgdmFyIG5ld1N0YXRlID0gbmV3IFN0YXRlKHtcbiAgICAgICAgICB2YWx1ZTogX3RoaXMuc3RhdGUudmFsdWUsXG4gICAgICAgICAgY29udGV4dDogdXBkYXRlZENvbnRleHQsXG4gICAgICAgICAgX2V2ZW50OiBfZXZlbnQsXG4gICAgICAgICAgX3Nlc3Npb25pZDogX3RoaXMuc2Vzc2lvbklkLFxuICAgICAgICAgIGhpc3RvcnlWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGhpc3Rvcnk6IF90aGlzLnN0YXRlLFxuICAgICAgICAgIGFjdGlvbnM6IHJlc29sdmVkQWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuICFpc1JhaXNhYmxlQWN0aW9uKGFjdGlvbik7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgYWN0aXZpdGllczoge30sXG4gICAgICAgICAgZXZlbnRzOiBbXSxcbiAgICAgICAgICBjb25maWd1cmF0aW9uOiBbXSxcbiAgICAgICAgICB0cmFuc2l0aW9uczogW10sXG4gICAgICAgICAgY2hpbGRyZW46IHt9LFxuICAgICAgICAgIGRvbmU6IF90aGlzLnN0YXRlLmRvbmUsXG4gICAgICAgICAgdGFnczogX3RoaXMuc3RhdGUudGFncyxcbiAgICAgICAgICBtYWNoaW5lOiBfdGhpcy5tYWNoaW5lXG4gICAgICAgIH0pO1xuICAgICAgICBuZXdTdGF0ZS5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZShuZXh0U3RhdGUsIF9ldmVudCk7XG5cbiAgICAgIF90aGlzLl9zdG9wQ2hpbGRyZW4oKTtcblxuICAgICAgcmVnaXN0cnkuZnJlZShfdGhpcy5zZXNzaW9uSWQpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5iYXRjaCA9IGZ1bmN0aW9uIChldmVudHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBJbnRlcnByZXRlclN0YXR1cy5Ob3RTdGFydGVkICYmIHRoaXMub3B0aW9ucy5kZWZlckV2ZW50cykge1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgIGlmICghSVNfUFJPRFVDVElPTikge1xuICAgICAgICB3YXJuKGZhbHNlLCBcIlwiLmNvbmNhdChldmVudHMubGVuZ3RoLCBcIiBldmVudChzKSB3ZXJlIHNlbnQgdG8gdW5pbml0aWFsaXplZCBzZXJ2aWNlIFxcXCJcIikuY29uY2F0KHRoaXMubWFjaGluZS5pZCwgXCJcXFwiIGFuZCBhcmUgZGVmZXJyZWQuIE1ha2Ugc3VyZSAuc3RhcnQoKSBpcyBjYWxsZWQgZm9yIHRoaXMgc2VydmljZS5cXG5FdmVudDogXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShldmVudCkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzICE9PSBJbnRlcnByZXRlclN0YXR1cy5SdW5uaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgIFwiXCIuY29uY2F0KGV2ZW50cy5sZW5ndGgsIFwiIGV2ZW50KHMpIHdlcmUgc2VudCB0byB1bmluaXRpYWxpemVkIHNlcnZpY2UgXFxcIlwiKS5jb25jYXQodGhpcy5tYWNoaW5lLmlkLCBcIlxcXCIuIE1ha2Ugc3VyZSAuc3RhcnQoKSBpcyBjYWxsZWQgZm9yIHRoaXMgc2VydmljZSwgb3Igc2V0IHsgZGVmZXJFdmVudHM6IHRydWUgfSBpbiB0aGUgc2VydmljZSBvcHRpb25zLlwiKSk7XG4gICAgfVxuXG4gICAgaWYgKCFldmVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGV4ZWMgPSAhIXRoaXMubWFjaGluZS5jb25maWcucHJlZGljdGFibGVBY3Rpb25Bcmd1bWVudHMgJiYgdGhpcy5fZXhlYztcbiAgICB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZV8xMSwgX2E7XG5cbiAgICAgIHZhciBuZXh0U3RhdGUgPSBfdGhpcy5zdGF0ZTtcbiAgICAgIHZhciBiYXRjaENoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciBiYXRjaGVkQWN0aW9ucyA9IFtdO1xuXG4gICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChldmVudF8xKSB7XG4gICAgICAgIHZhciBfZXZlbnQgPSB0b1NDWE1MRXZlbnQoZXZlbnRfMSk7XG5cbiAgICAgICAgX3RoaXMuZm9yd2FyZChfZXZlbnQpO1xuXG4gICAgICAgIG5leHRTdGF0ZSA9IHByb3ZpZGUoX3RoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMubWFjaGluZS50cmFuc2l0aW9uKG5leHRTdGF0ZSwgX2V2ZW50LCB1bmRlZmluZWQsIGV4ZWMgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJhdGNoZWRBY3Rpb25zLnB1c2guYXBwbHkoYmF0Y2hlZEFjdGlvbnMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChfdGhpcy5tYWNoaW5lLmNvbmZpZy5wcmVkaWN0YWJsZUFjdGlvbkFyZ3VtZW50cyA/IG5leHRTdGF0ZS5hY3Rpb25zIDogbmV4dFN0YXRlLmFjdGlvbnMubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgcmV0dXJuIGJpbmRBY3Rpb25Ub1N0YXRlKGEsIG5leHRTdGF0ZSk7XG4gICAgICAgIH0pKSwgZmFsc2UpKTtcbiAgICAgICAgYmF0Y2hDaGFuZ2VkID0gYmF0Y2hDaGFuZ2VkIHx8ICEhbmV4dFN0YXRlLmNoYW5nZWQ7XG4gICAgICB9O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBldmVudHNfMSA9IF9fdmFsdWVzKGV2ZW50cyksIGV2ZW50c18xXzEgPSBldmVudHNfMS5uZXh0KCk7ICFldmVudHNfMV8xLmRvbmU7IGV2ZW50c18xXzEgPSBldmVudHNfMS5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgZXZlbnRfMSA9IGV2ZW50c18xXzEudmFsdWU7XG5cbiAgICAgICAgICBfbG9vcF8xKGV2ZW50XzEpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzExXzEpIHtcbiAgICAgICAgZV8xMSA9IHtcbiAgICAgICAgICBlcnJvcjogZV8xMV8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChldmVudHNfMV8xICYmICFldmVudHNfMV8xLmRvbmUgJiYgKF9hID0gZXZlbnRzXzEucmV0dXJuKSkgX2EuY2FsbChldmVudHNfMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVfMTEpIHRocm93IGVfMTEuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dFN0YXRlLmNoYW5nZWQgPSBiYXRjaENoYW5nZWQ7XG4gICAgICBuZXh0U3RhdGUuYWN0aW9ucyA9IGJhdGNoZWRBY3Rpb25zO1xuXG4gICAgICBfdGhpcy51cGRhdGUobmV4dFN0YXRlLCB0b1NDWE1MRXZlbnQoZXZlbnRzW2V2ZW50cy5sZW5ndGggLSAxXSkpO1xuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm5zIGEgc2VuZCBmdW5jdGlvbiBib3VuZCB0byB0aGlzIGludGVycHJldGVyIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBiZSBzZW50IGJ5IHRoZSBzZW5kZXIuXHJcbiAgICovXG5cblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuc2VuZGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZC5iaW5kKHRoaXMsIGV2ZW50KTtcbiAgfTtcblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuX25leHRTdGF0ZSA9IGZ1bmN0aW9uIChldmVudCwgZXhlYykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoZXhlYyA9PT0gdm9pZCAwKSB7XG4gICAgICBleGVjID0gISF0aGlzLm1hY2hpbmUuY29uZmlnLnByZWRpY3RhYmxlQWN0aW9uQXJndW1lbnRzICYmIHRoaXMuX2V4ZWM7XG4gICAgfVxuXG4gICAgdmFyIF9ldmVudCA9IHRvU0NYTUxFdmVudChldmVudCk7XG5cbiAgICBpZiAoX2V2ZW50Lm5hbWUuaW5kZXhPZihlcnJvclBsYXRmb3JtKSA9PT0gMCAmJiAhdGhpcy5zdGF0ZS5uZXh0RXZlbnRzLnNvbWUoZnVuY3Rpb24gKG5leHRFdmVudCkge1xuICAgICAgcmV0dXJuIG5leHRFdmVudC5pbmRleE9mKGVycm9yUGxhdGZvcm0pID09PSAwO1xuICAgIH0pKSB7XG4gICAgICB0aHJvdyBfZXZlbnQuZGF0YS5kYXRhO1xuICAgIH1cblxuICAgIHZhciBuZXh0U3RhdGUgPSBwcm92aWRlKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5tYWNoaW5lLnRyYW5zaXRpb24oX3RoaXMuc3RhdGUsIF9ldmVudCwgdW5kZWZpbmVkLCBleGVjIHx8IHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgfTtcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgbmV4dCBzdGF0ZSBnaXZlbiB0aGUgaW50ZXJwcmV0ZXIncyBjdXJyZW50IHN0YXRlIGFuZCB0aGUgZXZlbnQuXHJcbiAgICpcclxuICAgKiBUaGlzIGlzIGEgcHVyZSBtZXRob2QgdGhhdCBkb2VzIF9ub3RfIHVwZGF0ZSB0aGUgaW50ZXJwcmV0ZXIncyBzdGF0ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gZGV0ZXJtaW5lIHRoZSBuZXh0IHN0YXRlXHJcbiAgICovXG5cblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUubmV4dFN0YXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX25leHRTdGF0ZShldmVudCwgZmFsc2UpO1xuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGVfMTIsIF9hO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5mb3J3YXJkVG8pLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgIHZhciBpZCA9IF9jLnZhbHVlO1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChpZCk7XG5cbiAgICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmb3J3YXJkIGV2ZW50ICdcIi5jb25jYXQoZXZlbnQsIFwiJyBmcm9tIGludGVycHJldGVyICdcIikuY29uY2F0KHRoaXMuaWQsIFwiJyB0byBub25leGlzdGFudCBjaGlsZCAnXCIpLmNvbmNhdChpZCwgXCInLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZC5zZW5kKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzEyXzEpIHtcbiAgICAgIGVfMTIgPSB7XG4gICAgICAgIGVycm9yOiBlXzEyXzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzEyKSB0aHJvdyBlXzEyLmVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuZGVmZXIgPSBmdW5jdGlvbiAoc2VuZEFjdGlvbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgdGltZXJJZCA9IHRoaXMuY2xvY2suc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoJ3RvJyBpbiBzZW5kQWN0aW9uICYmIHNlbmRBY3Rpb24udG8pIHtcbiAgICAgICAgX3RoaXMuc2VuZFRvKHNlbmRBY3Rpb24uX2V2ZW50LCBzZW5kQWN0aW9uLnRvLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnNlbmQoc2VuZEFjdGlvbi5fZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHNlbmRBY3Rpb24uZGVsYXkpO1xuXG4gICAgaWYgKHNlbmRBY3Rpb24uaWQpIHtcbiAgICAgIHRoaXMuZGVsYXllZEV2ZW50c01hcFtzZW5kQWN0aW9uLmlkXSA9IHRpbWVySWQ7XG4gICAgfVxuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoc2VuZElkKSB7XG4gICAgdGhpcy5jbG9jay5jbGVhclRpbWVvdXQodGhpcy5kZWxheWVkRXZlbnRzTWFwW3NlbmRJZF0pO1xuICAgIGRlbGV0ZSB0aGlzLmRlbGF5ZWRFdmVudHNNYXBbc2VuZElkXTtcbiAgfTtcblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uIChhY3Rpb24sIHN0YXRlLCBhY3Rpb25GdW5jdGlvbk1hcCkge1xuICAgIGlmIChhY3Rpb25GdW5jdGlvbk1hcCA9PT0gdm9pZCAwKSB7XG4gICAgICBhY3Rpb25GdW5jdGlvbk1hcCA9IHRoaXMubWFjaGluZS5vcHRpb25zLmFjdGlvbnM7XG4gICAgfVxuXG4gICAgdGhpcy5fZXhlYyhhY3Rpb24sIHN0YXRlLmNvbnRleHQsIHN0YXRlLl9ldmVudCwgYWN0aW9uRnVuY3Rpb25NYXApO1xuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZElkKSB7XG4gICAgdmFyIF9hO1xuXG4gICAgdGhpcy5jaGlsZHJlbi5kZWxldGUoY2hpbGRJZCk7XG4gICAgdGhpcy5mb3J3YXJkVG8uZGVsZXRlKGNoaWxkSWQpOyAvLyB0aGlzLnN0YXRlIG1pZ2h0IG5vdCBleGlzdCBhdCB0aGUgdGltZSB0aGlzIGlzIGNhbGxlZCxcbiAgICAvLyBzdWNoIGFzIHdoZW4gYSBjaGlsZCBpcyBhZGRlZCB0aGVuIHJlbW92ZWQgd2hpbGUgaW5pdGlhbGl6aW5nIHRoZSBzdGF0ZVxuXG4gICAgKF9hID0gdGhpcy5zdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHRydWUgOiBkZWxldGUgX2EuY2hpbGRyZW5bY2hpbGRJZF07XG4gIH07XG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLnN0b3BDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZElkKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoY2hpbGRJZCk7XG5cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZElkKTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGNoaWxkLnN0b3ApKSB7XG4gICAgICBjaGlsZC5zdG9wKCk7XG4gICAgfVxuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5zcGF3biA9IGZ1bmN0aW9uIChlbnRpdHksIG5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IEludGVycHJldGVyU3RhdHVzLlJ1bm5pbmcpIHtcbiAgICAgIHJldHVybiBjcmVhdGVEZWZlcnJlZEFjdG9yKGVudGl0eSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzUHJvbWlzZUxpa2UoZW50aXR5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3Bhd25Qcm9taXNlKFByb21pc2UucmVzb2x2ZShlbnRpdHkpLCBuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oZW50aXR5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3Bhd25DYWxsYmFjayhlbnRpdHksIG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoaXNTcGF3bmVkQWN0b3IoZW50aXR5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3Bhd25BY3RvcihlbnRpdHksIG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlKGVudGl0eSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwYXduT2JzZXJ2YWJsZShlbnRpdHksIG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoaXNNYWNoaW5lKGVudGl0eSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwYXduTWFjaGluZShlbnRpdHksIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgICAgICBpZDogbmFtZVxuICAgICAgfSkpO1xuICAgIH0gZWxzZSBpZiAoaXNCZWhhdmlvcihlbnRpdHkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGF3bkJlaGF2aW9yKGVudGl0eSwgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBzcGF3biBlbnRpdHkgXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIgb2YgdHlwZSBcXFwiXCIpLmNvbmNhdCh0eXBlb2YgZW50aXR5LCBcIlxcXCIuXCIpKTtcbiAgICB9XG4gIH07XG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLnNwYXduTWFjaGluZSA9IGZ1bmN0aW9uIChtYWNoaW5lLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRTZXJ2aWNlID0gbmV3IEludGVycHJldGVyKG1hY2hpbmUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCB7XG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBpZDogb3B0aW9ucy5pZCB8fCBtYWNoaW5lLmlkXG4gICAgfSkpO1xuXG4gICAgdmFyIHJlc29sdmVkT3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBERUZBVUxUX1NQQVdOX09QVElPTlMpLCBvcHRpb25zKTtcblxuICAgIGlmIChyZXNvbHZlZE9wdGlvbnMuc3luYykge1xuICAgICAgY2hpbGRTZXJ2aWNlLm9uVHJhbnNpdGlvbihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgX3RoaXMuc2VuZCh1cGRhdGUsIHtcbiAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgaWQ6IGNoaWxkU2VydmljZS5pZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBhY3RvciA9IGNoaWxkU2VydmljZTtcbiAgICB0aGlzLmNoaWxkcmVuLnNldChjaGlsZFNlcnZpY2UuaWQsIGFjdG9yKTtcblxuICAgIGlmIChyZXNvbHZlZE9wdGlvbnMuYXV0b0ZvcndhcmQpIHtcbiAgICAgIHRoaXMuZm9yd2FyZFRvLmFkZChjaGlsZFNlcnZpY2UuaWQpO1xuICAgIH1cblxuICAgIGNoaWxkU2VydmljZS5vbkRvbmUoZnVuY3Rpb24gKGRvbmVFdmVudCkge1xuICAgICAgX3RoaXMucmVtb3ZlQ2hpbGQoY2hpbGRTZXJ2aWNlLmlkKTtcblxuICAgICAgX3RoaXMuc2VuZCh0b1NDWE1MRXZlbnQoZG9uZUV2ZW50LCB7XG4gICAgICAgIG9yaWdpbjogY2hpbGRTZXJ2aWNlLmlkXG4gICAgICB9KSk7XG4gICAgfSkuc3RhcnQoKTtcbiAgICByZXR1cm4gYWN0b3I7XG4gIH07XG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLnNwYXduQmVoYXZpb3IgPSBmdW5jdGlvbiAoYmVoYXZpb3IsIGlkKSB7XG4gICAgdmFyIGFjdG9yUmVmID0gc3Bhd25CZWhhdmlvcihiZWhhdmlvciwge1xuICAgICAgaWQ6IGlkLFxuICAgICAgcGFyZW50OiB0aGlzXG4gICAgfSk7XG4gICAgdGhpcy5jaGlsZHJlbi5zZXQoaWQsIGFjdG9yUmVmKTtcbiAgICByZXR1cm4gYWN0b3JSZWY7XG4gIH07XG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLnNwYXduUHJvbWlzZSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpZCkge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmVzb2x2ZWREYXRhO1xuICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmICghY2FuY2VsZWQpIHtcbiAgICAgICAgcmVzb2x2ZWREYXRhID0gcmVzcG9uc2U7XG5cbiAgICAgICAgX3RoaXMucmVtb3ZlQ2hpbGQoaWQpO1xuXG4gICAgICAgIF90aGlzLnNlbmQodG9TQ1hNTEV2ZW50KGRvbmVJbnZva2UoaWQsIHJlc3BvbnNlKSwge1xuICAgICAgICAgIG9yaWdpbjogaWRcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvckRhdGEpIHtcbiAgICAgIGlmICghY2FuY2VsZWQpIHtcbiAgICAgICAgX3RoaXMucmVtb3ZlQ2hpbGQoaWQpO1xuXG4gICAgICAgIHZhciBlcnJvckV2ZW50ID0gZXJyb3IoaWQsIGVycm9yRGF0YSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBTZW5kIFwiZXJyb3IucGxhdGZvcm0uaWRcIiB0byB0aGlzIChwYXJlbnQpLlxuICAgICAgICAgIF90aGlzLnNlbmQodG9TQ1hNTEV2ZW50KGVycm9yRXZlbnQsIHtcbiAgICAgICAgICAgIG9yaWdpbjogaWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXhjZXB0aW9uT25JbnZvY2F0aW9uKGVycm9yRGF0YSwgZXJyb3IsIGlkKTtcblxuICAgICAgICAgIGlmIChfdGhpcy5kZXZUb29scykge1xuICAgICAgICAgICAgX3RoaXMuZGV2VG9vbHMuc2VuZChlcnJvckV2ZW50LCBfdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF90aGlzLm1hY2hpbmUuc3RyaWN0KSB7XG4gICAgICAgICAgICAvLyBpdCB3b3VsZCBiZSBiZXR0ZXIgdG8gYWx3YXlzIHN0b3AgdGhlIHN0YXRlIG1hY2hpbmUgaWYgdW5oYW5kbGVkXG4gICAgICAgICAgICAvLyBleGNlcHRpb24vcHJvbWlzZSByZWplY3Rpb24gaGFwcGVucyBidXQgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgICAgICAvLyBicmVhayBleGlzdGluZyBjb2RlIHNvIGVuZm9yY2UgaXQgb24gc3RyaWN0IG1vZGUgb25seSBlc3BlY2lhbGx5IHNvXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGRvY3VtZW50YXRpb24gc2F5cyB0aGF0IG9uRXJyb3IgaXMgb3B0aW9uYWxcbiAgICAgICAgICAgIF90aGlzLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgYWN0b3IgPSAoX2EgPSB7XG4gICAgICBpZDogaWQsXG4gICAgICBzZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9LFxuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAobmV4dCwgaGFuZGxlRXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IHRvT2JzZXJ2ZXIobmV4dCwgaGFuZGxlRXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgaWYgKHVuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9ic2VydmVyLm5leHQocmVzcG9uc2UpO1xuXG4gICAgICAgICAgaWYgKHVuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAodW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogaWRcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBnZXRTbmFwc2hvdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWREYXRhO1xuICAgICAgfVxuICAgIH0sIF9hW3N5bWJvbE9ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgX2EpO1xuICAgIHRoaXMuY2hpbGRyZW4uc2V0KGlkLCBhY3Rvcik7XG4gICAgcmV0dXJuIGFjdG9yO1xuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5zcGF3bkNhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBpZCkge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmVjZWl2ZXJzID0gbmV3IFNldCgpO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGVtaXR0ZWQ7XG5cbiAgICB2YXIgcmVjZWl2ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBlbWl0dGVkID0gZTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoZSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2VuZCh0b1NDWE1MRXZlbnQoZSwge1xuICAgICAgICBvcmlnaW46IGlkXG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIHZhciBjYWxsYmFja1N0b3A7XG5cbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2tTdG9wID0gY2FsbGJhY2socmVjZWl2ZSwgZnVuY3Rpb24gKG5ld0xpc3RlbmVyKSB7XG4gICAgICAgIHJlY2VpdmVycy5hZGQobmV3TGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLnNlbmQoZXJyb3IoaWQsIGVycikpO1xuICAgIH1cblxuICAgIGlmIChpc1Byb21pc2VMaWtlKGNhbGxiYWNrU3RvcCkpIHtcbiAgICAgIC8vIGl0IHR1cm5lZCBvdXQgdG8gYmUgYW4gYXN5bmMgZnVuY3Rpb24sIGNhbid0IHJlbGlhYmx5IGNoZWNrIHRoaXMgYmVmb3JlIGNhbGxpbmcgYGNhbGxiYWNrYFxuICAgICAgLy8gYmVjYXVzZSB0cmFuc3BpbGVkIGFzeW5jIGZ1bmN0aW9ucyBhcmUgbm90IHJlY29nbml6YWJsZVxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd25Qcm9taXNlKGNhbGxiYWNrU3RvcCwgaWQpO1xuICAgIH1cblxuICAgIHZhciBhY3RvciA9IChfYSA9IHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHNlbmQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gcmVjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlY2VpdmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlY2VpdmVyKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSB0b09ic2VydmVyKG5leHQpO1xuICAgICAgICBsaXN0ZW5lcnMuYWRkKG9ic2VydmVyLm5leHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKG9ic2VydmVyLm5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFja1N0b3ApKSB7XG4gICAgICAgICAgY2FsbGJhY2tTdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogaWRcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBnZXRTbmFwc2hvdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZW1pdHRlZDtcbiAgICAgIH1cbiAgICB9LCBfYVtzeW1ib2xPYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9hKTtcbiAgICB0aGlzLmNoaWxkcmVuLnNldChpZCwgYWN0b3IpO1xuICAgIHJldHVybiBhY3RvcjtcbiAgfTtcblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuc3Bhd25PYnNlcnZhYmxlID0gZnVuY3Rpb24gKHNvdXJjZSwgaWQpIHtcbiAgICB2YXIgX2E7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGVtaXR0ZWQ7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBlbWl0dGVkID0gdmFsdWU7XG5cbiAgICAgIF90aGlzLnNlbmQodG9TQ1hNTEV2ZW50KHZhbHVlLCB7XG4gICAgICAgIG9yaWdpbjogaWRcbiAgICAgIH0pKTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBfdGhpcy5yZW1vdmVDaGlsZChpZCk7XG5cbiAgICAgIF90aGlzLnNlbmQodG9TQ1hNTEV2ZW50KGVycm9yKGlkLCBlcnIpLCB7XG4gICAgICAgIG9yaWdpbjogaWRcbiAgICAgIH0pKTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5yZW1vdmVDaGlsZChpZCk7XG5cbiAgICAgIF90aGlzLnNlbmQodG9TQ1hNTEV2ZW50KGRvbmVJbnZva2UoaWQpLCB7XG4gICAgICAgIG9yaWdpbjogaWRcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICB2YXIgYWN0b3IgPSAoX2EgPSB7XG4gICAgICBpZDogaWQsXG4gICAgICBzZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9LFxuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAobmV4dCwgaGFuZGxlRXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5leHQsIGhhbmRsZUVycm9yLCBjb21wbGV0ZSk7XG4gICAgICB9LFxuICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9LFxuICAgICAgZ2V0U25hcHNob3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVtaXR0ZWQ7XG4gICAgICB9LFxuICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IGlkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwgX2Fbc3ltYm9sT2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfYSk7XG4gICAgdGhpcy5jaGlsZHJlbi5zZXQoaWQsIGFjdG9yKTtcbiAgICByZXR1cm4gYWN0b3I7XG4gIH07XG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLnNwYXduQWN0b3IgPSBmdW5jdGlvbiAoYWN0b3IsIG5hbWUpIHtcbiAgICB0aGlzLmNoaWxkcmVuLnNldChuYW1lLCBhY3Rvcik7XG4gICAgcmV0dXJuIGFjdG9yO1xuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5zcGF3bkFjdGl2aXR5ID0gZnVuY3Rpb24gKGFjdGl2aXR5KSB7XG4gICAgdmFyIGltcGxlbWVudGF0aW9uID0gdGhpcy5tYWNoaW5lLm9wdGlvbnMgJiYgdGhpcy5tYWNoaW5lLm9wdGlvbnMuYWN0aXZpdGllcyA/IHRoaXMubWFjaGluZS5vcHRpb25zLmFjdGl2aXRpZXNbYWN0aXZpdHkudHlwZV0gOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIWltcGxlbWVudGF0aW9uKSB7XG4gICAgICBpZiAoIUlTX1BST0RVQ1RJT04pIHtcbiAgICAgICAgd2FybihmYWxzZSwgXCJObyBpbXBsZW1lbnRhdGlvbiBmb3VuZCBmb3IgYWN0aXZpdHkgJ1wiLmNvbmNhdChhY3Rpdml0eS50eXBlLCBcIidcIikpO1xuICAgICAgfSAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuXG5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFN0YXJ0IGltcGxlbWVudGF0aW9uXG5cblxuICAgIHZhciBkaXNwb3NlID0gaW1wbGVtZW50YXRpb24odGhpcy5zdGF0ZS5jb250ZXh0LCBhY3Rpdml0eSk7XG4gICAgdGhpcy5zcGF3bkVmZmVjdChhY3Rpdml0eS5pZCwgZGlzcG9zZSk7XG4gIH07XG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLnNwYXduRWZmZWN0ID0gZnVuY3Rpb24gKGlkLCBkaXNwb3NlKSB7XG4gICAgdmFyIF9hO1xuXG4gICAgdGhpcy5jaGlsZHJlbi5zZXQoaWQsIChfYSA9IHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHNlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH0sXG4gICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgc3RvcDogZGlzcG9zZSB8fCB1bmRlZmluZWQsXG4gICAgICBnZXRTbmFwc2hvdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICAgIHRvSlNPTjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBpZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIF9hW3N5bWJvbE9ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgX2EpKTtcbiAgfTtcblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuYXR0YWNoRGV2ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnbG9iYWwgPSBnZXRHbG9iYWwoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGV2VG9vbHMgJiYgZ2xvYmFsKSB7XG4gICAgICBpZiAoZ2xvYmFsLl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18pIHtcbiAgICAgICAgdmFyIGRldlRvb2xzT3B0aW9ucyA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuZGV2VG9vbHMgPT09ICdvYmplY3QnID8gdGhpcy5vcHRpb25zLmRldlRvb2xzIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRldlRvb2xzID0gZ2xvYmFsLl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18uY29ubmVjdChfX2Fzc2lnbihfX2Fzc2lnbih7XG4gICAgICAgICAgbmFtZTogdGhpcy5pZCxcbiAgICAgICAgICBhdXRvUGF1c2U6IHRydWUsXG4gICAgICAgICAgc3RhdGVTYW5pdGl6ZXI6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHN0YXRlLnZhbHVlLFxuICAgICAgICAgICAgICBjb250ZXh0OiBzdGF0ZS5jb250ZXh0LFxuICAgICAgICAgICAgICBhY3Rpb25zOiBzdGF0ZS5hY3Rpb25zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZGV2VG9vbHNPcHRpb25zKSwge1xuICAgICAgICAgIGZlYXR1cmVzOiBfX2Fzc2lnbih7XG4gICAgICAgICAgICBqdW1wOiBmYWxzZSxcbiAgICAgICAgICAgIHNraXA6IGZhbHNlXG4gICAgICAgICAgfSwgZGV2VG9vbHNPcHRpb25zID8gZGV2VG9vbHNPcHRpb25zLmZlYXR1cmVzIDogdW5kZWZpbmVkKVxuICAgICAgICB9KSwgdGhpcy5tYWNoaW5lKTtcbiAgICAgICAgdGhpcy5kZXZUb29scy5pbml0KHRoaXMuc3RhdGUpO1xuICAgICAgfSAvLyBhZGQgWFN0YXRlLXNwZWNpZmljIGRldiB0b29saW5nIGhvb2tcblxuXG4gICAgICByZWdpc3RlclNlcnZpY2UodGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkXG4gICAgfTtcbiAgfTtcblxuICBJbnRlcnByZXRlci5wcm90b3R5cGVbc3ltYm9sT2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLmdldFNuYXBzaG90ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gSW50ZXJwcmV0ZXJTdGF0dXMuTm90U3RhcnRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFN0YXRlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVGhlIGRlZmF1bHQgaW50ZXJwcmV0ZXIgb3B0aW9uczpcclxuICAgKlxyXG4gICAqIC0gYGNsb2NrYCB1c2VzIHRoZSBnbG9iYWwgYHNldFRpbWVvdXRgIGFuZCBgY2xlYXJUaW1lb3V0YCBmdW5jdGlvbnNcclxuICAgKiAtIGBsb2dnZXJgIHVzZXMgdGhlIGdsb2JhbCBgY29uc29sZS5sb2coKWAgbWV0aG9kXHJcbiAgICovXG5cblxuICBJbnRlcnByZXRlci5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBleGVjdXRlOiB0cnVlLFxuICAgIGRlZmVyRXZlbnRzOiB0cnVlLFxuICAgIGNsb2NrOiB7XG4gICAgICBzZXRUaW1lb3V0OiBmdW5jdGlvbiAoZm4sIG1zKSB7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZuLCBtcyk7XG4gICAgICB9LFxuICAgICAgY2xlYXJUaW1lb3V0OiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChpZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsb2dnZXI6IC8qI19fUFVSRV9fKi9jb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFxuICAgIGRldlRvb2xzOiBmYWxzZVxuICB9O1xuICBJbnRlcnByZXRlci5pbnRlcnByZXQgPSBpbnRlcnByZXQ7XG4gIHJldHVybiBJbnRlcnByZXRlcjtcbn0oKTtcblxudmFyIHJlc29sdmVTcGF3bk9wdGlvbnMgPSBmdW5jdGlvbiAobmFtZU9yT3B0aW9ucykge1xuICBpZiAoaXNTdHJpbmcobmFtZU9yT3B0aW9ucykpIHtcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIERFRkFVTFRfU1BBV05fT1BUSU9OUyksIHtcbiAgICAgIG5hbWU6IG5hbWVPck9wdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgREVGQVVMVF9TUEFXTl9PUFRJT05TKSwge1xuICAgIG5hbWU6IHVuaXF1ZUlkKClcbiAgfSksIG5hbWVPck9wdGlvbnMpO1xufTtcblxuZnVuY3Rpb24gc3Bhd24oZW50aXR5LCBuYW1lT3JPcHRpb25zKSB7XG4gIHZhciByZXNvbHZlZE9wdGlvbnMgPSByZXNvbHZlU3Bhd25PcHRpb25zKG5hbWVPck9wdGlvbnMpO1xuICByZXR1cm4gY29uc3VtZShmdW5jdGlvbiAoc2VydmljZSkge1xuICAgIGlmICghSVNfUFJPRFVDVElPTikge1xuICAgICAgdmFyIGlzTGF6eUVudGl0eSA9IGlzTWFjaGluZShlbnRpdHkpIHx8IGlzRnVuY3Rpb24oZW50aXR5KTtcbiAgICAgIHdhcm4oISFzZXJ2aWNlIHx8IGlzTGF6eUVudGl0eSwgXCJBdHRlbXB0ZWQgdG8gc3Bhd24gYW4gQWN0b3IgKElEOiBcXFwiXCIuY29uY2F0KGlzTWFjaGluZShlbnRpdHkpID8gZW50aXR5LmlkIDogJ3VuZGVmaW5lZCcsIFwiXFxcIikgb3V0c2lkZSBvZiBhIHNlcnZpY2UuIFRoaXMgd2lsbCBoYXZlIG5vIGVmZmVjdC5cIikpO1xuICAgIH1cblxuICAgIGlmIChzZXJ2aWNlKSB7XG4gICAgICByZXR1cm4gc2VydmljZS5zcGF3bihlbnRpdHksIHJlc29sdmVkT3B0aW9ucy5uYW1lLCByZXNvbHZlZE9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3JlYXRlRGVmZXJyZWRBY3RvcihlbnRpdHksIHJlc29sdmVkT3B0aW9ucy5uYW1lKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgSW50ZXJwcmV0ZXIgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBtYWNoaW5lIHdpdGggdGhlIHByb3ZpZGVkIG9wdGlvbnMsIGlmIGFueS5cclxuICpcclxuICogQHBhcmFtIG1hY2hpbmUgVGhlIG1hY2hpbmUgdG8gaW50ZXJwcmV0XHJcbiAqIEBwYXJhbSBvcHRpb25zIEludGVycHJldGVyIG9wdGlvbnNcclxuICovXG5cbmZ1bmN0aW9uIGludGVycHJldChtYWNoaW5lLCBvcHRpb25zKSB7XG4gIHZhciBpbnRlcnByZXRlciA9IG5ldyBJbnRlcnByZXRlcihtYWNoaW5lLCBvcHRpb25zKTtcbiAgcmV0dXJuIGludGVycHJldGVyO1xufVxuXG5leHBvcnQgeyBJbnRlcnByZXRlciwgSW50ZXJwcmV0ZXJTdGF0dXMsIGludGVycHJldCwgc3Bhd24gfTtcbiIsImltcG9ydCB7IF9fYXNzaWduLCBfX3Jlc3QgfSBmcm9tICcuL192aXJ0dWFsL190c2xpYi5qcyc7XG5pbXBvcnQgJy4vdHlwZXMuanMnO1xuaW1wb3J0IHsgaW52b2tlIH0gZnJvbSAnLi9hY3Rpb25UeXBlcy5qcyc7XG5pbXBvcnQgJy4vdXRpbHMuanMnO1xuaW1wb3J0ICcuL2Vudmlyb25tZW50LmpzJztcblxuZnVuY3Rpb24gdG9JbnZva2VTb3VyY2Uoc3JjKSB7XG4gIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzaW1wbGVTcmMgPSB7XG4gICAgICB0eXBlOiBzcmNcbiAgICB9O1xuXG4gICAgc2ltcGxlU3JjLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNyYztcbiAgICB9OyAvLyB2NCBjb21wYXQgLSBUT0RPOiByZW1vdmUgaW4gdjVcblxuXG4gICAgcmV0dXJuIHNpbXBsZVNyYztcbiAgfVxuXG4gIHJldHVybiBzcmM7XG59XG5mdW5jdGlvbiB0b0ludm9rZURlZmluaXRpb24oaW52b2tlQ29uZmlnKSB7XG4gIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7XG4gICAgdHlwZTogaW52b2tlXG4gIH0sIGludm9rZUNvbmZpZyksIHtcbiAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgIGludm9rZUNvbmZpZy5vbkRvbmU7XG4gICAgICAgICAgaW52b2tlQ29uZmlnLm9uRXJyb3I7XG4gICAgICAgICAgdmFyIGludm9rZURlZiA9IF9fcmVzdChpbnZva2VDb25maWcsIFtcIm9uRG9uZVwiLCBcIm9uRXJyb3JcIl0pO1xuXG4gICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGludm9rZURlZiksIHtcbiAgICAgICAgdHlwZTogaW52b2tlLFxuICAgICAgICBzcmM6IHRvSW52b2tlU291cmNlKGludm9rZUNvbmZpZy5zcmMpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgeyB0b0ludm9rZURlZmluaXRpb24sIHRvSW52b2tlU291cmNlIH07XG4iLCJpbXBvcnQgeyBfX3ZhbHVlcyB9IGZyb20gJy4vX3ZpcnR1YWwvX3RzbGliLmpzJztcbmltcG9ydCB7IG1hdGNoZXNTdGF0ZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5mdW5jdGlvbiBtYXBTdGF0ZShzdGF0ZU1hcCwgc3RhdGVJZCkge1xuICB2YXIgZV8xLCBfYTtcblxuICB2YXIgZm91bmRTdGF0ZUlkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhzdGF0ZU1hcCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICB2YXIgbWFwcGVkU3RhdGVJZCA9IF9jLnZhbHVlO1xuXG4gICAgICBpZiAobWF0Y2hlc1N0YXRlKG1hcHBlZFN0YXRlSWQsIHN0YXRlSWQpICYmICghZm91bmRTdGF0ZUlkIHx8IHN0YXRlSWQubGVuZ3RoID4gZm91bmRTdGF0ZUlkLmxlbmd0aCkpIHtcbiAgICAgICAgZm91bmRTdGF0ZUlkID0gbWFwcGVkU3RhdGVJZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgZV8xID0ge1xuICAgICAgZXJyb3I6IGVfMV8xXG4gICAgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0YXRlTWFwW2ZvdW5kU3RhdGVJZF07XG59XG5cbmV4cG9ydCB7IG1hcFN0YXRlIH07XG4iLCJpbXBvcnQgeyBfX3ZhbHVlcywgX19yZWFkIH0gZnJvbSAnLi9fdmlydHVhbC9fdHNsaWIuanMnO1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICcuL1N0YXRlLmpzJztcblxuZnVuY3Rpb24gbWF0Y2hTdGF0ZShzdGF0ZSwgcGF0dGVybnMsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgZV8xLCBfYTtcblxuICB2YXIgcmVzb2x2ZWRTdGF0ZSA9IFN0YXRlLmZyb20oc3RhdGUsIHN0YXRlIGluc3RhbmNlb2YgU3RhdGUgPyBzdGF0ZS5jb250ZXh0IDogdW5kZWZpbmVkKTtcblxuICB0cnkge1xuICAgIGZvciAodmFyIHBhdHRlcm5zXzEgPSBfX3ZhbHVlcyhwYXR0ZXJucyksIHBhdHRlcm5zXzFfMSA9IHBhdHRlcm5zXzEubmV4dCgpOyAhcGF0dGVybnNfMV8xLmRvbmU7IHBhdHRlcm5zXzFfMSA9IHBhdHRlcm5zXzEubmV4dCgpKSB7XG4gICAgICB2YXIgX2IgPSBfX3JlYWQocGF0dGVybnNfMV8xLnZhbHVlLCAyKSxcbiAgICAgICAgICBzdGF0ZVZhbHVlID0gX2JbMF0sXG4gICAgICAgICAgZ2V0VmFsdWUgPSBfYlsxXTtcblxuICAgICAgaWYgKHJlc29sdmVkU3RhdGUubWF0Y2hlcyhzdGF0ZVZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZ2V0VmFsdWUocmVzb2x2ZWRTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlXzFfMSkge1xuICAgIGVfMSA9IHtcbiAgICAgIGVycm9yOiBlXzFfMVxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChwYXR0ZXJuc18xXzEgJiYgIXBhdHRlcm5zXzFfMS5kb25lICYmIChfYSA9IHBhdHRlcm5zXzEucmV0dXJuKSkgX2EuY2FsbChwYXR0ZXJuc18xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0VmFsdWUocmVzb2x2ZWRTdGF0ZSk7XG59XG5cbmV4cG9ydCB7IG1hdGNoU3RhdGUgfTtcbiIsInZhciBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi9uZXcgTWFwKCk7XG52YXIgc2Vzc2lvbklkSW5kZXggPSAwO1xudmFyIHJlZ2lzdHJ5ID0ge1xuICBib29rSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJ4OlwiLmNvbmNhdChzZXNzaW9uSWRJbmRleCsrKTtcbiAgfSxcbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChpZCwgYWN0b3IpIHtcbiAgICBjaGlsZHJlbi5zZXQoaWQsIGFjdG9yKTtcbiAgICByZXR1cm4gaWQ7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuLmdldChpZCk7XG4gIH0sXG4gIGZyZWU6IGZ1bmN0aW9uIChpZCkge1xuICAgIGNoaWxkcmVuLmRlbGV0ZShpZCk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IHJlZ2lzdHJ5IH07XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJy4vX3ZpcnR1YWwvX3RzbGliLmpzJztcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBkZWZlckV2ZW50czogZmFsc2Vcbn07XG5cbnZhciBTY2hlZHVsZXIgPVxuLyojX19QVVJFX18qL1xuXG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNjaGVkdWxlcihvcHRpb25zKSB7XG4gICAgdGhpcy5wcm9jZXNzaW5nRXZlbnQgPSBmYWxzZTtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucyksIG9wdGlvbnMpO1xuICB9XG5cbiAgU2NoZWR1bGVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmRlZmVyRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoY2FsbGJhY2spO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvY2VzcyhjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgdGhpcy5mbHVzaEV2ZW50cygpO1xuICB9O1xuXG4gIFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAodGFzaykge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCB8fCB0aGlzLnByb2Nlc3NpbmdFdmVudCkge1xuICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRhc2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCBxdWV1ZSBzaG91bGQgYmUgZW1wdHkgd2hlbiBpdCBpcyBub3QgcHJvY2Vzc2luZyBldmVudHMnKTtcbiAgICB9XG5cbiAgICB0aGlzLnByb2Nlc3ModGFzayk7XG4gICAgdGhpcy5mbHVzaEV2ZW50cygpO1xuICB9O1xuXG4gIFNjaGVkdWxlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICB9O1xuXG4gIFNjaGVkdWxlci5wcm90b3R5cGUuZmx1c2hFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5leHRDYWxsYmFjayA9IHRoaXMucXVldWUuc2hpZnQoKTtcblxuICAgIHdoaWxlIChuZXh0Q2FsbGJhY2spIHtcbiAgICAgIHRoaXMucHJvY2VzcyhuZXh0Q2FsbGJhY2spO1xuICAgICAgbmV4dENhbGxiYWNrID0gdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgIH1cbiAgfTtcblxuICBTY2hlZHVsZXIucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnByb2Nlc3NpbmdFdmVudCA9IHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyB0aGVyZSBpcyBubyB1c2UgdG8ga2VlcCB0aGUgZnV0dXJlIGV2ZW50c1xuICAgICAgLy8gYXMgdGhlIHNpdHVhdGlvbiBpcyBub3QgYW55bW9yZSB0aGUgc2FtZVxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5wcm9jZXNzaW5nRXZlbnQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNjaGVkdWxlcjtcbn0oKTtcblxuZXhwb3J0IHsgU2NoZWR1bGVyIH07XG4iLCJmdW5jdGlvbiBjcmVhdGVTY2hlbWEoc2NoZW1hKSB7XG4gIHJldHVybiBzY2hlbWE7XG59XG52YXIgdCA9IGNyZWF0ZVNjaGVtYTtcblxuZXhwb3J0IHsgY3JlYXRlU2NoZW1hLCB0IH07XG4iLCIvKipcclxuICogTWFpbnRhaW5zIGEgc3RhY2sgb2YgdGhlIGN1cnJlbnQgc2VydmljZSBpbiBzY29wZS5cclxuICogVGhpcyBpcyB1c2VkIHRvIHByb3ZpZGUgdGhlIGNvcnJlY3Qgc2VydmljZSB0byBzcGF3bigpLlxyXG4gKi9cbnZhciBzZXJ2aWNlU3RhY2sgPSBbXTtcbnZhciBwcm92aWRlID0gZnVuY3Rpb24gKHNlcnZpY2UsIGZuKSB7XG4gIHNlcnZpY2VTdGFjay5wdXNoKHNlcnZpY2UpO1xuICB2YXIgcmVzdWx0ID0gZm4oc2VydmljZSk7XG4gIHNlcnZpY2VTdGFjay5wb3AoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgY29uc3VtZSA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4oc2VydmljZVN0YWNrW3NlcnZpY2VTdGFjay5sZW5ndGggLSAxXSk7XG59O1xuXG5leHBvcnQgeyBjb25zdW1lLCBwcm92aWRlIH07XG4iLCJpbXBvcnQgeyBfX3ZhbHVlcywgX19zcHJlYWRBcnJheSwgX19yZWFkIH0gZnJvbSAnLi9fdmlydHVhbC9fdHNsaWIuanMnO1xuaW1wb3J0IHsgZmxhdHRlbiB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG52YXIgaXNMZWFmTm9kZSA9IGZ1bmN0aW9uIChzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIHN0YXRlTm9kZS50eXBlID09PSAnYXRvbWljJyB8fCBzdGF0ZU5vZGUudHlwZSA9PT0gJ2ZpbmFsJztcbn07XG5mdW5jdGlvbiBnZXRBbGxDaGlsZHJlbihzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHN0YXRlTm9kZS5zdGF0ZXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5zdGF0ZXNba2V5XTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIGdldEFsbENoaWxkcmVuKHN0YXRlTm9kZSkuZmlsdGVyKGZ1bmN0aW9uIChzbikge1xuICAgIHJldHVybiBzbi50eXBlICE9PSAnaGlzdG9yeSc7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0QWxsU3RhdGVOb2RlcyhzdGF0ZU5vZGUpIHtcbiAgdmFyIHN0YXRlTm9kZXMgPSBbc3RhdGVOb2RlXTtcblxuICBpZiAoaXNMZWFmTm9kZShzdGF0ZU5vZGUpKSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZXM7XG4gIH1cblxuICByZXR1cm4gc3RhdGVOb2Rlcy5jb25jYXQoZmxhdHRlbihnZXRDaGlsZHJlbihzdGF0ZU5vZGUpLm1hcChnZXRBbGxTdGF0ZU5vZGVzKSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29uZmlndXJhdGlvbihwcmV2U3RhdGVOb2Rlcywgc3RhdGVOb2Rlcykge1xuICB2YXIgZV8xLCBfYSwgZV8yLCBfYiwgZV8zLCBfYywgZV80LCBfZDtcblxuICB2YXIgcHJldkNvbmZpZ3VyYXRpb24gPSBuZXcgU2V0KHByZXZTdGF0ZU5vZGVzKTtcbiAgdmFyIHByZXZBZGpMaXN0ID0gZ2V0QWRqTGlzdChwcmV2Q29uZmlndXJhdGlvbik7XG4gIHZhciBjb25maWd1cmF0aW9uID0gbmV3IFNldChzdGF0ZU5vZGVzKTtcblxuICB0cnkge1xuICAgIC8vIGFkZCBhbGwgYW5jZXN0b3JzXG4gICAgZm9yICh2YXIgY29uZmlndXJhdGlvbl8xID0gX192YWx1ZXMoY29uZmlndXJhdGlvbiksIGNvbmZpZ3VyYXRpb25fMV8xID0gY29uZmlndXJhdGlvbl8xLm5leHQoKTsgIWNvbmZpZ3VyYXRpb25fMV8xLmRvbmU7IGNvbmZpZ3VyYXRpb25fMV8xID0gY29uZmlndXJhdGlvbl8xLm5leHQoKSkge1xuICAgICAgdmFyIHMgPSBjb25maWd1cmF0aW9uXzFfMS52YWx1ZTtcbiAgICAgIHZhciBtID0gcy5wYXJlbnQ7XG5cbiAgICAgIHdoaWxlIChtICYmICFjb25maWd1cmF0aW9uLmhhcyhtKSkge1xuICAgICAgICBjb25maWd1cmF0aW9uLmFkZChtKTtcbiAgICAgICAgbSA9IG0ucGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICBlXzEgPSB7XG4gICAgICBlcnJvcjogZV8xXzFcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbl8xXzEgJiYgIWNvbmZpZ3VyYXRpb25fMV8xLmRvbmUgJiYgKF9hID0gY29uZmlndXJhdGlvbl8xLnJldHVybikpIF9hLmNhbGwoY29uZmlndXJhdGlvbl8xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhZGpMaXN0ID0gZ2V0QWRqTGlzdChjb25maWd1cmF0aW9uKTtcblxuICB0cnkge1xuICAgIC8vIGFkZCBkZXNjZW5kYW50c1xuICAgIGZvciAodmFyIGNvbmZpZ3VyYXRpb25fMiA9IF9fdmFsdWVzKGNvbmZpZ3VyYXRpb24pLCBjb25maWd1cmF0aW9uXzJfMSA9IGNvbmZpZ3VyYXRpb25fMi5uZXh0KCk7ICFjb25maWd1cmF0aW9uXzJfMS5kb25lOyBjb25maWd1cmF0aW9uXzJfMSA9IGNvbmZpZ3VyYXRpb25fMi5uZXh0KCkpIHtcbiAgICAgIHZhciBzID0gY29uZmlndXJhdGlvbl8yXzEudmFsdWU7IC8vIGlmIHByZXZpb3VzbHkgYWN0aXZlLCBhZGQgZXhpc3RpbmcgY2hpbGQgbm9kZXNcblxuICAgICAgaWYgKHMudHlwZSA9PT0gJ2NvbXBvdW5kJyAmJiAoIWFkakxpc3QuZ2V0KHMpIHx8ICFhZGpMaXN0LmdldChzKS5sZW5ndGgpKSB7XG4gICAgICAgIGlmIChwcmV2QWRqTGlzdC5nZXQocykpIHtcbiAgICAgICAgICBwcmV2QWRqTGlzdC5nZXQocykuZm9yRWFjaChmdW5jdGlvbiAoc24pIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWd1cmF0aW9uLmFkZChzbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcy5pbml0aWFsU3RhdGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzbikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb24uYWRkKHNuKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHMudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZSA9IChlXzMgPSB2b2lkIDAsIF9fdmFsdWVzKGdldENoaWxkcmVuKHMpKSksIF9mID0gX2UubmV4dCgpOyAhX2YuZG9uZTsgX2YgPSBfZS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2YudmFsdWU7XG5cbiAgICAgICAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uLmFkZChjaGlsZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJldkFkakxpc3QuZ2V0KGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgcHJldkFkakxpc3QuZ2V0KGNoaWxkKS5mb3JFYWNoKGZ1bmN0aW9uIChzbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlndXJhdGlvbi5hZGQoc24pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkLmluaXRpYWxTdGF0ZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHNuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25maWd1cmF0aW9uLmFkZChzbik7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlXzNfMSkge1xuICAgICAgICAgICAgZV8zID0ge1xuICAgICAgICAgICAgICBlcnJvcjogZV8zXzFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChfZiAmJiAhX2YuZG9uZSAmJiAoX2MgPSBfZS5yZXR1cm4pKSBfYy5jYWxsKF9lKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVfMl8xKSB7XG4gICAgZV8yID0ge1xuICAgICAgZXJyb3I6IGVfMl8xXG4gICAgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKGNvbmZpZ3VyYXRpb25fMl8xICYmICFjb25maWd1cmF0aW9uXzJfMS5kb25lICYmIChfYiA9IGNvbmZpZ3VyYXRpb25fMi5yZXR1cm4pKSBfYi5jYWxsKGNvbmZpZ3VyYXRpb25fMik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjtcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIC8vIGFkZCBhbGwgYW5jZXN0b3JzXG4gICAgZm9yICh2YXIgY29uZmlndXJhdGlvbl8zID0gX192YWx1ZXMoY29uZmlndXJhdGlvbiksIGNvbmZpZ3VyYXRpb25fM18xID0gY29uZmlndXJhdGlvbl8zLm5leHQoKTsgIWNvbmZpZ3VyYXRpb25fM18xLmRvbmU7IGNvbmZpZ3VyYXRpb25fM18xID0gY29uZmlndXJhdGlvbl8zLm5leHQoKSkge1xuICAgICAgdmFyIHMgPSBjb25maWd1cmF0aW9uXzNfMS52YWx1ZTtcbiAgICAgIHZhciBtID0gcy5wYXJlbnQ7XG5cbiAgICAgIHdoaWxlIChtICYmICFjb25maWd1cmF0aW9uLmhhcyhtKSkge1xuICAgICAgICBjb25maWd1cmF0aW9uLmFkZChtKTtcbiAgICAgICAgbSA9IG0ucGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZV80XzEpIHtcbiAgICBlXzQgPSB7XG4gICAgICBlcnJvcjogZV80XzFcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbl8zXzEgJiYgIWNvbmZpZ3VyYXRpb25fM18xLmRvbmUgJiYgKF9kID0gY29uZmlndXJhdGlvbl8zLnJldHVybikpIF9kLmNhbGwoY29uZmlndXJhdGlvbl8zKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWd1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZUZyb21BZGooYmFzZU5vZGUsIGFkakxpc3QpIHtcbiAgdmFyIGNoaWxkU3RhdGVOb2RlcyA9IGFkakxpc3QuZ2V0KGJhc2VOb2RlKTtcblxuICBpZiAoIWNoaWxkU3RhdGVOb2Rlcykge1xuICAgIHJldHVybiB7fTsgLy8gdG9kbzogZml4P1xuICB9XG5cbiAgaWYgKGJhc2VOb2RlLnR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICB2YXIgY2hpbGRTdGF0ZU5vZGUgPSBjaGlsZFN0YXRlTm9kZXNbMF07XG5cbiAgICBpZiAoY2hpbGRTdGF0ZU5vZGUpIHtcbiAgICAgIGlmIChpc0xlYWZOb2RlKGNoaWxkU3RhdGVOb2RlKSkge1xuICAgICAgICByZXR1cm4gY2hpbGRTdGF0ZU5vZGUua2V5O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlVmFsdWUgPSB7fTtcbiAgY2hpbGRTdGF0ZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGNzbikge1xuICAgIHN0YXRlVmFsdWVbY3NuLmtleV0gPSBnZXRWYWx1ZUZyb21BZGooY3NuLCBhZGpMaXN0KTtcbiAgfSk7XG4gIHJldHVybiBzdGF0ZVZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRBZGpMaXN0KGNvbmZpZ3VyYXRpb24pIHtcbiAgdmFyIGVfNSwgX2E7XG5cbiAgdmFyIGFkakxpc3QgPSBuZXcgTWFwKCk7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBjb25maWd1cmF0aW9uXzQgPSBfX3ZhbHVlcyhjb25maWd1cmF0aW9uKSwgY29uZmlndXJhdGlvbl80XzEgPSBjb25maWd1cmF0aW9uXzQubmV4dCgpOyAhY29uZmlndXJhdGlvbl80XzEuZG9uZTsgY29uZmlndXJhdGlvbl80XzEgPSBjb25maWd1cmF0aW9uXzQubmV4dCgpKSB7XG4gICAgICB2YXIgcyA9IGNvbmZpZ3VyYXRpb25fNF8xLnZhbHVlO1xuXG4gICAgICBpZiAoIWFkakxpc3QuaGFzKHMpKSB7XG4gICAgICAgIGFkakxpc3Quc2V0KHMsIFtdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMucGFyZW50KSB7XG4gICAgICAgIGlmICghYWRqTGlzdC5oYXMocy5wYXJlbnQpKSB7XG4gICAgICAgICAgYWRqTGlzdC5zZXQocy5wYXJlbnQsIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkakxpc3QuZ2V0KHMucGFyZW50KS5wdXNoKHMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZV81XzEpIHtcbiAgICBlXzUgPSB7XG4gICAgICBlcnJvcjogZV81XzFcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbl80XzEgJiYgIWNvbmZpZ3VyYXRpb25fNF8xLmRvbmUgJiYgKF9hID0gY29uZmlndXJhdGlvbl80LnJldHVybikpIF9hLmNhbGwoY29uZmlndXJhdGlvbl80KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhZGpMaXN0O1xufVxuZnVuY3Rpb24gZ2V0VmFsdWUocm9vdE5vZGUsIGNvbmZpZ3VyYXRpb24pIHtcbiAgdmFyIGNvbmZpZyA9IGdldENvbmZpZ3VyYXRpb24oW3Jvb3ROb2RlXSwgY29uZmlndXJhdGlvbik7XG4gIHJldHVybiBnZXRWYWx1ZUZyb21BZGoocm9vdE5vZGUsIGdldEFkakxpc3QoY29uZmlnKSk7XG59XG5mdW5jdGlvbiBoYXMoaXRlcmFibGUsIGl0ZW0pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaXRlcmFibGUpKSB7XG4gICAgcmV0dXJuIGl0ZXJhYmxlLnNvbWUoZnVuY3Rpb24gKG1lbWJlcikge1xuICAgICAgcmV0dXJuIG1lbWJlciA9PT0gaXRlbTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpdGVyYWJsZSBpbnN0YW5jZW9mIFNldCkge1xuICAgIHJldHVybiBpdGVyYWJsZS5oYXMoaXRlbSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7IC8vIFRPRE86IGZpeFxufVxuZnVuY3Rpb24gbmV4dEV2ZW50cyhjb25maWd1cmF0aW9uKSB7XG4gIHJldHVybiBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQobmV3IFNldChmbGF0dGVuKF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChjb25maWd1cmF0aW9uLm1hcChmdW5jdGlvbiAoc24pIHtcbiAgICByZXR1cm4gc24ub3duRXZlbnRzO1xuICB9KSksIGZhbHNlKSkpKSwgZmFsc2UpO1xufVxuZnVuY3Rpb24gaXNJbkZpbmFsU3RhdGUoY29uZmlndXJhdGlvbiwgc3RhdGVOb2RlKSB7XG4gIGlmIChzdGF0ZU5vZGUudHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgIHJldHVybiBnZXRDaGlsZHJlbihzdGF0ZU5vZGUpLnNvbWUoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiBzLnR5cGUgPT09ICdmaW5hbCcgJiYgaGFzKGNvbmZpZ3VyYXRpb24sIHMpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHN0YXRlTm9kZS50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgcmV0dXJuIGdldENoaWxkcmVuKHN0YXRlTm9kZSkuZXZlcnkoZnVuY3Rpb24gKHNuKSB7XG4gICAgICByZXR1cm4gaXNJbkZpbmFsU3RhdGUoY29uZmlndXJhdGlvbiwgc24pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0TWV0YShjb25maWd1cmF0aW9uKSB7XG4gIGlmIChjb25maWd1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICBjb25maWd1cmF0aW9uID0gW107XG4gIH1cblxuICByZXR1cm4gY29uZmlndXJhdGlvbi5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc3RhdGVOb2RlKSB7XG4gICAgaWYgKHN0YXRlTm9kZS5tZXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFjY1tzdGF0ZU5vZGUuaWRdID0gc3RhdGVOb2RlLm1ldGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gZ2V0VGFnc0Zyb21Db25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pIHtcbiAgcmV0dXJuIG5ldyBTZXQoZmxhdHRlbihjb25maWd1cmF0aW9uLm1hcChmdW5jdGlvbiAoc24pIHtcbiAgICByZXR1cm4gc24udGFncztcbiAgfSkpKTtcbn1cblxuZXhwb3J0IHsgZ2V0QWRqTGlzdCwgZ2V0QWxsQ2hpbGRyZW4sIGdldEFsbFN0YXRlTm9kZXMsIGdldENoaWxkcmVuLCBnZXRDb25maWd1cmF0aW9uLCBnZXRNZXRhLCBnZXRUYWdzRnJvbUNvbmZpZ3VyYXRpb24sIGdldFZhbHVlLCBoYXMsIGlzSW5GaW5hbFN0YXRlLCBpc0xlYWZOb2RlLCBuZXh0RXZlbnRzIH07XG4iLCJ2YXIgQWN0aW9uVHlwZXM7XG5cbihmdW5jdGlvbiAoQWN0aW9uVHlwZXMpIHtcbiAgQWN0aW9uVHlwZXNbXCJTdGFydFwiXSA9IFwieHN0YXRlLnN0YXJ0XCI7XG4gIEFjdGlvblR5cGVzW1wiU3RvcFwiXSA9IFwieHN0YXRlLnN0b3BcIjtcbiAgQWN0aW9uVHlwZXNbXCJSYWlzZVwiXSA9IFwieHN0YXRlLnJhaXNlXCI7XG4gIEFjdGlvblR5cGVzW1wiU2VuZFwiXSA9IFwieHN0YXRlLnNlbmRcIjtcbiAgQWN0aW9uVHlwZXNbXCJDYW5jZWxcIl0gPSBcInhzdGF0ZS5jYW5jZWxcIjtcbiAgQWN0aW9uVHlwZXNbXCJOdWxsRXZlbnRcIl0gPSBcIlwiO1xuICBBY3Rpb25UeXBlc1tcIkFzc2lnblwiXSA9IFwieHN0YXRlLmFzc2lnblwiO1xuICBBY3Rpb25UeXBlc1tcIkFmdGVyXCJdID0gXCJ4c3RhdGUuYWZ0ZXJcIjtcbiAgQWN0aW9uVHlwZXNbXCJEb25lU3RhdGVcIl0gPSBcImRvbmUuc3RhdGVcIjtcbiAgQWN0aW9uVHlwZXNbXCJEb25lSW52b2tlXCJdID0gXCJkb25lLmludm9rZVwiO1xuICBBY3Rpb25UeXBlc1tcIkxvZ1wiXSA9IFwieHN0YXRlLmxvZ1wiO1xuICBBY3Rpb25UeXBlc1tcIkluaXRcIl0gPSBcInhzdGF0ZS5pbml0XCI7XG4gIEFjdGlvblR5cGVzW1wiSW52b2tlXCJdID0gXCJ4c3RhdGUuaW52b2tlXCI7XG4gIEFjdGlvblR5cGVzW1wiRXJyb3JFeGVjdXRpb25cIl0gPSBcImVycm9yLmV4ZWN1dGlvblwiO1xuICBBY3Rpb25UeXBlc1tcIkVycm9yQ29tbXVuaWNhdGlvblwiXSA9IFwiZXJyb3IuY29tbXVuaWNhdGlvblwiO1xuICBBY3Rpb25UeXBlc1tcIkVycm9yUGxhdGZvcm1cIl0gPSBcImVycm9yLnBsYXRmb3JtXCI7XG4gIEFjdGlvblR5cGVzW1wiRXJyb3JDdXN0b21cIl0gPSBcInhzdGF0ZS5lcnJvclwiO1xuICBBY3Rpb25UeXBlc1tcIlVwZGF0ZVwiXSA9IFwieHN0YXRlLnVwZGF0ZVwiO1xuICBBY3Rpb25UeXBlc1tcIlB1cmVcIl0gPSBcInhzdGF0ZS5wdXJlXCI7XG4gIEFjdGlvblR5cGVzW1wiQ2hvb3NlXCJdID0gXCJ4c3RhdGUuY2hvb3NlXCI7XG59KShBY3Rpb25UeXBlcyB8fCAoQWN0aW9uVHlwZXMgPSB7fSkpO1xuXG52YXIgU3BlY2lhbFRhcmdldHM7XG5cbihmdW5jdGlvbiAoU3BlY2lhbFRhcmdldHMpIHtcbiAgU3BlY2lhbFRhcmdldHNbXCJQYXJlbnRcIl0gPSBcIiNfcGFyZW50XCI7XG4gIFNwZWNpYWxUYXJnZXRzW1wiSW50ZXJuYWxcIl0gPSBcIiNfaW50ZXJuYWxcIjtcbn0pKFNwZWNpYWxUYXJnZXRzIHx8IChTcGVjaWFsVGFyZ2V0cyA9IHt9KSk7XG5cbmV4cG9ydCB7IEFjdGlvblR5cGVzLCBTcGVjaWFsVGFyZ2V0cyB9O1xuIiwiaW1wb3J0IHsgX192YWx1ZXMsIF9fc3ByZWFkQXJyYXksIF9fcmVhZCwgX19hc3NpZ24gfSBmcm9tICcuL192aXJ0dWFsL190c2xpYi5qcyc7XG5pbXBvcnQgeyBTcGVjaWFsVGFyZ2V0cyB9IGZyb20gJy4vdHlwZXMuanMnO1xuaW1wb3J0IHsgcmFpc2UsIHNlbmQgfSBmcm9tICcuL2FjdGlvblR5cGVzLmpzJztcbmltcG9ydCB7IERFRkFVTFRfR1VBUkRfVFlQRSwgVEFSR0VUTEVTU19LRVksIFNUQVRFX0RFTElNSVRFUiB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IElTX1BST0RVQ1RJT04gfSBmcm9tICcuL2Vudmlyb25tZW50LmpzJztcblxudmFyIF9hO1xuZnVuY3Rpb24ga2V5cyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpO1xufVxuZnVuY3Rpb24gbWF0Y2hlc1N0YXRlKHBhcmVudFN0YXRlSWQsIGNoaWxkU3RhdGVJZCwgZGVsaW1pdGVyKSB7XG4gIGlmIChkZWxpbWl0ZXIgPT09IHZvaWQgMCkge1xuICAgIGRlbGltaXRlciA9IFNUQVRFX0RFTElNSVRFUjtcbiAgfVxuXG4gIHZhciBwYXJlbnRTdGF0ZVZhbHVlID0gdG9TdGF0ZVZhbHVlKHBhcmVudFN0YXRlSWQsIGRlbGltaXRlcik7XG4gIHZhciBjaGlsZFN0YXRlVmFsdWUgPSB0b1N0YXRlVmFsdWUoY2hpbGRTdGF0ZUlkLCBkZWxpbWl0ZXIpO1xuXG4gIGlmIChpc1N0cmluZyhjaGlsZFN0YXRlVmFsdWUpKSB7XG4gICAgaWYgKGlzU3RyaW5nKHBhcmVudFN0YXRlVmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2hpbGRTdGF0ZVZhbHVlID09PSBwYXJlbnRTdGF0ZVZhbHVlO1xuICAgIH0gLy8gUGFyZW50IG1vcmUgc3BlY2lmaWMgdGhhbiBjaGlsZFxuXG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNTdHJpbmcocGFyZW50U3RhdGVWYWx1ZSkpIHtcbiAgICByZXR1cm4gcGFyZW50U3RhdGVWYWx1ZSBpbiBjaGlsZFN0YXRlVmFsdWU7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXMocGFyZW50U3RhdGVWYWx1ZSkuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghKGtleSBpbiBjaGlsZFN0YXRlVmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXNTdGF0ZShwYXJlbnRTdGF0ZVZhbHVlW2tleV0sIGNoaWxkU3RhdGVWYWx1ZVtrZXldKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRFdmVudFR5cGUoZXZlbnQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXNTdHJpbmcoZXZlbnQpIHx8IHR5cGVvZiBldmVudCA9PT0gJ251bWJlcicgPyBcIlwiLmNvbmNhdChldmVudCkgOiBldmVudC50eXBlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudHMgbXVzdCBiZSBzdHJpbmdzIG9yIG9iamVjdHMgd2l0aCBhIHN0cmluZyBldmVudC50eXBlIHByb3BlcnR5LicpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRBY3Rpb25UeXBlKGFjdGlvbikge1xuICB0cnkge1xuICAgIHJldHVybiBpc1N0cmluZyhhY3Rpb24pIHx8IHR5cGVvZiBhY3Rpb24gPT09ICdudW1iZXInID8gXCJcIi5jb25jYXQoYWN0aW9uKSA6IGlzRnVuY3Rpb24oYWN0aW9uKSA/IGFjdGlvbi5uYW1lIDogYWN0aW9uLnR5cGU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbXVzdCBiZSBzdHJpbmdzIG9yIG9iamVjdHMgd2l0aCBhIHN0cmluZyBhY3Rpb24udHlwZSBwcm9wZXJ0eS4nKTtcbiAgfVxufVxuZnVuY3Rpb24gdG9TdGF0ZVBhdGgoc3RhdGVJZCwgZGVsaW1pdGVyKSB7XG4gIHRyeSB7XG4gICAgaWYgKGlzQXJyYXkoc3RhdGVJZCkpIHtcbiAgICAgIHJldHVybiBzdGF0ZUlkO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZUlkLnRvU3RyaW5nKCkuc3BsaXQoZGVsaW1pdGVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIidcIi5jb25jYXQoc3RhdGVJZCwgXCInIGlzIG5vdCBhIHZhbGlkIHN0YXRlIHBhdGguXCIpKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTdGF0ZUxpa2Uoc3RhdGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gJ29iamVjdCcgJiYgJ3ZhbHVlJyBpbiBzdGF0ZSAmJiAnY29udGV4dCcgaW4gc3RhdGUgJiYgJ2V2ZW50JyBpbiBzdGF0ZSAmJiAnX2V2ZW50JyBpbiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHRvU3RhdGVWYWx1ZShzdGF0ZVZhbHVlLCBkZWxpbWl0ZXIpIHtcbiAgaWYgKGlzU3RhdGVMaWtlKHN0YXRlVmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0YXRlVmFsdWUudmFsdWU7XG4gIH1cblxuICBpZiAoaXNBcnJheShzdGF0ZVZhbHVlKSkge1xuICAgIHJldHVybiBwYXRoVG9TdGF0ZVZhbHVlKHN0YXRlVmFsdWUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzdGF0ZVZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdGF0ZVZhbHVlO1xuICB9XG5cbiAgdmFyIHN0YXRlUGF0aCA9IHRvU3RhdGVQYXRoKHN0YXRlVmFsdWUsIGRlbGltaXRlcik7XG4gIHJldHVybiBwYXRoVG9TdGF0ZVZhbHVlKHN0YXRlUGF0aCk7XG59XG5mdW5jdGlvbiBwYXRoVG9TdGF0ZVZhbHVlKHN0YXRlUGF0aCkge1xuICBpZiAoc3RhdGVQYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBzdGF0ZVBhdGhbMF07XG4gIH1cblxuICB2YXIgdmFsdWUgPSB7fTtcbiAgdmFyIG1hcmtlciA9IHZhbHVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVQYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmIChpID09PSBzdGF0ZVBhdGgubGVuZ3RoIC0gMikge1xuICAgICAgbWFya2VyW3N0YXRlUGF0aFtpXV0gPSBzdGF0ZVBhdGhbaSArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrZXJbc3RhdGVQYXRoW2ldXSA9IHt9O1xuICAgICAgbWFya2VyID0gbWFya2VyW3N0YXRlUGF0aFtpXV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gbWFwVmFsdWVzKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIGNvbGxlY3Rpb25LZXlzID0gT2JqZWN0LmtleXMoY29sbGVjdGlvbik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBjb2xsZWN0aW9uS2V5c1tpXTtcbiAgICByZXN1bHRba2V5XSA9IGl0ZXJhdGVlKGNvbGxlY3Rpb25ba2V5XSwga2V5LCBjb2xsZWN0aW9uLCBpKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtYXBGaWx0ZXJWYWx1ZXMoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHByZWRpY2F0ZSkge1xuICB2YXIgZV8xLCBfYTtcblxuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgdmFyIGtleSA9IF9jLnZhbHVlO1xuICAgICAgdmFyIGl0ZW0gPSBjb2xsZWN0aW9uW2tleV07XG5cbiAgICAgIGlmICghcHJlZGljYXRlKGl0ZW0pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRba2V5XSA9IGl0ZXJhdGVlKGl0ZW0sIGtleSwgY29sbGVjdGlvbik7XG4gICAgfVxuICB9IGNhdGNoIChlXzFfMSkge1xuICAgIGVfMSA9IHtcbiAgICAgIGVycm9yOiBlXzFfMVxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcclxuICogUmV0cmlldmVzIGEgdmFsdWUgYXQgdGhlIGdpdmVuIHBhdGguXHJcbiAqIEBwYXJhbSBwcm9wcyBUaGUgZGVlcCBwYXRoIHRvIHRoZSBwcm9wIG9mIHRoZSBkZXNpcmVkIHZhbHVlXHJcbiAqL1xuXG52YXIgcGF0aCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBlXzIsIF9hO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9iamVjdDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBwcm9wc18xID0gX192YWx1ZXMocHJvcHMpLCBwcm9wc18xXzEgPSBwcm9wc18xLm5leHQoKTsgIXByb3BzXzFfMS5kb25lOyBwcm9wc18xXzEgPSBwcm9wc18xLm5leHQoKSkge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzXzFfMS52YWx1ZTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0W3Byb3BdO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfMl8xKSB7XG4gICAgICBlXzIgPSB7XG4gICAgICAgIGVycm9yOiBlXzJfMVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHByb3BzXzFfMSAmJiAhcHJvcHNfMV8xLmRvbmUgJiYgKF9hID0gcHJvcHNfMS5yZXR1cm4pKSBfYS5jYWxsKHByb3BzXzEpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuLyoqXHJcbiAqIFJldHJpZXZlcyBhIHZhbHVlIGF0IHRoZSBnaXZlbiBwYXRoIHZpYSB0aGUgbmVzdGVkIGFjY2Vzc29yIHByb3AuXHJcbiAqIEBwYXJhbSBwcm9wcyBUaGUgZGVlcCBwYXRoIHRvIHRoZSBwcm9wIG9mIHRoZSBkZXNpcmVkIHZhbHVlXHJcbiAqL1xuXG5mdW5jdGlvbiBuZXN0ZWRQYXRoKHByb3BzLCBhY2Nlc3NvclByb3ApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgZV8zLCBfYTtcblxuICAgIHZhciByZXN1bHQgPSBvYmplY3Q7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgcHJvcHNfMiA9IF9fdmFsdWVzKHByb3BzKSwgcHJvcHNfMl8xID0gcHJvcHNfMi5uZXh0KCk7ICFwcm9wc18yXzEuZG9uZTsgcHJvcHNfMl8xID0gcHJvcHNfMi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc18yXzEudmFsdWU7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdFthY2Nlc3NvclByb3BdW3Byb3BdO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfM18xKSB7XG4gICAgICBlXzMgPSB7XG4gICAgICAgIGVycm9yOiBlXzNfMVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHByb3BzXzJfMSAmJiAhcHJvcHNfMl8xLmRvbmUgJiYgKF9hID0gcHJvcHNfMi5yZXR1cm4pKSBfYS5jYWxsKHByb3BzXzIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5mdW5jdGlvbiB0b1N0YXRlUGF0aHMoc3RhdGVWYWx1ZSkge1xuICBpZiAoIXN0YXRlVmFsdWUpIHtcbiAgICByZXR1cm4gW1tdXTtcbiAgfVxuXG4gIGlmIChpc1N0cmluZyhzdGF0ZVZhbHVlKSkge1xuICAgIHJldHVybiBbW3N0YXRlVmFsdWVdXTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBmbGF0dGVuKE9iamVjdC5rZXlzKHN0YXRlVmFsdWUpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHN1YlN0YXRlVmFsdWUgPSBzdGF0ZVZhbHVlW2tleV07XG5cbiAgICBpZiAodHlwZW9mIHN1YlN0YXRlVmFsdWUgIT09ICdzdHJpbmcnICYmICghc3ViU3RhdGVWYWx1ZSB8fCAhT2JqZWN0LmtleXMoc3ViU3RhdGVWYWx1ZSkubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIFtba2V5XV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvU3RhdGVQYXRocyhzdGF0ZVZhbHVlW2tleV0pLm1hcChmdW5jdGlvbiAoc3ViUGF0aCkge1xuICAgICAgcmV0dXJuIFtrZXldLmNvbmNhdChzdWJQYXRoKTtcbiAgICB9KTtcbiAgfSkpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGF0aHNUb1N0YXRlVmFsdWUocGF0aHMpIHtcbiAgdmFyIGVfNCwgX2E7XG5cbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGlmIChwYXRocyAmJiBwYXRocy5sZW5ndGggPT09IDEgJiYgcGF0aHNbMF0ubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHBhdGhzWzBdWzBdO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBwYXRoc18xID0gX192YWx1ZXMocGF0aHMpLCBwYXRoc18xXzEgPSBwYXRoc18xLm5leHQoKTsgIXBhdGhzXzFfMS5kb25lOyBwYXRoc18xXzEgPSBwYXRoc18xLm5leHQoKSkge1xuICAgICAgdmFyIGN1cnJlbnRQYXRoID0gcGF0aHNfMV8xLnZhbHVlO1xuICAgICAgdmFyIG1hcmtlciA9IHJlc3VsdDsgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnByZWZlci1mb3Itb2ZcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyZW50UGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3ViUGF0aCA9IGN1cnJlbnRQYXRoW2ldO1xuXG4gICAgICAgIGlmIChpID09PSBjdXJyZW50UGF0aC5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgbWFya2VyW3N1YlBhdGhdID0gY3VycmVudFBhdGhbaSArIDFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFya2VyW3N1YlBhdGhdID0gbWFya2VyW3N1YlBhdGhdIHx8IHt9O1xuICAgICAgICBtYXJrZXIgPSBtYXJrZXJbc3ViUGF0aF07XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlXzRfMSkge1xuICAgIGVfNCA9IHtcbiAgICAgIGVycm9yOiBlXzRfMVxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChwYXRoc18xXzEgJiYgIXBhdGhzXzFfMS5kb25lICYmIChfYSA9IHBhdGhzXzEucmV0dXJuKSkgX2EuY2FsbChwYXRoc18xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBfYTtcblxuICByZXR1cm4gKF9hID0gW10pLmNvbmNhdC5hcHBseShfYSwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFycmF5KSwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIHRvQXJyYXlTdHJpY3QodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIFt2YWx1ZV07XG59XG5mdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIHRvQXJyYXlTdHJpY3QodmFsdWUpO1xufVxuZnVuY3Rpb24gbWFwQ29udGV4dChtYXBwZXIsIGNvbnRleHQsIF9ldmVudCkge1xuICB2YXIgZV81LCBfYTtcblxuICBpZiAoaXNGdW5jdGlvbihtYXBwZXIpKSB7XG4gICAgcmV0dXJuIG1hcHBlcihjb250ZXh0LCBfZXZlbnQuZGF0YSk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKE9iamVjdC5rZXlzKG1hcHBlcikpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICB2YXIga2V5ID0gX2MudmFsdWU7XG4gICAgICB2YXIgc3ViTWFwcGVyID0gbWFwcGVyW2tleV07XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHN1Yk1hcHBlcikpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBzdWJNYXBwZXIoY29udGV4dCwgX2V2ZW50LmRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBzdWJNYXBwZXI7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlXzVfMSkge1xuICAgIGVfNSA9IHtcbiAgICAgIGVycm9yOiBlXzVfMVxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc0J1aWx0SW5FdmVudChldmVudFR5cGUpIHtcbiAgcmV0dXJuIC9eKGRvbmV8ZXJyb3IpXFwuLy50ZXN0KGV2ZW50VHlwZSk7XG59XG5mdW5jdGlvbiBpc1Byb21pc2VMaWtlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBDaGVjayBpZiBzaGFwZSBtYXRjaGVzIHRoZSBQcm9taXNlL0ErIHNwZWNpZmljYXRpb24gZm9yIGEgXCJ0aGVuYWJsZVwiLlxuXG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnRoZW4pKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0JlaGF2aW9yKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICd0cmFuc2l0aW9uJyBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudHJhbnNpdGlvbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIHBhcnRpdGlvbihpdGVtcywgcHJlZGljYXRlKSB7XG4gIHZhciBlXzYsIF9hO1xuXG4gIHZhciBfYiA9IF9fcmVhZChbW10sIFtdXSwgMiksXG4gICAgICB0cnV0aHkgPSBfYlswXSxcbiAgICAgIGZhbHN5ID0gX2JbMV07XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBpdGVtc18xID0gX192YWx1ZXMoaXRlbXMpLCBpdGVtc18xXzEgPSBpdGVtc18xLm5leHQoKTsgIWl0ZW1zXzFfMS5kb25lOyBpdGVtc18xXzEgPSBpdGVtc18xLm5leHQoKSkge1xuICAgICAgdmFyIGl0ZW0gPSBpdGVtc18xXzEudmFsdWU7XG5cbiAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSkpIHtcbiAgICAgICAgdHJ1dGh5LnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWxzeS5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZV82XzEpIHtcbiAgICBlXzYgPSB7XG4gICAgICBlcnJvcjogZV82XzFcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoaXRlbXNfMV8xICYmICFpdGVtc18xXzEuZG9uZSAmJiAoX2EgPSBpdGVtc18xLnJldHVybikpIF9hLmNhbGwoaXRlbXNfMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlXzYpIHRocm93IGVfNi5lcnJvcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW3RydXRoeSwgZmFsc3ldO1xufVxuZnVuY3Rpb24gdXBkYXRlSGlzdG9yeVN0YXRlcyhoaXN0LCBzdGF0ZVZhbHVlKSB7XG4gIHJldHVybiBtYXBWYWx1ZXMoaGlzdC5zdGF0ZXMsIGZ1bmN0aW9uIChzdWJIaXN0LCBrZXkpIHtcbiAgICBpZiAoIXN1Ykhpc3QpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIHN1YlN0YXRlVmFsdWUgPSAoaXNTdHJpbmcoc3RhdGVWYWx1ZSkgPyB1bmRlZmluZWQgOiBzdGF0ZVZhbHVlW2tleV0pIHx8IChzdWJIaXN0ID8gc3ViSGlzdC5jdXJyZW50IDogdW5kZWZpbmVkKTtcblxuICAgIGlmICghc3ViU3RhdGVWYWx1ZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudDogc3ViU3RhdGVWYWx1ZSxcbiAgICAgIHN0YXRlczogdXBkYXRlSGlzdG9yeVN0YXRlcyhzdWJIaXN0LCBzdWJTdGF0ZVZhbHVlKVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlSGlzdG9yeVZhbHVlKGhpc3QsIHN0YXRlVmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBzdGF0ZVZhbHVlLFxuICAgIHN0YXRlczogdXBkYXRlSGlzdG9yeVN0YXRlcyhoaXN0LCBzdGF0ZVZhbHVlKVxuICB9O1xufVxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dChjb250ZXh0LCBfZXZlbnQsIGFzc2lnbkFjdGlvbnMsIHN0YXRlKSB7XG4gIGlmICghSVNfUFJPRFVDVElPTikge1xuICAgIHdhcm4oISFjb250ZXh0LCAnQXR0ZW1wdGluZyB0byB1cGRhdGUgdW5kZWZpbmVkIGNvbnRleHQnKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVkQ29udGV4dCA9IGNvbnRleHQgPyBhc3NpZ25BY3Rpb25zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhc3NpZ25BY3Rpb24pIHtcbiAgICB2YXIgZV83LCBfYTtcblxuICAgIHZhciBhc3NpZ25tZW50ID0gYXNzaWduQWN0aW9uLmFzc2lnbm1lbnQ7XG4gICAgdmFyIG1ldGEgPSB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBhY3Rpb246IGFzc2lnbkFjdGlvbixcbiAgICAgIF9ldmVudDogX2V2ZW50XG4gICAgfTtcbiAgICB2YXIgcGFydGlhbFVwZGF0ZSA9IHt9O1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oYXNzaWdubWVudCkpIHtcbiAgICAgIHBhcnRpYWxVcGRhdGUgPSBhc3NpZ25tZW50KGFjYywgX2V2ZW50LmRhdGEsIG1ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKE9iamVjdC5rZXlzKGFzc2lnbm1lbnQpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgIHZhciBrZXkgPSBfYy52YWx1ZTtcbiAgICAgICAgICB2YXIgcHJvcEFzc2lnbm1lbnQgPSBhc3NpZ25tZW50W2tleV07XG4gICAgICAgICAgcGFydGlhbFVwZGF0ZVtrZXldID0gaXNGdW5jdGlvbihwcm9wQXNzaWdubWVudCkgPyBwcm9wQXNzaWdubWVudChhY2MsIF9ldmVudC5kYXRhLCBtZXRhKSA6IHByb3BBc3NpZ25tZW50O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzdfMSkge1xuICAgICAgICBlXzcgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfN18xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV83KSB0aHJvdyBlXzcuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYWNjLCBwYXJ0aWFsVXBkYXRlKTtcbiAgfSwgY29udGV4dCkgOiBjb250ZXh0O1xuICByZXR1cm4gdXBkYXRlZENvbnRleHQ7XG59IC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1lbXB0eVxuXG52YXIgd2FybiA9IGZ1bmN0aW9uICgpIHt9O1xuXG5pZiAoIUlTX1BST0RVQ1RJT04pIHtcbiAgd2FybiA9IGZ1bmN0aW9uIChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICB2YXIgZXJyb3IgPSBjb25kaXRpb24gaW5zdGFuY2VvZiBFcnJvciA/IGNvbmRpdGlvbiA6IHVuZGVmaW5lZDtcblxuICAgIGlmICghZXJyb3IgJiYgY29uZGl0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNvbnNvbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXCJXYXJuaW5nOiBcIi5jb25jYXQobWVzc2FnZSldO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgYXJncy5wdXNoKGVycm9yKTtcbiAgICAgIH0gLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcblxuXG4gICAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59IC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpiYW4tdHlwZXNcblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5mdW5jdGlvbiB0b0d1YXJkKGNvbmRpdGlvbiwgZ3VhcmRNYXApIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nKGNvbmRpdGlvbikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogREVGQVVMVF9HVUFSRF9UWVBFLFxuICAgICAgbmFtZTogY29uZGl0aW9uLFxuICAgICAgcHJlZGljYXRlOiBndWFyZE1hcCA/IGd1YXJkTWFwW2NvbmRpdGlvbl0gOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG5cbiAgaWYgKGlzRnVuY3Rpb24oY29uZGl0aW9uKSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBERUZBVUxUX0dVQVJEX1RZUEUsXG4gICAgICBuYW1lOiBjb25kaXRpb24ubmFtZSxcbiAgICAgIHByZWRpY2F0ZTogY29uZGl0aW9uXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBjb25kaXRpb247XG59XG5mdW5jdGlvbiBpc09ic2VydmFibGUodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJ3N1YnNjcmliZScgaW4gdmFsdWUgJiYgaXNGdW5jdGlvbih2YWx1ZS5zdWJzY3JpYmUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG52YXIgc3ltYm9sT2JzZXJ2YWJsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5vYnNlcnZhYmxlIHx8ICdAQG9ic2VydmFibGUnO1xufSgpOyAvLyBUT0RPOiB0byBiZSByZW1vdmVkIGluIHY1LCBsZWZ0IGl0IG91dCBqdXN0IHRvIG1pbmltaXplIHRoZSBzY29wZSBvZiB0aGUgY2hhbmdlIGFuZCBtYWludGFpbiBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgaW50ZWdyYXRpb24gcGFhY2thZ2VzXG5cbnZhciBpbnRlcm9wU3ltYm9scyA9IChfYSA9IHt9LCBfYVtzeW1ib2xPYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59LCBfYVtTeW1ib2wub2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufSwgX2EpO1xuZnVuY3Rpb24gaXNNYWNoaW5lKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmICdfX3hzdGF0ZW5vZGUnIGluIHZhbHVlO1xufVxuZnVuY3Rpb24gaXNBY3Rvcih2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuc2VuZCA9PT0gJ2Z1bmN0aW9uJztcbn1cbnZhciB1bmlxdWVJZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBjdXJyZW50SWQgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGN1cnJlbnRJZCsrO1xuICAgIHJldHVybiBjdXJyZW50SWQudG9TdHJpbmcoMTYpO1xuICB9O1xufSgpO1xuZnVuY3Rpb24gdG9FdmVudE9iamVjdChldmVudCwgcGF5bG9hZCAvLyBpZD86IFRFdmVudFsndHlwZSddXG4pIHtcbiAgaWYgKGlzU3RyaW5nKGV2ZW50KSB8fCB0eXBlb2YgZXZlbnQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIF9fYXNzaWduKHtcbiAgICAgIHR5cGU6IGV2ZW50XG4gICAgfSwgcGF5bG9hZCk7XG4gIH1cblxuICByZXR1cm4gZXZlbnQ7XG59XG5mdW5jdGlvbiB0b1NDWE1MRXZlbnQoZXZlbnQsIHNjeG1sRXZlbnQpIHtcbiAgaWYgKCFpc1N0cmluZyhldmVudCkgJiYgJyQkdHlwZScgaW4gZXZlbnQgJiYgZXZlbnQuJCR0eXBlID09PSAnc2N4bWwnKSB7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgdmFyIGV2ZW50T2JqZWN0ID0gdG9FdmVudE9iamVjdChldmVudCk7XG4gIHJldHVybiBfX2Fzc2lnbih7XG4gICAgbmFtZTogZXZlbnRPYmplY3QudHlwZSxcbiAgICBkYXRhOiBldmVudE9iamVjdCxcbiAgICAkJHR5cGU6ICdzY3htbCcsXG4gICAgdHlwZTogJ2V4dGVybmFsJ1xuICB9LCBzY3htbEV2ZW50KTtcbn1cbmZ1bmN0aW9uIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KGV2ZW50LCBjb25maWdMaWtlKSB7XG4gIHZhciB0cmFuc2l0aW9ucyA9IHRvQXJyYXlTdHJpY3QoY29uZmlnTGlrZSkubWFwKGZ1bmN0aW9uICh0cmFuc2l0aW9uTGlrZSkge1xuICAgIGlmICh0eXBlb2YgdHJhbnNpdGlvbkxpa2UgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB0cmFuc2l0aW9uTGlrZSA9PT0gJ3N0cmluZycgfHwgaXNNYWNoaW5lKHRyYW5zaXRpb25MaWtlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiB0cmFuc2l0aW9uTGlrZSxcbiAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdHJhbnNpdGlvbkxpa2UpLCB7XG4gICAgICBldmVudDogZXZlbnRcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0cmFuc2l0aW9ucztcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gVEFSR0VUTEVTU19LRVkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHRvQXJyYXkodGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHJlcG9ydFVuaGFuZGxlZEV4Y2VwdGlvbk9uSW52b2NhdGlvbihvcmlnaW5hbEVycm9yLCBjdXJyZW50RXJyb3IsIGlkKSB7XG4gIGlmICghSVNfUFJPRFVDVElPTikge1xuICAgIHZhciBvcmlnaW5hbFN0YWNrVHJhY2UgPSBvcmlnaW5hbEVycm9yLnN0YWNrID8gXCIgU3RhY2t0cmFjZSB3YXMgJ1wiLmNvbmNhdChvcmlnaW5hbEVycm9yLnN0YWNrLCBcIidcIikgOiAnJztcblxuICAgIGlmIChvcmlnaW5hbEVycm9yID09PSBjdXJyZW50RXJyb3IpIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKFwiTWlzc2luZyBvbkVycm9yIGhhbmRsZXIgZm9yIGludm9jYXRpb24gJ1wiLmNvbmNhdChpZCwgXCInLCBlcnJvciB3YXMgJ1wiKS5jb25jYXQob3JpZ2luYWxFcnJvciwgXCInLlwiKS5jb25jYXQob3JpZ2luYWxTdGFja1RyYWNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFja1RyYWNlID0gY3VycmVudEVycm9yLnN0YWNrID8gXCIgU3RhY2t0cmFjZSB3YXMgJ1wiLmNvbmNhdChjdXJyZW50RXJyb3Iuc3RhY2ssIFwiJ1wiKSA6ICcnOyAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuXG4gICAgICBjb25zb2xlLmVycm9yKFwiTWlzc2luZyBvbkVycm9yIGhhbmRsZXIgYW5kL29yIHVuaGFuZGxlZCBleGNlcHRpb24vcHJvbWlzZSByZWplY3Rpb24gZm9yIGludm9jYXRpb24gJ1wiLmNvbmNhdChpZCwgXCInLiBcIikgKyBcIk9yaWdpbmFsIGVycm9yOiAnXCIuY29uY2F0KG9yaWdpbmFsRXJyb3IsIFwiJy4gXCIpLmNvbmNhdChvcmlnaW5hbFN0YWNrVHJhY2UsIFwiIEN1cnJlbnQgZXJyb3IgaXMgJ1wiKS5jb25jYXQoY3VycmVudEVycm9yLCBcIicuXCIpLmNvbmNhdChzdGFja1RyYWNlKSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBldmFsdWF0ZUd1YXJkKG1hY2hpbmUsIGd1YXJkLCBjb250ZXh0LCBfZXZlbnQsIHN0YXRlKSB7XG4gIHZhciBndWFyZHMgPSBtYWNoaW5lLm9wdGlvbnMuZ3VhcmRzO1xuICB2YXIgZ3VhcmRNZXRhID0ge1xuICAgIHN0YXRlOiBzdGF0ZSxcbiAgICBjb25kOiBndWFyZCxcbiAgICBfZXZlbnQ6IF9ldmVudFxuICB9OyAvLyBUT0RPOiBkbyBub3QgaGFyZGNvZGUhXG5cbiAgaWYgKGd1YXJkLnR5cGUgPT09IERFRkFVTFRfR1VBUkRfVFlQRSkge1xuICAgIHJldHVybiAoKGd1YXJkcyA9PT0gbnVsbCB8fCBndWFyZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGd1YXJkc1tndWFyZC5uYW1lXSkgfHwgZ3VhcmQucHJlZGljYXRlKShjb250ZXh0LCBfZXZlbnQuZGF0YSwgZ3VhcmRNZXRhKTtcbiAgfVxuXG4gIHZhciBjb25kRm4gPSBndWFyZHMgPT09IG51bGwgfHwgZ3VhcmRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBndWFyZHNbZ3VhcmQudHlwZV07XG5cbiAgaWYgKCFjb25kRm4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJHdWFyZCAnXCIuY29uY2F0KGd1YXJkLnR5cGUsIFwiJyBpcyBub3QgaW1wbGVtZW50ZWQgb24gbWFjaGluZSAnXCIpLmNvbmNhdChtYWNoaW5lLmlkLCBcIicuXCIpKTtcbiAgfVxuXG4gIHJldHVybiBjb25kRm4oY29udGV4dCwgX2V2ZW50LmRhdGEsIGd1YXJkTWV0YSk7XG59XG5mdW5jdGlvbiB0b0ludm9rZVNvdXJjZShzcmMpIHtcbiAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHNyY1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gc3JjO1xufVxuZnVuY3Rpb24gdG9PYnNlcnZlcihuZXh0SGFuZGxlciwgZXJyb3JIYW5kbGVyLCBjb21wbGV0aW9uSGFuZGxlcikge1xuICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIHZhciBpc09ic2VydmVyID0gdHlwZW9mIG5leHRIYW5kbGVyID09PSAnb2JqZWN0JztcbiAgdmFyIHNlbGYgPSBpc09ic2VydmVyID8gbmV4dEhhbmRsZXIgOiBudWxsO1xuICByZXR1cm4ge1xuICAgIG5leHQ6ICgoaXNPYnNlcnZlciA/IG5leHRIYW5kbGVyLm5leHQgOiBuZXh0SGFuZGxlcikgfHwgbm9vcCkuYmluZChzZWxmKSxcbiAgICBlcnJvcjogKChpc09ic2VydmVyID8gbmV4dEhhbmRsZXIuZXJyb3IgOiBlcnJvckhhbmRsZXIpIHx8IG5vb3ApLmJpbmQoc2VsZiksXG4gICAgY29tcGxldGU6ICgoaXNPYnNlcnZlciA/IG5leHRIYW5kbGVyLmNvbXBsZXRlIDogY29tcGxldGlvbkhhbmRsZXIpIHx8IG5vb3ApLmJpbmQoc2VsZilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludm9rZUlkKHN0YXRlTm9kZUlkLCBpbmRleCkge1xuICByZXR1cm4gXCJcIi5jb25jYXQoc3RhdGVOb2RlSWQsIFwiOmludm9jYXRpb25bXCIpLmNvbmNhdChpbmRleCwgXCJdXCIpO1xufVxuZnVuY3Rpb24gaXNSYWlzYWJsZUFjdGlvbihhY3Rpb24pIHtcbiAgcmV0dXJuIChhY3Rpb24udHlwZSA9PT0gcmFpc2UgfHwgYWN0aW9uLnR5cGUgPT09IHNlbmQgJiYgYWN0aW9uLnRvID09PSBTcGVjaWFsVGFyZ2V0cy5JbnRlcm5hbCkgJiYgdHlwZW9mIGFjdGlvbi5kZWxheSAhPT0gJ251bWJlcic7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUludm9rZUlkLCBldmFsdWF0ZUd1YXJkLCBmbGF0dGVuLCBnZXRBY3Rpb25UeXBlLCBnZXRFdmVudFR5cGUsIGludGVyb3BTeW1ib2xzLCBpc0FjdG9yLCBpc0FycmF5LCBpc0JlaGF2aW9yLCBpc0J1aWx0SW5FdmVudCwgaXNGdW5jdGlvbiwgaXNNYWNoaW5lLCBpc09ic2VydmFibGUsIGlzUHJvbWlzZUxpa2UsIGlzUmFpc2FibGVBY3Rpb24sIGlzU3RhdGVMaWtlLCBpc1N0cmluZywga2V5cywgbWFwQ29udGV4dCwgbWFwRmlsdGVyVmFsdWVzLCBtYXBWYWx1ZXMsIG1hdGNoZXNTdGF0ZSwgbmVzdGVkUGF0aCwgbm9ybWFsaXplVGFyZ2V0LCBwYXJ0aXRpb24sIHBhdGgsIHBhdGhUb1N0YXRlVmFsdWUsIHBhdGhzVG9TdGF0ZVZhbHVlLCByZXBvcnRVbmhhbmRsZWRFeGNlcHRpb25Pbkludm9jYXRpb24sIHN5bWJvbE9ic2VydmFibGUsIHRvQXJyYXksIHRvQXJyYXlTdHJpY3QsIHRvRXZlbnRPYmplY3QsIHRvR3VhcmQsIHRvSW52b2tlU291cmNlLCB0b09ic2VydmVyLCB0b1NDWE1MRXZlbnQsIHRvU3RhdGVQYXRoLCB0b1N0YXRlUGF0aHMsIHRvU3RhdGVWYWx1ZSwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXksIHVuaXF1ZUlkLCB1cGRhdGVDb250ZXh0LCB1cGRhdGVIaXN0b3J5U3RhdGVzLCB1cGRhdGVIaXN0b3J5VmFsdWUsIHdhcm4gfTtcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbk1vZHVsZSB7XG4gIHN0YXRpYyByZWN0YW5nbGVzU2VsZWN0b3IgPVxuICAgIFwiLm91dGVybW9zdCwgLnNlY29uZCwgLnRoaXJkLCAuZm91cnRoLCAuZmlmdGgsIC5pbm5lcm1vc3RcIjtcbiAgc3RhdGljIHRhbGtCdXR0b25BbmltYXRpb25zID0gW1wicGlTcGVha2luZ1wiLCBcInVzZXJTcGVha2luZ1wiLCBcInRyYW5zY3JpYmluZ1wiXTtcblxuICBzdGF0aWMgc3RhcnRBbmltYXRpb24oYW5pbWF0aW9uKSB7XG4gICAgdGhpcy5zdG9wT3RoZXJBbmltYXRpb25zKGFuaW1hdGlvbik7XG5cbiAgICBsZXQgcmVjdGFuZ2xlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5yZWN0YW5nbGVzU2VsZWN0b3IpO1xuICAgIHJlY3RhbmdsZXMuZm9yRWFjaCgocmVjdCkgPT4gcmVjdC5jbGFzc0xpc3QuYWRkKGFuaW1hdGlvbikpO1xuICB9XG5cbiAgc3RhdGljIHN0b3BBbmltYXRpb24oYW5pbWF0aW9uKSB7XG4gICAgbGV0IHJlY3RhbmdsZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMucmVjdGFuZ2xlc1NlbGVjdG9yKTtcbiAgICByZWN0YW5nbGVzLmZvckVhY2goKHJlY3QpID0+IHJlY3QuY2xhc3NMaXN0LnJlbW92ZShhbmltYXRpb24pKTtcbiAgfVxuXG4gIHN0YXRpYyBzdG9wQWxsQW5pbWF0aW9ucygpIHtcbiAgICB0aGlzLnRhbGtCdXR0b25BbmltYXRpb25zLmZvckVhY2goKGFuaW1hdGlvbikgPT5cbiAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbihhbmltYXRpb24pXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBzdG9wT3RoZXJBbmltYXRpb25zKGtlZXBBbmltYXRpb24pIHtcbiAgICB0aGlzLnRhbGtCdXR0b25BbmltYXRpb25zLmZvckVhY2goKGFuaW1hdGlvbikgPT4ge1xuICAgICAgaWYgKGFuaW1hdGlvbiAhPT0ga2VlcEFuaW1hdGlvbikge1xuICAgICAgICB0aGlzLnN0b3BBbmltYXRpb24oYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLy8gaW1wb3J0IHN0YXRlIG1hY2hpbmVzIGZvciBhdWRpbyBpbnB1dCBhbmQgb3V0cHV0XG5pbXBvcnQgeyBpbnRlcnByZXQgfSBmcm9tIFwieHN0YXRlXCI7XG5pbXBvcnQgeyBhdWRpb0lucHV0TWFjaGluZSB9IGZyb20gXCIuL3N0YXRlLW1hY2hpbmVzL0F1ZGlvSW5wdXRNYWNoaW5lLnRzXCI7XG5pbXBvcnQgeyBhdWRpb091dHB1dE1hY2hpbmUgfSBmcm9tIFwiLi9zdGF0ZS1tYWNoaW5lcy9BdWRpb091dHB1dE1hY2hpbmUuanNcIjtcbmltcG9ydCB7IGxvZ2dlciwgc2VyaWFsaXplU3RhdGVWYWx1ZSB9IGZyb20gXCIuL0xvZ2dpbmdNb2R1bGUuanNcIjtcbmltcG9ydCBFdmVudEJ1cyBmcm9tIFwiLi9FdmVudEJ1cy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdWRpb01vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYXVkaW9FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImF1ZGlvXCIpO1xuICAgIGlmICghdGhpcy5hdWRpb0VsZW1lbnQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBdWRpbyBlbGVtZW50IG5vdCBmb3VuZCFcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXVkaW9FbGVtZW50LnByZWxvYWQgPSBcImF1dG9cIjsgLy8gZW5hYmxlIGFnZ3Jlc3NpdmUgcHJlbG9hZGluZyBvZiBhdWRpb1xuICAgIH1cblxuICAgIHRoaXMuYXVkaW9PdXRwdXRBY3RvciA9IGludGVycHJldChhdWRpb091dHB1dE1hY2hpbmUpO1xuICAgIHRoaXMuYXVkaW9PdXRwdXRBY3Rvci5vblRyYW5zaXRpb24oKHN0YXRlKSA9PiB7XG4gICAgICBpZiAoc3RhdGUuY2hhbmdlZCkge1xuICAgICAgICBjb25zdCBmcm9tU3RhdGUgPSBzdGF0ZS5oaXN0b3J5XG4gICAgICAgICAgPyBzZXJpYWxpemVTdGF0ZVZhbHVlKHN0YXRlLmhpc3RvcnkudmFsdWUpXG4gICAgICAgICAgOiBcIk4vQVwiO1xuICAgICAgICBjb25zdCB0b1N0YXRlID0gc2VyaWFsaXplU3RhdGVWYWx1ZShzdGF0ZS52YWx1ZSk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICBgQXVkaW8gT3V0cHV0IE1hY2hpbmUgdHJhbnNpdGlvbmVkIGZyb20gJHtmcm9tU3RhdGV9IHRvICR7dG9TdGF0ZX0gd2l0aCAke3N0YXRlLmV2ZW50LnR5cGV9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5hdWRpb0lucHV0QWN0b3IgPSBpbnRlcnByZXQoYXVkaW9JbnB1dE1hY2hpbmUpO1xuICAgIHRoaXMuYXVkaW9JbnB1dEFjdG9yLm9uVHJhbnNpdGlvbigoc3RhdGUpID0+IHtcbiAgICAgIGlmIChzdGF0ZS5jaGFuZ2VkKSB7XG4gICAgICAgIGNvbnN0IGZyb21TdGF0ZSA9IHN0YXRlLmhpc3RvcnlcbiAgICAgICAgICA/IHNlcmlhbGl6ZVN0YXRlVmFsdWUoc3RhdGUuaGlzdG9yeS52YWx1ZSlcbiAgICAgICAgICA6IFwiTi9BXCI7XG4gICAgICAgIGNvbnN0IHRvU3RhdGUgPSBzZXJpYWxpemVTdGF0ZVZhbHVlKHN0YXRlLnZhbHVlKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgICAgIGBBdWRpbyBJbnB1dCBNYWNoaW5lIHRyYW5zaXRpb25lZCBmcm9tICR7ZnJvbVN0YXRlfSB0byAke3RvU3RhdGV9IHdpdGggJHtzdGF0ZS5ldmVudC50eXBlfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIC8vIGF1ZGlvIG91dHB1dCAoUGkpXG4gICAgdGhpcy5hdWRpb091dHB1dEFjdG9yLnN0YXJ0KCk7XG4gICAgdGhpcy5yZWdpc3RlckF1ZGlvUGxheWJhY2tFdmVudHModGhpcy5hdWRpb0VsZW1lbnQsIHRoaXMuYXVkaW9PdXRwdXRBY3Rvcik7XG5cbiAgICAvLyBhdWRpbyBpbnB1dCAodXNlcilcbiAgICB0aGlzLmF1ZGlvSW5wdXRBY3Rvci5zdGFydCgpO1xuICAgIHRoaXMucmVnaXN0ZXJBdWRpb0NvbW1hbmRzKHRoaXMuYXVkaW9JbnB1dEFjdG9yLCB0aGlzLmF1ZGlvT3V0cHV0QWN0b3IpO1xuICB9XG5cbiAgcmVnaXN0ZXJBdWRpb1BsYXliYWNrRXZlbnRzKGF1ZGlvLCBhY3Rvcikge1xuICAgIGNvbnN0IGV2ZW50cyA9IFtcbiAgICAgIFwibG9hZHN0YXJ0XCIsXG4gICAgICBcImxvYWRlZG1ldGFkYXRhXCIsXG4gICAgICBcImNhbnBsYXl0aHJvdWdoXCIsXG4gICAgICBcInBsYXlcIixcbiAgICAgIFwicGF1c2VcIixcbiAgICAgIFwiZW5kZWRcIixcbiAgICAgIFwic2Vla2VkXCIsXG4gICAgICBcImVtcHRpZWRcIixcbiAgICBdO1xuXG4gICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCAoKSA9PiBhY3Rvci5zZW5kKGV2ZW50KSk7XG4gICAgfSk7XG5cbiAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKFwicGxheWluZ1wiLCAoKSA9PiB7XG4gICAgICBhY3Rvci5zZW5kKFwicGxheVwiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qIFRoZXNlIGV2ZW50cyBhcmUgdXNlZCB0byBjb250cm9sL3Bhc3MgcmVxdWVzdHMgdG8gdGhlIGF1ZGlvIG1vZHVsZSBmcm9tIG90aGVyIG1vZHVsZXMgKi9cbiAgcmVnaXN0ZXJBdWRpb0NvbW1hbmRzKGlucHV0QWN0b3IsIG91dHB1dEFjdG9yKSB7XG4gICAgLy8gYXVkaW8gaW5wdXQgKHJlY29yZGluZykgY29tbWFuZHNcbiAgICBFdmVudEJ1cy5vbihcImF1ZGlvOnNldHVwUmVjb3JkaW5nXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpbnB1dEFjdG9yLnNlbmQoXCJhY3F1aXJlXCIpO1xuICAgIH0pO1xuXG4gICAgRXZlbnRCdXMub24oXCJhdWRpbzp0ZWFyRG93blJlY29yZGluZ1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaW5wdXRBY3Rvci5zZW5kKFwicmVsZWFzZVwiKTtcbiAgICB9KTtcblxuICAgIEV2ZW50QnVzLm9uKFwiYXVkaW86c3RhcnRSZWNvcmRpbmdcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIENoZWNrIGlmIFBpIGlzIGN1cnJlbnRseSBzcGVha2luZyBhbmQgc3RvcCBoZXIgYXVkaW9cbiAgICAgIG91dHB1dEFjdG9yLnNlbmQoXCJwYXVzZVwiKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG1pY3JvcGhvbmUgaXMgYWNxdWlyZWQgYmVmb3JlIHN0YXJ0aW5nP1xuICAgICAgaW5wdXRBY3Rvci5zZW5kKFtcImFjcXVpcmVcIiwgXCJzdGFydFwiXSk7XG4gICAgfSk7XG4gICAgRXZlbnRCdXMub24oXCJhdWRpbzpzdG9wUmVjb3JkaW5nXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpbnB1dEFjdG9yLnNlbmQoXCJzdG9wUmVxdWVzdGVkXCIpO1xuICAgICAgLyogcmVzdW1lIG9yIGNhbmNlbCBQaSdzIGF1ZGlvICovXG4gICAgICAvKiBUT0RPOiByZWFzc2VzcyBob3cgdG8gaGFuZGxlIGludGVycnVwdGlvbnNcbiAgICAgIG91dHB1dEFjdG9yLnNlbmQoXCJwbGF5XCIpOyAvLyByZXN1bWUgUGkncyBhdWRpb1xuICAgICAgb3V0cHV0QWN0b3Iuc2VuZChcInN0b3BcIik7IC8vIGNhbmNlbCBQaSdzIGF1ZGlvXG4gICAgICAqL1xuICAgIH0pO1xuICAgIC8vIGF1ZGlvIGlucHV0IChyZWNvcmRpbmcpIGV2ZW50cyAocGFzcyBtZWRpYSByZWNvcmRlciBldmVudHMgLT4gYXVkaW8gaW5wdXQgbWFjaGluZSBhY3RvcilcbiAgICBFdmVudEJ1cy5vbihcImF1ZGlvOmRhdGFhdmFpbGFibGVcIiwgKGRldGFpbCkgPT4ge1xuICAgICAgaW5wdXRBY3Rvci5zZW5kKHsgdHlwZTogXCJkYXRhQXZhaWxhYmxlXCIsIC4uLmRldGFpbCB9KTtcbiAgICB9KTtcbiAgICBFdmVudEJ1cy5vbihcImF1ZGlvOmlucHV0OnN0b3BcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlucHV0QWN0b3Iuc2VuZChcInN0b3BcIik7XG4gICAgfSk7XG5cbiAgICAvLyBhdWRpbyBvdXRwdXQgKHBsYXliYWNrKSBjb21tYW5kc1xuICAgIEV2ZW50QnVzLm9uKFwiYXVkaW86cmVsb2FkXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBvdXRwdXRBY3Rvci5zZW5kKFwicmVsb2FkXCIpO1xuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBlbnRlck1vYmlsZU1vZGUsXG4gIGV4aXRNb2JpbGVNb2RlLFxuICBpc01vYmlsZVZpZXcsXG59IGZyb20gXCIuL1VzZXJBZ2VudE1vZHVsZS5qc1wiO1xuaW1wb3J0IHsgYXBwZW5kQ2hpbGQgfSBmcm9tIFwiLi9ET01Nb2R1bGUudHNcIjtcbmltcG9ydCBFdmVudEJ1cyBmcm9tIFwiLi9FdmVudEJ1cy5qc1wiO1xuaW1wb3J0IFN0YXRlTWFjaGluZVNlcnZpY2UgZnJvbSBcIi4vU3RhdGVNYWNoaW5lU2VydmljZS5qc1wiO1xuaW1wb3J0IHsgc3VibWl0RXJyb3JIYW5kbGVyIH0gZnJvbSBcIi4vU3VibWl0RXJyb3JIYW5kbGVyLnRzXCI7XG5pbXBvcnQgZXhpdEljb25TVkcgZnJvbSBcIi4vaWNvbnMvZXhpdC5zdmdcIjtcbmltcG9ydCBtYXhpbWl6ZUljb25TVkcgZnJvbSBcIi4vaWNvbnMvbWF4aW1pemUuc3ZnXCI7XG5pbXBvcnQgcmVjdGFuZ2xlc1NWRyBmcm9tIFwiLi9pY29ucy9yZWN0YW5nbGVzLnN2Z1wiO1xuaW1wb3J0IHRhbGtJY29uU1ZHIGZyb20gXCIuL2ljb25zL3dhdmVmb3JtLnN2Z1wiO1xuaW1wb3J0IG11dGVkTWljSWNvblNWRyBmcm9tIFwiLi9pY29ucy9tdXRlZF9taWNyb3Bob25lLnN2Z1wiO1xuaW1wb3J0IGNhbGxJY29uU1ZHIGZyb20gXCIuL2ljb25zL2NhbGwuc3ZnXCI7XG5pbXBvcnQgaGFuZ3VwSWNvblNWRyBmcm9tIFwiLi9pY29ucy9oYW5ndXAuc3ZnXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b25Nb2R1bGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmFjdG9yID0gU3RhdGVNYWNoaW5lU2VydmljZS5hY3RvcjtcbiAgICAvLyBCaW5kaW5nIG1ldGhvZHMgdG8gdGhlIGN1cnJlbnQgaW5zdGFuY2VcbiAgICB0aGlzLnJlZ2lzdGVyT3RoZXJFdmVudHMoKTtcblxuICAgIC8vIHRyYWNrIHRoZSBmcmVxdWVuY3kgb2YgYnVnICMyNlxuICAgIHRoaXMuc3VibWlzc2lvbnNXaXRob3V0QW5FcnJvciA9IDA7XG4gIH1cblxuICByZWdpc3Rlck90aGVyRXZlbnRzKCkge1xuICAgIEV2ZW50QnVzLm9uKFwic2F5cGk6YXV0b1N1Ym1pdFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZUF1dG9TdWJtaXQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG5ldyBidXR0b25cbiAgY3JlYXRlQnV0dG9uKGxhYmVsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICBidXR0b24udGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBidXR0b24ub25jbGljayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICByZXR1cm4gYnV0dG9uO1xuICB9XG5cbiAgLy8gRnVuY3Rpb24gdG8gc3R5bGUgYSBnaXZlbiBidXR0b25cbiAgc3R5bGVCdXR0b24oYnV0dG9uLCBzdHlsZXMpIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgYnV0dG9uLnN0eWxlW2tleV0gPSBzdHlsZXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhZGRUYWxrSWNvbihidXR0b24pIHtcbiAgICB0aGlzLnVwZGF0ZUljb25Db250ZW50KGJ1dHRvbik7XG5cbiAgICB3aW5kb3cubWF0Y2hNZWRpYShcIihtYXgtd2lkdGg6IDc2OHB4KVwiKS5hZGRMaXN0ZW5lcigoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZUljb25Db250ZW50KGJ1dHRvbik7XG4gICAgfSk7XG4gICAgdGhpcy5zZXR1cENsYXNzT2JzZXJ2ZXIoYnV0dG9uKTtcbiAgfVxuXG4gIHVwZGF0ZUljb25Db250ZW50KGljb25Db250YWluZXIpIHtcbiAgICBpZiAoaXNNb2JpbGVWaWV3KCkpIHtcbiAgICAgIGljb25Db250YWluZXIuaW5uZXJIVE1MID0gcmVjdGFuZ2xlc1NWRztcbiAgICB9IGVsc2Uge1xuICAgICAgaWNvbkNvbnRhaW5lci5pbm5lckhUTUwgPSB0YWxrSWNvblNWRztcbiAgICB9XG4gIH1cblxuICBzZXR1cENsYXNzT2JzZXJ2ZXIoYnV0dG9uKSB7XG4gICAgY29uc3QgdGFyZ2V0Tm9kZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsgLy8gVGhlIDxodG1sPiBlbGVtZW50XG5cbiAgICBjb25zdCBjb25maWcgPSB7IGF0dHJpYnV0ZXM6IHRydWUsIGF0dHJpYnV0ZUZpbHRlcjogW1wiY2xhc3NcIl0gfTtcblxuICAgIGNvbnN0IGNhbGxiYWNrID0gKG11dGF0aW9uc0xpc3QsIG9ic2VydmVyKSA9PiB7XG4gICAgICBmb3IgKGxldCBtdXRhdGlvbiBvZiBtdXRhdGlvbnNMaXN0KSB7XG4gICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSBcImF0dHJpYnV0ZXNcIikge1xuICAgICAgICAgIGlmIChtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lID09PSBcImNsYXNzXCIpIHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwibW9iaWxlLXZpZXdcIikpIHtcbiAgICAgICAgICAgICAgLy8gJ21vYmlsZS12aWV3JyBjbGFzcyB3YXMgYWRkZWRcbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVJY29uQ29udGVudChidXR0b24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gJ21vYmlsZS12aWV3JyBjbGFzcyB3YXMgcmVtb3ZlZFxuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUljb25Db250ZW50KGJ1dHRvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spO1xuXG4gICAgLy8gU3RhcnQgb2JzZXJ2aW5nIHRoZSB0YXJnZXQgbm9kZSBmb3IgY29uZmlndXJlZCBtdXRhdGlvbnNcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRhcmdldE5vZGUsIGNvbmZpZyk7XG5cbiAgICAvLyBMYXRlciwgeW91IGNhbiBzdG9wIG9ic2VydmluZyBieSBjYWxsaW5nOlxuICAgIC8vIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuXG4gIC8vIFNpbXVsYXRlIGFuIFwiRW50ZXJcIiBrZXlwcmVzcyBldmVudCBvbiBhIGZvcm1cbiAgc2ltdWxhdGVGb3JtU3VibWl0KCkge1xuICAgIGNvbnN0IHN1Ym1pdEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2F5cGktc3VibWl0QnV0dG9uXCIpO1xuXG4gICAgaWYgKHN1Ym1pdEJ1dHRvbikge1xuICAgICAgaWYgKHN1Ym1pdEVycm9ySGFuZGxlci5kZXRlY3RTdWJtaXRFcnJvcigpKSB7XG4gICAgICAgIC8vIHRyYWNrIGhvdyBvZnRlbiB0aGlzIGhhcHBlbnNcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgQXV0b3N1Ym1pdCBmYWlsZWQgYWZ0ZXIgJHt0aGlzLnN1Ym1pc3Npb25zV2l0aG91dEFuRXJyb3J9IHR1cm5zLmBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zdWJtaXNzaW9uc1dpdGhvdXRBbkVycm9yID0gMDtcbiAgICAgICAgc3VibWl0RXJyb3JIYW5kbGVyLmhhbmRsZVN1Ym1pdEVycm9yKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN1Ym1pc3Npb25zV2l0aG91dEFuRXJyb3IrKztcbiAgICAgICAgc3VibWl0QnV0dG9uLmNsaWNrKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGhpdCBlbnRlciBrZXkgaW4gdGhlIHByb21wdCB0ZXh0YXJlYSwgbWlnaHQgbm90IHdvcmsgYXMgZXhwZWN0ZWQgb24gXCJuZXcgdWkgbGF5b3V0XCIgKi9cbiAgICAgIGNvbnN0IHRleHRhcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzYXlwaS1wcm9tcHRcIik7XG5cbiAgICAgIGNvbnN0IGVudGVyRXZlbnQgPSBuZXcgS2V5Ym9hcmRFdmVudChcImtleWRvd25cIiwge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBrZXk6IFwiRW50ZXJcIixcbiAgICAgICAga2V5Q29kZTogMTMsXG4gICAgICAgIHdoaWNoOiAxMyxcbiAgICAgIH0pO1xuXG4gICAgICB0ZXh0YXJlYS5kaXNwYXRjaEV2ZW50KGVudGVyRXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZ1bmN0aW9uIHRvIGhhbmRsZSBhdXRvLXN1Ym1pdCBiYXNlZCBvbiB0aGUgYnV0dG9uJ3MgZGF0YSBhdHRyaWJ1dGVcbiAgaGFuZGxlQXV0b1N1Ym1pdCgpIHtcbiAgICBjb25zdCB0YWxrQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzYXlwaS10YWxrQnV0dG9uXCIpO1xuXG4gICAgaWYgKHRhbGtCdXR0b24uZGF0YXNldC5hdXRvc3VibWl0ID09PSBcImZhbHNlXCIpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiQXV0b3N1Ym1pdCBpcyBvZmZcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2ltdWxhdGVGb3JtU3VibWl0KCk7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlRXhpdEJ1dHRvbigpIHtcbiAgICBjb25zdCBsYWJlbCA9IFwiRXhpdCBWb2ljZS1Db250cm9sbGVkIE1vYmlsZSBNb2RlXCI7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy5jcmVhdGVCdXR0b24oXCJcIiwgKCkgPT4ge1xuICAgICAgZXhpdE1vYmlsZU1vZGUoKTtcbiAgICB9KTtcbiAgICBidXR0b24uaWQgPSBcInNheXBpLWV4aXRCdXR0b25cIjtcbiAgICBidXR0b24udHlwZSA9IFwiYnV0dG9uXCI7XG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9XG4gICAgICBcImV4aXQtYnV0dG9uIGZpeGVkIHJvdW5kZWQtZnVsbCBiZy1jcmVhbS01NTAgZW5hYmxlZDpob3ZlcjpiZy1jcmVhbS02NTBcIjtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBsYWJlbCk7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIGxhYmVsKTtcbiAgICBidXR0b24uaW5uZXJIVE1MID0gZXhpdEljb25TVkc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgIHJldHVybiBidXR0b247XG4gIH1cblxuICBjcmVhdGVFbnRlckJ1dHRvbigpIHtcbiAgICBjb25zdCBsYWJlbCA9IFwiRW50ZXIgVm9pY2UtQ29udHJvbGxlZCBNb2JpbGUgTW9kZVwiO1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuY3JlYXRlQnV0dG9uKFwiXCIsICgpID0+IHtcbiAgICAgIGVudGVyTW9iaWxlTW9kZSgpO1xuICAgIH0pO1xuICAgIGJ1dHRvbi5pZCA9IFwic2F5cGktZW50ZXJCdXR0b25cIjtcbiAgICBidXR0b24udHlwZSA9IFwiYnV0dG9uXCI7XG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9XG4gICAgICBcImVudGVyLWJ1dHRvbiBmaXhlZCByb3VuZGVkLWZ1bGwgYmctY3JlYW0tNTUwIGVuYWJsZWQ6aG92ZXI6YmctY3JlYW0tNjUwXCI7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbGFiZWwpO1xuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCBsYWJlbCk7XG4gICAgYnV0dG9uLmlubmVySFRNTCA9IG1heGltaXplSWNvblNWRztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgcmV0dXJuIGJ1dHRvbjtcbiAgfVxuXG4gIHNob3dOb3RpZmljYXRpb24oZGV0YWlscykge1xuICAgIGNvbnN0IGljb24gPSBkZXRhaWxzLmljb247XG4gICAgbGV0IGljb25TVkc7XG4gICAgaWYgKGljb24gPT09IFwibXV0ZWQtbWljcm9waG9uZVwiKSB7XG4gICAgICBpY29uU1ZHID0gbXV0ZWRNaWNJY29uU1ZHO1xuICAgIH1cblxuICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2F5cGktbm90aWZpY2F0aW9uXCIpO1xuICAgIGlmIChub3RpZmljYXRpb24pIHtcbiAgICAgIG5vdGlmaWNhdGlvbi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgICAgbm90aWZpY2F0aW9uLmlubmVySFRNTCA9IGljb25TVkc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBub3RpZmljYXRpb24uaWQgPSBcInNheXBpLW5vdGlmaWNhdGlvblwiO1xuICAgICAgbm90aWZpY2F0aW9uLmNsYXNzTmFtZSA9IFwibm90aWZpY2F0aW9uXCI7XG4gICAgICBub3RpZmljYXRpb24uaW5uZXJIVE1MID0gaWNvblNWRztcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm90aWZpY2F0aW9uKTtcbiAgICB9XG4gIH1cblxuICBkaXNtaXNzTm90aWZpY2F0aW9uKCkge1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2F5cGktbm90aWZpY2F0aW9uXCIpO1xuICAgIGlmIChub3RpZmljYXRpb24pIHtcbiAgICAgIG5vdGlmaWNhdGlvbi5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZUNhbGxCdXR0b24oY29udGFpbmVyLCBwb3NpdGlvbiA9IDApIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLmNyZWF0ZUJ1dHRvbigpO1xuICAgIGJ1dHRvbi5pZCA9IFwic2F5cGktY2FsbEJ1dHRvblwiO1xuICAgIGJ1dHRvbi50eXBlID0gXCJidXR0b25cIjtcbiAgICBidXR0b24uY2xhc3NOYW1lID1cbiAgICAgIFwiY2FsbC1idXR0b24gZml4ZWQgcm91bmRlZC1mdWxsIGJnLWNyZWFtLTU1MCBlbmFibGVkOmhvdmVyOmJnLWNyZWFtLTY1MFwiO1xuICAgIHRoaXMuY2FsbEluYWN0aXZlKGJ1dHRvbik7IC8vIG1pYyBpcyBvZmYgYnkgZGVmYXVsdFxuXG4gICAgYXBwZW5kQ2hpbGQoY29udGFpbmVyLCBidXR0b24sIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gYnV0dG9uO1xuICB9XG5cbiAgY2FsbEFjdGl2ZShjYWxsQnV0dG9uKSB7XG4gICAgaWYgKCFjYWxsQnV0dG9uKSB7XG4gICAgICBjYWxsQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzYXlwaS1jYWxsQnV0dG9uXCIpO1xuICAgIH1cbiAgICBpZiAoY2FsbEJ1dHRvbikge1xuICAgICAgY29uc3QgbGFiZWwgPSBcIkFjdGl2ZSBjb250aW51b3VzIGxpc3RlbmluZy4gQ2xpY2sgdG8gc3RvcC5cIjtcbiAgICAgIGNhbGxCdXR0b24uaW5uZXJIVE1MID0gaGFuZ3VwSWNvblNWRztcbiAgICAgIGNhbGxCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBsYWJlbCk7XG4gICAgICBjYWxsQnV0dG9uLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIGxhYmVsKTtcbiAgICAgIGNhbGxCdXR0b24ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5hY3Rvci5zZW5kKFwic2F5cGk6aGFuZ3VwXCIpO1xuICAgICAgfTtcbiAgICAgIGNhbGxCdXR0b24uY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKTtcbiAgICB9XG4gIH1cblxuICBjYWxsSW5hY3RpdmUoY2FsbEJ1dHRvbikge1xuICAgIGlmICghY2FsbEJ1dHRvbikge1xuICAgICAgY2FsbEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2F5cGktY2FsbEJ1dHRvblwiKTtcbiAgICB9XG4gICAgaWYgKGNhbGxCdXR0b24pIHtcbiAgICAgIGNhbGxCdXR0b24uaW5uZXJIVE1MID0gY2FsbEljb25TVkc7XG4gICAgICBjYWxsQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICAgIFwiQ2xpY2sgdG8gc3RhcnQgY29udGludW91cyBsaXN0ZW5pbmcuXCJcbiAgICAgICk7XG4gICAgICBjYWxsQnV0dG9uLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIFwiTm90IGxpc3RlbmluZy4gQ2xpY2sgdG8gc3RhcnQuXCIpO1xuICAgICAgY2FsbEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmFjdG9yLnNlbmQoXCJzYXlwaTpjYWxsXCIpO1xuICAgICAgfTtcbiAgICAgIGNhbGxCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlQ2FsbEJ1dHRvbigpIHtcbiAgICBjb25zdCBjYWxsQnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzYXlwaS1jYWxsQnV0dG9uXCIpO1xuICAgIGlmIChjYWxsQnV0dG9uKSB7XG4gICAgICBjYWxsQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJkaXNhYmxlZFwiKTtcbiAgICAgIC8vIGRpc2FibGUgdGhlIGNhbGwgYWN0aW9uLCBidXQgYWx3YXlzIGFsbG93IGhhbmd1cFxuICAgICAgaWYgKCFjYWxsQnV0dG9uLmNsYXNzTGlzdC5jb250YWlucyhcImFjdGl2ZVwiKSkge1xuICAgICAgICBjYWxsQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbmFibGVDYWxsQnV0dG9uKCkge1xuICAgIGNvbnN0IGNhbGxCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNheXBpLWNhbGxCdXR0b25cIik7XG4gICAgaWYgKGNhbGxCdXR0b24pIHtcbiAgICAgIGNhbGxCdXR0b24uY2xhc3NMaXN0LnJlbW92ZShcImRpc2FibGVkXCIpO1xuICAgICAgY2FsbEJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBTaW5nbGV0b25cbmV4cG9ydCBjb25zdCBidXR0b25Nb2R1bGUgPSBuZXcgQnV0dG9uTW9kdWxlKCk7XG4iLCJleHBvcnQgY29uc3QgY29uZmlnID0ge1xuICBhcHBTZXJ2ZXJVcmw6IHByb2Nlc3MuZW52LkFQUF9TRVJWRVJfVVJMLFxuICBhcGlTZXJ2ZXJVcmw6IHByb2Nlc3MuZW52LkFQSV9TRVJWRVJfVVJMLFxufTtcbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcImV2ZW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgRXZlbnRFbWl0dGVyKCk7XG4iLCJpbXBvcnQgRXZlbnRCdXMgZnJvbSBcIi4vRXZlbnRCdXMuanNcIjtcbmltcG9ydCBTdGF0ZU1hY2hpbmVTZXJ2aWNlIGZyb20gXCIuL1N0YXRlTWFjaGluZVNlcnZpY2UuanNcIjtcblxuY29uc3QgVVNFUl9TUEVBS0lORyA9IFwic2F5cGk6dXNlclNwZWFraW5nXCI7XG5jb25zdCBVU0VSX1NUT1BQRURfU1BFQUtJTkcgPSBcInNheXBpOnVzZXJTdG9wcGVkU3BlYWtpbmdcIjtcbmNvbnN0IFVTRVJfRklOSVNIRURfU1BFQUtJTkcgPSBcInNheXBpOnVzZXJGaW5pc2hlZFNwZWFraW5nXCI7XG5jb25zdCBQSV9TUEVBS0lORyA9IFwic2F5cGk6cGlTcGVha2luZ1wiO1xuY29uc3QgUElfU1RPUFBFRF9TUEVBS0lORyA9IFwic2F5cGk6cGlTdG9wcGVkU3BlYWtpbmdcIjtcbmNvbnN0IFBJX0ZJTklTSEVEX1NQRUFLSU5HID0gXCJzYXlwaTpwaUZpbmlzaGVkU3BlYWtpbmdcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRNb2R1bGUge1xuICBzdGF0aWMgaW5pdCgpIHtcbiAgICAvLyBBbGwgdGhlIGV2ZW50IGxpc3RlbmVycyBjYW4gYmUgYWRkZWQgaGVyZVxuICAgIHRoaXMucmVnaXN0ZXJTdGF0ZU1hY2hpbmVFdmVudHMoU3RhdGVNYWNoaW5lU2VydmljZS5hY3Rvcik7XG4gICAgLy8gQW55IG90aGVyIGluaXRpYWxpemF0aW9ucy4uLlxuICB9XG5cbiAgc3RhdGljIGNsZWFudXAoKSB7XG4gICAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBpZiBuZWVkZWQsIG9yIGFueSBvdGhlciBjbGVhbnVwIG9wZXJhdGlvbnNcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwic2F5cGk6dHJhbnNjcmliZWRcIixcbiAgICAgIHRoaXMuaGFuZGxlVHJhbnNjcmlwdGlvblJlc3BvbnNlXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBzaW11bGF0ZVR5cGluZyhlbGVtZW50LCB0ZXh0KSB7XG4gICAgZWxlbWVudC5mb2N1cygpO1xuXG4gICAgLy8gRGVmaW5lIGEgcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIHNlbnRlbmNlIHRlcm1pbmF0b3JzLCBjYXB0dXJpbmcgdGhlbVxuICAgIGNvbnN0IHNlbnRlbmNlUmVnZXggPSAvKFsuIT/jgILvvJ/vvIFdKykvZztcbiAgICBjb25zdCB0b2tlbnMgPSB0ZXh0LnNwbGl0KHNlbnRlbmNlUmVnZXgpLmZpbHRlcihCb29sZWFuKTtcblxuICAgIC8vIFJlYXNzZW1ibGUgc2VudGVuY2VzIHdpdGggdGhlaXIgdGVybWluYXRvcnNcbiAgICBjb25zdCBzZW50ZW5jZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3Qgc2VudGVuY2UgPSB0b2tlbnNbaV0gKyAodG9rZW5zW2kgKyAxXSB8fCBcIlwiKTtcbiAgICAgIHNlbnRlbmNlcy5wdXNoKHNlbnRlbmNlKTtcbiAgICB9XG5cbiAgICBsZXQgaSA9IDA7XG5cbiAgICBjb25zdCB0eXBlU2VudGVuY2UgPSAoKSA9PiB7XG4gICAgICBpZiAoaSA8IHNlbnRlbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gVHlwZSB0aGUgc2VudGVuY2UgYW5kIGl0cyBpbW1lZGlhdGUgZm9sbG93aW5nIHRlcm1pbmF0b3JcbiAgICAgICAgRXZlbnRNb2R1bGUuc2V0TmF0aXZlVmFsdWUoZWxlbWVudCwgZWxlbWVudC52YWx1ZSArIHNlbnRlbmNlc1tpKytdKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHR5cGVTZW50ZW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBFdmVudEJ1cy5lbWl0KFwic2F5cGk6YXV0b1N1Ym1pdFwiKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHNlbnRlbmNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgc2VudGVuY2VzLCBwcm9jZWVkIHdpdGggc2VudGVuY2Utd2lzZSB0eXBpbmdcbiAgICAgIHR5cGVTZW50ZW5jZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0ZXh0IGRvZXMgbm90IGNvbnRhaW4gcmVjb2duaXNhYmxlIHNlbnRlbmNlIHRlcm1pbmF0b3JzLCB0eXBlIGl0IGFsbCBhdCBvbmNlXG4gICAgICBFdmVudE1vZHVsZS5zZXROYXRpdmVWYWx1ZShlbGVtZW50LCB0ZXh0KTtcbiAgICAgIEV2ZW50QnVzLmVtaXQoXCJzYXlwaTphdXRvU3VibWl0XCIpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBzZXROYXRpdmVWYWx1ZShlbGVtZW50LCB2YWx1ZSkge1xuICAgIGxldCBsYXN0VmFsdWUgPSBlbGVtZW50LnZhbHVlO1xuICAgIGVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcbiAgICBsZXQgZXZlbnQgPSBuZXcgRXZlbnQoXCJpbnB1dFwiLCB7IHRhcmdldDogZWxlbWVudCwgYnViYmxlczogdHJ1ZSB9KTtcbiAgICAvLyBSZWFjdCAxNVxuICAgIGV2ZW50LnNpbXVsYXRlZCA9IHRydWU7XG4gICAgLy8gUmVhY3QgMTYtMTdcbiAgICBsZXQgdHJhY2tlciA9IGVsZW1lbnQuX3ZhbHVlVHJhY2tlcjtcbiAgICBpZiAodHJhY2tlcikge1xuICAgICAgdHJhY2tlci5zZXRWYWx1ZShsYXN0VmFsdWUpO1xuICAgIH1cbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgc3RhdGljIHJlZ2lzdGVyU3RhdGVNYWNoaW5lRXZlbnRzKGFjdG9yKSB7XG4gICAgRXZlbnRCdXMub24oVVNFUl9TUEVBS0lORywgKCkgPT4ge1xuICAgICAgYWN0b3Iuc2VuZChVU0VSX1NQRUFLSU5HKTtcbiAgICB9KTtcblxuICAgIFtVU0VSX1NUT1BQRURfU1BFQUtJTkcsIFVTRVJfRklOSVNIRURfU1BFQUtJTkddLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgRXZlbnRCdXMub24oZXZlbnROYW1lLCAoZGV0YWlsKSA9PiB7XG4gICAgICAgIGlmIChkZXRhaWwpIHtcbiAgICAgICAgICBhY3Rvci5zZW5kKHsgdHlwZTogZXZlbnROYW1lLCAuLi5kZXRhaWwgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBSZWNlaXZlZCAke2V2ZW50TmFtZX0gd2l0aG91dCBkZXRhaWxzLmApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIFtQSV9TUEVBS0lORywgUElfU1RPUFBFRF9TUEVBS0lORywgUElfRklOSVNIRURfU1BFQUtJTkddLmZvckVhY2goXG4gICAgICAoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgIEV2ZW50QnVzLm9uKGV2ZW50TmFtZSwgKCkgPT4ge1xuICAgICAgICAgIGFjdG9yLnNlbmQoZXZlbnROYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZVN0YXRlVmFsdWUoc3RhdGVWYWx1ZSkge1xuICBpZiAodHlwZW9mIHN0YXRlVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gc3RhdGVWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhzdGF0ZVZhbHVlKVxuICAgIC5tYXAoKGtleSkgPT4gYCR7a2V5fToke3NlcmlhbGl6ZVN0YXRlVmFsdWUoc3RhdGVWYWx1ZVtrZXldKX1gKVxuICAgIC5qb2luKFwiLFwiKTtcbn1cblxuY29uc3QgREVCVUcgPSBmYWxzZTsgLy8gQ29uc2lkZXIgdXNpbmcgY29uZmlnIGFuZCAuZW52IHRvIHNldCB0aGUgREVCVUcgZmxhZ1xuXG5leHBvcnQgY29uc3QgbG9nZ2VyID0ge1xuICBkZWJ1ZzogKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiREVCVUc6XCIsIC4uLmFyZ3MpO1xuICAgIH1cbiAgfSxcbiAgaW5mbzogKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIklORk86XCIsIC4uLmFyZ3MpO1xuICB9LFxuICBlcnJvcjogKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKFwiRVJST1I6XCIsIC4uLmFyZ3MpO1xuICB9LFxufTtcbiIsImltcG9ydCB7IGNvbmZpZyB9IGZyb20gXCIuL0NvbmZpZ01vZHVsZS5qc1wiO1xuXG5jb25zdCBmaWxlc1RvUmVkaXJlY3QgPSBbXG4gIFwic2lsZXJvX3ZhZC5vbm54XCIsXG4gIFwib3J0LXdhc20tc2ltZC53YXNtXCIsXG4gIFwib3J0Lm1pbi5qcy5tYXBcIixcbiAgXCJ2YWQud29ya2xldC5idW5kbGUubWluLmpzXCIsXG5dO1xuXG4vLyBGdW5jdGlvbiB0byBjb25zdHJ1Y3QgdGhlIFVSTCBmb3IgbG9jYWwgZXh0ZW5zaW9uIHJlc291cmNlc1xuZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uUmVzb3VyY2VVcmwoZmlsZW5hbWUpIHtcbiAgY29uc3Qgd2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzX2RpciA9IFwicHVibGljXCI7XG4gIGNvbnN0IGZpbGVwYXRoID0gd2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzX2RpciArIFwiL1wiICsgZmlsZW5hbWU7XG4gIHJldHVybiBjaHJvbWUucnVudGltZS5nZXRVUkwoZmlsZXBhdGgpO1xufVxuXG4vLyBGdW5jdGlvbiB0byByZWRpcmVjdCBzcGVjaWZpYyBYTUxIdHRwUmVxdWVzdHNcbmZ1bmN0aW9uIHJlZGlyZWN0WE1MSHR0cFJlcXVlc3Qob3Blbikge1xuICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChcbiAgICBtZXRob2QsXG4gICAgdXJsLFxuICAgIGFzeW5jLFxuICAgIHVzZXIsXG4gICAgcGFzc3dvcmRcbiAgKSB7XG4gICAgY29uc3QgZmlsZW5hbWUgPSB1cmwuc3BsaXQoXCIvXCIpLnBvcCgpO1xuICAgIGlmIChmaWxlbmFtZSAmJiBmaWxlc1RvUmVkaXJlY3QuaW5jbHVkZXMoZmlsZW5hbWUpKSB7XG4gICAgICAvLyBDaGVjayBpZiBydW5uaW5nIGFzIGEgQ2hyb21lIGV4dGVuc2lvblxuICAgICAgaWYgKGNocm9tZS5ydW50aW1lICYmIGNocm9tZS5ydW50aW1lLmlkKSB7XG4gICAgICAgIGFyZ3VtZW50c1sxXSA9IGdldEV4dGVuc2lvblJlc291cmNlVXJsKGZpbGVuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3VtZW50c1sxXSA9IGAke2NvbmZpZy5hcHBTZXJ2ZXJVcmx9LyR7ZmlsZW5hbWV9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgb3Blbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vLyBGdW5jdGlvbiB0byByZWRpcmVjdCBzcGVjaWZpYyBmZXRjaCByZXF1ZXN0c1xuZnVuY3Rpb24gcmVkaXJlY3RGZXRjaChfZmV0Y2gpIHtcbiAgd2luZG93LmZldGNoID0gZnVuY3Rpb24gKHVybCwgb3B0cykge1xuICAgIGNvbnN0IGZpbGVuYW1lID0gdXJsLnNwbGl0KFwiL1wiKS5wb3AoKTtcbiAgICBpZiAoZmlsZW5hbWUgJiYgZmlsZXNUb1JlZGlyZWN0LmluY2x1ZGVzKGZpbGVuYW1lKSkge1xuICAgICAgLy8gQ2hlY2sgaWYgcnVubmluZyBhcyBhIENocm9tZSBleHRlbnNpb25cbiAgICAgIGlmIChjaHJvbWUucnVudGltZSAmJiBjaHJvbWUucnVudGltZS5pZCkge1xuICAgICAgICBhcmd1bWVudHNbMF0gPSBnZXRFeHRlbnNpb25SZXNvdXJjZVVybChmaWxlbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmd1bWVudHNbMF0gPSBgJHtjb25maWcuYXBwU2VydmVyVXJsfS8ke2ZpbGVuYW1lfWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfZmV0Y2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLy8gRnVuY3Rpb24gdG8gc2V0IHVwIHRoZSBpbnRlcmNlcHRvcnNcbmV4cG9ydCBmdW5jdGlvbiBzZXR1cEludGVyY2VwdG9ycygpIHtcbiAgcmVkaXJlY3RYTUxIdHRwUmVxdWVzdChYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUub3Blbik7XG4gIHJlZGlyZWN0RmV0Y2god2luZG93LmZldGNoKTtcbn1cbiIsImltcG9ydCB7IGludGVycHJldCB9IGZyb20gXCJ4c3RhdGVcIjtcbmltcG9ydCB7IG1hY2hpbmUgfSBmcm9tIFwiLi9zdGF0ZS1tYWNoaW5lcy9TYXlQaU1hY2hpbmUudHNcIjtcbmltcG9ydCB7IGxvZ2dlciwgc2VyaWFsaXplU3RhdGVWYWx1ZSB9IGZyb20gXCIuL0xvZ2dpbmdNb2R1bGUuanNcIjtcblxuLyoqXG4gKiBBIHNpbmdsZXRvbiBzZXJ2aWNlIHRoYXQgbWFuYWdlcyB0aGUgc3RhdGUgbWFjaGluZS5cbiAqL1xuY2xhc3MgU3RhdGVNYWNoaW5lU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYWN0b3IgPSBpbnRlcnByZXQobWFjaGluZSkub25UcmFuc2l0aW9uKChzdGF0ZSkgPT4ge1xuICAgICAgaWYgKHN0YXRlLmNoYW5nZWQpIHtcbiAgICAgICAgY29uc3QgZnJvbVN0YXRlID0gc3RhdGUuaGlzdG9yeVxuICAgICAgICAgID8gc2VyaWFsaXplU3RhdGVWYWx1ZShzdGF0ZS5oaXN0b3J5LnZhbHVlKVxuICAgICAgICAgIDogXCJOL0FcIjtcbiAgICAgICAgY29uc3QgdG9TdGF0ZSA9IHNlcmlhbGl6ZVN0YXRlVmFsdWUoc3RhdGUudmFsdWUpO1xuICAgICAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgICAgYFNheSwgUGkgTWFjaGluZSB0cmFuc2l0aW9uZWQgZnJvbSAke2Zyb21TdGF0ZX0gdG8gJHt0b1N0YXRlfSB3aXRoICR7c3RhdGUuZXZlbnQudHlwZX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hY3Rvci5zdGFydCgpO1xuICB9XG59XG5cbi8vIFNpbmdsZXRvblxuZXhwb3J0IGRlZmF1bHQgbmV3IFN0YXRlTWFjaGluZVNlcnZpY2UoKTtcbiIsImltcG9ydCB7IGFwcGVuZENoaWxkIH0gZnJvbSBcIi4vRE9NTW9kdWxlLnRzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc01vYmlsZURldmljZSgpIHtcbiAgcmV0dXJuIChcbiAgICAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QoXG4gICAgICBuYXZpZ2F0b3IudXNlckFnZW50XG4gICAgKSB8fCB3aW5kb3cubWF0Y2hNZWRpYShcIihtYXgtd2lkdGg6IDc2OHB4KVwiKS5tYXRjaGVzXG4gICk7XG59XG5cbi8vIHRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHNob3cgdGhlIG1vYmlsZSB2aWV3IG9yIG5vdFxuZXhwb3J0IGZ1bmN0aW9uIGlzTW9iaWxlVmlldygpIHtcbiAgbGV0IHVzZXJWaWV3UHJlZmVyZW5jZSA9IG51bGw7XG5cbiAgdHJ5IHtcbiAgICB1c2VyVmlld1ByZWZlcmVuY2UgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInVzZXJWaWV3UHJlZmVyZW5jZVwiKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBhY2Nlc3MgbG9jYWxTdG9yYWdlOiBcIiwgZSk7XG4gIH1cblxuICBsZXQgcHJlZmVyc01vYmlsZSA9IGZhbHNlO1xuICBpZiAodXNlclZpZXdQcmVmZXJlbmNlKSB7XG4gICAgcHJlZmVyc01vYmlsZSA9IHVzZXJWaWV3UHJlZmVyZW5jZSA9PT0gXCJtb2JpbGVcIjtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBpc01vYmlsZURldmljZSBpcyBkZWZpbmVkIG9yIGltcG9ydGVkXG4gIHJldHVybiBpc01vYmlsZURldmljZSgpICYmIHByZWZlcnNNb2JpbGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleGl0TW9iaWxlTW9kZSgpIHtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1c2VyVmlld1ByZWZlcmVuY2VcIiwgXCJkZXNrdG9wXCIpOyAvLyBTYXZlIHByZWZlcmVuY2VcblxuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJtb2JpbGUtdmlld1wiKTtcbiAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZGVza3RvcC12aWV3XCIpO1xuXG4gIGF0dGFjaENhbGxCdXR0b24oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVudGVyTW9iaWxlTW9kZSgpIHtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1c2VyVmlld1ByZWZlcmVuY2VcIiwgXCJtb2JpbGVcIik7IC8vIFNhdmUgcHJlZmVyZW5jZVxuXG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImRlc2t0b3Atdmlld1wiKTtcbiAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibW9iaWxlLXZpZXdcIik7XG5cbiAgZGV0YWNoQ2FsbEJ1dHRvbigpO1xufVxuXG5mdW5jdGlvbiBhdHRhY2hDYWxsQnV0dG9uKCkge1xuICAvLyBtb3ZlIHRoZSBjYWxsIGJ1dHRvbiBiYWNrIGludG8gdGhlIHRleHQgcHJvbXB0IGNvbnRhaW5lciBmb3IgZGVza3RvcCB2aWV3XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2F5cGktcHJvbXB0LWNvbnRyb2xzLWNvbnRhaW5lclwiKTtcbiAgY29uc3QgY2FsbEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2F5cGktY2FsbEJ1dHRvblwiKTtcbiAgaWYgKGNvbnRhaW5lciAmJiBjYWxsQnV0dG9uKSB7XG4gICAgYXBwZW5kQ2hpbGQoY29udGFpbmVyLCBjYWxsQnV0dG9uLCAtMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoQ2FsbEJ1dHRvbigpIHtcbiAgLy8gcmVtb3ZlIHRoZSBjYWxsIGJ1dHRvbiBmcm9tIHRoZSB0ZXh0IHByb21wdCBjb250YWluZXIgd2hpbGUgaW4gbW9iaWxlIHZpZXdcbiAgY29uc3QgY2FsbEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2F5cGktY2FsbEJ1dHRvblwiKTtcbiAgaWYgKGNhbGxCdXR0b24pIHtcbiAgICBhcHBlbmRDaGlsZChkb2N1bWVudC5ib2R5LCBjYWxsQnV0dG9uKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkVXNlckFnZW50RmxhZ3MoKSB7XG4gIGNvbnN0IGlzRmlyZWZveEFuZHJvaWQgPVxuICAgIC9GaXJlZm94Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmIC9BbmRyb2lkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gIGlmIChpc0ZpcmVmb3hBbmRyb2lkKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZmlyZWZveC1hbmRyb2lkXCIpO1xuICB9XG5cbiAgYWRkRGV2aWNlRmxhZ3MoZWxlbWVudCk7XG4gIGFkZFZpZXdGbGFncyhlbGVtZW50KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZERldmljZUZsYWdzKGVsZW1lbnQpIHtcbiAgaWYgKGlzTW9iaWxlRGV2aWNlKCkpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJtb2JpbGUtZGV2aWNlXCIpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRWaWV3RmxhZ3MoZWxlbWVudCkge1xuICBpZiAoaXNNb2JpbGVWaWV3KCkpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJkZXNrdG9wLXZpZXdcIik7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibW9iaWxlLXZpZXdcIik7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwibW9iaWxlLXZpZXdcIik7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZGVza3RvcC12aWV3XCIpO1xuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybSBpbml0aWFsIHNldHVwIG9mIHRoZSBVSSBiYXNlZCBvbiB0aGUgdXNlcidzIGRldmljZSBhbmQgdmlldyBwcmVmZXJlbmNlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdE1vZGUoKSB7XG4gIGlmIChpc01vYmlsZVZpZXcoKSkge1xuICAgIGVudGVyTW9iaWxlTW9kZSgpO1xuICB9IGVsc2Uge1xuICAgIGV4aXRNb2JpbGVNb2RlKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGNyZWF0ZU1hY2hpbmUsIGFzc2lnbiB9IGZyb20gXCJ4c3RhdGVcIjtcbmltcG9ydCBFdmVudEJ1cyBmcm9tIFwiLi4vRXZlbnRCdXMuanNcIjtcblxuZXhwb3J0IGNvbnN0IGF1ZGlvT3V0cHV0TWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoXG4gIHtcbiAgICBjb250ZXh0OiB7XG4gICAgICBhdXRvcGxheTogZmFsc2UsXG4gICAgfSxcbiAgICBpZDogXCJhdWRpb091dHB1dFwiLFxuICAgIGluaXRpYWw6IFwiaWRsZVwiLFxuICAgIHN0YXRlczoge1xuICAgICAgaWRsZToge1xuICAgICAgICBvbjoge1xuICAgICAgICAgIGxvYWRzdGFydDoge1xuICAgICAgICAgICAgdGFyZ2V0OiBcImxvYWRpbmdcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGxvYWRpbmc6IHtcbiAgICAgICAgb246IHtcbiAgICAgICAgICBsb2FkZWRtZXRhZGF0YToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcImxvYWRlZFwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgbG9hZGVkOiB7XG4gICAgICAgIGluaXRpYWw6IFwicmVhZHlcIixcbiAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgcmVhZHk6IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgICBcIkF1ZGlvIGhhcyBsb2FkZWQgYW5kIGlzIHJlYWR5IHRvIHN0YXJ0IHBsYXlpbmcgKGZ1cnRoZXIgYnVmZmVyaW5nIG1heSBiZSByZXF1aXJlZCB0byByZWFjaCB0aGUgZW5kKS5cIixcbiAgICAgICAgICAgIGVudHJ5OiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZW1pdEV2ZW50XCIsXG4gICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGV2ZW50TmFtZTogXCJzYXlwaTpyZWFkeVwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIHBsYXk6IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IFwicGxheWluZ1wiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBsYXlpbmc6IHtcbiAgICAgICAgICAgIGVudHJ5OiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZW1pdEV2ZW50XCIsXG4gICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIGV2ZW50TmFtZTogXCJzYXlwaTpwaVNwZWFraW5nXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhpdDogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlbWl0RXZlbnRcIixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZTogXCJzYXlwaTpwaVN0b3BwZWRTcGVha2luZ1wiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgcGF1c2U6IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IFwicGF1c2VkXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVuZGVkOiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBcImVuZGVkXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNhbnBsYXl0aHJvdWdoOiB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWw6IHRydWUsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGF1c2VkOiB7XG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBwbGF5OiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBcInBsYXlpbmdcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmRlZDoge1xuICAgICAgICAgICAgZW50cnk6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlbWl0RXZlbnRcIixcbiAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgZXZlbnROYW1lOiBcInNheXBpOnBpRmluaXNoZWRTcGVha2luZ1wiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIHNlZWtlZDoge1xuICAgICAgICAgICAgICAgIHRhcmdldDogXCJyZWFkeVwiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgICAgICAgXCJBbiBlbmRlZCB0cmFjayBpcyBzZWVrZWQgYmFjayB0byBlYXJsaWVyIGluIHRoZSB0cmFjay5cIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBlbXB0aWVkOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgcHJlZGljdGFibGVBY3Rpb25Bcmd1bWVudHM6IHRydWUsXG4gICAgcHJlc2VydmVBY3Rpb25PcmRlcjogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGFjdGlvbnM6IHtcbiAgICAgIGVtaXRFdmVudDogKGNvbnRleHQsIGV2ZW50LCB7IGFjdGlvbiB9KSA9PiB7XG4gICAgICAgIEV2ZW50QnVzLmVtaXQoYWN0aW9uLnBhcmFtcy5ldmVudE5hbWUpO1xuICAgICAgfSxcbiAgICB9LFxuICAgIGd1YXJkczoge30sXG4gICAgc2VydmljZXM6IHt9LFxuICAgIGRlbGF5czoge30sXG4gIH1cbik7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5jID0gdW5kZWZpbmVkOyIsImltcG9ydCBBdWRpb01vZHVsZSBmcm9tIFwiLi9BdWRpb01vZHVsZS5qc1wiO1xuaW1wb3J0IHsgYnV0dG9uTW9kdWxlIH0gZnJvbSBcIi4vQnV0dG9uTW9kdWxlLmpzXCI7XG5pbXBvcnQgRXZlbnRNb2R1bGUgZnJvbSBcIi4vRXZlbnRNb2R1bGUuanNcIjtcbmltcG9ydCB7IGFkZFVzZXJBZ2VudEZsYWdzLCBpbml0TW9kZSB9IGZyb20gXCIuL1VzZXJBZ2VudE1vZHVsZS5qc1wiO1xuaW1wb3J0IHsgc3VibWl0RXJyb3JIYW5kbGVyIH0gZnJvbSBcIi4vU3VibWl0RXJyb3JIYW5kbGVyLnRzXCI7XG5pbXBvcnQgeyBjb25maWcgYXMgc2VydmVyQ29uZmlnIH0gZnJvbSBcIi4vQ29uZmlnTW9kdWxlLmpzXCI7XG5cbmltcG9ydCBcIi4vc3R5bGVzL2NvbW1vbi5zY3NzXCI7XG5pbXBvcnQgXCIuL3N0eWxlcy9kZXNrdG9wLnNjc3NcIjtcbmltcG9ydCBcIi4vc3R5bGVzL21vYmlsZS5zY3NzXCI7XG5pbXBvcnQgXCIuL3N0eWxlcy9yZWN0YW5nbGVzLmNzc1wiO1xuXG4oYXN5bmMgZnVuY3Rpb24gKCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBmdW5jdGlvbiBzdGFydEF1ZGlvTW9kdWxlKCkge1xuICAgIGNvbnN0IGF1ZGlvTW9kdWxlID0gbmV3IEF1ZGlvTW9kdWxlKCk7XG4gICAgYXVkaW9Nb2R1bGUuc3RhcnQoKTtcbiAgfVxuXG4gIGFkZFVzZXJBZ2VudEZsYWdzKCk7XG4gIEV2ZW50TW9kdWxlLmluaXQoKTtcblxuICAvLyBDcmVhdGUgYSBNdXRhdGlvbk9ic2VydmVyIHRvIGxpc3RlbiBmb3IgY2hhbmdlcyB0byB0aGUgRE9NXG4gIC8vIHRleHRhcmVhcyBhcmUgYWRkZWQgdG8gdGhlIERPTSBhZnRlciB0aGUgcGFnZSBsb2Fkc1xuICBjb25zdCBjYWxsYmFjayA9IGZ1bmN0aW9uIChtdXRhdGlvbnNMaXN0LCBvYnNlcnZlcikge1xuICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zTGlzdCkge1xuICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFkZGVkIG5vZGVzXG4gICAgICAgIG11dGF0aW9uLmFkZGVkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgIC8vIENoZWNrIGlmIGFkZGVkIG5vZGUgaXMgYSB0ZXh0YXJlYSB3aXRoICdlbnRlcmtleWhpbnQnIGF0dHJpYnV0ZVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG5vZGUubm9kZU5hbWUgPT09IFwiVEVYVEFSRUFcIiAmJlxuICAgICAgICAgICAgbm9kZS5oYXNBdHRyaWJ1dGUoXCJlbnRlcmtleWhpbnRcIilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIFN0b3Agb2JzZXJ2aW5nIHRvIGF2b2lkIGFueSBwb3RlbnRpYWwgaW5maW5pdGUgbG9vcHNcbiAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICAgICAgLy8gRG8gc29tZXRoaW5nIHdpdGggdGhlIHRleHRhcmVhLCBsaWtlIGFkZCBhbiBldmVudCBsaXN0ZW5lclxuICAgICAgICAgICAgYW5ub3RhdGVET00obm9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgYWRkZWQgbm9kZSBjb250YWlucyBhIHRleHRhcmVhIHdpdGggJ2VudGVya2V5aGludCcgYXR0cmlidXRlXG4gICAgICAgICAgaWYgKG5vZGUucXVlcnlTZWxlY3RvckFsbCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dGFyZWFzID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwidGV4dGFyZWFbZW50ZXJrZXloaW50XVwiKTtcbiAgICAgICAgICAgIGlmICh0ZXh0YXJlYXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBTdG9wIG9ic2VydmluZ1xuICAgICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgICAgICAgLy8gRG8gc29tZXRoaW5nIHdpdGggdGhlIGZpcnN0IHRleHRhcmVhIHRoYXQgaGFzICdlbnRlcmtleWhpbnQnXG4gICAgICAgICAgICAgIGFubm90YXRlRE9NKHRleHRhcmVhc1swXSk7XG4gICAgICAgICAgICAgIHN1Ym1pdEVycm9ySGFuZGxlci5pbml0QXVkaW9PdXRwdXRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICBzdWJtaXRFcnJvckhhbmRsZXIuY2hlY2tGb3JSZXN0b3JlUG9pbnQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIE9wdGlvbnMgZm9yIHRoZSBvYnNlcnZlciAod2hpY2ggbXV0YXRpb25zIHRvIG9ic2VydmUpXG4gIGNvbnN0IGNvbmZpZyA9IHsgYXR0cmlidXRlczogZmFsc2UsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9O1xuXG4gIC8vIENyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBsaW5rZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spO1xuXG4gIC8vIFN0YXJ0IG9ic2VydmluZyB0aGUgdGFyZ2V0IG5vZGUgZm9yIGNvbmZpZ3VyZWQgbXV0YXRpb25zXG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuYm9keSwgY29uZmlnKTtcblxuICBmdW5jdGlvbiBhbm5vdGF0ZURPTShwcm9tcHQpIHtcbiAgICAvLyBBZGQgaWQgYXR0cmlidXRlcyB0byBpbXBvcnRhbnQgZWxlbWVudHNcbiAgICBwcm9tcHQuaWQgPSBcInNheXBpLXByb21wdFwiO1xuICAgIHByb21wdC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJzYXlwaS1wcm9tcHQtY29udGFpbmVyXCIpO1xuICAgIGNvbnN0IGZvdW5kRm9vdGVyID0gYWRkSWRGb290ZXIoKTtcbiAgICBjb25zdCBmb3VuZEF1ZGlvQ29udHJvbHMgPSBhZGRJZEF1ZGlvQ29udHJvbHMoKTtcbiAgICBjb25zdCBwcm9tcHRDb250cm9sc0NvbnRhaW5lciA9IHByb21wdC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgcHJvbXB0Q29udHJvbHNDb250YWluZXIuaWQgPSBcInNheXBpLXByb21wdC1jb250cm9scy1jb250YWluZXJcIjtcbiAgICBjb25zdCBmb3VuZFByb21wdEFuY2VzdG9yID0gYWRkSWRQcm9tcHRBbmNlc3Rvcihwcm9tcHRDb250cm9sc0NvbnRhaW5lcik7XG4gICAgY29uc3QgZm91bmRBdWRpb091dHB1dEJ1dHRvbiA9IGFkZElkQXVkaW9PdXRwdXRCdXR0b24oKTtcbiAgICBhZGRJZFN1Ym1pdEJ1dHRvbihwcm9tcHRDb250cm9sc0NvbnRhaW5lcik7XG4gICAgYWRkVGFsa0J1dHRvbihkb2N1bWVudC5ib2R5KTtcbiAgICBidXR0b25Nb2R1bGUuY3JlYXRlQ2FsbEJ1dHRvbihwcm9tcHRDb250cm9sc0NvbnRhaW5lciwgLTEpO1xuICAgIGJ1dHRvbk1vZHVsZS5jcmVhdGVFbnRlckJ1dHRvbigpO1xuICAgIGJ1dHRvbk1vZHVsZS5jcmVhdGVFeGl0QnV0dG9uKCk7XG4gICAgaW5pdE1vZGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZElkUHJvbXB0QW5jZXN0b3IoY29udGFpbmVyKSB7XG4gICAgLy8gY2xpbWIgdXAgdGhlIERPTSB0cmVlIHVudGlsIHdlIGZpbmQgYSBkaXYgd2l0aCBjbGFzcyAndy1mdWxsJ1xuICAgIGxldCBwYXJlbnQgPSBjb250YWluZXIucGFyZW50RWxlbWVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmNsYXNzTGlzdC5jb250YWlucyhcInctZnVsbFwiKSkge1xuICAgICAgICBwYXJlbnQuaWQgPSBcInNheXBpLXByb21wdC1hbmNlc3RvclwiO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRJZFN1Ym1pdEJ1dHRvbihjb250YWluZXIpIHtcbiAgICBjb25zdCBzdWJtaXRCdXR0b25zID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCJidXR0b25bdHlwZT1idXR0b25dXCIpO1xuICAgIGlmIChzdWJtaXRCdXR0b25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGxhc3RTdWJtaXRCdXR0b24gPSBzdWJtaXRCdXR0b25zW3N1Ym1pdEJ1dHRvbnMubGVuZ3RoIC0gMV07XG4gICAgICBsYXN0U3VibWl0QnV0dG9uLmlkID0gXCJzYXlwaS1zdWJtaXRCdXR0b25cIjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRJZEZvb3RlcigpIHtcbiAgICAvLyBGaW5kIGFsbCBhdWRpbyBlbGVtZW50cyBvbiB0aGUgcGFnZVxuICAgIHZhciBhdWRpb0VsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImF1ZGlvXCIpO1xuICAgIHZhciBmb3VuZCA9IGZhbHNlOyAvLyBkZWZhdWx0IHRvIG5vdCBmb3VuZFxuXG4gICAgYXVkaW9FbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhdWRpbykge1xuICAgICAgdmFyIHByZWNlZGluZ0RpdiA9IGF1ZGlvLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG5cbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZm91bmQgYSBkaXYsIHdlIGNhbiBza2lwIGZ1cnRoZXIgaXRlcmF0aW9uc1xuICAgICAgaWYgKGZvdW5kKSByZXR1cm47XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBwcmVjZWRpbmcgZWxlbWVudCBpcyBhIGRpdlxuICAgICAgaWYgKHByZWNlZGluZ0RpdiAmJiBwcmVjZWRpbmdEaXYudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImRpdlwiKSB7XG4gICAgICAgIC8vIEFzc2lnbiBhbiBJRCB0byB0aGUgZGl2XG4gICAgICAgIHByZWNlZGluZ0Rpdi5sYXN0RWxlbWVudENoaWxkLmlkID0gXCJzYXlwaS1mb290ZXJcIjtcbiAgICAgICAgZm91bmQgPSB0cnVlOyAvLyBzZXQgdG8gZm91bmRcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZElkQXVkaW9Db250cm9scygpIHtcbiAgICAvLyBGaW5kIGFsbCBhdWRpbyBlbGVtZW50cyBvbiB0aGUgcGFnZVxuICAgIHZhciBhdWRpb0VsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImF1ZGlvXCIpO1xuICAgIHZhciBmb3VuZCA9IGZhbHNlOyAvLyBkZWZhdWx0IHRvIG5vdCBmb3VuZFxuXG4gICAgYXVkaW9FbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhdWRpbykge1xuICAgICAgdmFyIG5leHREaXYgPSBhdWRpby5uZXh0RWxlbWVudFNpYmxpbmc7XG5cbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZm91bmQgYSBkaXYsIHdlIGNhbiBza2lwIGZ1cnRoZXIgaXRlcmF0aW9uc1xuICAgICAgaWYgKGZvdW5kKSByZXR1cm47XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBwcmVjZWRpbmcgZWxlbWVudCBpcyBhIGRpdlxuICAgICAgaWYgKG5leHREaXYgJiYgbmV4dERpdi50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZGl2XCIpIHtcbiAgICAgICAgLy8gQXNzaWduIGFuIElEIHRvIHRoZSBkaXZcbiAgICAgICAgbmV4dERpdi5pZCA9IFwic2F5cGktYXVkaW8tY29udHJvbHNcIjtcbiAgICAgICAgZm91bmQgPSB0cnVlOyAvLyBzZXQgdG8gZm91bmRcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZElkQXVkaW9PdXRwdXRCdXR0b24oKSB7XG4gICAgLy8gYXVkaW8gYnV0dG9uIGlzIHRoZSBsYXN0IGJ1dHRvbiBlbGVtZW50IGluIHRoZSBhdWRpbyBjb250cm9scyBjb250YWluZXJcbiAgICBjb25zdCBhdWRpb0J1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICBcIiNzYXlwaS1hdWRpby1jb250cm9scyA+IGRpdiA+IGRpdi5yZWxhdGl2ZS5mbGV4Lml0ZW1zLWNlbnRlci5qdXN0aWZ5LWVuZC5zZWxmLWVuZC5wLTIgPiBidXR0b25cIlxuICAgICk7XG4gICAgaWYgKCFhdWRpb0J1dHRvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdWRpb0J1dHRvbi5pZCA9IFwic2F5cGktYXVkaW8tb3V0cHV0LWJ1dHRvblwiO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFRhbGtCdXR0b24oY29udGFpbmVyKSB7XG4gICAgLy8gQ3JlYXRlIGEgY29udGFpbmluZyBkaXZcbiAgICB2YXIgcGFuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHBhbmVsLmlkID0gXCJzYXlwaS1wYW5lbFwiO1xuXG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHBhbmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwYW5lbCk7XG4gICAgfVxuXG4gICAgLy8gdGFsayBcImJ1dHRvblwiIGlzIG5vIGxvbmdlciBhIGJ1dHRvbiwgYnV0IGEgZGl2XG4gICAgdmFyIGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgYnV0dG9uLmlkID0gXCJzYXlwaS10YWxrQnV0dG9uXCI7XG5cbiAgICBjb25zdCBjbGFzc05hbWVzID1cbiAgICAgIFwicmVsYXRpdmUgZmxleCBtdC0xIG1iLTEgcm91bmRlZC1mdWxsIHB4LTIgcHktMyB0ZXh0LWNlbnRlciBiZy1jcmVhbS01NTAgaG92ZXI6YmctY3JlYW0tNjUwIGhvdmVyOnRleHQtYnJhbmQtZ3JlZW4tNzAwIHRleHQtbXV0ZWRcIjtcbiAgICBidXR0b24uY2xhc3NMaXN0LmFkZChjbGFzc05hbWVzLnNwbGl0KFwiIFwiKSk7XG5cbiAgICAvLyBFbmFibGUgYXV0b3N1Ym1pdCBieSBkZWZhdWx0XG4gICAgYnV0dG9uLmRhdGFzZXQuYXV0b3N1Ym1pdCA9IFwidHJ1ZVwiO1xuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwiYXV0b1N1Ym1pdFwiKTtcblxuICAgIHBhbmVsLmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgYnV0dG9uTW9kdWxlLmFkZFRhbGtJY29uKGJ1dHRvbik7XG5cbiAgICAvLyBDYWxsIHRoZSBmdW5jdGlvbiB0byBpbmplY3QgdGhlIHNjcmlwdCBhZnRlciB0aGUgYnV0dG9uIGhhcyBiZWVuIGFkZGVkXG4gICAgc3RhcnRBdWRpb01vZHVsZSgpO1xuICB9XG5cbiAgLy8gU3RhcnQgb2JzZXJ2aW5nIHRoZSBlbnRpcmUgZG9jdW1lbnQgZm9yIGNoYW5nZXMgdG8gY2hpbGQgbm9kZXMgYW5kIHN1YnRyZWVcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG59KSgpO1xuIl0sIm5hbWVzIjpbIkFuaW1hdGlvbk1vZHVsZSIsIl9jbGFzc0NhbGxDaGVjayIsIl9jcmVhdGVDbGFzcyIsImtleSIsInZhbHVlIiwic3RhcnRBbmltYXRpb24iLCJhbmltYXRpb24iLCJzdG9wT3RoZXJBbmltYXRpb25zIiwicmVjdGFuZ2xlcyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsInJlY3RhbmdsZXNTZWxlY3RvciIsImZvckVhY2giLCJyZWN0IiwiY2xhc3NMaXN0IiwiYWRkIiwic3RvcEFuaW1hdGlvbiIsInJlbW92ZSIsInN0b3BBbGxBbmltYXRpb25zIiwiX3RoaXMiLCJ0YWxrQnV0dG9uQW5pbWF0aW9ucyIsImtlZXBBbmltYXRpb24iLCJfdGhpczIiLCJfZGVmaW5lUHJvcGVydHkiLCJkZWZhdWx0IiwiaW50ZXJwcmV0IiwiYXVkaW9JbnB1dE1hY2hpbmUiLCJhdWRpb091dHB1dE1hY2hpbmUiLCJsb2dnZXIiLCJzZXJpYWxpemVTdGF0ZVZhbHVlIiwiRXZlbnRCdXMiLCJBdWRpb01vZHVsZSIsImF1ZGlvRWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJjb25zb2xlIiwiZXJyb3IiLCJwcmVsb2FkIiwiYXVkaW9PdXRwdXRBY3RvciIsIm9uVHJhbnNpdGlvbiIsInN0YXRlIiwiY2hhbmdlZCIsImZyb21TdGF0ZSIsImhpc3RvcnkiLCJ0b1N0YXRlIiwiZGVidWciLCJjb25jYXQiLCJldmVudCIsInR5cGUiLCJhdWRpb0lucHV0QWN0b3IiLCJzdGFydCIsInJlZ2lzdGVyQXVkaW9QbGF5YmFja0V2ZW50cyIsInJlZ2lzdGVyQXVkaW9Db21tYW5kcyIsImF1ZGlvIiwiYWN0b3IiLCJldmVudHMiLCJhZGRFdmVudExpc3RlbmVyIiwic2VuZCIsImlucHV0QWN0b3IiLCJvdXRwdXRBY3RvciIsIm9uIiwiZSIsImRldGFpbCIsIl9vYmplY3RTcHJlYWQiLCJlbnRlck1vYmlsZU1vZGUiLCJleGl0TW9iaWxlTW9kZSIsImlzTW9iaWxlVmlldyIsImFwcGVuZENoaWxkIiwiU3RhdGVNYWNoaW5lU2VydmljZSIsInN1Ym1pdEVycm9ySGFuZGxlciIsImV4aXRJY29uU1ZHIiwibWF4aW1pemVJY29uU1ZHIiwicmVjdGFuZ2xlc1NWRyIsInRhbGtJY29uU1ZHIiwibXV0ZWRNaWNJY29uU1ZHIiwiY2FsbEljb25TVkciLCJoYW5ndXBJY29uU1ZHIiwiQnV0dG9uTW9kdWxlIiwicmVnaXN0ZXJPdGhlckV2ZW50cyIsInN1Ym1pc3Npb25zV2l0aG91dEFuRXJyb3IiLCJoYW5kbGVBdXRvU3VibWl0IiwiY3JlYXRlQnV0dG9uIiwibGFiZWwiLCJjYWxsYmFjayIsImJ1dHRvbiIsImNyZWF0ZUVsZW1lbnQiLCJ0ZXh0Q29udGVudCIsIm9uY2xpY2siLCJzdHlsZUJ1dHRvbiIsInN0eWxlcyIsImhhc093blByb3BlcnR5Iiwic3R5bGUiLCJhZGRUYWxrSWNvbiIsInVwZGF0ZUljb25Db250ZW50Iiwid2luZG93IiwibWF0Y2hNZWRpYSIsImFkZExpc3RlbmVyIiwic2V0dXBDbGFzc09ic2VydmVyIiwiaWNvbkNvbnRhaW5lciIsImlubmVySFRNTCIsIl90aGlzMyIsInRhcmdldE5vZGUiLCJkb2N1bWVudEVsZW1lbnQiLCJjb25maWciLCJhdHRyaWJ1dGVzIiwiYXR0cmlidXRlRmlsdGVyIiwibXV0YXRpb25zTGlzdCIsIm9ic2VydmVyIiwiX2l0ZXJhdG9yIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiLCJfc3RlcCIsInMiLCJuIiwiZG9uZSIsIm11dGF0aW9uIiwiYXR0cmlidXRlTmFtZSIsImNvbnRhaW5zIiwiZXJyIiwiZiIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwic2ltdWxhdGVGb3JtU3VibWl0Iiwic3VibWl0QnV0dG9uIiwiZ2V0RWxlbWVudEJ5SWQiLCJkZXRlY3RTdWJtaXRFcnJvciIsImhhbmRsZVN1Ym1pdEVycm9yIiwiY2xpY2siLCJ0ZXh0YXJlYSIsImVudGVyRXZlbnQiLCJLZXlib2FyZEV2ZW50IiwiYnViYmxlcyIsImtleUNvZGUiLCJ3aGljaCIsImRpc3BhdGNoRXZlbnQiLCJ0YWxrQnV0dG9uIiwiZGF0YXNldCIsImF1dG9zdWJtaXQiLCJsb2ciLCJjcmVhdGVFeGl0QnV0dG9uIiwiaWQiLCJjbGFzc05hbWUiLCJzZXRBdHRyaWJ1dGUiLCJib2R5IiwiY3JlYXRlRW50ZXJCdXR0b24iLCJzaG93Tm90aWZpY2F0aW9uIiwiZGV0YWlscyIsImljb24iLCJpY29uU1ZHIiwibm90aWZpY2F0aW9uIiwiZGlzbWlzc05vdGlmaWNhdGlvbiIsImNyZWF0ZUNhbGxCdXR0b24iLCJjb250YWluZXIiLCJwb3NpdGlvbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImNhbGxJbmFjdGl2ZSIsImNhbGxBY3RpdmUiLCJjYWxsQnV0dG9uIiwiX3RoaXM0IiwiX3RoaXM1IiwiZGlzYWJsZUNhbGxCdXR0b24iLCJkaXNhYmxlZCIsImVuYWJsZUNhbGxCdXR0b24iLCJidXR0b25Nb2R1bGUiLCJhcHBTZXJ2ZXJVcmwiLCJwcm9jZXNzIiwiZW52IiwiQVBQX1NFUlZFUl9VUkwiLCJhcGlTZXJ2ZXJVcmwiLCJBUElfU0VSVkVSX1VSTCIsIkV2ZW50RW1pdHRlciIsIlVTRVJfU1BFQUtJTkciLCJVU0VSX1NUT1BQRURfU1BFQUtJTkciLCJVU0VSX0ZJTklTSEVEX1NQRUFLSU5HIiwiUElfU1BFQUtJTkciLCJQSV9TVE9QUEVEX1NQRUFLSU5HIiwiUElfRklOSVNIRURfU1BFQUtJTkciLCJFdmVudE1vZHVsZSIsImluaXQiLCJyZWdpc3RlclN0YXRlTWFjaGluZUV2ZW50cyIsImNsZWFudXAiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlVHJhbnNjcmlwdGlvblJlc3BvbnNlIiwic2ltdWxhdGVUeXBpbmciLCJlbGVtZW50IiwidGV4dCIsImZvY3VzIiwic2VudGVuY2VSZWdleCIsInRva2VucyIsInNwbGl0IiwiZmlsdGVyIiwiQm9vbGVhbiIsInNlbnRlbmNlcyIsImkiLCJzZW50ZW5jZSIsInB1c2giLCJ0eXBlU2VudGVuY2UiLCJzZXROYXRpdmVWYWx1ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImVtaXQiLCJsYXN0VmFsdWUiLCJFdmVudCIsInRhcmdldCIsInNpbXVsYXRlZCIsInRyYWNrZXIiLCJfdmFsdWVUcmFja2VyIiwic2V0VmFsdWUiLCJldmVudE5hbWUiLCJ3YXJuIiwic3RhdGVWYWx1ZSIsIk9iamVjdCIsImtleXMiLCJtYXAiLCJqb2luIiwiREVCVUciLCJfY29uc29sZSIsIl9sZW4iLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiYXBwbHkiLCJpbmZvIiwiX2NvbnNvbGUyIiwiX2xlbjIiLCJfa2V5MiIsIl9jb25zb2xlMyIsIl9sZW4zIiwiX2tleTMiLCJmaWxlc1RvUmVkaXJlY3QiLCJnZXRFeHRlbnNpb25SZXNvdXJjZVVybCIsImZpbGVuYW1lIiwid2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzX2RpciIsImZpbGVwYXRoIiwiY2hyb21lIiwicnVudGltZSIsImdldFVSTCIsInJlZGlyZWN0WE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwiWE1MSHR0cFJlcXVlc3QiLCJwcm90b3R5cGUiLCJtZXRob2QiLCJ1cmwiLCJhc3luYyIsInVzZXIiLCJwYXNzd29yZCIsInBvcCIsImluY2x1ZGVzIiwicmVkaXJlY3RGZXRjaCIsIl9mZXRjaCIsImZldGNoIiwib3B0cyIsInNldHVwSW50ZXJjZXB0b3JzIiwibWFjaGluZSIsImlzTW9iaWxlRGV2aWNlIiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIm1hdGNoZXMiLCJ1c2VyVmlld1ByZWZlcmVuY2UiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwicHJlZmVyc01vYmlsZSIsInNldEl0ZW0iLCJhdHRhY2hDYWxsQnV0dG9uIiwiZGV0YWNoQ2FsbEJ1dHRvbiIsImFkZFVzZXJBZ2VudEZsYWdzIiwiaXNGaXJlZm94QW5kcm9pZCIsImFkZERldmljZUZsYWdzIiwiYWRkVmlld0ZsYWdzIiwiaW5pdE1vZGUiLCJjcmVhdGVNYWNoaW5lIiwiYXNzaWduIiwiY29udGV4dCIsImF1dG9wbGF5IiwiaW5pdGlhbCIsInN0YXRlcyIsImlkbGUiLCJsb2Fkc3RhcnQiLCJsb2FkaW5nIiwibG9hZGVkbWV0YWRhdGEiLCJsb2FkZWQiLCJyZWFkeSIsImRlc2NyaXB0aW9uIiwiZW50cnkiLCJwYXJhbXMiLCJwbGF5IiwicGxheWluZyIsImV4aXQiLCJwYXVzZSIsImVuZGVkIiwiY2FucGxheXRocm91Z2giLCJpbnRlcm5hbCIsInBhdXNlZCIsInNlZWtlZCIsImVtcHRpZWQiLCJwcmVkaWN0YWJsZUFjdGlvbkFyZ3VtZW50cyIsInByZXNlcnZlQWN0aW9uT3JkZXIiLCJhY3Rpb25zIiwiZW1pdEV2ZW50IiwiX3JlZiIsImFjdGlvbiIsImd1YXJkcyIsInNlcnZpY2VzIiwiZGVsYXlzIiwiX3JlZ2VuZXJhdG9yUnVudGltZSIsImV4cG9ydHMiLCJPcCIsImhhc093biIsImRlZmluZVByb3BlcnR5Iiwib2JqIiwiZGVzYyIsIiRTeW1ib2wiLCJTeW1ib2wiLCJpdGVyYXRvclN5bWJvbCIsIml0ZXJhdG9yIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsInRvU3RyaW5nVGFnIiwiZGVmaW5lIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwid3JhcCIsImlubmVyRm4iLCJvdXRlckZuIiwic2VsZiIsInRyeUxvY3NMaXN0IiwicHJvdG9HZW5lcmF0b3IiLCJHZW5lcmF0b3IiLCJnZW5lcmF0b3IiLCJjcmVhdGUiLCJDb250ZXh0IiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiZm4iLCJhcmciLCJjYWxsIiwiQ29udGludWVTZW50aW5lbCIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUiLCJJdGVyYXRvclByb3RvdHlwZSIsImdldFByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJOYXRpdmVJdGVyYXRvclByb3RvdHlwZSIsInZhbHVlcyIsIkdwIiwiZGVmaW5lSXRlcmF0b3JNZXRob2RzIiwiX2ludm9rZSIsIkFzeW5jSXRlcmF0b3IiLCJQcm9taXNlSW1wbCIsImludm9rZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWNvcmQiLCJyZXN1bHQiLCJfdHlwZW9mIiwiX19hd2FpdCIsInRoZW4iLCJ1bndyYXBwZWQiLCJwcmV2aW91c1Byb21pc2UiLCJjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyIsIkVycm9yIiwiZGVsZWdhdGUiLCJkZWxlZ2F0ZVJlc3VsdCIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsIm1ldGhvZE5hbWUiLCJUeXBlRXJyb3IiLCJyZXN1bHROYW1lIiwibmV4dCIsIm5leHRMb2MiLCJwdXNoVHJ5RW50cnkiLCJsb2NzIiwidHJ5TG9jIiwiY2F0Y2hMb2MiLCJmaW5hbGx5TG9jIiwiYWZ0ZXJMb2MiLCJ0cnlFbnRyaWVzIiwicmVzZXRUcnlFbnRyeSIsImNvbXBsZXRpb24iLCJyZXNldCIsIml0ZXJhYmxlIiwiaXRlcmF0b3JNZXRob2QiLCJpc05hTiIsImRpc3BsYXlOYW1lIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbkZ1biIsImN0b3IiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJtYXJrIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJhd3JhcCIsIlByb21pc2UiLCJpdGVyIiwidmFsIiwib2JqZWN0IiwicmV2ZXJzZSIsInNraXBUZW1wUmVzZXQiLCJwcmV2IiwiY2hhckF0Iiwic2xpY2UiLCJzdG9wIiwicm9vdFJlY29yZCIsInJ2YWwiLCJleGNlcHRpb24iLCJoYW5kbGUiLCJsb2MiLCJjYXVnaHQiLCJoYXNDYXRjaCIsImhhc0ZpbmFsbHkiLCJmaW5hbGx5RW50cnkiLCJjb21wbGV0ZSIsImZpbmlzaCIsIl9jYXRjaCIsInRocm93biIsImRlbGVnYXRlWWllbGQiLCJvIiwiYWxsb3dBcnJheUxpa2UiLCJpdCIsImlzQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJGIiwiX2UiLCJub3JtYWxDb21wbGV0aW9uIiwiZGlkRXJyIiwic3RlcCIsIl9lMiIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJmcm9tIiwiYXJyIiwibGVuIiwiYXJyMiIsImFzeW5jR2VuZXJhdG9yU3RlcCIsImdlbiIsIl9uZXh0IiwiX3Rocm93IiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJzZXJ2ZXJDb25maWciLCJfY2FsbGVlIiwic3RhcnRBdWRpb01vZHVsZSIsImFubm90YXRlRE9NIiwiYWRkSWRQcm9tcHRBbmNlc3RvciIsImFkZElkU3VibWl0QnV0dG9uIiwiYWRkSWRGb290ZXIiLCJhZGRJZEF1ZGlvQ29udHJvbHMiLCJhZGRJZEF1ZGlvT3V0cHV0QnV0dG9uIiwiYWRkVGFsa0J1dHRvbiIsIl9jYWxsZWUkIiwiX2NvbnRleHQiLCJfYWRkVGFsa0J1dHRvbiIsInBhbmVsIiwiY2xhc3NOYW1lcyIsIl9hZGRJZEF1ZGlvT3V0cHV0QnV0dCIsImF1ZGlvQnV0dG9uIiwiX2FkZElkQXVkaW9Db250cm9scyIsImF1ZGlvRWxlbWVudHMiLCJmb3VuZCIsIm5leHREaXYiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJfYWRkSWRGb290ZXIiLCJwcmVjZWRpbmdEaXYiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwibGFzdEVsZW1lbnRDaGlsZCIsIl9hZGRJZFN1Ym1pdEJ1dHRvbiIsInN1Ym1pdEJ1dHRvbnMiLCJsYXN0U3VibWl0QnV0dG9uIiwiX2FkZElkUHJvbXB0QW5jZXN0b3IiLCJwYXJlbnQiLCJwYXJlbnRFbGVtZW50IiwiX2Fubm90YXRlRE9NIiwicHJvbXB0IiwiZm91bmRGb290ZXIiLCJmb3VuZEF1ZGlvQ29udHJvbHMiLCJwcm9tcHRDb250cm9sc0NvbnRhaW5lciIsImZvdW5kUHJvbXB0QW5jZXN0b3IiLCJmb3VuZEF1ZGlvT3V0cHV0QnV0dG9uIiwiX3N0YXJ0QXVkaW9Nb2R1bGUiLCJhdWRpb01vZHVsZSIsImFkZGVkTm9kZXMiLCJub2RlIiwibm9kZU5hbWUiLCJoYXNBdHRyaWJ1dGUiLCJkaXNjb25uZWN0IiwidGV4dGFyZWFzIiwiaW5pdEF1ZGlvT3V0cHV0TGlzdGVuZXIiLCJjaGVja0ZvclJlc3RvcmVQb2ludCIsImNoaWxkTGlzdCIsInN1YnRyZWUiXSwic291cmNlUm9vdCI6IiJ9