// ==UserScript==
// @name         Say, Pi
// @namespace    http://www.saypi.ai/
// @version      1.3.9
// @description  Speak to Pi with OpenAI's Whisper
// @author       Ross Cadogan
// @match        https://pi.ai/talk
// @inject-into  page
// @updateURL    https://app.saypi.ai/saypi.user.js
// @downloadURL  https://app.saypi.ai/saypi.user.js
// @license      MIT
// ==/UserScript==

/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@ricky0123/vad-web/dist/_common/frame-processor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/_common/frame-processor.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
Some of this code, together with the default options found in index.ts,
were taken (or took inspiration) from https://github.com/snakers4/silero-vad
*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FrameProcessor = exports.validateOptions = exports.defaultFrameProcessorOptions = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/@ricky0123/vad-web/dist/_common/messages.js");
const logging_1 = __webpack_require__(/*! ./logging */ "./node_modules/@ricky0123/vad-web/dist/_common/logging.js");
const RECOMMENDED_FRAME_SAMPLES = [512, 1024, 1536];
exports.defaultFrameProcessorOptions = {
    positiveSpeechThreshold: 0.5,
    negativeSpeechThreshold: 0.5 - 0.15,
    preSpeechPadFrames: 1,
    redemptionFrames: 8,
    frameSamples: 1536,
    minSpeechFrames: 3,
};
function validateOptions(options) {
    if (!RECOMMENDED_FRAME_SAMPLES.includes(options.frameSamples)) {
        logging_1.log.warn("You are using an unusual frame size");
    }
    if (options.positiveSpeechThreshold < 0 ||
        options.negativeSpeechThreshold > 1) {
        logging_1.log.error("postiveSpeechThreshold should be a number between 0 and 1");
    }
    if (options.negativeSpeechThreshold < 0 ||
        options.negativeSpeechThreshold > options.positiveSpeechThreshold) {
        logging_1.log.error("negativeSpeechThreshold should be between 0 and postiveSpeechThreshold");
    }
    if (options.preSpeechPadFrames < 0) {
        logging_1.log.error("preSpeechPadFrames should be positive");
    }
    if (options.redemptionFrames < 0) {
        logging_1.log.error("preSpeechPadFrames should be positive");
    }
}
exports.validateOptions = validateOptions;
const concatArrays = (arrays) => {
    const sizes = arrays.reduce((out, next) => {
        out.push(out.at(-1) + next.length);
        return out;
    }, [0]);
    const outArray = new Float32Array(sizes.at(-1));
    arrays.forEach((arr, index) => {
        const place = sizes[index];
        outArray.set(arr, place);
    });
    return outArray;
};
class FrameProcessor {
    constructor(modelProcessFunc, modelResetFunc, options) {
        this.modelProcessFunc = modelProcessFunc;
        this.modelResetFunc = modelResetFunc;
        this.options = options;
        this.speaking = false;
        this.redemptionCounter = 0;
        this.active = false;
        this.reset = () => {
            this.speaking = false;
            this.audioBuffer = [];
            this.modelResetFunc();
            this.redemptionCounter = 0;
        };
        this.pause = () => {
            this.active = false;
            this.reset();
        };
        this.resume = () => {
            this.active = true;
        };
        this.endSegment = () => {
            const audioBuffer = this.audioBuffer;
            this.audioBuffer = [];
            const speaking = this.speaking;
            this.reset();
            const speechFrameCount = audioBuffer.reduce((acc, item) => {
                return acc + +item.isSpeech;
            }, 0);
            if (speaking) {
                if (speechFrameCount >= this.options.minSpeechFrames) {
                    const audio = concatArrays(audioBuffer.map((item) => item.frame));
                    return { msg: messages_1.Message.SpeechEnd, audio };
                }
                else {
                    return { msg: messages_1.Message.VADMisfire };
                }
            }
            return {};
        };
        this.process = async (frame) => {
            if (!this.active) {
                return {};
            }
            const probs = await this.modelProcessFunc(frame);
            this.audioBuffer.push({
                frame,
                isSpeech: probs.isSpeech >= this.options.positiveSpeechThreshold,
            });
            if (probs.isSpeech >= this.options.positiveSpeechThreshold &&
                this.redemptionCounter) {
                this.redemptionCounter = 0;
            }
            if (probs.isSpeech >= this.options.positiveSpeechThreshold &&
                !this.speaking) {
                this.speaking = true;
                return { probs, msg: messages_1.Message.SpeechStart };
            }
            if (probs.isSpeech < this.options.negativeSpeechThreshold &&
                this.speaking &&
                ++this.redemptionCounter >= this.options.redemptionFrames) {
                this.redemptionCounter = 0;
                this.speaking = false;
                const audioBuffer = this.audioBuffer;
                this.audioBuffer = [];
                const speechFrameCount = audioBuffer.reduce((acc, item) => {
                    return acc + +item.isSpeech;
                }, 0);
                if (speechFrameCount >= this.options.minSpeechFrames) {
                    const audio = concatArrays(audioBuffer.map((item) => item.frame));
                    return { probs, msg: messages_1.Message.SpeechEnd, audio };
                }
                else {
                    return { probs, msg: messages_1.Message.VADMisfire };
                }
            }
            if (!this.speaking) {
                while (this.audioBuffer.length > this.options.preSpeechPadFrames) {
                    this.audioBuffer.shift();
                }
            }
            return { probs };
        };
        this.audioBuffer = [];
        this.reset();
    }
}
exports.FrameProcessor = FrameProcessor;
//# sourceMappingURL=frame-processor.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/_common/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/_common/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.utils = void 0;
const _utils = __importStar(__webpack_require__(/*! ./utils */ "./node_modules/@ricky0123/vad-web/dist/_common/utils.js"));
exports.utils = {
    minFramesForTargetMS: _utils.minFramesForTargetMS,
    arrayBufferToBase64: _utils.arrayBufferToBase64,
    encodeWAV: _utils.encodeWAV,
};
__exportStar(__webpack_require__(/*! ./non-real-time-vad */ "./node_modules/@ricky0123/vad-web/dist/_common/non-real-time-vad.js"), exports);
__exportStar(__webpack_require__(/*! ./frame-processor */ "./node_modules/@ricky0123/vad-web/dist/_common/frame-processor.js"), exports);
__exportStar(__webpack_require__(/*! ./messages */ "./node_modules/@ricky0123/vad-web/dist/_common/messages.js"), exports);
__exportStar(__webpack_require__(/*! ./logging */ "./node_modules/@ricky0123/vad-web/dist/_common/logging.js"), exports);
__exportStar(__webpack_require__(/*! ./models */ "./node_modules/@ricky0123/vad-web/dist/_common/models.js"), exports);
__exportStar(__webpack_require__(/*! ./resampler */ "./node_modules/@ricky0123/vad-web/dist/_common/resampler.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/_common/logging.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/_common/logging.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.log = exports.LOG_PREFIX = void 0;
exports.LOG_PREFIX = "[VAD]";
const levels = ["error", "debug", "warn"];
function getLog(level) {
    return (...args) => {
        console[level](exports.LOG_PREFIX, ...args);
    };
}
const _log = levels.reduce((acc, level) => {
    acc[level] = getLog(level);
    return acc;
}, {});
exports.log = _log;
//# sourceMappingURL=logging.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/_common/messages.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/_common/messages.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Message = void 0;
var Message;
(function (Message) {
    Message["AudioFrame"] = "AUDIO_FRAME";
    Message["SpeechStart"] = "SPEECH_START";
    Message["VADMisfire"] = "VAD_MISFIRE";
    Message["SpeechEnd"] = "SPEECH_END";
})(Message = exports.Message || (exports.Message = {}));
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/_common/models.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/_common/models.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Silero = void 0;
// @ts-ignore
const logging_1 = __webpack_require__(/*! ./logging */ "./node_modules/@ricky0123/vad-web/dist/_common/logging.js");
class Silero {
    constructor(ort, modelFetcher) {
        this.ort = ort;
        this.modelFetcher = modelFetcher;
        this.init = async () => {
            logging_1.log.debug("initializing vad");
            const modelArrayBuffer = await this.modelFetcher();
            this._session = await this.ort.InferenceSession.create(modelArrayBuffer);
            this._sr = new this.ort.Tensor("int64", [16000n]);
            this.reset_state();
            logging_1.log.debug("vad is initialized");
        };
        this.reset_state = () => {
            const zeroes = Array(2 * 64).fill(0);
            this._h = new this.ort.Tensor("float32", zeroes, [2, 1, 64]);
            this._c = new this.ort.Tensor("float32", zeroes, [2, 1, 64]);
        };
        this.process = async (audioFrame) => {
            const t = new this.ort.Tensor("float32", audioFrame, [1, audioFrame.length]);
            const inputs = {
                input: t,
                h: this._h,
                c: this._c,
                sr: this._sr,
            };
            const out = await this._session.run(inputs);
            this._h = out.hn;
            this._c = out.cn;
            const [isSpeech] = out.output.data;
            const notSpeech = 1 - isSpeech;
            return { notSpeech, isSpeech };
        };
    }
}
exports.Silero = Silero;
_a = Silero;
Silero.new = async (ort, modelFetcher) => {
    const model = new Silero(ort, modelFetcher);
    await model.init();
    return model;
};
//# sourceMappingURL=models.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/_common/non-real-time-vad.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/_common/non-real-time-vad.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlatformAgnosticNonRealTimeVAD = exports.defaultNonRealTimeVADOptions = void 0;
const frame_processor_1 = __webpack_require__(/*! ./frame-processor */ "./node_modules/@ricky0123/vad-web/dist/_common/frame-processor.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/@ricky0123/vad-web/dist/_common/messages.js");
const models_1 = __webpack_require__(/*! ./models */ "./node_modules/@ricky0123/vad-web/dist/_common/models.js");
const resampler_1 = __webpack_require__(/*! ./resampler */ "./node_modules/@ricky0123/vad-web/dist/_common/resampler.js");
exports.defaultNonRealTimeVADOptions = {
    ...frame_processor_1.defaultFrameProcessorOptions,
};
class PlatformAgnosticNonRealTimeVAD {
    static async _new(modelFetcher, ort, options = {}) {
        const vad = new this(modelFetcher, ort, {
            ...exports.defaultNonRealTimeVADOptions,
            ...options,
        });
        await vad.init();
        return vad;
    }
    constructor(modelFetcher, ort, options) {
        this.modelFetcher = modelFetcher;
        this.ort = ort;
        this.options = options;
        this.init = async () => {
            const model = await models_1.Silero.new(this.ort, this.modelFetcher);
            this.frameProcessor = new frame_processor_1.FrameProcessor(model.process, model.reset_state, {
                frameSamples: this.options.frameSamples,
                positiveSpeechThreshold: this.options.positiveSpeechThreshold,
                negativeSpeechThreshold: this.options.negativeSpeechThreshold,
                redemptionFrames: this.options.redemptionFrames,
                preSpeechPadFrames: this.options.preSpeechPadFrames,
                minSpeechFrames: this.options.minSpeechFrames,
            });
            this.frameProcessor.resume();
        };
        this.run = async function* (inputAudio, sampleRate) {
            const resamplerOptions = {
                nativeSampleRate: sampleRate,
                targetSampleRate: 16000,
                targetFrameSize: this.options.frameSamples,
            };
            const resampler = new resampler_1.Resampler(resamplerOptions);
            const frames = resampler.process(inputAudio);
            let start, end;
            for (const i of [...Array(frames.length)].keys()) {
                const f = frames[i];
                const { msg, audio } = await this.frameProcessor.process(f);
                switch (msg) {
                    case messages_1.Message.SpeechStart:
                        start = (i * this.options.frameSamples) / 16;
                        break;
                    case messages_1.Message.SpeechEnd:
                        end = ((i + 1) * this.options.frameSamples) / 16;
                        // @ts-ignore
                        yield { audio, start, end };
                        break;
                    default:
                        break;
                }
            }
            const { msg, audio } = this.frameProcessor.endSegment();
            if (msg == messages_1.Message.SpeechEnd) {
                yield {
                    audio,
                    // @ts-ignore
                    start,
                    end: (frames.length * this.options.frameSamples) / 16,
                };
            }
        };
        (0, frame_processor_1.validateOptions)(options);
    }
}
exports.PlatformAgnosticNonRealTimeVAD = PlatformAgnosticNonRealTimeVAD;
//# sourceMappingURL=non-real-time-vad.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/_common/resampler.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/_common/resampler.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Resampler = void 0;
const logging_1 = __webpack_require__(/*! ./logging */ "./node_modules/@ricky0123/vad-web/dist/_common/logging.js");
class Resampler {
    constructor(options) {
        this.options = options;
        this.process = (audioFrame) => {
            const outputFrames = [];
            for (const sample of audioFrame) {
                this.inputBuffer.push(sample);
            }
            while ((this.inputBuffer.length * this.options.targetSampleRate) /
                this.options.nativeSampleRate >
                this.options.targetFrameSize) {
                const outputFrame = new Float32Array(this.options.targetFrameSize);
                let outputIndex = 0;
                let inputIndex = 0;
                while (outputIndex < this.options.targetFrameSize) {
                    let sum = 0;
                    let num = 0;
                    while (inputIndex <
                        Math.min(this.inputBuffer.length, ((outputIndex + 1) * this.options.nativeSampleRate) /
                            this.options.targetSampleRate)) {
                        sum += this.inputBuffer[inputIndex];
                        num++;
                        inputIndex++;
                    }
                    outputFrame[outputIndex] = sum / num;
                    outputIndex++;
                }
                this.inputBuffer = this.inputBuffer.slice(inputIndex);
                outputFrames.push(outputFrame);
            }
            return outputFrames;
        };
        if (options.nativeSampleRate < 16000) {
            logging_1.log.error("nativeSampleRate is too low. Should have 16000 = targetSampleRate <= nativeSampleRate");
        }
        this.inputBuffer = [];
    }
}
exports.Resampler = Resampler;
//# sourceMappingURL=resampler.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/_common/utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/_common/utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeWAV = exports.arrayBufferToBase64 = exports.minFramesForTargetMS = void 0;
function minFramesForTargetMS(targetDuration, frameSamples, sr = 16000) {
    return Math.ceil((targetDuration * sr) / 1000 / frameSamples);
}
exports.minFramesForTargetMS = minFramesForTargetMS;
function arrayBufferToBase64(buffer) {
    var binary = "";
    var bytes = new Uint8Array(buffer);
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}
exports.arrayBufferToBase64 = arrayBufferToBase64;
/*
This rest of this was mostly copied from https://github.com/linto-ai/WebVoiceSDK
*/
function encodeWAV(samples, format = 3, sampleRate = 16000, numChannels = 1, bitDepth = 32) {
    var bytesPerSample = bitDepth / 8;
    var blockAlign = numChannels * bytesPerSample;
    var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
    var view = new DataView(buffer);
    /* RIFF identifier */
    writeString(view, 0, "RIFF");
    /* RIFF chunk length */
    view.setUint32(4, 36 + samples.length * bytesPerSample, true);
    /* RIFF type */
    writeString(view, 8, "WAVE");
    /* format chunk identifier */
    writeString(view, 12, "fmt ");
    /* format chunk length */
    view.setUint32(16, 16, true);
    /* sample format (raw) */
    view.setUint16(20, format, true);
    /* channel count */
    view.setUint16(22, numChannels, true);
    /* sample rate */
    view.setUint32(24, sampleRate, true);
    /* byte rate (sample rate * block align) */
    view.setUint32(28, sampleRate * blockAlign, true);
    /* block align (channel count * bytes per sample) */
    view.setUint16(32, blockAlign, true);
    /* bits per sample */
    view.setUint16(34, bitDepth, true);
    /* data chunk identifier */
    writeString(view, 36, "data");
    /* data chunk length */
    view.setUint32(40, samples.length * bytesPerSample, true);
    if (format === 1) {
        // Raw PCM
        floatTo16BitPCM(view, 44, samples);
    }
    else {
        writeFloat32(view, 44, samples);
    }
    return buffer;
}
exports.encodeWAV = encodeWAV;
function interleave(inputL, inputR) {
    var length = inputL.length + inputR.length;
    var result = new Float32Array(length);
    var index = 0;
    var inputIndex = 0;
    while (index < length) {
        result[index++] = inputL[inputIndex];
        result[index++] = inputR[inputIndex];
        inputIndex++;
    }
    return result;
}
function writeFloat32(output, offset, input) {
    for (var i = 0; i < input.length; i++, offset += 4) {
        output.setFloat32(offset, input[i], true);
    }
}
function floatTo16BitPCM(output, offset, input) {
    for (var i = 0; i < input.length; i++, offset += 2) {
        var s = Math.max(-1, Math.min(1, input[i]));
        output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
    }
}
function writeString(view, offset, string) {
    for (var i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/asset-path.js":
/*!************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/asset-path.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assetPath = void 0;
const currentScript = window.document.currentScript;
let basePath = "";
if (currentScript) {
    basePath = currentScript.src
        .replace(/#.*$/, "")
        .replace(/\?.*$/, "")
        .replace(/\/[^\/]+$/, "/");
}
const assetPath = (file) => {
    return basePath + file;
};
exports.assetPath = assetPath;
//# sourceMappingURL=asset-path.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultRealTimeVADOptions = exports.AudioNodeVAD = exports.MicVAD = exports.NonRealTimeVAD = exports.Message = exports.FrameProcessor = exports.utils = void 0;
const ort = __importStar(__webpack_require__(/*! onnxruntime-web */ "./node_modules/onnxruntime-web/dist/ort.min.js"));
const _common_1 = __webpack_require__(/*! ./_common */ "./node_modules/@ricky0123/vad-web/dist/_common/index.js");
Object.defineProperty(exports, "FrameProcessor", ({ enumerable: true, get: function () { return _common_1.FrameProcessor; } }));
Object.defineProperty(exports, "Message", ({ enumerable: true, get: function () { return _common_1.Message; } }));
const model_fetcher_1 = __webpack_require__(/*! ./model-fetcher */ "./node_modules/@ricky0123/vad-web/dist/model-fetcher.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@ricky0123/vad-web/dist/utils.js");
class NonRealTimeVAD extends _common_1.PlatformAgnosticNonRealTimeVAD {
    static async new(options = {}) {
        return await this._new(model_fetcher_1.modelFetcher, ort, options);
    }
}
exports.NonRealTimeVAD = NonRealTimeVAD;
exports.utils = { audioFileToArray: utils_1.audioFileToArray, ..._common_1.utils };
var real_time_vad_1 = __webpack_require__(/*! ./real-time-vad */ "./node_modules/@ricky0123/vad-web/dist/real-time-vad.js");
Object.defineProperty(exports, "MicVAD", ({ enumerable: true, get: function () { return real_time_vad_1.MicVAD; } }));
Object.defineProperty(exports, "AudioNodeVAD", ({ enumerable: true, get: function () { return real_time_vad_1.AudioNodeVAD; } }));
Object.defineProperty(exports, "defaultRealTimeVADOptions", ({ enumerable: true, get: function () { return real_time_vad_1.defaultRealTimeVADOptions; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/model-fetcher.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/model-fetcher.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.modelFetcher = void 0;
const asset_path_1 = __webpack_require__(/*! ./asset-path */ "./node_modules/@ricky0123/vad-web/dist/asset-path.js");
const modelFetcher = async () => {
    const modelURL = (0, asset_path_1.assetPath)("silero_vad.onnx");
    return await fetch(modelURL).then((r) => r.arrayBuffer());
};
exports.modelFetcher = modelFetcher;
//# sourceMappingURL=model-fetcher.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/real-time-vad.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/real-time-vad.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AudioNodeVAD = exports.MicVAD = exports.defaultRealTimeVADOptions = void 0;
const ort = __importStar(__webpack_require__(/*! onnxruntime-web */ "./node_modules/onnxruntime-web/dist/ort.min.js"));
const _common_1 = __webpack_require__(/*! ./_common */ "./node_modules/@ricky0123/vad-web/dist/_common/index.js");
const model_fetcher_1 = __webpack_require__(/*! ./model-fetcher */ "./node_modules/@ricky0123/vad-web/dist/model-fetcher.js");
const asset_path_1 = __webpack_require__(/*! ./asset-path */ "./node_modules/@ricky0123/vad-web/dist/asset-path.js");
const _getWorkletURL = () => {
    return (0, asset_path_1.assetPath)("vad.worklet.bundle.min.js");
};
exports.defaultRealTimeVADOptions = {
    ..._common_1.defaultFrameProcessorOptions,
    onFrameProcessed: (probabilities) => { },
    onVADMisfire: () => {
        _common_1.log.debug("VAD misfire");
    },
    onSpeechStart: () => {
        _common_1.log.debug("Detected speech start");
    },
    onSpeechEnd: () => {
        _common_1.log.debug("Detected speech end");
    },
    workletURL: _getWorkletURL(),
    stream: undefined,
};
class MicVAD {
    static async new(options = {}) {
        const vad = new MicVAD({ ...exports.defaultRealTimeVADOptions, ...options });
        await vad.init();
        return vad;
    }
    constructor(options) {
        this.options = options;
        this.listening = false;
        this.init = async () => {
            if (this.options.stream === undefined)
                this.stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        ...this.options.additionalAudioConstraints,
                        channelCount: 1,
                        echoCancellation: true,
                        autoGainControl: true,
                        noiseSuppression: true,
                    },
                });
            else
                this.stream = this.options.stream;
            this.audioContext = new AudioContext();
            const source = new MediaStreamAudioSourceNode(this.audioContext, {
                mediaStream: this.stream,
            });
            this.audioNodeVAD = await AudioNodeVAD.new(this.audioContext, this.options);
            this.audioNodeVAD.receive(source);
        };
        this.pause = () => {
            this.audioNodeVAD.pause();
            this.listening = false;
        };
        this.start = () => {
            this.audioNodeVAD.start();
            this.listening = true;
        };
        (0, _common_1.validateOptions)(options);
    }
}
exports.MicVAD = MicVAD;
class AudioNodeVAD {
    static async new(ctx, options = {}) {
        const vad = new AudioNodeVAD(ctx, {
            ...exports.defaultRealTimeVADOptions,
            ...options,
        });
        await vad.init();
        return vad;
    }
    constructor(ctx, options) {
        this.ctx = ctx;
        this.options = options;
        this.pause = () => {
            this.frameProcessor.pause();
        };
        this.start = () => {
            this.frameProcessor.resume();
        };
        this.receive = (node) => {
            node.connect(this.entryNode);
        };
        this.processFrame = async (frame) => {
            const { probs, msg, audio } = await this.frameProcessor.process(frame);
            if (probs !== undefined) {
                this.options.onFrameProcessed(probs);
            }
            switch (msg) {
                case _common_1.Message.SpeechStart:
                    this.options.onSpeechStart();
                    break;
                case _common_1.Message.VADMisfire:
                    this.options.onVADMisfire();
                    break;
                case _common_1.Message.SpeechEnd:
                    // @ts-ignore
                    this.options.onSpeechEnd(audio);
                    break;
                default:
                    break;
            }
        };
        this.init = async () => {
            await this.ctx.audioWorklet.addModule(this.options.workletURL);
            const vadNode = new AudioWorkletNode(this.ctx, "vad-helper-worklet", {
                processorOptions: {
                    frameSamples: this.options.frameSamples,
                },
            });
            this.entryNode = vadNode;
            const model = await _common_1.Silero.new(ort, model_fetcher_1.modelFetcher);
            this.frameProcessor = new _common_1.FrameProcessor(model.process, model.reset_state, {
                frameSamples: this.options.frameSamples,
                positiveSpeechThreshold: this.options.positiveSpeechThreshold,
                negativeSpeechThreshold: this.options.negativeSpeechThreshold,
                redemptionFrames: this.options.redemptionFrames,
                preSpeechPadFrames: this.options.preSpeechPadFrames,
                minSpeechFrames: this.options.minSpeechFrames,
            });
            vadNode.port.onmessage = async (ev) => {
                switch (ev.data?.message) {
                    case _common_1.Message.AudioFrame:
                        const buffer = ev.data.data;
                        const frame = new Float32Array(buffer);
                        await this.processFrame(frame);
                        break;
                    default:
                        break;
                }
            };
        };
        (0, _common_1.validateOptions)(options);
    }
}
exports.AudioNodeVAD = AudioNodeVAD;
//# sourceMappingURL=real-time-vad.js.map

/***/ }),

/***/ "./node_modules/@ricky0123/vad-web/dist/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@ricky0123/vad-web/dist/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.audioFileToArray = void 0;
async function audioFileToArray(audioFileData) {
    const ctx = new OfflineAudioContext(1, 1, 44100);
    const reader = new FileReader();
    let audioBuffer = null;
    await new Promise((res) => {
        reader.addEventListener("loadend", (ev) => {
            const audioData = reader.result;
            ctx.decodeAudioData(audioData, (buffer) => {
                audioBuffer = buffer;
                ctx
                    .startRendering()
                    .then((renderedBuffer) => {
                    console.log("Rendering completed successfully");
                    res();
                })
                    .catch((err) => {
                    console.error(`Rendering failed: ${err}`);
                });
            }, (e) => {
                console.log(`Error with decoding audio data: ${e}`);
            });
        });
        reader.readAsArrayBuffer(audioFileData);
    });
    if (audioBuffer === null) {
        throw Error("some shit");
    }
    let _audioBuffer = audioBuffer;
    let out = new Float32Array(_audioBuffer.length);
    for (let i = 0; i < _audioBuffer.length; i++) {
        for (let j = 0; j < _audioBuffer.numberOfChannels; j++) {
            // @ts-ignore
            out[i] += _audioBuffer.getChannelData(j)[i];
        }
    }
    return { audio: out, sampleRate: _audioBuffer.sampleRate };
}
exports.audioFileToArray = audioFileToArray;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./src/ConfigModule.js":
/*!*****************************!*\
  !*** ./src/ConfigModule.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   config: () => (/* binding */ config)
/* harmony export */ });
var config = {
  appServerUrl: "https://localhost:4443",
  apiServerUrl: "http://localhost:8080"
};

/***/ }),

/***/ "./src/LoggingModule.js":
/*!******************************!*\
  !*** ./src/LoggingModule.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   serializeStateValue: () => (/* binding */ serializeStateValue)
/* harmony export */ });
function serializeStateValue(stateValue) {
  if (typeof stateValue === "string") {
    return stateValue;
  }
  return Object.keys(stateValue).map(function (key) {
    return "".concat(key, ":").concat(serializeStateValue(stateValue[key]));
  }).join(",");
}

/***/ }),

/***/ "./src/RequestInterceptor.js":
/*!***********************************!*\
  !*** ./src/RequestInterceptor.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setupInterceptors: () => (/* binding */ setupInterceptors)
/* harmony export */ });
/* harmony import */ var _ConfigModule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConfigModule */ "./src/ConfigModule.js");

var filesToRedirect = ["silero_vad.onnx", "ort-wasm-simd.wasm", "ort.min.js.map"];

// Function to redirect specific XMLHttpRequests
function redirectXMLHttpRequest(open) {
  XMLHttpRequest.prototype.open = function (method, url, async, user, password) {
    var filename = url.split("/").pop();
    if (filename && filesToRedirect.includes(filename)) {
      arguments[1] = "".concat(_ConfigModule__WEBPACK_IMPORTED_MODULE_0__.config.appServerUrl, "/").concat(filename);
    }
    open.apply(this, arguments);
  };
}

// Function to redirect specific fetch requests
function redirectFetch(_fetch) {
  window.fetch = function (url, opts) {
    var filename = url.split("/").pop();
    if (filename && filesToRedirect.includes(filename)) {
      arguments[0] = "".concat(_ConfigModule__WEBPACK_IMPORTED_MODULE_0__.config.appServerUrl, "/").concat(filename);
    }
    return _fetch.apply(this, arguments);
  };
}

// Function to set up the interceptors
function setupInterceptors() {
  redirectXMLHttpRequest(XMLHttpRequest.prototype.open);
  redirectFetch(window.fetch);
}

/***/ }),

/***/ "./src/UserAgentModule.js":
/*!********************************!*\
  !*** ./src/UserAgentModule.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addDeviceFlags: () => (/* binding */ addDeviceFlags),
/* harmony export */   addUserAgentFlags: () => (/* binding */ addUserAgentFlags),
/* harmony export */   addViewFlags: () => (/* binding */ addViewFlags),
/* harmony export */   enterMobileMode: () => (/* binding */ enterMobileMode),
/* harmony export */   exitMobileMode: () => (/* binding */ exitMobileMode),
/* harmony export */   isMobileDevice: () => (/* binding */ isMobileDevice),
/* harmony export */   isMobileView: () => (/* binding */ isMobileView),
/* harmony export */   isSafari: () => (/* binding */ isSafari)
/* harmony export */ });
function isSafari() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.matchMedia("(max-width: 768px)").matches;
}

// this function determines whether to show the mobile view or not
function isMobileView() {
  var userViewPreference = null;
  try {
    userViewPreference = localStorage.getItem("userViewPreference");
  } catch (e) {
    console.warn("Could not access localStorage: ", e);
  }
  var prefersMobile = false;
  if (userViewPreference) {
    prefersMobile = userViewPreference === "mobile";
  }

  // Make sure isMobileDevice is defined or imported
  return isMobileDevice() && prefersMobile;
}
function exitMobileMode() {
  localStorage.setItem("userViewPreference", "desktop"); // Save preference

  var element = document.documentElement;
  element.classList.remove("mobile-view");
  element.classList.add("desktop-view");
}
function enterMobileMode() {
  localStorage.setItem("userViewPreference", "mobile"); // Save preference

  var element = document.documentElement;
  element.classList.remove("desktop-view");
  element.classList.add("mobile-view");
}
function addUserAgentFlags() {
  var isFirefoxAndroid = /Firefox/.test(navigator.userAgent) && /Android/.test(navigator.userAgent);
  var element = document.documentElement;
  if (isFirefoxAndroid) {
    element.classList.add("firefox-android");
  }
  addDeviceFlags(element);
  addViewFlags(element);
}
function addDeviceFlags(element) {
  if (isMobileDevice()) {
    element.classList.add("mobile-device");
  }
}
function addViewFlags(element) {
  if (isMobileView()) {
    element.classList.remove("desktop-view");
    element.classList.add("mobile-view");
  } else {
    element.classList.remove("mobile-view");
    element.classList.add("desktop-view");
  }
}

/***/ }),

/***/ "./src/state-machines/AudioInputMachine.js":
/*!*************************************************!*\
  !*** ./src/state-machines/AudioInputMachine.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   audioInputMachine: () => (/* binding */ audioInputMachine)
/* harmony export */ });
/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xstate */ "./node_modules/xstate/es/actions.js");
/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! xstate */ "./node_modules/xstate/es/Machine.js");
/* harmony import */ var _ricky0123_vad_web__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ricky0123/vad-web */ "./node_modules/@ricky0123/vad-web/dist/index.js");
/* harmony import */ var _ricky0123_vad_web__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ricky0123_vad_web__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _ConfigModule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ConfigModule */ "./src/ConfigModule.js");
/* harmony import */ var _RequestInterceptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../RequestInterceptor */ "./src/RequestInterceptor.js");
/* harmony import */ var _AudioEncoder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../AudioEncoder */ "./src/AudioEncoder.ts");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return { value: void 0, done: !0 }; } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable || "" === iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } throw new TypeError(_typeof(iterable) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var log = xstate__WEBPACK_IMPORTED_MODULE_0__.log;





/* set URLs for VAD resources */
(0,_RequestInterceptor__WEBPACK_IMPORTED_MODULE_3__.setupInterceptors)();
var fullWorkletURL = "".concat(_ConfigModule__WEBPACK_IMPORTED_MODULE_2__.config.appServerUrl, "/vad.worklet.bundle.min.js");
var EventBus = window.EventBus;
var audioMimeType = "audio/wav";
var speechStartTime = 0;
var threshold = 1000; // 1000 ms = 1 second, about the length of "Hey, Pi"

var microphone;
function setupRecording(_x) {
  return _setupRecording.apply(this, arguments);
}
function _setupRecording() {
  _setupRecording = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(callback) {
    var stream;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (!microphone) {
            _context.next = 2;
            break;
          }
          return _context.abrupt("return");
        case 2:
          _context.prev = 2;
          _context.next = 5;
          return navigator.mediaDevices.getUserMedia({
            audio: {
              channelCount: 1,
              echoCancellation: true,
              autoGainControl: true,
              noiseSuppression: true
            }
          });
        case 5:
          stream = _context.sent;
          _context.next = 8;
          return _ricky0123_vad_web__WEBPACK_IMPORTED_MODULE_1__.MicVAD["new"]({
            workletURL: fullWorkletURL,
            stream: stream,
            positiveSpeechThreshold: 0.8,
            minSpeechFrames: 5,
            preSpeechPadFrames: 10,
            onSpeechStart: function onSpeechStart() {
              console.log("Speech started");
              speechStartTime = Date.now();
            },
            onSpeechEnd: function onSpeechEnd(rawAudioData) {
              console.log("Speech ended");
              var audioBlob = (0,_AudioEncoder__WEBPACK_IMPORTED_MODULE_4__.convertToWavBlob)(rawAudioData);
              EventBus.emit("audio:dataavailable", {
                blob: audioBlob
              });
            },
            onVADMisfire: function onVADMisfire() {
              console.log("VAD misfire. Audio was not speech.");
            }
          });
        case 8:
          microphone = _context.sent;
          if (typeof callback === "function") {
            callback();
          }
          _context.next = 15;
          break;
        case 12:
          _context.prev = 12;
          _context.t0 = _context["catch"](2);
          console.error("VAD failed to load", _context.t0);
        case 15:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[2, 12]]);
  }));
  return _setupRecording.apply(this, arguments);
}
function tearDownRecording() {
  if (microphone) {
    microphone.pause();
  }
  microphone = null;
}
var audioInputMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_5__.createMachine)({
  /** @xstate-layout N4IgpgJg5mDOIC5QEMCuECWB7AkgOwAdUAXAOgCcwAbMZWSAYmQGMBHVDSgbQAYBdRKAJZYGYtjyCQAD0QBGAGwBmUgFYANCACeiJXIAcpBQHYAnAtP6l+gCw2lAJgU2Avi81pMuQiVIt2nBh4UAwQWHhgpEEAblgA1pGe2PhEZP4c5EFQCDFYzMji4bx8xVLCooWSSDKIqg6aOgj6xnJqCqo8qtbKpjwODm4e6Mk+aWwZWQxg5ORY5KQEVAUAZnMAtn7D3ql+44HBOXix+ZXFpdXlYhJSsghyxioa2oj9qqT97Q-Wdo4KgyBJba+dKcRiUGh0MDnIQiK7hG7yB5qBqIfStDo8HhyHj6Wz2Jxyf6AlLAvaUCBRCA0BiwYjIcjEaEgS6VBEIGxyFSWezGJ6NfTmUhyVQKRSmbFKZQtIlbEljALkihgZhzTDBGnELAEABKYHYcGIkCZLOu1VuJgUaiUvQUDj5iHFrRsAo6DnsFmMnRlXjluwVkCVKvIapCEAKyAAgtFkBglgAjGjG2Gss21Bw8NT6VSmJS8lFNO2kGwOcw8BQKHiS3OE9wA2WjP0ZAMEMB4EMAZU1BA1WqTFVNoFucjkOaMdvzphspiFjgeikrUprQx9DZBipbbayna1oXDUZj8cT-DKyYHNQQk5UVnTenHzwLb1MJYr5YX1e9Ix2a4DtK1LYgDB9nCVSDvII4qLa9oIJ6bz3OYSjOjYXTGKKbi1ngWAQHAUjEqMJ79vCqYIAAtAo+bEY+phUbyPDFs4T6obWuE7OCtD0BA+HAWyxb5sONhGFiqhfHivxLnWK5fmSWScSmoHsumRiIbmUH9NOw6WH0qiqNiVFKB+QLyk2HEXKehFyQ4+gOEWtjKfmQkqHBr6CdpSiqPpvrfhSGBUmAMlnrcShKBmSl5ve4rTsoDhzhWVbSkx9aSf6FKUEGIZ+WZ55dJaJgGKFjQMaQuJRXoMWLu5q5ks2rYdl26UgeetjTlRDi5VBT7GKQ1jFfOsVicxpJJaQv4EP+dVsnIJatBZE2epOWZOG1E2kC0Fb6AoVi5mWaEuEAA */
  context: {
    waitingToStop: false
  },
  id: "audioInput",
  initial: "released",
  states: {
    released: {
      on: {
        acquire: {
          target: "acquiring"
        }
      }
    },
    acquiring: {
      description: "Acquiring the microphone. Waits until asynchronous call has completed.",
      invoke: {
        src: "acquireMicrophone",
        onDone: {
          target: "acquired"
        },
        onError: {
          target: "released",
          actions: "logError"
        }
      }
    },
    acquired: {
      description: "Microphone acquired and ready to start recording.",
      initial: "idle",
      states: {
        idle: {
          on: {
            start: {
              target: "recording",
              actions: {
                type: "startRecording",
                cond: "microphoneAcquired"
              }
            }
          }
        },
        recording: {
          on: {
            stopRequested: {
              target: "pendingStop"
            },
            dataAvailable: {
              actions: {
                type: "sendData",
                params: {}
              },
              internal: true
            }
          }
        },
        pendingStop: {
          description: "Waiting for the media recording device to stop recording.",
          on: {
            stop: {
              target: "stopped"
            },
            dataAvailable: {
              target: "stopped",
              actions: {
                type: "sendData",
                params: {}
              }
            }
          },
          entry: "prepareStop"
        },
        stopped: {
          entry: "notifyStopped",
          always: "idle"
        }
      },
      on: {
        release: {
          target: "released",
          actions: {
            type: "releaseMicrophone"
          }
        }
      }
    }
  },
  predictableActionArguments: true,
  preserveActionOrder: true
}, {
  actions: {
    startRecording: function startRecording(context, event) {
      context.recordingStartTime = Date.now();

      // Start recording
      if (microphone && microphone.listening === false) {
        microphone.start();
      }
      EventBus.emit("saypi:userSpeaking");
    },
    prepareStop: function prepareStop(context, event) {
      if (microphone && microphone.listening === true) {
        context.waitingToStop = true;
      }
    },
    notifyStopped: function notifyStopped(context, event) {
      var recordingStopTime = Date.now();
      var recordingDuration = recordingStopTime - context.recordingStartTime;
      EventBus.emit("saypi:userFinishedSpeaking", {
        durationRecording: recordingDuration
      });
    },
    sendData: function sendData(context, event) {
      var audioBlob = event.blob;
      var sizeInKb = (audioBlob.byteLength / 1024).toFixed(2); // Convert to kilobytes and keep 2 decimal places
      console.log("Sending ".concat(sizeInKb, "kb of audio data to server"));
      if (context.waitingToStop === true) {
        microphone.pause();
        context.waitingToStop = false;
      }

      // Get the stop time and calculate the duration
      var speechStopTime = Date.now();
      var speechDuration = speechStopTime - speechStartTime;

      // If the duration is greater than the threshold, upload the audio for transcription
      if (sizeInKb > 0) {
        // Upload the audio to the server for transcription
        EventBus.emit("saypi:userStoppedSpeaking", {
          duration: speechDuration,
          blob: audioBlob
        });
      }
    },
    releaseMicrophone: function releaseMicrophone(context, event) {
      tearDownRecording();
    },
    logError: function logError(context, event) {
      console.error("Error acquiring microphone: ", event.data);
    }
  },
  services: {
    acquireMicrophone: function acquireMicrophone(context, event, _ref) {
      var send = _ref.send;
      return new Promise(function (resolve, reject) {
        setupRecording(function () {
          if (microphone) {
            resolve();
          } else {
            reject(new Error("Failed to acquire microphone resource."));
          }
        });
      });
    }
  },
  guards: {
    microphoneAcquired: function microphoneAcquired(context, event) {
      return microphone !== null;
    },
    hasData: function hasData(context, event) {
      return context.audioDataChunks.length > 0;
    }
  },
  delays: {}
});

/***/ }),

/***/ "./src/state-machines/AudioOutputMachine.js":
/*!**************************************************!*\
  !*** ./src/state-machines/AudioOutputMachine.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   audioOutputMachine: () => (/* binding */ audioOutputMachine)
/* harmony export */ });
/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xstate */ "./node_modules/xstate/es/Machine.js");
/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! xstate */ "./node_modules/xstate/es/index.js");
/* harmony import */ var _UserAgentModule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../UserAgentModule */ "./src/UserAgentModule.js");


var EventBus = window.EventBus;
var audioElement = document.querySelector("audio");
if (!audioElement) {
  console.error("Audio element not found in output machine!");
}
var audioOutputMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_1__.createMachine)({
  /** @xstate-layout N4IgpgJg5mDOIC5QEMCuECWB7A8qgLgA4EDEYAtofhpANoAMAuoqIVrBtVgHYsgCeiALQBGAOwBWADQgAHohEBOACzKAdMrEA2LQA4ATPq0iJW-QF9zMtJlwFi+NRggAbMCRdZkEWPmQAnfAZmJBA2Di5eUPkEQwk1aQFERX1FNXoM+hMAZnoJXRFsrUtrdGw8IgI1T28MbigPLwhIcjA-CGQ-YL5wzmwo0BiJfRlBBAKEzPpFDPFdbP1lEpAbcvsqmuaINX8wb34SQhdkfm7Q3si+GJEsrQTsmbNEsdTsybEDD7yCouXVu0qjk2kDURxOdQahDQsDAZ1Y7D6PCuySM90UIn0GKMym+o0Qqn0ai0C0+um+hWKVhWZQBDmqTRBYP4ELI3C2cLCCMu0RRdwkDwxWK0OPyeIQ4noan0Eg++i++UK+T+NIqdOB2yZLIAxshuEz8AALfxYVBQA0ci79ZEIRQytRibTTehaPLZbLzMXDMT23QzB1khW-Kn-VUbBka47M+okC1cq08m2o-nozGGYW4pIIB53Yn6UnkoOlWyhoHh0HQyCHSOxiLxwYKLLqIpiRZmbEZsbZZS6NSFPNygM-SlFtaA+neRkViAkXabGuIgZyBR5ntiG6KRRt9OizPKW32iSzfkFiTK4vrUsT7ZgNmVmFgADWdCYPTjSITpj5Yno2Qxz0QRSEn2-r0GIyjiOIlhUtwWDNPAoQhher61u+9YIEIWhikIRiEqewYqheTiuGAyELtaygjJm2hvKkIh6EoLbdj+Z6jmqTQQqR3JoXRvr2iINwykYJhmGKvGHkeHyHroujKHhI60mGV6cXWS6xBIaTJs60qiYSkhfHu+hFO6igsQpl5bDsewQGM8IoYuMQUeomlPGK+hZESCwgWBEFiKZJbjhZmr1MpqGqVoiirqoMnOq67rZGKCzqH2+aBsO1LnmO6rlqgMIQCF9kKAJRLiK2aYiroCXge8KVDn5hFZTeWz5dauTes52mZhIdq5jVFJQeYQA */
  id: "audioOutput",
  context: {
    autoplay: false,
    audioElement: audioElement
  },
  initial: "idle",
  states: {
    idle: {
      on: {
        loadstart: "loading"
      }
    },
    loading: {
      on: {
        loadedmetadata: "loaded"
      }
    },
    loaded: {
      initial: "ready",
      on: {
        emptied: "idle"
      },
      states: {
        ready: {
          description: "Audio has loaded and is ready to start playing (further buffering may be required to reach the end).",
          on: {
            play: "playing"
          },
          entry: {
            type: "emitEvent",
            params: {
              eventName: "saypi:ready"
            }
          }
        },
        playing: {
          on: {
            pause: "paused",
            ended: "ended",
            canplaythrough: {
              target: "playing",
              internal: true
            }
          },
          always: {
            target: "paused",
            cond: "isSafariAutoPlay",
            actions: ["requestPause", {
              type: "emitEvent",
              params: {
                eventName: "saypi:safariBlocked"
              }
            }]
          },
          entry: [{
            type: "emitEvent",
            params: {
              eventName: "saypi:piSpeaking"
            }
          }],
          exit: [{
            type: "emitEvent",
            params: {
              eventName: "saypi:piStoppedSpeaking"
            }
          }, (0,xstate__WEBPACK_IMPORTED_MODULE_2__.assign)({
            autoplay: true,
            audioElement: function audioElement(context) {
              return context.audioElement;
            }
          })]
        },
        paused: {
          on: {
            play: "playing",
            reload: {
              target: "#audioOutput.loading",
              description: "Reload the audio stream for Safari. This is the only command that external modules can send the machine.",
              actions: [(0,xstate__WEBPACK_IMPORTED_MODULE_2__.assign)(function (context) {
                return {
                  autoplay: false,
                  audioElement: context.audioElement
                };
              }), "requestReload"],
              cond: "isSafari"
            }
          }
        },
        ended: {
          on: {
            seeked: {
              target: "#audioOutput.loaded.ready",
              description: "An ended track is seeked back to earlier in the track."
            }
          },
          entry: [{
            type: "emitEvent",
            params: {
              eventName: "saypi:piFinishedSpeaking"
            }
          }]
        }
      }
    }
  },
  predictableActionArguments: true,
  preserveActionOrder: true
}, {
  actions: {
    emitEvent: function emitEvent(context, event, _ref) {
      var action = _ref.action;
      EventBus.emit(action.params.eventName);
    },
    requestPause: function requestPause(context, event) {
      context.audioElement.pause();
    },
    seekToEnd: function seekToEnd(context, event) {
      var audio = context.audioElement;
      if (audio.duration && !audio.ended && audio.currentTime < audio.duration) {
        audio.currentTime = audio.duration; // seek the audio to the end
        audio.play(); // trigger the ended event
      }

      EventBus.emit("saypi:piFinishedSpeaking");
    },
    requestReload: function requestReload(context) {
      var audio = context.audioElement;
      audio.load();
      audio.play();
    }
  },
  guards: {
    isSafari: function isSafari(context, event) {
      return (0,_UserAgentModule__WEBPACK_IMPORTED_MODULE_0__.isSafari)();
    },
    isSafariAutoPlay: function isSafariAutoPlay(context, event) {
      return (0,_UserAgentModule__WEBPACK_IMPORTED_MODULE_0__.isSafari)() && context.autoplay;
    }
  }
});

/***/ }),

/***/ "./node_modules/onnxruntime-web/dist/ort.min.js":
/*!******************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.min.js ***!
  \******************************************************/
/***/ ((module) => {

/*!
* ONNX Runtime Web v1.15.1
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/
!function(e,t){ true?module.exports=t():0}(self,(()=>(()=>{var __webpack_modules__={8453:(e,t,n)=>{"use strict";n.r(t),n.d(t,{InferenceSession:()=>f,Tensor:()=>p,env:()=>a,registerBackend:()=>i});const r={},o=[],i=(e,t,n)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createSessionHandler)throw new TypeError("not a valid backend");{const i=r[e];if(void 0===i)r[e]={backend:t,priority:n};else{if(i.priority>n)return;if(i.priority===n&&i.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){const t=o.indexOf(e);-1!==t&&o.splice(t,1);for(let t=0;t<o.length;t++)if(r[o[t]].priority<=n)return void o.splice(t,0,e);o.push(e)}}},a=new class{constructor(){this.wasm={},this.webgl={},this.webgpu={},this.logLevelInternal="warning"}set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);this.logLevelInternal=e}}get logLevel(){return this.logLevelInternal}},s=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),u=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let l=!1;class c{constructor(e,t,n){let r,o,i;if((()=>{if(!l){l=!0;const e="undefined"!=typeof BigInt64Array&&"function"==typeof BigInt64Array.from,t="undefined"!=typeof BigUint64Array&&"function"==typeof BigUint64Array.from;e&&(s.set("int64",BigInt64Array),u.set(BigInt64Array,"int64")),t&&(s.set("uint64",BigUint64Array),u.set(BigUint64Array,"uint64"))}})(),"string"==typeof e)if(r=e,i=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");o=t}else{const n=s.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t))o=n.from(t);else{if(!(t instanceof n))throw new TypeError(`A ${r} tensor's data must be type of ${n}`);o=t}}else if(i=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const t=typeof e[0];if("string"===t)r="string",o=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",o=Uint8Array.from(e)}}else{const t=u.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,o=e}if(void 0===i)i=[o.length];else if(!Array.isArray(i))throw new TypeError("A tensor's dims must be a number array");const a=(e=>{let t=1;for(let n=0;n<e.length;n++){const r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t})(i);if(a!==o.length)throw new Error(`Tensor's size(${a}) does not match data length(${o.length}).`);this.dims=i,this.type=r,this.data=o,this.size=a}static bufferToTensor(e,t){if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");const{height:n,width:r}=t,o=t.norm??{mean:255,bias:0};let i,a;i="number"==typeof o.mean?[o.mean,o.mean,o.mean,o.mean]:[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],a="number"==typeof o.bias?[o.bias,o.bias,o.bias,o.bias]:[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];const s=void 0!==t.bitmapFormat?t.bitmapFormat:"RGBA",u=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",l=n*r,p="RGBA"===u?new Float32Array(4*l):new Float32Array(3*l);let d=4,f=0,h=1,g=2,m=3,b=0,y=l,w=2*l,_=-1;"RGB"===s&&(d=3,f=0,h=1,g=2,m=-1),"RGBA"===u?_=3*l:"RBG"===u?(b=0,w=l,y=2*l):"BGR"===u&&(w=0,y=l,b=2*l);for(let t=0;t<l;t++,f+=d,g+=d,h+=d,m+=d)p[b++]=(e[f]+a[0])/i[0],p[y++]=(e[h]+a[1])/i[1],p[w++]=(e[g]+a[2])/i[2],-1!==_&&-1!==m&&(p[_++]=(e[m]+a[3])/i[3]);return new c("float32",p,"RGBA"===u?[1,4,n,r]:[1,3,n,r])}static async fromImage(e,t){const n="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,r="undefined"!=typeof ImageData&&e instanceof ImageData,o="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,i="string"==typeof e;let a,s=t??{};if(n){const n=document.createElement("canvas");n.width=e.width,n.height=e.height;const r=n.getContext("2d");if(null==r)throw new Error("Can not access image data");{let n=e.height,o=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(n=t.resizedHeight,o=t.resizedWidth),void 0!==t){if(s=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(s.tensorFormat="RGBA",void 0!==t.height&&t.height!==n)throw new Error("Image input config height doesn't match HTMLImageElement height");if(s.height=n,void 0!==t.width&&t.width!==o)throw new Error("Image input config width doesn't match HTMLImageElement width");s.width=o}else s.tensorFormat="RGBA",s.height=n,s.width=o;r.drawImage(e,0,0),a=r.getImageData(0,0,o,n).data}}else{if(!r){if(o){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");if(void 0!==t.bitmapFormat)throw new Error("Image input config format must be defined for ImageBitmap");const n=document.createElement("canvas").getContext("2d");if(null!=n){const r=e.height,o=e.width;if(n.drawImage(e,0,0,o,r),a=n.getImageData(0,0,o,r).data,void 0!==t){if(void 0!==t.height&&t.height!==r)throw new Error("Image input config height doesn't match ImageBitmap height");if(s.height=r,void 0!==t.width&&t.width!==o)throw new Error("Image input config width doesn't match ImageBitmap width");s.width=o}else s.height=r,s.width=o;return c.bufferToTensor(a,s)}throw new Error("Can not access image data")}if(i)return new Promise(((n,r)=>{const o=document.createElement("canvas"),i=o.getContext("2d");if(!e||!i)return r();const a=new Image;a.crossOrigin="Anonymous",a.src=e,a.onload=()=>{o.width=a.width,o.height=a.height,i.drawImage(a,0,0,o.width,o.height);const e=i.getImageData(0,0,o.width,o.height);if(void 0!==t){if(void 0!==t.height&&t.height!==o.height)throw new Error("Image input config height doesn't match height");if(s.height=o.height,void 0!==t.width&&t.width!==o.width)throw new Error("Image input config width doesn't match width");s.width=o.width}else s.height=o.height,s.width=o.width;n(c.bufferToTensor(e.data,s))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{const n="RGBA";let r,o;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(r=t.resizedHeight,o=t.resizedWidth):(r=e.height,o=e.width),void 0!==t){if(s=t,void 0!==t.bitmapFormat&&t.bitmapFormat!==n)throw new Error("Image input config format must be RGBA for ImageData");s.bitmapFormat="RGBA"}else s.bitmapFormat="RGBA";if(s.height=r,s.width=o,void 0!==t){const t=document.createElement("canvas");t.width=o,t.height=r;const n=t.getContext("2d");if(null==n)throw new Error("Can not access image data");n.putImageData(e,0,0),a=n.getImageData(0,0,o,r).data}else a=e.data}}if(void 0!==a)return c.bufferToTensor(a,s);throw new Error("Input data provided is not supported - aborted tensor creation")}toDataURL(e){const t=document.createElement("canvas");t.width=this.dims[3],t.height=this.dims[2];const n=t.getContext("2d");if(null!=n){let r,o;void 0!==e?.tensorLayout&&"NHWC"===e.tensorLayout?(r=this.dims[2],o=this.dims[3]):(r=this.dims[3],o=this.dims[2]);const i=void 0!==e?.format?e.format:"RGB",a=e?.norm;let s,u;void 0===a||void 0===a.mean?s=[255,255,255,255]:"number"==typeof a.mean?s=[a.mean,a.mean,a.mean,a.mean]:(s=[a.mean[0],a.mean[1],a.mean[2],0],void 0!==a.mean[3]&&(s[3]=a.mean[3])),void 0===a||void 0===a.bias?u=[0,0,0,0]:"number"==typeof a.bias?u=[a.bias,a.bias,a.bias,a.bias]:(u=[a.bias[0],a.bias[1],a.bias[2],0],void 0!==a.bias[3]&&(u[3]=a.bias[3]));const l=o*r;let c=0,p=l,d=2*l,f=-1;"RGBA"===i?(c=0,p=l,d=2*l,f=3*l):"RGB"===i?(c=0,p=l,d=2*l):"RBG"===i&&(c=0,d=l,p=2*l);for(let e=0;e<o;e++)for(let t=0;t<r;t++){const r=(this.data[c++]-u[0])*s[0],o=(this.data[p++]-u[1])*s[1],i=(this.data[d++]-u[2])*s[2],a=-1===f?255:(this.data[f++]-u[3])*s[3];n.fillStyle="rgba("+r+","+o+","+i+","+a+")",n.fillRect(t,e,1,1)}return t.toDataURL()}throw new Error("Can not access image data")}toImageData(e){const t=document.createElement("canvas").getContext("2d");let n;if(null==t)throw new Error("Can not access image data");{let r,o,i;void 0!==e?.tensorLayout&&"NHWC"===e.tensorLayout?(r=this.dims[2],o=this.dims[1],i=this.dims[3]):(r=this.dims[3],o=this.dims[2],i=this.dims[1]);const a=void 0!==e&&void 0!==e.format?e.format:"RGB",s=e?.norm;let u,l;void 0===s||void 0===s.mean?u=[255,255,255,255]:"number"==typeof s.mean?u=[s.mean,s.mean,s.mean,s.mean]:(u=[s.mean[0],s.mean[1],s.mean[2],255],void 0!==s.mean[3]&&(u[3]=s.mean[3])),void 0===s||void 0===s.bias?l=[0,0,0,0]:"number"==typeof s.bias?l=[s.bias,s.bias,s.bias,s.bias]:(l=[s.bias[0],s.bias[1],s.bias[2],0],void 0!==s.bias[3]&&(l[3]=s.bias[3]));const c=o*r;if(void 0!==e){if(void 0!==e.height&&e.height!==o)throw new Error("Image output config height doesn't match tensor height");if(void 0!==e.width&&e.width!==r)throw new Error("Image output config width doesn't match tensor width");if(void 0!==e.format&&4===i&&"RGBA"!==e.format||3===i&&"RGB"!==e.format&&"BGR"!==e.format)throw new Error("Tensor format doesn't match input tensor dims")}const p=4;let d=0,f=1,h=2,g=3,m=0,b=c,y=2*c,w=-1;"RGBA"===a?(m=0,b=c,y=2*c,w=3*c):"RGB"===a?(m=0,b=c,y=2*c):"RBG"===a&&(m=0,y=c,b=2*c),n=t.createImageData(r,o);for(let e=0;e<o*r;d+=p,f+=p,h+=p,g+=p,e++)n.data[d]=(this.data[m++]-l[0])*u[0],n.data[f]=(this.data[b++]-l[1])*u[1],n.data[h]=(this.data[y++]-l[2])*u[2],n.data[g]=-1===w?255:(this.data[w++]-l[3])*u[3]}return n}reshape(e){return new c(this.type,this.data,e)}}const p=c;class d{constructor(e){this.handler=e}async run(e,t,n){const r={};let o={};if("object"!=typeof e||null===e||e instanceof p||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof p)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");i=!1;for(const e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)o=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else{let e=!1;const a=Object.getOwnPropertyNames(t);for(const n of this.outputNames)if(-1!==a.indexOf(n)){const o=t[n];(null===o||o instanceof p)&&(e=!0,i=!1,r[n]=o)}if(e){if("object"==typeof n&&null!==n)o=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else o=t}}else if(void 0!==t)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const t of this.inputNames)if(void 0===e[t])throw new Error(`input '${t}' is missing in 'feeds'.`);if(i)for(const e of this.outputNames)r[e]=null;const a=await this.handler.run(e,r,o),s={};for(const e in a)Object.hasOwnProperty.call(a,e)&&(s[e]=new p(a[e].type,a[e].data,a[e].dims));return s}static async create(e,t,n,i){let a,s={};if("string"==typeof e){if(a=e,"object"==typeof t&&null!==t)s=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(a=e,"object"==typeof t&&null!==t)s=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else{if(!(e instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const r=e;let o=0,u=e.byteLength;if("object"==typeof t&&null!==t)s=t;else if("number"==typeof t){if(o=t,!Number.isSafeInteger(o))throw new RangeError("'byteOffset' must be an integer.");if(o<0||o>=r.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${r.byteLength}).`);if(u=e.byteLength-o,"number"==typeof n){if(u=n,!Number.isSafeInteger(u))throw new RangeError("'byteLength' must be an integer.");if(u<=0||o+u>r.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${r.byteLength-o}].`);if("object"==typeof i&&null!==i)s=i;else if(void 0!==i)throw new TypeError("'options' must be an object.")}else if(void 0!==n)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==t)throw new TypeError("'options' must be an object.");a=new Uint8Array(r,o,u)}}const u=(s.executionProviders||[]).map((e=>"string"==typeof e?e:e.name)),l=await(async e=>{const t=0===e.length?o:e,n=[];for(const e of t){const t=r[e];if(t){if(t.initialized)return t.backend;if(t.aborted)continue;const r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init()),await t.initPromise,t.initialized=!0,t.backend}catch(o){r||n.push({name:e,err:o}),t.aborted=!0}finally{delete t.initPromise}}}throw new Error(`no available backend found. ERR: ${n.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`)})(u),c=await l.createSessionHandler(a,s);return new d(c)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}const f=d},5716:(e,t,n)=>{"use strict";t.R=void 0;const r=n(6027),o=n(1723);t.R=new class{async init(){}async createSessionHandler(e,t){const n=new r.Session(t);return await n.loadModel(e),new o.OnnxjsSessionHandler(n)}}},2818:(e,t,n)=>{"use strict";t.c8=t.rX=void 0;const r=n(8453),o=n(5381),i=n(9544),a=n(6640);t.rX=()=>{if(("number"!=typeof r.env.wasm.initTimeout||r.env.wasm.initTimeout<0)&&(r.env.wasm.initTimeout=0),"boolean"!=typeof r.env.wasm.simd&&(r.env.wasm.simd=!0),"boolean"!=typeof r.env.wasm.proxy&&(r.env.wasm.proxy=!1),"number"!=typeof r.env.wasm.numThreads||!Number.isInteger(r.env.wasm.numThreads)||r.env.wasm.numThreads<=0){const e="undefined"==typeof navigator?(0,o.cpus)().length:navigator.hardwareConcurrency;r.env.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},t.c8=new class{async init(){(0,t.rX)(),await(0,i.initWasm)()}async createSessionHandler(e,t){const n=new a.OnnxruntimeWebAssemblySessionHandler;return await n.loadModel(e,t),Promise.resolve(n)}}},1057:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var o=Object.getOwnPropertyDescriptor(t,n);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,o)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),o=this&&this.__exportStar||function(e,t){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(t,n)||r(t,e,n)};Object.defineProperty(t,"__esModule",{value:!0}),o(n(8453),t);const i=n(8453);{const e=n(5716).R;(0,i.registerBackend)("webgl",e,-10)}{const e=n(2818).c8;(0,i.registerBackend)("cpu",e,10),(0,i.registerBackend)("wasm",e,10),(0,i.registerBackend)("xnnpack",e,9)}},4910:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createAttributeWithCacheKey=void 0;class n{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this._cacheKey}}t.createAttributeWithCacheKey=e=>new n(e)},6874:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Attribute=void 0;const r=n(1446),o=n(1287),i=n(9240),a=n(7273);var s=o.onnxruntime.experimental.fbs;class u{constructor(e){if(this._attributes=new Map,null!=e){for(const t of e)t instanceof r.onnx.AttributeProto?this._attributes.set(t.name,[u.getValue(t),u.getType(t)]):t instanceof s.Attribute&&this._attributes.set(t.name(),[u.getValue(t),u.getType(t)]);if(this._attributes.size<e.length)throw new Error("duplicated attribute names")}}set(e,t,n){this._attributes.set(e,[n,t])}delete(e){this._attributes.delete(e)}getFloat(e,t){return this.get(e,"float",t)}getInt(e,t){return this.get(e,"int",t)}getString(e,t){return this.get(e,"string",t)}getTensor(e,t){return this.get(e,"tensor",t)}getFloats(e,t){return this.get(e,"floats",t)}getInts(e,t){return this.get(e,"ints",t)}getStrings(e,t){return this.get(e,"strings",t)}getTensors(e,t){return this.get(e,"tensors",t)}get(e,t,n){const r=this._attributes.get(e);if(void 0===r){if(void 0!==n)return n;throw new Error(`required attribute not found: ${e}`)}if(r[1]!==t)throw new Error(`type mismatch: expected ${t} but got ${r[1]}`);return r[0]}static getType(e){const t=e instanceof r.onnx.AttributeProto?e.type:e.type();switch(t){case r.onnx.AttributeProto.AttributeType.FLOAT:return"float";case r.onnx.AttributeProto.AttributeType.INT:return"int";case r.onnx.AttributeProto.AttributeType.STRING:return"string";case r.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case r.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case r.onnx.AttributeProto.AttributeType.INTS:return"ints";case r.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case r.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${r.onnx.AttributeProto.AttributeType[t]}`)}}static getValue(e){const t=e instanceof r.onnx.AttributeProto?e.type:e.type();if(t===r.onnx.AttributeProto.AttributeType.GRAPH||t===r.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const n=this.getValueNoCheck(e);if(t===r.onnx.AttributeProto.AttributeType.INT&&a.LongUtil.isLong(n))return a.LongUtil.longToNumber(n);if(t===r.onnx.AttributeProto.AttributeType.INTS){const e=n,t=new Array(e.length);for(let n=0;n<e.length;n++){const r=e[n];t[n]=a.LongUtil.longToNumber(r)}return t}if(t===r.onnx.AttributeProto.AttributeType.TENSOR)return e instanceof r.onnx.AttributeProto?i.Tensor.fromProto(n):i.Tensor.fromOrtTensor(n);if(t===r.onnx.AttributeProto.AttributeType.TENSORS){if(e instanceof r.onnx.AttributeProto)return n.map((e=>i.Tensor.fromProto(e)));if(e instanceof s.Attribute)return n.map((e=>i.Tensor.fromOrtTensor(e)))}if(t===r.onnx.AttributeProto.AttributeType.STRING&&e instanceof r.onnx.AttributeProto){const e=n;return(0,a.decodeUtf8String)(e)}return t===r.onnx.AttributeProto.AttributeType.STRINGS&&e instanceof r.onnx.AttributeProto?n.map(a.decodeUtf8String):n}static getValueNoCheck(e){return e instanceof r.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(e):this.getValueNoCheckFromOrtFormat(e)}static getValueNoCheckFromOnnxFormat(e){switch(e.type){case r.onnx.AttributeProto.AttributeType.FLOAT:return e.f;case r.onnx.AttributeProto.AttributeType.INT:return e.i;case r.onnx.AttributeProto.AttributeType.STRING:return e.s;case r.onnx.AttributeProto.AttributeType.TENSOR:return e.t;case r.onnx.AttributeProto.AttributeType.GRAPH:return e.g;case r.onnx.AttributeProto.AttributeType.FLOATS:return e.floats;case r.onnx.AttributeProto.AttributeType.INTS:return e.ints;case r.onnx.AttributeProto.AttributeType.STRINGS:return e.strings;case r.onnx.AttributeProto.AttributeType.TENSORS:return e.tensors;case r.onnx.AttributeProto.AttributeType.GRAPHS:return e.graphs;default:throw new Error(`unsupported attribute type: ${r.onnx.AttributeProto.AttributeType[e.type]}`)}}static getValueNoCheckFromOrtFormat(e){switch(e.type()){case s.AttributeType.FLOAT:return e.f();case s.AttributeType.INT:return e.i();case s.AttributeType.STRING:return e.s();case s.AttributeType.TENSOR:return e.t();case s.AttributeType.GRAPH:return e.g();case s.AttributeType.FLOATS:return e.floatsArray();case s.AttributeType.INTS:{const t=[];for(let n=0;n<e.intsLength();n++)t.push(e.ints(n));return t}case s.AttributeType.STRINGS:{const t=[];for(let n=0;n<e.stringsLength();n++)t.push(e.strings(n));return t}case s.AttributeType.TENSORS:{const t=[];for(let n=0;n<e.tensorsLength();n++)t.push(e.tensors(n));return t}default:throw new Error(`unsupported attribute type: ${s.AttributeType[e.type()]}`)}}}t.Attribute=u},1975:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.resolveBackend=t.backend=void 0;const r=n(4418),o=new Map;async function i(e){const n=t.backend;if(void 0!==n[e]&&function(e){const t=e;return"initialize"in t&&"function"==typeof t.initialize&&"createSessionHandler"in t&&"function"==typeof t.createSessionHandler&&"dispose"in t&&"function"==typeof t.dispose}(n[e])){const t=n[e];let r=t.initialize();if("object"==typeof r&&"then"in r&&(r=await r),r)return o.set(e,t),t}}t.backend={webgl:new r.WebGLBackend},t.resolveBackend=async function e(t){if(!t)return e(["webgl"]);{const e="string"==typeof t?[t]:t;for(const t of e){const e=o.get(t);if(e)return e;const n=await i(t);if(n)return n}}throw new Error("no available backend to use")}},4418:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLBackend=void 0;const r=n(8453),o=n(1315),i=n(2171),a=n(3389);t.WebGLBackend=class{get contextId(){return r.env.webgl.contextId}set contextId(e){r.env.webgl.contextId=e}get matmulMaxBatchSize(){return r.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(e){r.env.webgl.matmulMaxBatchSize=e}get textureCacheMode(){return r.env.webgl.textureCacheMode}set textureCacheMode(e){r.env.webgl.textureCacheMode=e}get pack(){return r.env.webgl.pack}set pack(e){r.env.webgl.pack=e}get async(){return r.env.webgl.async}set async(e){r.env.webgl.async=e}initialize(){try{return this.glContext=(0,a.createWebGLContext)(this.contextId),"number"!=typeof this.matmulMaxBatchSize&&(this.matmulMaxBatchSize=16),"string"!=typeof this.textureCacheMode&&(this.textureCacheMode="full"),"boolean"!=typeof this.pack&&(this.pack=!1),"boolean"!=typeof this.async&&(this.async=!1),o.Logger.setWithEnv(r.env),o.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(e){return o.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${e}`),!1}}createSessionHandler(e){return new i.WebGLSessionHandler(this,e)}dispose(){this.glContext.dispose()}}},6859:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.CoordsGlslLib=void 0;const r=n(7273),o=n(1997),i=n(6757),a=n(7618),s=n(432);class u extends o.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new o.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ")}}coordsToOffset(){return{coordsToOffset:new o.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ")}}getOutputSamplingSnippet(){const e=this.context.outputTextureLayout;return e.isPacked?this.getPackedOutputSamplingSnippet(e):this.getUnpackedOutputSamplingSnippet(e)}getPackedOutputSamplingSnippet(e){const t=e.unpackedShape,n=[e.width,e.height],r={},a="getOutputCoords";switch(t.length){case 0:r[a]=this.getOutputScalarCoords();break;case 1:r[a]=this.getOutputPacked1DCoords(t,n);break;case 2:r[a]=this.getOutputPacked2DCoords(t,n);break;case 3:r[a]=this.getOutputPacked3DCoords(t,n);break;default:r[a]=this.getOutputPackedNDCoords(t,n)}const s=`\n      void setOutput(vec4 val) {\n        ${(0,i.getGlsl)(this.context.glContext.version).output} = val;\n      }\n    `;return r.floatTextureSetRGBA=new o.GlslLibRoutine(s),r}getUnpackedOutputSamplingSnippet(e){const t=e.unpackedShape,n=[e.width,e.height],r={},a="getOutputCoords";switch(t.length){case 0:r[a]=this.getOutputScalarCoords();break;case 1:r[a]=this.getOutputUnpacked1DCoords(t,n);break;case 2:r[a]=this.getOutputUnpacked2DCoords(t,n);break;case 3:r[a]=this.getOutputUnpacked3DCoords(t,n);break;case 4:r[a]=this.getOutputUnpacked4DCoords(t,n);break;case 5:r[a]=this.getOutputUnpacked5DCoords(t,n);break;case 6:r[a]=this.getOutputUnpacked6DCoords(t,n);break;default:throw new Error(`Unsupported output dimensionality: ${t.length}`)}const s=`\n        void setOutput(float val) {\n          ${(0,i.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\n        }\n    `;return r.floatTextureSetR=new o.GlslLibRoutine(s),r}getOutputScalarCoords(){return new o.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ")}getOutputPacked1DCoords(e,t){const n=t;let r="";return 1===n[0]?(r=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${n[1]}.0);\n          }\n        `,new o.GlslLibRoutine(r)):1===n[1]?(r=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${n[0]}.0);\n          }\n        `,new o.GlslLibRoutine(r)):(r=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${n[0]}, ${n[1]}));\n          return 2 * (resTexRC.y * ${n[0]} + resTexRC.x);\n        }\n      `,new o.GlslLibRoutine(r))}getOutputPacked2DCoords(e,t){let n="";if(r.ArrayUtil.arraysEqual(e,t))return n=`\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${t[0]}, ${t[1]}));\n        }\n      `,new o.GlslLibRoutine(n);const i=t,a=Math.ceil(e[1]/2);return n=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${i[0]}, ${i[1]}));\n\n          int index = resTexRC.y * ${i[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${a}) * 2;\n          int c = 2 * (index / ${a});\n\n          return ivec2(r, c);\n        }\n      `,new o.GlslLibRoutine(n)}getOutputPacked3DCoords(e,t){const n=[t[0],t[1]],r=Math.ceil(e[2]/2),i=r*Math.ceil(e[1]/2),a=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${n[0]}, ${n[1]}));\n          int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n          int b = index / ${i};\n          index -= b * ${i};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${r}) * 2;\n          int c = 2 * (index / ${r});\n\n          return ivec3(b, r, c);\n        }\n      `;return new o.GlslLibRoutine(a)}getOutputPackedNDCoords(e,t){const n=[t[0],t[1]],r=Math.ceil(e[e.length-1]/2),i=r*Math.ceil(e[e.length-2]/2);let a=i,s="",u="b, r, c";for(let t=2;t<e.length-1;t++)a*=e[e.length-t-1],s=`\n      int b${t} = index / ${a};\n      index -= b${t} * ${a};\n    `+s,u=`b${t}, `+u;const l=`\n      ivec${e.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n        ${s}\n\n        int b = index / ${i};\n        index -= b * ${i};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${r}) * 2;\n        int c = 2 * (index / ${r});\n\n        return ivec${e.length}(${u});\n      }\n    `;return new o.GlslLibRoutine(l)}getOutputUnpacked1DCoords(e,t){const n=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          return resTexRC.y * ${t[0]} + resTexRC.x;\n        }\n      `;return new o.GlslLibRoutine(n)}getOutputUnpacked2DCoords(e,t){const n=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          int r = index / ${e[1]};\n          int c = index - r * ${e[1]};\n          return ivec2(r, c);\n        }\n      `;return new o.GlslLibRoutine(n)}getOutputUnpacked3DCoords(e,t){let n="";const r=e.length;let i=null;r<2&&(i=[]),i=new Array(r-1),i[r-2]=e[r-1];for(let t=r-3;t>=0;--t)i[t]=i[t+1]*e[t+1];const a=["r","c","d"],s=i.map(((e,t)=>`int ${a[t]} = index / ${e}; ${t===i.length-1?`int ${a[t+1]} = index - ${a[t]} * ${e}`:`index -= ${a[t]} * ${e}`};`)).join("");return n=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${s}\n          return ivec3(r, c, d);\n        }\n      `,new o.GlslLibRoutine(n)}getOutputUnpacked4DCoords(e,t){let n="";const r=e.length;let i=null;r<2&&(i=[]),i=new Array(r-1),i[r-2]=e[r-1];for(let t=r-3;t>=0;--t)i[t]=i[t+1]*e[t+1];const a=["r","c","d","d2"],s=i.map(((e,t)=>`int ${a[t]} = index / ${e}; ${t===i.length-1?`int ${a[t+1]} = index - ${a[t]} * ${e}`:`index -= ${a[t]} * ${e}`};`)).join("");return n=`\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${s}\n          return ivec4(r, c, d, d2);\n        }\n      `,new o.GlslLibRoutine(n)}getOutputUnpacked5DCoords(e,t){let n="";const r=e.length;let i=null;r<2&&(i=[]),i=new Array(r-1),i[r-2]=e[r-1];for(let t=r-3;t>=0;--t)i[t]=i[t+1]*e[t+1];const a=["r","c","d","d2","d3"],s=i.map(((e,t)=>`int ${a[t]} = index / ${e}; ${t===i.length-1?`int ${a[t+1]} = index - ${a[t]} * ${e}`:`index -= ${a[t]} * ${e}`};`)).join("");return n=`\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${s}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `,new o.GlslLibRoutine(n)}getOutputUnpacked6DCoords(e,t){let n="";const r=e.length;let i=null;r<2&&(i=[]),i=new Array(r-1),i[r-2]=e[r-1];for(let t=r-3;t>=0;--t)i[t]=i[t+1]*e[t+1];const a=["r","c","d","d2","d3","d4"],s=i.map(((e,t)=>`int ${a[t]} = index / ${e}; ${t===i.length-1?`int ${a[t+1]} = index - ${a[t]} * ${e}`:`index -= ${a[t]} * ${e}`};`)).join("");return n=`\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${t[0]}, ${t[1]}));\n         int index = resTexRC.y * ${t[0]} + resTexRC.x;\n         ${s}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `,new o.GlslLibRoutine(n)}getCommonUtilFuncs(){const e={};let t="uvFromFlat";e[t]=new o.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "),t="packedUVfrom1D",e[t]=new o.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),t="packedUVfrom2D",e[t]=new o.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),t="packedUVfrom3D",e[t]=new o.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),t="sampleTexture";const n=(0,i.getGlsl)(this.context.glContext.version);return e[t]=new o.GlslLibRoutine(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${n.texture2D}(textureSampler, uv).r;\n        }`),e}getInputsSamplingSnippets(){const e={},t=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach(((n,r)=>{const o=this.context.inputTextureLayouts[r],i=(0,s.generateShaderFuncNameFromInputSamplerName)(n);o.isPacked?e[i]=this.getPackedSamplerFromInput(i,n,o):e[i]=this.getUnpackedSamplerFromInput(i,n,o);const a=(0,s.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n);o.unpackedShape.length<=t.unpackedShape.length&&(o.isPacked?e[a]=this.getPackedSamplerAtOutputCoords(a,o,t,n):e[a]=this.getUnpackedSamplerAtOutputCoords(a,o,t,n))})),e}getPackedSamplerAtOutputCoords(e,t,n,i){const a=t.unpackedShape,u=n.unpackedShape,l=i,c=(0,s.generateShaderFuncNameFromInputSamplerName)(l),p=a.length,d=u.length,f=r.BroadcastUtil.getBroadcastDims(a,u),h=(0,s.getCoordsDataType)(d),g=d-p;let m;const b=(0,s.getGlChannels)();m=0===p?"":d<2&&f.length>=1?"coords = 0;":f.map((e=>`coords.${b[e+g]} = 0;`)).join("\n");let y="";y=d<2&&p>0?"coords":a.map(((e,t)=>`coords.${b[t+g]}`)).join(", ");let w="return outputValue;";const _=1===r.ShapeUtil.size(a),v=1===r.ShapeUtil.size(u);if(1!==p||_||v){if(_&&!v)w=1===d?"\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        ":"\n          return vec4(outputValue.x);\n        ";else if(f.length){const e=p-2,t=p-1;f.indexOf(e)>-1&&f.indexOf(t)>-1?w="return vec4(outputValue.x);":f.indexOf(e)>-1?w="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":f.indexOf(t)>-1&&(w="return vec4(outputValue.xx, outputValue.zz);")}}else w="\n        return vec4(outputValue.xy, outputValue.xy);\n      ";const x=`\n      vec4 ${e}() {\n        ${h} coords = getOutputCoords();\n        \n        int lastDim = coords.${b[d-1]};\n        coords.${b[d-1]} = coords.${b[d-2]};\n        coords.${b[d-2]} = lastDim;\n      \n        ${m}\n        vec4 outputValue = ${c}(${y});\n        ${w}\n      }\n    `;return new o.GlslLibRoutine(x,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(e,t,n,i){const a=[n.width,n.height],u=[t.width,t.height],l=t.unpackedShape.length,c=n.unpackedShape.length,p=t.unpackedShape,d=n.unpackedShape,f=(0,s.generateShaderFuncNameFromInputSamplerName)(i);if(l===c&&r.ArrayUtil.arraysEqual(u,a)){const t=`\n          float ${e}() {\n            return sampleTexture(${i}, TexCoords);\n          }\n        `;return new o.GlslLibRoutine(t,["coordinates.sampleTexture"])}const h=(0,s.getCoordsDataType)(c),g=r.BroadcastUtil.getBroadcastDims(p,d),m=c-l;let b;const y=(0,s.getGlChannels)();b=0===l?"":c<2&&g.length>=1?"coords = 0;":g.map((e=>`coords.${y[e+m]} = 0;`)).join("\n");let w="";w=c<2&&l>0?"coords":t.unpackedShape.map(((e,t)=>`coords.${y[t+m]}`)).join(", ");const _=`\n        float ${e}() {\n          ${h} coords = getOutputCoords();\n          ${b}\n          return ${f}(${w});\n        }\n      `;return new o.GlslLibRoutine(_,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(e,t,n){switch(n.unpackedShape.length){case 0:return this.getPackedSamplerScalar(e,t);case 1:return this.getPackedSampler1D(e,t,n);case 2:return this.getPackedSampler2D(e,t,n);case 3:return this.getPackedSampler3D(e,t,n);default:return this.getPackedSamplerND(e,t,n)}}getUnpackedSamplerFromInput(e,t,n){const r=n.unpackedShape;switch(r.length){case 0:return this.getUnpackedSamplerScalar(e,t,n);case 1:return this.getUnpackedSampler1D(e,t,n);case 2:return this.getUnpackedSampler2D(e,t,n);case 3:return this.getUnpackedSampler3D(e,t,n);case 4:return this.getUnpackedSampler4D(e,t,n);case 5:return this.getUnpackedSampler5D(e,t,n);case 6:return this.getUnpackedSampler6D(e,t,n);default:throw new Error(`Unsupported dimension ${r.length}-D`)}}getPackedSamplerScalar(e,t){const n=`\n          vec4 ${e}() {\n            return ${(0,i.getGlsl)(this.context.glContext.version).texture2D}(${t}, halfCR);\n          }\n        `;return new o.GlslLibRoutine(n)}getPackedSampler1D(e,t,n){const r=[n.width,n.height],a=[r[1],r[0]],s=(0,i.getGlsl)(this.context.glContext.version),u=`vec4 ${e}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${a[0]}, ${a[1]}, index);\n      return ${s.texture2D}(${t}, uv);\n    }`;return new o.GlslLibRoutine(u,["coordinates.packedUVfrom1D"])}getPackedSampler2D(e,t,n){const a=n.unpackedShape,s=[n.width,n.height],u=(0,i.getGlsl)(this.context.glContext.version),l=s[0],c=s[1];if(null!=s&&r.ArrayUtil.arraysEqual(a,s)){const n=`vec4 ${e}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${l}.0);\n        return ${u.texture2D}(${t}, uv);\n      }`;return new o.GlslLibRoutine(n)}const p=s,d=Math.ceil(a[1]/2),f=`vec4 ${e}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${d}, row, col);\n      return ${u.texture2D}(${t}, uv);\n    }`;return new o.GlslLibRoutine(f,["coordinates.packedUVfrom2D"])}getPackedSampler3D(e,t,n){const r=n.unpackedShape,a=[n.width,n.height],u=[a[0],a[1]],l=(0,i.getGlsl)(this.context.glContext.version);if(1===r[0]){const i=r.slice(1),a=[1,2],u=(0,s.squeezeInputShape)(r,i),l=["b","row","col"],c=JSON.parse(JSON.stringify(n));c.unpackedShape=u;const p=this.getPackedSamplerFromInput(e,t,c),d=`${p.routineBody}\n      vec4 ${e}(int b, int row, int col) {\n        return ${e}(${(0,s.getSqueezedParams)(l,a)});\n      } `;return new o.GlslLibRoutine(d,p.dependencies)}const c=u[0],p=u[1],d=Math.ceil(r[2]/2),f=`vec4 ${e}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${p}, ${c}, ${d*Math.ceil(r[1]/2)}, ${d}, b, row, col);\n      return ${l.texture2D}(${t}, uv);}`;return new o.GlslLibRoutine(f,["coordinates.packedUVfrom3D"])}getPackedSamplerND(e,t,n){const r=n.unpackedShape,a=r.length,s=[n.width,n.height],u=(0,i.getGlsl)(this.context.glContext.version),l=[s[0],s[1]],c=l[1],p=l[0],d=Math.ceil(r[a-1]/2);let f=d*Math.ceil(r[a-2]/2),h="int b, int row, int col",g=`b * ${f} + (row / 2) * ${d} + (col / 2)`;for(let e=2;e<a-1;e++)h=`int b${e}, `+h,f*=r[a-e-1],g=`b${e} * ${f} + `+g;const m=`vec4 ${e}(${h}) {\n      int index = ${g};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${c});\n      return ${u.texture2D}(${t}, uv);\n    }`;return new o.GlslLibRoutine(m)}getUnpackedSamplerScalar(e,t,n){const[r,i]=[n.width,n.height];if(1===r&&1===i){const n=`\n          float ${e}() {\n            return sampleTexture(${t}, halfCR);\n          }\n        `;return new o.GlslLibRoutine(n,["coordinates.sampleTexture"])}const a=`\n        float ${e}() {\n          int offset_${t} = coordsToOffset(TexCoords, ${r}, ${i});\n          vec2 uv = uvFromFlat(${r}, ${i}, offset_${t});\n          return sampleTexture(${t}, uv);\n        }\n      `;return new o.GlslLibRoutine(a,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(e,t,n){const r=n.width,i=n.height;if(1===i&&1===r){const n=`\n        float ${e}(int index) {\n          return sampleTexture(${t}, halfCR);\n        }\n      `;return new o.GlslLibRoutine(n,["coordinates.sampleTexture"])}if(1===i){const n=`\n          float ${e}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${r}.0, 0.5);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new o.GlslLibRoutine(n,["coordinates.sampleTexture"])}if(1===r){const n=`\n          float ${e}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${i}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new o.GlslLibRoutine(n,["coordinates.sampleTexture"])}const a=`\n        float ${e}(int index) {\n          vec2 uv = uvFromFlat(${r}, ${i}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new o.GlslLibRoutine(a,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(e,t,n){const i=n.unpackedShape,u=[n.height,n.width];if(null!=u&&r.ArrayUtil.arraysEqual(i,u)){const n=`\n          float ${e}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u[1]}.0, ${u[0]}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new o.GlslLibRoutine(n,["coordinates.sampleTexture"])}const{newShape:l,keptDims:c}=(0,a.squeezeShape)(i),p=l;if(p.length<i.length){const r=(0,s.squeezeInputShape)(i,p),a=JSON.parse(JSON.stringify(n));a.unpackedShape=r;const u=["col","row"],l=`\n          ${this.getUnpackedSamplerFromInput(e,t,a).routineBody}\n          float ${e}(int row, int col) {\n            return ${e}(${(0,s.getSqueezedParams)(u,c)});\n          }\n        `;return new o.GlslLibRoutine(l,["coordinates.sampleTexture"])}const d=u[1],f=u[0];if(1===f){const n=`\n          float ${e}(int row, int col) {\n            int offset_${t} = coordsToOffset(TexCoords, ${d}, ${f});\n            float index = dot(vec3(row, col, offset_${t}), vec3(${i[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new o.GlslLibRoutine(n,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(1===d){const n=`\n          float ${e}(int row, int col) {\n            int offset_${t} = coordsToOffset(TexCoords, ${d}, ${f});\n            float index = dot(vec3(row, col, offset_${t}), vec3(${i[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${f}.0, 0.5);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new o.GlslLibRoutine(n,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const h=`\n        float ${e}(int row, int col) {\n          int index = col * ${i[1]} + row;\n          vec2 uv = uvFromFlat(${d}, ${f}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new o.GlslLibRoutine(h,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(e,t,n){const r=n.unpackedShape,i=r[1]*r[2],u=r[2],{newShape:l,keptDims:c}=(0,a.squeezeShape)(r),p=l;if(p.length<r.length){const i=(0,s.squeezeInputShape)(r,p),a=["batch","col","row"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=i;const l=this.getUnpackedSamplerFromInput(e,t,u),d=c.reverse(),f=`\n          ${l.routineBody}\n          float ${e}(int batch, int row, int col) {\n            return ${e}(${(0,s.getSqueezedParams)(a,d)});\n          }\n        `;return new o.GlslLibRoutine(f,l.dependencies)}const d=`\n          float ${e}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${i} + col * ${u} + row;\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n            return sampleTexture(${t}, uv);\n          }\n      `;return new o.GlslLibRoutine(d,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(e,t,n){const r=n.unpackedShape,i=r[3],a=r[2]*i,s=`\n        float ${e}(int row, int col, int depth, int depth2) {\n          int index = row * ${r[1]*a} + col * ${a} +\n              depth2 * ${i} + depth;\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new o.GlslLibRoutine(s,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(e,t,n){const r=n.unpackedShape,i=r[4],u=r[3]*i,l=r[2]*u,c=r[1]*l,{newShape:p,keptDims:d}=(0,a.squeezeShape)(r);if(p.length<r.length){const i=(0,s.squeezeInputShape)(r,p),a=["row","col","depth","depth2","depth3"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=i;const l=`\n          ${this.getUnpackedSamplerFromInput(e,t,u).routineBody}\n          float ${e}(int row, int col, int depth, int depth2, int depth3) {\n            return ${e}(${(0,s.getSqueezedParams)(a,d)});\n          }\n        `;return new o.GlslLibRoutine(l,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const f=`\n        float ${e}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${c} + col * ${l} + depth * ${u} +\n          depth3 * ${i} + depth2;\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new o.GlslLibRoutine(f,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(e,t,n){const r=n.unpackedShape,i=r[5],u=r[4]*i,l=r[3]*u,c=r[2]*l,p=r[1]*c,{newShape:d,keptDims:f}=(0,a.squeezeShape)(r);if(d.length<r.length){const i=(0,s.squeezeInputShape)(r,d),a=["row","col","depth","depth2","depth3","depth4"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=i;const l=`\n            ${this.getUnpackedSamplerFromInput(e,t,u).routineBody}\n            float ${e}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${e}(${(0,s.getSqueezedParams)(a,f)});\n            }\n          `;return new o.GlslLibRoutine(l,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const h=`\n          float ${e}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${p} + col * ${c} + depth * ${l} +\n            depth2 * ${u} + depth3 * ${i} + depth4;\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new o.GlslLibRoutine(h,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const e=this.context.outputTextureLayout,t=e.shape.length,n=e.strides,r=e.width,i=e.height,a=[];for(let e=0;e<t-1;++e)a.push(`\n        c[${e}] = offset / ${n[e]};`),a.push(`\n        offset -= c[${e}] * ${n[e]};`);a.push(`\n        c[${t-1}] = offset;`);const s=`\n      void toVec(vec2 texCoords, out int c[${t}]) {\n        int offset = coordsToOffset(texCoords, ${r}, ${i});\n        ${a.join("")}\n      }\n      void toVec(int offset, out int c[${t}]) {\n        ${a.join("")}\n      }\n    `;return{toVec:new o.GlslLibRoutine(s,["coordinates.coordsToOffset"])}}valueFrom(){const e={};return this.context.programInfo.inputNames.forEach(((t,n)=>{const r=this.context.inputTextureLayouts[n],i=(r.unpackedShape.length>0?r.unpackedShape:r.shape).length;let a=`_${t}`;e[a]=new o.GlslLibRoutine(this.getValueFromSingle(t,i,r.width,r.height,!1),[`shapeUtils.indicesToOffset${a}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),a+="_T",e[a]=new o.GlslLibRoutine(this.getValueFromSingle(t,i,r.width,r.height,!0),[`shapeUtils.indicesToOffset${a}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])})),e}getValueFromSingle(e,t,n,r,o){let a=`_${e}`;return o&&(a+="_T"),`\n        float ${a}(int m[${t}]) {\n          int offset = indicesToOffset${a}(m);\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\n          float value = getColorAsFloat(${(0,i.getGlsl)(this.context.glContext.version).texture2D}(${e}, coords));\n          return value;\n        }\n        `}getPackedValueFrom(e,t,n,r,o){let a=`_${e}_Pack`;return o&&(a+="_T"),`\n        vec4 ${a}(int m[${t}]) {\n          int offset = indicesToOffset_${e}(m);\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\n          return ${(0,i.getGlsl)(this.context.glContext.version).texture2D}(${e}, coords);\n        }\n        `}}t.CoordsGlslLib=u},1997:(e,t)=>{"use strict";var n;Object.defineProperty(t,"__esModule",{value:!0}),t.TopologicalSortGlslRoutines=t.GlslLibRoutineNode=t.GlslLibRoutine=t.GlslLib=t.GlslContext=t.FunctionType=void 0,(n=t.FunctionType||(t.FunctionType={}))[n.ValueBased=0]="ValueBased",n[n.Positional=1]="Positional",t.GlslContext=class{constructor(e,t,n,r){this.glContext=e,this.programInfo=t,this.inputTextureLayouts=n,this.outputTextureLayout=r}},t.GlslLib=class{constructor(e){this.context=e}},t.GlslLibRoutine=class{constructor(e,t){this.routineBody=e,this.dependencies=t}},t.GlslLibRoutineNode=class{constructor(e,t,n){this.name=e,this.dependencies=n||[],t&&(this.routineBody=t)}addDependency(e){e&&this.dependencies.push(e)}},t.TopologicalSortGlslRoutines=class{static returnOrderedNodes(e){if(!e||0===e.length)return[];if(1===e.length)return e;const t=new Set,n=new Set,r=new Array;return this.createOrderedNodes(e,t,n,r),r}static createOrderedNodes(e,t,n,r){for(let o=0;o<e.length;++o)this.dfsTraverse(e[o],t,n,r)}static dfsTraverse(e,t,n,r){if(!e||n.has(e.name))return;if(t.has(e.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");t.add(e.name);const o=e.dependencies;if(o&&o.length>0)for(let e=0;e<o.length;++e)this.dfsTraverse(o[e],t,n,r);r.push(e),n.add(e.name),t.delete(e.name)}}},1371:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.EncodingGlslLib=void 0;const r=n(1997);class o extends r.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new r.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ")}}decodeFloat32(){return{decode:new r.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ")}}encodeUint8(){const e=o.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new r.GlslLibRoutine(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${e}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `)}}decodeUint8(){const e=o.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new r.GlslLibRoutine(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${e}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `)}}static isLittleEndian(){const e=new ArrayBuffer(4),t=new Uint32Array(e),n=new Uint8Array(e);if(t[0]=3735928559,239===n[0])return!0;if(222===n[0])return!1;throw new Error("unknown endianness")}}t.EncodingGlslLib=o},2691:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FragColorGlslLib=void 0;const r=n(1997),o=n(6757);class i extends r.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const e=(0,o.getGlsl)(this.context.glContext.version);return{setFragColor:new r.GlslLibRoutine(`\n        void setFragColor(float value) {\n            ${e.output} = encode(value);\n        }\n        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new r.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ",["encoding.decode"])}}}t.FragColorGlslLib=i},3878:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.replaceInlines=void 0;const n=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;t.replaceInlines=function(e){const t={};let r;for(;null!==(r=n.exec(e));){const e=r[3].split(",").map((e=>{const t=e.trim().split(" ");return t&&2===t.length?{type:t[0],name:t[1]}:null})).filter((e=>null!==e));t[r[2]]={params:e,body:r[4]}}for(const n in t){const o="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",n),i=new RegExp(o,"gm");for(;null!==(r=i.exec(e));){const o=r[1],i=r[2],a=r[3].split(","),s=o?`${o} ${i};`:"";let u=t[n].body,l="";t[n].params.forEach(((e,t)=>{e&&(l+=`${e.type} ${e.name} = ${a[t]};\n`)})),u=`${l}\n ${u}`,u=u.replace("return",`${i} = `);const c=`\n      ${s}\n      {\n        ${u}\n      }\n      `;e=e.replace(r[0],c)}}return e.replace(n,"")}},8897:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GlslPreprocessor=void 0;const r=n(1997),o=n(3878),i=n(1248),a=n(6757);t.GlslPreprocessor=class{constructor(e,t,n,o){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new r.GlslContext(e,t,n,o),Object.keys(i.glslRegistry).forEach((e=>{const t=new i.glslRegistry[e](this.context);this.libs[e]=t}));const a=this.glslLibRoutineDependencyGraph;for(const e in this.libs){const t=this.libs[e].getFunctions();for(const n in t){const o=e+"."+n;let i;a[o]?(i=a[o],i.routineBody=t[n].routineBody):(i=new r.GlslLibRoutineNode(o,t[n].routineBody),a[o]=i);const s=t[n].dependencies;if(s)for(let e=0;e<s.length;++e)if(a[s[e]])i.addDependency(a[s[e]]);else{const t=new r.GlslLibRoutineNode(s[e]);a[s[e]]=t,i.addDependency(t)}}}}preprocess(){const e=this.context.programInfo;let t=e.shaderSource;return this.context.programInfo.hasMain||(t=`${t}\n      ${(0,a.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),t=(0,o.replaceInlines)(t),`${(0,a.getFragShaderPreamble)(this.context.glContext.version)}\n    ${this.getUniforms(e.inputNames,e.variables)}\n    ${this.getImports(t)}\n    ${t}`}getImports(e){const t=this.selectGlslLibRoutinesToBeIncluded(e);if(0===t.length)return"";let n="";for(let e=0;e<t.length;++e){if(!t[e].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${t[e].name}`);n+=t[e].routineBody+"\n"}return n}selectGlslLibRoutinesToBeIncluded(e){const t=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n=>{const r=n.split(".")[1];-1!==e.indexOf(r)&&t.push(this.glslLibRoutineDependencyGraph[n])})),r.TopologicalSortGlslRoutines.returnOrderedNodes(t)}getUniforms(e,t){const n=[];if(e)for(const t of e)n.push(`uniform sampler2D ${t};`);if(t)for(const e of t)n.push(`uniform ${e.type} ${e.name}${e.arrayLength?`[${e.arrayLength}]`:""};`);return n.join("\n")}}},1248:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.glslRegistry=void 0;const r=n(6859),o=n(1371),i=n(2691),a=n(9183),s=n(9314);t.glslRegistry={encoding:o.EncodingGlslLib,fragcolor:i.FragColorGlslLib,vec:s.VecGlslLib,shapeUtils:a.ShapeUtilsGlslLib,coordinates:r.CoordsGlslLib}},9183:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ShapeUtilsGlslLib=void 0;const r=n(1997);class o extends r.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const e=this.context.outputTextureLayout.shape.length,t={};return this.context.programInfo.inputNames.forEach(((n,o)=>{const i=this.context.inputTextureLayouts[o].unpackedShape;if(i.length<=e){const o=i.length,a=e-o,s=`bcastIndices_${n}`;let u="";for(let e=0;e<o;++e)u+=`\n          realIndices[${e}] = int( mod(float(bcastedIndices[${a+e}]), ${i[e]}.0) );\n          `;const l=`\n        void ${s} (int bcastedIndices[${e}], out int realIndices[${o}]) {\n          ${u}\n        }\n        `;t[s]=new r.GlslLibRoutine(l)}})),t}bcastMatmulIndex(){const e=this.context.outputTextureLayout.shape.length,t={};return this.context.programInfo.inputNames.forEach(((n,o)=>{const i=this.context.inputTextureLayouts[o].shape;if(!(i.length<2||i.length>e)){const o=i.length,a=e-o,s=`bcastMatmulIndices_${n}`;let u="";for(let e=0;e<o-2;++e)u+=`\n          realIndices[${e}] = int( mod(float(bcastedIndices[${a+e}]), ${i[e]}.0) );\n          `;const l=`\n        void ${s}(int bcastedIndices[${e}], out int realIndices[${o}]) {\n          ${u}\n          realIndices[${o-1}] = bcastedIndices[${e-1}];\n          realIndices[${o-2}] = bcastedIndices[${e-2}];\n        }\n        `;t[s]=new r.GlslLibRoutine(l)}})),t}indicesToOffset(){const e={};return this.context.programInfo.inputNames.forEach(((t,n)=>{const i=this.context.inputTextureLayouts[n].shape,a=this.context.inputTextureLayouts[n].strides,s=i.length;let u=`indicesToOffset_${t}`;e[u]=new r.GlslLibRoutine(o.indexToOffsetSingle(u,s,a)),u=`indicesToOffset_${t}_T`,e[u]=new r.GlslLibRoutine(o.indexToOffsetSingle(u,s,a.slice().reverse()))})),e}static indexToOffsetSingle(e,t,n){let r="";for(let e=t-1;e>=0;--e)r+=`\n        offset += indices[${e}] * ${n[e]};\n        `;return`\n      int ${e}(int indices[${t}]) {\n        int offset = 0;\n        ${r}\n        return offset;\n      }\n      `}offsetToIndices(){const e={};return this.context.programInfo.inputNames.forEach(((t,n)=>{const i=this.context.inputTextureLayouts[n].shape,a=this.context.inputTextureLayouts[n].strides,s=i.length;let u=`offsetToIndices_${t}`;e[u]=new r.GlslLibRoutine(o.offsetToIndicesSingle(u,s,a)),u=`offsetToIndices_${t}_T`,e[u]=new r.GlslLibRoutine(o.offsetToIndicesSingle(u,s,a.slice().reverse()))})),e}static offsetToIndicesSingle(e,t,n){const r=[];for(let e=0;e<t-1;++e)r.push(`\n      indices[${e}] = offset / ${n[e]};`),r.push(`\n        offset -= indices[${e}] * ${n[e]};`);return r.push(`\n      indices[${t-1}] = offset;`),`\n      void ${e}(int offset, out int indices[${t}]) {\n        ${r.join("")}\n      }\n      `}incrementIndices(){const e={};return this.context.programInfo.inputNames.forEach(((t,n)=>{const o=this.context.inputTextureLayouts[n].shape,i=o.length,a=`incrementIndices_${t}`;let s="";for(let e=0;e<i;++e)s+=`\n        shape[${e}] = ${o[e]};`;const u=`\n        void ${a}(int axis, out int indices[${i}]) {\n          int shape[${i}];\n          ${s};\n          for(int i = ${i} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `;e[a]=new r.GlslLibRoutine(u)})),e}}t.ShapeUtilsGlslLib=o},6757:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getDefaultFragShaderMain=t.getFragShaderPreamble=t.getVertexShaderSource=t.getGlsl=void 0;const n={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},r={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function o(e){return 1===e?n:r}t.getGlsl=o,t.getVertexShaderSource=function(e){const t=o(e);return`${t.version}\n      precision highp float;\n      ${t.attribute} vec3 position;\n      ${t.attribute} vec2 textureCoord;\n\n      ${t.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`},t.getFragShaderPreamble=function(e){const t=o(e);return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFrag} vec2 TexCoords;\n    ${t.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `},t.getDefaultFragShaderMain=function(e,t){return`\n  void main() {\n    int indices[${t}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${o(e).output} = result;\n  }\n  `}},9314:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.VecGlslLib=void 0;const r=n(1997);class o extends r.GlslLib{constructor(e){super(e)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const e=this.context.outputTextureLayout.shape.length,t={add:"+=",sub:"-=",mul:"*=",div:"/="},n={};for(const o in t){const i=`${o}Vec`;let a="";for(let n=0;n<e;++n)a+=`\n          dest[${n}] ${t[o]} src[${n}];\n          `;const s=`\n        void ${i}(int src[${e}], out int dest[${e}]) {\n          ${a}\n        }\n        `;n[i]=new r.GlslLibRoutine(s)}return n}copyVec(){const e=this.context.outputTextureLayout.shape.length;let t="";for(let n=0;n<e;++n)t+=`\n        dest[${n}] = src[${n}];\n        `;const n=`\n      void copyVec(int src[${e}], out int dest[${e}]) {\n        ${t}\n      }\n      `;return{copyVec:new r.GlslLibRoutine(n)}}setVecItem(){const e=this.context.outputTextureLayout.shape.length;let t=`\n        if(index < 0)\n            index =${e} + index;\n        if (index == 0)\n            m[0] = value;\n        `;for(let n=1;n<e-1;++n)t+=`\n        else if (index == ${n})\n            m[${n}] = value;\n            `;t+=`\n        else\n            m[${e-1}] = value;\n        `;const n=`\n      void setVecItem(out int m[${e}], int index, int value) {\n        ${t}\n      }\n        `;return{setVecItem:new r.GlslLibRoutine(n)}}getVecItem(){const e=this.context.outputTextureLayout.shape.length;let t=`\n        if(index < 0)\n            index = ${e} + index;\n        if (index == 0)\n            return m[0];\n      `;for(let n=1;n<e-1;++n)t+=`\n        else if (index == ${n})\n            return m[${n}];\n      `;t+=`\n        else\n            return m[${e-1}];\n        `;const n=`\n      int getVecItem(int m[${e}], int index) {\n        ${t}\n      }\n    `;return{getVecItem:new r.GlslLibRoutine(n)}}}t.VecGlslLib=o},7860:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLInferenceHandler=void 0;const r=n(1315),o=n(9240),i=n(7273),a=n(9),s=n(7379),u=n(2488),l=n(540),c=n(3314),p=n(5639);t.WebGLInferenceHandler=class{constructor(e){this.session=e,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,t){return(0,c.calculateTextureWidthAndHeight)(this.session.layoutStrategy,e,t)}executeProgram(e,t){if(t.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");const n=[];for(let r=0;r<e.inputNames.length;++r)n[r]=this.getOrCreateTextureData(t[r],e.inputTypes[r]);const r=((e,t)=>{const n=t.map((e=>`${e.unpackedShape.join(",")};${e.width}x${e.height}`)).join("_");let r=e.name;return e.cacheHint&&(r+="["+e.cacheHint+"]"),r+=":"+n,r})(e,n);let o=this.session.programManager.getArtifact(r);const i=o?o.programInfo:"function"==typeof e.get?e.get():e,a=(0,c.createTextureLayoutFromTextureType)(this.session.layoutStrategy,i.output.dims,i.output.textureType),s=this.createTextureData(a,i.output.type);return o||(o=this.session.programManager.build(i,n,s),this.session.programManager.setArtifact(r,o)),this.runProgram(o,n,s),s}run(e,t){return this.executeProgram(e,t).tensor}runProgram(e,t,n){for(let n=0;n<t.length;++n)if(!!t[n].isPacked!=(e.programInfo.inputTypes[n]===p.TextureType.packed))throw new Error(`input[${n}] property packed inconsistent`);if(!!n.isPacked!=(e.programInfo.output.textureType===p.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(e,t,n)}getOrCreateTextureData(e,t){let n=this.getTextureData(e.dataId,t===p.TextureType.packed);if(!n&&(n=this.getTextureData(e.dataId,t!==p.TextureType.packed),n))return t===p.TextureType.packed?this.pack(n):this.unpack(n);if(!n){const r=(0,c.createTextureLayoutFromTextureType)(this.session.layoutStrategy,e.dims,t);if(t===p.TextureType.packedLastDimension){const n=1,r=4,o=e.dims;if(4===o.length){const i=[o[0],Math.ceil(o[1]*o[2]*o[3]/r)],a=(0,c.createTextureLayoutFromTextureType)(this.session.layoutStrategy,i,t);let s=e.numberData;if(o[1]*o[2]*o[3]%r!=0){const t=o[0],i=o[1]*o[2]*o[3],a=Math.ceil(i*n/r)*r;s=new Float32Array(t*a);for(let r=0;r<t;++r){const t=r*i,o=r*a+r%n*i;s.set(e.numberData.subarray(t,t+i),o)}}return this.createTextureData(a,e.type,s,e,1)}}if(t===p.TextureType.packed){const t=(0,c.createTextureLayoutFromShape)(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),r=this.createTextureData(t,e.type,e.numberData,e,1);n=this.pack(r)}else n=this.createTextureData(r,e.type,e.numberData,e,1)}return n}createTextureDataFromLayoutBindTensor(e,t,n,r){return this.createTextureData(e,t,n,r,1)}createTextureData(e,t,n,o,i){r.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);const a=this.session.textureManager.createTextureFromLayout(t,e,n,i);return this.createTextureDataFromTexture(e,t,a,o)}reshapeUnpacked(e,t){const n=this.getOrCreateTextureData(e,p.TextureType.unpacked),r={channels:n.channels,height:n.height,width:n.width,shape:0!==t.length?t:[1],strides:i.ShapeUtil.computeStrides(t),unpackedShape:t};return this.createTextureDataFromTexture(r,e.type,n.texture).tensor}reshapePacked(e,t){const n=this.getOrCreateTextureData(e,p.TextureType.packed);if((0,s.isReshapeCheap)(e.dims,t)){const r={channels:n.channels,height:n.height,width:n.width,shape:0!==t.length?t:[1],strides:i.ShapeUtil.computeStrides(t),unpackedShape:t,isPacked:!0};return this.createTextureDataFromTexture(r,e.type,n.texture).tensor}const r=(0,s.processDims3D)(e.dims),o=(0,s.processDims3D)(t),a=this.reshapePacked(e,r),u=this.run((0,s.createPackedReshape3DProgramInfoLoader)(this,a,o),[a]);return this.reshapePacked(u,t)}cast(e,t){const n=this.getOrCreateTextureData(e,p.TextureType.unpacked);return this.createTextureDataFromTexture(n,t,n.texture).tensor}createTextureDataFromTexture(e,t,n,r,i){const a=Object.assign(Object.assign({},e),{tensor:r||new o.Tensor(e.unpackedShape,t,(e=>this.readTexture(a)),(async e=>this.readTextureAsync(a)),void 0,i),texture:n});return this.setTextureData(a.tensor.dataId,a,e.isPacked),a}getTextureData(e,t=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,t):t?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,t,n=!1){this.session.isInitializer(e)?this.session.setTextureData(e,t,n):(n?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,t)}isTextureLayoutCached(e,t=!1){return!!this.getTextureData(e.dataId,t)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((e=>this.session.textureManager.releaseTexture(e))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((e=>this.session.textureManager.releaseTexture(e))),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,u.encodeAsUint8)(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,u.encodeAsUint8)(this,e))}pack(e){return this.executeProgram((0,a.createPackProgramInfoLoader)(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram((0,l.createUnpackProgramInfoLoader)(this,e.tensor),[e.tensor])}}},4110:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var o=Object.getOwnPropertyDescriptor(t,n);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,o)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return o(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.WEBGL_OP_RESOLVE_RULES=void 0;const a=n(8817),s=i(n(5194)),u=n(4752),l=n(6668),c=n(9754),p=n(5042),d=n(6742),f=n(4125),h=n(6149),g=n(5378),m=n(6981),b=n(7413),y=n(7006),w=n(8276),_=n(5565),v=n(2834),x=n(1010),T=n(8126),S=n(2801),O=n(565),A=n(2444),E=n(815),I=n(564),$=n(5416),P=n(1240),D=n(5944),k=n(5707),C=i(n(9087)),R=n(7862),M=n(3980);t.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",C.abs],["Acos","","7+",C.acos],["Add","","7+",s.add],["And","","7+",s.and],["Asin","","7+",C.asin],["Atan","","7+",C.atan],["AveragePool","","7+",v.averagePool,v.parseAveragePoolAttributes],["BatchNormalization","","7+",a.batchNormalization,a.parseBatchNormalizationAttributes],["Cast","","6+",u.cast,u.parseCastAttributes],["Ceil","","6+",C.ceil],["Clip","","6-10",C.clip,C.parseClipAttributes],["Clip","","11+",C.clipV11],["Concat","","4+",l.concat,l.parseConcatAttributes],["Conv","","1+",c.conv,c.parseConvAttributes],["ConvTranspose","","1+",p.convTranspose,p.parseConvTransposeAttributes],["Cos","","7+",C.cos],["Div","","7+",s.div],["Dropout","","7+",C.identity],["DepthToSpace","","1+",d.depthToSpace,d.parseDepthToSpaceAttributes],["Equal","","7+",s.equal],["Elu","","6+",C.elu,C.parseEluAttributes],["Exp","","6+",C.exp],["Flatten","","1+",f.flatten,f.parseFlattenAttributes],["Floor","","6+",C.floor],["FusedConv","com.microsoft","1+",c.conv,c.parseConvAttributes],["Gather","","1+",h.gather,h.parseGatherAttributes],["Gemm","","7-10",g.gemm,g.parseGemmAttributesV7],["Gemm","","11+",g.gemm,g.parseGemmAttributesV11],["GlobalAveragePool","","1+",v.globalAveragePool,v.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",v.globalMaxPool],["Greater","","7+",s.greater],["Identity","","1+",C.identity],["ImageScaler","","1+",m.imageScaler,m.parseImageScalerAttributes],["InstanceNormalization","","6+",b.instanceNormalization,b.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",C.leakyRelu,C.parseLeakyReluAttributes],["Less","","7+",s.less],["LRN","","1+",y.lrn,y.parseLrnAttributes],["Log","","6+",C.log],["MatMul","","1+",w.matMul,w.parseMatMulAttributes],["MaxPool","","1+",v.maxPool,v.parseMaxPoolAttributes],["Mul","","7+",s.mul],["Neg","","6+",C.neg],["Not","","1+",C.not],["Or","","7+",s.or],["Pad","","2-10",_.padV2,_.parsePadAttributesV2],["Pad","","11+",_.padV11,_.parsePadAttributesV11],["Pow","","7+",s.pow],["PRelu","","7+",s.pRelu],["ReduceLogSum","","1+",x.reduceLogSum,x.parseReduceAttributes],["ReduceMax","","1+",x.reduceMax,x.parseReduceAttributes],["ReduceMean","","1+",x.reduceMean,x.parseReduceAttributes],["ReduceMin","","1+",x.reduceMin,x.parseReduceAttributes],["ReduceProd","","1+",x.reduceProd,x.parseReduceAttributes],["ReduceSum","","1-12",x.reduceSum,x.parseReduceAttributes],["ReduceSumSquare","","1+",x.reduceLogSumSquare,x.parseReduceAttributes],["Relu","","6+",C.relu],["Reshape","","5+",T.reshape],["Resize","","10",S.resize,S.parseResizeAttributesV10],["Resize","","11+",S.resize,S.parseResizeAttributesV11],["Shape","","1+",O.shape],["Sigmoid","","6+",C.sigmoid],["Sin","","7+",C.sin],["Slice","","10+",A.sliceV10],["Slice","","1-9",A.slice,A.parseSliceAttributes],["Softmax","","1-12",E.softmax,E.parseSoftmaxAttributes],["Softmax","","13+",E.softmaxV13,E.parseSoftmaxAttributesV13],["Split","","2-12",I.split,I.parseSplitAttributes],["Sqrt","","6+",C.sqrt],["Squeeze","","1-12",$.squeeze,$.parseSqueezeAttributes],["Squeeze","","13+",$.squeezeV13],["Sub","","7+",s.sub],["Sum","","6+",P.sum],["Tan","","7+",C.tan],["Tanh","","6+",C.tanh],["Tile","","6+",D.tile],["Transpose","","1+",k.transpose,k.parseTransposeAttributes],["Upsample","","7-8",M.upsample,M.parseUpsampleAttributesV7],["Upsample","","9",M.upsample,M.parseUpsampleAttributesV9],["Unsqueeze","","1-12",R.unsqueeze,R.parseUnsqueezeAttributes],["Unsqueeze","","13+",R.unsqueezeV13],["Xor","","7+",s.xor]]},8817:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseBatchNormalizationAttributes=t.batchNormalization=void 0;const r=n(4910),o=n(6757),i=n(5639),a={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked]};t.batchNormalization=(e,t,n)=>(u(t),[e.run(Object.assign(Object.assign({},a),{cacheHint:n.cacheKey,get:()=>s(e,t,n)}),t)]),t.parseBatchNormalizationAttributes=e=>{const t=e.attributes.getFloat("epsilon",1e-5),n=e.attributes.getFloat("momentum",.9),o=e.attributes.getInt("spatial",1);return(0,r.createAttributeWithCacheKey)({epsilon:t,momentum:n,spatial:o})};const s=(e,t,n)=>{const r=(0,o.getGlsl)(e.session.backend.glContext.version),s=t[0].dims.length,[u,l]=e.calculateTextureWidthAndHeight(t[1].dims,i.TextureType.unpacked),c=`\n  float process(int[${s}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${u}, ${l});\n    float scale = getColorAsFloat(${r.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${r.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${r.texture2D}(Variance, position));\n    float b = getColorAsFloat(${r.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;\n  }`;return Object.assign(Object.assign({},a),{output:{dims:t[0].dims,type:t[0].type,textureType:i.TextureType.unpacked},shaderSource:c})},u=e=>{if(!e||5!==e.length)throw new Error("BatchNormalization requires 5 inputs.");const t=e[0],n=e[1],r=e[2],o=e[3],i=e[4];if(t.dims.length<3||1!==n.dims.length||1!==r.dims.length||1!==o.dims.length||1!==i.dims.length)throw new Error("invalid input shape.");if(n.dims[0]!==t.dims[1]||r.dims[0]!==t.dims[1]||o.dims[0]!==t.dims[1]||i.dims[0]!==t.dims[1])throw new Error("invalid input shape.");if("float32"!==t.type&&"float64"!==t.type||"float32"!==n.type&&"float64"!==n.type||"float32"!==r.type&&"float64"!==r.type||"float32"!==o.type&&"float64"!==o.type||"float32"!==i.type&&"float64"!==i.type)throw new Error("invalid input tensor types.")}},5194:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.xor=t.sub=t.pRelu=t.pow=t.or=t.mul=t.less=t.greater=t.equal=t.div=t.and=t.add=t.glslPRelu=t.glslPow=t.glslXor=t.glslOr=t.glslAnd=t.glslLess=t.glslGreater=t.glslEqual=t.glslSub=t.glslMul=t.glslDiv=t.glslAdd=void 0;const r=n(7273),o=n(1997),i=n(6757),a=n(5639);function s(){const e="add_";return{body:`\n  float ${e}(float a, float b) {\n    return a + b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function u(){const e="div_";return{body:`\n  float ${e}(float a, float b) {\n    return a / b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function l(){const e="mul_";return{body:`\n  float ${e}(float a, float b) {\n    return a * b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function c(){const e="sub_";return{body:`\n  float ${e}(float a, float b) {\n    return a - b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function p(){const e="equal_";return{body:`\n  float ${e}(float a, float b) {\n    return float(a == b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function d(){const e="greater_";return{body:`\n  float ${e}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function f(){const e="less_";return{body:`\n  float ${e}(float a, float b) {\n    return float(a < b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function h(){const e="and_";return{body:`\n  float ${e}(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function g(){const e="or_";return{body:`\n  float ${e}(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function m(){const e="xor_";return{body:`\n  float ${e}(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function b(){return function(e){const t=`${e}_`;return{body:`\n  float ${t}(float a, float b) {\n    return ${e}(a, b);\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return ${e}(v1, v2);\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}("pow")}function y(){const e="prelu_";return{body:`\n  float ${e}(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}t.glslAdd=s,t.glslDiv=u,t.glslMul=l,t.glslSub=c,t.glslEqual=p,t.glslGreater=d,t.glslLess=f,t.glslAnd=h,t.glslOr=g,t.glslXor=m,t.glslPow=b,t.glslPRelu=y;const w=(e,t,n,r=t[0].type,o)=>{const i=e.session.pack?a.TextureType.packed:a.TextureType.unpacked;return{name:n.name,inputNames:["A","B"],inputTypes:[i,i],cacheHint:o,get:()=>_(e,t,n,r)}},_=(e,t,n,o=t[0].type)=>{const s=e.session.pack?a.TextureType.packed:a.TextureType.unpacked,u=!r.ShapeUtil.areEqual(t[0].dims,t[1].dims);let l=t[0].dims;const c=e.session.pack;if(u){const a=r.BroadcastUtil.calcShape(t[0].dims,t[1].dims,!1);if(!a)throw new Error("Can't perform binary op on the given tensors");l=a;const u=l.length,p=0!==t[0].dims.length?t[0].dims.length:1,d=0!==t[1].dims.length?t[1].dims.length:1,f=0!==t[0].dims.length?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",h=0!==t[1].dims.length?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",g=(0,i.getGlsl)(e.session.backend.glContext.version),m=c?`\n      ${n.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${n.name}(a, b);\n        ${g.output} = result;\n      }`:`\n      ${n.body}\n      float process(int indices[${u}]) {\n        int aindices[${p}];\n        int bindices[${d}];\n        ${f}\n        ${h}\n        return ${n.name}(_A(aindices), _B(bindices));\n      }`;return{name:n.name,inputNames:["A","B"],inputTypes:[s,s],output:{dims:l,type:o,textureType:s},shaderSource:m,hasMain:c}}const p=(0,i.getGlsl)(e.session.backend.glContext.version),d=`\n    ${n.body}\n    void main() {\n      vec4 v1 = ${p.texture2D}(A, TexCoords);\n      vec4 v2 = ${p.texture2D}(B, TexCoords);\n      vec4 result = ${n.name}(v1, v2);\n      ${p.output} = result;\n    }\n    `;return{name:n.name,inputNames:["A","B"],inputTypes:[s,s],output:{dims:t[0].dims,type:o,textureType:s},shaderSource:d,hasMain:!0}};t.add=(e,t)=>[e.run(w(e,t,s()),t)],t.and=(e,t)=>[e.run(w(e,t,h(),"bool"),t)],t.div=(e,t)=>[e.run(w(e,t,u()),t)],t.equal=(e,t)=>[e.run(w(e,t,p(),"bool"),t)],t.greater=(e,t)=>[e.run(w(e,t,d(),"bool"),t)],t.less=(e,t)=>[e.run(w(e,t,f(),"bool"),t)],t.mul=(e,t)=>[e.run(w(e,t,l()),t)],t.or=(e,t)=>[e.run(w(e,t,g(),"bool"),t)],t.pow=(e,t)=>[e.run(w(e,t,b()),t)],t.pRelu=(e,t)=>[e.run(w(e,t,y()),t)],t.sub=(e,t)=>[e.run(w(e,t,c()),t)],t.xor=(e,t)=>[e.run(w(e,t,m(),"bool"),t)]},4752:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseCastAttributes=t.cast=void 0;const r=n(7273);t.cast=(e,t,n)=>(o(t),[e.cast(t[0],n)]),t.parseCastAttributes=e=>r.ProtoUtil.tensorDataTypeFromProto(e.attributes.getInt("to"));const o=e=>{if(!e||1!==e.length)throw new Error("Cast requires 1 input.");if("string"===e[0].type)throw new Error("Invalid input type.")}},4595:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedConcatProgramInfoLoader=void 0;const r=n(6757),o=n(5639),i=n(432),a=n(5614);t.createPackedConcatProgramInfoLoader=(e,t,n)=>{const u=(l=t.length,c=n.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:l},((e,t)=>`X${t}`)),inputTypes:Array(l).fill(o.TextureType.packed),cacheHint:c});var l,c;return Object.assign(Object.assign({},u),{get:()=>((e,t,n,u)=>{const l=n[0].dims.slice();if(u>=l.length||u<-1*l.length)throw new Error("axis specified for concat doesn't match input dimensionality");u<0&&(u=l.length+u);const c=l.slice(0);for(let e=1;e<n.length;e++){const t=n[e].dims.slice();for(let e=0;e<l.length;e++)if(e===u)c[u]+=t[e];else if(l[e]!==t[e])throw new Error("non concat dimensions must match")}const p=c.length,d=(0,a.getChannels)("coords",p),f=(0,i.getCoordsDataType)(p),h=(0,a.unpackFromChannel)(),g=n.map((e=>e.dims)),m=(0,i.getGlChannels)(p),b=new Array(g.length-1);b[0]=g[0][u];for(let e=1;e<b.length;e++)b[e]=b[e-1]+g[e][u];const y=m[u],w=m.slice(-2),_=m.join();let v=`if (${y} < ${b[0]}) {\n        return getChannel(\n            getX0(${_}), vec2(${w.join()}));\n        }`;for(let e=1;e<b.length;e++){const t=b[e-1];v+=`\n            if (${y} < ${b[e]}  && ${y} >= ${b[e-1]}) {\n              return getChannel(\n                getX${e}(${s(m,y,t)}),\n                vec2(${s(w,y,t)}));\n            }`}const x=b.length,T=b[b.length-1];v+=`\n            return getChannel(\n              getX${x}(${s(m,y,T)}),\n              vec2(${s(w,y,T)}));`;const S=(0,r.getGlsl)(e.session.backend.glContext.version),O=`\n          ${h}\n          float getValue(${m.map((e=>"int "+e))}) {\n            ${v}\n          }\n\n          void main() {\n            ${f} coords = getOutputCoords();\n            int lastDim = coords.${m[p-1]};\n            coords.${m[p-1]} = coords.${m[p-2]};\n            coords.${m[p-2]} = lastDim;\n\n            vec4 result = vec4(getValue(${d}), 0., 0., 0.);\n\n            ${d[p-1]} = ${d[p-1]} + 1;\n            if (${d[p-1]} < ${c[p-1]}) {\n              result.g = getValue(${d});\n            }\n\n            ${d[p-2]} = ${d[p-2]} + 1;\n            if (${d[p-2]} < ${c[p-2]}) {\n              result.a = getValue(${d});\n            }\n\n            ${d[p-1]} = ${d[p-1]} - 1;\n            if (${d[p-2]} < ${c[p-2]} &&\n                ${d[p-1]} < ${c[p-1]}) {\n              result.b = getValue(${d});\n            }\n            ${S.output} = result;\n          }\n        `;return Object.assign(Object.assign({},t),{output:{dims:c,type:n[0].type,textureType:o.TextureType.packed},shaderSource:O,hasMain:!0})})(e,u,t,n.axis)})};const s=(e,t,n)=>{const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}},6668:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseConcatAttributes=t.concat=void 0;const r=n(4910),o=n(5639),i=n(4595);t.concat=(e,t,n)=>(p(t),e.session.pack&&t[0].dims.length>1?[e.run((0,i.createPackedConcatProgramInfoLoader)(e,t,n),t)]:[e.run(a(e,t,n),t)]);const a=(e,t,n)=>{const r=(i=t.length,a=n.cacheKey,{name:"Concat",inputNames:Array.from({length:i},((e,t)=>`X${t}`)),inputTypes:Array(i).fill(o.TextureType.unpacked),cacheHint:a});var i,a;return Object.assign(Object.assign({},r),{get:()=>((e,t,n,r)=>{const i=n[0].dims.slice();if(r>=i.length||r<-1*i.length)throw new Error("axis specified for concat doesn't match input dimensionality");r<0&&(r=i.length+r);const a=i.slice(0);for(let e=1;e<n.length;e++){const t=n[e].dims.slice();for(let e=0;e<i.length;e++)if(e===r)a[r]+=t[e];else if(i[e]!==t[e])throw new Error("non concat dimensions must match")}const p=a.length,d=new Array(n.length);let f=0;for(let e=0;e<d.length;++e)f+=n[e].dims[r],d[e]=f;let h="";h=n.length<5?s(d):u(d);const g=`\n        ${l(n.length,p)}\n        ${c(d)}\n        ${h}\n        float process(int indices[${p}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${r}]);\n\n          if(textureIndex != 0) {\n            indices[${r}] = indices[${r}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;return Object.assign(Object.assign({},t),{output:{dims:a,type:n[0].type,textureType:o.TextureType.unpacked},shaderSource:g})})(0,r,t,n.axis)})},s=e=>`int getTextureWhereDataResides(int index) {\n      ${e.map(((e,t)=>`if(index<${e}) {return ${t};}\n`)).join("")}\n    }`,u=e=>s(e),l=(e,t)=>{const n=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${t}]) {`];for(let t=0;t<e;++t)0===t?n.push(`\tif (textureIndex == ${t}) { return _X${t}(indices); }`):t===e-1?n.push(`\telse { return _X${t}(indices); }`):n.push(`\telse if (textureIndex == ${t}) { return _X${t}(indices); }`);return n.push("\t}"),n.join("\n")},c=e=>{const t=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let n=0;n<e.length;++n)0===n?t.push(`\tif (index == ${n}) { return ${e[n]}; }`):n===e.length-1?t.push(`\telse { return ${e[n]}; }`):t.push(`\telse if (index == ${n}) { return ${e[n]}; }`);return t.push("\t}"),t.join("\n")};t.parseConcatAttributes=e=>(0,r.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis")});const p=e=>{if(!e||e.length<1)throw new Error("too few inputs");const t=e[0].type,n=e[0].dims.length;if("string"===t)throw new Error("string tensor is not supported yet");for(const r of e){if(r.type!==t)throw new Error("input tensors should be one type");if(r.dims.length!==n)throw new Error("input tensors should have the same shape")}}},7825:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createUnpackedGroupedConvProgramInfoLoader=void 0;const r=n(1315),o=n(6757),i=n(5639),a=n(9754),s=n(2150);t.createUnpackedGroupedConvProgramInfoLoader=(e,t,n)=>{const u=(l=t.length>2,c=n.cacheKey,{name:"GroupedConv",inputNames:l?["X","W","Bias"]:["X","W"],inputTypes:l?[i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked]:[i.TextureType.unpacked,i.TextureType.unpacked],cacheHint:c});var l,c;return Object.assign(Object.assign({},u),{get:()=>((e,t,n,u)=>{const l=t.length>2?"value += getBias(output_channel);":"",c=t[0].dims.slice(),p=t[1].dims.slice(),d=p[0]/u.group;r.Logger.verbose("GroupedConv",`autpPad:${u.autoPad}, dilations:${u.dilations}, group:${u.group}, kernelShape:${u.kernelShape}, pads:${u.pads}, strides:${u.strides}`);const f=(0,a.calculateOutputShape)(c,p,u.dilations,u.pads,u.strides),h=(0,o.getGlsl)(e.session.backend.glContext.version),{activationFunction:g,applyActivation:m}=(0,s.getActivationSnippet)(u),b=`\n  const ivec2 strides = ivec2(${u.strides[0]}, ${u.strides[1]});\n  const ivec2 pads = ivec2(${u.pads[0]}, ${u.pads[1]});\n  ${g}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${d};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {\n      int input_channel = group_id * ${p[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${u.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${c[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${u.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${c[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${l}\n    ${m}\n    ${h.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},n),{output:{dims:f,type:t[0].type,textureType:i.TextureType.unpacked},shaderSource:b,hasMain:!0})})(e,t,u,n)})}},7708:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.conv2DPacked=t.conv2DPackedPointwise=void 0;const r=n(9754),o=n(5950),i=n(5632);t.conv2DPackedPointwise=(e,t,n)=>{const o=t[0].dims,a=t[1].dims,s=(0,r.calculateOutputShape)(o,a,n.dilations,n.pads,n.strides),u=e.reshapePacked(t[0],[o[1],o[2]*o[3]]),l=e.reshapePacked(t[1],[a[0],a[1]]),c=t.length>2?[l,u,t[2]]:[l,u],p=e.run((0,i.createPackedMatmulProgramInfoLoader)(e,c,n),c);return e.reshapePacked(p,s)},t.conv2DPacked=(e,t,n)=>{const a=t[0].dims,s=t[1].dims,u=(0,r.calculateOutputShape)(a,s,n.dilations,n.pads,n.strides),l=e.run((0,o.createPackedIm2ColProgramInfoLoader)(e,t[0],t[1],u,n),[t[0]]),c=e.reshapePacked(t[1],[s[0],s[1]*s[2]*s[3]]),p=3===t.length?[c,l,t[2]]:[c,l],d=e.run((0,i.createPackedMatmulProgramInfoLoader)(e,p,n),p);return e.reshapePacked(d,u)}},5042:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseConvTransposeAttributes=t.convTranspose=void 0;const r=n(4910),o=n(6757),i=n(5639),a=n(2150),s=(e,t,n,r,o,i)=>(e-1)*t+n+(r-1)*o+1-i,u=(e,t,n,r,o)=>{const i=Math.floor(e/2);"SAME_UPPER"===t?(n[r]=i,n[o]=e-i):"SAME_LOWER"===t&&(n[r]=e-i,n[o]=i)};t.convTranspose=(e,t,n)=>(d(t,n),l(e,t,n));const l=(e,t,n)=>{const r=p(n,t);return[c(e,t,r)]},c=(e,t,n)=>e.run(((e,t,n)=>{const r=(s=t.length>2,u=n.cacheKey,{name:"ConvTranspose",inputNames:s?["X","W","B"]:["X","W"],inputTypes:s?[i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked]:[i.TextureType.unpacked,i.TextureType.unpacked],cacheHint:u});var s,u;return Object.assign(Object.assign({},r),{get:()=>((e,t,n,r)=>{const s=t.length>2?"getB(output_channel)":"0.0",u=t[0].dims,l=t[1].dims,c=l[1],p=l[0]/r.group,d=[t[0].dims[0],t[1].dims[1]*r.group,...r.outputShape],f=(0,o.getGlsl)(e.session.backend.glContext.version),{activationFunction:h,applyActivation:g}=(0,a.getActivationSnippet)(r),m=`\n  const ivec2 strides = ivec2(${r.strides[0]}, ${r.strides[1]});\n  const ivec2 pads = ivec2(${r.pads[0]}, ${r.pads[1]});\n  ${h}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${c};\n    int wOutChannel = output_channel - group_id * ${c};\n\n    float value = ${s};\n    for (int inChannelOffset = 0; inChannelOffset < ${p}; inChannelOffset++) {\n      int input_channel = group_id * ${p} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${l[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${l[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${r.dilations[0]}, wHOff * ${r.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${u[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${u[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${g}\n    ${f.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},n),{output:{dims:d,type:t[0].type,textureType:i.TextureType.unpacked},shaderSource:m,hasMain:!0})})(e,t,r,n)})})(e,t,n),t),p=(e,t)=>{const n=e.kernelShape.slice();if(0===e.kernelShape.length)for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e]);const r=e.pads.slice(),o=e.outputShape.slice();((e,t,n,r,o,i,a,l)=>{const c=e.length-2,p=0===l.length;for(let d=0;d<c;++d){const f=p?e[d+2]*i[d]:l[d],h=s(e[d+2],i[d],o[d],t[d],n[d],f);u(h,r,o,d,d+c),p&&l.push(i[d]*(e[d+2]-1)+a[d]+(t[d]-1)*n[d]+1-o[d]-o[d+c])}})(t[0].dims,n,e.dilations,e.autoPad,r,e.strides,e.outputPadding,o);const i=Object.assign({},e);return Object.assign(i,{kernelShape:n,pads:r,outputShape:o,cacheKey:e.cacheKey}),i};t.parseConvTransposeAttributes=e=>{const t=e.attributes,n=(0,a.parseInternalActivationAttributes)(t),o=t.getString("auto_pad","NOTSET"),i=t.getInts("dilations",[1,1]),s=t.getInt("group",1),u=t.getInts("kernel_shape",[]),l=t.getInts("output_padding",[0,0]),c=t.getInts("output_shape",[]),p=t.getInts("pads",[0,0,0,0]),d=t.getInts("strides",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:o,dilations:i,group:s,kernelShape:u,outputPadding:l,outputShape:c,pads:p,strides:d},n))};const d=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length||4!==e[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims[1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const n=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==n))throw new Error("invalid bias");const r=e[0].dims.length-2;if(t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(t.outputPadding.length!==r)throw new Error(`output_padding should be ${r}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape");if("float32"!==e[0].type||"float32"!==e[1].type)throw new Error("ConvTranspose input(X,W) should be float tensor");if(3===e.length&&"float32"!==e[2].type)throw new Error("ConvTranspose input(bias) should be float tensor")}},9754:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseConvAttributes=t.conv=t.calculateOutputShape=void 0;const r=n(4910),o=n(7273),i=n(7825),a=n(7708),s=n(3281),u=n(2150),l=n(1625),c=n(8276);t.calculateOutputShape=(e,t,n,r,o)=>{const i=e[0],a=e.slice(2),s=a.length,u=t[0],l=t.slice(2).map(((e,t)=>e+(e-1)*(n[t]-1))),c=a.map(((e,t)=>e+r[t]+r[t+s])).map(((e,t)=>Math.floor((e-l[t]+o[t])/o[t])));return[i,u].concat(...c)},t.conv=(e,t,n)=>(g(t,n),p(e,t,n));const p=(e,t,n)=>{const r=h(n,t),o=e.session.pack,s=1===r.kernelShape[0]&&1===r.kernelShape[1];return r.group>1?[e.run((0,i.createUnpackedGroupedConvProgramInfoLoader)(e,t,r),t)]:s&&o?[d(e,t,r)]:o&&4===t[0].dims.length&&1===t[0].dims[0]&&!s?[(0,a.conv2DPacked)(e,t,r)]:[f(e,t,r)]},d=(e,n,r)=>{const o=n[0].dims,i=n[1].dims,a=(0,t.calculateOutputShape)(o,i,r.dilations,r.pads,r.strides),s=e.reshapeUnpacked(n[0],[o[1],o[2]*o[3]]),u=e.reshapeUnpacked(n[1],[i[0],i[1]]),l=n.length>2?[u,s,n[2]]:[u,s],p=e.run((0,c.createMatmulProgramInfoLoader)(l,r),l);return e.reshapeUnpacked(p,a)},f=(e,n,r)=>{const o=n[0].dims,i=n[1].dims,a=(0,t.calculateOutputShape)(o,i,r.dilations,r.pads,r.strides),u=e.run((0,l.createIm2ColProgramInfoLoader)(e,n[0],n[1],a,r),[n[0]]),c=3===n.length?[u,n[1],n[2]]:[u,n[1]];return e.run((0,s.createDotProductProgramInfoLoader)(e,n,a,r),c)},h=(e,t)=>{const n=e.kernelShape.slice();if(0===e.kernelShape.length)for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e]);const r=e.pads.slice();o.PoolConvUtil.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,e.autoPad);const i=Object.assign({},e);return Object.assign(i,{kernelShape:n,pads:r,cacheKey:e.cacheKey}),i};t.parseConvAttributes=e=>{const t=e.attributes,n=(0,u.parseInternalActivationAttributes)(t),o=t.getString("auto_pad","NOTSET"),i=t.getInts("dilations",[1,1]),a=t.getInt("group",1),s=t.getInts("kernel_shape",[]),l=t.getInts("pads",[0,0,0,0]),c=t.getInts("strides",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:o,dilations:i,group:a,kernelShape:s,pads:l,strides:c},n))};const g=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length||4!==e[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims[1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");const n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if("float32"!==e[0].type||"float32"!==e[1].type)throw new Error("Conv input(X,W) should be float tensor");if(3===e.length&&"float32"!==e[2].type)throw new Error("Conv input(bias) should be float tensor")}},6742:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseDepthToSpaceAttributes=t.depthToSpace=void 0;const r=n(5707);t.depthToSpace=(e,t,n)=>{o(t);const i=n.blocksize,a=i*i,s="DCR"===n.mode?[0,3,4,1,5,2]:[0,1,4,2,5,3],u="DCR"===n.mode?[t[0].dims[0],i,i,t[0].dims[1]/a,t[0].dims[2],t[0].dims[3]]:[t[0].dims[0],t[0].dims[1]/a,i,i,t[0].dims[2],t[0].dims[3]],l=e.reshapeUnpacked(t[0],u),c={perm:s,cacheKey:`${s}`},[p]=(0,r.transpose)(e,[l],c),d=[t[0].dims[0],t[0].dims[1]/a,t[0].dims[2]*i,t[0].dims[3]*i];return[e.reshapeUnpacked(p,d)]},t.parseDepthToSpaceAttributes=e=>{const t=e.attributes.getInt("blocksize");if(t<1)throw new Error(`blocksize must be >= 1, but got : ${t} for DepthToSpace`);const n=e.attributes.getString("mode","DCR");if("DCR"!==n&&"CRD"!==n)throw new Error(`unrecognized mode: ${n} for DepthToSpace`);return{mode:n,blocksize:t}};const o=e=>{if(1!==e.length)throw new Error(`DepthToSpace expect 1 inputs, but got ${e.length}`);if("string"===e[0].type||4!==e[0].dims.length)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},3281:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createDotProductProgramInfoLoader=void 0;const r=n(7273),o=n(6757),i=n(5639),a=n(2150),s=n(1625);t.createDotProductProgramInfoLoader=(e,t,n,u)=>{const l=((e,t)=>({name:"ConvDotProduct",inputNames:e?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:e?[i.TextureType.unpacked,i.TextureType.packedLastDimension,i.TextureType.unpacked]:[i.TextureType.unpacked,i.TextureType.packedLastDimension],cacheKey:t.activationCacheKey}))(t.length>2,u);return Object.assign(Object.assign({},l),{get:()=>((e,t,n,u,l)=>{const c=n[0].dims,p=n[1].dims,d=[p[0],Math.ceil(c[1]*p[2]*p[3]/4)],f=(0,s.calculateIm2ColDims)(c,p,u),[h,g]=e.calculateTextureWidthAndHeight(d,i.TextureType.packedLastDimension),m=r.ShapeUtil.computeStrides(f),[b,y]=e.calculateTextureWidthAndHeight(f,i.TextureType.packedLastDimension),w=u.length,_=n.length<3?"0.0":"_B(b)",v=Math.ceil(c[1]*p[2]*p[3]/4),{activationFunction:x,applyActivation:T}=(0,a.getActivationSnippet)(l),S=(0,o.getGlsl)(e.session.backend.glContext.version),O=`\n${x}\nfloat process(int indices[${w}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${m[0]} + im2col[1] * ${m[1]} + im2col[2] * ${m[2]};\n  int kernelOffset = indices[1] * ${d[1]};\n  float value = ${_};\n  for (int i = 0; i < ${v}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${b}, ${y});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h}, ${g});\n    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${T}\n  return value;\n}`;return Object.assign(Object.assign({},t),{output:{dims:u,type:n[0].type,textureType:i.TextureType.unpacked},shaderSource:O})})(e,l,t,n,u)})}},4125:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseFlattenAttributes=t.flatten=void 0;const r=n(7273);t.flatten=(e,t,n)=>{o(t,n);const i=r.ShapeUtil.flattenShape(t[0].dims,n);return[e.reshapeUnpacked(t[0],i)]},t.parseFlattenAttributes=e=>e.attributes.getInt("axis",1);const o=(e,t)=>{if(!e||1!==e.length)throw new Error("Flatten requires 1 input.");const n=e[0].dims.length;if(0===n)throw new Error("scalar tensor is not supported.");if(t<-n||t>n)throw new Error("Invalid axis");if("string"===e[0].type)throw new Error("string tensor is not supported.")}},2150:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseInternalActivationAttributes=t.getActivationSnippet=void 0;const r=n(7273),o=n(9087);t.getActivationSnippet=function(e){let t;switch(e.activation){case"Relu":t=(0,o.glslRelu)();break;case"Sigmoid":t=(0,o.glslSigmoid)();break;case"Clip":t=(0,o.glslClip)(e.clipMin,e.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const n=t.name;return{activationFunction:t.body,applyActivation:`value = ${n}_(value);`}},t.parseInternalActivationAttributes=e=>{const t=e.getString("activation","");if("Clip"===t){const[n,o]=e.getFloats("activation_params",[r.MIN_CLIP,r.MAX_CLIP]);return{activation:t,clipMax:o,clipMin:n,activationCacheKey:`${t}:${n},${o}`}}return{activation:t,activationCacheKey:t}}},6149:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseGatherAttributes=t.gather=void 0;const r=n(4910),o=n(6145),i=n(7273),a=n(5639);t.gather=(e,t,n)=>(l(t,n.axis),[e.run(u(e,t,n),t)]),t.parseGatherAttributes=e=>(0,r.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis",0)});const s={name:"Gather",inputNames:["A","B"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked]},u=(e,t,n)=>{const r=Object.assign(Object.assign({},s),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((e,t,n,r)=>{const o=n[0].dims.slice(),s=n[1].dims.slice(),u=new Array(o.length+s.length-1);r=i.ShapeUtil.normalizeAxis(r,o.length);const l=[];for(let e=0;e<u.length;e++)e<r?(u[e]=o[e],l.push(`inputIdx[${e}] = outputIdx[${e}];`)):e<r+s.length?(u[e]=s[e-r],l.push(`indexDataIdx[${e-r}] = outputIdx[${e}];`)):(u[e]=o[e-s.length+1],l.push(`inputIdx[${e-s.length+1}] = outputIdx[${e}];`));const c=`\n      float process(int outputIdx[${u.length||1}]) {\n        int inputIdx[${o.length}];\n        int indexDataIdx[${s.length||1}];\n        indexDataIdx[0] = 0;\n        ${l.join("\n        ")}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${r}] = idx < 0 ? idx + ${o[r]} : idx;\n        return _A(inputIdx);\n      }`;return Object.assign(Object.assign({},t),{output:{dims:u,type:n[0].type,textureType:a.TextureType.unpacked},shaderSource:c})})(0,r,t,n.axis)})},l=(e,t)=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.");const n=e[0].dims.length;if(n<1)throw new Error("Invalid input shape.");if(t<-n||t>n-1)throw new Error("Invalid axis.");if(-1===o.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invaid input type.");if("int32"!==e[1].type&&"int16"!==e[1].type)throw new Error("Invaid input type.")}},5378:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseGemmAttributesV11=t.parseGemmAttributesV7=t.gemm=void 0;const r=n(4910),o=n(7273),i=n(5639);t.gemm=(e,t,n)=>(l(t,n),[e.run(s(t,n),t)]);const a=(e,t)=>{const n=0!==e.attributes.getInt("transA",0),o=0!==e.attributes.getInt("transB",0),i=e.attributes.getFloat("alpha",1),a=e.attributes.getFloat("beta",1);return(0,r.createAttributeWithCacheKey)({transA:n,transB:o,alpha:i,beta:a,isOptionalC:t})};t.parseGemmAttributesV7=e=>a(e,!1),t.parseGemmAttributesV11=e=>a(e,!0);const s=(e,t)=>{const n={name:"Gemm",inputNames:3===e.length?["A","B","C"]:["A","B"],inputTypes:3===e.length?[i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked]:[i.TextureType.unpacked,i.TextureType.unpacked],key:t.cacheKey};return Object.assign(Object.assign({},n),{get:()=>u(n,e,t)})},u=(e,t,n)=>{const r=t[0].dims.slice(),a=t[1].dims.slice(),[s,u]=o.GemmUtil.getShapeOfGemmResult(r,n.transA,a,n.transB,3===t.length?t[2].dims:void 0),l=[s,u];if(!l)throw new Error("Can't use gemm on the given tensors");let c=r[r.length-1],p="";n.transA&&(c=r[0]),n.transA&&n.transB?p="value += _A_T(a) * _B_T(b);":n.transA&&!n.transB?p="value += _A_T(a) * _B(b);":!n.transA&&n.transB?p="value += _A(a) * _B_T(b);":n.transA||n.transB||(p="value += _A(a) * _B(b);");const d=l.length,f=`\n      float process(int indices[${d}]) {\n          int a[${d}];\n          int b[${d}];\n          ${3===t.length?`int c[${t[2].dims.length}];`:""}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${3===t.length?"bcastIndices_C(indices, c);":""}\n\n          float value = 0.0;\n          for (int k=0; k<${c}; ++k) {\n              a[${d-1}] = k;\n              b[${d-2}] = k;\n              ${p}\n          }\n\n          value = value * alpha;\n          ${3===t.length?"value += beta * _C(c);":""}\n          return value;\n      }`;return Object.assign(Object.assign({},e),{output:{dims:l,type:t[0].type,textureType:i.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:n.alpha},{name:"beta",type:"float",data:n.beta}],shaderSource:f})},l=(e,t)=>{if(!e)throw new Error("Input is missing");if(t.isOptionalC&&(e.length<2||e.length>3))throw new Error("Invaid input shape.");if(!t.isOptionalC&&3!==e.length)throw new Error("Gemm requires 3 inputs");if(3===e.length&&1!==e[2].dims.length&&2!==e[2].dims.length)throw new Error("Invalid input shape of C");if("float32"!==e[0].type&&"float64"!==e[0].type||"float32"!==e[1].type&&"float64"!==e[1].type||3===e.length&&"float32"!==e[2].type&&"float64"!==e[2].type)throw new Error("Invalid input type.");if(e[0].type!==e[1].type||3===e.length&&e[0].type!==e[2].type)throw new Error("Input types are mismatched")}},5950:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedIm2ColProgramInfoLoader=void 0;const r=n(6757),o=n(5639),i=n(5614);t.createPackedIm2ColProgramInfoLoader=(e,t,n,a,s)=>{const u=(l=s.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[o.TextureType.packed],cacheHint:l});var l;return Object.assign(Object.assign({},u),{get:()=>((e,t,n,a,s,u)=>{const l=n.dims,c=a.dims,p=s.length,d=[c[1]*c[2]*c[3],s[2]*s[3]],f=c[2]*c[3],h=(0,i.unpackFromChannel)(),g=(0,r.getGlsl)(e.session.backend.glContext.version);let m="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)m+=`\n            blockIndex = rc.x + ${t};\n            pos = rc.y + ${e};\n\n            if(blockIndex < ${d[1]} && pos < ${d[0]}) {\n              offsetY = int(blockIndex / (${s[p-1]})) * ${u.strides[0]} -\n                ${u.pads[0]};\n              d0 = offsetY + ${u.dilations[0]} * (imod(pos, ${f}) / ${c[2]});\n\n              if(d0 < ${l[2]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${s[p-1]}) * ${u.strides[1]} -\n                  ${u.pads[1]};\n                d1 = offsetX + ${u.dilations[1]} * imod(imod(pos, ${f}), ${c[2]});\n\n                if(d1 < ${l[3]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${f}.);\n                    innerDims = vec2(d0, d1);\n                    result[${2*e+t}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;const b=`\n      ${h}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${m}\n          ${g.output} = result;\n      }\n            `;return Object.assign(Object.assign({},t),{output:{dims:d,type:n.type,textureType:o.TextureType.packed},shaderSource:b,hasMain:!0})})(e,u,t,n,a,s)})}},1625:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.calculateIm2ColDims=t.createIm2ColProgramInfoLoader=void 0;const r=n(5639);t.createIm2ColProgramInfoLoader=(e,n,o,i,a)=>{const s=(u=a.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[r.TextureType.unpacked],cacheHint:u});var u;return Object.assign(Object.assign({},s),{get:()=>((e,n,o,i,a,s)=>{const u=o.dims,l=i.dims,c=a.length,p=(0,t.calculateIm2ColDims)(u,l,a,4),d=`\n        const int XC = ${u[1]};\n        const int XH = ${u[2]};\n        const int XW = ${u[3]};\n        const int KH = ${s.kernelShape[0]};\n        const int KW = ${s.kernelShape[1]};\n        const int dilationH = ${s.dilations[0]};\n        const int dilationW = ${s.dilations[1]};\n        const int strideH = ${s.strides[0]};\n        const int strideW = ${s.strides[1]};\n        const int padH = ${s.pads[0]};\n        const int padW = ${s.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${c}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${u.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;return Object.assign(Object.assign({},n),{output:{dims:p,type:o.type,textureType:r.TextureType.packedLastDimension},shaderSource:d})})(0,s,n,o,i,a)})},t.calculateIm2ColDims=(e,t,n,r=4)=>[n[0],n[2],n[3],Math.ceil(e[1]*t[2]*t[3]/r)]},6981:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseImageScalerAttributes=t.imageScaler=void 0;const r=n(4910),o=n(5639);t.imageScaler=(e,t,n)=>(u(t),[e.run(a(e,t,n),t)]),t.parseImageScalerAttributes=e=>{const t=e.attributes.getFloat("scale"),n=e.attributes.getFloats("bias");return(0,r.createAttributeWithCacheKey)({scale:t,bias:n})};const i={name:"ImageScaler",inputNames:["X"],inputTypes:[o.TextureType.unpacked]},a=(e,t,n)=>{const r=Object.assign(Object.assign({},i),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((e,t,n,r)=>{const i=n[0].dims.slice(),a=i.length,u=`\n      ${s(r.bias.length)}\n      float process(int indices[${a}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;return Object.assign(Object.assign({},t),{output:{dims:i,type:n[0].type,textureType:o.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:r.bias.length,data:r.bias},{name:"scale",type:"float",data:r.scale}],shaderSource:u})})(0,r,t,n)})},s=e=>{const t=[`float getBias(float bias[${e}], int channel) {`];for(let n=0;n<e;++n)0===n?t.push(`\tif (channel == ${n}) { return bias[${n}]; }`):n===e-1?t.push(`\telse { return bias[${n}]; }`):t.push(`\telse if (channel == ${n}) { return bias[${n}]; }`);return t.push("\t}"),t.join("\n")},u=e=>{if(!e||1!==e.length)throw new Error("ImageScaler requires 1 input.");if(4!==e[0].dims.length)throw new Error("Invalid input shape.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.")}},7413:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseInstanceNormalizationAttributes=t.instanceNormalization=void 0;const r=n(6757),o=n(5639);t.instanceNormalization=(e,t,n)=>{l(t);const r=e.run(a(t[0]),t);return[e.run(u(e,t[0],n,r.dims),[t[0],r,t[1],t[2]])]},t.parseInstanceNormalizationAttributes=e=>e.attributes.getFloat("epsilon",1e-5);const i={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[o.TextureType.unpacked]},a=e=>Object.assign(Object.assign({},i),{get:()=>((e,t)=>{const n=t.dims.slice(),r=n[1],i=n[2]*n[3],a=[n[0],r],s=`\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${n[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${n[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${i});\n        temp = 0.0;\n        for(int a2=0; a2<${n[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${n[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${i});\n\n        return v;\n      }`;return Object.assign(Object.assign({},e),{output:{dims:a,type:t.type,textureType:o.TextureType.packedLastDimension},shaderSource:s})})(i,e)}),s={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[o.TextureType.unpacked,o.TextureType.packedLastDimension,o.TextureType.unpacked,o.TextureType.unpacked]},u=(e,t,n,i)=>{const a=Object.assign(Object.assign({},s),{cacheHint:`${n}`});return Object.assign(Object.assign({},a),{get:()=>((e,t,n,i,a)=>{const s=(0,r.getGlsl)(e.session.backend.glContext.version),[u,l]=e.calculateTextureWidthAndHeight(a,o.TextureType.packedLastDimension),[c,p]=[u/4,l],d=`\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${c}, ${p});\n        return ${s.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;return Object.assign(Object.assign({},t),{output:{dims:n.dims,type:n.type,textureType:o.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:i}],shaderSource:d})})(e,a,t,n,i)})},l=e=>{if(!e||3!==e.length)throw new Error("InstanceNormalization requires 3 inputs.");const t=e[0],n=e[1],r=e[2];if(t.dims.length<3||1!==n.dims.length||1!==r.dims.length)throw new Error("Invalid input shape.");if(n.dims[0]!==t.dims[1]||r.dims[0]!==t.dims[1])throw new Error("Input shapes are mismatched.");if("float32"!==t.type&&"float64"!==t.type||"float32"!==n.type&&"float64"!==n.type||"float32"!==r.type&&"float64"!==r.type)throw new Error("Invalid input type.");if(4!==e[0].dims.length)throw new Error("Only support 4-D input shape.")}},7006:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createLrnProgramInfoLoader=t.parseLrnAttributes=t.lrn=void 0;const r=n(4910),o=n(5639);t.lrn=(e,t,n)=>(s(t),[e.run(a(t,n),t)]),t.parseLrnAttributes=e=>{const t=e.attributes.getFloat("alpha",1e-4),n=e.attributes.getFloat("beta",.75),o=e.attributes.getFloat("bias",1),i=e.attributes.getInt("size");return(0,r.createAttributeWithCacheKey)({alpha:t,beta:n,bias:o,size:i})};const i={name:"LRN",inputNames:["X"],inputTypes:[o.TextureType.unpacked]};function a(e,t){return Object.assign(Object.assign({},i),{cacheHint:t.cacheKey,get:()=>function(e,t){const n=e[0].dims[1],r=e[0].dims.length,a=-Math.floor((t.size-1)/2),s=Math.ceil((t.size-1)/2),u=`float(${t.alpha}) / float(${t.size})`,l=`\n    float process(int indices[${r}]) {\n        int c = indices[1];\n        float x = _X(indices);\n        float square_sum = 0.0;\n\n        for (int i = ${a}; i <= ${s}; i++) {\n          int idx = c + i;\n          if (c >= 0 && c < ${n}) {\n            indices[1] = idx;\n            float j = _X(indices);\n            square_sum += j * j;\n          }\n        }\n        return x / pow(float(${t.bias}) + ${u} * square_sum, float(${t.beta}));\n    }`;return Object.assign(Object.assign({},i),{cacheHint:t.cacheKey,output:{dims:e[0].dims,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:l})}(e,t)})}t.createLrnProgramInfoLoader=a;const s=e=>{if(!e||1!==e.length)throw new Error("LRN requires 1 input.");if(4!==e[0].dims.length)throw new Error('currently only support LRN for input with "NCHW" format');if("float32"!==e[0].type)throw new Error("input should be float type")}},5632:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedMatmulProgramInfoLoader=void 0;const r=n(7273),o=n(6757),i=n(5639),a=n(432),s=n(2150),u=n(8276);t.createPackedMatmulProgramInfoLoader=(e,t,n)=>{const l=(c=t.length>2,p=n.activationCacheKey,{name:"MatMul (packed)",inputNames:c?["A","B","Bias"]:["A","B"],inputTypes:c?[i.TextureType.packed,i.TextureType.packed,i.TextureType.packed]:[i.TextureType.packed,i.TextureType.packed],cacheHint:p});var c,p;return Object.assign(Object.assign({},l),{get:()=>((e,t,n,l)=>{const c=n.length>2,p=c?"value += getBiasForMatmul();":"",d=n[0].dims,f=n[1].dims,h=r.BroadcastUtil.calcShape(d,f,!0),g=!r.ShapeUtil.areEqual(n[0].dims,n[1].dims);if(!h)throw new Error("Can't use matmul on the given tensors");const m=d[d.length-1],b=Math.ceil(m/2),y=d.length,w=f.length,_=(0,o.getGlsl)(e.session.backend.glContext.version),v=(0,a.getCoordsDataType)(h.length),x=h.length,T=(0,a.getGlChannels)(),{activationFunction:S,applyActivation:O}=(0,s.getActivationSnippet)(l),A=c?`${(0,u.getBiasForMatmul)(v,T,n[2].dims,h,!0)}`:"",E=g?`${function(e,t,n,o){let i=[],a=[];const s=n[0].dims,u=n[1].dims,l=s.length,c=u.length,p=o.length,d=p-l,f=p-c;i=s.map(((e,n)=>`coords.${t[n+d]}`)),i[l-1]="i*2",i.join(", "),a=u.map(((e,n)=>`coords.${t[n+f]}`)),a[c-2]="i*2",a.join(", ");const h=r.BroadcastUtil.getBroadcastDims(s,o),g=r.BroadcastUtil.getBroadcastDims(u,o),m=h.map((e=>`coords.${t[e+d]} = 0;`)).join("\n"),b=g.map((e=>`coords.${t[e+f]} = 0;`)).join("\n"),y=`int lastDim = coords.${t[p-1]};\n  coords.${t[p-1]} = coords.${t[p-2]};\n  coords.${t[p-2]} = lastDim;`;return`\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${e} coords = getOutputCoords();\n  ${y}\n  ${m}\n  vec4 outputValue = getA(${i});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${e} coords = getOutputCoords();\n  ${y}\n  ${b}\n  vec4 outputValue = getB(${a});\n  return outputValue;\n}`}(v,T,n,h)}`:"",I=g?"getAAtOutCoordsMatmul(i)":`getA(${function(e,t){let n="";for(let r=0;r<t-2;r++)n+=`rc.${e[r]}, `;return n+=`rc.${e[t-2]}, i*2`,n}(T,y)})`,$=g?"getBAtOutCoordsMatmul(i)":`getB(${function(e,t){let n="";for(let r=0;r<t-2;r++)n+=`rc.${e[r]}, `;return n+=`i*2, rc.${e[t-1]}`,n}(T,w)})`,P=`\n            ${E}\n            ${A}\n            ${S}\n            void main() {\n              ${g?"":`${v} rc =\n          getOutputCoords(); int lastDim = rc.${T[x-1]}; rc.${T[x-1]} =\n          rc.${T[x-2]}; rc.${T[x-2]} = lastDim;\n      `}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${b}; i++) {\n                vec4 a = ${I};\n                vec4 b = ${$};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${p}\n              ${O}\n              ${_.output} = value;\n            }`;return Object.assign(Object.assign({},t),{output:{dims:h,type:n[0].type,textureType:i.TextureType.packed},shaderSource:P,hasMain:!0})})(e,l,t,n)})}},8276:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getBiasForMatmul=t.createMatmulProgramInfoLoader=t.parseMatMulAttributes=t.matMul=void 0;const r=n(7273),o=n(5639),i=n(432),a=n(2150),s=n(5632);t.matMul=(e,t,n)=>(c(t),e.session.pack?[e.run((0,s.createPackedMatmulProgramInfoLoader)(e,t,n),t)]:[e.run(l(t,n),t)]),t.parseMatMulAttributes=e=>(0,a.parseInternalActivationAttributes)(e.attributes);const u=(e,t)=>({name:"MatMul",inputNames:e?["A","B","Bias"]:["A","B"],inputTypes:e?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],cacheHint:t});function l(e,t){const n=u(e.length>2,t.activationCacheKey);return Object.assign(Object.assign({},n),{get:()=>function(e,t,n){const s=t[0].dims,u=t[1].dims,l=r.BroadcastUtil.calcShape(s,u,!0);if(!l)throw new Error("Can't use matmul on the given tensors");const c=(0,i.getCoordsDataType)(l.length),d=(0,i.getGlChannels)(),{activationFunction:f,applyActivation:h}=(0,a.getActivationSnippet)(n),g=t.length>2,m=g?"value += getBiasForMatmul();":"",b=g?`${p(c,d,t[2].dims,l,!1)}`:"",y=l.length,w=s.length,_=u.length,v=`\n    ${f}\n    ${b}\n    float process(int indices[${y}]) {\n        int a[${w}];\n        int b[${_}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${s[s.length-1]}; ++k) {\n            a[${w-1}] = k;\n            b[${_-2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${m}\n        ${h}\n        return value;\n    }`;return Object.assign(Object.assign({},e),{output:{dims:l,type:t[0].type,textureType:o.TextureType.unpacked},shaderSource:v})}(n,e,t)})}t.createMatmulProgramInfoLoader=l;const c=e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if("float32"!==e[0].type&&"float64"!==e[0].type||"float32"!==e[1].type&&"float64"!==e[1].type)throw new Error("inputs should be float type");if(e[0].type!==e[1].type)throw new Error("inputs types should match")};function p(e,t,n,o,i){let a="";const s=n.length,u=o.length,l=u-s;a=u<2&&s>0?"coords":n.map(((e,n)=>`coords.${t[n+l]}`)).join(", ");const c=r.BroadcastUtil.getBroadcastDims(n,o).map((e=>`coords.${t[e+l]} = 0;`)).join("\n");let p="vec4(outputValue.xx, outputValue.yy)";return 1===r.ShapeUtil.size(n)&&(p="vec4(outputValue.x)"),i?`\nvec4 getBiasForMatmul() {\n  ${e} coords = getOutputCoords();\n  ${c}\n  vec4 outputValue = getBias(${a});\n  return ${p};\n}`:`\nfloat getBiasForMatmul() {\n  ${e} coords = getOutputCoords();\n  ${c}\n  return getBias(coords.x);\n}`}t.getBiasForMatmul=p},9:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createPackProgramInfoLoader=void 0;const r=n(6757),o=n(5639),i=n(432),a=n(5614),s={name:"pack",inputNames:["A"],inputTypes:[o.TextureType.unpackedReversed]};t.createPackProgramInfoLoader=(e,t)=>Object.assign(Object.assign({},s),{get:()=>((e,t)=>{const n=(0,r.getGlsl)(e.session.backend.glContext.version),u=t.dims,l=u.length,c=t.dims.length,p=(0,i.getCoordsDataType)(c),d=(0,a.getChannels)("rc",c),f=(h=c,g=d,m=u[u.length-2],b=u[u.length-1],0===h||1===h?"":`\n    int r = ${g[h-2]};\n    int c = ${g[h-1]};\n    int rp1 = ${g[h-2]} + 1;\n    int cp1 = ${g[h-1]} + 1;\n    bool rEdge = rp1 >= ${b};\n    bool cEdge = cp1 >= ${m};\n    `);var h,g,m,b;let y;y=0===l?[1,1]:1===l?[u[0],1]:[u[c-1],u[c-2]];const w=function(e,t,n){if(0===e)return"false";if(1===e)return`rc > ${t[0]}`;let r="";for(let o=e-2;o<e;o++)r+=`${n[o]} >= ${t[o-e+2]}`,o<e-1&&(r+="||");return r}(c,y,d),_=function(e,t){const n=e.length;if(0===n)return"getA(), 0, 0, 0";if(1===n)return`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`;let r="";if(n>2)for(let e=0;e<n-2;++e)r+=`${t[e]},`;return`getA(${r}r, c),\n          rEdge ? 0. : getA(${r}rp1, c),\n          cEdge ? 0. : getA(${r}r, cp1),\n          rEdge || cEdge ? 0. : getA(${r}rp1, cp1)`}(u,d),v=`\n        void main() {\n          ${p} rc = getOutputCoords();\n\n          if(${w}) {\n            ${n.output} = vec4(0);\n          } else {\n            ${f}\n\n            ${n.output} = vec4(${_});\n          }\n        }\n      `;return Object.assign(Object.assign({},s),{hasMain:!0,output:{dims:t.dims,type:t.type,textureType:o.TextureType.packed},shaderSource:v})})(e,t)})},5614:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.unpackFromChannel=t.getChannels=t.getVecChannels=void 0;const r=n(432);function o(e,t){return(0,r.getGlChannels)(t).map((t=>`${e}.${t}`))}t.getVecChannels=o,t.getChannels=function(e,t){return 1===t?[e]:o(e,t)},t.unpackFromChannel=function(){return"\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  "}},5565:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parsePadAttributesV11=t.padV11=t.parsePadAttributesV2=t.padV2=void 0;const r=n(4910),o=n(7273),i=n(6757),a=n(5639),s={name:"Pad",inputNames:["A"],inputTypes:[a.TextureType.unpacked]};t.padV2=(e,t,n)=>(c(t),[e.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>l(e,t[0],n)}),t)]),t.parsePadAttributesV2=e=>{const t=e.attributes.getString("mode","constant"),n=e.attributes.getFloat("value",0),o=e.attributes.getInts("pads");return(0,r.createAttributeWithCacheKey)({mode:t,value:n,pads:o})},t.padV11=(e,n,r)=>{p(n);const o=u(e,n,r);return(0,t.padV2)(e,[n[0]],o)},t.parsePadAttributesV11=e=>e.attributes.getString("mode","constant");const u=(e,t,n)=>{if(!e.session.isInitializer(t[1].dataId)||t.length>=3&&!e.session.isInitializer(t[2].dataId))throw new Error("dynamic pad attributes are not allowed");const o=Array.from(t[1].integerData),i=t.length>=3?t[2].floatData[0]:0;return(0,r.createAttributeWithCacheKey)({mode:n,pads:o,value:i})},l=(e,t,n)=>{const r=o.ShapeUtil.padShape(t.dims.slice(),n.pads),i=r.length,s=`\n      ${d(e,t,n)}\n      float process(int[${i}] indices) {\n          return padA(indices);\n      }`;return{name:"Pad",inputNames:["A"],inputTypes:[a.TextureType.unpacked],output:{dims:r,type:t.type,textureType:a.TextureType.unpacked},shaderSource:s}},c=e=>{if(!e||1!==e.length)throw new Error("Pad requires 1 input");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.")},p=e=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Pad requires 2 or 3 inputs");if("int32"!==e[1].type)throw new Error("Invalid input type.");if(e.length>=3&&"string"===e[2].type)throw new Error("Invalid input type.")},d=(e,t,n)=>{const r=(0,i.getGlsl)(e.session.backend.glContext.version),[s,u]=e.calculateTextureWidthAndHeight(t.dims,a.TextureType.unpacked),l=o.ShapeUtil.computeStrides(t.dims);switch(n.mode){case"constant":return f(r,t.dims,l,s,u,n.pads,n.value);case"reflect":return h(r,t.dims,l,s,u,n.pads);case"edge":return g(r,t.dims,l,s,u,n.pads);default:throw new Error("Invalid mode")}},f=(e,t,n,r,o,i,a)=>{const s=t.length;let u="";for(let e=s-1;e>=0;--e)u+=`\n        k = m[${e}] - ${i[e]};\n        if (k < 0)  return constant;\n        if (k >= ${t[e]}) return constant;\n        offset += k * ${n[e]};\n        `;return`\n      float padA(int m[${s}]) {\n        const float constant = float(${a});\n        int offset = 0;\n        int k = 0;\n        ${u}\n        vec2 coords = offsetToCoords(offset, ${r}, ${o});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `},h=(e,t,n,r,o,i)=>{const a=t.length;let s="";for(let e=a-1;e>=0;--e)s+=`\n        k = m[${e}] - ${i[e]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2*(t[e]-1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${t[e]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${n[e]};\n        `;return`\n      float padA(int m[${a}]) {\n        int offset = 0;\n        int k = 0;\n        ${s}\n        vec2 coords = offsetToCoords(offset, ${r}, ${o});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `},g=(e,t,n,r,o,i)=>{const a=t.length;let s="";for(let e=a-1;e>=0;--e)s+=`\n        k = m[${e}] - ${i[e]};\n        if (k < 0)  k = 0;\n        if (k >= ${t[e]}) k = ${t[e]-1};\n        offset += k * ${n[e]};\n      `;return`\n      float padA(int m[${a}]) {\n        int offset = 0;\n        int k = 0;\n        ${s}\n        vec2 coords = offsetToCoords(offset, ${r}, ${o});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `}},2834:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.globalMaxPool=t.parseMaxPoolAttributes=t.maxPool=t.parseGlobalAveragePoolAttributes=t.globalAveragePool=t.parseAveragePoolAttributes=t.averagePool=void 0;const r=n(4910),o=n(7273),i=n(5639);t.averagePool=(e,t,n)=>{p(t);const r={name:"AveragePool",inputNames:["X"],inputTypes:[i.TextureType.unpacked],cacheHint:n.cacheKey};return[e.run(Object.assign(Object.assign({},r),{get:()=>a(t,r,!1,n)}),t)]},t.parseAveragePoolAttributes=e=>{const t=e.attributes.getString("auto_pad","NOTSET"),n=e.attributes.getInt("ceil_mode",0),o=0!==e.attributes.getInt("count_include_pad",0),i=e.attributes.getInts("kernel_shape"),a=e.attributes.getInts("strides",[]),s=e.attributes.getInts("pads",[]);if(0!==n)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,r.createAttributeWithCacheKey)({autoPad:t,ceilMode:n,countIncludePad:o,kernelShape:i,strides:a,pads:s})};const a=(e,t,n,r)=>{const[a,s]=u(e,r,n),l=o.ShapeUtil.size(a.kernelShape);let c="";a.countIncludePad?c+=`value /= float(${l});`:c+=`value /= float(${l} - pad);`;const p=`\n        ${d(e[0].dims,a,"value += _X(x);",c,"0.0")}\n      `;return Object.assign(Object.assign({},t),{output:{dims:s,type:e[0].type,textureType:i.TextureType.unpacked},shaderSource:p})};t.globalAveragePool=(e,t,n)=>{p(t);const r={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[i.TextureType.unpacked],cacheHint:`${n.countIncludePad}`};return[e.run(Object.assign(Object.assign({},r),{get:()=>a(t,r,!0,n)}),t)]},t.parseGlobalAveragePoolAttributes=e=>{const t=0!==e.attributes.getInt("count_include_pad",0);return(0,r.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:t,kernelShape:[],strides:[],pads:[]})},t.maxPool=(e,t,n)=>{p(t);const r={name:"MaxPool",inputNames:["X"],inputTypes:[i.TextureType.unpacked],cacheHint:n.cacheKey};return[e.run(Object.assign(Object.assign({},r),{get:()=>s(t,r,!1,n)}),t)]},t.parseMaxPoolAttributes=e=>{const t=e.attributes.getString("auto_pad","NOTSET"),n=e.attributes.getInt("ceil_mode",0),o=e.attributes.getInts("kernel_shape"),i=e.attributes.getInts("strides",[]),a=e.attributes.getInts("pads",[]),s=e.attributes.getInt("storage_order",0),u=e.attributes.getInts("dilations",[]);if(0!==s)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==n)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,r.createAttributeWithCacheKey)({autoPad:t,ceilMode:n,countIncludePad:!1,kernelShape:o,strides:i,pads:a,storageOrder:s,dilations:u})};const s=(e,t,n,r)=>{const[o,a]=u(e,r,n),s=`\n      ${d(e[0].dims,o,"\n      value = max(_X(x), value);\n    ","","-1e5")}\n    `;return Object.assign(Object.assign({},t),{output:{dims:a,type:e[0].type,textureType:i.TextureType.unpacked},shaderSource:s})},u=(e,t,n)=>{const r=e[0].dims.slice(),i=Object.hasOwnProperty.call(t,"dilations"),a=t.kernelShape.slice(),s=t.strides.slice(),u=i?t.dilations.slice():[],l=t.pads.slice();o.PoolConvUtil.adjustPoolAttributes(n,r,a,s,u,l);const c=o.PoolConvUtil.computePoolOutputShape(n,r,s,u,a,l,t.autoPad),p=Object.assign({},t);return i?Object.assign(p,{kernelShape:a,strides:s,pads:l,dilations:u,cacheKey:t.cacheKey}):Object.assign(p,{kernelShape:a,strides:s,pads:l,cacheKey:t.cacheKey}),[p,c]},l={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},c={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[i.TextureType.unpacked]};t.globalMaxPool=(e,t)=>(p(t),[e.run(Object.assign(Object.assign({},c),{get:()=>s(t,c,!0,l)}),t)]);const p=e=>{if(!e||1!==e.length)throw new Error("Pool ops requires 1 input.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.")},d=(e,t,n,r,i)=>{const a=e.length;if(t.kernelShape.length<=2){const o=t.kernelShape[t.kernelShape.length-1],s=t.strides[t.strides.length-1],u=t.pads[t.pads.length/2-1],l=t.pads[t.pads.length-1],c=e[a-1];let p="",d="",f="";if(p=u+l!==0?`\n          for (int i = 0; i < ${o}; i++) {\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\n            if (x[${a} - 1] < 0 || x[${a} - 1] >= ${c}) {\n              pad++;\n              continue;\n            }\n            ${n}\n          }`:`\n          for (int i = 0; i < ${o}; i++) {\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\n            ${n}\n          }`,2===t.kernelShape.length){const n=t.kernelShape[t.kernelShape.length-2],r=t.strides[t.strides.length-2],i=t.pads[t.pads.length/2-2],s=t.pads[t.pads.length-2],u=e[a-2];d=i+s!==0?`\n            for (int j = 0; j < ${n}; j++) {\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${i} + j;\n              if (x[${a} - 2] < 0 || x[${a} - 2] >= ${u}) {\n                pad+= ${o};\n                continue;\n              }\n          `:`\n            for (int j = 0; j < ${n}; j++) {\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${i} + j;\n            `,f="\n          }\n        "}return`\n        float process(int indices[${a}]) {\n          int x[${a}];\n          copyVec(indices, x);\n\n          float value = ${i};\n          int pad = 0;\n          ${d}\n          ${p}\n          ${f}\n          ${r}\n          return value;\n        }\n      `}{const s=o.ShapeUtil.size(t.kernelShape),u=o.ShapeUtil.computeStrides(t.kernelShape),l=u.length,c=t.pads.length,p=h(l),d=f(e,"inputDims"),g=f(t.pads,"pads"),m=f(u,"kernelStrides"),b=f(t.strides,"strides");let y="";return y=t.pads.reduce(((e,t)=>e+t))?`\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${n}\n          }`:`\n          }\n          ${n}\n        `,`\n        ${p}\n        float process(int indices[${a}]) {\n          int x[${a}];\n          copyVec(indices, x);\n          int offset[${l}];\n          int pads[${c}];\n          int inputDims[${a}];\n          int kernelStrides[${l}];\n          int strides[${l}];\n          ${g}\n          ${d}\n          ${b}\n          ${m}\n\n          float value = ${i};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${s}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${a} - ${l}; j < ${a}; j++) {\n              x[j] = indices[j] * strides[j - ${a} + ${l}]\n                + offset[j - ${a} + ${l}] - pads[j - 2];\n              ${y}\n          }\n          ${r}\n\n          return value;\n        }\n      `}},f=(e,t)=>{let n="";for(let r=0;r<e.length;r++)n+=`\n      ${t}[${r}] = ${e[r]};\n    `;return n},h=e=>`\n  void offsetToIndices(int offset, int[${e}] strides, out int[${e}] indices) {\n    if (${e} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${e} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${e} - 1] = offset;\n  }`},1010:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.reduceLogSumSquare=t.reduceLogSum=t.reduceProd=t.reduceMin=t.reduceMax=t.reduceMean=t.reduceSum=t.parseReduceAttributes=void 0;const r=n(4910),o=n(6145),i=n(7273),a=n(5639),s=(e,t,n,r,o)=>{l(t);const i={name:r,inputNames:["A"],inputTypes:[a.TextureType.unpacked]};return[e.run(Object.assign(Object.assign({},i),{cacheHint:n.cacheKey,get:()=>u(e,t,n,r,o,i)}),t)]};t.parseReduceAttributes=e=>{const t=e.attributes.getInts("axes",[]),n=1===e.attributes.getInt("keepdims",1);return(0,r.createAttributeWithCacheKey)({axes:t,keepDims:n})};const u=(e,t,n,r,o,s)=>{const u=[],l=t[0].dims.length||1,c=[],p=i.ShapeUtil.normalizeAxes(n.axes,t[0].dims.length),d=o(t,p);let f=d[1];for(let e=0;e<t[0].dims.length;e++)p.indexOf(e)>=0||0===p.length?(n.keepDims&&u.push(1),f=`\n          for(int j${e} = 0; j${e} < ${t[0].dims[e]}; j${e}++) {\n            inputIdx[${e}] = j${e};\n            ${f}\n          }`):(c.push(`inputIdx[${e}] = outputIdx[${u.length}];`),u.push(t[0].dims[e]));const h=`\n      float process(int outputIdx[${u.length||1}]) {\n        float value;                 // final result\n        int inputIdx[${l}];      // addressing input data\n        ${c.join("\n")}\n        ${d[0]}       // init ops for reduce max/min\n        ${f}\n        ${d[2]}       // final computation for reduce mean\n        return value;\n      }`;return Object.assign(Object.assign({},s),{output:{dims:u,type:t[0].type,textureType:a.TextureType.unpacked},shaderSource:h})},l=e=>{if(!e||1!==e.length)throw new Error("Reduce op requires 1 input.");if(-1===o.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invalid input type.")};t.reduceSum=(e,t,n)=>s(e,t,n,"ReduceSum",(()=>["value = 0.0;","value += _A(inputIdx);",""])),t.reduceMean=(e,t,n)=>s(e,t,n,"ReduceMean",((e,t)=>{let n=1;for(let r=0;r<e[0].dims.length;r++)(t.indexOf(r)>=0||0===t.length)&&(n*=e[0].dims[r]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${n}.;`]})),t.reduceMax=(e,t,n)=>s(e,t,n,"ReduceMax",((e,t)=>{const n=[];for(let r=0;r<e[0].dims.length;r++)(t.indexOf(r)>=0||0===t.length)&&n.push(`inputIdx[${r}] = 0;`);return[`${n.join("\n")}\nvalue = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]})),t.reduceMin=(e,t,n)=>s(e,t,n,"ReduceMin",((e,t)=>{const n=[];for(let r=0;r<e[0].dims.length;r++)(t.indexOf(r)>=0||0===t.length)&&n.push(`inputIdx[${r}] = 0;`);return[`${n.join("\n")}\nvalue = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]})),t.reduceProd=(e,t,n)=>s(e,t,n,"ReduceProd",(()=>["value = 1.0;","value *= _A(inputIdx);",""])),t.reduceLogSum=(e,t,n)=>s(e,t,n,"ReduceLogSum",(()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"])),t.reduceLogSumSquare=(e,t,n)=>s(e,t,n,"ReduceLogSumSquare",(()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""]))},7379:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isReshapeCheap=t.processDims3D=t.createPackedReshape3DProgramInfoLoader=void 0;const r=n(7273),o=n(6757),i=n(5639),a=n(5614);t.createPackedReshape3DProgramInfoLoader=(e,t,n)=>{const s=(e=>({name:"Reshape (packed)",inputTypes:[i.TextureType.packed],inputNames:["A"],cacheHint:`${e}`}))(n);return Object.assign(Object.assign({},s),{get:()=>((e,t,n,s)=>{const u=t.dims,l=s;let c="";for(let e=0;e<4;e++){let t="";switch(e){case 0:t="outputCoords = rc;";break;case 1:t="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:t="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:t="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}c+=`\n        ${t}\n        ${e>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${e>0?"}":""}\n      `}const p=(0,o.getGlsl)(e.session.backend.glContext.version),d=`\n      ${function(e){const t=r.ShapeUtil.computeStrides(e),n=["b","r","c"],o="index";return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t.map(((e,r)=>`int ${n[r]} = ${o} / ${e}; ${r===t.length-1?`int ${n[r+1]} = ${o} - ${n[r]} * ${e}`:`index -= ${n[r]} * ${e}`};`)).join("")}\n      return ivec3(b, r, c);\n    }\n  `}(u)}\n      ${function(e){const t=r.ShapeUtil.computeStrides(e);return`\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${t[0]} + coords.z * ${t[1]} + coords.y;\n  }\n`}(l)}\n      ${(0,a.unpackFromChannel)()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${l[2]};\n        int cols = ${l[1]};\n\n        ${c}\n        ${p.output} = result;\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:l,type:t.type,textureType:i.TextureType.packed},shaderSource:d,hasMain:!0})})(e,t,s,n)})},t.processDims3D=function(e){if(0===e.length)return[1,1,1];let t=1;for(let n=0;n<e.length-2;++n)t*=e[n];return[t,e.length>1?e[e.length-2]:1,e[e.length-1]]},t.isReshapeCheap=function(e,t){let n=!1;return n=0===e.length||0===t.length||(e.length<2||t.length<2?e[e.length-1]===t[t.length-1]:e[e.length-1]===t[t.length-1]&&e[e.length-2]===t[t.length-2]),n}},8126:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.reshape=void 0;const r=n(7273);t.reshape=(e,t)=>{const n=r.ShapeUtil.calculateReshapedDims(t[0].dims,t[1].integerData);return e.session.pack?[e.reshapePacked(t[0],n)]:[e.reshapeUnpacked(t[0],n)]}},2801:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseResizeAttributesV11=t.parseResizeAttributesV10=t.resize=void 0;const r=n(6757),o=n(5639),i=n(432),a=n(5614),s=n(3980),u={name:"Resize",inputNames:["A"],inputTypes:[o.TextureType.packed]};t.resize=(e,t,n)=>((0,s.validateInputs)(t,n),[e.run(Object.assign(Object.assign({},u),{cacheHint:n.cacheKey,get:()=>l(e,t,n)}),t)]),t.parseResizeAttributesV10=e=>(0,s.parseUpsampleAttributes)(e,10),t.parseResizeAttributesV11=e=>(0,s.parseUpsampleAttributes)(e,11);const l=(e,t,n)=>{const s=(0,r.getGlsl)(e.session.backend.glContext.version),[l,p]=c(t,n);if(l.every((e=>1===e))&&"tf_crop_and_resize"!==n.coordinateTransformMode)return Object.assign(Object.assign({},u),{output:{dims:p,type:t[0].type,textureType:o.TextureType.packed},hasMain:!0,shaderSource:`void main() {\n                    vec4 v = ${s.texture2D}(X, TexCoords);\n                    ${s.output} = v;\n                }`});const d=p.length;if(d<2)throw new Error(`output dimension should be at least 2, but got ${d}`);const f=p[d-2],h=p[d-1],g=t[0].dims;if(d!==g.length)throw new Error(`output dimension should match input ${g.length}, but got ${d}`);const m=g[d-2],b=g[d-1],y=l[d-2],w=l[d-1];let _="";if("linear"!==n.mode)throw new Error(`resize (packed) does not support mode: '${n.mode}'`);switch(n.coordinateTransformMode){case"asymmetric":_="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";break;case"half_pixel":_="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";break;case"pytorch_half_pixel":_=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${h}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${f}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${h}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${f}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;break;case"align_corners":_=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${h}.0 - 1.0, ${f}.0 - 1.0, ${h}.0 - 1.0,\n                            ${f}.0 - 1.0);\n                        vec4 original = vec4(${b}.0 - 1.0, ${m}.0 - 1.0, ${b}.0 - 1.0,\n                            ${m}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n.coordinateTransformMode}'`)}const v=(0,i.getCoordsDataType)(d),x=`\n            const vec2 inputWH = vec2(${m}.0, ${b}.0);\n            const vec4 scaleWHWH = vec4(float(${y}), float(${w}), float(${y}), float(${w}));\n            ${(0,a.unpackFromChannel)()}\n            ${_}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${v} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${f-1};\n                bool hasNextCol = rc.z < ${h-1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${s.output} = vec4(newValue);\n            }\n        `;return Object.assign(Object.assign({},u),{output:{dims:p,type:t[0].type,textureType:o.TextureType.packed},hasMain:!0,shaderSource:x})},c=(e,t)=>{const n=e[0].dims;let r,o=t.scales;if(0===o.length){const i=e[t.scalesInputIdx];if(i&&0!==i.size){if(e[t.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");o=p(i,t.mode,t.isResize)}else{const i=e[t.sizesInputIdx];if(!i||0===i.size)throw new Error("Either scales or sizes MUST be provided as input.");r=Array.from(i.integerData),o=d(r,n,t.mode,t.isResize)}}else if(e[t.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const i=r||n.map(((e,t)=>Math.floor(e*o[t])));return[o,i]},p=(e,t,n)=>{const r=Array.from(e.floatData);return(0,s.scalesValidation)(r,t,n),r},d=(e,t,n,r)=>{const o=t.length,i=new Array(o);for(let n=0,r=o;n<r;n++)if(0===t[n]){if(0!==e[n])throw new Error("Input dim is zero but required output dim is non-zero.");i[n]=1}else i[n]=e[n]/t[n];return(0,s.scalesValidation)(i,n,r),i}},565:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.shape=void 0;const r=n(9240);t.shape=(e,t)=>(o(t),[new r.Tensor([t[0].dims.length],"int32",void 0,void 0,new Int32Array(t[0].dims))]);const o=e=>{if(!e||1!==e.length)throw new Error("Shape requires 1 input.")}},2444:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.sliceV10=t.parseSliceAttributes=t.slice=void 0;const r=n(4910),o=n(6145),i=n(7273),a=n(5639),s={name:"Slice",inputNames:["A"],inputTypes:[a.TextureType.unpacked]};t.slice=(e,t,n)=>(l(t),[e.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>u(e,t[0],n)}),t)]),t.parseSliceAttributes=e=>{const t=e.attributes.getInts("starts"),n=e.attributes.getInts("ends"),o=e.attributes.getInts("axes",[]);return(0,r.createAttributeWithCacheKey)({starts:t,ends:n,axes:o})};const u=(e,t,n)=>{const r=0===n.axes.length?t.dims.slice(0).map(((e,t)=>t)):n.axes,o=i.ShapeUtil.normalizeAxes(r,t.dims.length),u=n.starts.map(((e,n)=>e>t.dims[o[n]]-1?t.dims[o[n]]:i.ShapeUtil.normalizeAxis(e,t.dims[o[n]]))),l=n.ends.map(((e,n)=>e>t.dims[o[n]]-1?t.dims[o[n]]:i.ShapeUtil.normalizeAxis(e,t.dims[o[n]]))),c=t.dims.slice(),p=[];for(let e=0;e<o.length;e++)c[o[e]]=l[e]-u[e],u[e]>0&&p.push(`outputIdx[${o[e]}] += ${u[e]};`);const d=`\n      float process(int outputIdx[${c.length}]) {\n        ${p.join("\n      ")}\n        return _A(outputIdx);\n      }`;return Object.assign(Object.assign({},s),{output:{dims:c,type:t.type,textureType:a.TextureType.unpacked},shaderSource:d})},l=e=>{if(!e||1!==e.length)throw new Error("Slice requires 1 input.");if(-1===o.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invalid input type.")};t.sliceV10=(e,t)=>{p(t);const n=c(e,t);return[e.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>u(e,t[0],n)}),[t[0]])]};const c=(e,t)=>{if(!e.session.isInitializer(t[1].dataId)||!e.session.isInitializer(t[2].dataId)||t.length>=4&&!e.session.isInitializer(t[3].dataId)||t.length>=5&&!e.session.isInitializer(t[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(t.length>=5&&t[4].integerData.some((e=>1!==e)))throw new Error("currently non-1 steps is not supported for Slice");const n=Array.from(t[1].integerData),r=Array.from(t[2].integerData),o=t.length>=4?Array.from(t[3].integerData):[];return{starts:n,ends:r,axes:o,cacheKey:`${o};${n};${r}`}},p=e=>{if(!e||e.length<3||e.length>5)throw new Error("Invalid input number.");if("int32"!==e[1].type||1!==e[1].dims.length)throw new Error("Invalid input type.");if("int32"!==e[2].type||1!==e[2].dims.length)throw new Error("Invalid input type.");if(e.length>=4&&("int32"!==e[3].type||1!==e[3].dims.length))throw new Error("Invalid input type.");if(e.length>=5&&("int32"!==e[4].type||1!==e[4].dims.length))throw new Error("Invalid input type.")}},815:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.softmaxV13=t.parseSoftmaxAttributesV13=t.parseSoftmaxAttributes=t.softmax=void 0;const r=n(4910),o=n(7273),i=n(6757),a=n(5639),s=n(5707),u={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[a.TextureType.unpacked]},l={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked]},c={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]};t.softmax=(e,t,n)=>{g(t);const r=t[0].dims.slice(),i=o.ShapeUtil.normalizeAxis(n.axis,r.length),a=o.ShapeUtil.sizeToDimension(r,i),s=o.ShapeUtil.sizeFromDimension(r,i);return p(e,t,n,a,s)},t.parseSoftmaxAttributes=e=>(0,r.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis",1)}),t.parseSoftmaxAttributesV13=e=>(0,r.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis",-1)}),t.softmaxV13=(e,t,n)=>{g(t);const i=t[0].dims.slice(),a=o.ShapeUtil.normalizeAxis(n.axis,i.length),u=i.length,l=a!==u-1,c=[];let d,f=[],h=[];l&&(f=Array.from({length:u}).map(((e,t)=>t)),f[a]=u-1,f[u-1]=a,f.map((e=>c.push(i[e]))),d=(0,r.createAttributeWithCacheKey)({perm:f}),h=(0,s.transpose)(e,t,d));const m=l?o.ShapeUtil.sizeToDimension(c,u-1):o.ShapeUtil.sizeToDimension(i,u-1),b=l?o.ShapeUtil.sizeFromDimension(c,u-1):o.ShapeUtil.sizeFromDimension(i,u-1),y=p(e,l?h:t,n,m,b);return l?(0,s.transpose)(e,y,d):y};const p=(e,t,n,r,o)=>{const i=d(e,t[0],r,o,[r]),a=e.run(Object.assign(Object.assign({},u),{cacheHint:n.cacheKey,get:()=>i}),t),s=f(e,t[0],r,o,i.output.dims,[r]),p=e.run(Object.assign(Object.assign({},l),{cacheHint:n.cacheKey,get:()=>s}),[t[0],a]),g=h(e,t[0],r,o,i.output.dims,s.output.dims);return[e.run(Object.assign(Object.assign({},c),{cacheHint:n.cacheKey,get:()=>g}),[t[0],a,p])]},d=(e,t,n,r,o)=>{const[s,l]=e.calculateTextureWidthAndHeight(t.dims,a.TextureType.unpacked),c=o.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==o.length)throw new Error("Dimensionality of the output should be 1");if(o[0]!==n)throw new Error("Shape of the output should be equal to logical row count");const p=(0,i.getGlsl)(e.session.backend.glContext.version),d=`\n      float process(int[${c}] indices) {\n        int logical_row_start_offset = indices[0] * ${r};\n\n        float max = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s},\n        ${l} )));\n        for(int i=1; i<${r}; ++i)\n        {\n          float current = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${s}, ${l})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;return Object.assign(Object.assign({},u),{output:{dims:o,type:t.type,textureType:a.TextureType.unpacked},shaderSource:d})},f=(e,t,n,r,o,s)=>{const[u,c]=e.calculateTextureWidthAndHeight(t.dims,a.TextureType.unpacked),p=s.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==s.length)throw new Error("Dimensionality of the output should be 1");if(s[0]!==n)throw new Error("Shape of the output should be equal to logical row count");if(1!==o.length)throw new Error("Dimensionality of the intermediate results should be 1");if(o[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");const d=`\n      float process(int[${p}] indices) {\n        int logical_row_start_offset = indices[0] * ${r};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${r}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${(0,i.getGlsl)(e.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${u}, ${c}))) - max);\n        }\n\n        return norm_factor;\n      }`;return Object.assign(Object.assign({},l),{output:{dims:s,type:t.type,textureType:a.TextureType.unpacked},shaderSource:d})},h=(e,t,n,r,o,i)=>{const[s,u]=e.calculateTextureWidthAndHeight(t.dims,a.TextureType.unpacked),l=t.dims.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==o.length||1!==i.length)throw new Error("Dimensionality of the intermediate results should be 1");if(o[0]!==n||i[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");const p=`\n      float process(int[${l}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${s}, ${u});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${r};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;return Object.assign(Object.assign({},c),{output:{dims:t.dims,type:t.type,textureType:a.TextureType.unpacked},shaderSource:p})},g=e=>{if(!e||1!==e.length)throw new Error("Softmax requires 1 input.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type")}},564:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseSplitAttributes=t.split=void 0;const r=n(4910),o=n(7273),i=n(5639),a={name:"Split",inputNames:["A"],inputTypes:[i.TextureType.unpacked]};t.split=(e,t,n)=>{l(t);const r=o.ShapeUtil.normalizeAxis(n.axis,t[0].dims.length),i=s(e,t,r,n),c=[];for(let o=0;o<i;++o)c.push(e.run(Object.assign(Object.assign({},a),{cacheHint:`${n.cacheKey};${o}`,get:()=>u(e,t[0],n,r,o)}),t));return c},t.parseSplitAttributes=e=>{const t=e.attributes.getInt("axis",0),n=e.attributes.getInts("split",[]),o=e.outputs.length;return(0,r.createAttributeWithCacheKey)({axis:t,split:n,numOutputs:o})};const s=(e,t,n,r)=>{const[,i]=o.SplitUtil.splitShape(t[0].dims,n,r.split,r.numOutputs);return i.length},u=(e,t,n,r,s)=>{const[u,l]=o.SplitUtil.splitShape(t.dims,r,n.split,n.numOutputs),c=l[s],p=u[s],d=`\n      float process(int indices[${p.length}]) {\n        indices[${r}] += ${c};\n        return _A(indices);\n      }\n    `;return Object.assign(Object.assign({},a),{cacheHint:`${n.cacheKey}:${s}`,output:{dims:p,type:t.type,textureType:i.TextureType.unpacked},shaderSource:d})},l=e=>{if(!e||1!==e.length)throw new Error("Split requires one input.");if("int8"!==e[0].type&&"uint8"!==e[0].type&&"int16"!==e[0].type&&"uint16"!==e[0].type&&"int32"!==e[0].type&&"uint32"!==e[0].type&&"float32"!==e[0].type&&"float64"!==e[0].type&&"bool"!==e[0].type)throw new Error("Invalid input type.")}},5416:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseSqueezeAttributes=t.squeezeV13=t.squeeze=void 0;const r=n(7273);t.squeeze=(e,t,n)=>{o(t);const i=r.ShapeUtil.squeezeShape(t[0].dims,n);return[e.reshapeUnpacked(t[0],i)]},t.squeezeV13=(e,n)=>(i(n),(0,t.squeeze)(e,[n[0]],Array.from(n[1].integerData))),t.parseSqueezeAttributes=e=>e.attributes.getInts("axes");const o=e=>{if(!e||1!==e.length)throw new Error("Squeeze requires 1 input.");if("string"===e[0].type)throw new Error("invalid input tensor types.")},i=e=>{if(!e||2!==e.length)throw new Error("Squeeze requires 2 inputs.");if("int32"!==e[1].type)throw new Error("Invalid input type.")}},1240:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.sum=void 0;const r=n(6757),o=n(5639);t.sum=(e,t)=>{a(t);const n={name:"Sum",inputNames:t.map(((e,t)=>`X${t}`)),inputTypes:new Array(t.length).fill(o.TextureType.unpacked)};return[e.run(Object.assign(Object.assign({},n),{get:()=>i(e,t,n)}),t)]};const i=(e,t,n)=>{const i=(0,r.getGlsl)(e.session.backend.glContext.version),a=t[0].dims.slice(),s=`\n      void main() {\n        vec4 result = ${t.map(((e,t)=>`${i.texture2D}(X${t},TexCoords)`)).join(" + ")};\n        ${i.output} = result;\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:a,type:t[0].type,textureType:o.TextureType.unpacked},hasMain:!0,shaderSource:s})},a=e=>{if(!e||0===e.length)throw new Error("Sum requires inputs.");const t=e[0].dims.length;for(let n=1;n<e.length;n++){if(t!==e[n].dims.length)throw new Error("Input shapes are mismatched.");for(let r=0;r<t;r++)if(e[0].dims[r]!==e[n].dims[r])throw new Error("Input shapes are not matched.")}if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.");for(let t=1;t<e.length;t++)if(e[0].type!==e[t].type)throw new Error("Input types are not matched.")}},5944:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.tile=void 0;const r=n(6145),o=n(5639);t.tile=(e,t)=>{a(t);const n={name:"Tile",inputNames:["A"],inputTypes:[o.TextureType.unpacked]};return[e.run(Object.assign(Object.assign({},n),{get:()=>i(e,t,n)}),t)]};const i=(e,t,n)=>{const r=t[0].dims.slice(),i=new Array(r.length),a=[];for(let e=0;e<r.length;e++)i[e]=r[e]*t[1].numberData[e],a.push(`inputIdx[${e}] = int(mod(float(outputIdx[${e}]), ${r[e]}.));`);const s=i.length,u=`\n      float process(int outputIdx[${s}]) {\n        int inputIdx[${s}];\n        ${a.join("\n")}\n        return _A(inputIdx);\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:i,type:t[0].type,textureType:o.TextureType.unpacked},shaderSource:u})},a=e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 input.");if(1!==e[1].dims.length)throw new Error("The second input shape must 1 dimension.");if(e[1].dims[0]!==e[0].dims.length)throw new Error("Invalid input shape.");if(-1===r.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invalid input type.");if("int32"!==e[1].type&&"int16"!==e[1].type)throw new Error("Invalid repeat type.")}},5707:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseTransposeAttributes=t.transpose=void 0;const r=n(4910),o=n(7273),i=n(5639),a={name:"Transpose",inputNames:["A"],inputTypes:[i.TextureType.unpacked]};t.transpose=(e,t,n)=>(p(t),[e.run(Object.assign(Object.assign({},a),{cacheHint:n.cacheKey,get:()=>s(e,t[0],n.perm)}),t)]),t.parseTransposeAttributes=e=>(0,r.createAttributeWithCacheKey)({perm:e.attributes.getInts("perm",[])});const s=(e,t,n)=>{const r=t.dims;n=u(r,n);const o=l(r,n),s=r.length,p=`\n      ${c("perm",n,s)}\n      float process(int indices[${s}]) {\n        int a[${s}];\n        perm(a, indices);\n        return _A(a);\n      }`;return Object.assign(Object.assign({},a),{output:{dims:o,type:t.type,textureType:i.TextureType.unpacked},shaderSource:p})},u=(e,t)=>(t&&t.length!==e.length&&(t=[...e.keys()].reverse()),t),l=(e,t)=>(t=u(e,t),o.ShapeUtil.sortBasedOnPerm(e,t)),c=(e,t,n)=>{const r=[];r.push(`void ${e}(out int a[${n}], int src[${n}]) {`);for(let e=0;e<n;++e)r.push(`\ta[${t[e]}]=src[${e}];`);return r.push("\t}"),r.join("\n")},p=e=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("input should be float tensor")}},2488:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.encodeAsUint8=void 0;const r=n(6757),o=n(5639);t.encodeAsUint8=(e,t)=>{const n=t.shape,i=(0,r.getGlsl)(e.session.backend.glContext.version),a=`\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${i.texture2D}(X,TexCoords).r;\n      ${i.output} = encodeAsUint8(value);\n    }`,s={name:"Uint8Encode",inputTypes:[o.TextureType.unpacked],inputNames:["X"],output:{dims:n,type:t.tensor.type,textureType:o.TextureType.downloadUint8AsFloat},shaderSource:a,hasMain:!0};return e.executeProgram(s,[t.tensor])}},9087:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.tanh=t.tan=t.sqrt=t.sin=t.sigmoid=t.relu=t.not=t.neg=t.log=t.parseLeakyReluAttributes=t.leakyRelu=t.identity=t.floor=t.exp=t.parseEluAttributes=t.elu=t.cos=t.ceil=t.clipV11=t.parseClipAttributes=t.clip=t.atan=t.asin=t.acos=t.abs=t.glslTanh=t.glslTan=t.glslSqrt=t.glslSigmoid=t.glslRelu=t.glslSin=t.glslNot=t.glslNeg=t.glslLog=t.glslLeakyRelu=t.glslIdentity=t.glslClip=t.glslFloor=t.glslExp=t.glslElu=t.glslCos=t.glslCeil=t.glslAtan=t.glslAsin=t.glslAcos=t.glslAbs=void 0;const r=n(4910),o=n(7273),i=n(1997),a=n(6757),s=n(5639);function u(){return $("abs")}function l(){return $("acos")}function c(){return $("asin")}function p(){return $("atan")}function d(){return $("ceil")}function f(){return $("cos")}function h(e){const t="elu";return{body:`\n  const float alpha = float(${e});\n\n  float ${t}_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 ${t}_(vec4 v) {\n    return vec4(${t}_(v.x), ${t}_(v.y), ${t}_(v.z), ${t}_(v.w));\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function g(){return $("exp")}function m(){return $("floor")}function b(e,t){const n="clip";return{body:`\n  const float min = float(${e});\n  const float max = float(${t});\n\n  float ${n}_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 ${n}_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `,name:n,type:i.FunctionType.ValueBased}}function y(){const e="indentity";return{body:`\n  float ${e}_(float a) {\n    return a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return v;\n  }\n  `,name:e,type:i.FunctionType.ValueBased}}function w(e){const t="leakyRelu";return{body:`\n  const float alpha = float(${e});\n\n  float ${t}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${t}_(vec4 v) {\n    return vec4(${t}_(v.x), ${t}_(v.y), ${t}_(v.z), ${t}_(v.w));\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function _(){return $("log")}function v(){const e="neg";return{body:`\n  float ${e}_(float a) {\n    return -a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return -v;\n  }\n  `,name:e,type:i.FunctionType.ValueBased}}function x(){const e="not";return{body:`\n  float ${e}_(float a) {\n    return float( ! bool(a) );\n  }\n  bool ${e}_(bool a) {\n    return !a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 ${e}_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  `,name:e,type:i.FunctionType.ValueBased}}function T(){return $("sin")}function S(){const e="relu";return{body:`\n  float ${e}_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 ${e}_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  `,name:e,type:i.FunctionType.ValueBased}}function O(){const e="sigmoid";return{body:`\n  float ${e}_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 ${e}_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  `,name:e,type:i.FunctionType.ValueBased}}function A(){return $("sqrt")}function E(){return $("tan")}function I(){const e="tanh";return{body:`\n  float ${e}_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 ${e}_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  `,name:e,type:i.FunctionType.ValueBased}}function $(e){return{body:`\n  float ${e}_(float a) {\n    return ${e}(a);\n  }\n  vec4 ${e}_(vec4 v) {\n    return ${e}(v);\n  }\n  `,name:e,type:i.FunctionType.ValueBased}}t.glslAbs=u,t.glslAcos=l,t.glslAsin=c,t.glslAtan=p,t.glslCeil=d,t.glslCos=f,t.glslElu=h,t.glslExp=g,t.glslFloor=m,t.glslClip=b,t.glslIdentity=y,t.glslLeakyRelu=w,t.glslLog=_,t.glslNeg=v,t.glslNot=x,t.glslSin=T,t.glslRelu=S,t.glslSigmoid=O,t.glslSqrt=A,t.glslTan=E,t.glslTanh=I;const P=(e,t,n,r)=>{const o=e.session.pack?s.TextureType.packed:s.TextureType.unpacked,i={name:n.name,inputTypes:[o],inputNames:["A"],cacheHint:r};return Object.assign(Object.assign({},i),{get:()=>((e,t,n,r)=>{const o=e.session.pack?s.TextureType.packed:s.TextureType.unpacked,i=(0,a.getGlsl)(e.session.backend.glContext.version);return Object.assign(Object.assign({},t),{output:{dims:n.dims,type:n.type,textureType:o},shaderSource:`\n     ${r.body}\n     void main() {\n       vec4 v = ${i.texture2D}(A, TexCoords);\n       v = ${r.name}_(v);\n       ${i.output} = v;\n     }\n     `,hasMain:!0})})(e,i,t,n)})};t.abs=(e,t)=>[e.run(P(e,t[0],u()),t)],t.acos=(e,t)=>[e.run(P(e,t[0],l()),t)],t.asin=(e,t)=>[e.run(P(e,t[0],c()),t)],t.atan=(e,t)=>[e.run(P(e,t[0],p()),t)],t.clip=(e,t,n)=>[e.run(P(e,t[0],b(n.min,n.max),n.cacheKey),t)],t.parseClipAttributes=e=>(0,r.createAttributeWithCacheKey)({min:e.attributes.getFloat("min",o.MIN_CLIP),max:e.attributes.getFloat("max",o.MAX_CLIP)}),t.clipV11=(e,n)=>{const r=D(e,n);return(0,t.clip)(e,[n[0]],r)};const D=(e,t)=>{if(t.length>=3&&(!e.session.isInitializer(t[1].dataId)||!e.session.isInitializer(t[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const n=t.length>=3?t[1].numberData[0]:o.MIN_CLIP,i=t.length>=3?t[2].numberData[0]:o.MAX_CLIP;return(0,r.createAttributeWithCacheKey)({min:n,max:i})};t.ceil=(e,t)=>[e.run(P(e,t[0],d()),t)],t.cos=(e,t)=>[e.run(P(e,t[0],f()),t)],t.elu=(e,t,n)=>[e.run(P(e,t[0],h(n.alpha),n.cacheKey),t)],t.parseEluAttributes=e=>(0,r.createAttributeWithCacheKey)({alpha:e.attributes.getFloat("alpha",1)}),t.exp=(e,t)=>[e.run(P(e,t[0],g()),t)],t.floor=(e,t)=>[e.run(P(e,t[0],m()),t)],t.identity=(e,t)=>[e.run(P(e,t[0],y()),t)],t.leakyRelu=(e,t,n)=>[e.run(P(e,t[0],w(n.alpha),n.cacheKey),t)],t.parseLeakyReluAttributes=e=>(0,r.createAttributeWithCacheKey)({alpha:e.attributes.getFloat("alpha",.01)}),t.log=(e,t)=>[e.run(P(e,t[0],_()),t)],t.neg=(e,t)=>[e.run(P(e,t[0],v()),t)],t.not=(e,t)=>[e.run(P(e,t[0],x()),t)],t.relu=(e,t)=>[e.run(P(e,t[0],S()),t)],t.sigmoid=(e,t)=>[e.run(P(e,t[0],O()),t)],t.sin=(e,t)=>[e.run(P(e,t[0],T()),t)],t.sqrt=(e,t)=>[e.run(P(e,t[0],A()),t)],t.tan=(e,t)=>[e.run(P(e,t[0],E()),t)],t.tanh=(e,t)=>[e.run(P(e,t[0],I()),t)]},540:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createUnpackProgramInfoLoader=t.createUnpackProgramInfo=void 0;const r=n(6757),o=n(5639),i=n(432),a=n(5614),s={name:"unpack",inputNames:["A"],inputTypes:[o.TextureType.packed]};t.createUnpackProgramInfo=(e,t)=>{const n=t.dims.length,u=(0,a.getChannels)("rc",n),l=u.slice(-2),c=(0,i.getCoordsDataType)(n),p=(0,a.unpackFromChannel)(),d=0===t.dims.length?"":function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(n,u),f=n<=1?"rc":`vec2(${l.join(",")})`,h=`\n    ${p}\n    void main() {\n      ${c} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${d});\n\n       ${(0,r.getGlsl)(e.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${f}), 0, 0, 0);\n     }\n   `;return Object.assign(Object.assign({},s),{hasMain:!0,output:{dims:t.dims,type:t.type,textureType:o.TextureType.unpacked},shaderSource:h})},t.createUnpackProgramInfoLoader=(e,n)=>Object.assign(Object.assign({},s),{get:()=>(0,t.createUnpackProgramInfo)(e,n)})},7862:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseUnsqueezeAttributes=t.unsqueezeV13=t.unsqueeze=void 0;const r=n(7273);t.unsqueeze=(e,t,n)=>{o(t);const i=r.ShapeUtil.unsqueezeShape(t[0].dims,n);return[e.reshapeUnpacked(t[0],i)]},t.unsqueezeV13=(e,n)=>(i(n),(0,t.unsqueeze)(e,[n[0]],Array.from(n[1].integerData))),t.parseUnsqueezeAttributes=e=>e.attributes.getInts("axes");const o=e=>{if(!e||1!==e.length)throw new Error("Unsqueeze requires 1 input.");if("string"===e[0].type)throw new Error("invalid input tensor types.")},i=e=>{if(!e||2!==e.length)throw new Error("Unsqueeze requires 2 inputs.");if("int32"!==e[1].type)throw new Error("Invalid input type.")}},3980:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.scalesValidation=t.validateInputs=t.parseUpsampleAttributes=t.parseUpsampleAttributesV9=t.parseUpsampleAttributesV7=t.upsample=void 0;const r=n(4910),o=n(6757),i=n(5639),a={name:"Upsample",inputNames:["X"],inputTypes:[i.TextureType.unpacked]};t.upsample=(e,n,r)=>((0,t.validateInputs)(n,r),[e.run(Object.assign(Object.assign({},a),{cacheHint:r.cacheKey,get:()=>s(e,n,r)}),n)]),t.parseUpsampleAttributesV7=e=>(0,t.parseUpsampleAttributes)(e,7),t.parseUpsampleAttributesV9=e=>(0,t.parseUpsampleAttributes)(e,9),t.parseUpsampleAttributes=(e,n)=>{const o=n>=10,i=e.attributes.getString("mode","nearest");if("nearest"!==i&&"linear"!==i&&(n<11||"cubic"!==i))throw new Error(`unrecognized mode: ${i}`);let a=[];n<9&&(a=e.attributes.getFloats("scales"),(0,t.scalesValidation)(a,i,o));const s=e.attributes.getFloat("extrapolation_value",0),u=n>10?e.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(-1===["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(u))throw new Error(`coordinate_transform_mode '${u}' is not supported`);const l="tf_crop_and_resize"===u,c=l,p="nearest"===i&&n>=11?e.attributes.getString("nearest_mode","round_prefer_floor"):"";if(-1===["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(p))throw new Error(`nearest_mode '${p}' is not supported`);const d=e.attributes.getFloat("cubic_coeff_a",-.75),f=0!==e.attributes.getInt("exclude_outside",0);if(f&&"cubic"!==i)throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const h=n<11||"nearest"===i&&"asymmetric"===u&&"floor"===p;let g=0,m=0,b=0;return n>10?e.inputs.length>2?(g=1,m=2,b=3):(m=1,b=2):9===n&&(m=1),(0,r.createAttributeWithCacheKey)({opset:n,isResize:o,mode:i,scales:a,extrapolationValue:s,coordinateTransformMode:u,useExtrapolation:c,needRoiInput:l,nearestMode:p,cubicCoefficientA:d,excludeOutside:f,useNearest2xOptimization:h,roiInputIdx:g,scalesInputIdx:m,sizesInputIdx:b})};const s=(e,t,n)=>{const r=(0,o.getGlsl)(e.session.backend.glContext.version),[s,u]=e.calculateTextureWidthAndHeight(t[0].dims,i.TextureType.unpacked),l=t[0].dims.map(((e,t)=>Math.floor(e*n.scales[t]))),[c,p]=e.calculateTextureWidthAndHeight(l,i.TextureType.unpacked),d=l.length,f=new Array(d),h=new Array(d);let g=`\n      int output_pitches[${d}];\n      int input_pitches[${d}];\n      `;for(let e=d-1;e>=0;e--)f[e]=e===d-1?1:f[e+1]*l[e+1],h[e]=e===d-1?1:h[e+1]*t[0].dims[e+1],g+=`\n        output_pitches[${e}] = ${f[e]};\n        input_pitches[${e}] = ${h[e]};\n        `;const m=`\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${s}, ${u});\n        float value = getColorAsFloat(${r.texture2D}(X, coords));\n        return value;\n      }\n      `,b="nearest"===n.mode?`\n    ${m}\n    float process(int indices[${d}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${c}, ${p});\n\n      ${g}\n\n      int d, m;\n      for (int dim = 0; dim < ${d}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }`:4===d?`\n    ${m}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${c}, ${p});\n\n      ${g}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${t[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }`:`\n    ${m}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${c}, ${p});\n\n      ${g}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${t[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;return Object.assign(Object.assign({},a),{output:{dims:l,type:t[0].type,textureType:i.TextureType.unpacked},shaderSource:b,variables:[{name:"scales",type:"int",arrayLength:n.scales.length,data:n.scales.map((e=>Math.ceil(e)))}]})};t.validateInputs=(e,t)=>{if(!e||t.opset<9&&1!==e.length||t.opset>=9&&t.opset<11&&2!==e.length||t.opset>=11&&e.length<2)throw new Error("invalid inputs.");if(t.scales.length>0&&e[0].dims.length!==t.scales.length)throw new Error("Invalid input shape.");if("string"===e[0].type)throw new Error("Invalid input tensor types.")},t.scalesValidation=(e,t,n)=>{if(n){for(const t of e)if(t<=0)throw new Error("Scale value should be greater than 0.")}else for(const t of e)if(t<1)throw new Error("Scale value should be greater than or equal to 1.");if(!("linear"!==t&&"cubic"!==t||2===e.length||4===e.length&&1===e[0]&&1===e[1]))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n?"Resize":"Upsample"} opeartor.`)}},2757:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ProgramManager=void 0;const r=n(8453),o=n(1315),i=n(8897),a=n(6757);t.ProgramManager=class{constructor(e,t,n){this.profiler=e,this.glContext=t,this.textureLayoutStrategy=n,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n){var r;this.profiler.event("op",`ProgramManager.run ${null!==(r=e.programInfo.name)&&void 0!==r?r:"unknown kernel"}`,(()=>{var r;const i=this.glContext.gl,a=e.program;i.useProgram(a);try{this.bindOutput(n),this.attributesBound||this.bindAttributes(e.attribLocations),this.bindUniforms(e.uniformLocations,null!==(r=e.programInfo.variables)&&void 0!==r?r:[],t)}catch(t){throw o.Logger.error("ProgramManager",e.programInfo.shaderSource),t}this.profiler.event("backend","GlContext.draw()",(()=>{this.glContext.draw()}))}),this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach((e=>this.glContext.deleteProgram(e.program)))}build(e,t,n){return this.profiler.event("backend","ProgramManager.build",(()=>{const r=new i.GlslPreprocessor(this.glContext,e,t,n),o=r.preprocess(),a=this.compile(o);return{programInfo:e,program:a,uniformLocations:this.getUniformLocations(a,r.context.programInfo.inputNames,r.context.programInfo.variables),attribLocations:this.getAttribLocations(a)}}))}compile(e){if(!this.vertexShader){o.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const e=(0,a.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(e,this.glContext.gl.VERTEX_SHADER)}r.env.debug&&o.Logger.verbose("ProrgramManager",`FragShader:\n${e}\n`);const t=this.glContext.compileShader(e,this.glContext.gl.FRAGMENT_SHADER),n=this.glContext.createProgram(this.vertexShader,t);return this.glContext.deleteShader(t),n}bindOutput(e){const t=e.width,n=e.height;o.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${t}/${n}, shape=${e.shape}, type=${e.tensor.type}`),this.glContext.attachFramebuffer(e.texture,t,n)}bindAttributes(e){const t=e.position,n=e.textureCoord;this.glContext.setVertexAttributes(t,n),this.attributesBound=!0}bindUniforms(e,t,n){var r;const o=this.glContext.gl;let i=0;for(const{name:a,type:s,location:u,arrayLength:l}of e){const e=null===(r=t.find((e=>e.name===a)))||void 0===r?void 0:r.data;if("sampler2D"!==s&&!e)throw new Error(`variable '${a}' does not have data defined in program info`);switch(s){case"sampler2D":this.bindTexture(n[i],u,i),i++;break;case"float":l?o.uniform1fv(u,e):o.uniform1f(u,e);break;case"int":l?o.uniform1iv(u,e):o.uniform1i(u,e);break;default:throw new Error(`Uniform not implemented: ${s}`)}}}bindTexture(e,t,n){this.glContext.bindTextureToUniform(e.texture,n,t)}getAttribLocations(e){return{position:this.getAttribLocation(e,"position"),textureCoord:this.getAttribLocation(e,"textureCoord")}}getUniformLocations(e,t,n){const r=[];if(t)for(const n of t)r.push({name:n,type:"sampler2D",location:this.getUniformLocation(e,n)});if(n)for(const t of n)r.push(Object.assign(Object.assign({},t),{location:this.getUniformLocation(e,t.name)}));return r}getUniformLocation(e,t){const n=this.glContext.gl.getUniformLocation(e,t);if(null===n)throw new Error(`Uniform ${t} not found.`);return n}getAttribLocation(e,t){return this.glContext.gl.getAttribLocation(e,t)}}},2171:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLSessionHandler=void 0;const r=n(1315),o=n(5881),i=n(7860),a=n(4110),s=n(2757),u=n(7618),l=n(5243);t.WebGLSessionHandler=class{constructor(e,t){this.backend=e,this.context=t,this.layoutStrategy=new u.PreferLogicalStrategy(e.glContext.maxTextureSize),this.programManager=new s.ProgramManager(this.context.profiler,e.glContext,this.layoutStrategy),this.textureManager=new l.TextureManager(e.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:"full"===e.textureCacheMode}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=e.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new i.WebGLInferenceHandler(this)}onGraphInitialized(e){const t=e.getValues().filter((e=>-1===e.from&&e.tensor)).map((e=>e.tensor.dataId));this.initializers=new Set(t)}isInitializer(e){return!!this.initializers&&this.initializers.has(e)}addInitializer(e){this.initializers.add(e)}getTextureData(e,t){return t?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,t,n=!1){r.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),n?this.packedTextureDataCache.set(e,t):this.unpackedTextureDataCache.set(e,t)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((e=>this.textureManager.releaseTexture(e,!0))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((e=>this.textureManager.releaseTexture(e,!0))),this.unpackedTextureDataCache=new Map}resolve(e,t,n){const r=(0,o.resolveOperator)(e,t,a.WEBGL_OP_RESOLVE_RULES);return{impl:r.opImpl,context:r.opInit?r.opInit(e,n):e}}}},9622:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Uint8DataEncoder=t.RGBAFloatDataEncoder=t.RedFloat32DataEncoder=void 0;const r=n(1315);t.RedFloat32DataEncoder=class{constructor(e,t=1){if(1===t)this.internalFormat=e.R32F,this.format=e.RED,this.textureType=e.FLOAT,this.channelSize=t;else{if(4!==t)throw new Error(`Invalid number of channels: ${t}`);this.internalFormat=e.RGBA32F,this.format=e.RGBA,this.textureType=e.FLOAT,this.channelSize=t}}encode(e,t){let n,o;return e.constructor!==Float32Array&&(r.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),o=new Float32Array(e)),t*this.channelSize>e.length?(r.Logger.warning("Encoder","Source data too small. Allocating larger array"),o=e,n=this.allocate(t*this.channelSize),o.forEach(((e,t)=>n[t]=e))):(o=e,n=o),n}allocate(e){return new Float32Array(4*e)}decode(e,t){return 1===this.channelSize?e.filter(((e,t)=>t%4==0)).subarray(0,t):e.subarray(0,t)}},t.RGBAFloatDataEncoder=class{constructor(e,t=1,n){if(1!==t&&4!==t)throw new Error(`Invalid number of channels: ${t}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.channelSize=t,this.textureType=n||e.FLOAT}encode(e,t){let n=e;return 1===this.channelSize&&(r.Logger.verbose("Encoder","Exploding into a larger array"),n=this.allocate(t),e.forEach(((e,t)=>n[4*t]=e))),n}allocate(e){return new Float32Array(4*e)}decode(e,t){return 1===this.channelSize?e.filter(((e,t)=>t%4==0)).subarray(0,t):e.subarray(0,t)}},t.Uint8DataEncoder=class{constructor(e,t=1){if(this.channelSize=4,1===t)this.internalFormat=e.ALPHA,this.format=e.ALPHA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=t;else{if(4!==t)throw new Error(`Invalid number of channels: ${t}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=t}}encode(e,t){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}allocate(e){return new Uint8Array(e*this.channelSize)}decode(e,t){if(e instanceof Uint8Array)return e.subarray(0,t);throw new Error(`Invalid array type: ${e.constructor}`)}}},7618:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getBatchDim=t.sizeToSquarishShape=t.getRowsCols=t.sizeFromShape=t.isInt=t.parseAxisParam=t.squeezeShape=t.PreferLogicalStrategy=t.AlwaysKeepOriginalSizeStrategy=void 0;const r=n(1315),o=n(7273);function i(e,t){const n=[],r=[],o=null!=t&&Array.isArray(t)&&0===t.length,i=null==t||o?null:a(t,e).sort();let s=0;for(let t=0;t<e.length;++t){if(null!=i){if(i[s]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==i[s]||i[s]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),i[s]<=t&&s++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function a(e,t){const n=t.length;return e=null==e?t.map(((e,t)=>t)):[].concat(e),(0,o.assert)(e.every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),(0,o.assert)(e.every(s),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function s(e){return e%1==0}function u(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function l(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}t.AlwaysKeepOriginalSizeStrategy=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,t){if(0===e.length)return[1,1];const n=this.maxTextureSize;if(t&&void 0!==t.breakAxis){const o=t.breakAxis>=e.length?1:e.slice(t.breakAxis).reduce(((e,t)=>e*t)),i=t.breakAxis<=0?1:e.slice(0,t.breakAxis).reduce(((e,t)=>e*t));if(!(o>n||i>n))return[o,i];r.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${t.breakAxis}`)}const o=e.reduce(((e,t)=>e*t));let i=Math.floor(Math.sqrt(o));for(;i<n&&i<o&&o%i!=0;i++);if(i>=n||o%i!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${e}`);return[i,o/i]}},t.PreferLogicalStrategy=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,t){const n=this.computeTexture(e,t);return t&&t.isPacked&&(n[0]/=2,n[1]/=2),t&&t.reverseWH?[n[1],n[0]]:n}computeTexture(e,t){const n=t&&t.isPacked;if(0===e.length)return n?[2,2]:[1,1];let o=this.maxTextureSize;if(t&&void 0!==t.breakAxis){const n=t.breakAxis>=e.length?1:e.slice(t.breakAxis).reduce(((e,t)=>e*t)),i=t.breakAxis<=0?1:e.slice(0,t.breakAxis).reduce(((e,t)=>e*t));if(!(n>o||i>o))return[n,i];r.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${t.breakAxis}`)}let a=e.slice(0);if(n&&(o*=2,a=a.map(((e,t)=>t>=a.length-2?a[t]%2==0?a[t]:a[t]+1:a[t])),1===a.length&&(a=[2,a[0]])),2!==a.length){const e=i(a);a=e.newShape}const s=u(a);return a.length<=1&&s<=o?[1,s]:2===a.length&&a[0]<=o&&a[1]<=o?a:3===a.length&&a[0]*a[1]<=o&&a[2]<=o?[a[0]*a[1],a[2]]:3===a.length&&a[0]<=o&&a[1]*a[2]<=o?[a[0],a[1]*a[2]]:4===a.length&&a[0]*a[1]*a[2]<=o&&a[3]<=o?[a[0]*a[1]*a[2],a[3]]:4===a.length&&a[0]<=o&&a[1]*a[2]*a[3]<=o?[a[0],a[1]*a[2]*a[3]]:n?l(s/4).map((e=>2*e)):l(s)}},t.squeezeShape=i,t.parseAxisParam=a,t.isInt=s,t.sizeFromShape=u,t.getRowsCols=function(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]},t.sizeToSquarishShape=l,t.getBatchDim=function(e,t=2){return u(e.slice(0,e.length-t))}},3314:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createTextureLayoutFromShape=t.calculateTextureWidthAndHeight=t.createTextureLayoutFromTextureType=void 0;const r=n(7273),o=n(5639);t.createTextureLayoutFromTextureType=(e,n,r)=>{const i=r===o.TextureType.unpacked||r===o.TextureType.unpackedReversed?1:4,a=r===o.TextureType.packed,s=r===o.TextureType.unpackedReversed||r===o.TextureType.packed,u=r===o.TextureType.packedLastDimension?n.length-1:void 0,l=r===o.TextureType.packedLastDimension?n.map(((e,t)=>t===n.length-1?4*e:e)):void 0;return(0,t.createTextureLayoutFromShape)(e,n,i,l,{isPacked:a,reverseWH:s,breakAxis:u})},t.calculateTextureWidthAndHeight=(e,n,r)=>{const o=(0,t.createTextureLayoutFromTextureType)(e,n,r);return[o.width,o.height]},t.createTextureLayoutFromShape=(e,t,n=1,o,i)=>{const a=!(!i||!i.isPacked),[s,u]=e.computeTextureWH(a&&o||t,i),l=t.length;let c=t.slice(0);if(0===l&&(c=[1]),1===n)o=t;else if(a){if(4!==n)throw new Error("a packed texture must be 4-channel");o=t,l>0&&(c[l-1]=Math.ceil(c[l-1]/2)),l>1&&(c[l-2]=Math.ceil(c[l-2]/2))}else if(!o)throw new Error("Unpacked shape is needed when using channels > 1");return{width:s,height:u,channels:n,isPacked:a,shape:c,strides:r.ShapeUtil.computeStrides(c),unpackedShape:o,reversedWH:i&&i.reverseWH}}},5243:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.TextureManager=void 0;const r=n(1315);t.TextureManager=class{constructor(e,t,n,r){this.glContext=e,this.layoutStrategy=t,this.profiler=n,this.config=r,this.pendingRead=new Map,r.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(e,t,n,o){const i=this.toEncoderType(e),a=this.glContext.getEncoder(i,t.channels||1,o);if(t.isPacked&&1===o)throw new Error("not implemented");const s=t.width,u=t.height;let l,c;if(this.config.reuseTextures){l=`${s}x${u}_${a.format}_${a.internalFormat}_${a.textureType}`,c=this.inUseTextures.get(l),c||(c=[],this.inUseTextures.set(l,c));const t=this.idleTextures.get(l);if(t&&t.length>0){const r=t.pop();return c.push(r),1===o&&this.glContext.updateTexture(r,s,u,a,this.toTextureData(e,n)),r}}r.Logger.verbose("TextureManager",`Creating new texture of size ${t.width}x${t.height}`);const p=this.glContext.allocateTexture(s,u,a,this.toTextureData(e,n));return this.config.reuseTextures&&(c.push(p),this.textureLookup.set(p,l)),p}readTexture(e,t,n){return n||(n=1),this.profiler.event("backend","TextureManager.readTexture",(()=>{const r=e.shape.reduce(((e,t)=>e*t))*n,o=this.glContext.readTexture(e.texture,e.width,e.height,r,this.toEncoderType(t),n);return this.toTensorData(t,o)}))}async readTextureAsync(e,t,n){const r=e.tensor.dataId;if(n||(n=1),this.pendingRead.has(r)){const e=this.pendingRead.get(r);return new Promise((t=>null==e?void 0:e.push(t)))}return this.profiler.event("backend","TextureManager.readTextureAsync",(async()=>{this.pendingRead.set(r,[]);const o=e.shape.reduce(((e,t)=>e*t))*n;await this.glContext.createAndWaitForFence();const i=this.glContext.readTexture(e.texture,e.width,e.height,o,this.toEncoderType(t),n),a=this.toTensorData(t,i),s=this.pendingRead.get(r);return this.pendingRead.delete(r),null==s||s.forEach((e=>e(a))),a}))}readUint8TextureAsFloat(e){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",(()=>{const t=e.shape.reduce(((e,t)=>e*t)),n=this.glContext.readTexture(e.texture,e.width,e.height,4*t,"byte",4);return new Float32Array(n.buffer,n.byteOffset,t)}))}releaseTexture(e,t){let n;if(this.config.reuseTextures&&(n=this.textureLookup.get(e.texture),n)){t&&this.textureLookup.delete(n);const r=this.inUseTextures.get(n);if(r){const t=r.indexOf(e.texture);if(-1!==t){r.splice(t,1);let o=this.idleTextures.get(n);o||(o=[],this.idleTextures.set(n,o)),o.push(e.texture)}}}n&&!t||(r.Logger.verbose("TextureManager",`Deleting texture of size ${e.width}x${e.height}`),this.glContext.deleteTexture(e.texture))}toTensorData(e,t){switch(e){case"int16":return t instanceof Int16Array?t:Int16Array.from(t);case"int32":return t instanceof Int32Array?t:Int32Array.from(t);case"int8":return t instanceof Int8Array?t:Int8Array.from(t);case"uint16":return t instanceof Uint16Array?t:Uint16Array.from(t);case"uint32":return t instanceof Uint32Array?t:Uint32Array.from(t);case"uint8":case"bool":return t instanceof Uint8Array?t:Uint8Array.from(t);case"float32":return t instanceof Float32Array?t:Float32Array.from(t);case"float64":return t instanceof Float64Array?t:Float64Array.from(t);default:throw new Error(`TensorData type ${e} is not supported`)}}toTextureData(e,t){if(t)return t instanceof Float32Array?t:new Float32Array(t)}toEncoderType(e){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},5639:(e,t)=>{"use strict";var n;Object.defineProperty(t,"__esModule",{value:!0}),t.TextureType=void 0,(n=t.TextureType||(t.TextureType={}))[n.unpacked=0]="unpacked",n[n.unpackedReversed=1]="unpackedReversed",n[n.packed=2]="packed",n[n.downloadUint8AsFloat=3]="downloadUint8AsFloat",n[n.packedLastDimension=4]="packedLastDimension"},432:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getGlChannels=t.getCoordsDataType=t.getSqueezedParams=t.squeezeInputShape=t.generateShaderFuncNameFromInputSamplerNameAtOutCoords=t.generateShaderFuncNameFromInputSamplerName=t.repeatedTry=t.getPackedShape=void 0;const r=n(7273);t.getPackedShape=function(e){const t=e.length;return e.slice(0,t-1).concat(e[t-1]/4)},t.repeatedTry=async function(e,t=(e=>0),n){return new Promise(((r,o)=>{let i=0;const a=()=>{if(e())return void r();i++;const s=t(i);null!=n&&i>=n?o():setTimeout(a,s)};a()}))},t.generateShaderFuncNameFromInputSamplerName=function(e){return(0,r.assert)(void 0!==e&&0!==e.length,(()=>"empty string found for sampler name")),"get"+e.charAt(0).toUpperCase()+e.slice(1)},t.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(e){return(0,r.assert)(void 0!==e&&0!==e.length,(()=>"empty string found for sampler name")),"get"+e.charAt(0).toUpperCase()+e.slice(1)+"AtOutCoords"},t.squeezeInputShape=function(e,t){let n=JSON.parse(JSON.stringify(e));return n=t,n},t.getSqueezedParams=function(e,t){return t.map((t=>e[t])).join(", ")},t.getCoordsDataType=function(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)},t.getGlChannels=function(e=6){return["x","y","z","w","u","v"].slice(0,e)}},3389:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createNewWebGLContext=t.createWebGLContext=void 0;const r=n(1315),o=n(3524),i={};function a(e){const t=function(){if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas)throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const e=document.createElement("canvas");return e.width=1,e.height=1,e}();let n;const i={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!e||"webgl2"===e)&&(n=t.getContext("webgl2",i),n))try{return new o.WebGLContext(n,2)}catch(e){r.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${e}`)}if((!e||"webgl"===e)&&(n=t.getContext("webgl",i)||t.getContext("experimental-webgl",i),n))try{return new o.WebGLContext(n,1)}catch(e){r.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${e}`)}throw new Error("WebGL is not supported")}t.createWebGLContext=function e(t){let n;t&&"webgl2"!==t||!("webgl2"in i)?t&&"webgl"!==t||!("webgl"in i)||(n=i.webgl):n=i.webgl2,n=n||a(t),t=t||1===n.version?"webgl":"webgl2";const r=n.gl;return i[t]=n,r.isContextLost()?(delete i[t],e(t)):(r.disable(r.DEPTH_TEST),r.disable(r.STENCIL_TEST),r.disable(r.BLEND),r.disable(r.DITHER),r.disable(r.POLYGON_OFFSET_FILL),r.disable(r.SAMPLE_COVERAGE),r.enable(r.SCISSOR_TEST),r.enable(r.CULL_FACE),r.cullFace(r.BACK),n)},t.createNewWebGLContext=a},3524:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var o=Object.getOwnPropertyDescriptor(t,n);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,o)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return o(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLContext=t.linearSearchLastTrue=void 0;const a=n(8453),s=i(n(9622)),u=n(432);function l(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}t.linearSearchLastTrue=l,t.WebGLContext=class{constructor(e,t){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=e,this.version=t,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(e,t,n,r){const o=this.gl,i=o.createTexture();o.bindTexture(o.TEXTURE_2D,i),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MIN_FILTER,o.NEAREST),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MAG_FILTER,o.NEAREST),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_S,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_T,o.CLAMP_TO_EDGE);const a=r?n.encode(r,e*t):null;return o.texImage2D(o.TEXTURE_2D,0,n.internalFormat,e,t,0,n.format,n.textureType,a),this.checkError(),i}updateTexture(e,t,n,r,o){const i=this.gl;i.bindTexture(i.TEXTURE_2D,e);const a=r.encode(o,t*n);i.texSubImage2D(i.TEXTURE_2D,0,0,0,t,n,r.format,r.textureType,a),this.checkError()}attachFramebuffer(e,t,n){const r=this.gl;r.bindTexture(r.TEXTURE_2D,e),r.bindFramebuffer(r.FRAMEBUFFER,this.framebuffer),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0),this.checkError(),r.viewport(0,0,t,n),r.scissor(0,0,t,n)}readTexture(e,t,n,r,o,i){const a=this.gl;i||(i=1),this.frameBufferBound||this.attachFramebuffer(e,t,n);const s=this.getEncoder(o,i),u=s.allocate(t*n);return a.bindTexture(a.TEXTURE_2D,e),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e,0),a.readPixels(0,0,t,n,a.RGBA,s.textureType,u),this.checkError(),s.decode(u,r)}isFramebufferReady(){return!0}getActiveTexture(){const e=this.gl;return"TEXTURE"+(e.getParameter(this.gl.ACTIVE_TEXTURE)-e.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(e,t){const n=this.gl;n.vertexAttribPointer(e,3,n.FLOAT,!1,20,0),n.enableVertexAttribArray(e),-1!==t&&(n.vertexAttribPointer(t,2,n.FLOAT,!1,20,12),n.enableVertexAttribArray(t)),this.checkError()}createProgram(e,t){const n=this.gl,r=n.createProgram();return n.attachShader(r,e),n.attachShader(r,t),n.linkProgram(r),r}compileShader(e,t){const n=this.gl,r=n.createShader(t);if(!r)throw new Error(`createShader() returned null with type ${t}`);if(n.shaderSource(r,e),n.compileShader(r),!1===n.getShaderParameter(r,n.COMPILE_STATUS))throw new Error(`Failed to compile shader: ${n.getShaderInfoLog(r)}\nShader source:\n${e}`);return r}deleteShader(e){this.gl.deleteShader(e)}bindTextureToUniform(e,t,n){const r=this.gl;r.activeTexture(r.TEXTURE0+t),this.checkError(),r.bindTexture(r.TEXTURE_2D,e),this.checkError(),r.uniform1i(n,t),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(a.env.debug){const e=this.gl,t=e.getError();let n="";switch(t){case e.NO_ERROR:return;case e.INVALID_ENUM:n="INVALID_ENUM";break;case e.INVALID_VALUE:n="INVALID_VALUE";break;case e.INVALID_OPERATION:n="INVALID_OPERATION";break;case e.INVALID_FRAMEBUFFER_OPERATION:n="INVALID_FRAMEBUFFER_OPERATION";break;case e.OUT_OF_MEMORY:n="OUT_OF_MEMORY";break;case e.CONTEXT_LOST_WEBGL:n="CONTEXT_LOST_WEBGL";break;default:n=`Unknown WebGL Error: ${t.toString(16)}`}throw new Error(n)}}deleteTexture(e){this.gl.deleteTexture(e)}deleteProgram(e){this.gl.deleteProgram(e)}getEncoder(e,t,n=0){if(2===this.version)return new s.RedFloat32DataEncoder(this.gl,t);switch(e){case"float":return 1===n||this.isRenderFloat32Supported?new s.RGBAFloatDataEncoder(this.gl,t):new s.RGBAFloatDataEncoder(this.gl,t,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new s.Uint8DataEncoder(this.gl,t);default:throw new Error(`Invalid dataType: ${e}`)}}clearActiveTextures(){const e=this.gl;for(let t=0;t<this.maxTextureImageUnits;++t)e.activeTexture(e.TEXTURE0+t),e.bindTexture(e.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(this.framebuffer),e.bindBuffer(e.ARRAY_BUFFER,null),e.deleteBuffer(this.vertexbuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const e=this.gl,t=e.createBuffer();if(!t)throw new Error("createBuffer() returned null");const n=this.createDefaultGeometry();return e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW),this.checkError(),t}createFramebuffer(){const e=this.gl.createFramebuffer();if(!e)throw new Error("createFramebuffer returned null");return e}queryVitalParameters(){const e=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),1===this.version&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){2===this.version?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const e=this.gl,t=e.createTexture();e.bindTexture(e.TEXTURE_2D,t);const n=2===this.version?e.RGBA32F:e.RGBA;e.texImage2D(e.TEXTURE_2D,0,n,1,1,0,e.RGBA,e.FLOAT,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(t),e.deleteFramebuffer(r),o}checkRenderFloat32(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else{if(!this.textureFloatExtension)return!1;if(!this.gl.getExtension("WEBGL_color_buffer_float"))return!1}return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const e=this.gl;let t,n,r,o,i;try{t=e.createTexture(),n=e.createFramebuffer(),e.bindTexture(e.TEXTURE_2D,t);const a=2===this.version?e.RGBA32F:e.RGBA;return e.texImage2D(e.TEXTURE_2D,0,a,1,1,0,e.RGBA,e.FLOAT,null),e.bindFramebuffer(e.FRAMEBUFFER,n),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0),e.enable(e.BLEND),r=e.createShader(e.VERTEX_SHADER),!!r&&(e.shaderSource(r,"void main(){}"),e.compileShader(r),o=e.createShader(e.FRAGMENT_SHADER),!!o&&(e.shaderSource(o,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),e.compileShader(o),i=e.createProgram(),!!i&&(e.attachShader(i,r),e.attachShader(i,o),e.linkProgram(i),e.useProgram(i),e.drawArrays(e.POINTS,0,1),e.getError()===e.NO_ERROR)))}finally{e.disable(e.BLEND),i&&e.deleteProgram(i),r&&e.deleteShader(r),o&&e.deleteShader(o),n&&(e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(n)),t&&(e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(t))}}beginTimer(){if(2===this.version&&this.disjointTimerQueryWebgl2Extension){const e=this.gl,t=this.disjointTimerQueryWebgl2Extension,n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const e=this.gl,t=this.disjointTimerQueryWebgl2Extension;e.endQuery(t.TIME_ELAPSED_EXT)}}isTimerResultAvailable(e){let t=!1,n=!1;if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const r=this.gl,o=this.disjointTimerQueryWebgl2Extension;t=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE),n=r.getParameter(o.GPU_DISJOINT_EXT)}return t&&!n}getTimerResult(e){let t=0;if(2!==this.version)throw new Error("WebGL1 profiling currently not supported");{const n=this.gl;t=n.getQueryParameter(e,n.QUERY_RESULT),n.deleteQuery(e)}return t/1e6}async waitForQueryAndGetTime(e){return await(0,u.repeatedTry)((()=>this.isTimerResultAvailable(e))),this.getTimerResult(e)}async createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t;const n=e,r=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),t=null===r?()=>!0:()=>{const e=n.clientWaitSync(r,0,0);return e===n.ALREADY_SIGNALED||e===n.CONDITION_SATISFIED},{query:r,isFencePassed:t}}async pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=l(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}async addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||await(0,u.repeatedTry)((()=>(this.pollItems(),0===this.itemsToPoll.length)))}}},6496:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ExecutionPlan=void 0;const r=n(1315);class o{constructor(e,t){this.op=e,this.node=t}}t.ExecutionPlan=class{constructor(e,t,n){this.graph=e,this.profiler=n,this.initialize(t)}initialize(e){this.profiler.event("session","ExecutionPlan.initialize",(()=>{const t=this.graph.getNodes();if(t.length!==e.length)throw new Error("The size of nodes and OPs do not match.");this._ops=e.map(((e,n)=>new o(e,t[n]))),this.reset(),this._starter=[],this._ops.forEach(((e,t)=>{let n=!0;for(const t of e.node.inputs)if(!this._values[t]&&-1===this.graph.getInputIndices().indexOf(t)){n=!1;break}n&&this._starter.push(t)}))}))}reset(){this._values=this.graph.getValues().map((e=>e.tensor))}async execute(e,t){return this.profiler.event("session","ExecutionPlan.execute",(async()=>{this.reset();const n=e.createInferenceHandler(),o=this.graph.getInputIndices();if(t.length!==o.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${t.length} expected: ${o.length}`);t.forEach(((e,t)=>{const n=o[t];this._values[n]=e}));const i=this._starter.slice(0),a=this.graph.getValues(),s=this.graph.getNodes();let u=0;for(;u<i.length;){const e=i[u++],t=this._ops[e],o=t.node.inputs.map((e=>this._values[e]));if(-1!==o.indexOf(void 0))throw new Error(`unresolved input detected: op: ${t.node}`);const l=o;r.Logger.verbose("ExecPlan",`Runing op:${t.node.name} (${l.map(((e,n)=>`'${t.node.inputs[n]}': ${e.type}[${e.dims.join(",")}]`)).join(", ")})`);const c=await this.profiler.event("node",t.node.name,(async()=>t.op.impl(n,l,t.op.context)));if(c.length!==t.node.outputs.length)throw new Error("the size of output does not match model definition.");c.forEach(((e,n)=>{const r=t.node.outputs[n];if(this._values[r])throw new Error(`output [${r}] already has value: op:${t.node.name}`);this._values[r]=e}));const p=new Set;c.forEach(((e,n)=>{const r=t.node.outputs[n];for(const e of a[r].to){const t=s[e];let n=!0;for(const e of t.inputs)if(!this._values[e]){n=!1;break}n&&p.add(e)}})),i.push(...p)}const l=[];for(let e=0;e<this.graph.getOutputIndices().length;e++){const t=this.graph.getOutputIndices()[e],n=this._values[t];if(void 0===n)throw new Error(`required output [${t}] does not have value`);0===t?await n.getData():n.data,l.push(n)}return r.Logger.verbose("ExecPlan","disposing of inferenceHandler"),n.dispose(),l}))}}},4662:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Graph=void 0;const r=n(1446),o=n(6874),i=n(1287),a=n(9240),s=n(7273);var u=i.onnxruntime.experimental.fbs;t.Graph={from:(e,t)=>new p(e,t)};class l{constructor(e){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,e&&(this.type=s.ProtoUtil.tensorValueTypeFromProto(e.type.tensorType))}get from(){return this._from}get to(){return this._to}}class c{constructor(e,t){e instanceof r.onnx.NodeProto?(this.name=e.name,this.opType=e.opType,this.attributes=new o.Attribute(e.attribute)):e instanceof u.Node&&(this.name=null!=t?t:e.name(),this.opType=e.opType(),this.attributes=new o.Attribute(s.ProtoUtil.tensorAttributesFromORTFormat(e))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class p{constructor(e,t){if(!e)throw new TypeError("graph is empty");this.buildGraph(e),this.transformGraph(t),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(e){if(e instanceof r.onnx.GraphProto)this.buildGraphFromOnnxFormat(e);else{if(!(e instanceof u.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(e)}}buildGraphFromOnnxFormat(e){const t=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const n=new Map;if(!e.input)throw new Error("missing information in graph: input");const r=[];for(const n of e.input){if(t.has(n.name))throw new Error(`duplicated input name: ${n.name}`);const e=this._allData.push(new l(n))-1;t.set(n.name,e),r.push(n.name)}if(!e.initializer)throw new Error("missing information in graph: initializer");for(const n of e.initializer){let e=t.get(n.name);if(void 0===e){const r=new l;r.type={shape:{dims:s.ProtoUtil.tensorDimsFromProto(n.dims)},tensorType:s.ProtoUtil.tensorDataTypeFromProto(n.dataType)},e=this._allData.push(r)-1,t.set(n.name,e)}this._allData[e]._from=-1,this._allData[e].tensor=a.Tensor.fromProto(n)}for(let e=0;e<this._allData.length;e++)this._allData[e].tensor||(this._allInputIndices.push(e),this._allInputNames.push(r[e]));if(!e.output)throw new Error("missing information in graph: output");for(const n of e.output){if(t.has(n.name))throw new Error(`duplicated output name: ${n.name}`);const e=this._allData.push(new l(n))-1;t.set(n.name,e),this._allOutputIndices.push(e),this._allOutputNames.push(n.name)}if(!e.node)throw new Error("missing information in graph: node");for(const t of e.node){if(!t.name)for(let e=0;;e++){const r=`unnamed_${t.opType}_${e}`;if(!n.has(r)){t.name=r;break}}if(n.has(t.name))throw new Error(`duplicated node name: ${t.name}`);const e=this._nodes.push(new c(t))-1;n.set(t.name,e)}for(let n=0;n<this._nodes.length;n++){const r=this._nodes[n],o=e.node[n];if(!o.output)throw new Error(`missing output for node: ${o.name}`);for(const e of o.output){let i=t.get(e);if(void 0===i&&(i=this._allData.push(new l)-1,t.set(e,i)),r.outputs.push(i),void 0!==this._allData[i]._from)throw new Error(`multiple nodes output to one data value: ${i}`);if(this._allData[i]._from=n,"Constant"===o.opType){if(!o.attribute||1!==o.attribute.length||!o.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!o.output||1!==o.output.length)throw new Error("missing output or incorrect number of outputs for this Constant operator");r.outputs.pop(),r.executeNode=!1,this._allData[i]._from=-1,this._allData[i].tensor=a.Tensor.fromProto(o.attribute[0].t)}}}for(let n=0;n<this._nodes.length;n++){const r=this._nodes[n],o=e.node[n];if(!o.input)throw new Error(`missing input for node: ${o.name}`);for(const e of o.input){const i=t.get(e);if(void 0===i){if(""===e&&3===o.input.length&&"Resize"===o.opType)continue;throw new Error(`unrecognized input '${e}' for node: ${o.name}`)}r.inputs.push(i),this._allData[i]._to.push(n)}}return!0}buildGraphFromOrtFormat(e){var t,n,r;const o=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const i=new Map,p=[];for(let i=0;i<e.inputsLength();i++){const a=e.inputs(i);if(o.has(a))throw new Error(`duplicated input name: ${a}`);for(let i=0;i<e.nodeArgsLength();i++)if((null===(t=e.nodeArgs(i))||void 0===t?void 0:t.name())===a){const t=new l;if((null===(r=null===(n=e.nodeArgs(i))||void 0===n?void 0:n.type())||void 0===r?void 0:r.valueType())!==u.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const c=e.nodeArgs(i).type().value(new u.TensorTypeAndShape),d=s.ProtoUtil.tensorDataTypeFromProto(c.elemType()),f=c.shape(),h=[];for(let e=0;e<f.dimLength();e++)h.push(s.LongUtil.longToNumber(f.dim(e).value().dimValue()));t.type={shape:{dims:h},tensorType:d};const g=this._allData.push(t)-1;o.set(a,g),p.push(a)}}for(let t=0;t<e.initializersLength();t++){const n=e.initializers(t);let r=o.get(n.name());if(void 0===r){const e=new l,t=s.ProtoUtil.tensorDimsFromORTFormat(n),i=s.ProtoUtil.tensorDataTypeFromProto(n.dataType());e.type={shape:{dims:t},tensorType:i},r=this._allData.push(e)-1,o.set(n.name(),r)}this._allData[r]._from=-1,this._allData[r].tensor=a.Tensor.fromOrtTensor(n)}for(let e=0;e<this._allData.length;e++)this._allData[e].tensor||(this._allInputIndices.push(e),this._allInputNames.push(p[e]));for(let t=0;t<e.outputsLength();t++){const n=e.outputs(t);if(o.has(n))throw new Error(`duplicated output name: ${n}`);const r=this._allData.push(new l)-1;o.set(n,r),this._allOutputIndices.push(r),this._allOutputNames.push(n)}if(!e.nodes)throw new Error("missing information in graph: node");for(let t=0;t<e.nodesLength();t++){const n=e.nodes(t);let r=n.name();if(!r)for(let e=0;r=`unnamed_${n.opType()}_${e}`,i.has(r);e++);if(i.has(r))throw new Error(`duplicated node name: ${r}`);const o=this._nodes.push(new c(n,r))-1;i.set(r,o)}for(let t=0;t<this._nodes.length;t++){const n=this._nodes[t],r=e.nodes(t);if(null==r)throw new Error(`No node exists at index ${t}`);if(0===(null==r?void 0:r.outputsLength()))throw new Error(`missing output for node: ${r.name}`);for(let e=0;e<(null==r?void 0:r.outputsLength());e++){const i=null==r?void 0:r.outputs(e);let s=o.get(i);if(void 0===s&&(s=this._allData.push(new l)-1,o.set(i,s)),n.outputs.push(s),void 0!==this._allData[s]._from)throw new Error(`multiple nodes output to one data value: ${s}`);if(this._allData[s]._from=t,"Constant"===r.opType()){if(1!==r.attributesLength()||!r.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(1!==r.outputsLength())throw new Error("missing output or incorrect number of outputs for this Constant operator");n.outputs.pop(),n.executeNode=!1,this._allData[s]._from=-1,this._allData[s].tensor=a.Tensor.fromOrtTensor(r.attributes(0).t())}}}for(let t=0;t<this._nodes.length;t++){const n=this._nodes[t],r=e.nodes(t);if(0===r.inputsLength())throw new Error(`missing input for node: ${r.name}`);for(let e=0;e<r.inputsLength();e++){const i=r.inputs(e),a=o.get(i);if(void 0===a)throw new Error(`unrecognized input '${i}' for node: ${r.name()}`);n.inputs.push(a),this._allData[a]._to.push(t)}}}checkIsAcyclic(){const e=new Set;this._allInputIndices.forEach((t=>{this._allData[t]._to.forEach((t=>{e.add(t)}))}));const t=Array.from(e),n=new Array(this._nodes.length).fill("white");for(;t.length>0;){const e=t.pop();"gray"===n[e]?n[e]="black":(t.push(e),n[e]="gray",this._nodes[e].outputs.forEach((r=>{const o=this._allData[r];if(void 0!==o.tensor)throw new Error("node outputs should not be initialized");if(o._from!==e)throw new Error("from property of the Value object doesn't match index of Node being processed");o._to.forEach((e=>{if("gray"===n[e])throw new Error("model graph is cyclic");"white"===n[e]&&t.push(e)}))})))}}transformGraph(e){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),e&&e.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let e=0;const t=new Array(this._nodes.length,0);let n=0;for(let e=0;e<this._nodes.length;e++)t[e]=n,this._nodes[e].executeNode?(n!==e&&(this._nodes[n]=this._nodes[e]),n++):this._nodes[e].outputs.forEach((e=>{this._allData[e]._from=-2}));this._nodes.splice(n,this._nodes.length-n);for(let e=0;e<this._allData.length;e++){const n=this._allData[e];void 0!==n._from&&-1!==n._from&&-2!==n._from&&(n._from=t[n._from]);for(let e=0;e<n._to.length;e++){if(!(n._to[e]>=0))throw new Error("Trying to update a removed node");n._to[e]=t[n._to[e]]}}e=0;for(let t=0;t<this._allData.length;t++)if(-2!==this._allData[t].from||-1!==this._allOutputIndices.indexOf(t+e)){if(e>0){let n=-1;void 0!==this._allData[t].from&&-1!==this._allData[t].from?(n=this._nodes[this._allData[t].from].outputs.indexOf(t+e),-1!==n&&(this._nodes[this._allData[t].from].outputs[n]=t)):(n=this._allInputIndices.indexOf(t+e),-1!==n&&(this._allInputIndices[n]=t)),this._allData[t].to.forEach((r=>{n=this._nodes[r].inputs.indexOf(t+e),-1!==n&&(this._nodes[r].inputs[n]=t)})),0===this._allData[t].to.length&&(n=this._allOutputIndices.indexOf(t+e),-1!==n&&(this._allOutputIndices[n]=t))}}else e++,this._allData.splice(t,1),t--}deleteNode(e){const t=this._nodes[e];if(t.outputs.length>1)for(let e=1;e<t.outputs.length;e++)if(this._allData[t.outputs[e]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");t.executeNode=!1;const n=t.inputs[0],r=t.outputs[0],o=this._allData[r].to;for(let n=0;n<t.inputs.length;n++){const r=this._allData[t.inputs[n]].to.indexOf(e);if(-1===r)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[t.inputs[n]].to.splice(r,1)}this._allData[r]._to=[];const i=this._allOutputIndices.indexOf(r);if(-1!==i&&(this._allOutputIndices[i]=n),o&&o.length>0)for(const e of o){const t=this._nodes[e].inputs.indexOf(r);if(-1===t)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[e].inputs[t]=n,this._allData[n].to.push(e)}}removeAllDropoutNodes(){let e=0;for(const t of this._nodes){if("Dropout"===t.opType){if(1!==t.inputs.length)throw new Error("Dropout nodes should only contain one input. ");if(1!==t.outputs.length&&2!==t.outputs.length)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(2===t.outputs.length&&0!==this._allData[t.outputs[1]]._to.length)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(e)}e++}}removeAllIdentityNodes(){let e=0;for(const t of this._nodes)"Identity"===t.opType&&this.deleteNode(e),e++}isActivation(e){switch(e.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const e of this._nodes)if("Conv"===e.opType){const t=this._allData[e.outputs[0]]._to;if(1===t.length&&this.isActivation(this._nodes[t[0]])){const n=this._nodes[t[0]];if("Clip"===n.opType)if(1===n.inputs.length)try{e.attributes.set("activation_params","floats",[n.attributes.getFloat("min"),n.attributes.getFloat("max")])}catch(t){e.attributes.set("activation_params","floats",[s.MIN_CLIP,s.MAX_CLIP])}else{if(!(n.inputs.length>=3&&void 0!==this._allData[n.inputs[1]].tensor&&void 0!==this._allData[n.inputs[2]].tensor))continue;e.attributes.set("activation_params","floats",[this._allData[n.inputs[1]].tensor.floatData[0],this._allData[n.inputs[2]].tensor.floatData[0]])}e.attributes.set("activation","string",n.opType),this.deleteNode(t[0])}}}}},1315:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.now=t.Profiler=t.Logger=void 0;const n={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},r={none:new class{log(e,t,n){}},console:new class{log(e,t,n){console.log(`${this.color(e)} ${n?"[35m"+n+"[0m ":""}${t}`)}color(e){switch(e){case"verbose":return"[34;40mv[0m";case"info":return"[32mi[0m";case"warning":return"[30;43mw[0m";case"error":return"[31;40me[0m";case"fatal":return"[101mf[0m";default:throw new Error(`unsupported severity: ${e}`)}}}},o={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let i={"":o};function a(e,t,n,r){if(void 0===t)return o=e,{verbose:a.verbose.bind(null,o),info:a.info.bind(null,o),warning:a.warning.bind(null,o),error:a.error.bind(null,o),fatal:a.fatal.bind(null,o)};if(void 0===n)s(e,t);else if("number"==typeof n&&void 0===r)s(e,t);else if("string"==typeof n&&void 0===r)s(e,n,0,t);else{if("string"!=typeof n||"number"!=typeof r)throw new TypeError("input is valid");s(e,n,0,t)}var o}function s(e,t,o,a){const s=i[a||""]||i[""];n[e]<n[s.minimalSeverity]||(s.logDateTime&&(t=`${(new Date).toISOString()}|${t}`),s.logSourceLocation,r[s.provider].log(e,t,a))}!function(e){function t(e){i={},n("",e||{})}function n(e,n){if("*"===e)t(n);else{const t=i[e]||o;i[e]={provider:n.provider||t.provider,minimalSeverity:n.minimalSeverity||t.minimalSeverity,logDateTime:void 0===n.logDateTime?t.logDateTime:n.logDateTime,logSourceLocation:void 0===n.logSourceLocation?t.logSourceLocation:n.logSourceLocation}}}e.verbose=function(t,n){e("verbose",t,n)},e.info=function(t,n){e("info",t,n)},e.warning=function(t,n){e("warning",t,n)},e.error=function(t,n){e("error",t,n)},e.fatal=function(t,n){e("fatal",t,n)},e.reset=t,e.set=n,e.setWithEnv=function(e){const t={};e.logLevel&&(t.minimalSeverity=e.logLevel),n("",t)}}(a||(a={})),t.Logger=a;class u{constructor(e,t,n,r,o,i){this.category=e,this.name=t,this.startTime=n,this.endCallback=r,this.timer=o,this.ctx=i}async end(){return this.endCallback(this)}async checkTimer(){if(void 0===this.ctx||void 0===this.timer)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class l{constructor(e,t,n,r){this.category=e,this.name=t,this.startTime=n,this.endTime=r}}t.Profiler=class{static create(e){return void 0===e?new this:new this(e.maxNumberEvents,e.flushBatchSize,e.flushIntervalInMilliseconds)}constructor(e,t,n){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=void 0===e?1e4:e,this._flushBatchSize=void 0===t?10:t,this._flushIntervalInMilliseconds=void 0===n?5e3:n}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,t.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(e,t,n,r){const o=this._started?this.begin(e,t,r):void 0;let i=!1;const a=n();if(a&&"function"==typeof a.then)return i=!0,new Promise(((e,t)=>{a.then((async t=>{o&&await o.end(),e(t)}),(async e=>{o&&await o.end(),t(e)}))}));if(!i&&o){const e=o.end();if(e&&"function"==typeof e.then)return new Promise(((t,n)=>{e.then((()=>{t(a)}),(e=>{n(e)}))}))}return a}begin(e,n,r){if(!this._started)throw new Error("profiler is not started yet");if(void 0===r){const r=(0,t.now)();return this.flush(r),new u(e,n,r,(e=>this.endSync(e)))}{const t=r.beginTimer();return new u(e,n,0,(async e=>this.end(e)),t,r)}}async end(e){const t=await e.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new l(e.category,e.name,e.startTime,t)),this.flush(t))}endSync(e){const n=(0,t.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new l(e.category,e.name,e.startTime,n)),this.flush(n))}logOneEvent(e){t.Logger.verbose(`Profiler.${e.category}`,`${(e.endTime-e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`)}flush(e){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||e-this._flushTime>=this._flushIntervalInMilliseconds){for(const e=this._flushPointer;this._flushPointer<e+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,t.now)()}}get started(){return this._started}},t.now="undefined"!=typeof performance&&performance.now?()=>performance.now():Date.now},1745:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Model=void 0;const r=n(5686),o=n(1446),i=n(4662),a=n(1287),s=n(7273);var u=a.onnxruntime.experimental.fbs;t.Model=class{constructor(){}load(e,t,n){if(!n)try{return void this.loadFromOnnxFormat(e,t)}catch(e){if(void 0!==n)throw e}this.loadFromOrtFormat(e,t)}loadFromOnnxFormat(e,t){const n=o.onnx.ModelProto.decode(e);if(s.LongUtil.longToNumber(n.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=n.opsetImport.map((e=>({domain:e.domain,version:s.LongUtil.longToNumber(e.version)}))),this._graph=i.Graph.from(n.graph,t)}loadFromOrtFormat(e,t){const n=new r.flatbuffers.ByteBuffer(e),o=u.InferenceSession.getRootAsInferenceSession(n).model();if(s.LongUtil.longToNumber(o.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let e=0;e<o.opsetImportLength();e++){const t=o.opsetImport(e);this._opsets.push({domain:null==t?void 0:t.domain(),version:s.LongUtil.longToNumber(t.version())})}this._graph=i.Graph.from(o.graph(),t)}get graph(){return this._graph}get opsets(){return this._opsets}}},6145:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FLOAT_TYPES=t.INT_TYPES=t.NUMBER_TYPES=void 0,t.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],t.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],t.FLOAT_TYPES=["float32","float64"]},5881:(e,t)=>{"use strict";function n(e,t){if(t.endsWith("+")){const n=Number.parseInt(t.substring(0,t.length-1),10);return!isNaN(n)&&n<=e}if(2===t.split("-").length){const n=t.split("-"),r=Number.parseInt(n[0],10),o=Number.parseInt(n[1],10);return!isNaN(r)&&!isNaN(o)&&r<=e&&e<=o}return Number.parseInt(t,10)===e}Object.defineProperty(t,"__esModule",{value:!0}),t.resolveOperator=void 0,t.resolveOperator=function(e,t,r){for(const o of r){const r=o[0],i=o[1],a=o[2],s=o[3],u=o[4];if(e.opType===r)for(const e of t)if((e.domain===i||"ai.onnx"===e.domain&&""===i)&&n(e.version,a))return{opImpl:s,opInit:u}}throw new TypeError(`cannot resolve operator '${e.opType}' with opsets: ${t.map((e=>`${e.domain||"ai.onnx"} v${e.version}`)).join(", ")}`)}},1287:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.onnxruntime=void 0;const r=n(5686);var o,i;o=t.onnxruntime||(t.onnxruntime={}),function(e){let t;!function(e){e[e.UNDEFINED=0]="UNDEFINED",e[e.FLOAT=1]="FLOAT",e[e.INT=2]="INT",e[e.STRING=3]="STRING",e[e.TENSOR=4]="TENSOR",e[e.GRAPH=5]="GRAPH",e[e.FLOATS=6]="FLOATS",e[e.INTS=7]="INTS",e[e.STRINGS=8]="STRINGS",e[e.TENSORS=9]="TENSORS",e[e.GRAPHS=10]="GRAPHS",e[e.SPARSE_TENSOR=11]="SPARSE_TENSOR",e[e.SPARSE_TENSORS=12]="SPARSE_TENSORS"}(t=e.AttributeType||(e.AttributeType={}))}((i=o.experimental||(o.experimental={})).fbs||(i.fbs={})),function(e){!function(e){!function(e){let t;!function(e){e[e.UNKNOWN=0]="UNKNOWN",e[e.VALUE=1]="VALUE",e[e.PARAM=2]="PARAM"}(t=e.DimensionValueType||(e.DimensionValueType={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){let t;!function(e){e[e.UNDEFINED=0]="UNDEFINED",e[e.FLOAT=1]="FLOAT",e[e.UINT8=2]="UINT8",e[e.INT8=3]="INT8",e[e.UINT16=4]="UINT16",e[e.INT16=5]="INT16",e[e.INT32=6]="INT32",e[e.INT64=7]="INT64",e[e.STRING=8]="STRING",e[e.BOOL=9]="BOOL",e[e.FLOAT16=10]="FLOAT16",e[e.DOUBLE=11]="DOUBLE",e[e.UINT32=12]="UINT32",e[e.UINT64=13]="UINT64",e[e.COMPLEX64=14]="COMPLEX64",e[e.COMPLEX128=15]="COMPLEX128",e[e.BFLOAT16=16]="BFLOAT16"}(t=e.TensorDataType||(e.TensorDataType={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){let t;!function(e){e[e.Primitive=0]="Primitive",e[e.Fused=1]="Fused"}(t=e.NodeType||(e.NodeType={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){let t;!function(e){e[e.NONE=0]="NONE",e[e.tensor_type=1]="tensor_type",e[e.sequence_type=2]="sequence_type",e[e.map_type=3]="map_type"}(t=e.TypeInfoValue||(e.TypeInfoValue={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsShape(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsShape(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}dim(t,n){let r=this.bb.__offset(this.bb_pos,4);return r?(n||new e.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}dimLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}static startShape(e){e.startObject(1)}static addDim(e,t){e.addFieldOffset(0,t,0)}static createDimVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startDimVector(e,t){e.startVector(4,t,4)}static endShape(e){return e.endObject()}static createShape(e,t){return n.startShape(e),n.addDim(e,t),n.endShape(e)}}t.Shape=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsDimension(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsDimension(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}value(t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new e.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}denotation(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}static startDimension(e){e.startObject(2)}static addValue(e,t){e.addFieldOffset(0,t,0)}static addDenotation(e,t){e.addFieldOffset(1,t,0)}static endDimension(e){return e.endObject()}static createDimension(e,t,r){return n.startDimension(e),n.addValue(e,t),n.addDenotation(e,r),n.endDimension(e)}}t.Dimension=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsDimensionValue(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsDimensionValue(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}dimType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt8(this.bb_pos+t):e.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}dimParam(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}static startDimensionValue(e){e.startObject(3)}static addDimType(t,n){t.addFieldInt8(0,n,e.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(e,t){e.addFieldInt64(1,t,e.createLong(0,0))}static addDimParam(e,t){e.addFieldOffset(2,t,0)}static endDimensionValue(e){return e.endObject()}static createDimensionValue(e,t,r,o){return n.startDimensionValue(e),n.addDimType(e,t),n.addDimValue(e,r),n.addDimParam(e,o),n.endDimensionValue(e)}}t.DimensionValue=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTensorTypeAndShape(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTensorTypeAndShape(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}elemType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.TensorDataType.UNDEFINED}shape(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startTensorTypeAndShape(e){e.startObject(2)}static addElemType(t,n){t.addFieldInt32(0,n,e.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(e,t){e.addFieldOffset(1,t,0)}static endTensorTypeAndShape(e){return e.endObject()}static createTensorTypeAndShape(e,t,r){return n.startTensorTypeAndShape(e),n.addElemType(e,t),n.addShape(e,r),n.endTensorTypeAndShape(e)}}t.TensorTypeAndShape=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsMapType(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsMapType(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}keyType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.TensorDataType.UNDEFINED}valueType(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startMapType(e){e.startObject(2)}static addKeyType(t,n){t.addFieldInt32(0,n,e.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(e,t){e.addFieldOffset(1,t,0)}static endMapType(e){return e.endObject()}static createMapType(e,t,r){return n.startMapType(e),n.addKeyType(e,t),n.addValueType(e,r),n.endMapType(e)}}t.MapType=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSequenceType(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSequenceType(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}elemType(t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSequenceType(e){e.startObject(1)}static addElemType(e,t){e.addFieldOffset(0,t,0)}static endSequenceType(e){return e.endObject()}static createSequenceType(e,t){return n.startSequenceType(e),n.addElemType(e,t),n.endSequenceType(e)}}t.SequenceType=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){(e.fbs||(e.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(e,t,n,r){return e.prep(4,12),e.writeInt32(r),e.writeInt32(n),e.writeInt32(t),e.offset()}}}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsNodeEdge(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsNodeEdge(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}nodeIndex(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb_pos+e):0}inputEdges(t,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+r)+12*t,this.bb):null}inputEdgesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}outputEdges(t,n){let r=this.bb.__offset(this.bb_pos,8);return r?(n||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+r)+12*t,this.bb):null}outputEdgesLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}static startNodeEdge(e){e.startObject(3)}static addNodeIndex(e,t){e.addFieldInt32(0,t,0)}static addInputEdges(e,t){e.addFieldOffset(1,t,0)}static startInputEdgesVector(e,t){e.startVector(12,t,4)}static addOutputEdges(e,t){e.addFieldOffset(2,t,0)}static startOutputEdgesVector(e,t){e.startVector(12,t,4)}static endNodeEdge(e){return e.endObject()}static createNodeEdge(e,t,r,o){return n.startNodeEdge(e),n.addNodeIndex(e,t),n.addInputEdges(e,r),n.addOutputEdges(e,o),n.endNodeEdge(e)}}t.NodeEdge=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsNode(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsNode(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}domain(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}sinceVersion(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readInt32(this.bb_pos+e):0}index(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint32(this.bb_pos+e):0}opType(e){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb_pos+t,e):null}type(){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.NodeType.Primitive}executionProviderType(e){let t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__string(this.bb_pos+t,e):null}inputs(e,t){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}inputsLength(){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__vector_len(this.bb_pos+e):0}outputs(e,t){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}outputsLength(){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__vector_len(this.bb_pos+e):0}attributes(t,n){let r=this.bb.__offset(this.bb_pos,24);return r?(n||new e.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}attributesLength(){let e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__vector_len(this.bb_pos+e):0}inputArgCounts(e){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readInt32(this.bb.__vector(this.bb_pos+t)+4*e):0}inputArgCountsLength(){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__vector_len(this.bb_pos+e):0}inputArgCountsArray(){let e=this.bb.__offset(this.bb_pos,26);return e?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}implicitInputs(e,t){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}implicitInputsLength(){let e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__vector_len(this.bb_pos+e):0}static startNode(e){e.startObject(13)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addDomain(e,t){e.addFieldOffset(2,t,0)}static addSinceVersion(e,t){e.addFieldInt32(3,t,0)}static addIndex(e,t){e.addFieldInt32(4,t,0)}static addOpType(e,t){e.addFieldOffset(5,t,0)}static addType(t,n){t.addFieldInt32(6,n,e.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(e,t){e.addFieldOffset(7,t,0)}static addInputs(e,t){e.addFieldOffset(8,t,0)}static createInputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startInputsVector(e,t){e.startVector(4,t,4)}static addOutputs(e,t){e.addFieldOffset(9,t,0)}static createOutputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startOutputsVector(e,t){e.startVector(4,t,4)}static addAttributes(e,t){e.addFieldOffset(10,t,0)}static createAttributesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startAttributesVector(e,t){e.startVector(4,t,4)}static addInputArgCounts(e,t){e.addFieldOffset(11,t,0)}static createInputArgCountsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addInt32(t[n]);return e.endVector()}static startInputArgCountsVector(e,t){e.startVector(4,t,4)}static addImplicitInputs(e,t){e.addFieldOffset(12,t,0)}static createImplicitInputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startImplicitInputsVector(e,t){e.startVector(4,t,4)}static endNode(e){return e.endObject()}static createNode(e,t,r,o,i,a,s,u,l,c,p,d,f,h){return n.startNode(e),n.addName(e,t),n.addDocString(e,r),n.addDomain(e,o),n.addSinceVersion(e,i),n.addIndex(e,a),n.addOpType(e,s),n.addType(e,u),n.addExecutionProviderType(e,l),n.addInputs(e,c),n.addOutputs(e,p),n.addAttributes(e,d),n.addInputArgCounts(e,f),n.addImplicitInputs(e,h),n.endNode(e)}}t.Node=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsValueInfo(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsValueInfo(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}type(t){let n=this.bb.__offset(this.bb_pos,8);return n?(t||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startValueInfo(e){e.startObject(3)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addType(e,t){e.addFieldOffset(2,t,0)}static endValueInfo(e){return e.endObject()}static createValueInfo(e,t,r,o){return n.startValueInfo(e),n.addName(e,t),n.addDocString(e,r),n.addType(e,o),n.endValueInfo(e)}}t.ValueInfo=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTypeInfo(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTypeInfo(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}denotation(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}valueType(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint8(this.bb_pos+t):e.experimental.fbs.TypeInfoValue.NONE}value(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__union(e,this.bb_pos+t):null}static startTypeInfo(e){e.startObject(3)}static addDenotation(e,t){e.addFieldOffset(0,t,0)}static addValueType(t,n){t.addFieldInt8(1,n,e.experimental.fbs.TypeInfoValue.NONE)}static addValue(e,t){e.addFieldOffset(2,t,0)}static endTypeInfo(e){return e.endObject()}static createTypeInfo(e,t,r,o){return n.startTypeInfo(e),n.addDenotation(e,t),n.addValueType(e,r),n.addValue(e,o),n.endTypeInfo(e)}}t.TypeInfo=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){class t{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsOperatorSetId(e,n){return(n||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsOperatorSetId(e,n){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(n||new t).__init(e.readInt32(e.position())+e.position(),e)}domain(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}version(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}static startOperatorSetId(e){e.startObject(2)}static addDomain(e,t){e.addFieldOffset(0,t,0)}static addVersion(e,t){e.addFieldInt64(1,t,e.createLong(0,0))}static endOperatorSetId(e){return e.endObject()}static createOperatorSetId(e,n,r){return t.startOperatorSetId(e),t.addDomain(e,n),t.addVersion(e,r),t.endOperatorSetId(e)}}e.OperatorSetId=t}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTensor(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTensor(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}dims(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}dimsLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}dataType(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.TensorDataType.UNDEFINED}rawData(e){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readUint8(this.bb.__vector(this.bb_pos+t)+e):0}rawDataLength(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__vector_len(this.bb_pos+e):0}rawDataArray(){let e=this.bb.__offset(this.bb_pos,12);return e?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}stringData(e,t){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}stringDataLength(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__vector_len(this.bb_pos+e):0}static startTensor(e){e.startObject(6)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addDims(e,t){e.addFieldOffset(2,t,0)}static createDimsVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startDimsVector(e,t){e.startVector(8,t,8)}static addDataType(t,n){t.addFieldInt32(3,n,e.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(e,t){e.addFieldOffset(4,t,0)}static createRawDataVector(e,t){e.startVector(1,t.length,1);for(let n=t.length-1;n>=0;n--)e.addInt8(t[n]);return e.endVector()}static startRawDataVector(e,t){e.startVector(1,t,1)}static addStringData(e,t){e.addFieldOffset(5,t,0)}static createStringDataVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startStringDataVector(e,t){e.startVector(4,t,4)}static endTensor(e){return e.endObject()}static createTensor(e,t,r,o,i,a,s){return n.startTensor(e),n.addName(e,t),n.addDocString(e,r),n.addDims(e,o),n.addDataType(e,i),n.addRawData(e,a),n.addStringData(e,s),n.endTensor(e)}}t.Tensor=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSparseTensor(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSparseTensor(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}values(t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}indices(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}dims(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}dimsLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}static startSparseTensor(e){e.startObject(3)}static addValues(e,t){e.addFieldOffset(0,t,0)}static addIndices(e,t){e.addFieldOffset(1,t,0)}static addDims(e,t){e.addFieldOffset(2,t,0)}static createDimsVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startDimsVector(e,t){e.startVector(8,t,8)}static endSparseTensor(e){return e.endObject()}static createSparseTensor(e,t,r,o){return n.startSparseTensor(e),n.addValues(e,t),n.addIndices(e,r),n.addDims(e,o),n.endSparseTensor(e)}}t.SparseTensor=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsAttribute(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsAttribute(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}type(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.AttributeType.UNDEFINED}f(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readFloat32(this.bb_pos+e):0}i(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}s(e){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb_pos+t,e):null}t(t){let n=this.bb.__offset(this.bb_pos,16);return n?(t||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}g(t){let n=this.bb.__offset(this.bb_pos,18);return n?(t||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}floats(e){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.readFloat32(this.bb.__vector(this.bb_pos+t)+4*e):0}floatsLength(){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__vector_len(this.bb_pos+e):0}floatsArray(){let e=this.bb.__offset(this.bb_pos,20);return e?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}ints(e){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}intsLength(){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__vector_len(this.bb_pos+e):0}strings(e,t){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}stringsLength(){let e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__vector_len(this.bb_pos+e):0}tensors(t,n){let r=this.bb.__offset(this.bb_pos,26);return r?(n||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}tensorsLength(){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__vector_len(this.bb_pos+e):0}graphs(t,n){let r=this.bb.__offset(this.bb_pos,28);return r?(n||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}graphsLength(){let e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__vector_len(this.bb_pos+e):0}static startAttribute(e){e.startObject(13)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addType(t,n){t.addFieldInt32(2,n,e.experimental.fbs.AttributeType.UNDEFINED)}static addF(e,t){e.addFieldFloat32(3,t,0)}static addI(e,t){e.addFieldInt64(4,t,e.createLong(0,0))}static addS(e,t){e.addFieldOffset(5,t,0)}static addT(e,t){e.addFieldOffset(6,t,0)}static addG(e,t){e.addFieldOffset(7,t,0)}static addFloats(e,t){e.addFieldOffset(8,t,0)}static createFloatsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addFloat32(t[n]);return e.endVector()}static startFloatsVector(e,t){e.startVector(4,t,4)}static addInts(e,t){e.addFieldOffset(9,t,0)}static createIntsVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startIntsVector(e,t){e.startVector(8,t,8)}static addStrings(e,t){e.addFieldOffset(10,t,0)}static createStringsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startStringsVector(e,t){e.startVector(4,t,4)}static addTensors(e,t){e.addFieldOffset(11,t,0)}static createTensorsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startTensorsVector(e,t){e.startVector(4,t,4)}static addGraphs(e,t){e.addFieldOffset(12,t,0)}static createGraphsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startGraphsVector(e,t){e.startVector(4,t,4)}static endAttribute(e){return e.endObject()}static createAttribute(e,t,r,o,i,a,s,u,l,c,p,d,f,h){return n.startAttribute(e),n.addName(e,t),n.addDocString(e,r),n.addType(e,o),n.addF(e,i),n.addI(e,a),n.addS(e,s),n.addT(e,u),n.addG(e,l),n.addFloats(e,c),n.addInts(e,p),n.addStrings(e,d),n.addTensors(e,f),n.addGraphs(e,h),n.endAttribute(e)}}t.Attribute=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsGraph(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsGraph(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}initializers(t,n){let r=this.bb.__offset(this.bb_pos,4);return r?(n||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}initializersLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}nodeArgs(t,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new e.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}nodeArgsLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}nodes(t,n){let r=this.bb.__offset(this.bb_pos,8);return r?(n||new e.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}nodesLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}maxNodeIndex(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb_pos+e):0}nodeEdges(t,n){let r=this.bb.__offset(this.bb_pos,12);return r?(n||new e.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}nodeEdgesLength(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__vector_len(this.bb_pos+e):0}inputs(e,t){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}inputsLength(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__vector_len(this.bb_pos+e):0}outputs(e,t){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}outputsLength(){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.__vector_len(this.bb_pos+e):0}sparseInitializers(t,n){let r=this.bb.__offset(this.bb_pos,18);return r?(n||new e.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}sparseInitializersLength(){let e=this.bb.__offset(this.bb_pos,18);return e?this.bb.__vector_len(this.bb_pos+e):0}static startGraph(e){e.startObject(8)}static addInitializers(e,t){e.addFieldOffset(0,t,0)}static createInitializersVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startInitializersVector(e,t){e.startVector(4,t,4)}static addNodeArgs(e,t){e.addFieldOffset(1,t,0)}static createNodeArgsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startNodeArgsVector(e,t){e.startVector(4,t,4)}static addNodes(e,t){e.addFieldOffset(2,t,0)}static createNodesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startNodesVector(e,t){e.startVector(4,t,4)}static addMaxNodeIndex(e,t){e.addFieldInt32(3,t,0)}static addNodeEdges(e,t){e.addFieldOffset(4,t,0)}static createNodeEdgesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startNodeEdgesVector(e,t){e.startVector(4,t,4)}static addInputs(e,t){e.addFieldOffset(5,t,0)}static createInputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startInputsVector(e,t){e.startVector(4,t,4)}static addOutputs(e,t){e.addFieldOffset(6,t,0)}static createOutputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startOutputsVector(e,t){e.startVector(4,t,4)}static addSparseInitializers(e,t){e.addFieldOffset(7,t,0)}static createSparseInitializersVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startSparseInitializersVector(e,t){e.startVector(4,t,4)}static endGraph(e){return e.endObject()}static createGraph(e,t,r,o,i,a,s,u,l){return n.startGraph(e),n.addInitializers(e,t),n.addNodeArgs(e,r),n.addNodes(e,o),n.addMaxNodeIndex(e,i),n.addNodeEdges(e,a),n.addInputs(e,s),n.addOutputs(e,u),n.addSparseInitializers(e,l),n.endGraph(e)}}t.Graph=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsModel(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsModel(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}irVersion(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}opsetImport(t,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new e.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}opsetImportLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}producerName(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}producerVersion(e){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__string(this.bb_pos+t,e):null}domain(e){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__string(this.bb_pos+t,e):null}modelVersion(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}docString(e){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__string(this.bb_pos+t,e):null}graph(t){let n=this.bb.__offset(this.bb_pos,18);return n?(t||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}graphDocString(e){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__string(this.bb_pos+t,e):null}static startModel(e){e.startObject(9)}static addIrVersion(e,t){e.addFieldInt64(0,t,e.createLong(0,0))}static addOpsetImport(e,t){e.addFieldOffset(1,t,0)}static createOpsetImportVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startOpsetImportVector(e,t){e.startVector(4,t,4)}static addProducerName(e,t){e.addFieldOffset(2,t,0)}static addProducerVersion(e,t){e.addFieldOffset(3,t,0)}static addDomain(e,t){e.addFieldOffset(4,t,0)}static addModelVersion(e,t){e.addFieldInt64(5,t,e.createLong(0,0))}static addDocString(e,t){e.addFieldOffset(6,t,0)}static addGraph(e,t){e.addFieldOffset(7,t,0)}static addGraphDocString(e,t){e.addFieldOffset(8,t,0)}static endModel(e){return e.endObject()}static createModel(e,t,r,o,i,a,s,u,l,c){return n.startModel(e),n.addIrVersion(e,t),n.addOpsetImport(e,r),n.addProducerName(e,o),n.addProducerVersion(e,i),n.addDomain(e,a),n.addModelVersion(e,s),n.addDocString(e,u),n.addGraph(e,l),n.addGraphDocString(e,c),n.endModel(e)}}t.Model=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){class t{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsKernelCreateInfos(e,n){return(n||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsKernelCreateInfos(e,n){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(n||new t).__init(e.readInt32(e.position())+e.position(),e)}nodeIndices(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb.__vector(this.bb_pos+t)+4*e):0}nodeIndicesLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}nodeIndicesArray(){let e=this.bb.__offset(this.bb_pos,4);return e?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}kernelDefHashes(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}kernelDefHashesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}static startKernelCreateInfos(e){e.startObject(2)}static addNodeIndices(e,t){e.addFieldOffset(0,t,0)}static createNodeIndicesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addInt32(t[n]);return e.endVector()}static startNodeIndicesVector(e,t){e.startVector(4,t,4)}static addKernelDefHashes(e,t){e.addFieldOffset(1,t,0)}static createKernelDefHashesVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startKernelDefHashesVector(e,t){e.startVector(8,t,8)}static endKernelCreateInfos(e){return e.endObject()}static createKernelCreateInfos(e,n,r){return t.startKernelCreateInfos(e),t.addNodeIndices(e,n),t.addKernelDefHashes(e,r),t.endKernelCreateInfos(e)}}e.KernelCreateInfos=t}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSubGraphSessionState(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSubGraphSessionState(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}graphId(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}sessionState(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSubGraphSessionState(e){e.startObject(2)}static addGraphId(e,t){e.addFieldOffset(0,t,0)}static addSessionState(e,t){e.addFieldOffset(1,t,0)}static endSubGraphSessionState(e){let t=e.endObject();return e.requiredField(t,4),t}static createSubGraphSessionState(e,t,r){return n.startSubGraphSessionState(e),n.addGraphId(e,t),n.addSessionState(e,r),n.endSubGraphSessionState(e)}}t.SubGraphSessionState=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSessionState(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSessionState(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}kernels(t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new e.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}subGraphSessionStates(t,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new e.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}subGraphSessionStatesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}static startSessionState(e){e.startObject(2)}static addKernels(e,t){e.addFieldOffset(0,t,0)}static addSubGraphSessionStates(e,t){e.addFieldOffset(1,t,0)}static createSubGraphSessionStatesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startSubGraphSessionStatesVector(e,t){e.startVector(4,t,4)}static endSessionState(e){return e.endObject()}static createSessionState(e,t,r){return n.startSessionState(e),n.addKernels(e,t),n.addSubGraphSessionStates(e,r),n.endSessionState(e)}}t.SessionState=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsInferenceSession(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsInferenceSession(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static bufferHasIdentifier(e){return e.__has_identifier("ORTM")}ortVersion(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}model(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}sessionState(t){let n=this.bb.__offset(this.bb_pos,8);return n?(t||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startInferenceSession(e){e.startObject(3)}static addOrtVersion(e,t){e.addFieldOffset(0,t,0)}static addModel(e,t){e.addFieldOffset(1,t,0)}static addSessionState(e,t){e.addFieldOffset(2,t,0)}static endInferenceSession(e){return e.endObject()}static finishInferenceSessionBuffer(e,t){e.finish(t,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(e,t){e.finish(t,"ORTM",!0)}static createInferenceSession(e,t,r,o){return n.startInferenceSession(e),n.addOrtVersion(e,t),n.addModel(e,r),n.addSessionState(e,o),n.endInferenceSession(e)}}t.InferenceSession=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={}))},1723:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.OnnxjsSessionHandler=void 0;const r=n(8453),o=n(9240);t.OnnxjsSessionHandler=class{constructor(e){this.session=e,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(e,t,n){const i=new Map;for(const t in e)if(Object.hasOwnProperty.call(e,t)){const n=e[t];i.set(t,new o.Tensor(n.dims,n.type,void 0,void 0,n.data))}const a=await this.session.run(i),s={};return a.forEach(((e,t)=>{s[t]=new r.Tensor(e.type,e.data,e.dims)})),s}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6027:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Session=void 0;const r=n(7067),o=n(1296),i=n(1975),a=n(6496),s=n(1315),u=n(1745);t.Session=class{constructor(e={}){this._initialized=!1,this.backendHint=e.backendHint,this.profiler=s.Profiler.create(e.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(e,t,n){await this.profiler.event("session","Session.loadModel",(async()=>{const a=await(0,i.resolveBackend)(this.backendHint);if(this.sessionHandler=a.createSessionHandler(this.context),this._model=new u.Model,"string"==typeof e){const t=e.endsWith(".ort");if("undefined"==typeof fetch){const n=await(0,o.promisify)(r.readFile)(e);this.initialize(n,t)}else{const n=await fetch(e),r=await n.arrayBuffer();this.initialize(new Uint8Array(r),t)}}else if(ArrayBuffer.isView(e))this.initialize(e);else{const r=new Uint8Array(e,t||0,n||e.byteLength);this.initialize(r)}}))}initialize(e,t){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",(()=>{const n=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(e,n,t),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new a.ExecutionPlan(this._model.graph,this._ops,this.profiler)})),this._initialized=!0}async run(e){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",(async()=>{const t=this.normalizeAndValidateInputs(e),n=await this._executionPlan.execute(this.sessionHandler,t);return this.createOutput(n)}))}normalizeAndValidateInputs(e){const t=this._model.graph.getInputNames();if(Array.isArray(e)){if(e.length!==t.length)throw new Error(`incorrect input array length: expected ${t.length} but got ${e.length}`)}else{if(e.size!==t.length)throw new Error(`incorrect input map size: expected ${t.length} but got ${e.size}`);const n=new Array(e.size);let r=0;for(let o=0;o<t.length;++o){const i=e.get(t[o]);if(!i)throw new Error(`missing input tensor for: '${name}'`);n[r++]=i}e=n}if(this.context.graphInputTypes&&0!==this.context.graphInputTypes.length&&this.context.graphInputDims&&0!==this.context.graphInputDims.length)this.validateInputTensorDims(this.context.graphInputDims,e,!1);else{const t=this._model.graph.getInputIndices(),n=this._model.graph.getValues(),r=new Array(t.length);for(let o=0;o<t.length;++o){const i=n[t[o]];r[o]=i.type.shape.dims,this.context.graphInputTypes.push(i.type.tensorType),this.context.graphInputDims.push(e[o].dims)}this.validateInputTensorDims(r,e,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,e),e}validateInputTensorTypes(e,t){for(let n=0;n<t.length;n++){const r=e[n],o=t[n].type;if(r!==o)throw new Error(`input tensor[${n}] check failed: expected type '${r}' but got ${o}`)}}validateInputTensorDims(e,t,n){for(let r=0;r<t.length;r++){const o=e[r],i=t[r].dims;if(!this.compareTensorDims(o,i,n))throw new Error(`input tensor[${r}] check failed: expected shape '[${o.join(",")}]' but got [${i.join(",")}]`)}}compareTensorDims(e,t,n){if(e.length!==t.length)return!1;for(let r=0;r<e.length;++r)if(e[r]!==t[r]&&(!n||0!==e[r]))return!1;return!0}createOutput(e){const t=this._model.graph.getOutputNames();if(e.length!==t.length)throw new Error("expected number of outputs do not match number of generated outputs");const n=new Map;for(let r=0;r<t.length;++r)n.set(t[r],e[r]);return n}initializeOps(e){const t=e.getNodes();this._ops=new Array(t.length);for(let n=0;n<t.length;n++)this._ops[n]=this.sessionHandler.resolve(t[n],this._model.opsets,e)}}},9240:function(e,t,n){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.Tensor=void 0;const o=n(3442),i=r(n(3720)),a=n(1446),s=n(1287),u=n(7273);var l=s.onnxruntime.experimental.fbs;class c{get data(){if(void 0===this.cache){const e=this.dataProvider(this.dataId);if(e.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=e}return this.cache}get stringData(){if("string"!==this.type)throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if("string"!==this.type)return this.data;throw new TypeError("type cannot be non-number (string)")}get(e){return this.data[u.ShapeUtil.indicesToOffset(e,this.strides)]}set(e,t){this.data[u.ShapeUtil.indicesToOffset(e,this.strides)]=t}async getData(){return void 0===this.cache&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=u.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(e,t,n,r,i,a=o.Guid.create()){this.dims=e,this.type=t,this.dataProvider=n,this.asyncDataProvider=r,this.cache=i,this.dataId=a,this.size=u.ShapeUtil.validateDimsAndCalcSize(e);const s=this.size,l=void 0===n&&void 0===r&&void 0===i;if(void 0!==i&&i.length!==s)throw new RangeError("Input dims doesn't match data length.");if("string"===t){if(!(void 0===i||Array.isArray(i)&&i.every((e=>"string"==typeof e))))throw new TypeError("cache should be a string array");l&&(this.cache=new Array(s))}else{if(void 0!==i){const e=d(t);if(!(i instanceof e))throw new TypeError(`cache should be type ${e.name}`)}if(l){const e=new ArrayBuffer(s*function(e){switch(e){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${e}`)}}(t));this.cache=function(e,t){return new(d(t))(e)}(e,t)}}}static fromProto(e){if(!e)throw new Error("cannot construct Value from an empty tensor");const t=u.ProtoUtil.tensorDataTypeFromProto(e.dataType),n=u.ProtoUtil.tensorDimsFromProto(e.dims),r=new c(n,t);if("string"===t)e.stringData.forEach(((e,t)=>{r.data[t]=(0,u.decodeUtf8String)(e)}));else if(e.rawData&&"number"==typeof e.rawData.byteLength&&e.rawData.byteLength>0){const t=r.data,n=new DataView(e.rawData.buffer,e.rawData.byteOffset,e.rawData.byteLength),o=p(e.dataType),i=e.rawData.byteLength/o;if(e.rawData.byteLength%o!=0)throw new Error("invalid buffer length");if(t.length!==i)throw new Error("buffer length mismatch");for(let r=0;r<i;r++){const i=h(n,e.dataType,r*o);t[r]=i}}else{let t;switch(e.dataType){case a.onnx.TensorProto.DataType.FLOAT:t=e.floatData;break;case a.onnx.TensorProto.DataType.INT32:case a.onnx.TensorProto.DataType.INT16:case a.onnx.TensorProto.DataType.UINT16:case a.onnx.TensorProto.DataType.INT8:case a.onnx.TensorProto.DataType.UINT8:case a.onnx.TensorProto.DataType.BOOL:t=e.int32Data;break;case a.onnx.TensorProto.DataType.INT64:t=e.int64Data;break;case a.onnx.TensorProto.DataType.DOUBLE:t=e.doubleData;break;case a.onnx.TensorProto.DataType.UINT32:case a.onnx.TensorProto.DataType.UINT64:t=e.uint64Data;break;default:throw new Error("unspecific error")}if(null==t)throw new Error("failed to populate data from a tensorproto value");const n=r.data;if(n.length!==t.length)throw new Error("array length mismatch");for(let r=0;r<t.length;r++){const o=t[r];i.default.isLong(o)?n[r]=f(o,e.dataType):n[r]=o}}return r}static fromData(e,t,n){return new c(t,n,void 0,void 0,e)}static fromOrtTensor(e){if(!e)throw new Error("cannot construct Value from an empty tensor");const t=u.ProtoUtil.tensorDimsFromORTFormat(e),n=u.ProtoUtil.tensorDataTypeFromProto(e.dataType()),r=new c(t,n);if("string"===n)for(let t=0;t<e.stringDataLength();t++)r.data[t]=e.stringData(t);else if(e.rawDataArray()&&"number"==typeof e.rawDataLength()&&e.rawDataLength()>0){const t=r.data,n=new DataView(e.rawDataArray().buffer,e.rawDataArray().byteOffset,e.rawDataLength()),o=p(e.dataType()),i=e.rawDataLength()/o;if(e.rawDataLength()%o!=0)throw new Error("invalid buffer length");if(t.length!==i)throw new Error("buffer length mismatch");for(let r=0;r<i;r++){const i=h(n,e.dataType(),r*o);t[r]=i}}return r}}function p(e){switch(e){case a.onnx.TensorProto.DataType.UINT8:case a.onnx.TensorProto.DataType.INT8:case a.onnx.TensorProto.DataType.BOOL:return 1;case a.onnx.TensorProto.DataType.UINT16:case a.onnx.TensorProto.DataType.INT16:return 2;case a.onnx.TensorProto.DataType.FLOAT:case a.onnx.TensorProto.DataType.INT32:case a.onnx.TensorProto.DataType.UINT32:return 4;case a.onnx.TensorProto.DataType.INT64:case a.onnx.TensorProto.DataType.DOUBLE:case a.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${a.onnx.TensorProto.DataType[e]}`)}}function d(e){switch(e){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function f(e,t){if(t===a.onnx.TensorProto.DataType.INT64||t===l.TensorDataType.INT64){if(e.greaterThanOrEqual(2147483648)||e.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(t!==a.onnx.TensorProto.DataType.UINT32&&t!==l.TensorDataType.UINT32&&t!==a.onnx.TensorProto.DataType.UINT64&&t!==l.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${a.onnx.TensorProto.DataType[t]}`);if(e.greaterThanOrEqual(4294967296)||e.lessThan(0))throw new TypeError("uint64 is not supported")}return e.toNumber()}function h(e,t,n){switch(t){case a.onnx.TensorProto.DataType.BOOL:case a.onnx.TensorProto.DataType.UINT8:return e.getUint8(n);case a.onnx.TensorProto.DataType.INT8:return e.getInt8(n);case a.onnx.TensorProto.DataType.UINT16:return e.getUint16(n,!0);case a.onnx.TensorProto.DataType.INT16:return e.getInt16(n,!0);case a.onnx.TensorProto.DataType.FLOAT:return e.getFloat32(n,!0);case a.onnx.TensorProto.DataType.INT32:return e.getInt32(n,!0);case a.onnx.TensorProto.DataType.UINT32:return e.getUint32(n,!0);case a.onnx.TensorProto.DataType.INT64:return f(i.default.fromBits(e.getUint32(n,!0),e.getUint32(n+4,!0),!1),t);case a.onnx.TensorProto.DataType.DOUBLE:return e.getFloat64(n,!0);case a.onnx.TensorProto.DataType.UINT64:return f(i.default.fromBits(e.getUint32(n,!0),e.getUint32(n+4,!0),!0),t);default:throw new Error(`cannot read from DataView for type ${a.onnx.TensorProto.DataType[t]}`)}}t.Tensor=c},7273:function(e,t,n){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.decodeUtf8String=t.MAX_CLIP=t.MIN_CLIP=t.PoolConvUtil=t.ReduceUtil=t.SplitUtil=t.MathUtil=t.ShapeUtil=t.LongUtil=t.ProtoUtil=t.GemmUtil=t.arrayCopyHelper=t.BroadcastUtil=t.MatMulUtil=t.ArrayUtil=t.assert=t.checkInputsShape=void 0;const o=n(5686),i=r(n(3720)),a=n(1446),s=n(9240);t.checkInputsShape=function(e,...t){if(!e||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(!e[n].dims||e[n].dims.length!==t[n])return!1;return!0},t.assert=function(e,t){if(!e)throw new Error("string"==typeof t?t:t())},t.ArrayUtil=class{static arraysEqual(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}};class u{static preprocessInputShapes(e,t){return[1===e.length?[1,e[0]]:e,1===t.length?[t[0],1]:t]}static postprocessOutputShape(e,t,n){1===t&&e.splice(e.length-2,1),1===n&&e.pop()}static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}}t.MatMulUtil=u;class l{static calcShape(e,t,n=!1){const r=e.length,o=t.length;if(0===r)return t;if(0===o)return e;const i=Math.max(e.length,t.length),a=new Array(i);if(n){if(r<2||o<2)return;const n=u.calcMatMulShape([e[r-2],e[r-1]],[t[o-2],t[o-1]]);if(void 0===n)return;[a[i-2],a[i-1]]=n}for(let s=n?3:1;s<=i;s++){const n=r-s<0?1:e[r-s],u=o-s<0?1:t[o-s];if(n!==u&&n>1&&u>1)return;a[i-s]=Math.max(n,u)}return a}static index(e,t){const n=new Array(t.length);return l.fillIndex(e,t,n),n}static fillIndex(e,t,n){const r=e.length-t.length;for(let o=0;o<t.length;o++)n[o]=e[r+o]%t[o]}static calc(e,t,n,r,o){const i=l.calcShape(e.dims,t.dims);if(i){if(r&&!d.areEqual(i,e.dims))return;const a=d.size(i),u=r?e:new s.Tensor(i,o||e.type);if(0===i.length)u.set([],n(e.get([]),t.get([])));else{const r=new Array(i.length),o=new Array(e.dims.length),s=new Array(t.dims.length);let c,p=0,d=0,f=!1,h=!1;0===e.dims.length&&(p=e.get([]),f=!0),0===t.dims.length&&(d=t.get([]),h=!0);for(let g=0;g<a;g++){c=g;for(let e=i.length-1;e>=0;e--)r[e]=c%i[e],c=Math.floor(c/i[e]);f||(l.fillIndex(r,e.dims,o),p=e.get(o)),h||(l.fillIndex(r,t.dims,s),d=t.get(s)),u.set(r,n(p,d))}}return u}}static isValidBroadcast(e,t){const n=e.length,r=t.length;if(n>r)return!1;for(let o=1;o<=n;o++)if(1!==e[n-o]&&e[n-o]!==t[r-o])return!1;return!0}static getBroadcastDims(e,t){const n=e.length,r=[];for(let o=0;o<n;o++){const i=n-1-o,a=e[i]||1;(t[t.length-1-o]||1)>1&&1===a&&r.unshift(i)}return r}}t.BroadcastUtil=l,t.arrayCopyHelper=function(e,t,n,r,o){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+o>t.length)throw new Error("source indices to be copied are outside bounds");if(n+o>e.length)throw new Error("target array is too small to hold result");for(let i=0;i<o;i++)e[n+i]=t[r+i]},t.GemmUtil=class{static getShapeOfGemmResult(e,t,n,r,o){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let i,a,s;t?(i=e[1],a=e[0]):(i=e[0],a=e[1]);let u=-1;if(r?(s=n[0],u=1):(s=n[1],u=0),n[u]!==a)throw new Error("dimension mismatch");if(i<=0||s<=0||a<=0)throw new Error("invalid shape specified");if(o&&!l.isValidBroadcast(o,[i,s]))throw new Error("gemm: invalid bias shape for broadcast");return[i,s,a]}};class c{static tensorDataTypeFromProto(e){switch(e){case a.onnx.TensorProto.DataType.INT8:return"int8";case a.onnx.TensorProto.DataType.UINT8:return"uint8";case a.onnx.TensorProto.DataType.BOOL:return"bool";case a.onnx.TensorProto.DataType.INT16:return"int16";case a.onnx.TensorProto.DataType.UINT16:return"uint16";case a.onnx.TensorProto.DataType.INT32:return"int32";case a.onnx.TensorProto.DataType.UINT32:return"uint32";case a.onnx.TensorProto.DataType.FLOAT:return"float32";case a.onnx.TensorProto.DataType.DOUBLE:return"float64";case a.onnx.TensorProto.DataType.STRING:return"string";case a.onnx.TensorProto.DataType.INT64:return"int32";case a.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${a.onnx.TensorProto.DataType[e]}`)}}static tensorDataTypeStringToEnum(e){switch(e){case"int8":return a.onnx.TensorProto.DataType.INT8;case"uint8":return a.onnx.TensorProto.DataType.UINT8;case"bool":return a.onnx.TensorProto.DataType.BOOL;case"int16":return a.onnx.TensorProto.DataType.INT16;case"uint16":return a.onnx.TensorProto.DataType.UINT16;case"int32":return a.onnx.TensorProto.DataType.INT32;case"uint32":return a.onnx.TensorProto.DataType.UINT32;case"float32":return a.onnx.TensorProto.DataType.FLOAT;case"float64":return a.onnx.TensorProto.DataType.DOUBLE;case"string":return a.onnx.TensorProto.DataType.STRING;case"int64":return a.onnx.TensorProto.DataType.INT64;case"uint64":return a.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${e}`)}}static tensorDimsFromProto(e){return e.map((e=>i.default.isLong(e)?e.toNumber():e))}static tensorValueTypeFromProto(e){return{tensorType:c.tensorDataTypeFromProto(e.elemType),shape:{dims:c.tensorDimsFromProto(e.shape.dim.map((e=>e.dimValue)))}}}static tensorDimsFromORTFormat(e){const t=[];for(let n=0;n<e.dimsLength();n++)t.push(p.longToNumber(e.dims(n)));return t}static tensorAttributesFromORTFormat(e){const t=[];for(let n=0;n<e.attributesLength();n++)t.push(e.attributes(n));return t}}t.ProtoUtil=c;class p{static longToNumber(e,t){return i.default.isLong(e)?e.toNumber():e instanceof o.flatbuffers.Long?i.default.fromValue({low:e.low,high:e.high,unsigned:null!=t&&t}).toNumber():e}static isLong(e){return i.default.isLong(e)||e instanceof o.flatbuffers.Long}}t.LongUtil=p;class d{static size(e){return d.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return d.getSizeFromDimensionRange(e,t,e.length)}static sizeToDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${e.length} dimensions.`);return d.getSizeFromDimensionRange(e,0,t)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let o=t;o<n;o++){if(e[o]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");r*=e[o]}return r}static computeStrides(e){const t=e.length;if(0===t)return[];if(1===t)return[1];const n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static transpose(e){return e.slice().reverse()}static indicesToOffset(e,t,n){void 0===n&&(n=e.length);let r=0;for(let o=0;o<n;++o)r+=t[o]*e[o];return r}static offsetToIndices(e,t){const n=t.length;if(0===n)return[];if(1===n)return[e*t[0]];const r=new Array(t.length);for(let n=0;n<r.length-1;++n)r[n]=Math.floor(e/t[n]),e-=r[n]*t[n];return r[r.length-1]=e,r}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((e=>this.normalizeAxis(e,t)))}static incrementIndex(e,t,n){if(0===t.length||0===e.length)throw new Error("Index incrementing unsupported for scalar Tensor");if(void 0===n)n=t.length;else if(n<=0||n>t.length)throw new Error("Incorrect axis to increment on");for(let r=n-1;r>=0&&(e[r]++,!(e[r]<t[r]));--r)e[r]=0}static calculateReshapedDims(e,t){if(0===t.length){if(0===e.length||1===d.size(e))return[];throw new Error("cannot reshape to a scalar Tensor")}const n=t.length,r=new Array(n);let o=-1,i=1;for(let a=0;a<n;a++){if(t[a]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(-1===t[a]){if(-1!==o)throw new Error("at most one dimension in shape hints can be -1");o=a}else{if(0===t[a]){if(a>=e.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");r[a]=e[a]}else r[a]=t[a];i*=r[a]}}const a=d.size(e);if(-1!==o){if(a%i!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e}] Output shape: [${t}]`);r[o]=a/i}else if(i!==a)throw new Error("reshapedDims and originalDims don't have matching sizes");return r}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){const n=e.length;return e.map(((e,r)=>e+t[r]+t[r+n]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,n)=>e===t[n]))}static validateDimsAndCalcSize(e){if(e.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let t=1;for(const n of e){if(!Number.isInteger(n))throw new TypeError(`Invalid shape: ${n} is not an integer`);if(n<0||n>2147483647)throw new TypeError(`Invalid shape: length ${n} is not allowed`);t*=n}return t}static flattenShape(e,t){t<0&&(t+=e.length);const n=e.reduce(((e,t)=>e*t),1),r=e.slice(t).reduce(((e,t)=>e*t),1);return[n/r,r]}static squeezeShape(e,t){const n=new Array;t=d.normalizeAxes(t,e.length);for(let r=0;r<e.length;r++){const o=t.indexOf(r)>=0;if(o&&1!==e[r])throw new Error("squeeze an axis of size different than 1");(0===t.length&&e[r]>1||t.length>0&&!o)&&n.push(e[r])}return n}static unsqueezeShape(e,t){const n=new Array(e.length+t.length);n.fill(0);for(let e=0;e<t.length;e++){const r=d.normalizeAxis(t[e],n.length);if(r>=n.length)throw new Error("'axes' has an out of range axis");if(0!==n[r])throw new Error("'axes' has a duplicate axis");n[r]=1}let r=0;for(let t=0;t<n.length;t++)0===n[t]&&(n[t]=e[r++]);if(r!==e.length)throw new Error("the unsqueezed dimension could not be established");return n}}t.ShapeUtil=d,t.MathUtil=class{static sqr(e,t,n,r,o){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+o>t.length)throw new Error("source indices to be copied are outside bounds");if(n+o>e.length)throw new Error("target array is too small to hold result");for(let i=0;i<o;i++)e[n+i]+=Math.pow(t[r+i],2)}static axpy(e,t,n,r,o,i){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+o>t.length)throw new Error("source indices to be copied are outside bounds");if(n+o>e.length)throw new Error("target array is too small to hold result");for(let a=0;a<o;a++)e[n+a]+=i*t[r+a]}static powx(e,t,n,r,o,i){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+o>t.length)throw new Error("source indices to be copied are outside bounds");if(n+o>e.length)throw new Error("target array is too small to hold result");for(let a=0;a<o;a++)e[n+a]=Math.pow(t[r+a],i)}static mul(e,t,n,r,o){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+o>t.length)throw new Error("source indices to be copied are outside bounds");if(n+o>e.length)throw new Error("target array is too small to hold result");for(let i=0;i<o;i++)e[n+i]=t[r+i]*e[n+i]}};class f{static splitShape(e,t,n,r){if(0===n.length){if(!r)throw new Error("need to know number of outputs when the 'split' attribute is not specified");f.determineSplit(e[t],r,n)}const o=[],i=[0];for(let r=0;r<n.length;++r){0!==r&&i.push(i[r-1]+n[r-1]);const a=e.slice();a[t]=n[r],o.push(a)}return[o,i]}static determineSplit(e,t,n){if(e%t!=0)throw new Error("cannot split tensor to equal sized parts");for(let r=0;r<t;++r)n.push(e/t)}}t.SplitUtil=f;class h{static calcReduce(e,t,n,r,o){const i=e.dims.slice(0);0===t.length&&i.forEach(((e,n)=>t.push(n)));const a=h.calcReduceShape(i,t,!0),u=d.size(a),c=new s.Tensor(a,e.type),p=d.computeStrides(a),f=d.computeStrides(i),g=new Array(i.length);for(let n=0;n<u;n++){const a=d.offsetToIndices(n,p);l.fillIndex(a,i,g),c.set(a,h.calcReduceByAxis(e.numberData,t,i,0,d.indicesToOffset(g,f),r,o))}return n?c:new s.Tensor(h.calcReduceShape(i,t,n),c.type,void 0,void 0,c.data,c.dataId)}static calcReduceByAxis(e,t,n,r,o,i,a){let s=0;if(r>=t.length)return i(e[o]);const u=t[r],l=u>=n.length?1:d.size(n.slice(u+1));for(let c=0;c<n[u];c++)s=0===c?h.calcReduceByAxis(e,t,n,r+1,o,i,a):a(s,h.calcReduceByAxis(e,t,n,r+1,o,i,a)),o+=l;return s}static calcReduceShape(e,t,n){const r=e.slice();for(let e=0;e<t.length;e++)r[t[e]]=n?1:0;return r.filter((e=>0!==e))}}t.ReduceUtil=h;class g{static adjustPoolAttributes(e,t,n,r,o,i){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<o.length){if(o[e]<0)throw new Error("dilations should be greater than or equal to 1")}else o.push(1);for(let e=0;e<2*n.length;e++)if(e<i.length){if(i[e]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[e]>=n[e]||i[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,t,n,r,o,i){if(i){if(o.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(t.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let a=0;a<e.length-2;a++)g.adjustPadAndReturnShape(e[a+2],t[a],n[a],r[a],o,a,a+e.length-2,i)}}static computePoolOutputShape(e,t,n,r,o,i,a){if(t.length<=0)throw new Error("input shape must be of size greater than 0");const s=[t[0],t[1]];return g.computeShapeHelper(e,t,s,n,r,o,i,a),s}static computeConvOutputShape(e,t,n,r,o,i,a){if(e.length<=0||t.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const s=[e[0],t[0]];return g.computeShapeHelper(!1,e,s,n,r,o,i,a),s}static computeShapeHelper(e,t,n,r,o,i,a,s){if(e)for(let e=0;e<t.length-2;e++)n.push(1);else for(let e=0;e<t.length-2;e++)n.push(g.adjustPadAndReturnShape(t[e+2],r[e],o[e],i[e],a,e,e+t.length-2,s))}static adjustPadAndReturnShape(e,t,n,r,o,i,a,s){const u=n*(r-1)+1;if(!s||"NOTSET"===s)return Math.floor((e+o[i]+o[a]-u)/t+1);switch(s){case"VALID":return o[i]=0,o[a]=0,Math.floor((e-u)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const n=((e+t-1)/t-1)*t+r-e;return o[i]="SAME_LOWER"===s?Math.floor((n+1)/2):Math.floor(n/2),o[a]=n-o[i],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}}t.PoolConvUtil=g,t.MIN_CLIP=-34028234663852886e22,t.MAX_CLIP=34028234663852886e22,t.decodeUtf8String=function(e){return(new TextDecoder).decode(e)}},3838:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebGpuBackend=void 0;const r=n(8453),o=n(4955),i=n(7771),a=n(8510),s=n(8305);t.WebGpuBackend=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.pendingDispatchNumber=0,this.profilingEnabled=!1}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");const e=await navigator.gpu.requestAdapter();if(!e)throw new Error("WebGpuBackend: Failed to get GPU adapter.");const t={requiredLimits:{maxComputeWorkgroupStorageSize:e.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:e.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:e.limits.maxStorageBufferBindingSize}};e.features.has("timestamp-query-inside-passes")&&"default"===r.env.webgpu.profilingMode&&(this.profilingEnabled=!0,t.requiredFeatures=["timestamp-query-inside-passes"]),this.device=await e.requestDevice(t),this.gpuDataManager=(0,i.createGpuDataManager)(this),this.programManager=new s.ProgramManager(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,this.device.onuncapturederror=e=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},this.profilingEnabled&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2}))}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0}run(e,t,n,r,i){if(t.length!==e.inputTypes.length)throw new Error(`Input size must be equal to ${e.inputTypes.length}.`);const a=[];for(let e=0;e<t.length;++e){const n=this.gpuDataManager.get(t[e].data);if(!n)throw new Error(`no GPU data for input: ${t[e].data}`);a[e]=n}const s=((e,t,n)=>{const r=t.map((e=>`${e.join(",")}`)).join("_"),o=n.join("_");let i=e.name;return e.cacheHint&&(i+="["+e.cacheHint+"]"),i+=":"+r+";"+o,i})(e,t.map((e=>e.dims)),a.map((e=>e.type)));let u=this.programManager.getArtifact(s);const l=u?u.programInfo:"function"==typeof e.get?e.get():e,c=0===n.length?l.outputs.map(((e,t)=>t)):n;if(c.length!==l.outputs.length)throw new Error(`Output size ${c.length} must be equal to ${l.outputs.length}.`);const p=[],d=[];for(let e=0;e<l.outputs.length;++e){if(!Number.isInteger(c[e])||c[e]<-2||c[e]>=l.outputs.length)throw new Error(`Invalid output index: ${c[e]}`);const t=-1===c[e],n=-2===c[e],o=t||n?i(l.outputs[e].dataType,l.outputs[e].dims):r(c[e],l.outputs[e].dataType,l.outputs[e].dims),a=this.gpuDataManager.get(o.data);if(!a)throw new Error(`no GPU data for output: ${o.data}`);if(t&&this.temporaryData.push(a),n){let e=this.kernelPersistentData.get(this.currentKernelId);e||(e=[],this.kernelPersistentData.set(this.currentKernelId,e)),e.push(a)}p.push(o),d.push(a)}const f=this.programManager.normalizeDispatchGroupSize(l.dispatchGroup(t));return u||(u=this.programManager.build(l,f),this.programManager.setArtifact(s,u)),(0,o.LOG_DEBUG)("info",(()=>`[ProgramManager] run "${l.name}" (key=${s}) with ${f[0]}x${f[1]}x${f[2]}`)),this.programManager.run(u,a,d,f),p}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){const n=await this.gpuDataManager.download(e);t().set(new Uint8Array(n))}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n){const r=a.WEBGPU_OP_RESOLVE_RULES.get(e);if(!r)throw new Error(`kernel not implemented: ${e}`);this.kernels.set(t,[e,r[0],[r[1],n]])}releaseKernel(e){const t=this.kernelPersistentData.get(e);if(t){for(const e of t)this.gpuDataManager.release(e.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t){const n=this.kernels.get(e);if(!n)throw new Error(`kernel not created: ${e}`);const[r,i,a]=n;if(null!==this.currentKernelId)throw new Error(`kernel "${r}" is not allowed to be called recursively`);this.currentKernelId=e,a[0]&&(a[1]=a[0](a[1]),a[0]=void 0),(0,o.LOG_DEBUG)("info",(()=>`[WebGPU] Start to run kernel "${r}"...`)),this.temporaryData=[];try{return i(t,a[1]),0}catch(e){return(0,o.LOG_DEBUG)("warning",`[WebGPU] Kernel "${r}" failed. Error: ${e}`),1}finally{for(const e of this.temporaryData)this.gpuDataManager.release(e.id);this.temporaryData=[],this.currentKernelId=null}}}},7675:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.init=void 0;const r=n(7917),o=n(3838),i=n(4955),a=n(6952);class s{constructor(e,t,n,r){this.module=e,this.dataType=t,this.data=n,this.dims=r}getFloat32Array(){return new Float32Array(this.module.HEAP8.buffer,this.data,a.ShapeUtil.size(this.dims))}reshape(e){if(a.ShapeUtil.size(e)!==a.ShapeUtil.size(this.dims))throw new Error("Invalid new shape");return new s(this.module,this.dataType,this.data,e)}}class u{get customData(){return this.backend.currentKernelCustomData}constructor(e,t,n){this.module=e,this.backend=t;const r=e.HEAPU32;let o=n>>2;this.opKernelContext=r[o++];const i=r[o++],a=[];for(let t=0;t<i;t++){const t=r[o++],n=r[o++],i=r[o++],u=[];for(let e=0;e<i;e++)u.push(r[o++]);a.push(new s(e,t,n,u))}this.inputs=a}compute(e,t){var n,o,i;const u=null!==(o=null===(n=null==t?void 0:t.inputs)||void 0===n?void 0:n.map((e=>"number"==typeof e?this.inputs[e]:e)))&&void 0!==o?o:this.inputs,l=null!==(i=null==t?void 0:t.outputs)&&void 0!==i?i:[];return this.backend.run(e,u,l,((e,t,n)=>new s(this.module,t,this.output(e,n),n)),((e,t)=>{const n=(0,r.getTensorElementSize)(e);if(!n)throw new Error(`Unsupported data type: ${e}`);const o=n*a.ShapeUtil.size(t);return new s(this.module,e,this.backend.gpuDataManager.create(o).id,t)}))}output(e,t){const n=this.module.stackSave();try{const n=this.module.stackAlloc(4*(1+t.length));let r=n>>2;this.module.HEAPU32[r++]=t.length;for(let e=0;e<t.length;e++)this.module.HEAPU32[r++]=t[e];return this.module._JsepOutput(this.opKernelContext,e,n)}finally{this.module.stackRestore(n)}}}t.init=async e=>{const t=e.jsepInit;if(t&&navigator.gpu){const n=new o.WebGpuBackend;await n.initialize(),t({backend:n},(e=>n.alloc(e)),(e=>n.free(e)),((t,r,o,a=!1)=>{if(a)(0,i.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepCopyGpuToGpu: src=${t}, dst=${r}, size=${o}`)),n.memcpy(t,r);else{(0,i.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${t}, gpuDataId=${r}, size=${o}`));const a=e.HEAPU8.subarray(t,t+o);n.upload(r,a)}}),(async(t,r,o)=>{(0,i.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${t}, dataOffset=${r}, size=${o}`)),await n.download(t,(()=>e.HEAPU8.subarray(r,r+o)))}),((e,t,r)=>n.createKernel(e,t,r)),(e=>n.releaseKernel(e)),((t,r)=>{(0,i.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepRun: kernel=${t}, contextDataOffset=${r}`));const o=new u(e,n,r);return n.computeKernel(t,o)}))}}},4955:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.LOG_DEBUG=t.LOG=void 0;const r=n(8453),o=n(7917),i=["V","I","W","E","F"];t.LOG=(e,t)=>{const n=(0,o.logLevelStringToEnum)(e);var a,s;n>=(0,o.logLevelStringToEnum)(r.env.logLevel)&&(a=n,s="function"==typeof t?t():t,console.log(`[${i[a]},${(new Date).toISOString()}]${s}`))},t.LOG_DEBUG=(...e)=>{r.env.debug&&(0,t.LOG)(...e)}},6952:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MAX_CLIP=t.MIN_CLIP=t.GemmUtil=t.PoolConvUtil=t.ShapeUtil=t.BroadcastUtil=t.MatMulUtil=void 0;class n{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}}t.MatMulUtil=n;class r{static calcShape(e,t,r=!1){const o=e.length,i=t.length;if(0===o)return t;if(0===i)return e;const a=Math.max(e.length,t.length),s=new Array(a);if(r){if(o<2||i<2)return;const r=n.calcMatMulShape([e[o-2],e[o-1]],[t[i-2],t[i-1]]);if(void 0===r)return;[s[a-2],s[a-1]]=r}for(let n=r?3:1;n<=a;n++){const r=o-n<0?1:e[o-n],u=i-n<0?1:t[i-n];if(r!==u&&r>1&&u>1)return;s[a-n]=Math.max(r,u)}return s}static isValidBroadcast(e,t){const n=e.length,r=t.length;if(n>r)return!1;for(let o=1;o<=n;o++)if(1!==e[n-o]&&e[n-o]!==t[r-o])return!1;return!0}}t.BroadcastUtil=r;class o{static size(e){return o.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return o.getSizeFromDimensionRange(e,t,e.length)}static sizeToDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${e.length} dimensions.`);return o.getSizeFromDimensionRange(e,0,t)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let o=t;o<n;o++){if(e[o]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");r*=e[o]}return r}static computeStrides(e){const t=e.length;if(0===t)return[];if(1===t)return[1];const n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((n=>this.normalizeAxis(n,null!=t?t:e.length)))}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){const n=e.length;return e.map(((e,r)=>e+t[r]+t[r+n]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,n)=>e===t[n]))}}t.ShapeUtil=o;class i{static adjustPoolAttributes(e,t,n,r,o,i){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<o.length){if(o[e]<0)throw new Error("dilations should be greater than or equal to 1")}else o.push(1);for(let e=0;e<2*n.length;e++)if(e<i.length){if(i[e]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[e]>=n[e]||i[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,t,n,r,o,a,s){if(s){if(o.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(t.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let u=0;u<e.length-2;u++)i.adjustPadAndReturnShape(e[u+(a?1:2)],t[u],n[u],r[u],o,u,u+e.length-2,s)}}static computePoolOutputShape(e,t,n,r,o,a,s){if(t.length<=0)throw new Error("input shape must be of size greater than 0");const u=[t[0],t[1]];return i.computeShapeHelper(e,t,u,n,r,o,a,s),u}static computeConvOutputShape(e,t,n,r,o,a,s){if(e.length<=0||t.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const u=[e[0],t[0]];return i.computeShapeHelper(!1,e,u,n,r,o,a,s),u}static computeShapeHelper(e,t,n,r,o,a,s,u){if(e)for(let e=0;e<t.length-2;e++)n.push(1);else for(let e=0;e<t.length-2;e++)n.push(i.adjustPadAndReturnShape(t[e+2],r[e],o[e],a[e],s,e,e+t.length-2,u))}static adjustPadAndReturnShape(e,t,n,r,o,i,a,s){const u=n*(r-1)+1;if(!s||"NOTSET"===s)return Math.floor((e+o[i]+o[a]-u)/t+1);switch(s){case"VALID":return o[i]=0,o[a]=0,Math.floor((e-u)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const n=((e+t-1)/t-1)*t+r-e;return o[i]="SAME_LOWER"===s?Math.floor((n+1)/2):Math.floor(n/2),o[a]=n-o[i],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}}t.PoolConvUtil=i,t.GemmUtil=class{static getShapeOfGemmResult(e,t,n,o,i){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let a,s,u;t?(a=e[1],s=e[0]):(a=e[0],s=e[1]);let l=-1;if(o?(u=n[0],l=1):(u=n[1],l=0),n[l]!==s)throw new Error("dimension mismatch");if(a<=0||u<=0||s<=0)throw new Error("invalid shape specified");if(i&&!r.isValidBroadcast(i,[a,u]))throw new Error("gemm: invalid bias shape for broadcast");return[a,u,s]}},t.MIN_CLIP=-34028234663852886e22,t.MAX_CLIP=34028234663852886e22},387:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createAttributeWithCacheKey=void 0;class n{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this._cacheKey}}t.createAttributeWithCacheKey=e=>new n(e)},7771:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createGpuDataManager=void 0;const r=n(4955),o=n(1163),i=e=>16*Math.ceil(e/16);let a=0;class s{constructor(e){this.backend=e,this.storageCache=new Map,this.downloadCache=new Map,this.buffersForUploadingPending=[],this.buffersPending=[]}upload(e,t){const n=t.buffer,o=t.byteOffset,a=t.byteLength,s=i(a),u=this.storageCache.get(e);if(!u)throw new Error("gpu data for uploading does not exist");if(u.originalSize!==a)throw new Error(`inconsistent data size. gpu data size=${u.originalSize}, data size=${a}`);const l=this.backend.device.createBuffer({mappedAtCreation:!0,size:s,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),c=l.getMappedRange();new Uint8Array(c).set(new Uint8Array(n,o,a)),l.unmap();const p=this.backend.getCommandEncoder();this.backend.endComputePass(),p.copyBufferToBuffer(l,0,u.gpuData.buffer,0,s),(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] GpuDataManager.upload(id=${e})`)),this.buffersForUploadingPending.push(l)}memcpy(e,t){const n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");const r=this.storageCache.get(t);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");const o=i(n.originalSize);this.backend.getCommandEncoder().copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,o)}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){const n=i(e),s=this.backend.device.createBuffer({size:n,usage:t}),u={id:a++,type:o.GpuDataType.default,buffer:s};return this.storageCache.set(u.id,{gpuData:u,originalSize:e}),(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${u.id}`)),u}get(e){var t;return null===(t=this.storageCache.get(e))||void 0===t?void 0:t.gpuData}release(e){const t=this.storageCache.get(e);if(!t)throw new Error("releasing data does not exist");return(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${t.gpuData.id}`)),this.storageCache.delete(e),this.buffersPending.push(t.gpuData.buffer),this.downloadCache.get(e)&&this.downloadCache.delete(e),t.originalSize}async download(e){const t=this.downloadCache.get(e);if(t)return t.data;const n=this.storageCache.get(e);if(!n)throw new Error("data does not exist");const r=this.backend.getCommandEncoder();this.backend.endComputePass();const o=this.backend.device.createBuffer({size:n.originalSize,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});r.copyBufferToBuffer(n.gpuData.buffer,0,o,0,n.originalSize),this.backend.flush();const i=new Promise((e=>{o.mapAsync(GPUMapMode.READ).then((()=>{const t=o.getMappedRange().slice(0);o.destroy(),e(t)}))}));return this.downloadCache.set(e,{data:i}),i}refreshPendingBuffers(){for(const e of this.buffersForUploadingPending)e.destroy();for(const e of this.buffersPending)e.destroy()}}t.createGpuDataManager=(...e)=>new s(...e)},8510:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var o=Object.getOwnPropertyDescriptor(t,n);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,o)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return o(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.WEBGPU_OP_RESOLVE_RULES=void 0;const a=i(n(504)),s=n(9770),u=n(4271),l=n(1522),c=i(n(5262)),p=n(2625),d=i(n(9302));t.WEBGPU_OP_RESOLVE_RULES=new Map([["Abs",[d.abs]],["Acos",[d.acos]],["Acosh",[d.acosh]],["Add",[a.add]],["Asin",[d.asin]],["Asinh",[d.asinh]],["Atan",[d.atan]],["Atanh",[d.atanh]],["AveragePool",[c.averagePool,c.parseAveragePoolAttributes]],["Ceil",[d.ceil]],["ClipV10",[d.clipV10]],["Clip",[d.clip]],["Conv",[s.conv,s.parseConvAttributes]],["Cos",[d.cos]],["Cosh",[d.cosh]],["Div",[a.div]],["Elu",[d.elu,d.parseAlphaAttributes]],["Erf",[d.erf]],["Exp",[d.exp]],["Floor",[d.floor]],["Gemm",[u.gemm,u.parseGemmAttributes]],["GlobalAveragePool",[c.globalAveragePool,c.parseGlobalAveragePoolAttributes]],["GlobalMaxPool",[c.globalMaxPool,c.parseGlobalMaxPoolAttributes]],["LeakyRelu",[d.leakyRelu,d.parseAlphaAttributes]],["MatMul",[l.matMul]],["MaxPool",[c.maxPool,c.parseMaxPoolAttributes]],["Mul",[a.mul]],["Neg",[d.neg]],["Pow",[a.pow]],["Reciprocal",[d.reciprocal]],["Relu",[d.relu]],["Sigmoid",[d.sigmoid]],["Sin",[d.sin]],["Sinh",[d.sinh]],["Sqrt",[d.sqrt]],["Sub",[a.sub]],["Tan",[d.tan]],["Tanh",[d.tanh]],["ThresholdedRelu",[d.thresholdedRelu,d.parseAlphaAttributes]],["Transpose",[p.transpose,p.parseTransposeAttributes]]])},1427:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.biasActivationSnippet=t.activationFnSnippet=t.typeSnippet=void 0,t.typeSnippet=e=>{switch(e){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${e}-component is not supported.`)}},t.activationFnSnippet=(e,t=!1,n=!1,r=3)=>"",t.biasActivationSnippet=(e,t)=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      ${t?"value = activation(value, coords);":""}\n      `},9456:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createConv2DMatMulProgramInfo=void 0;const r=n(4955),o=n(6952),i=n(1163),a=n(1427),s=n(4085),u=n(158);t.createConv2DMatMulProgramInfo=(e,t,n,l,c,p,d,f,h)=>{const g="NHWC"===n.format,m=g?e[0].dims[3]:e[0].dims[1],b=l[0],y=g?l[2]:l[3],w=g?l[1]:l[2],_=g?l[3]:l[1],v=((m%4==0||m%3==0)&&g||y%4==0&&!g)&&_%4==0,x=g?_:y*w,T=g?y*w:_,S=v?[8,8,1]:[x<=4?4:16,x>4&&T<=4?4:16,1],O=v?[4,4,1]:[x<=4?1:2,x>4&&T<=4?1:2,1],A=[Math.ceil(x/S[0]/O[0]),Math.ceil(T/S[1]/O[1]),Math.ceil(b/S[2]/O[1])];(0,r.LOG_DEBUG)("verbose",(()=>`[conv2d_mm_webgpu] dispatch = ${A}`));const E=v?g&&m%4!=0?3:4:O[0],I=S[1]*O[1],$=S[0]*O[0],P=Math.max(S[0]*E,S[1]),D=c%I==0,k=p%$==0,C=d%P==0,R=v?[E,4,4]:[1,1,1],M=[`@group(0) @binding(0) var<storage, read> x: array<${v&&4===E?"vec4<f32>":"f32"}>;`,`@group(0) @binding(1) var<storage, read> w: array<${v?"vec4<f32>":"f32"}>;`];let N=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${v?"vec4<f32>":"f32"}) {\n        result[flatIndex] = ${v?"vec4<f32>":"f32"}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${v?"vec4<f32>":"f32"}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${v?"/ 4":""}, value);\n      }`;return f&&(M.push(`@group(0) @binding(2) var<storage, read> bias: array<${v?"vec4<f32>":"f32"}>;`),N+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${v?"vec4<f32>":"f32"} {\n          return bias[coords.${g?"w":"y"}${v?"/ 4":""}];\n        }`),Object.assign(Object.assign({},t),{outputs:[{dims:l,dataType:e[0].dataType,gpuDataType:i.GpuDataType.default}],dispatchGroup:()=>({x:A[0],y:A[1],z:A[2]}),getShaderSource:()=>`\n        ${s.utilFunctions}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${M.join("")}\n        @group(0) @binding(${M.length}) var<storage, read_write> result: array<${v?"vec4<f32>":"f32"}>;\n        //@group(0) @binding(${M.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${l.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${o.ShapeUtil.computeStrides(l).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${n.kernelShape[0]}, ${n.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${n.pads[0]}, ${n.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${n.strides[0]}, ${n.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${n.dilations[0]}, ${n.dilations[1]});\n        const dimAOuter : i32 = ${c};\n        const dimBOuter : i32 = ${p};\n        const dimInner : i32 = ${d};\n        ${N}\n        ${((e,t,n,r,o=!1,i,s=!1,u=4,l=4,c=4)=>{const p=e?"\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    ":"\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    ",d=e?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",f=e?"xShape[1]":"xShape[2]",h=e?"xShape[2]":"xShape[3]",g=e?"row":"col",m=e?"col":"row",b=`\n    let inChannels = wShape[2];\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\n    let outRow = ${g} / outWidth;\n    let outCol = ${g} % outWidth;\n\n    let WRow = ${m} / (filterDims[1] * inChannels);\n    let WCol = ${m} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${m} % inChannels;\n    var resData = ${(0,a.typeSnippet)(u)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${h}) {\n      ${p}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u)}\n    }\n    return resData;`,y=e?t&&r?`\n    let col = colIn * ${u};\n    ${b}`:`\n    let col = colIn * ${u};\n    if (row < dimAOuter && col < dimInner) {\n      ${b}\n    }\n    return ${(0,a.typeSnippet)(u)}(0.0);`:r&&n?`\n    let col = colIn * ${u};\n    ${b}`:`\n    let col = colIn * ${u};\n    if (row < dimInner && col < dimBOuter) {\n      ${b}\n    }\n    return ${(0,a.typeSnippet)(u)}(0.0);`,w=`${(e=>{switch(e){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(l)}`,_=(0,a.typeSnippet)(c),v=e?(0,a.typeSnippet)(u):(0,a.typeSnippet)(l),x=e?(0,a.typeSnippet)(l):(0,a.typeSnippet)(u);return`\n    ${(0,a.activationFnSnippet)(i,s,4===c,4)}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${v} {\n      ${e?y:w}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${x} {\n      ${e?w:y}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${_}) {\n      let col = colIn * ${c};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${d}\n      ${(0,a.biasActivationSnippet)(o,i)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`})(g,D,k,C,f,void 0,!1,R[0],R[1],R[2])}\n            ${v?(0,u.makeMatMulPackedVec4Source)(O,S,!g,P):(0,u.makeMatMulPackedSource)(O,S,!g,P,!1,void 0,h)}`})}},4085:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.utilFunctions=void 0,t.utilFunctions="\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n"},158:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.makeMatMulPackedSource=t.makeMatMulPackedVec4Source=void 0,t.makeMatMulPackedVec4Source=(e,t,n=!1,r=32,o=!1,i=32,a=!1)=>{const s=t[1]*e[1],u=t[0]*e[0],l=n?s:r,c=n?r:s,p=l/t[0],d=r/t[1];if((!n||4!==p||4!==e[1])&&(n||3!==p&&4!==p)||l%t[0]!=0||r%t[1]!=0||4!==e[0])throw new Error(`If transposeA ${n} is true, innerElementSize ${p} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${p} must be 3 or 4.\n  tileAWidth ${l} must be divisible by workgroupSize[0]${t[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub : array<array<vec${p}<f32>, ${l/p}>, ${c}>;\nvar<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/e[0]}>, ${r}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${p};\nconst tileInner = ${r};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = ${a?"0":"localRow * rowPerThread"};\n  let tileCol = i32(localId.x);\n\n  let globalRow = ${a?"0":"i32(globalId.y) * rowPerThread"};\n  let globalCol = i32(globalId.x);\n  let batch = ${o?"0":"i32(globalId.z)"};\n  let globalRowStart = i32(workgroupId.y) * ${s};\n\n  let numTiles = ${o?`${Math.ceil(i/r)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${o?`i32(globalId.z) * ${i}`:"0"};\n\n  var acc: array<vec4<f32>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${d};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${f=n,f?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol);\n        "}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${d}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${3===p?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${((e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${3===t?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`)(n,p)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`;var f};const n=e=>e?"\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol);\n            ":"\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol);\n            ";t.makeMatMulPackedSource=(e,t,r=!1,o=32,i=!1,a=32,s=!1)=>{const u=e[1]*t[1],l=e[0]*t[0],c=r?u:o,p=r?o:u;if(p%t[1]!=0||c%t[0]!=0||o%t[1]!=0)throw new Error(`tileAHight ${p} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${o} must be divisible by workgroupSize[1]${t[1]}`);const d=p/t[1],f=c/t[0],h=o/t[1],g=s?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${u};\n    let globalColStart = i32(workgroupId.x) * ${l};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\n          ${n(r)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${o}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol);\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<f32, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${r?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${u};\n\nlet tileRowA = i32(localId.y) * ${d};\nlet tileColA = i32(localId.x) * ${f};\nlet tileRowB = i32(localId.y) * ${h};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${d}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${f}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${n(r)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol);\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<f32, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${(e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(r)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<f32, ${c}>, ${p}>;\n  var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${o}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${o};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${i?"0":"i32(globalId.z)"};\n    let numTiles = ${i?`${Math.ceil(a/o)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${i?`i32(globalId.z) * ${a}`:"0"};\n\n    var acc : array<array<f32, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${g}\n  }\n`}},504:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.sub=t.pow=t.mul=t.div=t.add=void 0;const r=n(6952),o=n(1163),i=n(2075),a=(e,t,n,a,s)=>{const u={name:t,inputTypes:[o.GpuDataType.default,o.GpuDataType.default],cacheHint:s};return Object.assign(Object.assign({},u),{get:()=>((e,t,n,a,s,u=t.dataType)=>{var l,c;const p=!r.ShapeUtil.areEqual(t.dims,n.dims);let d=t.dims,f=r.ShapeUtil.size(t.dims),h=!1;if(p){const e=r.BroadcastUtil.calcShape(t.dims,n.dims,!1);if(!e)throw new Error("Can't perform binary op on the given tensors");d=e,f=r.ShapeUtil.size(d);let o=1;for(let e=0;e<d.length;e++){const r=null!==(l=t.dims[t.dims.length-e])&&void 0!==l?l:1;if(r!==(null!==(c=n.dims[n.dims.length-e])&&void 0!==c?c:1))break;o*=r}o%4==0&&(h=!0)}else h=!0;return Object.assign(Object.assign({},e),{getShaderSource:e=>((e,t,n,o,a,s,u,l,c="f32",p="f32",d="f32")=>{const f=r.ShapeUtil.size(o),h=Math.ceil(f/4);let g,m;"string"==typeof u?g=m=(e,t)=>`${u}((${e}),(${t}))`:"function"==typeof u?g=m=u:(g=u.scalar,m=u.vector);let b="";const y=(0,i.createIndicesHelper)("output",o);if(s){const e=e=>{const t=r.ShapeUtil.computeStrides(e),n=[];for(let r=e.length-1;r>=0;r--){const i=0===o.length?"0u":1===o.length?"(*outputIndices)":`(*outputIndices)[${r+o.length-e.length}]`;n.push(`${t[r]}u * (${i} % ${e[r]}u)`)}return n.length>0?n.join("+"):"0u"};b=`\n  ${y.o2iImpl}\n\n  fn calcOffsetA(outputIndices: ptr<function, ${y.iType}>) -> u32 {\n    return ${e(t)};\n  }\n\n  fn calcOffsetB(outputIndices: ptr<function, ${y.iType}>) -> u32 {\n    return ${e(n)};\n  }\n  `}let w;if(a)w=s?`\n      ${y.indicesVariableDeclaration("outputIndices")}\n      ${y.o2iCall("global_idx * 4u","outputIndices")}\n      let offsetA = calcOffsetA(&outputIndices);\n      let offsetB = calcOffsetB(&outputIndices);\n      outputData[global_idx] = ${m("aData[offsetA / 4u]","bData[offsetB / 4u]")};`:`outputData[global_idx] = ${m("aData[global_idx]","bData[global_idx]")};`;else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");const e=e=>{const t=`aData[indexA${e}][componentA${e}]`,n=`bData[indexB${e}][componentB${e}]`;return`\n      ${y.o2iCall(`global_idx * 4u + ${e}u`,"outputIndices")}\n      let offsetA${e} = calcOffsetA(&outputIndices);\n      let offsetB${e} = calcOffsetB(&outputIndices);\n      let indexA${e} = offsetA${e} / 4u;\n      let indexB${e} = offsetB${e} / 4u;\n      let componentA${e} = offsetA${e} % 4u;\n      let componentB${e} = offsetB${e} % 4u;\n      outputData[global_idx][${e}] = ${g(t,n)};`};w=`\n      ${y.indicesVariableDeclaration("outputIndices")}\n      ${e(0)}\n      ${e(1)}\n      ${e(2)}\n      ${e(3)}`}return`\n  @group(0) @binding(0) var<storage, read> aData : array<vec4<${c}>>;\n  @group(0) @binding(1) var<storage, read> bData : array<vec4<${p}>>;\n  @group(0) @binding(2) var<storage, read_write> outputData : array<vec4<${d}>>;\n\n  ${null!=l?l:""}\n  ${b}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n    ${w}\n  }`})(e,t.dims,n.dims,d,h,p,a,s),outputs:[{dims:d,dataType:u,gpuDataType:o.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(f/64/(h?4:1))})})})(u,e[0],e[1],n,a)})};t.add=e=>{e.compute(a(e.inputs,"Add",((e,t)=>`${e}+${t}`)))},t.div=e=>{e.compute(a(e.inputs,"Div",((e,t)=>`${e}/${t}`)))},t.mul=e=>{e.compute(a(e.inputs,"Mul",((e,t)=>`${e}*${t}`)))},t.pow=e=>{e.compute(a(e.inputs,"Pow",{scalar:(e,t)=>`pow_f32(${e},${t})`,vector:(e,t)=>`pow_vf32(${e},${t})`},"\n    fn pow_f32(a : f32, b : f32) -> f32 {\n      if (b == 0.0) {\n        return 1.0;\n      } else if (a < 0.0 && b != floor(b)) {\n        return pow(a, b); // NaN\n      }\n      return select(sign(a), 1.0, round(abs(b) % 2.0) != 1.0) * pow(abs(a), b);\n    }\n    fn pow_vf32(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {\n      // TODO: implement vectorized pow\n      return vec4<f32>(pow_f32(a.x, b.x), pow_f32(a.y, b.y), pow_f32(a.z, b.z), pow_f32(a.w, b.w));\n    }\n      "))},t.sub=e=>{e.compute(a(e.inputs,"Sub",((e,t)=>`${e}-${t}`)))}},2075:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createShaderHelper=t.createIndicesHelper=t.WORKGROUP_SIZE=void 0;const r=n(6952);t.WORKGROUP_SIZE=64,t.createIndicesHelper=(e,t)=>{const n=t.length<2?"u32":`array<u32, ${t.length}>`,o=r.ShapeUtil.computeStrides(t);let i="";for(let e=0;e<t.length-1;e++)i+=`\n    let dim${e} = current / ${o[e]}u;\n    let rest${e} = current % ${o[e]}u;\n    (*indices)[${e}] = dim${e};\n    current = rest${e};\n    `;i+=`(*indices)[${t.length-1}] = current;`;const a=t.length<2?"":`\n  fn ih_o2i_${e}(offset: u32, indices: ptr<function, ${n}>) {\n    var current = offset;\n    ${i}\n  }`,s=[];if(0===t.length)s.push("0u");else if(t.length<2)s.push("(*indices)");else for(let e=t.length-1;e>=0;e--)s.push(`${o[e]}u * ((*indices)[${e}])`);return{o2iImpl:a,o2iCall:(n,r)=>t.length<2?`${r}=${n};`:`ih_o2i_${e}(${n}, &${r});`,i2oImpl:t.length<2?"":`\n  fn ih_i2o_${e}(indices: ptr<function, ${n}>) -> u32 {\n    return ${s.join("+")};\n  }`,i2oExpression:(n,r)=>t.length<2?`(${r?"*":""}${n})`:`ih_i2o_${e}(${r?"":"&"}${n})`,indicesVariableDeclaration:(e,t)=>`var ${e}:${n}${t?`=${n}(${t.join(",")})`:""};`,iType:n}};class o{constructor(e){this.normalizedDispatchGroup=e}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${"number"==typeof e?`${e}u`:e}) { return; }`}mainStart(e=t.WORKGROUP_SIZE){const n="number"==typeof e?e:e[0],r="number"==typeof e?1:e[1],o="number"==typeof e?1:e[2],i=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${n}, ${r}, ${o})\n  fn main(${i?"@builtin(global_invocation_id) global_id : vec3<u32>":"@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>"}) {\n    ${i?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +\n          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${n*r*o}u + local_index;`}\n  `}}t.createShaderHelper=e=>new o(e)},9192:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createGroupedConvProgramInfoLoader=void 0;const r=n(6952),o=n(1163),i=n(2075),a=n(9770),s=n(3997);t.createGroupedConvProgramInfoLoader=(e,t,n)=>{const u=(l=e.length>2,c=t.cacheKey,{name:"GroupedConv",inputTypes:l?[o.GpuDataType.default,o.GpuDataType.default,o.GpuDataType.default]:[o.GpuDataType.default,o.GpuDataType.default],cacheHint:c});var l,c;return Object.assign(Object.assign({},u),{get:()=>((e,t,n,u)=>{const l=e.length>2,c=l?"value += b[output_channel];":"",p=e[0].dims,d=e[1].dims,f=d[0]/n.group,h="f32",{activationFunction:g,applyActivation:m}=(0,s.getActicationSnippet)(n),b=[`@group(0) @binding(0) var<storage, read> x : array<${h}>;`,`@group(0) @binding(1) var<storage, read> w : array<${h}>;`];l&&b.push(`@group(0) @binding(2) var<storage, read> b : array<${h}>;`);const y="NHWC"===n.format,w=(0,a.calculateOutputShape)(p,d,n.dilations,n.pads,n.strides,y),_=r.ShapeUtil.size(w),v=(0,i.createIndicesHelper)("output",w),x=(0,i.createIndicesHelper)("x",p),T=(0,i.createIndicesHelper)("w",d);return Object.assign(Object.assign({},t),{outputs:[{dims:u?u(w):w,dataType:e[0].dataType,gpuDataType:o.GpuDataType.default}],getShaderSource:e=>`\n  const strides: vec2<u32> = vec2(${n.strides[0]}u, ${n.strides[1]}u);\n  const pads: vec2<u32> = vec2(${n.pads[0]}u, ${n.pads[1]}u);\n\n  ${b.join("\n")}\n  @group(0) @binding(${b.length}) var<storage, read_write> output : array<${h}>;\n\n  ${g}\n  ${v.o2iImpl}\n  ${x.i2oImpl}\n  ${T.i2oImpl}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(_)}\n\n    ${v.indicesVariableDeclaration("outputIndices")}\n    ${v.o2iCall("global_idx","outputIndices")}\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${y?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${y?1:2}], outputIndices[${y?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${f}u;\n\n    var value: ${h} = ${h}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${d[1]}u; wInChannel++) {\n      let input_channel = group_id * ${d[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${d[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${n.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${p[y?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${d[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${n.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${p[y?2:3]}u) {\n            continue;\n          }\n\n          ${x.indicesVariableDeclaration("xIndices",y?["batch","xHeight","xWidth","input_channel"]:["batch","input_channel","xHeight","xWidth"])}\n          let xVal = x[${x.i2oExpression("xIndices")}];\n          ${T.indicesVariableDeclaration("wIndices",["output_channel","wInChannel","wHeight","wWidth"])}\n          let wVal = w[${T.i2oExpression("wIndices")}];\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${c}\n    ${m}\n    output[global_idx] = value;\n  }`,dispatchGroup:()=>({x:Math.ceil(_/64)})})})(e,u,t,n)})}},9770:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.conv=t.parseConvAttributes=t.calculateOutputShape=void 0;const r=n(6952),o=n(387),i=n(9192),a=n(3822),s=n(3997),u=n(2625);t.calculateOutputShape=(e,t,n,r,o,i)=>{const a=e[0],s=e.slice(i?1:2,i?3:4),u=s.length,l=t[0],c=t.slice(2).map(((e,t)=>e+(e-1)*(n[t]-1))),p=s.map(((e,t)=>e+r[t]+r[t+u])).map(((e,t)=>Math.floor((e-c[t]+o[t])/o[t])));return p.splice(0,0,a),p.splice(i?3:1,0,l),p};const l=(0,o.createAttributeWithCacheKey)({perm:[2,3,1,0]}),c=(e,t)=>{const n=e.kernelShape.slice();for(let e=2;e<t[1].dims.length;++e)0===n[e-2]&&(n[e-2]=t[1].dims[e]);const o=e.pads.slice();r.PoolConvUtil.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,o,"NHWC"===e.format,e.autoPad);const i=Object.assign({},e);return Object.assign(i,{kernelShape:n,pads:o,cacheKey:e.cacheKey}),i};t.parseConvAttributes=e=>{const t=(0,s.parseInternalActivationAttributes)(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],i=e.dilations,a=e.group,u=e.kernel_shape,l=e.pads,c=e.strides,p=e.w_is_const();return(0,o.createAttributeWithCacheKey)(Object.assign({autoPad:r,format:n,dilations:i,group:a,kernelShape:u,pads:l,strides:c,wIsConst:p},t))},t.conv=(e,n)=>{((e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");const n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("Conv input(X,W) should be float tensor");if(3===e.length&&1!==e[2].dataType)throw new Error("Conv input(bias) should be float tensor")})(e.inputs,n),3===e.inputs[0].dims.length?((e,t)=>{const n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);const o=[0,t.pads[0],0,t.pads[1]],a=[1].concat(t.strides),s=[1].concat(t.dilations),u=[1].concat(t.kernelShape),l=c(Object.assign(Object.assign({},t),{pads:o,strides:a,dilations:s,kernelShape:u}),r);e.compute((0,i.createGroupedConvProgramInfoLoader)(r,l,(e=>n?[e[0],e[2],e[3]]:[])))})(e,n):((e,n,r)=>{var o;const s=c(r,n),p=3===n.length,d="NHWC"===r.format,f=n[0].dims[d?1:2],h=n[0].dims[d?2:3],g=n[0].dims[d?3:1],m=n[1].dims[2],b=n[1].dims[3],y=(0,t.calculateOutputShape)(n[0].dims,n[1].dims,r.dilations,s.pads,r.strides,d),w=y[d?1:2],_=y[d?2:3],v=y[d?3:1];if(d&&m===f&&b===h&&"VALID"===r.autoPad||1===m&&1===b&&1===r.dilations[0]&&1===r.dilations[1]&&1===r.strides[0]&&1===r.strides[1]&&("SAME_UPPER"===r.autoPad||"SAME_LOWER"===r.autoPad||"VALID"===r.autoPad))return void e.compute((0,i.createGroupedConvProgramInfoLoader)(n,s));if(!d||1!==r.group)return void e.compute((0,i.createGroupedConvProgramInfoLoader)(n,s));const x=d?w*_:v,T=d?v:w*_,S=m*b*g,O=null!==(o=e.customData.wT)&&void 0!==o?o:e.compute(Object.assign(Object.assign({},u.transposeProgramMetadata),{cacheHint:l.cacheKey,get:()=>(0,u.createTransposeProgramInfo)(n[1],l.perm)}),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.customData.wT&&(e.customData.wT=O);const A=[n[0],O];p&&(d||1!==n[2].dims.length?A.push(n[2]):A.push(n[2].reshape([n[2].dims[0],1,1]))),e.compute((0,a.createConv2DMatMulProgramInfoLoader)(A,s,y,x,T,S,p,!0),{inputs:A})})(e,e.inputs,n)}},3822:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createConv2DMatMulProgramInfoLoader=void 0;const r=n(1163),o=n(9456);t.createConv2DMatMulProgramInfoLoader=(e,t,n,i,a,s,u,l)=>{const c=((e,t)=>({name:"Conv2DMatMul",inputTypes:e?[r.GpuDataType.default,r.GpuDataType.default,r.GpuDataType.default]:[r.GpuDataType.default,r.GpuDataType.default],cacheHint:t}))(u,t.cacheKey);return Object.assign(Object.assign({},c),{get:()=>(0,o.createConv2DMatMulProgramInfo)(e,c,t,n,i,a,s,u,l)})}},3997:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseInternalActivationAttributes=t.getActicationSnippet=void 0;const r=n(6952);t.getActicationSnippet=e=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},t.parseInternalActivationAttributes=e=>{const t=(null==e?void 0:e.activation)||"";if("Clip"===t){const[n,o]=(null==e?void 0:e.activation_params)||[r.MIN_CLIP,r.MAX_CLIP];return{activation:t,clipMax:o,clipMin:n,activationCacheKey:`${t}:${n},${o}`}}return{activation:t,activationCacheKey:t}}},4271:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseGemmAttributes=t.gemm=void 0;const r=n(6952),o=n(387),i=n(1163);t.gemm=(e,t)=>{(e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(3===e.length&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(1!==e[0].dataType||1!==e[1].dataType||3===e.length&&1!==e[2].dataType)throw new Error("Invalid input type.");if(e[0].dataType!==e[1].dataType||3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")})(e.inputs),e.compute(((e,t)=>{const n={name:"Gemm",inputTypes:3===e.length?[i.GpuDataType.default,i.GpuDataType.default,i.GpuDataType.default]:[i.GpuDataType.default,i.GpuDataType.default],cacheHint:t.cacheKey};return Object.assign(Object.assign({},n),{get:()=>((e,t,n)=>{const o=t[0].dims.slice(),a=t[1].dims.slice(),[s,u,l]=r.GemmUtil.getShapeOfGemmResult(o,n.transA,a,n.transB,3===t.length?t[2].dims:void 0),c=[s,u];if(!c)throw new Error("Can't use gemm on the given tensors");const p=r.ShapeUtil.size(c);let d="";n.transA&&n.transB?d="value += a[k * M + m] * b[n * K + k];":n.transA&&!n.transB?d="value += a[k * M + m] * b[k * N + n];":!n.transA&&n.transB?d="value += a[m * K + k] * b[n * K + k];":n.transA||n.transB||(d="value += a[m * K + k] * b[k * N + n];");const f="f32",h=1===n.alpha?"":"value *= alpha;",g=3===t.length?`value += beta * c[${((e,t,n)=>{if(0===n.length)return"0u";const r=1===n.length&&1!==e||2===n.length&&n[0]!==e,o=n[n.length-1]!==t;let i="0u";return r||(i+=`+ m * ${n[n.length-1]}u`),o||(i+="+n"),i})(s,u,t[2].dims)}];`:"",m=[`@group(0) @binding(0) var<storage, read> a : array<${f}>;`,`@group(0) @binding(1) var<storage, read> b : array<${f}>;`];return 3===t.length&&m.push(`@group(0) @binding(2) var<storage, read> c : array<${f}>;`),Object.assign(Object.assign({},e),{outputs:[{dims:c,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>`\n  const M: u32 = ${s}u;\n  const N: u32 = ${u}u;\n  const K: u32 = ${l}u;\n  const alpha = ${f}(${n.alpha});\n  const beta = ${f}(${n.beta});\n\n  ${m.join("\n")}\n  @group(0) @binding(${t.length}) var<storage, read_write> output : array<${f}>;\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${f}(0);\n    for (var k: u32 = 0u; k<${l}u; k++) {\n      ${d}\n    }\n\n    ${h}\n    ${g}\n    output[global_id.x] = value;\n\n  }`,dispatchGroup:()=>({x:Math.ceil(p/64)})})})(n,e,t)})})(e.inputs,t))},t.parseGemmAttributes=e=>(0,o.createAttributeWithCacheKey)(e)},1522:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.matMul=t.createMatmulProgramInfoLoader=void 0;const r=n(6952),o=n(1163),i=n(3997);t.createMatmulProgramInfoLoader=(e,t)=>{const n=(a=e.length>2,s=t.activationCacheKey,{name:"MatMul",inputTypes:a?[o.GpuDataType.default,o.GpuDataType.default,o.GpuDataType.default]:[o.GpuDataType.default,o.GpuDataType.default],cacheHint:s});var a,s;return Object.assign(Object.assign({},n),{get:()=>((e,t,n)=>{const a=t[0].dims,s=t[1].dims,u=r.BroadcastUtil.calcShape(a,s,!0);if(!u)throw new Error("Can't use matmul on the given tensors");const l=r.ShapeUtil.size(u),c="f32",{activationFunction:p,applyActivation:d}=(0,i.getActicationSnippet)(n),f=u[u.length-2],h=a[a.length-1],g=u[u.length-1];return Object.assign(Object.assign({},e),{outputs:[{dims:u,dataType:t[0].dataType,gpuDataType:o.GpuDataType.default}],getShaderSource:e=>`\n  const M: u32 = ${f}u;\n  const N: u32 = ${g}u;\n  const K: u32 = ${h}u;\n\n  @group(0) @binding(0) var<storage, read> a : array<${c}>;\n  @group(0) @binding(1) var<storage, read> b : array<${c}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${c}>;\n\n  ${p}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n\n    let stack = global_idx / (M * N);\n    let mn = global_idx % (M * N);\n    let n = global_idx % N;\n    let m = mn / N;\n\n    let offsetA = stack * (M * K);\n    let offsetB = stack * (K * N);\n\n    var value = ${c}(0);\n    for (var k: u32 = 0u; k<${h}u; k++) {\n      value += a[offsetA + m * K + k] * b[offsetB + k * N + n];\n    }\n    ${d}\n    output[global_idx] = value;\n  }`,dispatchGroup:()=>({x:Math.ceil(l/64)})})})(n,e,t)})},t.matMul=e=>{(e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("inputs should be float type")})(e.inputs),e.compute((0,t.createMatmulProgramInfoLoader)(e.inputs,{activation:"",activationCacheKey:""}))}},5262:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.globalMaxPool=t.parseGlobalMaxPoolAttributes=t.parseMaxPoolAttributes=t.maxPool=t.globalAveragePool=t.parseGlobalAveragePoolAttributes=t.averagePool=t.parseAveragePoolAttributes=void 0;const r=n(6952),o=n(387),i=n(1163),a=n(2075),s=e=>{if(!e||1!==e.length)throw new Error("Pool ops requires 1 input.");if(4!==e[0].dims.length)throw new Error("Pool ops supports 2-D inputs only for now.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},u=(e,t,n)=>{const o="NHWC"===t.format,i=o?[e[0].dims[0],e[0].dims[3],e[0].dims[1],e[0].dims[2]]:e[0].dims.slice(),a=Object.hasOwnProperty.call(t,"dilations"),s=t.kernelShape.slice(),u=t.strides.slice(),l=a?t.dilations.slice():[],c=t.pads.slice();r.PoolConvUtil.adjustPoolAttributes(n,i,s,u,l,c);const p=r.PoolConvUtil.computePoolOutputShape(n,i,u,l,s,c,t.autoPad),d=Object.assign({},t);return a?Object.assign(d,{kernelShape:s,strides:u,pads:c,dilations:l,cacheKey:t.cacheKey}):Object.assign(d,{kernelShape:s,strides:u,pads:c,cacheKey:t.cacheKey}),[d,o?[p[0],p[2],p[3],p[1]]:p]},l=(e,t,n,o,i,s,u,l)=>{const c="NHWC"===o.format,p=t.length,d=r.ShapeUtil.size(n),f=(0,a.createIndicesHelper)("output",n),h=(0,a.createIndicesHelper)("x",t);if(o.kernelShape.length<=2){const n=o.kernelShape[o.kernelShape.length-1],r=o.strides[o.strides.length-1],a=o.pads[o.pads.length/2-1],g=p-(c?2:1);let m="",b="",y="";if(m=a+o.pads[o.pads.length-1]!==0?`\n              for (var i: u32 = 0u; i < ${n}u; i++) {\n                xIndices[${g}] = indices[${g}] * ${r} - ${a} + i;\n                if (xIndices[${g}] < 0 || xIndices[${g}] >= ${t[g]}) {\n                  pad++;\n                  continue;\n                }\n                let x_val = x[${h.i2oExpression("xIndices")}];\n                ${i}\n              }`:`\n              for (var i: u32 = 0u; i < ${n}u; i++) {\n                xIndices[${g}] = indices[${g}] * ${r} - ${a} + i;\n                let x_val = x[${h.i2oExpression("xIndices")}];\n                ${i}\n              }`,2===o.kernelShape.length){const e=o.kernelShape[o.kernelShape.length-2],r=o.strides[o.strides.length-2],i=o.pads[o.pads.length/2-2],a=o.pads[o.pads.length-2],s=p-(c?3:2),u=t[s];b=i+a!==0?`\n                for (var j: u32 = 0u; j < ${e}u; j++) {\n                  xIndices[${s}] = indices[${s}] * ${r} - ${i} + j;\n                  if (xIndices[${s}] < 0 || xIndices[${s}] >= ${u}) {\n                    pad+= ${n};\n                    continue;\n                  }\n              `:`\n                for (var j: u32 = 0u; j < ${e}u; j++) {\n                  xIndices[${s}] = indices[${s}] * ${r} - ${i} + j;\n                `,y="\n              }\n            "}return`\n            @group(0) @binding(0) var<storage, read> x : array<${u}>;\n            @group(0) @binding(1) var<storage, read_write> output : array<${u}>;\n\n            ${f.o2iImpl}\n            ${h.i2oImpl}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(d)}\n\n              ${f.indicesVariableDeclaration("indices")}\n              ${f.o2iCall("global_idx","indices")}\n              ${f.indicesVariableDeclaration("xIndices")}\n              ${f.o2iCall("global_idx","xIndices")}\n\n              var value: ${u} = ${u}(${l});\n              var pad = 0;\n              ${b}\n              ${m}\n              ${y}\n              ${s}\n\n              output[global_idx] = value;\n            }`}{if(c)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");const n=r.ShapeUtil.size(o.kernelShape),a=r.ShapeUtil.computeStrides(o.kernelShape),g=a.length,m=o.pads.length;let b="";return b=o.pads.reduce(((e,t)=>e+t))?`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${h.i2oExpression("xIndices")}];\n                ${i}\n              }`:`\n              }\n              let x_val = x[${h.i2oExpression("xIndices")}];\n              ${i}\n            `,`\n            @group(0) @binding(0) var<storage, read> x : array<${u}>;\n            @group(0) @binding(1) var<storage, read_write> output : array<${u}>;\n\n            ${f.o2iImpl}\n            ${h.i2oImpl}\n\n            const pads = array<u32, ${m}>(${o.pads.map((e=>`${e}u`)).join(",")});\n            const inputDims = array<u32, ${p}>(${t.map((e=>`${e}u`)).join(",")});\n            const kernelStrides = array<u32, ${g}>(${a.map((e=>`${e}u`)).join(",")});\n            const strides = array<u32, ${g}>(${o.strides.map((e=>`${e}u`)).join(",")});\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(d)}\n\n              ${f.indicesVariableDeclaration("indices")}\n              ${f.o2iCall("global_idx","indices")}\n              ${f.indicesVariableDeclaration("xIndices")}\n              ${f.o2iCall("global_idx","xIndices")}\n\n              var offsets: array<u32, ${g}>;\n\n              var value = ${u}(${l});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${n}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${g-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${g-1}] = offset;\n\n                isPad = false;\n                for (var j = ${p-g}u; j < ${p}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${p-g}u]\n                    + offsets[j - ${p-g}u] - pads[j - 2u];\n                  ${b}\n              }\n              ${s}\n\n              output[global_idx] = value;\n            }`}},c=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),p=(e,t,n,o)=>{const[a,s]=u(e,o,n),c=r.ShapeUtil.size(a.kernelShape),p="f32";let d="";return a.countIncludePad?d+=`value /= ${p}(${c});`:d+=`value /= ${p}(${c} - pad);`,Object.assign(Object.assign({},t),{outputs:[{dims:s,dataType:e[0].dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:t=>l(t,e[0].dims,s,a,"value += x_val;",d,p,"0.0"),dispatchGroup:()=>({x:Math.ceil(r.ShapeUtil.size(s)/64)})})};t.parseAveragePoolAttributes=e=>{const t=0!==e.count_include_pad,n=c(e);if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,o.createAttributeWithCacheKey)(Object.assign({countIncludePad:t},n))},t.averagePool=(e,t)=>{s(e.inputs);const n={name:"AveragePool",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>p(e.inputs,n,!1,t)}))};const d={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""};t.parseGlobalAveragePoolAttributes=e=>{const t=e.format;return Object.assign(Object.assign({format:t},d),{cacheKey:t})},t.globalAveragePool=(e,t)=>{s(e.inputs);const n={name:"GlobalAveragePool",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>p(e.inputs,n,!0,t)}))};const f=(e,t,n,o)=>{const[a,s]=u(e,o,n);return Object.assign(Object.assign({},t),{outputs:[{dims:s,dataType:e[0].dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:t=>l(t,e[0].dims,s,a,"\n      value = max(x_val, value);\n    ","","f32","-1e5"),dispatchGroup:()=>({x:Math.ceil(r.ShapeUtil.size(s)/64)})})};t.maxPool=(e,t)=>{s(e.inputs);const n={name:"MaxPool",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>f(e.inputs,n,!1,t)}))},t.parseMaxPoolAttributes=e=>{const t=e.storage_order,n=e.dilations,r=c(e);if(0!==t)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==r.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,o.createAttributeWithCacheKey)(Object.assign({storageOrder:t,dilations:n},r))},t.parseGlobalMaxPoolAttributes=e=>{const t=e.format;return Object.assign(Object.assign({format:t},d),{cacheKey:t})},t.globalMaxPool=(e,t)=>{s(e.inputs);const n={name:"GlobalMaxPool",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>f(e.inputs,n,!0,t)}))}},2625:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseTransposeAttributes=t.transpose=t.createTransposeProgramInfo=t.transposeProgramMetadata=void 0;const r=n(6952),o=n(387),i=n(1163),a=n(2075);t.transposeProgramMetadata={name:"Transpose",inputTypes:[i.GpuDataType.default]};const s=(e,t)=>t&&t.length!==e.length?[...e.keys()].reverse():t;t.createTransposeProgramInfo=(e,n)=>{const o=e.dims,u=s(o,n),l=((e,t)=>r.ShapeUtil.sortBasedOnPerm(e,s(e,t)))(o,u),c=o.length,p=r.ShapeUtil.size(l),d=(0,a.createIndicesHelper)("output",l),f=(0,a.createIndicesHelper)("a",o);return Object.assign(Object.assign({},t.transposeProgramMetadata),{outputs:[{dims:l,dataType:e.dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>`\n  @group(0) @binding(0) var<storage, read> a : array<f32>;\n  @group(0) @binding(1) var<storage, read_write> output : array<f32>;\n\n  ${((e,t)=>{const n=[];n.push(`fn perm(a: ptr<function, array<u32, ${t}>>, i: ptr<function, array<u32, ${t}>>) {`);for(let r=0;r<t;++r)n.push(`\t(*a)[${e[r]}]=(*i)[${r}];`);return n.push("\t}"),n.join("\n")})(u,c)}\n  ${d.o2iImpl}\n  ${f.i2oImpl}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\n\n    ${d.indicesVariableDeclaration("indices")}\n    ${d.o2iCall("global_idx","indices")}\n    ${f.indicesVariableDeclaration("aIndices")}\n    perm(&aIndices, &indices);\n\n    output[global_idx] = a[${f.i2oExpression("aIndices")}];\n  }`,dispatchGroup:()=>({x:Math.ceil(p/64)})})},t.transpose=(e,n)=>{(e=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.");if(1!==e[0].dataType)throw new Error("input should be float tensor")})(e.inputs),e.compute(Object.assign(Object.assign({},t.transposeProgramMetadata),{cacheHint:n.cacheKey,get:()=>(0,t.createTransposeProgramInfo)(e.inputs[0],n.perm)}))},t.parseTransposeAttributes=e=>(0,o.createAttributeWithCacheKey)({perm:e.perm})},9302:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.thresholdedRelu=t.tanh=t.tan=t.sqrt=t.sinh=t.sin=t.sigmoid=t.relu=t.reciprocal=t.neg=t.leakyRelu=t.floor=t.exp=t.erf=t.elu=t.parseAlphaAttributes=t.cosh=t.cos=t.ceil=t.clip=t.clipV10=t.atanh=t.atan=t.asinh=t.asin=t.acosh=t.acos=t.abs=void 0;const r=n(6952),o=n(387),i=n(1163),a=(e,t,n,o,a)=>{const s={name:t,inputTypes:[i.GpuDataType.default],cacheHint:a};return Object.assign(Object.assign({},s),{get:()=>((e,t,n,o)=>Object.assign(Object.assign({},e),{getShaderSource:e=>((e,t,n,r)=>{const o=Math.ceil(t/4);let i="";return i="string"==typeof n?`${n}(a)`:n("a"),`\n  @group(0) @binding(0) var<storage, read> inputData : array<vec4<f32>>;\n  @group(0) @binding(1) var<storage, read_write> outputData : array<vec4<f32>>;\n\n  ${null!=r?r:""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n\n    let a = inputData[global_idx];\n    outputData[global_idx] = ${i};\n  }`})(e,r.ShapeUtil.size(t.dims),n,o),outputs:[{dims:t.dims,dataType:t.dataType,gpuDataType:i.GpuDataType.default}],dispatchGroup:e=>({x:Math.ceil(r.ShapeUtil.size(e[0].dims)/64/4)})}))(s,e,n,o)})};t.abs=e=>{e.compute(a(e.inputs[0],"Abs","abs"))},t.acos=e=>{e.compute(a(e.inputs[0],"Acos","acos"))},t.acosh=e=>{e.compute(a(e.inputs[0],"Acosh","acosh"))},t.asin=e=>{e.compute(a(e.inputs[0],"Asin","asin"))},t.asinh=e=>{e.compute(a(e.inputs[0],"Asinh","asinh"))},t.atan=e=>{e.compute(a(e.inputs[0],"Atan","atan"))},t.atanh=e=>{e.compute(a(e.inputs[0],"Atanh","atanh"))},t.clipV10=(e,t)=>{e.compute(a(e.inputs[0],"Clip",(e=>`clamp(${e}, clip_min_, clip_max_)`),`\n    const clip_min_: vec4<f32> = vec4(f32(${t.min}));\n    const clip_max_: vec4<f32> = vec4(f32(${t.max}));\n`,t.cacheKey),{inputs:[0]})},t.clip=e=>{const n=(e=>{const t=e.length>=2?e[1].getFloat32Array()[0]:r.MIN_CLIP,n=e.length>=3?e[2].getFloat32Array()[0]:r.MAX_CLIP;return(0,o.createAttributeWithCacheKey)({min:t,max:n})})(e.inputs);(0,t.clipV10)(e,n)},t.ceil=e=>{e.compute(a(e.inputs[0],"Ceil","ceil"))},t.cos=e=>{e.compute(a(e.inputs[0],"Cos","cos"))},t.cosh=e=>{e.compute(a(e.inputs[0],"Cosh","cosh"))},t.parseAlphaAttributes=e=>(0,o.createAttributeWithCacheKey)(e),t.elu=(e,t)=>{e.compute(a(e.inputs[0],"Elu",(e=>`elu_vf32(${e})`),`\n  const elu_alpha_: f32 = f32(${t.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},t.erf=e=>{e.compute(a(e.inputs[0],"Erf",(e=>`erf_vf32(${e})`),"\n  const r0: f32 = 0.3275911;\n  const r1: f32 = 0.254829592;\n  const r2: f32 = -0.284496736;\n  const r3: f32 = 1.421413741;\n  const r4: f32 = -1.453152027;\n  const r5: f32 = 1.061405429;\n\n  fn erf_vf32(v: vec4<f32>) -> vec4<f32> {\n    let absv = abs(v);\n    let x = 1.0 / (1.0 + r0 * absv);\n    return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n  }"))},t.exp=e=>{e.compute(a(e.inputs[0],"Exp","exp"))},t.floor=e=>{e.compute(a(e.inputs[0],"Floor","floor"))},t.leakyRelu=(e,t)=>{e.compute(a(e.inputs[0],"LeakyRelu",(e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<f32>(0.0))`),`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},t.neg=e=>{e.compute(a(e.inputs[0],"Neg",(e=>`-${e}`)))},t.reciprocal=e=>{e.compute(a(e.inputs[0],"Reciprocal",(e=>`1.0/${e}`)))},t.relu=e=>{e.compute(a(e.inputs[0],"Relu",(e=>`select(vec4<f32>(0.0), ${e}, ${e} > vec4<f32>(0.0))`)))},t.sigmoid=e=>{e.compute(a(e.inputs[0],"Sigmoid",(e=>`(1.0 / (1.0 + exp(-${e})))`)))},t.sin=e=>{e.compute(a(e.inputs[0],"Sin","sin"))},t.sinh=e=>{e.compute(a(e.inputs[0],"Sinh","sinh"))},t.sqrt=e=>{e.compute(a(e.inputs[0],"Sqrt","sqrt"))},t.tan=e=>{e.compute(a(e.inputs[0],"Tan","tan"))},t.tanh=e=>{e.compute(a(e.inputs[0],"Tanh","tanh"))},t.thresholdedRelu=(e,t)=>(e.compute(a(e.inputs[0],"ThresholdedRelu",(e=>`select(vec4<f32>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`),`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0)},8305:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ProgramManager=void 0;const r=n(4955),o=n(2075);t.ProgramManager=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,r){const o=this.backend.device,i=this.backend.getComputePassEncoder();this.backend.profilingEnabled&&i.writeTimestamp(this.backend.profilingQuerySet,0),i.setPipeline(e.computePipeline);const a=[];for(const e of t)a.push({binding:a.length,resource:{buffer:e.buffer}});for(const e of n)a.push({binding:a.length,resource:{buffer:e.buffer}});const s=o.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:a});if(i.setBindGroup(0,s),i.dispatchWorkgroups(...r),this.backend.pendingDispatchNumber++,this.backend.profilingEnabled){i.writeTimestamp(this.backend.profilingQuerySet,1);const e=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),t=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,e.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(e.buffer,0,t.buffer,0,16),this.backend.flush();const n=this.backend.currentKernelId,r=this.backend.kernels.get(n)[0];t.buffer.mapAsync(GPUMapMode.READ).then((()=>{const o=new BigUint64Array(t.buffer.getMappedRange()),i=o[0],a=o[1];t.buffer.unmap(),void 0===this.backend.profilingTimeBase&&(this.backend.profilingTimeBase=i);const s=Number(i-this.backend.profilingTimeBase),u=Number(a-this.backend.profilingTimeBase);if(!Number.isSafeInteger(s)||!Number.isSafeInteger(u))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(e.id),this.backend.gpuDataManager.release(t.id),console.log(`[profiling] kernel "${n}|${r}" execution time: ${u-s} ns`)}))}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(e,t){const n=this.backend.device,i=e.getShaderSource((0,o.createShaderHelper)(t)),a=n.createShaderModule({code:i});return(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] shader code: ${i}`)),{programInfo:e,computePipeline:n.createComputePipeline({compute:{module:a,entryPoint:"main"},layout:"auto"})}}normalizeDispatchGroupSize(e){const t="number"==typeof e?e:e.x,n="number"==typeof e?1:e.y||1,r="number"==typeof e?1:e.z||1,o=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=o&&n<=o&&r<=o)return[t,n,r];const i=t*n*r;let a=Math.ceil(Math.sqrt(i));if(a>o){if(a=Math.ceil(Math.cbrt(i)),a>o)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[a,a,a]}return[a,a,1]}}},1163:(e,t)=>{"use strict";var n;Object.defineProperty(t,"__esModule",{value:!0}),t.GpuDataType=void 0,(n=t.GpuDataType||(t.GpuDataType={}))[n.default=0]="default",n[n.upload=1]="upload",n[n.profile=2]="profile"},3899:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.iterateExtraOptions=void 0,t.iterateExtraOptions=(e,n,r,o)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,i])=>{const a=n?n+e:e;if("object"==typeof i)(0,t.iterateExtraOptions)(i,a+".",r,o);else if("string"==typeof i||"number"==typeof i)o(a,i.toString());else{if("boolean"!=typeof i)throw new Error("Can't handle extra config type: "+typeof i);o(a,i?"1":"0")}}))}},9544:function(e,t,n){"use strict";var r,o=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var o=Object.getOwnPropertyDescriptor(t,n);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,o)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),i=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&o(t,e,n);return i(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=t.initWasm=void 0;const s=n(8453),u=n(7675),l=a(n(1259)),c=n(263),p=()=>!!s.env.wasm.proxy&&"undefined"!=typeof document;let d,f,h,g=!1,m=!1,b=!1;const y=[],w=[],_=[],v=[],x=[],T=[],S=()=>{if(g||!m||b||!d)throw new Error("worker not ready")},O=e=>{switch(e.data.type){case"init-wasm":g=!1,e.data.err?(b=!0,f[1](e.data.err)):(m=!0,f[0]());break;case"init-ort":e.data.err?h[1](e.data.err):h[0]();break;case"create_allocate":e.data.err?y.shift()[1](e.data.err):y.shift()[0](e.data.out);break;case"create_finalize":e.data.err?w.shift()[1](e.data.err):w.shift()[0](e.data.out);break;case"create":e.data.err?_.shift()[1](e.data.err):_.shift()[0](e.data.out);break;case"release":e.data.err?v.shift()[1](e.data.err):v.shift()[0]();break;case"run":e.data.err?x.shift()[1](e.data.err):x.shift()[0](e.data.out);break;case"end-profiling":e.data.err?T.shift()[1](e.data.err):T.shift()[0]()}},A="undefined"!=typeof document?null===(r=null===document||void 0===document?void 0:document.currentScript)||void 0===r?void 0:r.src:void 0;t.initWasm=async()=>{if(p()){if(m)return;if(g)throw new Error("multiple calls to 'initWasm()' detected.");if(b)throw new Error("previous call to 'initWasm()' failed.");return g=!0,void 0===s.env.wasm.wasmPaths&&A&&0!==A.indexOf("blob:")&&(s.env.wasm.wasmPaths=A.substr(0,+A.lastIndexOf("/")+1)),new Promise(((e,t)=>{null==d||d.terminate(),d=n(8050).Z(),d.onmessage=O,f=[e,t];const r={type:"init-wasm",in:s.env.wasm};d.postMessage(r)}))}return(0,c.initializeWebAssembly)(s.env.wasm)},t.initOrt=async(e,t)=>{if(p())return S(),new Promise(((n,r)=>{h=[n,r];const o={type:"init-ort",in:{numThreads:e,loggingLevel:t}};d.postMessage(o)}));l.initOrt(e,t),await(0,u.init)((0,c.getInstance)())},t.createSessionAllocate=async e=>p()?(S(),new Promise(((t,n)=>{y.push([t,n]);const r={type:"create_allocate",in:{model:e}};d.postMessage(r,[e.buffer])}))):l.createSessionAllocate(e),t.createSessionFinalize=async(e,t)=>p()?(S(),new Promise(((n,r)=>{w.push([n,r]);const o={type:"create_finalize",in:{modeldata:e,options:t}};d.postMessage(o)}))):l.createSessionFinalize(e,t),t.createSession=async(e,t)=>p()?(S(),new Promise(((n,r)=>{_.push([n,r]);const o={type:"create",in:{model:e,options:t}};d.postMessage(o,[e.buffer])}))):l.createSession(e,t),t.releaseSession=async e=>{if(p())return S(),new Promise(((t,n)=>{v.push([t,n]);const r={type:"release",in:e};d.postMessage(r)}));l.releaseSession(e)},t.run=async(e,t,n,r,o)=>p()?(S(),new Promise(((i,a)=>{x.push([i,a]);const s={type:"run",in:{sessionId:e,inputIndices:t,inputs:n,outputIndices:r,options:o}};d.postMessage(s,l.extractTransferableBuffers(n))}))):l.run(e,t,n,r,o),t.endProfiling=async e=>{if(p())return S(),new Promise(((t,n)=>{T.push([t,n]);const r={type:"end-profiling",in:e};d.postMessage(r)}));l.endProfiling(e)}},7918:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=n(3899),o=n(9444),i=n(263);t.setRunOptions=e=>{const t=(0,i.getInstance)();let n=0;const a=[],s=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(s.terminate=!1);let i=0;if(void 0!==(null==e?void 0:e.tag)&&(i=(0,o.allocWasmString)(e.tag,a)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,i),0===n)throw new Error("Can't create run options");return void 0!==(null==e?void 0:e.extra)&&(0,r.iterateExtraOptions)(e.extra,"",new WeakSet,((e,r)=>{const i=(0,o.allocWasmString)(e,a),s=(0,o.allocWasmString)(r,a);if(0!==t._OrtAddRunConfigEntry(n,i,s))throw new Error(`Can't set a run config entry: ${e} - ${r}`)})),[n,a]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),a.forEach(t._free),e}}},6640:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.OnnxruntimeWebAssemblySessionHandler=void 0;const r=n(2806),o=n(8453),i=n(2850),a=n(9544),s=n(7917);let u;t.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(e){const t=await fetch(e),n=await t.arrayBuffer();return(0,a.createSessionAllocate)(new Uint8Array(n))}async loadModel(e,t){if(u||(await(0,a.initOrt)(o.env.wasm.numThreads,(0,s.logLevelStringToEnum)(o.env.logLevel)),u=!0),"string"==typeof e)if("undefined"==typeof fetch){const n=await(0,i.promisify)(r.readFile)(e);[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSession)(n,t)}else{const n=await this.createSessionAllocate(e);[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSessionFinalize)(n,t)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSession)(e,t)}async dispose(){return(0,a.releaseSession)(this.sessionId)}async run(e,t,n){const r=[],i=[];Object.entries(e).forEach((e=>{const t=e[0],n=e[1],o=this.inputNames.indexOf(t);if(-1===o)throw new Error(`invalid input '${t}'`);r.push(n),i.push(o)}));const s=[];Object.entries(t).forEach((e=>{const t=e[0],n=this.outputNames.indexOf(t);if(-1===n)throw new Error(`invalid output '${t}'`);s.push(n)}));const u=await(0,a.run)(this.sessionId,i,r.map((e=>[e.type,e.dims,e.data])),s,n),l={};for(let e=0;e<u.length;e++)l[this.outputNames[s[e]]]=new o.Tensor(u[e][0],u[e][2],u[e][1]);return l}startProfiling(){}endProfiling(){(0,a.endProfiling)(this.sessionId)}}},7622:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=n(3899),o=n(9444),i=n(263);t.setSessionOptions=e=>{var t,n,a,s;const u=(0,i.getInstance)();let l=0;const c=[],p=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(p);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=p.graphOptimizationLevel)&&void 0!==t?t:"all"),d=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(n=p.executionMode)&&void 0!==n?n:"sequential"),f="string"==typeof p.logId?(0,o.allocWasmString)(p.logId,c):0,h=null!==(a=p.logSeverityLevel)&&void 0!==a?a:2;if(!Number.isInteger(h)||h<0||h>4)throw new Error(`log serverity level is not valid: ${h}`);const g=null!==(s=p.logVerbosityLevel)&&void 0!==s?s:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const m="string"==typeof p.optimizedModelFilePath?(0,o.allocWasmString)(p.optimizedModelFilePath,c):0;if(l=u._OrtCreateSessionOptions(e,!!p.enableCpuMemArena,!!p.enableMemPattern,d,!!p.enableProfiling,0,f,h,g,m),0===l)throw new Error("Can't create session options");return p.executionProviders&&((e,t,n)=>{for(const r of t){let t="string"==typeof r?r:r.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${t}`)}const a=(0,o.allocWasmString)(t,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(e,a))throw new Error(`Can't append execution provider: ${t}`)}})(l,p.executionProviders,c),void 0!==p.extra&&(0,r.iterateExtraOptions)(p.extra,"",new WeakSet,((e,t)=>{const n=(0,o.allocWasmString)(e,c),r=(0,o.allocWasmString)(t,c);if(0!==u._OrtAddSessionConfigEntry(l,n,r))throw new Error(`Can't set a session config entry: ${e} - ${t}`)})),[l,c]}catch(e){throw 0!==l&&u._OrtReleaseSessionOptions(l),c.forEach(u._free),e}}},9444:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allocWasmString=void 0;const r=n(263);t.allocWasmString=(e,t)=>{const n=(0,r.getInstance)(),o=n.lengthBytesUTF8(e)+1,i=n._malloc(o);return n.stringToUTF8(e,i,o),t.push(i),i}},7917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},1259:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=void 0;const r=n(7918),o=n(7622),i=n(9444),a=n(7917),s=n(263);t.initOrt=(e,t)=>{const n=(0,s.getInstance)()._OrtInit(e,t);if(0!==n)throw new Error(`Can't initialize onnxruntime. error code = ${n}`)};const u=new Map;t.createSessionAllocate=e=>{const t=(0,s.getInstance)(),n=t._malloc(e.byteLength);return t.HEAPU8.set(e,n),[n,e.byteLength]},t.createSessionFinalize=(e,t)=>{const n=(0,s.getInstance)();let r=0,i=0,a=[];try{if([i,a]=(0,o.setSessionOptions)(t),r=n._OrtCreateSession(e[0],e[1],i),0===r)throw new Error("Can't create a session")}finally{n._free(e[0]),0!==i&&n._OrtReleaseSessionOptions(i),a.forEach(n._free)}const l=n._OrtGetInputCount(r),c=n._OrtGetOutputCount(r),p=[],d=[],f=[],h=[];for(let e=0;e<l;e++){const t=n._OrtGetInputName(r,e);if(0===t)throw new Error("Can't get an input name");d.push(t),p.push(n.UTF8ToString(t))}for(let e=0;e<c;e++){const t=n._OrtGetOutputName(r,e);if(0===t)throw new Error("Can't get an output name");h.push(t),f.push(n.UTF8ToString(t))}return u.set(r,[r,d,h]),[r,p,f]},t.createSession=(e,n)=>{const r=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(r,n)},t.releaseSession=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],o=n[1],i=n[2];o.forEach(t._OrtFree),i.forEach(t._OrtFree),t._OrtReleaseSession(r),u.delete(e)},t.run=async(e,t,n,o,l)=>{const c=(0,s.getInstance)(),p=u.get(e);if(!p)throw new Error("invalid session id");const d=p[0],f=p[1],h=p[2],g=t.length,m=o.length;let b=0,y=[];const w=[],_=[];try{[b,y]=(0,r.setRunOptions)(l);for(let e=0;e<g;e++){const t=n[e][0],r=n[e][1],o=n[e][2];let s,u;if(Array.isArray(o)){u=4*o.length,s=c._malloc(u),_.push(s);let e=s/4;for(let t=0;t<o.length;t++){if("string"!=typeof o[t])throw new TypeError(`tensor data at index ${t} is not a string`);c.HEAPU32[e++]=(0,i.allocWasmString)(o[t],_)}}else u=o.byteLength,s=c._malloc(u),_.push(s),c.HEAPU8.set(new Uint8Array(o.buffer,o.byteOffset,u),s);const l=c.stackSave(),p=c.stackAlloc(4*r.length);try{let e=p/4;r.forEach((t=>c.HEAP32[e++]=t));const n=c._OrtCreateTensor((0,a.tensorDataTypeStringToEnum)(t),s,u,p,r.length);if(0===n)throw new Error("Can't create a tensor");w.push(n)}finally{c.stackRestore(l)}}const e=c.stackSave(),s=c.stackAlloc(4*g),u=c.stackAlloc(4*g),p=c.stackAlloc(4*m),v=c.stackAlloc(4*m);try{let e=s/4,n=u/4,r=p/4,i=v/4;for(let r=0;r<g;r++)c.HEAPU32[e++]=w[r],c.HEAPU32[n++]=f[t[r]];for(let e=0;e<m;e++)c.HEAPU32[r++]=0,c.HEAPU32[i++]=h[o[e]];let l=c._OrtRun(d,u,s,g,v,m,p,b);const y=c.jsepRunPromise;y&&void 0!==y.then&&(l=await y);const _=[];if(0===l)for(let e=0;e<m;e++){const t=c.HEAPU32[p/4+e],n=c.stackSave(),r=c.stackAlloc(16);let o,i=0;try{if(l=c._OrtGetTensorData(t,r,r+4,r+8,r+12),0!==l)throw new Error(`Can't access output tensor data. error code = ${l}`);let e=r/4;const n=c.HEAPU32[e++];i=c.HEAPU32[e++];const s=c.HEAPU32[e++],u=c.HEAPU32[e++],p=[];for(let e=0;e<u;e++)p.push(c.HEAPU32[s/4+e]);c._OrtFree(s);const d=0===p.length?1:p.reduce(((e,t)=>e*t));if(o=(0,a.tensorDataTypeEnumToString)(n),"string"===o){const e=[];let t=i/4;for(let n=0;n<d;n++){const r=c.HEAPU32[t++],o=n===d-1?void 0:c.HEAPU32[t]-r;e.push(c.UTF8ToString(r,o))}_.push([o,p,e])}else{const e=new((0,a.tensorTypeToTypedArrayConstructor)(o))(d);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(c.HEAPU8.subarray(i,i+e.byteLength)),_.push([o,p,e])}}finally{c.stackRestore(n),"string"===o&&i&&c._free(i),c._OrtReleaseTensor(t)}}if(0===l)return _;throw new Error(`failed to call OrtRun(). error code = ${l}.`)}finally{c.stackRestore(e)}}finally{w.forEach(c._OrtReleaseTensor),_.forEach(c._free),c._OrtReleaseRunOptions(b),y.forEach(c._free)}},t.endProfiling=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],o=t._OrtEndProfiling(r);if(0===o)throw new Error("Can't get an profile file name");t._OrtFree(o)},t.extractTransferableBuffers=e=>{const t=[];for(const n of e){const e=n[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var o=Object.getOwnPropertyDescriptor(t,n);o&&!("get"in o?!t.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,o)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return o(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const a=i(n(6449)),s=n(932),u=n(3474);let l,c=!1,p=!1,d=!1;t.initializeWebAssembly=async e=>{if(c)return Promise.resolve();if(p)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(d)throw new Error("previous call to 'initializeWebAssembly()' failed.");p=!0;const t=e.initTimeout,r=e.numThreads,o=e.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),f=o&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),h=e.wasmPaths,g="string"==typeof h?h:void 0,m=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(f,i),b="object"==typeof h?h[m]:void 0;let y=!1;const w=[];if(t>0&&w.push(new Promise((e=>{setTimeout((()=>{y=!0,e()}),t)}))),w.push(new Promise(((e,t)=>{const r=i?u:s,o={locateFile:(e,t)=>i&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(4154)],{type:"text/javascript"})):e.endsWith(".wasm")?b||(null!=g?g:t)+m:t+e};if(i)if("undefined"==typeof Blob)o.mainScriptUrlOrBlob=a.join("/","ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;o.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}r(o).then((t=>{p=!1,c=!0,l=t,e()}),(e=>{p=!1,d=!0,t(e)}))}))),await Promise.race(w),y)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(c&&l)return l;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!c||p||d||(p=!0,null===(e=l.PThread)||void 0===e||e.terminateAllThreads(),l=void 0,p=!1,c=!1,d=!0)}},8050:(e,t,n)=>{"use strict";n.d(t,{Z:()=>i});var r=n(6614),o=n.n(r);function i(){return o()('/*!\n* ONNX Runtime Web v1.15.1\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={899:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.iterateExtraOptions=void 0,t.iterateExtraOptions=(e,n,r,a)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,o])=>{const i=n?n+e:e;if("object"==typeof o)(0,t.iterateExtraOptions)(o,i+".",r,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can\'t handle extra config type: "+typeof o);a(i,o?"1":"0")}}))}},918:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setRunOptions=e=>{const t=(0,o.getInstance)();let n=0;const i=[],s=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(s.terminate=!1);let o=0;if(void 0!==(null==e?void 0:e.tag)&&(o=(0,a.allocWasmString)(e.tag,i)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,o),0===n)throw new Error("Can\'t create run options");return void 0!==(null==e?void 0:e.extra)&&(0,r.iterateExtraOptions)(e.extra,"",new WeakSet,((e,r)=>{const o=(0,a.allocWasmString)(e,i),s=(0,a.allocWasmString)(r,i);if(0!==t._OrtAddRunConfigEntry(n,o,s))throw new Error(`Can\'t set a run config entry: ${e} - ${r}`)})),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),i.forEach(t._free),e}}},622:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setSessionOptions=e=>{var t,n,i,s;const u=(0,o.getInstance)();let c=0;const l=[],f=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(f);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=f.graphOptimizationLevel)&&void 0!==t?t:"all"),p=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(n=f.executionMode)&&void 0!==n?n:"sequential"),d="string"==typeof f.logId?(0,a.allocWasmString)(f.logId,l):0,m=null!==(i=f.logSeverityLevel)&&void 0!==i?i:2;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log serverity level is not valid: ${m}`);const g=null!==(s=f.logVerbosityLevel)&&void 0!==s?s:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h="string"==typeof f.optimizedModelFilePath?(0,a.allocWasmString)(f.optimizedModelFilePath,l):0;if(c=u._OrtCreateSessionOptions(e,!!f.enableCpuMemArena,!!f.enableMemPattern,p,!!f.enableProfiling,0,d,m,g,h),0===c)throw new Error("Can\'t create session options");return f.executionProviders&&((e,t,n)=>{for(const r of t){let t="string"==typeof r?r:r.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${t}`)}const i=(0,a.allocWasmString)(t,n);if(0!==(0,o.getInstance)()._OrtAppendExecutionProvider(e,i))throw new Error(`Can\'t append execution provider: ${t}`)}})(c,f.executionProviders,l),void 0!==f.extra&&(0,r.iterateExtraOptions)(f.extra,"",new WeakSet,((e,t)=>{const n=(0,a.allocWasmString)(e,l),r=(0,a.allocWasmString)(t,l);if(0!==u._OrtAddSessionConfigEntry(c,n,r))throw new Error(`Can\'t set a session config entry: ${e} - ${t}`)})),[c,l]}catch(e){throw 0!==c&&u._OrtReleaseSessionOptions(c),l.forEach(u._free),e}}},444:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allocWasmString=void 0;const r=n(263);t.allocWasmString=(e,t)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(e)+1,o=n._malloc(a);return n.stringToUTF8(e,o,a),t.push(o),o}},917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=void 0;const r=n(918),a=n(622),o=n(444),i=n(917),s=n(263);t.initOrt=(e,t)=>{const n=(0,s.getInstance)()._OrtInit(e,t);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;t.createSessionAllocate=e=>{const t=(0,s.getInstance)(),n=t._malloc(e.byteLength);return t.HEAPU8.set(e,n),[n,e.byteLength]},t.createSessionFinalize=(e,t)=>{const n=(0,s.getInstance)();let r=0,o=0,i=[];try{if([o,i]=(0,a.setSessionOptions)(t),r=n._OrtCreateSession(e[0],e[1],o),0===r)throw new Error("Can\'t create a session")}finally{n._free(e[0]),0!==o&&n._OrtReleaseSessionOptions(o),i.forEach(n._free)}const c=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],d=[],m=[];for(let e=0;e<c;e++){const t=n._OrtGetInputName(r,e);if(0===t)throw new Error("Can\'t get an input name");p.push(t),f.push(n.UTF8ToString(t))}for(let e=0;e<l;e++){const t=n._OrtGetOutputName(r,e);if(0===t)throw new Error("Can\'t get an output name");m.push(t),d.push(n.UTF8ToString(t))}return u.set(r,[r,p,m]),[r,f,d]},t.createSession=(e,n)=>{const r=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(r,n)},t.releaseSession=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],o=n[2];a.forEach(t._OrtFree),o.forEach(t._OrtFree),t._OrtReleaseSession(r),u.delete(e)},t.run=async(e,t,n,a,c)=>{const l=(0,s.getInstance)(),f=u.get(e);if(!f)throw new Error("invalid session id");const p=f[0],d=f[1],m=f[2],g=t.length,h=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,r.setRunOptions)(c);for(let e=0;e<g;e++){const t=n[e][0],r=n[e][1],a=n[e][2];let s,u;if(Array.isArray(a)){u=4*a.length,s=l._malloc(u),w.push(s);let e=s/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,o.allocWasmString)(a[t],w)}}else u=a.byteLength,s=l._malloc(u),w.push(s),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),s);const c=l.stackSave(),f=l.stackAlloc(4*r.length);try{let e=f/4;r.forEach((t=>l.HEAP32[e++]=t));const n=l._OrtCreateTensor((0,i.tensorDataTypeStringToEnum)(t),s,u,f,r.length);if(0===n)throw new Error("Can\'t create a tensor");b.push(n)}finally{l.stackRestore(c)}}const e=l.stackSave(),s=l.stackAlloc(4*g),u=l.stackAlloc(4*g),f=l.stackAlloc(4*h),_=l.stackAlloc(4*h);try{let e=s/4,n=u/4,r=f/4,o=_/4;for(let r=0;r<g;r++)l.HEAPU32[e++]=b[r],l.HEAPU32[n++]=d[t[r]];for(let e=0;e<h;e++)l.HEAPU32[r++]=0,l.HEAPU32[o++]=m[a[e]];let c=l._OrtRun(p,u,s,g,_,h,f,y);const v=l.jsepRunPromise;v&&void 0!==v.then&&(c=await v);const w=[];if(0===c)for(let e=0;e<h;e++){const t=l.HEAPU32[f/4+e],n=l.stackSave(),r=l.stackAlloc(16);let a,o=0;try{if(c=l._OrtGetTensorData(t,r,r+4,r+8,r+12),0!==c)throw new Error(`Can\'t access output tensor data. error code = ${c}`);let e=r/4;const n=l.HEAPU32[e++];o=l.HEAPU32[e++];const s=l.HEAPU32[e++],u=l.HEAPU32[e++],f=[];for(let e=0;e<u;e++)f.push(l.HEAPU32[s/4+e]);l._OrtFree(s);const p=0===f.length?1:f.reduce(((e,t)=>e*t));if(a=(0,i.tensorDataTypeEnumToString)(n),"string"===a){const e=[];let t=o/4;for(let n=0;n<p;n++){const r=l.HEAPU32[t++],a=n===p-1?void 0:l.HEAPU32[t]-r;e.push(l.UTF8ToString(r,a))}w.push([a,f,e])}else{const e=new((0,i.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(o,o+e.byteLength)),w.push([a,f,e])}}finally{l.stackRestore(n),"string"===a&&o&&l._free(o),l._OrtReleaseTensor(t)}}if(0===c)return w;throw new Error(`failed to call OrtRun(). error code = ${c}.`)}finally{l.stackRestore(e)}}finally{b.forEach(l._OrtReleaseTensor),w.forEach(l._free),l._OrtReleaseRunOptions(y),v.forEach(l._free)}},t.endProfiling=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=t._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const n of e){const e=n[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const i=o(n(449)),s=n(932),u=n(474);let c,l=!1,f=!1,p=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(p)throw new Error("previous call to \'initializeWebAssembly()\' failed.");f=!0;const t=e.initTimeout,r=e.numThreads,a=e.simd,o=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),d=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),m=e.wasmPaths,g="string"==typeof m?m:void 0,h=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(d,o),y="object"==typeof m?m[h]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const r=o?u:s,a={locateFile:(e,t)=>o&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):e.endsWith(".wasm")?y||(null!=g?g:t)+h:t+e};if(o)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=i.join("/","ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}r(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,p=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!l||f||p||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,p=!0)}},474:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){function t(){return P.buffer!=D&&G(P.buffer),F}function r(){return P.buffer!=D&&G(P.buffer),U}function a(){return P.buffer!=D&&G(P.buffer),I}function o(){return P.buffer!=D&&G(P.buffer),W}function i(){return P.buffer!=D&&G(P.buffer),j}var s,u,c;e=e||{},s||(s=void 0!==e?e:{}),s.ready=new Promise((function(e,t){u=e,c=t}));var l,f,p,d,m,g,h=Object.assign({},s),y="./this.program",v=(e,t)=>{throw t},b="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=s.ENVIRONMENT_IS_PTHREAD||!1,S="";function T(e){return s.locateFile?s.locateFile(e,S):S+e}if(_){let t;S=w?n(908).dirname(S)+"/":"//",g=()=>{m||(d=n(384),m=n(908))},l=function(e,t){return g(),e=m.normalize(e),d.readFileSync(e,t?void 0:"utf8")},p=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,n)=>{g(),e=m.normalize(e),d.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(y=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof ie))throw e})),process.on("unhandledRejection",(function(e){throw e})),v=(e,t)=>{if(C)throw process.exitCode=e,t;t instanceof ie||x("exiting due to exception: "+t),process.exit(e)},s.inspect=function(){return"[Emscripten Module object]"};try{t=n(925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}n.g.Worker=t.Worker}else(b||w)&&(w?S=self.location.href:"undefined"!=typeof document&&document.currentScript&&(S=document.currentScript.src),_scriptDir&&(S=_scriptDir),S=0!==S.indexOf("blob:")?S.substr(0,S.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},w&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var A=console.log.bind(console),E=console.warn.bind(console);_&&(g(),A=e=>d.writeSync(1,e+"\\n"),E=e=>d.writeSync(2,e+"\\n"));var M,R=s.print||A,x=s.printErr||E;Object.assign(s,h),h=null,s.thisProgram&&(y=s.thisProgram),s.quit&&(v=s.quit),s.wasmBinary&&(M=s.wasmBinary);var C=s.noExitRuntime||!0;"object"!=typeof WebAssembly&&ne("no native wasm support detected");var P,k,D,F,U,I,W,j,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function Y(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&L)return L.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function z(e,t){return(e>>>=0)?Y(r(),e,t):""}function B(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function N(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function G(e){D=e,s.HEAP8=F=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=I=new Int32Array(e),s.HEAPU8=U=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=W=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=j=new Float64Array(e)}O&&(D=s.buffer);var q=s.INITIAL_MEMORY||16777216;if(O)P=s.wasmMemory,D=s.buffer;else if(s.wasmMemory)P=s.wasmMemory;else if(!((P=new WebAssembly.Memory({initial:q/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");P&&(D=P.buffer),q=D.byteLength,G(D);var $,V=[],J=[],Q=[];function X(){var e=s.preRun.shift();V.unshift(e)}var K,Z=0,ee=null,te=null;function ne(e){throw O?postMessage({cmd:"onAbort",arg:e}):s.onAbort&&s.onAbort(e),x(e="Aborted("+e+")"),H=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),c(e),e}function re(){return K.startsWith("data:application/octet-stream;base64,")}function ae(){var e=K;try{if(e==K&&M)return new Uint8Array(M);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}catch(e){ne(e)}}K="ort-wasm-threaded.wasm",re()||(K=T(K));var oe={};function ie(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function se(e){(e=fe.La[e])||ne(),fe.Xa(e)}function ue(e){var t=fe.lb();if(!t)return 6;fe.Ra.push(t),fe.La[e.Ka]=t,t.Ka=e.Ka;var n={cmd:"run",start_routine:e.pb,arg:e.ib,pthread_ptr:e.Ka};return t.Qa=()=>{n.time=performance.now(),t.postMessage(n,e.vb)},t.loaded&&(t.Qa(),delete t.Qa),0}function ce(e){if(O)return He(1,1,e);C||(fe.qb(),s.onExit&&s.onExit(e),H=!0),v(e,new ie(e))}function le(e,t){if(!t&&O)throw de(e),"unwind";ce(e)}var fe={Oa:[],Ra:[],$a:[],La:{},Ua:function(){O&&fe.mb()},xb:function(){},mb:function(){fe.receiveObjectTransfer=fe.ob,fe.threadInitTLS=fe.Za,fe.setExitStatus=fe.Ya,C=!1},Ya:function(){},qb:function(){for(var e of Object.values(fe.La))fe.Xa(e);for(e of fe.Oa)e.terminate();fe.Oa=[]},Xa:function(e){var t=e.Ka;delete fe.La[t],fe.Oa.push(e),fe.Ra.splice(fe.Ra.indexOf(e),1),e.Ka=0,ct(t)},ob:function(){},Za:function(){fe.$a.forEach((e=>e()))},nb:function(e,t){e.onmessage=n=>{var r=(n=n.data).cmd;if(e.Ka&&(fe.kb=e.Ka),n.targetThread&&n.targetThread!=rt()){var a=fe.La[n.yb];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?De(n.queue):"spawnThread"===r?ue(n):"cleanupThread"===r?se(n.thread):"killThread"===r?(n=n.thread,r=fe.La[n],delete fe.La[n],r.terminate(),ct(n),fe.Ra.splice(fe.Ra.indexOf(r),1),r.Ka=0):"cancelThread"===r?fe.La[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t&&t(e),e.Qa&&(e.Qa(),delete e.Qa)):"print"===r?R("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"onAbort"===r?s.onAbort&&s.onAbort(n.arg):r&&x("worker sent an unknown command "+r);fe.kb=void 0},e.onerror=e=>{throw x("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},_&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){}))),e.postMessage({cmd:"load",urlOrBlob:s.mainScriptUrlOrBlob||_scriptDir,wasmMemory:P,wasmModule:k})},hb:function(){var e=T("ort-wasm-threaded.worker.js");fe.Oa.push(new Worker(e))},lb:function(){return 0==fe.Oa.length&&(fe.hb(),fe.nb(fe.Oa[0])),fe.Oa.pop()}};function pe(e){for(;0<e.length;)e.shift()(s)}function de(e){if(O)return He(2,0,e);try{le(e)}catch(e){e instanceof ie||"unwind"==e||v(1,e)}}s.PThread=fe,s.establishStackSpace=function(){var e=rt(),t=a()[e+44>>2>>>0];e=a()[e+48>>2>>>0],ft(t,t-e),dt(t)};var me,ge,he=[];function ye(e){this.Pa=e-24,this.gb=function(e){o()[this.Pa+4>>2>>>0]=e},this.cb=function(e){o()[this.Pa+8>>2>>>0]=e},this.eb=function(){a()[this.Pa>>2>>>0]=0},this.bb=function(){t()[this.Pa+12>>0>>>0]=0},this.fb=function(){t()[this.Pa+13>>0>>>0]=0},this.Ua=function(e,t){this.ab(),this.gb(e),this.cb(t),this.eb(),this.bb(),this.fb()},this.ab=function(){o()[this.Pa+16>>2>>>0]=0}}function ve(e,t,n,r){return O?He(3,1,e,t,n,r):be(e,t,n,r)}function be(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?ve(e,t,n,r):(e={pb:n,Ka:e,ib:r,vb:a},O?(e.wb="spawnThread",postMessage(e,a),0):ue(e))}function we(e,t,n){return O?He(4,1,e,t,n):0}function _e(e,t){if(O)return He(5,1,e,t)}function Oe(e,t){if(O)return He(6,1,e,t)}function Se(e,t,n){if(O)return He(7,1,e,t,n)}function Te(e,t,n){return O?He(8,1,e,t,n):0}function Ae(e,t){if(O)return He(9,1,e,t)}function Ee(e,t,n){if(O)return He(10,1,e,t,n)}function Me(e,t,n,r){if(O)return He(11,1,e,t,n,r)}function Re(e,t,n,r){if(O)return He(12,1,e,t,n,r)}function xe(e,t,n,r){if(O)return He(13,1,e,t,n,r)}function Ce(e){if(O)return He(14,1,e)}function Pe(e,t){if(O)return He(15,1,e,t)}function ke(e,t,n){if(O)return He(16,1,e,t,n)}function De(e){Atomics.store(a(),e>>2,1),rt()&&ut(e),Atomics.compareExchange(a(),e>>2,1,0)}function Fe(e){return o()[e>>>2]+4294967296*a()[e+4>>>2]}function Ue(e,t,n,r,a,o){return O?He(17,1,e,t,n,r,a,o):-52}function Ie(e,t,n,r,a,o){if(O)return He(18,1,e,t,n,r,a,o)}function We(e){var n=N(e)+1,r=at(n);return r&&B(e,t(),r,n),r}function je(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}if(O)return He(19,1,e,t,n);var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(i,c);a()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(i!=c),e=r(s),t=r(u),e=We(e),t=We(t),c<i?(o()[n>>2>>>0]=e,o()[n+4>>2>>>0]=t):(o()[n>>2>>>0]=t,o()[n+4>>2>>>0]=e)}function He(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=pt();return e=e(),dt(t),e}((()=>{for(var a=mt(8*n),o=a>>3,s=0;s<n;s++){var u=r[2+s];i()[o+s>>>0]=u}return st(e,n,a,t)}))}s.invokeEntryPoint=function(e,t){var n=he[e];n||(e>=he.length&&(he.length=e+1),he[e]=n=$.get(e)),e=n(t),C?fe.Ya(e):lt(e)},s.executeNotifiedProxyingQueue=De,ge=_?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:O?()=>performance.now()-s.__performance_now_clock_drift:()=>performance.now();var Le,Ye=[],ze={};function Be(){if(!Le){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:y||"./this.program"};for(e in ze)void 0===ze[e]?delete t[e]:t[e]=ze[e];var n=[];for(e in t)n.push(e+"="+t[e]);Le=n}return Le}function Ne(e,n){if(O)return He(20,1,e,n);var r=0;return Be().forEach((function(a,i){var s=n+r;for(i=o()[e+4*i>>2>>>0]=s,s=0;s<a.length;++s)t()[i++>>0>>>0]=a.charCodeAt(s);t()[i>>0>>>0]=0,r+=a.length+1})),0}function Ge(e,t){if(O)return He(21,1,e,t);var n=Be();o()[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),o()[t>>2>>>0]=r,0}function qe(e){return O?He(22,1,e):52}function $e(e,t,n,r){return O?He(23,1,e,t,n,r):52}function Ve(e,t,n,r,a){return O?He(24,1,e,t,n,r,a):70}var Je=[null,[],[]];function Qe(e,t,n,a){if(O)return He(25,1,e,t,n,a);for(var i=0,s=0;s<n;s++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=r()[u+l>>>0],p=Je[e];0===f||10===f?((1===e?R:x)(Y(p,0)),p.length=0):p.push(f)}i+=c}return o()[a>>2>>>0]=i,0}function Xe(e){return 0==e%4&&(0!=e%100||0==e%400)}var Ke=[31,29,31,30,31,30,31,31,30,31,30,31],Ze=[31,28,31,30,31,30,31,31,30,31,30,31];function et(e,n,r,o){function i(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function s(e,t){return i(e,t,"0")}function u(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function c(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function l(e){var t=e.Ma;for(e=new Date(new Date(e.Na+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(Xe(e.getFullYear())?Ke:Ze)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=c(new Date(e.getFullYear(),0,4)),n=c(n),0>=u(t,e)?0>=u(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var f=a()[o+40>>2>>>0];for(var p in o={tb:a()[o>>2>>>0],sb:a()[o+4>>2>>>0],Sa:a()[o+8>>2>>>0],Va:a()[o+12>>2>>>0],Ta:a()[o+16>>2>>>0],Na:a()[o+20>>2>>>0],Ja:a()[o+24>>2>>>0],Ma:a()[o+28>>2>>>0],zb:a()[o+32>>2>>>0],rb:a()[o+36>>2>>>0],ub:f?z(f):""},r=z(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),m="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(e){return d[e.Ja].substring(0,3)},"%A":function(e){return d[e.Ja]},"%b":function(e){return m[e.Ta].substring(0,3)},"%B":function(e){return m[e.Ta]},"%C":function(e){return s((e.Na+1900)/100|0,2)},"%d":function(e){return s(e.Va,2)},"%e":function(e){return i(e.Va,2," ")},"%g":function(e){return l(e).toString().substring(2)},"%G":function(e){return l(e)},"%H":function(e){return s(e.Sa,2)},"%I":function(e){return 0==(e=e.Sa)?e=12:12<e&&(e-=12),s(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.Ta-1;t+=(Xe(e.Na+1900)?Ke:Ze)[n++]);return s(e.Va+t,3)},"%m":function(e){return s(e.Ta+1,2)},"%M":function(e){return s(e.sb,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.Sa&&12>e.Sa?"AM":"PM"},"%S":function(e){return s(e.tb,2)},"%t":function(){return"\\t"},"%u":function(e){return e.Ja||7},"%U":function(e){return s(Math.floor((e.Ma+7-e.Ja)/7),2)},"%V":function(e){var t=Math.floor((e.Ma+7-(e.Ja+6)%7)/7);if(2>=(e.Ja+371-e.Ma-2)%7&&t++,t)53==t&&(4==(n=(e.Ja+371-e.Ma)%7)||3==n&&Xe(e.Na)||(t=1));else{t=52;var n=(e.Ja+7-e.Ma-1)%7;(4==n||5==n&&Xe(e.Na%400-1))&&t++}return s(t,2)},"%w":function(e){return e.Ja},"%W":function(e){return s(Math.floor((e.Ma+7-(e.Ja+6)%7)/7),2)},"%y":function(e){return(e.Na+1900).toString().substring(2)},"%Y":function(e){return e.Na+1900},"%z":function(e){var t=0<=(e=e.rb);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.ub},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](o)));return p=function(e){var t=Array(N(e)+1);return B(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(e,n){t().set(e,n>>>0)}(p,e),p.length-1)}fe.Ua();var tt=[null,ce,de,ve,we,_e,Oe,Se,Te,Ae,Ee,Me,Re,xe,Ce,Pe,ke,Ue,Ie,je,Ne,Ge,qe,$e,Ve,Qe],nt={b:function(e){return at(e+24)+24},c:function(e,t,n){throw new ye(e).Ua(t,n),e},L:function(e){ot(e,!w,1,!b),fe.Za()},l:function(e){O?postMessage({cmd:"cleanupThread",thread:e}):se(e)},D:be,i:we,R:_e,z:Oe,B:Se,T:Te,P:Ae,I:Ee,O:Me,p:Re,A:xe,x:Ce,Q:Pe,y:ke,r:function(){},j:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},s:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},q:function(){return Date.now()},E:function(){return 2097152},V:function(){return!0},F:function(e,t,n,r){if(e==t)setTimeout((()=>De(r)));else if(O)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{if(!(e=fe.La[e]))return;e.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},K:function(){return-1},W:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getUTCSeconds(),a()[t+4>>2>>>0]=e.getUTCMinutes(),a()[t+8>>2>>>0]=e.getUTCHours(),a()[t+12>>2>>>0]=e.getUTCDate(),a()[t+16>>2>>>0]=e.getUTCMonth(),a()[t+20>>2>>>0]=e.getUTCFullYear()-1900,a()[t+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[t+28>>2>>>0]=e},X:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),a()[t+20>>2>>>0]=e.getFullYear()-1900,a()[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1),r=(e.getTime()-n.getTime())/864e5|0;a()[t+28>>2>>>0]=r,a()[t+36>>2>>>0]=-60*e.getTimezoneOffset(),r=new Date(e.getFullYear(),6,1).getTimezoneOffset(),e=0|(r!=(n=n.getTimezoneOffset())&&e.getTimezoneOffset()==Math.min(n,r)),a()[t+32>>2>>>0]=e},Y:function(e){var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),n=a()[e+32>>2>>>0],r=t.getTimezoneOffset(),o=new Date(t.getFullYear(),0,1),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),s=o.getTimezoneOffset(),u=Math.min(s,i);return 0>n?a()[e+32>>2>>>0]=Number(i!=s&&u==r):0<n!=(u==r)&&(i=Math.max(s,i),t.setTime(t.getTime()+6e4*((0<n?u:i)-r))),a()[e+24>>2>>>0]=t.getDay(),n=(t.getTime()-o.getTime())/864e5|0,a()[e+28>>2>>>0]=n,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},G:Ue,H:Ie,Z:function e(t,n,r){e.jb||(e.jb=!0,je(t,n,r))},d:function(){ne("")},m:function(){if(!_&&!w){var e="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";me||(me={}),me[e]||(me[e]=1,_&&(e="warning: "+e),x(e))}},w:function(){return 4294901760},f:ge,S:function(e,t,n){r().copyWithin(e>>>0,t>>>0,t+n>>>0)},g:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},J:function(e,t,n){Ye.length=t,n>>=3;for(var r=0;r<t;r++)Ye[r]=i()[n+r>>>0];return(0>e?oe[-e-1]:tt[e]).apply(null,Ye)},v:function(e){var t=r().length;if((e>>>=0)<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var a=t*(1+.2/n);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a),o=o.min.call(o,4294901760,a+(65536-a%65536)%65536);e:{try{P.grow(o-D.byteLength+65535>>>16),G(P.buffer);var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},U:function(){throw"unwind"},M:Ne,N:Ge,k:le,h:qe,o:$e,t:Ve,n:Qe,u:function e(r,a){e.Wa||(e.Wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(_)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>ne("randomDevice")}());for(var o=0;o<a;o++)t()[r+o>>0>>>0]=e.Wa();return 0},a:P||s.wasmMemory,C:et,e:function(e,t,n,r){return et(e,t,n,r)}};!function(){function e(e,t){s.asm=e.exports,fe.$a.push(s.asm.wa),$=s.asm.za,J.unshift(s.asm._),k=t,O||(Z--,s.monitorRunDependencies&&s.monitorRunDependencies(Z),0==Z&&(null!==ee&&(clearInterval(ee),ee=null),te&&(e=te,te=null,e())))}function t(t){e(t.instance,t.module)}function n(e){return function(){if(!M&&(b||w)){if("function"==typeof fetch&&!K.startsWith("file://"))return fetch(K,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+K+"\'";return e.arrayBuffer()})).catch((function(){return ae()}));if(f)return new Promise((function(e,t){f(K,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return ae()}))}().then((function(e){return WebAssembly.instantiate(e,r)})).then((function(e){return e})).then(e,(function(e){x("failed to asynchronously prepare wasm: "+e),ne(e)}))}var r={a:nt};if(O||(Z++,s.monitorRunDependencies&&s.monitorRunDependencies(Z)),s.instantiateWasm)try{return s.instantiateWasm(r,e)}catch(e){return x("Module.instantiateWasm callback failed with error: "+e),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||re()||K.startsWith("file://")||_||"function"!=typeof fetch?n(t):fetch(K,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,r).then(t,(function(e){return x("wasm streaming compile failed: "+e),x("falling back to ArrayBuffer instantiation"),n(t)}))}))).catch(c)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm._).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.$).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.aa).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.ba).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.ca).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm.da).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.ea).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.fa).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.ga).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.ha).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm.ia).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.ja).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.ka).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.la).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.ma).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.na).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.oa).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.pa).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.qa).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.ra).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.sa).apply(null,arguments)};var rt=s._pthread_self=function(){return(rt=s._pthread_self=s.asm.ta).apply(null,arguments)},at=s._malloc=function(){return(at=s._malloc=s.asm.ua).apply(null,arguments)};s._free=function(){return(s._free=s.asm.va).apply(null,arguments)},s.__emscripten_tls_init=function(){return(s.__emscripten_tls_init=s.asm.wa).apply(null,arguments)};var ot=s.__emscripten_thread_init=function(){return(ot=s.__emscripten_thread_init=s.asm.xa).apply(null,arguments)};s.__emscripten_thread_crashed=function(){return(s.__emscripten_thread_crashed=s.asm.ya).apply(null,arguments)};var it,st=s._emscripten_run_in_main_runtime_thread_js=function(){return(st=s._emscripten_run_in_main_runtime_thread_js=s.asm.Aa).apply(null,arguments)},ut=s.__emscripten_proxy_execute_task_queue=function(){return(ut=s.__emscripten_proxy_execute_task_queue=s.asm.Ba).apply(null,arguments)},ct=s.__emscripten_thread_free_data=function(){return(ct=s.__emscripten_thread_free_data=s.asm.Ca).apply(null,arguments)},lt=s.__emscripten_thread_exit=function(){return(lt=s.__emscripten_thread_exit=s.asm.Da).apply(null,arguments)},ft=s._emscripten_stack_set_limits=function(){return(ft=s._emscripten_stack_set_limits=s.asm.Ea).apply(null,arguments)},pt=s.stackSave=function(){return(pt=s.stackSave=s.asm.Fa).apply(null,arguments)},dt=s.stackRestore=function(){return(dt=s.stackRestore=s.asm.Ga).apply(null,arguments)},mt=s.stackAlloc=function(){return(mt=s.stackAlloc=s.asm.Ha).apply(null,arguments)};function gt(){function e(){if(!it&&(it=!0,s.calledRun=!0,!H)&&(O||pe(J),u(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!O)){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;){var e=s.postRun.shift();Q.unshift(e)}pe(Q)}}if(!(0<Z))if(O)u(s),O||pe(J),postMessage({cmd:"loaded"});else{if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)X();pe(V),0<Z||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),e()}),1)):e())}}if(s.___cxa_is_pointer_type=function(){return(s.___cxa_is_pointer_type=s.asm.Ia).apply(null,arguments)},s.UTF8ToString=z,s.stringToUTF8=function(e,t,n){return B(e,r(),t,n)},s.lengthBytesUTF8=N,s.keepRuntimeAlive=function(){return C},s.wasmMemory=P,s.stackSave=pt,s.stackRestore=dt,s.stackAlloc=mt,s.ExitStatus=ie,s.PThread=fe,te=function e(){it||gt(),it||(te=e)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return gt(),e.ready});e.exports=r},932:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){var t,r,a;e=e||{},t||(t=void 0!==e?e:{}),t.ready=new Promise((function(e,t){r=e,a=t}));var o,i,s,u,c,l,f=Object.assign({},t),p="./this.program",d=(e,t)=>{throw t},m="object"==typeof window,g="function"==typeof importScripts,h="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,y="";h?(y=g?n(908).dirname(y)+"/":"//",l=()=>{c||(u=n(384),c=n(908))},o=function(e,t){return l(),e=c.normalize(e),u.readFileSync(e,t?void 0:"utf8")},s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,n)=>{l(),e=c.normalize(e),u.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof $))throw e})),process.on("unhandledRejection",(function(e){throw e})),d=(e,t)=>{if(_)throw process.exitCode=e,t;t instanceof $||w("exiting due to exception: "+t),process.exit(e)},t.inspect=function(){return"[Emscripten Module object]"}):(m||g)&&(g?y=self.location.href:"undefined"!=typeof document&&document.currentScript&&(y=document.currentScript.src),_scriptDir&&(y=_scriptDir),y=0!==y.indexOf("blob:")?y.substr(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},g&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),i=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var v,b=t.print||console.log.bind(console),w=t.printErr||console.warn.bind(console);Object.assign(t,f),f=null,t.thisProgram&&(p=t.thisProgram),t.quit&&(d=t.quit),t.wasmBinary&&(v=t.wasmBinary);var _=t.noExitRuntime||!0;"object"!=typeof WebAssembly&&B("no native wasm support detected");var O,S,T,A,E,M,R=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function C(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&x)return x.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function P(e,t){return(e>>>=0)?C(A,e,t):""}function k(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function D(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function F(){var e=O.buffer;S=e,t.HEAP8=T=new Int8Array(e),t.HEAP16=new Int16Array(e),t.HEAP32=E=new Int32Array(e),t.HEAPU8=A=new Uint8Array(e),t.HEAPU16=new Uint16Array(e),t.HEAPU32=M=new Uint32Array(e),t.HEAPF32=new Float32Array(e),t.HEAPF64=new Float64Array(e)}var U=[],I=[],W=[];function j(){var e=t.preRun.shift();U.unshift(e)}var H,L=0,Y=null,z=null;function B(e){throw t.onAbort&&t.onAbort(e),w(e="Aborted("+e+")"),R=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),a(e),e}function N(){return H.startsWith("data:application/octet-stream;base64,")}if(H="ort-wasm.wasm",!N()){var G=H;H=t.locateFile?t.locateFile(G,y):y+G}function q(){var e=H;try{if(e==H&&v)return new Uint8Array(v);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}catch(e){B(e)}}function $(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function V(e){for(;0<e.length;)e.shift()(t)}function J(e){this.sa=e-24,this.Ia=function(e){M[this.sa+4>>2>>>0]=e},this.Ba=function(e){M[this.sa+8>>2>>>0]=e},this.Ga=function(){E[this.sa>>2>>>0]=0},this.Aa=function(){T[this.sa+12>>0>>>0]=0},this.Ha=function(){T[this.sa+13>>0>>>0]=0},this.ya=function(e,t){this.za(),this.Ia(e),this.Ba(t),this.Ga(),this.Aa(),this.Ha()},this.za=function(){M[this.sa+16>>2>>>0]=0}}function Q(e){var t=D(e)+1,n=ie(t);return n&&k(e,T,n,t),n}var X={};function K(){if(!Z){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(e in X)void 0===X[e]?delete t[e]:t[e]=X[e];var n=[];for(e in t)n.push(e+"="+t[e]);Z=n}return Z}var Z,ee=[null,[],[]];function te(e){return 0==e%4&&(0!=e%100||0==e%400)}var ne=[31,29,31,30,31,30,31,31,30,31,30,31],re=[31,28,31,30,31,30,31,31,30,31,30,31];function ae(e,t,n,r){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.qa;for(e=new Date(new Date(e.ra+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(te(e.getFullYear())?ne:re)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=i(t,e)?0>=i(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var c=E[r+40>>2>>>0];for(var l in r={Ea:E[r>>2>>>0],Da:E[r+4>>2>>>0],ta:E[r+8>>2>>>0],va:E[r+12>>2>>>0],ua:E[r+16>>2>>>0],ra:E[r+20>>2>>>0],la:E[r+24>>2>>>0],qa:E[r+28>>2>>>0],Ja:E[r+32>>2>>>0],Ca:E[r+36>>2>>>0],Fa:c?P(c):""},n=P(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),c[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in c={"%a":function(e){return f[e.la].substring(0,3)},"%A":function(e){return f[e.la]},"%b":function(e){return p[e.ua].substring(0,3)},"%B":function(e){return p[e.ua]},"%C":function(e){return o((e.ra+1900)/100|0,2)},"%d":function(e){return o(e.va,2)},"%e":function(e){return a(e.va,2," ")},"%g":function(e){return u(e).toString().substring(2)},"%G":function(e){return u(e)},"%H":function(e){return o(e.ta,2)},"%I":function(e){return 0==(e=e.ta)?e=12:12<e&&(e-=12),o(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.ua-1;t+=(te(e.ra+1900)?ne:re)[n++]);return o(e.va+t,3)},"%m":function(e){return o(e.ua+1,2)},"%M":function(e){return o(e.Da,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.ta&&12>e.ta?"AM":"PM"},"%S":function(e){return o(e.Ea,2)},"%t":function(){return"\\t"},"%u":function(e){return e.la||7},"%U":function(e){return o(Math.floor((e.qa+7-e.la)/7),2)},"%V":function(e){var t=Math.floor((e.qa+7-(e.la+6)%7)/7);if(2>=(e.la+371-e.qa-2)%7&&t++,t)53==t&&(4==(n=(e.la+371-e.qa)%7)||3==n&&te(e.ra)||(t=1));else{t=52;var n=(e.la+7-e.qa-1)%7;(4==n||5==n&&te(e.ra%400-1))&&t++}return o(t,2)},"%w":function(e){return e.la},"%W":function(e){return o(Math.floor((e.qa+7-(e.la+6)%7)/7),2)},"%y":function(e){return(e.ra+1900).toString().substring(2)},"%Y":function(e){return e.ra+1900},"%z":function(e){var t=0<=(e=e.Ca);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.Fa},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),c)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),c[l](r)));return l=function(e){var t=Array(D(e)+1);return k(e,t,0,t.length),t}(n=n.replace(/\\0\\0/g,"%")),l.length>t?0:(T.set(l,e>>>0),l.length-1)}var oe={a:function(e){return ie(e+24)+24},b:function(e,t,n){throw new J(e).ya(t,n),e},g:function(){return 0},I:function(){},w:function(){},y:function(){},K:function(){return 0},G:function(){},C:function(){},F:function(){},k:function(){},x:function(){},u:function(){},H:function(){},v:function(){},n:function(){},p:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},o:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},l:function(){return Date.now()},L:function(){return!0},M:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getUTCSeconds(),E[t+4>>2>>>0]=e.getUTCMinutes(),E[t+8>>2>>>0]=e.getUTCHours(),E[t+12>>2>>>0]=e.getUTCDate(),E[t+16>>2>>>0]=e.getUTCMonth(),E[t+20>>2>>>0]=e.getUTCFullYear()-1900,E[t+24>>2>>>0]=e.getUTCDay(),E[t+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},N:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),E[t+20>>2>>>0]=e.getFullYear()-1900,E[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1);E[t+28>>2>>>0]=(e.getTime()-n.getTime())/864e5|0,E[t+36>>2>>>0]=-60*e.getTimezoneOffset();var r=new Date(e.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[t+32>>2>>>0]=0|(r!=n&&e.getTimezoneOffset()==Math.min(n,r))},O:function(e){var t=new Date(E[e+20>>2>>>0]+1900,E[e+16>>2>>>0],E[e+12>>2>>>0],E[e+8>>2>>>0],E[e+4>>2>>>0],E[e>>2>>>0],0),n=E[e+32>>2>>>0],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),0,1),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=a.getTimezoneOffset(),s=Math.min(i,o);return 0>n?E[e+32>>2>>>0]=Number(o!=i&&s==r):0<n!=(s==r)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<n?s:o)-r))),E[e+24>>2>>>0]=t.getDay(),E[e+28>>2>>>0]=(t.getTime()-a.getTime())/864e5|0,E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},z:function(){return-52},B:function(){},m:function e(t,n,r){e.xa||(e.xa=!0,function(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();E[e>>2>>>0]=60*Math.max(a,s),E[t>>2>>>0]=Number(a!=s),e=r(o),t=r(i),e=Q(e),t=Q(t),s<a?(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t):(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e)}(t,n,r))},d:function(){B("")},t:function(){return 4294901760},h:h?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.now(),J:function(e,t,n){A.copyWithin(e>>>0,t>>>0,t+n>>>0)},f:function(e){var t=A.length;if(4294901760<(e>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math;r=Math.max(e,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);e:{try{O.grow(a-S.byteLength+65535>>>16),F();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){var n=0;return K().forEach((function(r,a){var o=t+n;for(a=M[e+4*a>>2>>>0]=o,o=0;o<r.length;++o)T[a++>>0>>>0]=r.charCodeAt(o);T[a>>0>>>0]=0,n+=r.length+1})),0},E:function(e,t){var n=K();M[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),M[t>>2>>>0]=r,0},r:function(e){_||(t.onExit&&t.onExit(e),R=!0),d(e,new $(e))},e:function(){return 52},j:function(){return 52},q:function(){return 70},i:function(e,t,n,r){for(var a=0,o=0;o<n;o++){var i=M[t>>2>>>0],s=M[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var c=A[i+u>>>0],l=ee[e];0===c||10===c?((1===e?b:w)(C(l,0)),l.length=0):l.push(c)}a+=s}return M[r>>2>>>0]=a,0},s:function e(t,r){e.wa||(e.wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(h)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>B("randomDevice")}());for(var a=0;a<r;a++)T[t+a>>0>>>0]=e.wa();return 0},A:ae,c:function(e,t,n,r){return ae(e,t,n,r)}};!function(){function e(e){t.asm=e.exports,O=t.asm.P,F(),I.unshift(t.asm.Q),L--,t.monitorRunDependencies&&t.monitorRunDependencies(L),0==L&&(null!==Y&&(clearInterval(Y),Y=null),z&&(e=z,z=null,e()))}function n(t){e(t.instance)}function r(e){return function(){if(!v&&(m||g)){if("function"==typeof fetch&&!H.startsWith("file://"))return fetch(H,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+H+"\'";return e.arrayBuffer()})).catch((function(){return q()}));if(i)return new Promise((function(e,t){i(H,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return q()}))}().then((function(e){return WebAssembly.instantiate(e,o)})).then((function(e){return e})).then(e,(function(e){w("failed to asynchronously prepare wasm: "+e),B(e)}))}var o={a:oe};if(L++,t.monitorRunDependencies&&t.monitorRunDependencies(L),t.instantiateWasm)try{return t.instantiateWasm(o,e)}catch(e){return w("Module.instantiateWasm callback failed with error: "+e),!1}(v||"function"!=typeof WebAssembly.instantiateStreaming||N()||H.startsWith("file://")||h||"function"!=typeof fetch?r(n):fetch(H,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,o).then(n,(function(e){return w("wasm streaming compile failed: "+e),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm.Q).apply(null,arguments)},t._OrtInit=function(){return(t._OrtInit=t.asm.R).apply(null,arguments)},t._OrtCreateSessionOptions=function(){return(t._OrtCreateSessionOptions=t.asm.S).apply(null,arguments)},t._OrtAppendExecutionProvider=function(){return(t._OrtAppendExecutionProvider=t.asm.T).apply(null,arguments)},t._OrtAddSessionConfigEntry=function(){return(t._OrtAddSessionConfigEntry=t.asm.U).apply(null,arguments)},t._OrtReleaseSessionOptions=function(){return(t._OrtReleaseSessionOptions=t.asm.V).apply(null,arguments)},t._OrtCreateSession=function(){return(t._OrtCreateSession=t.asm.W).apply(null,arguments)},t._OrtReleaseSession=function(){return(t._OrtReleaseSession=t.asm.X).apply(null,arguments)},t._OrtGetInputCount=function(){return(t._OrtGetInputCount=t.asm.Y).apply(null,arguments)},t._OrtGetOutputCount=function(){return(t._OrtGetOutputCount=t.asm.Z).apply(null,arguments)},t._OrtGetInputName=function(){return(t._OrtGetInputName=t.asm._).apply(null,arguments)},t._OrtGetOutputName=function(){return(t._OrtGetOutputName=t.asm.$).apply(null,arguments)},t._OrtFree=function(){return(t._OrtFree=t.asm.aa).apply(null,arguments)},t._OrtCreateTensor=function(){return(t._OrtCreateTensor=t.asm.ba).apply(null,arguments)},t._OrtGetTensorData=function(){return(t._OrtGetTensorData=t.asm.ca).apply(null,arguments)},t._OrtReleaseTensor=function(){return(t._OrtReleaseTensor=t.asm.da).apply(null,arguments)},t._OrtCreateRunOptions=function(){return(t._OrtCreateRunOptions=t.asm.ea).apply(null,arguments)},t._OrtAddRunConfigEntry=function(){return(t._OrtAddRunConfigEntry=t.asm.fa).apply(null,arguments)},t._OrtReleaseRunOptions=function(){return(t._OrtReleaseRunOptions=t.asm.ga).apply(null,arguments)},t._OrtRun=function(){return(t._OrtRun=t.asm.ha).apply(null,arguments)},t._OrtEndProfiling=function(){return(t._OrtEndProfiling=t.asm.ia).apply(null,arguments)};var ie=t._malloc=function(){return(ie=t._malloc=t.asm.ja).apply(null,arguments)};t._free=function(){return(t._free=t.asm.ka).apply(null,arguments)};var se,ue=t.stackSave=function(){return(ue=t.stackSave=t.asm.ma).apply(null,arguments)},ce=t.stackRestore=function(){return(ce=t.stackRestore=t.asm.na).apply(null,arguments)},le=t.stackAlloc=function(){return(le=t.stackAlloc=t.asm.oa).apply(null,arguments)};function fe(){function e(){if(!se&&(se=!0,t.calledRun=!0,!R)){if(V(I),r(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;){var e=t.postRun.shift();W.unshift(e)}V(W)}}if(!(0<L)){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)j();V(U),0<L||(t.setStatus?(t.setStatus("Running..."),setTimeout((function(){setTimeout((function(){t.setStatus("")}),1),e()}),1)):e())}}if(t.___cxa_is_pointer_type=function(){return(t.___cxa_is_pointer_type=t.asm.pa).apply(null,arguments)},t.UTF8ToString=P,t.stringToUTF8=function(e,t,n){return k(e,A,t,n)},t.lengthBytesUTF8=D,t.stackSave=ue,t.stackRestore=ce,t.stackAlloc=le,z=function e(){se||fe(),se||(z=e)},t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return fe(),e.ready});e.exports=r},154:e=>{"use strict";e.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},760:()=>{},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var o=t[r]={exports:{}};return e[r].call(o.exports,o,o.exports,n),o.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{"use strict";const e=n(259),t=n(263);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,t.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})));break;case"init-ort":try{const{numThreads:t,loggingLevel:r}=n.data.in;(0,e.initOrt)(t,r),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create_allocate":try{const{model:t}=n.data.in,r=(0,e.createSessionAllocate)(t);postMessage({type:"create_allocate",out:r})}catch(e){postMessage({type:"create_allocate",err:e})}break;case"create_finalize":try{const{modeldata:t,options:r}=n.data.in,a=(0,e.createSessionFinalize)(t,r);postMessage({type:"create_finalize",out:a})}catch(e){postMessage({type:"create_finalize",err:e})}break;case"create":try{const{model:t,options:r}=n.data.in,a=(0,e.createSession)(t,r);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=n.data.in;(0,e.releaseSession)(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:r,inputs:a,outputIndices:o,options:i}=n.data.in;(0,e.run)(t,r,a,o,i).then((t=>{postMessage({type:"run",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:"run",err:e})}))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=n.data.in;(0,e.endProfiling)(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n',"Worker",void 0,void 0)}},6614:e=>{"use strict";e.exports=function(e,t,n,r){var o=self||window;try{try{var i;try{i=new o.Blob([e])}catch(t){(i=new(o.BlobBuilder||o.WebKitBlobBuilder||o.MozBlobBuilder||o.MSBlobBuilder)).append(e),i=i.getBlob()}var a=o.URL||o.webkitURL,s=a.createObjectURL(i),u=new o[t](s,n);return a.revokeObjectURL(s),u}catch(r){return new o[t]("data:application/javascript,".concat(encodeURIComponent(e)),n)}}catch(e){if(!r)throw Error("Inline worker is not supported");return new o[t](r,n)}}},3474:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){function t(){return D.buffer!=C&&H(D.buffer),R}function r(){return D.buffer!=C&&H(D.buffer),M}function o(){return D.buffer!=C&&H(D.buffer),N}function i(){return D.buffer!=C&&H(D.buffer),F}function a(){return D.buffer!=C&&H(D.buffer),L}var s,u,l;e=e||{},s||(s=void 0!==e?e:{}),s.ready=new Promise((function(e,t){u=e,l=t}));var c,p,d,f,h,g,m=Object.assign({},s),b="./this.program",y=(e,t)=>{throw t},w="object"==typeof window,_="function"==typeof importScripts,v="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,x=s.ENVIRONMENT_IS_PTHREAD||!1,T="";function S(e){return s.locateFile?s.locateFile(e,T):T+e}if(v){let t;T=_?n(908).dirname(T)+"/":"//",g=()=>{h||(f=n(1384),h=n(908))},c=function(e,t){return g(),e=h.normalize(e),f.readFileSync(e,t?void 0:"utf8")},d=e=>((e=c(e,!0)).buffer||(e=new Uint8Array(e)),e),p=(e,t,n)=>{g(),e=h.normalize(e),f.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(b=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof ae))throw e})),process.on("unhandledRejection",(function(e){throw e})),y=(e,t)=>{if(P)throw process.exitCode=e,t;t instanceof ae||$("exiting due to exception: "+t),process.exit(e)},s.inspect=function(){return"[Emscripten Module object]"};try{t=n(9925)}catch(e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),e}n.g.Worker=t.Worker}else(w||_)&&(_?T=self.location.href:"undefined"!=typeof document&&document.currentScript&&(T=document.currentScript.src),_scriptDir&&(T=_scriptDir),T=0!==T.indexOf("blob:")?T.substr(0,T.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v||(c=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},_&&(d=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),p=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));v&&"undefined"==typeof performance&&(n.g.performance=n(6953).performance);var O=console.log.bind(console),A=console.warn.bind(console);v&&(g(),O=e=>f.writeSync(1,e+"\n"),A=e=>f.writeSync(2,e+"\n"));var E,I=s.print||O,$=s.printErr||A;Object.assign(s,m),m=null,s.thisProgram&&(b=s.thisProgram),s.quit&&(y=s.quit),s.wasmBinary&&(E=s.wasmBinary);var P=s.noExitRuntime||!0;"object"!=typeof WebAssembly&&ne("no native wasm support detected");var D,k,C,R,M,N,F,L,j=!1,U="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function B(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&U)return U.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var o=e[t++];if(128&o){var i=63&e[t++];if(192==(224&o))r+=String.fromCharCode((31&o)<<6|i);else{var a=63&e[t++];65536>(o=224==(240&o)?(15&o)<<12|i<<6|a:(7&o)<<18|i<<12|a<<6|63&e[t++])?r+=String.fromCharCode(o):(o-=65536,r+=String.fromCharCode(55296|o>>10,56320|1023&o))}}else r+=String.fromCharCode(o)}return r}function G(e,t){return(e>>>=0)?B(r(),e,t):""}function V(e,t,n,r){if(!(0<r))return 0;var o=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var a=e.charCodeAt(i);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&e.charCodeAt(++i)),127>=a){if(n>=r)break;t[n++>>>0]=a}else{if(2047>=a){if(n+1>=r)break;t[n++>>>0]=192|a>>6}else{if(65535>=a){if(n+2>=r)break;t[n++>>>0]=224|a>>12}else{if(n+3>=r)break;t[n++>>>0]=240|a>>18,t[n++>>>0]=128|a>>12&63}t[n++>>>0]=128|a>>6&63}t[n++>>>0]=128|63&a}}return t[n>>>0]=0,n-o}function z(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function H(e){C=e,s.HEAP8=R=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=N=new Int32Array(e),s.HEAPU8=M=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=F=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=L=new Float64Array(e)}x&&(C=s.buffer);var W=s.INITIAL_MEMORY||16777216;if(x)D=s.wasmMemory,C=s.buffer;else if(s.wasmMemory)D=s.wasmMemory;else if(!((D=new WebAssembly.Memory({initial:W/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw $("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");D&&(C=D.buffer),W=C.byteLength,H(C);var q,K=[],X=[],Y=[];function J(){var e=s.preRun.shift();K.unshift(e)}var Z,Q=0,ee=null,te=null;function ne(e){throw x?postMessage({cmd:"onAbort",arg:e}):s.onAbort&&s.onAbort(e),$(e="Aborted("+e+")"),j=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),l(e),e}function re(){return Z.startsWith("data:application/octet-stream;base64,")}function oe(){var e=Z;try{if(e==Z&&E)return new Uint8Array(E);if(d)return d(e);throw"both async and sync fetching of the wasm failed"}catch(e){ne(e)}}Z="ort-wasm-threaded.wasm",re()||(Z=S(Z));var ie={};function ae(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function se(e){(e=pe.La[e])||ne(),pe.Xa(e)}function ue(e){var t=pe.lb();if(!t)return 6;pe.Ra.push(t),pe.La[e.Ka]=t,t.Ka=e.Ka;var n={cmd:"run",start_routine:e.pb,arg:e.ib,pthread_ptr:e.Ka};return t.Qa=()=>{n.time=performance.now(),t.postMessage(n,e.vb)},t.loaded&&(t.Qa(),delete t.Qa),0}function le(e){if(x)return je(1,1,e);P||(pe.qb(),s.onExit&&s.onExit(e),j=!0),y(e,new ae(e))}function ce(e,t){if(!t&&x)throw fe(e),"unwind";le(e)}var pe={Oa:[],Ra:[],$a:[],La:{},Ua:function(){x&&pe.mb()},xb:function(){},mb:function(){pe.receiveObjectTransfer=pe.ob,pe.threadInitTLS=pe.Za,pe.setExitStatus=pe.Ya,P=!1},Ya:function(){},qb:function(){for(var e of Object.values(pe.La))pe.Xa(e);for(e of pe.Oa)e.terminate();pe.Oa=[]},Xa:function(e){var t=e.Ka;delete pe.La[t],pe.Oa.push(e),pe.Ra.splice(pe.Ra.indexOf(e),1),e.Ka=0,lt(t)},ob:function(){},Za:function(){pe.$a.forEach((e=>e()))},nb:function(e,t){e.onmessage=n=>{var r=(n=n.data).cmd;if(e.Ka&&(pe.kb=e.Ka),n.targetThread&&n.targetThread!=rt()){var o=pe.La[n.yb];o?o.postMessage(n,n.transferList):$('Internal error! Worker sent a message "'+r+'" to target pthread '+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?Ce(n.queue):"spawnThread"===r?ue(n):"cleanupThread"===r?se(n.thread):"killThread"===r?(n=n.thread,r=pe.La[n],delete pe.La[n],r.terminate(),lt(n),pe.Ra.splice(pe.Ra.indexOf(r),1),r.Ka=0):"cancelThread"===r?pe.La[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t&&t(e),e.Qa&&(e.Qa(),delete e.Qa)):"print"===r?I("Thread "+n.threadId+": "+n.text):"printErr"===r?$("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"onAbort"===r?s.onAbort&&s.onAbort(n.arg):r&&$("worker sent an unknown command "+r);pe.kb=void 0},e.onerror=e=>{throw $("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},v&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){}))),e.postMessage({cmd:"load",urlOrBlob:s.mainScriptUrlOrBlob||_scriptDir,wasmMemory:D,wasmModule:k})},hb:function(){var e=S("ort-wasm-threaded.worker.js");pe.Oa.push(new Worker(e))},lb:function(){return 0==pe.Oa.length&&(pe.hb(),pe.nb(pe.Oa[0])),pe.Oa.pop()}};function de(e){for(;0<e.length;)e.shift()(s)}function fe(e){if(x)return je(2,0,e);try{ce(e)}catch(e){e instanceof ae||"unwind"==e||y(1,e)}}s.PThread=pe,s.establishStackSpace=function(){var e=rt(),t=o()[e+44>>2>>>0];e=o()[e+48>>2>>>0],pt(t,t-e),ft(t)};var he,ge,me=[];function be(e){this.Pa=e-24,this.gb=function(e){i()[this.Pa+4>>2>>>0]=e},this.cb=function(e){i()[this.Pa+8>>2>>>0]=e},this.eb=function(){o()[this.Pa>>2>>>0]=0},this.bb=function(){t()[this.Pa+12>>0>>>0]=0},this.fb=function(){t()[this.Pa+13>>0>>>0]=0},this.Ua=function(e,t){this.ab(),this.gb(e),this.cb(t),this.eb(),this.bb(),this.fb()},this.ab=function(){i()[this.Pa+16>>2>>>0]=0}}function ye(e,t,n,r){return x?je(3,1,e,t,n,r):we(e,t,n,r)}function we(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return $("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var o=[];return x&&0===o.length?ye(e,t,n,r):(e={pb:n,Ka:e,ib:r,vb:o},x?(e.wb="spawnThread",postMessage(e,o),0):ue(e))}function _e(e,t,n){return x?je(4,1,e,t,n):0}function ve(e,t){if(x)return je(5,1,e,t)}function xe(e,t){if(x)return je(6,1,e,t)}function Te(e,t,n){if(x)return je(7,1,e,t,n)}function Se(e,t,n){return x?je(8,1,e,t,n):0}function Oe(e,t){if(x)return je(9,1,e,t)}function Ae(e,t,n){if(x)return je(10,1,e,t,n)}function Ee(e,t,n,r){if(x)return je(11,1,e,t,n,r)}function Ie(e,t,n,r){if(x)return je(12,1,e,t,n,r)}function $e(e,t,n,r){if(x)return je(13,1,e,t,n,r)}function Pe(e){if(x)return je(14,1,e)}function De(e,t){if(x)return je(15,1,e,t)}function ke(e,t,n){if(x)return je(16,1,e,t,n)}function Ce(e){Atomics.store(o(),e>>2,1),rt()&&ut(e),Atomics.compareExchange(o(),e>>2,1,0)}function Re(e){return i()[e>>>2]+4294967296*o()[e+4>>>2]}function Me(e,t,n,r,o,i){return x?je(17,1,e,t,n,r,o,i):-52}function Ne(e,t,n,r,o,i){if(x)return je(18,1,e,t,n,r,o,i)}function Fe(e){var n=z(e)+1,r=ot(n);return r&&V(e,t(),r,n),r}function Le(e,t,n){function r(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}if(x)return je(19,1,e,t,n);var a=(new Date).getFullYear(),s=new Date(a,0,1),u=new Date(a,6,1);a=s.getTimezoneOffset();var l=u.getTimezoneOffset(),c=Math.max(a,l);o()[e>>2>>>0]=60*c,o()[t>>2>>>0]=Number(a!=l),e=r(s),t=r(u),e=Fe(e),t=Fe(t),l<a?(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t):(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e)}function je(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=dt();return e=e(),ft(t),e}((()=>{for(var o=ht(8*n),i=o>>3,s=0;s<n;s++){var u=r[2+s];a()[i+s>>>0]=u}return st(e,n,o,t)}))}s.invokeEntryPoint=function(e,t){var n=me[e];n||(e>=me.length&&(me.length=e+1),me[e]=n=q.get(e)),e=n(t),P?pe.Ya(e):ct(e)},s.executeNotifiedProxyingQueue=Ce,ge=v?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:x?()=>performance.now()-s.__performance_now_clock_drift:()=>performance.now();var Ue,Be=[],Ge={};function Ve(){if(!Ue){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:b||"./this.program"};for(e in Ge)void 0===Ge[e]?delete t[e]:t[e]=Ge[e];var n=[];for(e in t)n.push(e+"="+t[e]);Ue=n}return Ue}function ze(e,n){if(x)return je(20,1,e,n);var r=0;return Ve().forEach((function(o,a){var s=n+r;for(a=i()[e+4*a>>2>>>0]=s,s=0;s<o.length;++s)t()[a++>>0>>>0]=o.charCodeAt(s);t()[a>>0>>>0]=0,r+=o.length+1})),0}function He(e,t){if(x)return je(21,1,e,t);var n=Ve();i()[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),i()[t>>2>>>0]=r,0}function We(e){return x?je(22,1,e):52}function qe(e,t,n,r){return x?je(23,1,e,t,n,r):52}function Ke(e,t,n,r,o){return x?je(24,1,e,t,n,r,o):70}var Xe=[null,[],[]];function Ye(e,t,n,o){if(x)return je(25,1,e,t,n,o);for(var a=0,s=0;s<n;s++){var u=i()[t>>2>>>0],l=i()[t+4>>2>>>0];t+=8;for(var c=0;c<l;c++){var p=r()[u+c>>>0],d=Xe[e];0===p||10===p?((1===e?I:$)(B(d,0)),d.length=0):d.push(p)}a+=l}return i()[o>>2>>>0]=a,0}function Je(e){return 0==e%4&&(0!=e%100||0==e%400)}var Ze=[31,29,31,30,31,30,31,31,30,31,30,31],Qe=[31,28,31,30,31,30,31,31,30,31,30,31];function et(e,n,r,i){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function s(e,t){return a(e,t,"0")}function u(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function l(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function c(e){var t=e.Ma;for(e=new Date(new Date(e.Na+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(Je(e.getFullYear())?Ze:Qe)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=l(new Date(e.getFullYear(),0,4)),n=l(n),0>=u(t,e)?0>=u(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var p=o()[i+40>>2>>>0];for(var d in i={tb:o()[i>>2>>>0],sb:o()[i+4>>2>>>0],Sa:o()[i+8>>2>>>0],Va:o()[i+12>>2>>>0],Ta:o()[i+16>>2>>>0],Na:o()[i+20>>2>>>0],Ja:o()[i+24>>2>>>0],Ma:o()[i+28>>2>>>0],zb:o()[i+32>>2>>>0],rb:o()[i+36>>2>>>0],ub:p?G(p):""},r=G(r),p={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(d,"g"),p[d]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),h="January February March April May June July August September October November December".split(" ");for(d in p={"%a":function(e){return f[e.Ja].substring(0,3)},"%A":function(e){return f[e.Ja]},"%b":function(e){return h[e.Ta].substring(0,3)},"%B":function(e){return h[e.Ta]},"%C":function(e){return s((e.Na+1900)/100|0,2)},"%d":function(e){return s(e.Va,2)},"%e":function(e){return a(e.Va,2," ")},"%g":function(e){return c(e).toString().substring(2)},"%G":function(e){return c(e)},"%H":function(e){return s(e.Sa,2)},"%I":function(e){return 0==(e=e.Sa)?e=12:12<e&&(e-=12),s(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.Ta-1;t+=(Je(e.Na+1900)?Ze:Qe)[n++]);return s(e.Va+t,3)},"%m":function(e){return s(e.Ta+1,2)},"%M":function(e){return s(e.sb,2)},"%n":function(){return"\n"},"%p":function(e){return 0<=e.Sa&&12>e.Sa?"AM":"PM"},"%S":function(e){return s(e.tb,2)},"%t":function(){return"\t"},"%u":function(e){return e.Ja||7},"%U":function(e){return s(Math.floor((e.Ma+7-e.Ja)/7),2)},"%V":function(e){var t=Math.floor((e.Ma+7-(e.Ja+6)%7)/7);if(2>=(e.Ja+371-e.Ma-2)%7&&t++,t)53==t&&(4==(n=(e.Ja+371-e.Ma)%7)||3==n&&Je(e.Na)||(t=1));else{t=52;var n=(e.Ja+7-e.Ma-1)%7;(4==n||5==n&&Je(e.Na%400-1))&&t++}return s(t,2)},"%w":function(e){return e.Ja},"%W":function(e){return s(Math.floor((e.Ma+7-(e.Ja+6)%7)/7),2)},"%y":function(e){return(e.Na+1900).toString().substring(2)},"%Y":function(e){return e.Na+1900},"%z":function(e){var t=0<=(e=e.rb);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.ub},"%%":function(){return"%"}},r=r.replace(/%%/g,"\0\0"),p)r.includes(d)&&(r=r.replace(new RegExp(d,"g"),p[d](i)));return d=function(e){var t=Array(z(e)+1);return V(e,t,0,t.length),t}(r=r.replace(/\0\0/g,"%")),d.length>n?0:(function(e,n){t().set(e,n>>>0)}(d,e),d.length-1)}pe.Ua();var tt=[null,le,fe,ye,_e,ve,xe,Te,Se,Oe,Ae,Ee,Ie,$e,Pe,De,ke,Me,Ne,Le,ze,He,We,qe,Ke,Ye],nt={b:function(e){return ot(e+24)+24},c:function(e,t,n){throw new be(e).Ua(t,n),e},L:function(e){it(e,!_,1,!w),pe.Za()},l:function(e){x?postMessage({cmd:"cleanupThread",thread:e}):se(e)},D:we,i:_e,R:ve,z:xe,B:Te,T:Se,P:Oe,I:Ae,O:Ee,p:Ie,A:$e,x:Pe,Q:De,y:ke,r:function(){},j:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},s:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},q:function(){return Date.now()},E:function(){return 2097152},V:function(){return!0},F:function(e,t,n,r){if(e==t)setTimeout((()=>Ce(r)));else if(x)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{if(!(e=pe.La[e]))return;e.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},K:function(){return-1},W:function(e,t){e=new Date(1e3*Re(e)),o()[t>>2>>>0]=e.getUTCSeconds(),o()[t+4>>2>>>0]=e.getUTCMinutes(),o()[t+8>>2>>>0]=e.getUTCHours(),o()[t+12>>2>>>0]=e.getUTCDate(),o()[t+16>>2>>>0]=e.getUTCMonth(),o()[t+20>>2>>>0]=e.getUTCFullYear()-1900,o()[t+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,o()[t+28>>2>>>0]=e},X:function(e,t){e=new Date(1e3*Re(e)),o()[t>>2>>>0]=e.getSeconds(),o()[t+4>>2>>>0]=e.getMinutes(),o()[t+8>>2>>>0]=e.getHours(),o()[t+12>>2>>>0]=e.getDate(),o()[t+16>>2>>>0]=e.getMonth(),o()[t+20>>2>>>0]=e.getFullYear()-1900,o()[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1),r=(e.getTime()-n.getTime())/864e5|0;o()[t+28>>2>>>0]=r,o()[t+36>>2>>>0]=-60*e.getTimezoneOffset(),r=new Date(e.getFullYear(),6,1).getTimezoneOffset(),e=0|(r!=(n=n.getTimezoneOffset())&&e.getTimezoneOffset()==Math.min(n,r)),o()[t+32>>2>>>0]=e},Y:function(e){var t=new Date(o()[e+20>>2>>>0]+1900,o()[e+16>>2>>>0],o()[e+12>>2>>>0],o()[e+8>>2>>>0],o()[e+4>>2>>>0],o()[e>>2>>>0],0),n=o()[e+32>>2>>>0],r=t.getTimezoneOffset(),i=new Date(t.getFullYear(),0,1),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),s=i.getTimezoneOffset(),u=Math.min(s,a);return 0>n?o()[e+32>>2>>>0]=Number(a!=s&&u==r):0<n!=(u==r)&&(a=Math.max(s,a),t.setTime(t.getTime()+6e4*((0<n?u:a)-r))),o()[e+24>>2>>>0]=t.getDay(),n=(t.getTime()-i.getTime())/864e5|0,o()[e+28>>2>>>0]=n,o()[e>>2>>>0]=t.getSeconds(),o()[e+4>>2>>>0]=t.getMinutes(),o()[e+8>>2>>>0]=t.getHours(),o()[e+12>>2>>>0]=t.getDate(),o()[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},G:Me,H:Ne,Z:function e(t,n,r){e.jb||(e.jb=!0,Le(t,n,r))},d:function(){ne("")},m:function(){if(!v&&!_){var e="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";he||(he={}),he[e]||(he[e]=1,v&&(e="warning: "+e),$(e))}},w:function(){return 4294901760},f:ge,S:function(e,t,n){r().copyWithin(e>>>0,t>>>0,t+n>>>0)},g:function(){return v?n(3993).cpus().length:navigator.hardwareConcurrency},J:function(e,t,n){Be.length=t,n>>=3;for(var r=0;r<t;r++)Be[r]=a()[n+r>>>0];return(0>e?ie[-e-1]:tt[e]).apply(null,Be)},v:function(e){var t=r().length;if((e>>>=0)<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var o=t*(1+.2/n);o=Math.min(o,e+100663296);var i=Math;o=Math.max(e,o),i=i.min.call(i,4294901760,o+(65536-o%65536)%65536);e:{try{D.grow(i-C.byteLength+65535>>>16),H(D.buffer);var a=1;break e}catch(e){}a=void 0}if(a)return!0}return!1},U:function(){throw"unwind"},M:ze,N:He,k:ce,h:We,o:qe,t:Ke,n:Ye,u:function e(r,o){e.Wa||(e.Wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(v)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>ne("randomDevice")}());for(var i=0;i<o;i++)t()[r+i>>0>>>0]=e.Wa();return 0},a:D||s.wasmMemory,C:et,e:function(e,t,n,r){return et(e,t,n,r)}};!function(){function e(e,t){s.asm=e.exports,pe.$a.push(s.asm.wa),q=s.asm.za,X.unshift(s.asm._),k=t,x||(Q--,s.monitorRunDependencies&&s.monitorRunDependencies(Q),0==Q&&(null!==ee&&(clearInterval(ee),ee=null),te&&(e=te,te=null,e())))}function t(t){e(t.instance,t.module)}function n(e){return function(){if(!E&&(w||_)){if("function"==typeof fetch&&!Z.startsWith("file://"))return fetch(Z,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+Z+"'";return e.arrayBuffer()})).catch((function(){return oe()}));if(p)return new Promise((function(e,t){p(Z,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return oe()}))}().then((function(e){return WebAssembly.instantiate(e,r)})).then((function(e){return e})).then(e,(function(e){$("failed to asynchronously prepare wasm: "+e),ne(e)}))}var r={a:nt};if(x||(Q++,s.monitorRunDependencies&&s.monitorRunDependencies(Q)),s.instantiateWasm)try{return s.instantiateWasm(r,e)}catch(e){return $("Module.instantiateWasm callback failed with error: "+e),!1}(E||"function"!=typeof WebAssembly.instantiateStreaming||re()||Z.startsWith("file://")||v||"function"!=typeof fetch?n(t):fetch(Z,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,r).then(t,(function(e){return $("wasm streaming compile failed: "+e),$("falling back to ArrayBuffer instantiation"),n(t)}))}))).catch(l)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm._).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.$).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.aa).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.ba).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.ca).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm.da).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.ea).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.fa).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.ga).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.ha).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm.ia).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.ja).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.ka).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.la).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.ma).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.na).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.oa).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.pa).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.qa).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.ra).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.sa).apply(null,arguments)};var rt=s._pthread_self=function(){return(rt=s._pthread_self=s.asm.ta).apply(null,arguments)},ot=s._malloc=function(){return(ot=s._malloc=s.asm.ua).apply(null,arguments)};s._free=function(){return(s._free=s.asm.va).apply(null,arguments)},s.__emscripten_tls_init=function(){return(s.__emscripten_tls_init=s.asm.wa).apply(null,arguments)};var it=s.__emscripten_thread_init=function(){return(it=s.__emscripten_thread_init=s.asm.xa).apply(null,arguments)};s.__emscripten_thread_crashed=function(){return(s.__emscripten_thread_crashed=s.asm.ya).apply(null,arguments)};var at,st=s._emscripten_run_in_main_runtime_thread_js=function(){return(st=s._emscripten_run_in_main_runtime_thread_js=s.asm.Aa).apply(null,arguments)},ut=s.__emscripten_proxy_execute_task_queue=function(){return(ut=s.__emscripten_proxy_execute_task_queue=s.asm.Ba).apply(null,arguments)},lt=s.__emscripten_thread_free_data=function(){return(lt=s.__emscripten_thread_free_data=s.asm.Ca).apply(null,arguments)},ct=s.__emscripten_thread_exit=function(){return(ct=s.__emscripten_thread_exit=s.asm.Da).apply(null,arguments)},pt=s._emscripten_stack_set_limits=function(){return(pt=s._emscripten_stack_set_limits=s.asm.Ea).apply(null,arguments)},dt=s.stackSave=function(){return(dt=s.stackSave=s.asm.Fa).apply(null,arguments)},ft=s.stackRestore=function(){return(ft=s.stackRestore=s.asm.Ga).apply(null,arguments)},ht=s.stackAlloc=function(){return(ht=s.stackAlloc=s.asm.Ha).apply(null,arguments)};function gt(){function e(){if(!at&&(at=!0,s.calledRun=!0,!j)&&(x||de(X),u(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!x)){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;){var e=s.postRun.shift();Y.unshift(e)}de(Y)}}if(!(0<Q))if(x)u(s),x||de(X),postMessage({cmd:"loaded"});else{if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)J();de(K),0<Q||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),e()}),1)):e())}}if(s.___cxa_is_pointer_type=function(){return(s.___cxa_is_pointer_type=s.asm.Ia).apply(null,arguments)},s.UTF8ToString=G,s.stringToUTF8=function(e,t,n){return V(e,r(),t,n)},s.lengthBytesUTF8=z,s.keepRuntimeAlive=function(){return P},s.wasmMemory=D,s.stackSave=dt,s.stackRestore=ft,s.stackAlloc=ht,s.ExitStatus=ae,s.PThread=pe,te=function e(){at||gt(),at||(te=e)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return gt(),e.ready});e.exports=r},932:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){var t,r,o;e=e||{},t||(t=void 0!==e?e:{}),t.ready=new Promise((function(e,t){r=e,o=t}));var i,a,s,u,l,c,p=Object.assign({},t),d="./this.program",f=(e,t)=>{throw t},h="object"==typeof window,g="function"==typeof importScripts,m="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,b="";m?(b=g?n(908).dirname(b)+"/":"//",c=()=>{l||(u=n(1384),l=n(908))},i=function(e,t){return c(),e=l.normalize(e),u.readFileSync(e,t?void 0:"utf8")},s=e=>((e=i(e,!0)).buffer||(e=new Uint8Array(e)),e),a=(e,t,n)=>{c(),e=l.normalize(e),u.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(d=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof q))throw e})),process.on("unhandledRejection",(function(e){throw e})),f=(e,t)=>{if(v)throw process.exitCode=e,t;t instanceof q||_("exiting due to exception: "+t),process.exit(e)},t.inspect=function(){return"[Emscripten Module object]"}):(h||g)&&(g?b=self.location.href:"undefined"!=typeof document&&document.currentScript&&(b=document.currentScript.src),_scriptDir&&(b=_scriptDir),b=0!==b.indexOf("blob:")?b.substr(0,b.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},g&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),a=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var y,w=t.print||console.log.bind(console),_=t.printErr||console.warn.bind(console);Object.assign(t,p),p=null,t.thisProgram&&(d=t.thisProgram),t.quit&&(f=t.quit),t.wasmBinary&&(y=t.wasmBinary);var v=t.noExitRuntime||!0;"object"!=typeof WebAssembly&&V("no native wasm support detected");var x,T,S,O,A,E,I=!1,$="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function P(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&$)return $.decode(e.subarray(t,n));for(r="";t<n;){var o=e[t++];if(128&o){var i=63&e[t++];if(192==(224&o))r+=String.fromCharCode((31&o)<<6|i);else{var a=63&e[t++];65536>(o=224==(240&o)?(15&o)<<12|i<<6|a:(7&o)<<18|i<<12|a<<6|63&e[t++])?r+=String.fromCharCode(o):(o-=65536,r+=String.fromCharCode(55296|o>>10,56320|1023&o))}}else r+=String.fromCharCode(o)}return r}function D(e,t){return(e>>>=0)?P(O,e,t):""}function k(e,t,n,r){if(!(0<r))return 0;var o=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var a=e.charCodeAt(i);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&e.charCodeAt(++i)),127>=a){if(n>=r)break;t[n++>>>0]=a}else{if(2047>=a){if(n+1>=r)break;t[n++>>>0]=192|a>>6}else{if(65535>=a){if(n+2>=r)break;t[n++>>>0]=224|a>>12}else{if(n+3>=r)break;t[n++>>>0]=240|a>>18,t[n++>>>0]=128|a>>12&63}t[n++>>>0]=128|a>>6&63}t[n++>>>0]=128|63&a}}return t[n>>>0]=0,n-o}function C(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function R(){var e=x.buffer;T=e,t.HEAP8=S=new Int8Array(e),t.HEAP16=new Int16Array(e),t.HEAP32=A=new Int32Array(e),t.HEAPU8=O=new Uint8Array(e),t.HEAPU16=new Uint16Array(e),t.HEAPU32=E=new Uint32Array(e),t.HEAPF32=new Float32Array(e),t.HEAPF64=new Float64Array(e)}var M=[],N=[],F=[];function L(){var e=t.preRun.shift();M.unshift(e)}var j,U=0,B=null,G=null;function V(e){throw t.onAbort&&t.onAbort(e),_(e="Aborted("+e+")"),I=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),o(e),e}function z(){return j.startsWith("data:application/octet-stream;base64,")}if(j="ort-wasm.wasm",!z()){var H=j;j=t.locateFile?t.locateFile(H,b):b+H}function W(){var e=j;try{if(e==j&&y)return new Uint8Array(y);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}catch(e){V(e)}}function q(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function K(e){for(;0<e.length;)e.shift()(t)}function X(e){this.sa=e-24,this.Ia=function(e){E[this.sa+4>>2>>>0]=e},this.Ba=function(e){E[this.sa+8>>2>>>0]=e},this.Ga=function(){A[this.sa>>2>>>0]=0},this.Aa=function(){S[this.sa+12>>0>>>0]=0},this.Ha=function(){S[this.sa+13>>0>>>0]=0},this.ya=function(e,t){this.za(),this.Ia(e),this.Ba(t),this.Ga(),this.Aa(),this.Ha()},this.za=function(){E[this.sa+16>>2>>>0]=0}}function Y(e){var t=C(e)+1,n=ae(t);return n&&k(e,S,n,t),n}var J={};function Z(){if(!Q){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:d||"./this.program"};for(e in J)void 0===J[e]?delete t[e]:t[e]=J[e];var n=[];for(e in t)n.push(e+"="+t[e]);Q=n}return Q}var Q,ee=[null,[],[]];function te(e){return 0==e%4&&(0!=e%100||0==e%400)}var ne=[31,29,31,30,31,30,31,31,30,31,30,31],re=[31,28,31,30,31,30,31,31,30,31,30,31];function oe(e,t,n,r){function o(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function i(e,t){return o(e,t,"0")}function a(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.qa;for(e=new Date(new Date(e.ra+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(te(e.getFullYear())?ne:re)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=a(t,e)?0>=a(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var l=A[r+40>>2>>>0];for(var c in r={Ea:A[r>>2>>>0],Da:A[r+4>>2>>>0],ta:A[r+8>>2>>>0],va:A[r+12>>2>>>0],ua:A[r+16>>2>>>0],ra:A[r+20>>2>>>0],la:A[r+24>>2>>>0],qa:A[r+28>>2>>>0],Ja:A[r+32>>2>>>0],Ca:A[r+36>>2>>>0],Fa:l?D(l):""},n=D(n),l={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(c,"g"),l[c]);var p="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(c in l={"%a":function(e){return p[e.la].substring(0,3)},"%A":function(e){return p[e.la]},"%b":function(e){return d[e.ua].substring(0,3)},"%B":function(e){return d[e.ua]},"%C":function(e){return i((e.ra+1900)/100|0,2)},"%d":function(e){return i(e.va,2)},"%e":function(e){return o(e.va,2," ")},"%g":function(e){return u(e).toString().substring(2)},"%G":function(e){return u(e)},"%H":function(e){return i(e.ta,2)},"%I":function(e){return 0==(e=e.ta)?e=12:12<e&&(e-=12),i(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.ua-1;t+=(te(e.ra+1900)?ne:re)[n++]);return i(e.va+t,3)},"%m":function(e){return i(e.ua+1,2)},"%M":function(e){return i(e.Da,2)},"%n":function(){return"\n"},"%p":function(e){return 0<=e.ta&&12>e.ta?"AM":"PM"},"%S":function(e){return i(e.Ea,2)},"%t":function(){return"\t"},"%u":function(e){return e.la||7},"%U":function(e){return i(Math.floor((e.qa+7-e.la)/7),2)},"%V":function(e){var t=Math.floor((e.qa+7-(e.la+6)%7)/7);if(2>=(e.la+371-e.qa-2)%7&&t++,t)53==t&&(4==(n=(e.la+371-e.qa)%7)||3==n&&te(e.ra)||(t=1));else{t=52;var n=(e.la+7-e.qa-1)%7;(4==n||5==n&&te(e.ra%400-1))&&t++}return i(t,2)},"%w":function(e){return e.la},"%W":function(e){return i(Math.floor((e.qa+7-(e.la+6)%7)/7),2)},"%y":function(e){return(e.ra+1900).toString().substring(2)},"%Y":function(e){return e.ra+1900},"%z":function(e){var t=0<=(e=e.Ca);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.Fa},"%%":function(){return"%"}},n=n.replace(/%%/g,"\0\0"),l)n.includes(c)&&(n=n.replace(new RegExp(c,"g"),l[c](r)));return c=function(e){var t=Array(C(e)+1);return k(e,t,0,t.length),t}(n=n.replace(/\0\0/g,"%")),c.length>t?0:(S.set(c,e>>>0),c.length-1)}var ie={a:function(e){return ae(e+24)+24},b:function(e,t,n){throw new X(e).ya(t,n),e},g:function(){return 0},I:function(){},w:function(){},y:function(){},K:function(){return 0},G:function(){},C:function(){},F:function(){},k:function(){},x:function(){},u:function(){},H:function(){},v:function(){},n:function(){},p:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},o:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},l:function(){return Date.now()},L:function(){return!0},M:function(e,t){e=new Date(1e3*(E[e>>>2]+4294967296*A[e+4>>>2])),A[t>>2>>>0]=e.getUTCSeconds(),A[t+4>>2>>>0]=e.getUTCMinutes(),A[t+8>>2>>>0]=e.getUTCHours(),A[t+12>>2>>>0]=e.getUTCDate(),A[t+16>>2>>>0]=e.getUTCMonth(),A[t+20>>2>>>0]=e.getUTCFullYear()-1900,A[t+24>>2>>>0]=e.getUTCDay(),A[t+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},N:function(e,t){e=new Date(1e3*(E[e>>>2]+4294967296*A[e+4>>>2])),A[t>>2>>>0]=e.getSeconds(),A[t+4>>2>>>0]=e.getMinutes(),A[t+8>>2>>>0]=e.getHours(),A[t+12>>2>>>0]=e.getDate(),A[t+16>>2>>>0]=e.getMonth(),A[t+20>>2>>>0]=e.getFullYear()-1900,A[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1);A[t+28>>2>>>0]=(e.getTime()-n.getTime())/864e5|0,A[t+36>>2>>>0]=-60*e.getTimezoneOffset();var r=new Date(e.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),A[t+32>>2>>>0]=0|(r!=n&&e.getTimezoneOffset()==Math.min(n,r))},O:function(e){var t=new Date(A[e+20>>2>>>0]+1900,A[e+16>>2>>>0],A[e+12>>2>>>0],A[e+8>>2>>>0],A[e+4>>2>>>0],A[e>>2>>>0],0),n=A[e+32>>2>>>0],r=t.getTimezoneOffset(),o=new Date(t.getFullYear(),0,1),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),a=o.getTimezoneOffset(),s=Math.min(a,i);return 0>n?A[e+32>>2>>>0]=Number(i!=a&&s==r):0<n!=(s==r)&&(i=Math.max(a,i),t.setTime(t.getTime()+6e4*((0<n?s:i)-r))),A[e+24>>2>>>0]=t.getDay(),A[e+28>>2>>>0]=(t.getTime()-o.getTime())/864e5|0,A[e>>2>>>0]=t.getSeconds(),A[e+4>>2>>>0]=t.getMinutes(),A[e+8>>2>>>0]=t.getHours(),A[e+12>>2>>>0]=t.getDate(),A[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},z:function(){return-52},B:function(){},m:function e(t,n,r){e.xa||(e.xa=!0,function(e,t,n){function r(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}var o=(new Date).getFullYear(),i=new Date(o,0,1),a=new Date(o,6,1);o=i.getTimezoneOffset();var s=a.getTimezoneOffset();A[e>>2>>>0]=60*Math.max(o,s),A[t>>2>>>0]=Number(o!=s),e=r(i),t=r(a),e=Y(e),t=Y(t),s<o?(E[n>>2>>>0]=e,E[n+4>>2>>>0]=t):(E[n>>2>>>0]=t,E[n+4>>2>>>0]=e)}(t,n,r))},d:function(){V("")},t:function(){return 4294901760},h:m?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.now(),J:function(e,t,n){O.copyWithin(e>>>0,t>>>0,t+n>>>0)},f:function(e){var t=O.length;if(4294901760<(e>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var o=Math;r=Math.max(e,r),o=o.min.call(o,4294901760,r+(65536-r%65536)%65536);e:{try{x.grow(o-T.byteLength+65535>>>16),R();var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},D:function(e,t){var n=0;return Z().forEach((function(r,o){var i=t+n;for(o=E[e+4*o>>2>>>0]=i,i=0;i<r.length;++i)S[o++>>0>>>0]=r.charCodeAt(i);S[o>>0>>>0]=0,n+=r.length+1})),0},E:function(e,t){var n=Z();E[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),E[t>>2>>>0]=r,0},r:function(e){v||(t.onExit&&t.onExit(e),I=!0),f(e,new q(e))},e:function(){return 52},j:function(){return 52},q:function(){return 70},i:function(e,t,n,r){for(var o=0,i=0;i<n;i++){var a=E[t>>2>>>0],s=E[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var l=O[a+u>>>0],c=ee[e];0===l||10===l?((1===e?w:_)(P(c,0)),c.length=0):c.push(l)}o+=s}return E[r>>2>>>0]=o,0},s:function e(t,r){e.wa||(e.wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(m)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>V("randomDevice")}());for(var o=0;o<r;o++)S[t+o>>0>>>0]=e.wa();return 0},A:oe,c:function(e,t,n,r){return oe(e,t,n,r)}};!function(){function e(e){t.asm=e.exports,x=t.asm.P,R(),N.unshift(t.asm.Q),U--,t.monitorRunDependencies&&t.monitorRunDependencies(U),0==U&&(null!==B&&(clearInterval(B),B=null),G&&(e=G,G=null,e()))}function n(t){e(t.instance)}function r(e){return function(){if(!y&&(h||g)){if("function"==typeof fetch&&!j.startsWith("file://"))return fetch(j,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+j+"'";return e.arrayBuffer()})).catch((function(){return W()}));if(a)return new Promise((function(e,t){a(j,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return W()}))}().then((function(e){return WebAssembly.instantiate(e,i)})).then((function(e){return e})).then(e,(function(e){_("failed to asynchronously prepare wasm: "+e),V(e)}))}var i={a:ie};if(U++,t.monitorRunDependencies&&t.monitorRunDependencies(U),t.instantiateWasm)try{return t.instantiateWasm(i,e)}catch(e){return _("Module.instantiateWasm callback failed with error: "+e),!1}(y||"function"!=typeof WebAssembly.instantiateStreaming||z()||j.startsWith("file://")||m||"function"!=typeof fetch?r(n):fetch(j,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,i).then(n,(function(e){return _("wasm streaming compile failed: "+e),_("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(o)}(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm.Q).apply(null,arguments)},t._OrtInit=function(){return(t._OrtInit=t.asm.R).apply(null,arguments)},t._OrtCreateSessionOptions=function(){return(t._OrtCreateSessionOptions=t.asm.S).apply(null,arguments)},t._OrtAppendExecutionProvider=function(){return(t._OrtAppendExecutionProvider=t.asm.T).apply(null,arguments)},t._OrtAddSessionConfigEntry=function(){return(t._OrtAddSessionConfigEntry=t.asm.U).apply(null,arguments)},t._OrtReleaseSessionOptions=function(){return(t._OrtReleaseSessionOptions=t.asm.V).apply(null,arguments)},t._OrtCreateSession=function(){return(t._OrtCreateSession=t.asm.W).apply(null,arguments)},t._OrtReleaseSession=function(){return(t._OrtReleaseSession=t.asm.X).apply(null,arguments)},t._OrtGetInputCount=function(){return(t._OrtGetInputCount=t.asm.Y).apply(null,arguments)},t._OrtGetOutputCount=function(){return(t._OrtGetOutputCount=t.asm.Z).apply(null,arguments)},t._OrtGetInputName=function(){return(t._OrtGetInputName=t.asm._).apply(null,arguments)},t._OrtGetOutputName=function(){return(t._OrtGetOutputName=t.asm.$).apply(null,arguments)},t._OrtFree=function(){return(t._OrtFree=t.asm.aa).apply(null,arguments)},t._OrtCreateTensor=function(){return(t._OrtCreateTensor=t.asm.ba).apply(null,arguments)},t._OrtGetTensorData=function(){return(t._OrtGetTensorData=t.asm.ca).apply(null,arguments)},t._OrtReleaseTensor=function(){return(t._OrtReleaseTensor=t.asm.da).apply(null,arguments)},t._OrtCreateRunOptions=function(){return(t._OrtCreateRunOptions=t.asm.ea).apply(null,arguments)},t._OrtAddRunConfigEntry=function(){return(t._OrtAddRunConfigEntry=t.asm.fa).apply(null,arguments)},t._OrtReleaseRunOptions=function(){return(t._OrtReleaseRunOptions=t.asm.ga).apply(null,arguments)},t._OrtRun=function(){return(t._OrtRun=t.asm.ha).apply(null,arguments)},t._OrtEndProfiling=function(){return(t._OrtEndProfiling=t.asm.ia).apply(null,arguments)};var ae=t._malloc=function(){return(ae=t._malloc=t.asm.ja).apply(null,arguments)};t._free=function(){return(t._free=t.asm.ka).apply(null,arguments)};var se,ue=t.stackSave=function(){return(ue=t.stackSave=t.asm.ma).apply(null,arguments)},le=t.stackRestore=function(){return(le=t.stackRestore=t.asm.na).apply(null,arguments)},ce=t.stackAlloc=function(){return(ce=t.stackAlloc=t.asm.oa).apply(null,arguments)};function pe(){function e(){if(!se&&(se=!0,t.calledRun=!0,!I)){if(K(N),r(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;){var e=t.postRun.shift();F.unshift(e)}K(F)}}if(!(0<U)){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)L();K(M),0<U||(t.setStatus?(t.setStatus("Running..."),setTimeout((function(){setTimeout((function(){t.setStatus("")}),1),e()}),1)):e())}}if(t.___cxa_is_pointer_type=function(){return(t.___cxa_is_pointer_type=t.asm.pa).apply(null,arguments)},t.UTF8ToString=D,t.stringToUTF8=function(e,t,n){return k(e,O,t,n)},t.lengthBytesUTF8=C,t.stackSave=ue,t.stackRestore=le,t.stackAlloc=ce,G=function e(){se||pe(),se||(G=e)},t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return pe(),e.ready});e.exports=r},4537:e=>{"use strict";e.exports=function(e,t){for(var n=new Array(arguments.length-1),r=0,o=2,i=!0;o<arguments.length;)n[r++]=arguments[o++];return new Promise((function(o,a){n[r]=function(e){if(i)if(i=!1,e)a(e);else{for(var t=new Array(arguments.length-1),n=0;n<t.length;)t[n++]=arguments[n];o.apply(null,t)}};try{e.apply(t||null,n)}catch(e){i&&(i=!1,a(e))}}))}},7419:(e,t)=>{"use strict";var n=t;n.length=function(e){var t=e.length;if(!t)return 0;for(var n=0;--t%4>1&&"="===e.charAt(t);)++n;return Math.ceil(3*e.length)/4-n};for(var r=new Array(64),o=new Array(123),i=0;i<64;)o[r[i]=i<26?i+65:i<52?i+71:i<62?i-4:i-59|43]=i++;n.encode=function(e,t,n){for(var o,i=null,a=[],s=0,u=0;t<n;){var l=e[t++];switch(u){case 0:a[s++]=r[l>>2],o=(3&l)<<4,u=1;break;case 1:a[s++]=r[o|l>>4],o=(15&l)<<2,u=2;break;case 2:a[s++]=r[o|l>>6],a[s++]=r[63&l],u=0}s>8191&&((i||(i=[])).push(String.fromCharCode.apply(String,a)),s=0)}return u&&(a[s++]=r[o],a[s++]=61,1===u&&(a[s++]=61)),i?(s&&i.push(String.fromCharCode.apply(String,a.slice(0,s))),i.join("")):String.fromCharCode.apply(String,a.slice(0,s))};var a="invalid encoding";n.decode=function(e,t,n){for(var r,i=n,s=0,u=0;u<e.length;){var l=e.charCodeAt(u++);if(61===l&&s>1)break;if(void 0===(l=o[l]))throw Error(a);switch(s){case 0:r=l,s=1;break;case 1:t[n++]=r<<2|(48&l)>>4,r=l,s=2;break;case 2:t[n++]=(15&r)<<4|(60&l)>>2,r=l,s=3;break;case 3:t[n++]=(3&r)<<6|l,s=0}}if(1===s)throw Error(a);return n-i},n.test=function(e){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)}},9211:e=>{"use strict";function t(){this._listeners={}}e.exports=t,t.prototype.on=function(e,t,n){return(this._listeners[e]||(this._listeners[e]=[])).push({fn:t,ctx:n||this}),this},t.prototype.off=function(e,t){if(void 0===e)this._listeners={};else if(void 0===t)this._listeners[e]=[];else for(var n=this._listeners[e],r=0;r<n.length;)n[r].fn===t?n.splice(r,1):++r;return this},t.prototype.emit=function(e){var t=this._listeners[e];if(t){for(var n=[],r=1;r<arguments.length;)n.push(arguments[r++]);for(r=0;r<t.length;)t[r].fn.apply(t[r++].ctx,n)}return this}},945:e=>{"use strict";function t(e){return"undefined"!=typeof Float32Array?function(){var t=new Float32Array([-0]),n=new Uint8Array(t.buffer),r=128===n[3];function o(e,r,o){t[0]=e,r[o]=n[0],r[o+1]=n[1],r[o+2]=n[2],r[o+3]=n[3]}function i(e,r,o){t[0]=e,r[o]=n[3],r[o+1]=n[2],r[o+2]=n[1],r[o+3]=n[0]}function a(e,r){return n[0]=e[r],n[1]=e[r+1],n[2]=e[r+2],n[3]=e[r+3],t[0]}function s(e,r){return n[3]=e[r],n[2]=e[r+1],n[1]=e[r+2],n[0]=e[r+3],t[0]}e.writeFloatLE=r?o:i,e.writeFloatBE=r?i:o,e.readFloatLE=r?a:s,e.readFloatBE=r?s:a}():function(){function t(e,t,n,r){var o=t<0?1:0;if(o&&(t=-t),0===t)e(1/t>0?0:2147483648,n,r);else if(isNaN(t))e(2143289344,n,r);else if(t>34028234663852886e22)e((o<<31|2139095040)>>>0,n,r);else if(t<11754943508222875e-54)e((o<<31|Math.round(t/1401298464324817e-60))>>>0,n,r);else{var i=Math.floor(Math.log(t)/Math.LN2);e((o<<31|i+127<<23|8388607&Math.round(t*Math.pow(2,-i)*8388608))>>>0,n,r)}}function a(e,t,n){var r=e(t,n),o=2*(r>>31)+1,i=r>>>23&255,a=8388607&r;return 255===i?a?NaN:o*(1/0):0===i?1401298464324817e-60*o*a:o*Math.pow(2,i-150)*(a+8388608)}e.writeFloatLE=t.bind(null,n),e.writeFloatBE=t.bind(null,r),e.readFloatLE=a.bind(null,o),e.readFloatBE=a.bind(null,i)}(),"undefined"!=typeof Float64Array?function(){var t=new Float64Array([-0]),n=new Uint8Array(t.buffer),r=128===n[7];function o(e,r,o){t[0]=e,r[o]=n[0],r[o+1]=n[1],r[o+2]=n[2],r[o+3]=n[3],r[o+4]=n[4],r[o+5]=n[5],r[o+6]=n[6],r[o+7]=n[7]}function i(e,r,o){t[0]=e,r[o]=n[7],r[o+1]=n[6],r[o+2]=n[5],r[o+3]=n[4],r[o+4]=n[3],r[o+5]=n[2],r[o+6]=n[1],r[o+7]=n[0]}function a(e,r){return n[0]=e[r],n[1]=e[r+1],n[2]=e[r+2],n[3]=e[r+3],n[4]=e[r+4],n[5]=e[r+5],n[6]=e[r+6],n[7]=e[r+7],t[0]}function s(e,r){return n[7]=e[r],n[6]=e[r+1],n[5]=e[r+2],n[4]=e[r+3],n[3]=e[r+4],n[2]=e[r+5],n[1]=e[r+6],n[0]=e[r+7],t[0]}e.writeDoubleLE=r?o:i,e.writeDoubleBE=r?i:o,e.readDoubleLE=r?a:s,e.readDoubleBE=r?s:a}():function(){function t(e,t,n,r,o,i){var a=r<0?1:0;if(a&&(r=-r),0===r)e(0,o,i+t),e(1/r>0?0:2147483648,o,i+n);else if(isNaN(r))e(0,o,i+t),e(2146959360,o,i+n);else if(r>17976931348623157e292)e(0,o,i+t),e((a<<31|2146435072)>>>0,o,i+n);else{var s;if(r<22250738585072014e-324)e((s=r/5e-324)>>>0,o,i+t),e((a<<31|s/4294967296)>>>0,o,i+n);else{var u=Math.floor(Math.log(r)/Math.LN2);1024===u&&(u=1023),e(4503599627370496*(s=r*Math.pow(2,-u))>>>0,o,i+t),e((a<<31|u+1023<<20|1048576*s&1048575)>>>0,o,i+n)}}}function a(e,t,n,r,o){var i=e(r,o+t),a=e(r,o+n),s=2*(a>>31)+1,u=a>>>20&2047,l=4294967296*(1048575&a)+i;return 2047===u?l?NaN:s*(1/0):0===u?5e-324*s*l:s*Math.pow(2,u-1075)*(l+4503599627370496)}e.writeDoubleLE=t.bind(null,n,0,4),e.writeDoubleBE=t.bind(null,r,4,0),e.readDoubleLE=a.bind(null,o,0,4),e.readDoubleBE=a.bind(null,i,4,0)}(),e}function n(e,t,n){t[n]=255&e,t[n+1]=e>>>8&255,t[n+2]=e>>>16&255,t[n+3]=e>>>24}function r(e,t,n){t[n]=e>>>24,t[n+1]=e>>>16&255,t[n+2]=e>>>8&255,t[n+3]=255&e}function o(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0}function i(e,t){return(e[t]<<24|e[t+1]<<16|e[t+2]<<8|e[t+3])>>>0}e.exports=t(t)},7199:module=>{"use strict";function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(e){}return null}module.exports=inquire},6662:e=>{"use strict";e.exports=function(e,t,n){var r=n||8192,o=r>>>1,i=null,a=r;return function(n){if(n<1||n>o)return e(n);a+n>r&&(i=e(r),a=0);var s=t.call(i,a,a+=n);return 7&a&&(a=1+(7|a)),s}}},4997:(e,t)=>{"use strict";var n=t;n.length=function(e){for(var t=0,n=0,r=0;r<e.length;++r)(n=e.charCodeAt(r))<128?t+=1:n<2048?t+=2:55296==(64512&n)&&56320==(64512&e.charCodeAt(r+1))?(++r,t+=4):t+=3;return t},n.read=function(e,t,n){if(n-t<1)return"";for(var r,o=null,i=[],a=0;t<n;)(r=e[t++])<128?i[a++]=r:r>191&&r<224?i[a++]=(31&r)<<6|63&e[t++]:r>239&&r<365?(r=((7&r)<<18|(63&e[t++])<<12|(63&e[t++])<<6|63&e[t++])-65536,i[a++]=55296+(r>>10),i[a++]=56320+(1023&r)):i[a++]=(15&r)<<12|(63&e[t++])<<6|63&e[t++],a>8191&&((o||(o=[])).push(String.fromCharCode.apply(String,i)),a=0);return o?(a&&o.push(String.fromCharCode.apply(String,i.slice(0,a))),o.join("")):String.fromCharCode.apply(String,i.slice(0,a))},n.write=function(e,t,n){for(var r,o,i=n,a=0;a<e.length;++a)(r=e.charCodeAt(a))<128?t[n++]=r:r<2048?(t[n++]=r>>6|192,t[n++]=63&r|128):55296==(64512&r)&&56320==(64512&(o=e.charCodeAt(a+1)))?(r=65536+((1023&r)<<10)+(1023&o),++a,t[n++]=r>>18|240,t[n++]=r>>12&63|128,t[n++]=r>>6&63|128,t[n++]=63&r|128):(t[n++]=r>>12|224,t[n++]=r>>6&63|128,t[n++]=63&r|128);return n-i}},3442:(e,t)=>{"use strict";t.__esModule=!0;var n=function(){function e(t){if(!t)throw new TypeError("Invalid argument; `value` has no value.");this.value=e.EMPTY,t&&e.isGuid(t)&&(this.value=t)}return e.isGuid=function(t){var n=t.toString();return t&&(t instanceof e||e.validator.test(n))},e.create=function(){return new e([e.gen(2),e.gen(1),e.gen(1),e.gen(1),e.gen(3)].join("-"))},e.createEmpty=function(){return new e("emptyguid")},e.parse=function(t){return new e(t)},e.raw=function(){return[e.gen(2),e.gen(1),e.gen(1),e.gen(1),e.gen(3)].join("-")},e.gen=function(e){for(var t="",n=0;n<e;n++)t+=(65536*(1+Math.random())|0).toString(16).substring(1);return t},e.prototype.equals=function(t){return e.isGuid(t)&&this.value===t.toString()},e.prototype.isEmpty=function(){return this.value===e.EMPTY},e.prototype.toString=function(){return this.value},e.prototype.toJSON=function(){return{value:this.value}},e.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),e.EMPTY="00000000-0000-0000-0000-000000000000",e}();t.Guid=n},3720:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var o={},i={};function a(e,t){var n,r,a;return t?(a=0<=(e>>>=0)&&e<256)&&(r=i[e])?r:(n=u(e,(0|e)<0?-1:0,!0),a&&(i[e]=n),n):(a=-128<=(e|=0)&&e<128)&&(r=o[e])?r:(n=u(e,e<0?-1:0,!1),a&&(o[e]=n),n)}function s(e,t){if(isNaN(e))return t?b:m;if(t){if(e<0)return b;if(e>=f)return x}else{if(e<=-h)return T;if(e+1>=h)return v}return e<0?s(-e,t).neg():u(e%d|0,e/d|0,t)}function u(e,t,r){return new n(e,t,r)}n.fromInt=a,n.fromNumber=s,n.fromBits=u;var l=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return m;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var o=s(l(n,8)),i=m,a=0;a<e.length;a+=8){var u=Math.min(8,e.length-a),p=parseInt(e.substring(a,a+u),n);if(u<8){var d=s(l(n,u));i=i.mul(d).add(s(p))}else i=(i=i.mul(o)).add(s(p))}return i.unsigned=t,i}function p(e,t){return"number"==typeof e?s(e,t):"string"==typeof e?c(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=p;var d=4294967296,f=d*d,h=f/2,g=a(1<<24),m=a(0);n.ZERO=m;var b=a(0,!0);n.UZERO=b;var y=a(1);n.ONE=y;var w=a(1,!0);n.UONE=w;var _=a(-1);n.NEG_ONE=_;var v=u(-1,2147483647,!1);n.MAX_VALUE=v;var x=u(-1,-1,!0);n.MAX_UNSIGNED_VALUE=x;var T=u(0,-2147483648,!1);n.MIN_VALUE=T;var S=n.prototype;S.toInt=function(){return this.unsigned?this.low>>>0:this.low},S.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},S.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(T)){var t=s(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var o=s(l(e,6),this.unsigned),i=this,a="";;){var u=i.div(o),c=(i.sub(u.mul(o)).toInt()>>>0).toString(e);if((i=u).isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}},S.getHighBits=function(){return this.high},S.getHighBitsUnsigned=function(){return this.high>>>0},S.getLowBits=function(){return this.low},S.getLowBitsUnsigned=function(){return this.low>>>0},S.getNumBitsAbs=function(){if(this.isNegative())return this.eq(T)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},S.isZero=function(){return 0===this.high&&0===this.low},S.eqz=S.isZero,S.isNegative=function(){return!this.unsigned&&this.high<0},S.isPositive=function(){return this.unsigned||this.high>=0},S.isOdd=function(){return 1==(1&this.low)},S.isEven=function(){return 0==(1&this.low)},S.equals=function(e){return r(e)||(e=p(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},S.eq=S.equals,S.notEquals=function(e){return!this.eq(e)},S.neq=S.notEquals,S.ne=S.notEquals,S.lessThan=function(e){return this.comp(e)<0},S.lt=S.lessThan,S.lessThanOrEqual=function(e){return this.comp(e)<=0},S.lte=S.lessThanOrEqual,S.le=S.lessThanOrEqual,S.greaterThan=function(e){return this.comp(e)>0},S.gt=S.greaterThan,S.greaterThanOrEqual=function(e){return this.comp(e)>=0},S.gte=S.greaterThanOrEqual,S.ge=S.greaterThanOrEqual,S.compare=function(e){if(r(e)||(e=p(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},S.comp=S.compare,S.negate=function(){return!this.unsigned&&this.eq(T)?T:this.not().add(y)},S.neg=S.negate,S.add=function(e){r(e)||(e=p(e));var t=this.high>>>16,n=65535&this.high,o=this.low>>>16,i=65535&this.low,a=e.high>>>16,s=65535&e.high,l=e.low>>>16,c=0,d=0,f=0,h=0;return f+=(h+=i+(65535&e.low))>>>16,d+=(f+=o+l)>>>16,c+=(d+=n+s)>>>16,c+=t+a,u((f&=65535)<<16|(h&=65535),(c&=65535)<<16|(d&=65535),this.unsigned)},S.subtract=function(e){return r(e)||(e=p(e)),this.add(e.neg())},S.sub=S.subtract,S.multiply=function(e){if(this.isZero())return m;if(r(e)||(e=p(e)),t)return u(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return m;if(this.eq(T))return e.isOdd()?T:m;if(e.eq(T))return this.isOdd()?T:m;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(g)&&e.lt(g))return s(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,o=65535&this.high,i=this.low>>>16,a=65535&this.low,l=e.high>>>16,c=65535&e.high,d=e.low>>>16,f=65535&e.low,h=0,b=0,y=0,w=0;return y+=(w+=a*f)>>>16,b+=(y+=i*f)>>>16,y&=65535,b+=(y+=a*d)>>>16,h+=(b+=o*f)>>>16,b&=65535,h+=(b+=i*d)>>>16,b&=65535,h+=(b+=a*c)>>>16,h+=n*f+o*d+i*c+a*l,u((y&=65535)<<16|(w&=65535),(h&=65535)<<16|(b&=65535),this.unsigned)},S.mul=S.multiply,S.divide=function(e){if(r(e)||(e=p(e)),e.isZero())throw Error("division by zero");var n,o,i;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:m;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return w;i=b}else{if(this.eq(T))return e.eq(y)||e.eq(_)?T:e.eq(T)?y:(n=this.shr(1).div(e).shl(1)).eq(m)?e.isNegative()?y:_:(o=this.sub(e.mul(n)),i=n.add(o.div(e)));if(e.eq(T))return this.unsigned?b:m;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=m}for(o=this;o.gte(e);){n=Math.max(1,Math.floor(o.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),c=a<=48?1:l(2,a-48),d=s(n),f=d.mul(e);f.isNegative()||f.gt(o);)f=(d=s(n-=c,this.unsigned)).mul(e);d.isZero()&&(d=y),i=i.add(d),o=o.sub(f)}return i},S.div=S.divide,S.modulo=function(e){return r(e)||(e=p(e)),t?u((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},S.mod=S.modulo,S.rem=S.modulo,S.not=function(){return u(~this.low,~this.high,this.unsigned)},S.and=function(e){return r(e)||(e=p(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},S.or=function(e){return r(e)||(e=p(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},S.xor=function(e){return r(e)||(e=p(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},S.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},S.shl=S.shiftLeft,S.shiftRight=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},S.shr=S.shiftRight,S.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},S.shru=S.shiftRightUnsigned,S.shr_u=S.shiftRightUnsigned,S.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},S.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},S.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},S.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},S.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},1446:(e,t,n)=>{"use strict";var r,o,i,a=n(2100),s=a.Reader,u=a.Writer,l=a.util,c=a.roots.default||(a.roots.default={});c.onnx=((i={}).Version=(r={},(o=Object.create(r))[r[0]="_START_VERSION"]=0,o[r[1]="IR_VERSION_2017_10_10"]=1,o[r[2]="IR_VERSION_2017_10_30"]=2,o[r[3]="IR_VERSION_2017_11_3"]=3,o[r[4]="IR_VERSION_2019_1_22"]=4,o[r[5]="IR_VERSION"]=5,o),i.AttributeProto=function(){function e(e){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.name="",e.prototype.refAttrName="",e.prototype.docString="",e.prototype.type=0,e.prototype.f=0,e.prototype.i=l.Long?l.Long.fromBits(0,0,!1):0,e.prototype.s=l.newBuffer([]),e.prototype.t=null,e.prototype.g=null,e.prototype.floats=l.emptyArray,e.prototype.ints=l.emptyArray,e.prototype.strings=l.emptyArray,e.prototype.tensors=l.emptyArray,e.prototype.graphs=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.name&&e.hasOwnProperty("name")&&t.uint32(10).string(e.name),null!=e.f&&e.hasOwnProperty("f")&&t.uint32(21).float(e.f),null!=e.i&&e.hasOwnProperty("i")&&t.uint32(24).int64(e.i),null!=e.s&&e.hasOwnProperty("s")&&t.uint32(34).bytes(e.s),null!=e.t&&e.hasOwnProperty("t")&&c.onnx.TensorProto.encode(e.t,t.uint32(42).fork()).ldelim(),null!=e.g&&e.hasOwnProperty("g")&&c.onnx.GraphProto.encode(e.g,t.uint32(50).fork()).ldelim(),null!=e.floats&&e.floats.length){t.uint32(58).fork();for(var n=0;n<e.floats.length;++n)t.float(e.floats[n]);t.ldelim()}if(null!=e.ints&&e.ints.length){for(t.uint32(66).fork(),n=0;n<e.ints.length;++n)t.int64(e.ints[n]);t.ldelim()}if(null!=e.strings&&e.strings.length)for(n=0;n<e.strings.length;++n)t.uint32(74).bytes(e.strings[n]);if(null!=e.tensors&&e.tensors.length)for(n=0;n<e.tensors.length;++n)c.onnx.TensorProto.encode(e.tensors[n],t.uint32(82).fork()).ldelim();if(null!=e.graphs&&e.graphs.length)for(n=0;n<e.graphs.length;++n)c.onnx.GraphProto.encode(e.graphs[n],t.uint32(90).fork()).ldelim();return null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(106).string(e.docString),null!=e.type&&e.hasOwnProperty("type")&&t.uint32(160).int32(e.type),null!=e.refAttrName&&e.hasOwnProperty("refAttrName")&&t.uint32(170).string(e.refAttrName),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.AttributeProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.name=e.string();break;case 21:r.refAttrName=e.string();break;case 13:r.docString=e.string();break;case 20:r.type=e.int32();break;case 2:r.f=e.float();break;case 3:r.i=e.int64();break;case 4:r.s=e.bytes();break;case 5:r.t=c.onnx.TensorProto.decode(e,e.uint32());break;case 6:r.g=c.onnx.GraphProto.decode(e,e.uint32());break;case 7:if(r.floats&&r.floats.length||(r.floats=[]),2==(7&o))for(var i=e.uint32()+e.pos;e.pos<i;)r.floats.push(e.float());else r.floats.push(e.float());break;case 8:if(r.ints&&r.ints.length||(r.ints=[]),2==(7&o))for(i=e.uint32()+e.pos;e.pos<i;)r.ints.push(e.int64());else r.ints.push(e.int64());break;case 9:r.strings&&r.strings.length||(r.strings=[]),r.strings.push(e.bytes());break;case 10:r.tensors&&r.tensors.length||(r.tensors=[]),r.tensors.push(c.onnx.TensorProto.decode(e,e.uint32()));break;case 11:r.graphs&&r.graphs.length||(r.graphs=[]),r.graphs.push(c.onnx.GraphProto.decode(e,e.uint32()));break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.name&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(null!=e.refAttrName&&e.hasOwnProperty("refAttrName")&&!l.isString(e.refAttrName))return"refAttrName: string expected";if(null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString))return"docString: string expected";if(null!=e.type&&e.hasOwnProperty("type"))switch(e.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(null!=e.f&&e.hasOwnProperty("f")&&"number"!=typeof e.f)return"f: number expected";if(null!=e.i&&e.hasOwnProperty("i")&&!(l.isInteger(e.i)||e.i&&l.isInteger(e.i.low)&&l.isInteger(e.i.high)))return"i: integer|Long expected";if(null!=e.s&&e.hasOwnProperty("s")&&!(e.s&&"number"==typeof e.s.length||l.isString(e.s)))return"s: buffer expected";if(null!=e.t&&e.hasOwnProperty("t")&&(n=c.onnx.TensorProto.verify(e.t)))return"t."+n;if(null!=e.g&&e.hasOwnProperty("g")&&(n=c.onnx.GraphProto.verify(e.g)))return"g."+n;if(null!=e.floats&&e.hasOwnProperty("floats")){if(!Array.isArray(e.floats))return"floats: array expected";for(var t=0;t<e.floats.length;++t)if("number"!=typeof e.floats[t])return"floats: number[] expected"}if(null!=e.ints&&e.hasOwnProperty("ints")){if(!Array.isArray(e.ints))return"ints: array expected";for(t=0;t<e.ints.length;++t)if(!(l.isInteger(e.ints[t])||e.ints[t]&&l.isInteger(e.ints[t].low)&&l.isInteger(e.ints[t].high)))return"ints: integer|Long[] expected"}if(null!=e.strings&&e.hasOwnProperty("strings")){if(!Array.isArray(e.strings))return"strings: array expected";for(t=0;t<e.strings.length;++t)if(!(e.strings[t]&&"number"==typeof e.strings[t].length||l.isString(e.strings[t])))return"strings: buffer[] expected"}if(null!=e.tensors&&e.hasOwnProperty("tensors")){if(!Array.isArray(e.tensors))return"tensors: array expected";for(t=0;t<e.tensors.length;++t)if(n=c.onnx.TensorProto.verify(e.tensors[t]))return"tensors."+n}if(null!=e.graphs&&e.hasOwnProperty("graphs")){if(!Array.isArray(e.graphs))return"graphs: array expected";for(t=0;t<e.graphs.length;++t){var n;if(n=c.onnx.GraphProto.verify(e.graphs[t]))return"graphs."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.AttributeProto)return e;var t=new c.onnx.AttributeProto;switch(null!=e.name&&(t.name=String(e.name)),null!=e.refAttrName&&(t.refAttrName=String(e.refAttrName)),null!=e.docString&&(t.docString=String(e.docString)),e.type){case"UNDEFINED":case 0:t.type=0;break;case"FLOAT":case 1:t.type=1;break;case"INT":case 2:t.type=2;break;case"STRING":case 3:t.type=3;break;case"TENSOR":case 4:t.type=4;break;case"GRAPH":case 5:t.type=5;break;case"FLOATS":case 6:t.type=6;break;case"INTS":case 7:t.type=7;break;case"STRINGS":case 8:t.type=8;break;case"TENSORS":case 9:t.type=9;break;case"GRAPHS":case 10:t.type=10}if(null!=e.f&&(t.f=Number(e.f)),null!=e.i&&(l.Long?(t.i=l.Long.fromValue(e.i)).unsigned=!1:"string"==typeof e.i?t.i=parseInt(e.i,10):"number"==typeof e.i?t.i=e.i:"object"==typeof e.i&&(t.i=new l.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber())),null!=e.s&&("string"==typeof e.s?l.base64.decode(e.s,t.s=l.newBuffer(l.base64.length(e.s)),0):e.s.length&&(t.s=e.s)),null!=e.t){if("object"!=typeof e.t)throw TypeError(".onnx.AttributeProto.t: object expected");t.t=c.onnx.TensorProto.fromObject(e.t)}if(null!=e.g){if("object"!=typeof e.g)throw TypeError(".onnx.AttributeProto.g: object expected");t.g=c.onnx.GraphProto.fromObject(e.g)}if(e.floats){if(!Array.isArray(e.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");t.floats=[];for(var n=0;n<e.floats.length;++n)t.floats[n]=Number(e.floats[n])}if(e.ints){if(!Array.isArray(e.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(t.ints=[],n=0;n<e.ints.length;++n)l.Long?(t.ints[n]=l.Long.fromValue(e.ints[n])).unsigned=!1:"string"==typeof e.ints[n]?t.ints[n]=parseInt(e.ints[n],10):"number"==typeof e.ints[n]?t.ints[n]=e.ints[n]:"object"==typeof e.ints[n]&&(t.ints[n]=new l.LongBits(e.ints[n].low>>>0,e.ints[n].high>>>0).toNumber())}if(e.strings){if(!Array.isArray(e.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(t.strings=[],n=0;n<e.strings.length;++n)"string"==typeof e.strings[n]?l.base64.decode(e.strings[n],t.strings[n]=l.newBuffer(l.base64.length(e.strings[n])),0):e.strings[n].length&&(t.strings[n]=e.strings[n])}if(e.tensors){if(!Array.isArray(e.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(t.tensors=[],n=0;n<e.tensors.length;++n){if("object"!=typeof e.tensors[n])throw TypeError(".onnx.AttributeProto.tensors: object expected");t.tensors[n]=c.onnx.TensorProto.fromObject(e.tensors[n])}}if(e.graphs){if(!Array.isArray(e.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(t.graphs=[],n=0;n<e.graphs.length;++n){if("object"!=typeof e.graphs[n])throw TypeError(".onnx.AttributeProto.graphs: object expected");t.graphs[n]=c.onnx.GraphProto.fromObject(e.graphs[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.floats=[],n.ints=[],n.strings=[],n.tensors=[],n.graphs=[]),t.defaults){if(n.name="",n.f=0,l.Long){var r=new l.Long(0,0,!1);n.i=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.i=t.longs===String?"0":0;t.bytes===String?n.s="":(n.s=[],t.bytes!==Array&&(n.s=l.newBuffer(n.s))),n.t=null,n.g=null,n.docString="",n.type=t.enums===String?"UNDEFINED":0,n.refAttrName=""}if(null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),null!=e.f&&e.hasOwnProperty("f")&&(n.f=t.json&&!isFinite(e.f)?String(e.f):e.f),null!=e.i&&e.hasOwnProperty("i")&&("number"==typeof e.i?n.i=t.longs===String?String(e.i):e.i:n.i=t.longs===String?l.Long.prototype.toString.call(e.i):t.longs===Number?new l.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber():e.i),null!=e.s&&e.hasOwnProperty("s")&&(n.s=t.bytes===String?l.base64.encode(e.s,0,e.s.length):t.bytes===Array?Array.prototype.slice.call(e.s):e.s),null!=e.t&&e.hasOwnProperty("t")&&(n.t=c.onnx.TensorProto.toObject(e.t,t)),null!=e.g&&e.hasOwnProperty("g")&&(n.g=c.onnx.GraphProto.toObject(e.g,t)),e.floats&&e.floats.length){n.floats=[];for(var o=0;o<e.floats.length;++o)n.floats[o]=t.json&&!isFinite(e.floats[o])?String(e.floats[o]):e.floats[o]}if(e.ints&&e.ints.length)for(n.ints=[],o=0;o<e.ints.length;++o)"number"==typeof e.ints[o]?n.ints[o]=t.longs===String?String(e.ints[o]):e.ints[o]:n.ints[o]=t.longs===String?l.Long.prototype.toString.call(e.ints[o]):t.longs===Number?new l.LongBits(e.ints[o].low>>>0,e.ints[o].high>>>0).toNumber():e.ints[o];if(e.strings&&e.strings.length)for(n.strings=[],o=0;o<e.strings.length;++o)n.strings[o]=t.bytes===String?l.base64.encode(e.strings[o],0,e.strings[o].length):t.bytes===Array?Array.prototype.slice.call(e.strings[o]):e.strings[o];if(e.tensors&&e.tensors.length)for(n.tensors=[],o=0;o<e.tensors.length;++o)n.tensors[o]=c.onnx.TensorProto.toObject(e.tensors[o],t);if(e.graphs&&e.graphs.length)for(n.graphs=[],o=0;o<e.graphs.length;++o)n.graphs[o]=c.onnx.GraphProto.toObject(e.graphs[o],t);return null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),null!=e.type&&e.hasOwnProperty("type")&&(n.type=t.enums===String?c.onnx.AttributeProto.AttributeType[e.type]:e.type),null!=e.refAttrName&&e.hasOwnProperty("refAttrName")&&(n.refAttrName=e.refAttrName),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e.AttributeType=function(){var e={},t=Object.create(e);return t[e[0]="UNDEFINED"]=0,t[e[1]="FLOAT"]=1,t[e[2]="INT"]=2,t[e[3]="STRING"]=3,t[e[4]="TENSOR"]=4,t[e[5]="GRAPH"]=5,t[e[6]="FLOATS"]=6,t[e[7]="INTS"]=7,t[e[8]="STRINGS"]=8,t[e[9]="TENSORS"]=9,t[e[10]="GRAPHS"]=10,t}(),e}(),i.ValueInfoProto=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.name="",e.prototype.type=null,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.name&&e.hasOwnProperty("name")&&t.uint32(10).string(e.name),null!=e.type&&e.hasOwnProperty("type")&&c.onnx.TypeProto.encode(e.type,t.uint32(18).fork()).ldelim(),null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(26).string(e.docString),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.ValueInfoProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.name=e.string();break;case 2:r.type=c.onnx.TypeProto.decode(e,e.uint32());break;case 3:r.docString=e.string();break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.name&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(null!=e.type&&e.hasOwnProperty("type")){var t=c.onnx.TypeProto.verify(e.type);if(t)return"type."+t}return null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString)?"docString: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.ValueInfoProto)return e;var t=new c.onnx.ValueInfoProto;if(null!=e.name&&(t.name=String(e.name)),null!=e.type){if("object"!=typeof e.type)throw TypeError(".onnx.ValueInfoProto.type: object expected");t.type=c.onnx.TypeProto.fromObject(e.type)}return null!=e.docString&&(t.docString=String(e.docString)),t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.name="",n.type=null,n.docString=""),null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),null!=e.type&&e.hasOwnProperty("type")&&(n.type=c.onnx.TypeProto.toObject(e.type,t)),null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),i.NodeProto=function(){function e(e){if(this.input=[],this.output=[],this.attribute=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.input=l.emptyArray,e.prototype.output=l.emptyArray,e.prototype.name="",e.prototype.opType="",e.prototype.domain="",e.prototype.attribute=l.emptyArray,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.input&&e.input.length)for(var n=0;n<e.input.length;++n)t.uint32(10).string(e.input[n]);if(null!=e.output&&e.output.length)for(n=0;n<e.output.length;++n)t.uint32(18).string(e.output[n]);if(null!=e.name&&e.hasOwnProperty("name")&&t.uint32(26).string(e.name),null!=e.opType&&e.hasOwnProperty("opType")&&t.uint32(34).string(e.opType),null!=e.attribute&&e.attribute.length)for(n=0;n<e.attribute.length;++n)c.onnx.AttributeProto.encode(e.attribute[n],t.uint32(42).fork()).ldelim();return null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(50).string(e.docString),null!=e.domain&&e.hasOwnProperty("domain")&&t.uint32(58).string(e.domain),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.NodeProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.input&&r.input.length||(r.input=[]),r.input.push(e.string());break;case 2:r.output&&r.output.length||(r.output=[]),r.output.push(e.string());break;case 3:r.name=e.string();break;case 4:r.opType=e.string();break;case 7:r.domain=e.string();break;case 5:r.attribute&&r.attribute.length||(r.attribute=[]),r.attribute.push(c.onnx.AttributeProto.decode(e,e.uint32()));break;case 6:r.docString=e.string();break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.input&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(var t=0;t<e.input.length;++t)if(!l.isString(e.input[t]))return"input: string[] expected"}if(null!=e.output&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(t=0;t<e.output.length;++t)if(!l.isString(e.output[t]))return"output: string[] expected"}if(null!=e.name&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(null!=e.opType&&e.hasOwnProperty("opType")&&!l.isString(e.opType))return"opType: string expected";if(null!=e.domain&&e.hasOwnProperty("domain")&&!l.isString(e.domain))return"domain: string expected";if(null!=e.attribute&&e.hasOwnProperty("attribute")){if(!Array.isArray(e.attribute))return"attribute: array expected";for(t=0;t<e.attribute.length;++t){var n=c.onnx.AttributeProto.verify(e.attribute[t]);if(n)return"attribute."+n}}return null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString)?"docString: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.NodeProto)return e;var t=new c.onnx.NodeProto;if(e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.NodeProto.input: array expected");t.input=[];for(var n=0;n<e.input.length;++n)t.input[n]=String(e.input[n])}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.NodeProto.output: array expected");for(t.output=[],n=0;n<e.output.length;++n)t.output[n]=String(e.output[n])}if(null!=e.name&&(t.name=String(e.name)),null!=e.opType&&(t.opType=String(e.opType)),null!=e.domain&&(t.domain=String(e.domain)),e.attribute){if(!Array.isArray(e.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(t.attribute=[],n=0;n<e.attribute.length;++n){if("object"!=typeof e.attribute[n])throw TypeError(".onnx.NodeProto.attribute: object expected");t.attribute[n]=c.onnx.AttributeProto.fromObject(e.attribute[n])}}return null!=e.docString&&(t.docString=String(e.docString)),t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.input=[],n.output=[],n.attribute=[]),t.defaults&&(n.name="",n.opType="",n.docString="",n.domain=""),e.input&&e.input.length){n.input=[];for(var r=0;r<e.input.length;++r)n.input[r]=e.input[r]}if(e.output&&e.output.length)for(n.output=[],r=0;r<e.output.length;++r)n.output[r]=e.output[r];if(null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),null!=e.opType&&e.hasOwnProperty("opType")&&(n.opType=e.opType),e.attribute&&e.attribute.length)for(n.attribute=[],r=0;r<e.attribute.length;++r)n.attribute[r]=c.onnx.AttributeProto.toObject(e.attribute[r],t);return null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),null!=e.domain&&e.hasOwnProperty("domain")&&(n.domain=e.domain),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),i.ModelProto=function(){function e(e){if(this.opsetImport=[],this.metadataProps=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.irVersion=l.Long?l.Long.fromBits(0,0,!1):0,e.prototype.opsetImport=l.emptyArray,e.prototype.producerName="",e.prototype.producerVersion="",e.prototype.domain="",e.prototype.modelVersion=l.Long?l.Long.fromBits(0,0,!1):0,e.prototype.docString="",e.prototype.graph=null,e.prototype.metadataProps=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.irVersion&&e.hasOwnProperty("irVersion")&&t.uint32(8).int64(e.irVersion),null!=e.producerName&&e.hasOwnProperty("producerName")&&t.uint32(18).string(e.producerName),null!=e.producerVersion&&e.hasOwnProperty("producerVersion")&&t.uint32(26).string(e.producerVersion),null!=e.domain&&e.hasOwnProperty("domain")&&t.uint32(34).string(e.domain),null!=e.modelVersion&&e.hasOwnProperty("modelVersion")&&t.uint32(40).int64(e.modelVersion),null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(50).string(e.docString),null!=e.graph&&e.hasOwnProperty("graph")&&c.onnx.GraphProto.encode(e.graph,t.uint32(58).fork()).ldelim(),null!=e.opsetImport&&e.opsetImport.length)for(var n=0;n<e.opsetImport.length;++n)c.onnx.OperatorSetIdProto.encode(e.opsetImport[n],t.uint32(66).fork()).ldelim();if(null!=e.metadataProps&&e.metadataProps.length)for(n=0;n<e.metadataProps.length;++n)c.onnx.StringStringEntryProto.encode(e.metadataProps[n],t.uint32(114).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.ModelProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.irVersion=e.int64();break;case 8:r.opsetImport&&r.opsetImport.length||(r.opsetImport=[]),r.opsetImport.push(c.onnx.OperatorSetIdProto.decode(e,e.uint32()));break;case 2:r.producerName=e.string();break;case 3:r.producerVersion=e.string();break;case 4:r.domain=e.string();break;case 5:r.modelVersion=e.int64();break;case 6:r.docString=e.string();break;case 7:r.graph=c.onnx.GraphProto.decode(e,e.uint32());break;case 14:r.metadataProps&&r.metadataProps.length||(r.metadataProps=[]),r.metadataProps.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.irVersion&&e.hasOwnProperty("irVersion")&&!(l.isInteger(e.irVersion)||e.irVersion&&l.isInteger(e.irVersion.low)&&l.isInteger(e.irVersion.high)))return"irVersion: integer|Long expected";if(null!=e.opsetImport&&e.hasOwnProperty("opsetImport")){if(!Array.isArray(e.opsetImport))return"opsetImport: array expected";for(var t=0;t<e.opsetImport.length;++t)if(n=c.onnx.OperatorSetIdProto.verify(e.opsetImport[t]))return"opsetImport."+n}if(null!=e.producerName&&e.hasOwnProperty("producerName")&&!l.isString(e.producerName))return"producerName: string expected";if(null!=e.producerVersion&&e.hasOwnProperty("producerVersion")&&!l.isString(e.producerVersion))return"producerVersion: string expected";if(null!=e.domain&&e.hasOwnProperty("domain")&&!l.isString(e.domain))return"domain: string expected";if(null!=e.modelVersion&&e.hasOwnProperty("modelVersion")&&!(l.isInteger(e.modelVersion)||e.modelVersion&&l.isInteger(e.modelVersion.low)&&l.isInteger(e.modelVersion.high)))return"modelVersion: integer|Long expected";if(null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString))return"docString: string expected";if(null!=e.graph&&e.hasOwnProperty("graph")&&(n=c.onnx.GraphProto.verify(e.graph)))return"graph."+n;if(null!=e.metadataProps&&e.hasOwnProperty("metadataProps")){if(!Array.isArray(e.metadataProps))return"metadataProps: array expected";for(t=0;t<e.metadataProps.length;++t){var n;if(n=c.onnx.StringStringEntryProto.verify(e.metadataProps[t]))return"metadataProps."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.ModelProto)return e;var t=new c.onnx.ModelProto;if(null!=e.irVersion&&(l.Long?(t.irVersion=l.Long.fromValue(e.irVersion)).unsigned=!1:"string"==typeof e.irVersion?t.irVersion=parseInt(e.irVersion,10):"number"==typeof e.irVersion?t.irVersion=e.irVersion:"object"==typeof e.irVersion&&(t.irVersion=new l.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber())),e.opsetImport){if(!Array.isArray(e.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");t.opsetImport=[];for(var n=0;n<e.opsetImport.length;++n){if("object"!=typeof e.opsetImport[n])throw TypeError(".onnx.ModelProto.opsetImport: object expected");t.opsetImport[n]=c.onnx.OperatorSetIdProto.fromObject(e.opsetImport[n])}}if(null!=e.producerName&&(t.producerName=String(e.producerName)),null!=e.producerVersion&&(t.producerVersion=String(e.producerVersion)),null!=e.domain&&(t.domain=String(e.domain)),null!=e.modelVersion&&(l.Long?(t.modelVersion=l.Long.fromValue(e.modelVersion)).unsigned=!1:"string"==typeof e.modelVersion?t.modelVersion=parseInt(e.modelVersion,10):"number"==typeof e.modelVersion?t.modelVersion=e.modelVersion:"object"==typeof e.modelVersion&&(t.modelVersion=new l.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber())),null!=e.docString&&(t.docString=String(e.docString)),null!=e.graph){if("object"!=typeof e.graph)throw TypeError(".onnx.ModelProto.graph: object expected");t.graph=c.onnx.GraphProto.fromObject(e.graph)}if(e.metadataProps){if(!Array.isArray(e.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(t.metadataProps=[],n=0;n<e.metadataProps.length;++n){if("object"!=typeof e.metadataProps[n])throw TypeError(".onnx.ModelProto.metadataProps: object expected");t.metadataProps[n]=c.onnx.StringStringEntryProto.fromObject(e.metadataProps[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.opsetImport=[],n.metadataProps=[]),t.defaults){if(l.Long){var r=new l.Long(0,0,!1);n.irVersion=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.irVersion=t.longs===String?"0":0;n.producerName="",n.producerVersion="",n.domain="",l.Long?(r=new l.Long(0,0,!1),n.modelVersion=t.longs===String?r.toString():t.longs===Number?r.toNumber():r):n.modelVersion=t.longs===String?"0":0,n.docString="",n.graph=null}if(null!=e.irVersion&&e.hasOwnProperty("irVersion")&&("number"==typeof e.irVersion?n.irVersion=t.longs===String?String(e.irVersion):e.irVersion:n.irVersion=t.longs===String?l.Long.prototype.toString.call(e.irVersion):t.longs===Number?new l.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber():e.irVersion),null!=e.producerName&&e.hasOwnProperty("producerName")&&(n.producerName=e.producerName),null!=e.producerVersion&&e.hasOwnProperty("producerVersion")&&(n.producerVersion=e.producerVersion),null!=e.domain&&e.hasOwnProperty("domain")&&(n.domain=e.domain),null!=e.modelVersion&&e.hasOwnProperty("modelVersion")&&("number"==typeof e.modelVersion?n.modelVersion=t.longs===String?String(e.modelVersion):e.modelVersion:n.modelVersion=t.longs===String?l.Long.prototype.toString.call(e.modelVersion):t.longs===Number?new l.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber():e.modelVersion),null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),null!=e.graph&&e.hasOwnProperty("graph")&&(n.graph=c.onnx.GraphProto.toObject(e.graph,t)),e.opsetImport&&e.opsetImport.length){n.opsetImport=[];for(var o=0;o<e.opsetImport.length;++o)n.opsetImport[o]=c.onnx.OperatorSetIdProto.toObject(e.opsetImport[o],t)}if(e.metadataProps&&e.metadataProps.length)for(n.metadataProps=[],o=0;o<e.metadataProps.length;++o)n.metadataProps[o]=c.onnx.StringStringEntryProto.toObject(e.metadataProps[o],t);return n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),i.StringStringEntryProto=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.key="",e.prototype.value="",e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.key&&e.hasOwnProperty("key")&&t.uint32(10).string(e.key),null!=e.value&&e.hasOwnProperty("value")&&t.uint32(18).string(e.value),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.StringStringEntryProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.key=e.string();break;case 2:r.value=e.string();break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){return"object"!=typeof e||null===e?"object expected":null!=e.key&&e.hasOwnProperty("key")&&!l.isString(e.key)?"key: string expected":null!=e.value&&e.hasOwnProperty("value")&&!l.isString(e.value)?"value: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.StringStringEntryProto)return e;var t=new c.onnx.StringStringEntryProto;return null!=e.key&&(t.key=String(e.key)),null!=e.value&&(t.value=String(e.value)),t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.key="",n.value=""),null!=e.key&&e.hasOwnProperty("key")&&(n.key=e.key),null!=e.value&&e.hasOwnProperty("value")&&(n.value=e.value),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),i.TensorAnnotation=function(){function e(e){if(this.quantParameterTensorNames=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.tensorName="",e.prototype.quantParameterTensorNames=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.tensorName&&e.hasOwnProperty("tensorName")&&t.uint32(10).string(e.tensorName),null!=e.quantParameterTensorNames&&e.quantParameterTensorNames.length)for(var n=0;n<e.quantParameterTensorNames.length;++n)c.onnx.StringStringEntryProto.encode(e.quantParameterTensorNames[n],t.uint32(18).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorAnnotation;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.tensorName=e.string();break;case 2:r.quantParameterTensorNames&&r.quantParameterTensorNames.length||(r.quantParameterTensorNames=[]),r.quantParameterTensorNames.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.tensorName&&e.hasOwnProperty("tensorName")&&!l.isString(e.tensorName))return"tensorName: string expected";if(null!=e.quantParameterTensorNames&&e.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(e.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var t=0;t<e.quantParameterTensorNames.length;++t){var n=c.onnx.StringStringEntryProto.verify(e.quantParameterTensorNames[t]);if(n)return"quantParameterTensorNames."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.TensorAnnotation)return e;var t=new c.onnx.TensorAnnotation;if(null!=e.tensorName&&(t.tensorName=String(e.tensorName)),e.quantParameterTensorNames){if(!Array.isArray(e.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");t.quantParameterTensorNames=[];for(var n=0;n<e.quantParameterTensorNames.length;++n){if("object"!=typeof e.quantParameterTensorNames[n])throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");t.quantParameterTensorNames[n]=c.onnx.StringStringEntryProto.fromObject(e.quantParameterTensorNames[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.quantParameterTensorNames=[]),t.defaults&&(n.tensorName=""),null!=e.tensorName&&e.hasOwnProperty("tensorName")&&(n.tensorName=e.tensorName),e.quantParameterTensorNames&&e.quantParameterTensorNames.length){n.quantParameterTensorNames=[];for(var r=0;r<e.quantParameterTensorNames.length;++r)n.quantParameterTensorNames[r]=c.onnx.StringStringEntryProto.toObject(e.quantParameterTensorNames[r],t)}return n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),i.GraphProto=function(){function e(e){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.node=l.emptyArray,e.prototype.name="",e.prototype.initializer=l.emptyArray,e.prototype.docString="",e.prototype.input=l.emptyArray,e.prototype.output=l.emptyArray,e.prototype.valueInfo=l.emptyArray,e.prototype.quantizationAnnotation=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.node&&e.node.length)for(var n=0;n<e.node.length;++n)c.onnx.NodeProto.encode(e.node[n],t.uint32(10).fork()).ldelim();if(null!=e.name&&e.hasOwnProperty("name")&&t.uint32(18).string(e.name),null!=e.initializer&&e.initializer.length)for(n=0;n<e.initializer.length;++n)c.onnx.TensorProto.encode(e.initializer[n],t.uint32(42).fork()).ldelim();if(null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(82).string(e.docString),null!=e.input&&e.input.length)for(n=0;n<e.input.length;++n)c.onnx.ValueInfoProto.encode(e.input[n],t.uint32(90).fork()).ldelim();if(null!=e.output&&e.output.length)for(n=0;n<e.output.length;++n)c.onnx.ValueInfoProto.encode(e.output[n],t.uint32(98).fork()).ldelim();if(null!=e.valueInfo&&e.valueInfo.length)for(n=0;n<e.valueInfo.length;++n)c.onnx.ValueInfoProto.encode(e.valueInfo[n],t.uint32(106).fork()).ldelim();if(null!=e.quantizationAnnotation&&e.quantizationAnnotation.length)for(n=0;n<e.quantizationAnnotation.length;++n)c.onnx.TensorAnnotation.encode(e.quantizationAnnotation[n],t.uint32(114).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.GraphProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.node&&r.node.length||(r.node=[]),r.node.push(c.onnx.NodeProto.decode(e,e.uint32()));break;case 2:r.name=e.string();break;case 5:r.initializer&&r.initializer.length||(r.initializer=[]),r.initializer.push(c.onnx.TensorProto.decode(e,e.uint32()));break;case 10:r.docString=e.string();break;case 11:r.input&&r.input.length||(r.input=[]),r.input.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 12:r.output&&r.output.length||(r.output=[]),r.output.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 13:r.valueInfo&&r.valueInfo.length||(r.valueInfo=[]),r.valueInfo.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 14:r.quantizationAnnotation&&r.quantizationAnnotation.length||(r.quantizationAnnotation=[]),r.quantizationAnnotation.push(c.onnx.TensorAnnotation.decode(e,e.uint32()));break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.node&&e.hasOwnProperty("node")){if(!Array.isArray(e.node))return"node: array expected";for(var t=0;t<e.node.length;++t)if(n=c.onnx.NodeProto.verify(e.node[t]))return"node."+n}if(null!=e.name&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(null!=e.initializer&&e.hasOwnProperty("initializer")){if(!Array.isArray(e.initializer))return"initializer: array expected";for(t=0;t<e.initializer.length;++t)if(n=c.onnx.TensorProto.verify(e.initializer[t]))return"initializer."+n}if(null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString))return"docString: string expected";if(null!=e.input&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(t=0;t<e.input.length;++t)if(n=c.onnx.ValueInfoProto.verify(e.input[t]))return"input."+n}if(null!=e.output&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(t=0;t<e.output.length;++t)if(n=c.onnx.ValueInfoProto.verify(e.output[t]))return"output."+n}if(null!=e.valueInfo&&e.hasOwnProperty("valueInfo")){if(!Array.isArray(e.valueInfo))return"valueInfo: array expected";for(t=0;t<e.valueInfo.length;++t)if(n=c.onnx.ValueInfoProto.verify(e.valueInfo[t]))return"valueInfo."+n}if(null!=e.quantizationAnnotation&&e.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(e.quantizationAnnotation))return"quantizationAnnotation: array expected";for(t=0;t<e.quantizationAnnotation.length;++t){var n;if(n=c.onnx.TensorAnnotation.verify(e.quantizationAnnotation[t]))return"quantizationAnnotation."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.GraphProto)return e;var t=new c.onnx.GraphProto;if(e.node){if(!Array.isArray(e.node))throw TypeError(".onnx.GraphProto.node: array expected");t.node=[];for(var n=0;n<e.node.length;++n){if("object"!=typeof e.node[n])throw TypeError(".onnx.GraphProto.node: object expected");t.node[n]=c.onnx.NodeProto.fromObject(e.node[n])}}if(null!=e.name&&(t.name=String(e.name)),e.initializer){if(!Array.isArray(e.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(t.initializer=[],n=0;n<e.initializer.length;++n){if("object"!=typeof e.initializer[n])throw TypeError(".onnx.GraphProto.initializer: object expected");t.initializer[n]=c.onnx.TensorProto.fromObject(e.initializer[n])}}if(null!=e.docString&&(t.docString=String(e.docString)),e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.GraphProto.input: array expected");for(t.input=[],n=0;n<e.input.length;++n){if("object"!=typeof e.input[n])throw TypeError(".onnx.GraphProto.input: object expected");t.input[n]=c.onnx.ValueInfoProto.fromObject(e.input[n])}}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.GraphProto.output: array expected");for(t.output=[],n=0;n<e.output.length;++n){if("object"!=typeof e.output[n])throw TypeError(".onnx.GraphProto.output: object expected");t.output[n]=c.onnx.ValueInfoProto.fromObject(e.output[n])}}if(e.valueInfo){if(!Array.isArray(e.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(t.valueInfo=[],n=0;n<e.valueInfo.length;++n){if("object"!=typeof e.valueInfo[n])throw TypeError(".onnx.GraphProto.valueInfo: object expected");t.valueInfo[n]=c.onnx.ValueInfoProto.fromObject(e.valueInfo[n])}}if(e.quantizationAnnotation){if(!Array.isArray(e.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(t.quantizationAnnotation=[],n=0;n<e.quantizationAnnotation.length;++n){if("object"!=typeof e.quantizationAnnotation[n])throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");t.quantizationAnnotation[n]=c.onnx.TensorAnnotation.fromObject(e.quantizationAnnotation[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.node=[],n.initializer=[],n.input=[],n.output=[],n.valueInfo=[],n.quantizationAnnotation=[]),t.defaults&&(n.name="",n.docString=""),e.node&&e.node.length){n.node=[];for(var r=0;r<e.node.length;++r)n.node[r]=c.onnx.NodeProto.toObject(e.node[r],t)}if(null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),e.initializer&&e.initializer.length)for(n.initializer=[],r=0;r<e.initializer.length;++r)n.initializer[r]=c.onnx.TensorProto.toObject(e.initializer[r],t);if(null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),e.input&&e.input.length)for(n.input=[],r=0;r<e.input.length;++r)n.input[r]=c.onnx.ValueInfoProto.toObject(e.input[r],t);if(e.output&&e.output.length)for(n.output=[],r=0;r<e.output.length;++r)n.output[r]=c.onnx.ValueInfoProto.toObject(e.output[r],t);if(e.valueInfo&&e.valueInfo.length)for(n.valueInfo=[],r=0;r<e.valueInfo.length;++r)n.valueInfo[r]=c.onnx.ValueInfoProto.toObject(e.valueInfo[r],t);if(e.quantizationAnnotation&&e.quantizationAnnotation.length)for(n.quantizationAnnotation=[],r=0;r<e.quantizationAnnotation.length;++r)n.quantizationAnnotation[r]=c.onnx.TensorAnnotation.toObject(e.quantizationAnnotation[r],t);return n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),i.TensorProto=function(){function e(e){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.dims=l.emptyArray,e.prototype.dataType=0,e.prototype.segment=null,e.prototype.floatData=l.emptyArray,e.prototype.int32Data=l.emptyArray,e.prototype.stringData=l.emptyArray,e.prototype.int64Data=l.emptyArray,e.prototype.name="",e.prototype.docString="",e.prototype.rawData=l.newBuffer([]),e.prototype.externalData=l.emptyArray,e.prototype.dataLocation=0,e.prototype.doubleData=l.emptyArray,e.prototype.uint64Data=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.dims&&e.dims.length){t.uint32(10).fork();for(var n=0;n<e.dims.length;++n)t.int64(e.dims[n]);t.ldelim()}if(null!=e.dataType&&e.hasOwnProperty("dataType")&&t.uint32(16).int32(e.dataType),null!=e.segment&&e.hasOwnProperty("segment")&&c.onnx.TensorProto.Segment.encode(e.segment,t.uint32(26).fork()).ldelim(),null!=e.floatData&&e.floatData.length){for(t.uint32(34).fork(),n=0;n<e.floatData.length;++n)t.float(e.floatData[n]);t.ldelim()}if(null!=e.int32Data&&e.int32Data.length){for(t.uint32(42).fork(),n=0;n<e.int32Data.length;++n)t.int32(e.int32Data[n]);t.ldelim()}if(null!=e.stringData&&e.stringData.length)for(n=0;n<e.stringData.length;++n)t.uint32(50).bytes(e.stringData[n]);if(null!=e.int64Data&&e.int64Data.length){for(t.uint32(58).fork(),n=0;n<e.int64Data.length;++n)t.int64(e.int64Data[n]);t.ldelim()}if(null!=e.name&&e.hasOwnProperty("name")&&t.uint32(66).string(e.name),null!=e.rawData&&e.hasOwnProperty("rawData")&&t.uint32(74).bytes(e.rawData),null!=e.doubleData&&e.doubleData.length){for(t.uint32(82).fork(),n=0;n<e.doubleData.length;++n)t.double(e.doubleData[n]);t.ldelim()}if(null!=e.uint64Data&&e.uint64Data.length){for(t.uint32(90).fork(),n=0;n<e.uint64Data.length;++n)t.uint64(e.uint64Data[n]);t.ldelim()}if(null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(98).string(e.docString),null!=e.externalData&&e.externalData.length)for(n=0;n<e.externalData.length;++n)c.onnx.StringStringEntryProto.encode(e.externalData[n],t.uint32(106).fork()).ldelim();return null!=e.dataLocation&&e.hasOwnProperty("dataLocation")&&t.uint32(112).int32(e.dataLocation),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:if(r.dims&&r.dims.length||(r.dims=[]),2==(7&o))for(var i=e.uint32()+e.pos;e.pos<i;)r.dims.push(e.int64());else r.dims.push(e.int64());break;case 2:r.dataType=e.int32();break;case 3:r.segment=c.onnx.TensorProto.Segment.decode(e,e.uint32());break;case 4:if(r.floatData&&r.floatData.length||(r.floatData=[]),2==(7&o))for(i=e.uint32()+e.pos;e.pos<i;)r.floatData.push(e.float());else r.floatData.push(e.float());break;case 5:if(r.int32Data&&r.int32Data.length||(r.int32Data=[]),2==(7&o))for(i=e.uint32()+e.pos;e.pos<i;)r.int32Data.push(e.int32());else r.int32Data.push(e.int32());break;case 6:r.stringData&&r.stringData.length||(r.stringData=[]),r.stringData.push(e.bytes());break;case 7:if(r.int64Data&&r.int64Data.length||(r.int64Data=[]),2==(7&o))for(i=e.uint32()+e.pos;e.pos<i;)r.int64Data.push(e.int64());else r.int64Data.push(e.int64());break;case 8:r.name=e.string();break;case 12:r.docString=e.string();break;case 9:r.rawData=e.bytes();break;case 13:r.externalData&&r.externalData.length||(r.externalData=[]),r.externalData.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break;case 14:r.dataLocation=e.int32();break;case 10:if(r.doubleData&&r.doubleData.length||(r.doubleData=[]),2==(7&o))for(i=e.uint32()+e.pos;e.pos<i;)r.doubleData.push(e.double());else r.doubleData.push(e.double());break;case 11:if(r.uint64Data&&r.uint64Data.length||(r.uint64Data=[]),2==(7&o))for(i=e.uint32()+e.pos;e.pos<i;)r.uint64Data.push(e.uint64());else r.uint64Data.push(e.uint64());break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.dims&&e.hasOwnProperty("dims")){if(!Array.isArray(e.dims))return"dims: array expected";for(var t=0;t<e.dims.length;++t)if(!(l.isInteger(e.dims[t])||e.dims[t]&&l.isInteger(e.dims[t].low)&&l.isInteger(e.dims[t].high)))return"dims: integer|Long[] expected"}if(null!=e.dataType&&e.hasOwnProperty("dataType")&&!l.isInteger(e.dataType))return"dataType: integer expected";if(null!=e.segment&&e.hasOwnProperty("segment")&&(n=c.onnx.TensorProto.Segment.verify(e.segment)))return"segment."+n;if(null!=e.floatData&&e.hasOwnProperty("floatData")){if(!Array.isArray(e.floatData))return"floatData: array expected";for(t=0;t<e.floatData.length;++t)if("number"!=typeof e.floatData[t])return"floatData: number[] expected"}if(null!=e.int32Data&&e.hasOwnProperty("int32Data")){if(!Array.isArray(e.int32Data))return"int32Data: array expected";for(t=0;t<e.int32Data.length;++t)if(!l.isInteger(e.int32Data[t]))return"int32Data: integer[] expected"}if(null!=e.stringData&&e.hasOwnProperty("stringData")){if(!Array.isArray(e.stringData))return"stringData: array expected";for(t=0;t<e.stringData.length;++t)if(!(e.stringData[t]&&"number"==typeof e.stringData[t].length||l.isString(e.stringData[t])))return"stringData: buffer[] expected"}if(null!=e.int64Data&&e.hasOwnProperty("int64Data")){if(!Array.isArray(e.int64Data))return"int64Data: array expected";for(t=0;t<e.int64Data.length;++t)if(!(l.isInteger(e.int64Data[t])||e.int64Data[t]&&l.isInteger(e.int64Data[t].low)&&l.isInteger(e.int64Data[t].high)))return"int64Data: integer|Long[] expected"}if(null!=e.name&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString))return"docString: string expected";if(null!=e.rawData&&e.hasOwnProperty("rawData")&&!(e.rawData&&"number"==typeof e.rawData.length||l.isString(e.rawData)))return"rawData: buffer expected";if(null!=e.externalData&&e.hasOwnProperty("externalData")){if(!Array.isArray(e.externalData))return"externalData: array expected";for(t=0;t<e.externalData.length;++t){var n;if(n=c.onnx.StringStringEntryProto.verify(e.externalData[t]))return"externalData."+n}}if(null!=e.dataLocation&&e.hasOwnProperty("dataLocation"))switch(e.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(null!=e.doubleData&&e.hasOwnProperty("doubleData")){if(!Array.isArray(e.doubleData))return"doubleData: array expected";for(t=0;t<e.doubleData.length;++t)if("number"!=typeof e.doubleData[t])return"doubleData: number[] expected"}if(null!=e.uint64Data&&e.hasOwnProperty("uint64Data")){if(!Array.isArray(e.uint64Data))return"uint64Data: array expected";for(t=0;t<e.uint64Data.length;++t)if(!(l.isInteger(e.uint64Data[t])||e.uint64Data[t]&&l.isInteger(e.uint64Data[t].low)&&l.isInteger(e.uint64Data[t].high)))return"uint64Data: integer|Long[] expected"}return null},e.fromObject=function(e){if(e instanceof c.onnx.TensorProto)return e;var t=new c.onnx.TensorProto;if(e.dims){if(!Array.isArray(e.dims))throw TypeError(".onnx.TensorProto.dims: array expected");t.dims=[];for(var n=0;n<e.dims.length;++n)l.Long?(t.dims[n]=l.Long.fromValue(e.dims[n])).unsigned=!1:"string"==typeof e.dims[n]?t.dims[n]=parseInt(e.dims[n],10):"number"==typeof e.dims[n]?t.dims[n]=e.dims[n]:"object"==typeof e.dims[n]&&(t.dims[n]=new l.LongBits(e.dims[n].low>>>0,e.dims[n].high>>>0).toNumber())}if(null!=e.dataType&&(t.dataType=0|e.dataType),null!=e.segment){if("object"!=typeof e.segment)throw TypeError(".onnx.TensorProto.segment: object expected");t.segment=c.onnx.TensorProto.Segment.fromObject(e.segment)}if(e.floatData){if(!Array.isArray(e.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(t.floatData=[],n=0;n<e.floatData.length;++n)t.floatData[n]=Number(e.floatData[n])}if(e.int32Data){if(!Array.isArray(e.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(t.int32Data=[],n=0;n<e.int32Data.length;++n)t.int32Data[n]=0|e.int32Data[n]}if(e.stringData){if(!Array.isArray(e.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(t.stringData=[],n=0;n<e.stringData.length;++n)"string"==typeof e.stringData[n]?l.base64.decode(e.stringData[n],t.stringData[n]=l.newBuffer(l.base64.length(e.stringData[n])),0):e.stringData[n].length&&(t.stringData[n]=e.stringData[n])}if(e.int64Data){if(!Array.isArray(e.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(t.int64Data=[],n=0;n<e.int64Data.length;++n)l.Long?(t.int64Data[n]=l.Long.fromValue(e.int64Data[n])).unsigned=!1:"string"==typeof e.int64Data[n]?t.int64Data[n]=parseInt(e.int64Data[n],10):"number"==typeof e.int64Data[n]?t.int64Data[n]=e.int64Data[n]:"object"==typeof e.int64Data[n]&&(t.int64Data[n]=new l.LongBits(e.int64Data[n].low>>>0,e.int64Data[n].high>>>0).toNumber())}if(null!=e.name&&(t.name=String(e.name)),null!=e.docString&&(t.docString=String(e.docString)),null!=e.rawData&&("string"==typeof e.rawData?l.base64.decode(e.rawData,t.rawData=l.newBuffer(l.base64.length(e.rawData)),0):e.rawData.length&&(t.rawData=e.rawData)),e.externalData){if(!Array.isArray(e.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(t.externalData=[],n=0;n<e.externalData.length;++n){if("object"!=typeof e.externalData[n])throw TypeError(".onnx.TensorProto.externalData: object expected");t.externalData[n]=c.onnx.StringStringEntryProto.fromObject(e.externalData[n])}}switch(e.dataLocation){case"DEFAULT":case 0:t.dataLocation=0;break;case"EXTERNAL":case 1:t.dataLocation=1}if(e.doubleData){if(!Array.isArray(e.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(t.doubleData=[],n=0;n<e.doubleData.length;++n)t.doubleData[n]=Number(e.doubleData[n])}if(e.uint64Data){if(!Array.isArray(e.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(t.uint64Data=[],n=0;n<e.uint64Data.length;++n)l.Long?(t.uint64Data[n]=l.Long.fromValue(e.uint64Data[n])).unsigned=!0:"string"==typeof e.uint64Data[n]?t.uint64Data[n]=parseInt(e.uint64Data[n],10):"number"==typeof e.uint64Data[n]?t.uint64Data[n]=e.uint64Data[n]:"object"==typeof e.uint64Data[n]&&(t.uint64Data[n]=new l.LongBits(e.uint64Data[n].low>>>0,e.uint64Data[n].high>>>0).toNumber(!0))}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.dims=[],n.floatData=[],n.int32Data=[],n.stringData=[],n.int64Data=[],n.doubleData=[],n.uint64Data=[],n.externalData=[]),t.defaults&&(n.dataType=0,n.segment=null,n.name="",t.bytes===String?n.rawData="":(n.rawData=[],t.bytes!==Array&&(n.rawData=l.newBuffer(n.rawData))),n.docString="",n.dataLocation=t.enums===String?"DEFAULT":0),e.dims&&e.dims.length){n.dims=[];for(var r=0;r<e.dims.length;++r)"number"==typeof e.dims[r]?n.dims[r]=t.longs===String?String(e.dims[r]):e.dims[r]:n.dims[r]=t.longs===String?l.Long.prototype.toString.call(e.dims[r]):t.longs===Number?new l.LongBits(e.dims[r].low>>>0,e.dims[r].high>>>0).toNumber():e.dims[r]}if(null!=e.dataType&&e.hasOwnProperty("dataType")&&(n.dataType=e.dataType),null!=e.segment&&e.hasOwnProperty("segment")&&(n.segment=c.onnx.TensorProto.Segment.toObject(e.segment,t)),e.floatData&&e.floatData.length)for(n.floatData=[],r=0;r<e.floatData.length;++r)n.floatData[r]=t.json&&!isFinite(e.floatData[r])?String(e.floatData[r]):e.floatData[r];if(e.int32Data&&e.int32Data.length)for(n.int32Data=[],r=0;r<e.int32Data.length;++r)n.int32Data[r]=e.int32Data[r];if(e.stringData&&e.stringData.length)for(n.stringData=[],r=0;r<e.stringData.length;++r)n.stringData[r]=t.bytes===String?l.base64.encode(e.stringData[r],0,e.stringData[r].length):t.bytes===Array?Array.prototype.slice.call(e.stringData[r]):e.stringData[r];if(e.int64Data&&e.int64Data.length)for(n.int64Data=[],r=0;r<e.int64Data.length;++r)"number"==typeof e.int64Data[r]?n.int64Data[r]=t.longs===String?String(e.int64Data[r]):e.int64Data[r]:n.int64Data[r]=t.longs===String?l.Long.prototype.toString.call(e.int64Data[r]):t.longs===Number?new l.LongBits(e.int64Data[r].low>>>0,e.int64Data[r].high>>>0).toNumber():e.int64Data[r];if(null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),null!=e.rawData&&e.hasOwnProperty("rawData")&&(n.rawData=t.bytes===String?l.base64.encode(e.rawData,0,e.rawData.length):t.bytes===Array?Array.prototype.slice.call(e.rawData):e.rawData),e.doubleData&&e.doubleData.length)for(n.doubleData=[],r=0;r<e.doubleData.length;++r)n.doubleData[r]=t.json&&!isFinite(e.doubleData[r])?String(e.doubleData[r]):e.doubleData[r];if(e.uint64Data&&e.uint64Data.length)for(n.uint64Data=[],r=0;r<e.uint64Data.length;++r)"number"==typeof e.uint64Data[r]?n.uint64Data[r]=t.longs===String?String(e.uint64Data[r]):e.uint64Data[r]:n.uint64Data[r]=t.longs===String?l.Long.prototype.toString.call(e.uint64Data[r]):t.longs===Number?new l.LongBits(e.uint64Data[r].low>>>0,e.uint64Data[r].high>>>0).toNumber(!0):e.uint64Data[r];if(null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),e.externalData&&e.externalData.length)for(n.externalData=[],r=0;r<e.externalData.length;++r)n.externalData[r]=c.onnx.StringStringEntryProto.toObject(e.externalData[r],t);return null!=e.dataLocation&&e.hasOwnProperty("dataLocation")&&(n.dataLocation=t.enums===String?c.onnx.TensorProto.DataLocation[e.dataLocation]:e.dataLocation),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e.DataType=function(){var e={},t=Object.create(e);return t[e[0]="UNDEFINED"]=0,t[e[1]="FLOAT"]=1,t[e[2]="UINT8"]=2,t[e[3]="INT8"]=3,t[e[4]="UINT16"]=4,t[e[5]="INT16"]=5,t[e[6]="INT32"]=6,t[e[7]="INT64"]=7,t[e[8]="STRING"]=8,t[e[9]="BOOL"]=9,t[e[10]="FLOAT16"]=10,t[e[11]="DOUBLE"]=11,t[e[12]="UINT32"]=12,t[e[13]="UINT64"]=13,t[e[14]="COMPLEX64"]=14,t[e[15]="COMPLEX128"]=15,t[e[16]="BFLOAT16"]=16,t}(),e.Segment=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.begin=l.Long?l.Long.fromBits(0,0,!1):0,e.prototype.end=l.Long?l.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.begin&&e.hasOwnProperty("begin")&&t.uint32(8).int64(e.begin),null!=e.end&&e.hasOwnProperty("end")&&t.uint32(16).int64(e.end),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorProto.Segment;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.begin=e.int64();break;case 2:r.end=e.int64();break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){return"object"!=typeof e||null===e?"object expected":null!=e.begin&&e.hasOwnProperty("begin")&&!(l.isInteger(e.begin)||e.begin&&l.isInteger(e.begin.low)&&l.isInteger(e.begin.high))?"begin: integer|Long expected":null!=e.end&&e.hasOwnProperty("end")&&!(l.isInteger(e.end)||e.end&&l.isInteger(e.end.low)&&l.isInteger(e.end.high))?"end: integer|Long expected":null},e.fromObject=function(e){if(e instanceof c.onnx.TensorProto.Segment)return e;var t=new c.onnx.TensorProto.Segment;return null!=e.begin&&(l.Long?(t.begin=l.Long.fromValue(e.begin)).unsigned=!1:"string"==typeof e.begin?t.begin=parseInt(e.begin,10):"number"==typeof e.begin?t.begin=e.begin:"object"==typeof e.begin&&(t.begin=new l.LongBits(e.begin.low>>>0,e.begin.high>>>0).toNumber())),null!=e.end&&(l.Long?(t.end=l.Long.fromValue(e.end)).unsigned=!1:"string"==typeof e.end?t.end=parseInt(e.end,10):"number"==typeof e.end?t.end=e.end:"object"==typeof e.end&&(t.end=new l.LongBits(e.end.low>>>0,e.end.high>>>0).toNumber())),t},e.toObject=function(e,t){t||(t={});var n={};if(t.defaults){if(l.Long){var r=new l.Long(0,0,!1);n.begin=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.begin=t.longs===String?"0":0;l.Long?(r=new l.Long(0,0,!1),n.end=t.longs===String?r.toString():t.longs===Number?r.toNumber():r):n.end=t.longs===String?"0":0}return null!=e.begin&&e.hasOwnProperty("begin")&&("number"==typeof e.begin?n.begin=t.longs===String?String(e.begin):e.begin:n.begin=t.longs===String?l.Long.prototype.toString.call(e.begin):t.longs===Number?new l.LongBits(e.begin.low>>>0,e.begin.high>>>0).toNumber():e.begin),null!=e.end&&e.hasOwnProperty("end")&&("number"==typeof e.end?n.end=t.longs===String?String(e.end):e.end:n.end=t.longs===String?l.Long.prototype.toString.call(e.end):t.longs===Number?new l.LongBits(e.end.low>>>0,e.end.high>>>0).toNumber():e.end),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),e.DataLocation=function(){var e={},t=Object.create(e);return t[e[0]="DEFAULT"]=0,t[e[1]="EXTERNAL"]=1,t}(),e}(),i.TensorShapeProto=function(){function e(e){if(this.dim=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.dim=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.dim&&e.dim.length)for(var n=0;n<e.dim.length;++n)c.onnx.TensorShapeProto.Dimension.encode(e.dim[n],t.uint32(10).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorShapeProto;e.pos<n;){var o=e.uint32();o>>>3==1?(r.dim&&r.dim.length||(r.dim=[]),r.dim.push(c.onnx.TensorShapeProto.Dimension.decode(e,e.uint32()))):e.skipType(7&o)}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.dim&&e.hasOwnProperty("dim")){if(!Array.isArray(e.dim))return"dim: array expected";for(var t=0;t<e.dim.length;++t){var n=c.onnx.TensorShapeProto.Dimension.verify(e.dim[t]);if(n)return"dim."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.TensorShapeProto)return e;var t=new c.onnx.TensorShapeProto;if(e.dim){if(!Array.isArray(e.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");t.dim=[];for(var n=0;n<e.dim.length;++n){if("object"!=typeof e.dim[n])throw TypeError(".onnx.TensorShapeProto.dim: object expected");t.dim[n]=c.onnx.TensorShapeProto.Dimension.fromObject(e.dim[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.dim=[]),e.dim&&e.dim.length){n.dim=[];for(var r=0;r<e.dim.length;++r)n.dim[r]=c.onnx.TensorShapeProto.Dimension.toObject(e.dim[r],t)}return n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e.Dimension=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}var t;return e.prototype.dimValue=l.Long?l.Long.fromBits(0,0,!1):0,e.prototype.dimParam="",e.prototype.denotation="",Object.defineProperty(e.prototype,"value",{get:l.oneOfGetter(t=["dimValue","dimParam"]),set:l.oneOfSetter(t)}),e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.dimValue&&e.hasOwnProperty("dimValue")&&t.uint32(8).int64(e.dimValue),null!=e.dimParam&&e.hasOwnProperty("dimParam")&&t.uint32(18).string(e.dimParam),null!=e.denotation&&e.hasOwnProperty("denotation")&&t.uint32(26).string(e.denotation),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorShapeProto.Dimension;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.dimValue=e.int64();break;case 2:r.dimParam=e.string();break;case 3:r.denotation=e.string();break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";var t={};if(null!=e.dimValue&&e.hasOwnProperty("dimValue")&&(t.value=1,!(l.isInteger(e.dimValue)||e.dimValue&&l.isInteger(e.dimValue.low)&&l.isInteger(e.dimValue.high))))return"dimValue: integer|Long expected";if(null!=e.dimParam&&e.hasOwnProperty("dimParam")){if(1===t.value)return"value: multiple values";if(t.value=1,!l.isString(e.dimParam))return"dimParam: string expected"}return null!=e.denotation&&e.hasOwnProperty("denotation")&&!l.isString(e.denotation)?"denotation: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.TensorShapeProto.Dimension)return e;var t=new c.onnx.TensorShapeProto.Dimension;return null!=e.dimValue&&(l.Long?(t.dimValue=l.Long.fromValue(e.dimValue)).unsigned=!1:"string"==typeof e.dimValue?t.dimValue=parseInt(e.dimValue,10):"number"==typeof e.dimValue?t.dimValue=e.dimValue:"object"==typeof e.dimValue&&(t.dimValue=new l.LongBits(e.dimValue.low>>>0,e.dimValue.high>>>0).toNumber())),null!=e.dimParam&&(t.dimParam=String(e.dimParam)),null!=e.denotation&&(t.denotation=String(e.denotation)),t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.denotation=""),null!=e.dimValue&&e.hasOwnProperty("dimValue")&&("number"==typeof e.dimValue?n.dimValue=t.longs===String?String(e.dimValue):e.dimValue:n.dimValue=t.longs===String?l.Long.prototype.toString.call(e.dimValue):t.longs===Number?new l.LongBits(e.dimValue.low>>>0,e.dimValue.high>>>0).toNumber():e.dimValue,t.oneofs&&(n.value="dimValue")),null!=e.dimParam&&e.hasOwnProperty("dimParam")&&(n.dimParam=e.dimParam,t.oneofs&&(n.value="dimParam")),null!=e.denotation&&e.hasOwnProperty("denotation")&&(n.denotation=e.denotation),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),e}(),i.TypeProto=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}var t;return e.prototype.tensorType=null,e.prototype.denotation="",Object.defineProperty(e.prototype,"value",{get:l.oneOfGetter(t=["tensorType"]),set:l.oneOfSetter(t)}),e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.tensorType&&e.hasOwnProperty("tensorType")&&c.onnx.TypeProto.Tensor.encode(e.tensorType,t.uint32(10).fork()).ldelim(),null!=e.denotation&&e.hasOwnProperty("denotation")&&t.uint32(50).string(e.denotation),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TypeProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.tensorType=c.onnx.TypeProto.Tensor.decode(e,e.uint32());break;case 6:r.denotation=e.string();break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.tensorType&&e.hasOwnProperty("tensorType")){var t=c.onnx.TypeProto.Tensor.verify(e.tensorType);if(t)return"tensorType."+t}return null!=e.denotation&&e.hasOwnProperty("denotation")&&!l.isString(e.denotation)?"denotation: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.TypeProto)return e;var t=new c.onnx.TypeProto;if(null!=e.tensorType){if("object"!=typeof e.tensorType)throw TypeError(".onnx.TypeProto.tensorType: object expected");t.tensorType=c.onnx.TypeProto.Tensor.fromObject(e.tensorType)}return null!=e.denotation&&(t.denotation=String(e.denotation)),t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.denotation=""),null!=e.tensorType&&e.hasOwnProperty("tensorType")&&(n.tensorType=c.onnx.TypeProto.Tensor.toObject(e.tensorType,t),t.oneofs&&(n.value="tensorType")),null!=e.denotation&&e.hasOwnProperty("denotation")&&(n.denotation=e.denotation),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e.Tensor=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.elemType=0,e.prototype.shape=null,e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.elemType&&e.hasOwnProperty("elemType")&&t.uint32(8).int32(e.elemType),null!=e.shape&&e.hasOwnProperty("shape")&&c.onnx.TensorShapeProto.encode(e.shape,t.uint32(18).fork()).ldelim(),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TypeProto.Tensor;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.elemType=e.int32();break;case 2:r.shape=c.onnx.TensorShapeProto.decode(e,e.uint32());break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.elemType&&e.hasOwnProperty("elemType")&&!l.isInteger(e.elemType))return"elemType: integer expected";if(null!=e.shape&&e.hasOwnProperty("shape")){var t=c.onnx.TensorShapeProto.verify(e.shape);if(t)return"shape."+t}return null},e.fromObject=function(e){if(e instanceof c.onnx.TypeProto.Tensor)return e;var t=new c.onnx.TypeProto.Tensor;if(null!=e.elemType&&(t.elemType=0|e.elemType),null!=e.shape){if("object"!=typeof e.shape)throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");t.shape=c.onnx.TensorShapeProto.fromObject(e.shape)}return t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.elemType=0,n.shape=null),null!=e.elemType&&e.hasOwnProperty("elemType")&&(n.elemType=e.elemType),null!=e.shape&&e.hasOwnProperty("shape")&&(n.shape=c.onnx.TensorShapeProto.toObject(e.shape,t)),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),e}(),i.OperatorSetIdProto=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.domain="",e.prototype.version=l.Long?l.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.domain&&e.hasOwnProperty("domain")&&t.uint32(10).string(e.domain),null!=e.version&&e.hasOwnProperty("version")&&t.uint32(16).int64(e.version),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.OperatorSetIdProto;e.pos<n;){var o=e.uint32();switch(o>>>3){case 1:r.domain=e.string();break;case 2:r.version=e.int64();break;default:e.skipType(7&o)}}return r},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){return"object"!=typeof e||null===e?"object expected":null!=e.domain&&e.hasOwnProperty("domain")&&!l.isString(e.domain)?"domain: string expected":null!=e.version&&e.hasOwnProperty("version")&&!(l.isInteger(e.version)||e.version&&l.isInteger(e.version.low)&&l.isInteger(e.version.high))?"version: integer|Long expected":null},e.fromObject=function(e){if(e instanceof c.onnx.OperatorSetIdProto)return e;var t=new c.onnx.OperatorSetIdProto;return null!=e.domain&&(t.domain=String(e.domain)),null!=e.version&&(l.Long?(t.version=l.Long.fromValue(e.version)).unsigned=!1:"string"==typeof e.version?t.version=parseInt(e.version,10):"number"==typeof e.version?t.version=e.version:"object"==typeof e.version&&(t.version=new l.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber())),t},e.toObject=function(e,t){t||(t={});var n={};if(t.defaults)if(n.domain="",l.Long){var r=new l.Long(0,0,!1);n.version=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.version=t.longs===String?"0":0;return null!=e.domain&&e.hasOwnProperty("domain")&&(n.domain=e.domain),null!=e.version&&e.hasOwnProperty("version")&&("number"==typeof e.version?n.version=t.longs===String?String(e.version):e.version:n.version=t.longs===String?l.Long.prototype.toString.call(e.version):t.longs===Number?new l.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber():e.version),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},e}(),i),e.exports=c},2100:(e,t,n)=>{"use strict";e.exports=n(9482)},9482:(e,t,n)=>{"use strict";var r=t;function o(){r.util._configure(),r.Writer._configure(r.BufferWriter),r.Reader._configure(r.BufferReader)}r.build="minimal",r.Writer=n(1173),r.BufferWriter=n(3155),r.Reader=n(1408),r.BufferReader=n(593),r.util=n(9693),r.rpc=n(5994),r.roots=n(5054),r.configure=o,o()},1408:(e,t,n)=>{"use strict";e.exports=u;var r,o=n(9693),i=o.LongBits,a=o.utf8;function s(e,t){return RangeError("index out of range: "+e.pos+" + "+(t||1)+" > "+e.len)}function u(e){this.buf=e,this.pos=0,this.len=e.length}var l,c="undefined"!=typeof Uint8Array?function(e){if(e instanceof Uint8Array||Array.isArray(e))return new u(e);throw Error("illegal buffer")}:function(e){if(Array.isArray(e))return new u(e);throw Error("illegal buffer")},p=function(){return o.Buffer?function(e){return(u.create=function(e){return o.Buffer.isBuffer(e)?new r(e):c(e)})(e)}:c};function d(){var e=new i(0,0),t=0;if(!(this.len-this.pos>4)){for(;t<3;++t){if(this.pos>=this.len)throw s(this);if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(127&this.buf[this.pos++])<<7*t)>>>0,e}for(;t<4;++t)if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(127&this.buf[this.pos])<<28)>>>0,e.hi=(e.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return e;if(t=0,this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw s(this);if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}function f(e,t){return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0}function h(){if(this.pos+8>this.len)throw s(this,8);return new i(f(this.buf,this.pos+=4),f(this.buf,this.pos+=4))}u.create=p(),u.prototype._slice=o.Array.prototype.subarray||o.Array.prototype.slice,u.prototype.uint32=(l=4294967295,function(){if(l=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return l;if(l=(l|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return l;if(l=(l|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return l;if(l=(l|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return l;if(l=(l|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return l;if((this.pos+=5)>this.len)throw this.pos=this.len,s(this,10);return l}),u.prototype.int32=function(){return 0|this.uint32()},u.prototype.sint32=function(){var e=this.uint32();return e>>>1^-(1&e)|0},u.prototype.bool=function(){return 0!==this.uint32()},u.prototype.fixed32=function(){if(this.pos+4>this.len)throw s(this,4);return f(this.buf,this.pos+=4)},u.prototype.sfixed32=function(){if(this.pos+4>this.len)throw s(this,4);return 0|f(this.buf,this.pos+=4)},u.prototype.float=function(){if(this.pos+4>this.len)throw s(this,4);var e=o.float.readFloatLE(this.buf,this.pos);return this.pos+=4,e},u.prototype.double=function(){if(this.pos+8>this.len)throw s(this,4);var e=o.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,e},u.prototype.bytes=function(){var e=this.uint32(),t=this.pos,n=this.pos+e;if(n>this.len)throw s(this,e);return this.pos+=e,Array.isArray(this.buf)?this.buf.slice(t,n):t===n?new this.buf.constructor(0):this._slice.call(this.buf,t,n)},u.prototype.string=function(){var e=this.bytes();return a.read(e,0,e.length)},u.prototype.skip=function(e){if("number"==typeof e){if(this.pos+e>this.len)throw s(this,e);this.pos+=e}else do{if(this.pos>=this.len)throw s(this)}while(128&this.buf[this.pos++]);return this},u.prototype.skipType=function(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(e=7&this.uint32());)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+e+" at offset "+this.pos)}return this},u._configure=function(e){r=e,u.create=p(),r._configure();var t=o.Long?"toLong":"toNumber";o.merge(u.prototype,{int64:function(){return d.call(this)[t](!1)},uint64:function(){return d.call(this)[t](!0)},sint64:function(){return d.call(this).zzDecode()[t](!1)},fixed64:function(){return h.call(this)[t](!0)},sfixed64:function(){return h.call(this)[t](!1)}})}},593:(e,t,n)=>{"use strict";e.exports=i;var r=n(1408);(i.prototype=Object.create(r.prototype)).constructor=i;var o=n(9693);function i(e){r.call(this,e)}i._configure=function(){o.Buffer&&(i.prototype._slice=o.Buffer.prototype.slice)},i.prototype.string=function(){var e=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+e,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+e,this.len))},i._configure()},5054:e=>{"use strict";e.exports={}},5994:(e,t,n)=>{"use strict";t.Service=n(7948)},7948:(e,t,n)=>{"use strict";e.exports=o;var r=n(9693);function o(e,t,n){if("function"!=typeof e)throw TypeError("rpcImpl must be a function");r.EventEmitter.call(this),this.rpcImpl=e,this.requestDelimited=Boolean(t),this.responseDelimited=Boolean(n)}(o.prototype=Object.create(r.EventEmitter.prototype)).constructor=o,o.prototype.rpcCall=function e(t,n,o,i,a){if(!i)throw TypeError("request must be specified");var s=this;if(!a)return r.asPromise(e,s,t,n,o,i);if(s.rpcImpl)try{return s.rpcImpl(t,n[s.requestDelimited?"encodeDelimited":"encode"](i).finish(),(function(e,n){if(e)return s.emit("error",e,t),a(e);if(null!==n){if(!(n instanceof o))try{n=o[s.responseDelimited?"decodeDelimited":"decode"](n)}catch(e){return s.emit("error",e,t),a(e)}return s.emit("data",n,t),a(null,n)}s.end(!0)}))}catch(e){return s.emit("error",e,t),void setTimeout((function(){a(e)}),0)}else setTimeout((function(){a(Error("already ended"))}),0)},o.prototype.end=function(e){return this.rpcImpl&&(e||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(e,t,n)=>{"use strict";e.exports=o;var r=n(9693);function o(e,t){this.lo=e>>>0,this.hi=t>>>0}var i=o.zero=new o(0,0);i.toNumber=function(){return 0},i.zzEncode=i.zzDecode=function(){return this},i.length=function(){return 1};var a=o.zeroHash="\0\0\0\0\0\0\0\0";o.fromNumber=function(e){if(0===e)return i;var t=e<0;t&&(e=-e);var n=e>>>0,r=(e-n)/4294967296>>>0;return t&&(r=~r>>>0,n=~n>>>0,++n>4294967295&&(n=0,++r>4294967295&&(r=0))),new o(n,r)},o.from=function(e){if("number"==typeof e)return o.fromNumber(e);if(r.isString(e)){if(!r.Long)return o.fromNumber(parseInt(e,10));e=r.Long.fromString(e)}return e.low||e.high?new o(e.low>>>0,e.high>>>0):i},o.prototype.toNumber=function(e){if(!e&&this.hi>>>31){var t=1+~this.lo>>>0,n=~this.hi>>>0;return t||(n=n+1>>>0),-(t+4294967296*n)}return this.lo+4294967296*this.hi},o.prototype.toLong=function(e){return r.Long?new r.Long(0|this.lo,0|this.hi,Boolean(e)):{low:0|this.lo,high:0|this.hi,unsigned:Boolean(e)}};var s=String.prototype.charCodeAt;o.fromHash=function(e){return e===a?i:new o((s.call(e,0)|s.call(e,1)<<8|s.call(e,2)<<16|s.call(e,3)<<24)>>>0,(s.call(e,4)|s.call(e,5)<<8|s.call(e,6)<<16|s.call(e,7)<<24)>>>0)},o.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},o.prototype.zzEncode=function(){var e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this},o.prototype.zzDecode=function(){var e=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this},o.prototype.length=function(){var e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return 0===n?0===t?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10}},9693:function(e,t,n){"use strict";var r=t;function o(e,t,n){for(var r=Object.keys(t),o=0;o<r.length;++o)void 0!==e[r[o]]&&n||(e[r[o]]=t[r[o]]);return e}function i(e){function t(e,n){if(!(this instanceof t))return new t(e,n);Object.defineProperty(this,"message",{get:function(){return e}}),Error.captureStackTrace?Error.captureStackTrace(this,t):Object.defineProperty(this,"stack",{value:(new Error).stack||""}),n&&o(this,n)}return(t.prototype=Object.create(Error.prototype)).constructor=t,Object.defineProperty(t.prototype,"name",{get:function(){return e}}),t.prototype.toString=function(){return this.name+": "+this.message},t}r.asPromise=n(4537),r.base64=n(7419),r.EventEmitter=n(9211),r.float=n(945),r.inquire=n(7199),r.utf8=n(4997),r.pool=n(6662),r.LongBits=n(1945),r.isNode=Boolean(void 0!==n.g&&n.g&&n.g.process&&n.g.process.versions&&n.g.process.versions.node),r.global=r.isNode&&n.g||"undefined"!=typeof window&&window||"undefined"!=typeof self&&self||this,r.emptyArray=Object.freeze?Object.freeze([]):[],r.emptyObject=Object.freeze?Object.freeze({}):{},r.isInteger=Number.isInteger||function(e){return"number"==typeof e&&isFinite(e)&&Math.floor(e)===e},r.isString=function(e){return"string"==typeof e||e instanceof String},r.isObject=function(e){return e&&"object"==typeof e},r.isset=r.isSet=function(e,t){var n=e[t];return!(null==n||!e.hasOwnProperty(t))&&("object"!=typeof n||(Array.isArray(n)?n.length:Object.keys(n).length)>0)},r.Buffer=function(){try{var e=r.inquire("buffer").Buffer;return e.prototype.utf8Write?e:null}catch(e){return null}}(),r._Buffer_from=null,r._Buffer_allocUnsafe=null,r.newBuffer=function(e){return"number"==typeof e?r.Buffer?r._Buffer_allocUnsafe(e):new r.Array(e):r.Buffer?r._Buffer_from(e):"undefined"==typeof Uint8Array?e:new Uint8Array(e)},r.Array="undefined"!=typeof Uint8Array?Uint8Array:Array,r.Long=r.global.dcodeIO&&r.global.dcodeIO.Long||r.global.Long||r.inquire("long"),r.key2Re=/^true|false|0|1$/,r.key32Re=/^-?(?:0|[1-9][0-9]*)$/,r.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,r.longToHash=function(e){return e?r.LongBits.from(e).toHash():r.LongBits.zeroHash},r.longFromHash=function(e,t){var n=r.LongBits.fromHash(e);return r.Long?r.Long.fromBits(n.lo,n.hi,t):n.toNumber(Boolean(t))},r.merge=o,r.lcFirst=function(e){return e.charAt(0).toLowerCase()+e.substring(1)},r.newError=i,r.ProtocolError=i("ProtocolError"),r.oneOfGetter=function(e){for(var t={},n=0;n<e.length;++n)t[e[n]]=1;return function(){for(var e=Object.keys(this),n=e.length-1;n>-1;--n)if(1===t[e[n]]&&void 0!==this[e[n]]&&null!==this[e[n]])return e[n]}},r.oneOfSetter=function(e){return function(t){for(var n=0;n<e.length;++n)e[n]!==t&&delete this[e[n]]}},r.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},r._configure=function(){var e=r.Buffer;e?(r._Buffer_from=e.from!==Uint8Array.from&&e.from||function(t,n){return new e(t,n)},r._Buffer_allocUnsafe=e.allocUnsafe||function(t){return new e(t)}):r._Buffer_from=r._Buffer_allocUnsafe=null}},1173:(e,t,n)=>{"use strict";e.exports=p;var r,o=n(9693),i=o.LongBits,a=o.base64,s=o.utf8;function u(e,t,n){this.fn=e,this.len=t,this.next=void 0,this.val=n}function l(){}function c(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}function p(){this.len=0,this.head=new u(l,0,0),this.tail=this.head,this.states=null}var d=function(){return o.Buffer?function(){return(p.create=function(){return new r})()}:function(){return new p}};function f(e,t,n){t[n]=255&e}function h(e,t){this.len=e,this.next=void 0,this.val=t}function g(e,t,n){for(;e.hi;)t[n++]=127&e.lo|128,e.lo=(e.lo>>>7|e.hi<<25)>>>0,e.hi>>>=7;for(;e.lo>127;)t[n++]=127&e.lo|128,e.lo=e.lo>>>7;t[n++]=e.lo}function m(e,t,n){t[n]=255&e,t[n+1]=e>>>8&255,t[n+2]=e>>>16&255,t[n+3]=e>>>24}p.create=d(),p.alloc=function(e){return new o.Array(e)},o.Array!==Array&&(p.alloc=o.pool(p.alloc,o.Array.prototype.subarray)),p.prototype._push=function(e,t,n){return this.tail=this.tail.next=new u(e,t,n),this.len+=t,this},h.prototype=Object.create(u.prototype),h.prototype.fn=function(e,t,n){for(;e>127;)t[n++]=127&e|128,e>>>=7;t[n]=e},p.prototype.uint32=function(e){return this.len+=(this.tail=this.tail.next=new h((e>>>=0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this},p.prototype.int32=function(e){return e<0?this._push(g,10,i.fromNumber(e)):this.uint32(e)},p.prototype.sint32=function(e){return this.uint32((e<<1^e>>31)>>>0)},p.prototype.uint64=function(e){var t=i.from(e);return this._push(g,t.length(),t)},p.prototype.int64=p.prototype.uint64,p.prototype.sint64=function(e){var t=i.from(e).zzEncode();return this._push(g,t.length(),t)},p.prototype.bool=function(e){return this._push(f,1,e?1:0)},p.prototype.fixed32=function(e){return this._push(m,4,e>>>0)},p.prototype.sfixed32=p.prototype.fixed32,p.prototype.fixed64=function(e){var t=i.from(e);return this._push(m,4,t.lo)._push(m,4,t.hi)},p.prototype.sfixed64=p.prototype.fixed64,p.prototype.float=function(e){return this._push(o.float.writeFloatLE,4,e)},p.prototype.double=function(e){return this._push(o.float.writeDoubleLE,8,e)};var b=o.Array.prototype.set?function(e,t,n){t.set(e,n)}:function(e,t,n){for(var r=0;r<e.length;++r)t[n+r]=e[r]};p.prototype.bytes=function(e){var t=e.length>>>0;if(!t)return this._push(f,1,0);if(o.isString(e)){var n=p.alloc(t=a.length(e));a.decode(e,n,0),e=n}return this.uint32(t)._push(b,t,e)},p.prototype.string=function(e){var t=s.length(e);return t?this.uint32(t)._push(s.write,t,e):this._push(f,1,0)},p.prototype.fork=function(){return this.states=new c(this),this.head=this.tail=new u(l,0,0),this.len=0,this},p.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new u(l,0,0),this.len=0),this},p.prototype.ldelim=function(){var e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),n&&(this.tail.next=e.next,this.tail=t,this.len+=n),this},p.prototype.finish=function(){for(var e=this.head.next,t=this.constructor.alloc(this.len),n=0;e;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t},p._configure=function(e){r=e,p.create=d(),r._configure()}},3155:(e,t,n)=>{"use strict";e.exports=i;var r=n(1173);(i.prototype=Object.create(r.prototype)).constructor=i;var o=n(9693);function i(){r.call(this)}function a(e,t,n){e.length<40?o.utf8.write(e,t,n):t.utf8Write?t.utf8Write(e,n):t.write(e,n)}i._configure=function(){i.alloc=o._Buffer_allocUnsafe,i.writeBytesBuffer=o.Buffer&&o.Buffer.prototype instanceof Uint8Array&&"set"===o.Buffer.prototype.set.name?function(e,t,n){t.set(e,n)}:function(e,t,n){if(e.copy)e.copy(t,n,0,e.length);else for(var r=0;r<e.length;)t[n++]=e[r++]}},i.prototype.bytes=function(e){o.isString(e)&&(e=o._Buffer_from(e,"base64"));var t=e.length>>>0;return this.uint32(t),t&&this._push(i.writeBytesBuffer,t,e),this},i.prototype.string=function(e){var t=o.Buffer.byteLength(e);return this.uint32(t),t&&this._push(a,t,e),this},i._configure()},4154:e=>{"use strict";e.exports='"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\n'},7067:()=>{},1296:()=>{},760:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(e,t,n)=>{"use strict";n.r(t),n.d(t,{flatbuffers:()=>r});var r={};r.Offset,r.Table,r.SIZEOF_SHORT=2,r.SIZEOF_INT=4,r.FILE_IDENTIFIER_LENGTH=4,r.SIZE_PREFIX_LENGTH=4,r.Encoding={UTF8_BYTES:1,UTF16_STRING:2},r.int32=new Int32Array(2),r.float32=new Float32Array(r.int32.buffer),r.float64=new Float64Array(r.int32.buffer),r.isLittleEndian=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0],r.Long=function(e,t){this.low=0|e,this.high=0|t},r.Long.create=function(e,t){return 0==e&&0==t?r.Long.ZERO:new r.Long(e,t)},r.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},r.Long.prototype.equals=function(e){return this.low==e.low&&this.high==e.high},r.Long.ZERO=new r.Long(0,0),r.Builder=function(e){if(e)t=e;else var t=1024;this.bb=r.ByteBuffer.allocate(t),this.space=t,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.forceDefaults=function(e){this.force_defaults=e},r.Builder.prototype.dataBuffer=function(){return this.bb},r.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},r.Builder.prototype.prep=function(e,t){e>this.minalign&&(this.minalign=e);for(var n=1+~(this.bb.capacity()-this.space+t)&e-1;this.space<n+e+t;){var o=this.bb.capacity();this.bb=r.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-o}this.pad(n)},r.Builder.prototype.pad=function(e){for(var t=0;t<e;t++)this.bb.writeInt8(--this.space,0)},r.Builder.prototype.writeInt8=function(e){this.bb.writeInt8(this.space-=1,e)},r.Builder.prototype.writeInt16=function(e){this.bb.writeInt16(this.space-=2,e)},r.Builder.prototype.writeInt32=function(e){this.bb.writeInt32(this.space-=4,e)},r.Builder.prototype.writeInt64=function(e){this.bb.writeInt64(this.space-=8,e)},r.Builder.prototype.writeFloat32=function(e){this.bb.writeFloat32(this.space-=4,e)},r.Builder.prototype.writeFloat64=function(e){this.bb.writeFloat64(this.space-=8,e)},r.Builder.prototype.addInt8=function(e){this.prep(1,0),this.writeInt8(e)},r.Builder.prototype.addInt16=function(e){this.prep(2,0),this.writeInt16(e)},r.Builder.prototype.addInt32=function(e){this.prep(4,0),this.writeInt32(e)},r.Builder.prototype.addInt64=function(e){this.prep(8,0),this.writeInt64(e)},r.Builder.prototype.addFloat32=function(e){this.prep(4,0),this.writeFloat32(e)},r.Builder.prototype.addFloat64=function(e){this.prep(8,0),this.writeFloat64(e)},r.Builder.prototype.addFieldInt8=function(e,t,n){(this.force_defaults||t!=n)&&(this.addInt8(t),this.slot(e))},r.Builder.prototype.addFieldInt16=function(e,t,n){(this.force_defaults||t!=n)&&(this.addInt16(t),this.slot(e))},r.Builder.prototype.addFieldInt32=function(e,t,n){(this.force_defaults||t!=n)&&(this.addInt32(t),this.slot(e))},r.Builder.prototype.addFieldInt64=function(e,t,n){!this.force_defaults&&t.equals(n)||(this.addInt64(t),this.slot(e))},r.Builder.prototype.addFieldFloat32=function(e,t,n){(this.force_defaults||t!=n)&&(this.addFloat32(t),this.slot(e))},r.Builder.prototype.addFieldFloat64=function(e,t,n){(this.force_defaults||t!=n)&&(this.addFloat64(t),this.slot(e))},r.Builder.prototype.addFieldOffset=function(e,t,n){(this.force_defaults||t!=n)&&(this.addOffset(t),this.slot(e))},r.Builder.prototype.addFieldStruct=function(e,t,n){t!=n&&(this.nested(t),this.slot(e))},r.Builder.prototype.nested=function(e){if(e!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},r.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},r.Builder.prototype.slot=function(e){this.vtable[e]=this.offset()},r.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},r.Builder.growByteBuffer=function(e){var t=e.capacity();if(3221225472&t)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var n=t<<1,o=r.ByteBuffer.allocate(n);return o.setPosition(n-t),o.bytes().set(e.bytes(),n-t),o},r.Builder.prototype.addOffset=function(e){this.prep(r.SIZEOF_INT,0),this.writeInt32(this.offset()-e+r.SIZEOF_INT)},r.Builder.prototype.startObject=function(e){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=e;for(var t=0;t<e;t++)this.vtable[t]=0;this.isNested=!0,this.object_start=this.offset()},r.Builder.prototype.endObject=function(){if(null==this.vtable||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var e=this.offset(),t=this.vtable_in_use-1;t>=0&&0==this.vtable[t];t--);for(var n=t+1;t>=0;t--)this.addInt16(0!=this.vtable[t]?e-this.vtable[t]:0);this.addInt16(e-this.object_start);var o=(n+2)*r.SIZEOF_SHORT;this.addInt16(o);var i=0,a=this.space;e:for(t=0;t<this.vtables.length;t++){var s=this.bb.capacity()-this.vtables[t];if(o==this.bb.readInt16(s)){for(var u=r.SIZEOF_SHORT;u<o;u+=r.SIZEOF_SHORT)if(this.bb.readInt16(a+u)!=this.bb.readInt16(s+u))continue e;i=this.vtables[t];break}}return i?(this.space=this.bb.capacity()-e,this.bb.writeInt32(this.space,i-e)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-e,this.offset()-e)),this.isNested=!1,e},r.Builder.prototype.finish=function(e,t,n){var o=n?r.SIZE_PREFIX_LENGTH:0;if(t){var i=t;if(this.prep(this.minalign,r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH+o),i.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+r.FILE_IDENTIFIER_LENGTH);for(var a=r.FILE_IDENTIFIER_LENGTH-1;a>=0;a--)this.writeInt8(i.charCodeAt(a))}this.prep(this.minalign,r.SIZEOF_INT+o),this.addOffset(e),o&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},r.Builder.prototype.finishSizePrefixed=function(e,t){this.finish(e,t,!0)},r.Builder.prototype.requiredField=function(e,t){var n=this.bb.capacity()-e,r=n-this.bb.readInt32(n);if(0==this.bb.readInt16(r+t))throw new Error("FlatBuffers: field "+t+" must be set")},r.Builder.prototype.startVector=function(e,t,n){this.notNested(),this.vector_num_elems=t,this.prep(r.SIZEOF_INT,e*t),this.prep(n,e*t)},r.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},r.Builder.prototype.createString=function(e){if(e instanceof Uint8Array)var t=e;else{t=[];for(var n=0;n<e.length;){var r,o=e.charCodeAt(n++);(r=o<55296||o>=56320?o:(o<<10)+e.charCodeAt(n++)+-56613888)<128?t.push(r):(r<2048?t.push(r>>6&31|192):(r<65536?t.push(r>>12&15|224):t.push(r>>18&7|240,r>>12&63|128),t.push(r>>6&63|128)),t.push(63&r|128))}}this.addInt8(0),this.startVector(1,t.length,1),this.bb.setPosition(this.space-=t.length),n=0;for(var i=this.space,a=this.bb.bytes();n<t.length;n++)a[i++]=t[n];return this.endVector()},r.Builder.prototype.createLong=function(e,t){return r.Long.create(e,t)},r.ByteBuffer=function(e){this.bytes_=e,this.position_=0},r.ByteBuffer.allocate=function(e){return new r.ByteBuffer(new Uint8Array(e))},r.ByteBuffer.prototype.clear=function(){this.position_=0},r.ByteBuffer.prototype.bytes=function(){return this.bytes_},r.ByteBuffer.prototype.position=function(){return this.position_},r.ByteBuffer.prototype.setPosition=function(e){this.position_=e},r.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},r.ByteBuffer.prototype.readInt8=function(e){return this.readUint8(e)<<24>>24},r.ByteBuffer.prototype.readUint8=function(e){return this.bytes_[e]},r.ByteBuffer.prototype.readInt16=function(e){return this.readUint16(e)<<16>>16},r.ByteBuffer.prototype.readUint16=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8},r.ByteBuffer.prototype.readInt32=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8|this.bytes_[e+2]<<16|this.bytes_[e+3]<<24},r.ByteBuffer.prototype.readUint32=function(e){return this.readInt32(e)>>>0},r.ByteBuffer.prototype.readInt64=function(e){return new r.Long(this.readInt32(e),this.readInt32(e+4))},r.ByteBuffer.prototype.readUint64=function(e){return new r.Long(this.readUint32(e),this.readUint32(e+4))},r.ByteBuffer.prototype.readFloat32=function(e){return r.int32[0]=this.readInt32(e),r.float32[0]},r.ByteBuffer.prototype.readFloat64=function(e){return r.int32[r.isLittleEndian?0:1]=this.readInt32(e),r.int32[r.isLittleEndian?1:0]=this.readInt32(e+4),r.float64[0]},r.ByteBuffer.prototype.writeInt8=function(e,t){this.bytes_[e]=t},r.ByteBuffer.prototype.writeUint8=function(e,t){this.bytes_[e]=t},r.ByteBuffer.prototype.writeInt16=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8},r.ByteBuffer.prototype.writeUint16=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8},r.ByteBuffer.prototype.writeInt32=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8,this.bytes_[e+2]=t>>16,this.bytes_[e+3]=t>>24},r.ByteBuffer.prototype.writeUint32=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8,this.bytes_[e+2]=t>>16,this.bytes_[e+3]=t>>24},r.ByteBuffer.prototype.writeInt64=function(e,t){this.writeInt32(e,t.low),this.writeInt32(e+4,t.high)},r.ByteBuffer.prototype.writeUint64=function(e,t){this.writeUint32(e,t.low),this.writeUint32(e+4,t.high)},r.ByteBuffer.prototype.writeFloat32=function(e,t){r.float32[0]=t,this.writeInt32(e,r.int32[0])},r.ByteBuffer.prototype.writeFloat64=function(e,t){r.float64[0]=t,this.writeInt32(e,r.int32[r.isLittleEndian?0:1]),this.writeInt32(e+4,r.int32[r.isLittleEndian?1:0])},r.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var e="",t=0;t<r.FILE_IDENTIFIER_LENGTH;t++)e+=String.fromCharCode(this.readInt8(this.position_+r.SIZEOF_INT+t));return e},r.ByteBuffer.prototype.__offset=function(e,t){var n=e-this.readInt32(e);return t<this.readInt16(n)?this.readInt16(n+t):0},r.ByteBuffer.prototype.__union=function(e,t){return e.bb_pos=t+this.readInt32(t),e.bb=this,e},r.ByteBuffer.prototype.__string=function(e,t){e+=this.readInt32(e);var n=this.readInt32(e),o="",i=0;if(e+=r.SIZEOF_INT,t===r.Encoding.UTF8_BYTES)return this.bytes_.subarray(e,e+n);for(;i<n;){var a,s=this.readUint8(e+i++);if(s<192)a=s;else{var u=this.readUint8(e+i++);if(s<224)a=(31&s)<<6|63&u;else{var l=this.readUint8(e+i++);a=s<240?(15&s)<<12|(63&u)<<6|63&l:(7&s)<<18|(63&u)<<12|(63&l)<<6|63&this.readUint8(e+i++)}}a<65536?o+=String.fromCharCode(a):(a-=65536,o+=String.fromCharCode(55296+(a>>10),56320+(1023&a)))}return o},r.ByteBuffer.prototype.__indirect=function(e){return e+this.readInt32(e)},r.ByteBuffer.prototype.__vector=function(e){return e+this.readInt32(e)+r.SIZEOF_INT},r.ByteBuffer.prototype.__vector_len=function(e){return this.readInt32(e+this.readInt32(e))},r.ByteBuffer.prototype.__has_identifier=function(e){if(e.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+r.FILE_IDENTIFIER_LENGTH);for(var t=0;t<r.FILE_IDENTIFIER_LENGTH;t++)if(e.charCodeAt(t)!=this.readInt8(this.position_+r.SIZEOF_INT+t))return!1;return!0},r.ByteBuffer.prototype.createLong=function(e,t){return r.Long.create(e,t)}}},__webpack_module_cache__={};function __nested_webpack_require_606622__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var n=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(n.exports,n,n.exports,__nested_webpack_require_606622__),n.exports}__nested_webpack_require_606622__.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return __nested_webpack_require_606622__.d(t,{a:t}),t},__nested_webpack_require_606622__.d=(e,t)=>{for(var n in t)__nested_webpack_require_606622__.o(t,n)&&!__nested_webpack_require_606622__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__nested_webpack_require_606622__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__nested_webpack_require_606622__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__nested_webpack_require_606622__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __nested_webpack_exports__=__nested_webpack_require_606622__(1057);return __nested_webpack_exports__})()));
//# sourceMappingURL=ort.min.js.map

/***/ }),

/***/ "./src/AudioEncoder.ts":
/*!*****************************!*\
  !*** ./src/AudioEncoder.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertToWavBlob = exports.convertToWavBuffer = void 0;
const WavEncoder_1 = __webpack_require__(/*! ./WavEncoder */ "./src/WavEncoder.ts");
/**
 * Convert a Float32Array of audio samples to a WAV array buffer
 * @param audioData - The audio samples
 * @returns - The audio in WAV format as an ArrayBuffer
 */
function convertToWavBuffer(audioData) {
    const arrayBuffer = (0, WavEncoder_1.encodeWAV)(audioData);
    return arrayBuffer;
}
exports.convertToWavBuffer = convertToWavBuffer;
/**
 * Convert a Float32Array of audio samples to a WAV Blob
 * @param audioData - The audio samples
 * @returns - The audio in WAV format
 */
function convertToWavBlob(audioData) {
    const arrayBuffer = convertToWavBuffer(audioData);
    return new Blob([arrayBuffer], { type: "audio/wav" });
}
exports.convertToWavBlob = convertToWavBlob;


/***/ }),

/***/ "./src/WavEncoder.ts":
/*!***************************!*\
  !*** ./src/WavEncoder.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Most of the code here come from ricky0123/vad-web
// Who in turn copied it from linto-ai/WebVoiceSDK
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeWAV = exports.arrayBufferToBase64 = exports.minFramesForTargetMS = void 0;
function minFramesForTargetMS(targetDuration, frameSamples, sr = 16000) {
    return Math.ceil((targetDuration * sr) / 1000 / frameSamples);
}
exports.minFramesForTargetMS = minFramesForTargetMS;
function arrayBufferToBase64(buffer) {
    var binary = "";
    var bytes = new Uint8Array(buffer);
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}
exports.arrayBufferToBase64 = arrayBufferToBase64;
/*
  This rest of this was mostly copied from https://github.com/linto-ai/WebVoiceSDK
  */
// this function is used to encode the Float32Array audio data produced from a MicVAD
// as a WAV file audio buffer
function encodeWAV(samples, format = 3, sampleRate = 16000, numChannels = 1, bitDepth = 32) {
    var bytesPerSample = bitDepth / 8;
    var blockAlign = numChannels * bytesPerSample;
    var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
    var view = new DataView(buffer);
    /* RIFF identifier */
    writeString(view, 0, "RIFF");
    /* RIFF chunk length */
    view.setUint32(4, 36 + samples.length * bytesPerSample, true);
    /* RIFF type */
    writeString(view, 8, "WAVE");
    /* format chunk identifier */
    writeString(view, 12, "fmt ");
    /* format chunk length */
    view.setUint32(16, 16, true);
    /* sample format (raw) */
    view.setUint16(20, format, true);
    /* channel count */
    view.setUint16(22, numChannels, true);
    /* sample rate */
    view.setUint32(24, sampleRate, true);
    /* byte rate (sample rate * block align) */
    view.setUint32(28, sampleRate * blockAlign, true);
    /* block align (channel count * bytes per sample) */
    view.setUint16(32, blockAlign, true);
    /* bits per sample */
    view.setUint16(34, bitDepth, true);
    /* data chunk identifier */
    writeString(view, 36, "data");
    /* data chunk length */
    view.setUint32(40, samples.length * bytesPerSample, true);
    if (format === 1) {
        // Raw PCM
        floatTo16BitPCM(view, 44, samples);
    }
    else {
        writeFloat32(view, 44, samples);
    }
    return buffer;
}
exports.encodeWAV = encodeWAV;
function interleave(inputL, inputR) {
    var length = inputL.length + inputR.length;
    var result = new Float32Array(length);
    var index = 0;
    var inputIndex = 0;
    while (index < length) {
        result[index++] = inputL[inputIndex];
        result[index++] = inputR[inputIndex];
        inputIndex++;
    }
    return result;
}
function writeFloat32(output, offset, input) {
    for (var i = 0; i < input.length; i++, offset += 4) {
        output.setFloat32(offset, input[i], true);
    }
}
function floatTo16BitPCM(output, offset, input) {
    for (var i = 0; i < input.length; i++, offset += 2) {
        var s = Math.max(-1, Math.min(1, input[i]));
        output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
    }
}
function writeString(view, offset, string) {
    for (var i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}


/***/ }),

/***/ "./node_modules/xstate/es/Actor.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/Actor.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createDeferredActor: () => (/* binding */ createDeferredActor),
/* harmony export */   createInvocableActor: () => (/* binding */ createInvocableActor),
/* harmony export */   createNullActor: () => (/* binding */ createNullActor),
/* harmony export */   isActor: () => (/* binding */ isActor),
/* harmony export */   isSpawnedActor: () => (/* binding */ isSpawnedActor),
/* harmony export */   toActorRef: () => (/* binding */ toActorRef)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");
/* harmony import */ var _serviceScope_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serviceScope.js */ "./node_modules/xstate/es/serviceScope.js");




function createNullActor(id) {
  var _a;

  return _a = {
    id: id,
    send: function () {
      return void 0;
    },
    subscribe: function () {
      return {
        unsubscribe: function () {
          return void 0;
        }
      };
    },
    getSnapshot: function () {
      return undefined;
    },
    toJSON: function () {
      return {
        id: id
      };
    }
  }, _a[_utils_js__WEBPACK_IMPORTED_MODULE_0__.symbolObservable] = function () {
    return this;
  }, _a;
}
/**
 * Creates a deferred actor that is able to be invoked given the provided
 * invocation information in its `.meta` value.
 *
 * @param invokeDefinition The meta information needed to invoke the actor.
 */

function createInvocableActor(invokeDefinition, machine, context, _event) {
  var _a;

  var invokeSrc = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toInvokeSource)(invokeDefinition.src);
  var serviceCreator = (_a = machine === null || machine === void 0 ? void 0 : machine.options.services) === null || _a === void 0 ? void 0 : _a[invokeSrc.type];
  var resolvedData = invokeDefinition.data ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapContext)(invokeDefinition.data, context, _event) : undefined;
  var tempActor = serviceCreator ? createDeferredActor(serviceCreator, invokeDefinition.id, resolvedData) : createNullActor(invokeDefinition.id); // @ts-ignore

  tempActor.meta = invokeDefinition;
  return tempActor;
}
function createDeferredActor(entity, id, data) {
  var tempActor = createNullActor(id); // @ts-ignore

  tempActor.deferred = true;

  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isMachine)(entity)) {
    // "mute" the existing service scope so potential spawned actors within the `.initialState` stay deferred here
    var initialState_1 = tempActor.state = (0,_serviceScope_js__WEBPACK_IMPORTED_MODULE_1__.provide)(undefined, function () {
      return (data ? entity.withContext(data) : entity).initialState;
    });

    tempActor.getSnapshot = function () {
      return initialState_1;
    };
  }

  return tempActor;
}
function isActor(item) {
  try {
    return typeof item.send === 'function';
  } catch (e) {
    return false;
  }
}
function isSpawnedActor(item) {
  return isActor(item) && 'id' in item;
} // TODO: refactor the return type, this could be written in a better way but it's best to avoid unneccessary breaking changes now

function toActorRef(actorRefLike) {
  var _a;

  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((_a = {
    subscribe: function () {
      return {
        unsubscribe: function () {
          return void 0;
        }
      };
    },
    id: 'anonymous',
    getSnapshot: function () {
      return undefined;
    }
  }, _a[_utils_js__WEBPACK_IMPORTED_MODULE_0__.symbolObservable] = function () {
    return this;
  }, _a), actorRefLike);
}




/***/ }),

/***/ "./node_modules/xstate/es/Machine.js":
/*!*******************************************!*\
  !*** ./node_modules/xstate/es/Machine.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Machine: () => (/* binding */ Machine),
/* harmony export */   createMachine: () => (/* binding */ createMachine)
/* harmony export */ });
/* harmony import */ var _StateNode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StateNode.js */ "./node_modules/xstate/es/StateNode.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./environment.js */ "./node_modules/xstate/es/environment.js");



var warned = false;
function Machine(config, options, initialContext) {
  if (initialContext === void 0) {
    initialContext = config.context;
  }

  return new _StateNode_js__WEBPACK_IMPORTED_MODULE_0__.StateNode(config, options, initialContext);
}
function createMachine(config, options) {
  if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION && !('predictableActionArguments' in config) && !warned) {
    warned = true;
    console.warn('It is highly recommended to set `predictableActionArguments` to `true` when using `createMachine`. https://xstate.js.org/docs/guides/actions.html');
  }

  return new _StateNode_js__WEBPACK_IMPORTED_MODULE_0__.StateNode(config, options);
}




/***/ }),

/***/ "./node_modules/xstate/es/State.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/State.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   State: () => (/* binding */ State),
/* harmony export */   bindActionToState: () => (/* binding */ bindActionToState),
/* harmony export */   isState: () => (/* binding */ isState),
/* harmony export */   isStateConfig: () => (/* binding */ isStateConfig),
/* harmony export */   stateValuesEqual: () => (/* binding */ stateValuesEqual)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ "./node_modules/xstate/es/constants.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");
/* harmony import */ var _stateUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stateUtils.js */ "./node_modules/xstate/es/stateUtils.js");
/* harmony import */ var _actions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./actions.js */ "./node_modules/xstate/es/actions.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./environment.js */ "./node_modules/xstate/es/environment.js");







function stateValuesEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (a === undefined || b === undefined) {
    return false;
  }

  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(a) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(b)) {
    return a === b;
  }

  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  return aKeys.length === bKeys.length && aKeys.every(function (key) {
    return stateValuesEqual(a[key], b[key]);
  });
}
function isStateConfig(state) {
  if (typeof state !== 'object' || state === null) {
    return false;
  }

  return 'value' in state && '_event' in state;
}
/**
 * @deprecated Use `isStateConfig(object)` or `state instanceof State` instead.
 */

var isState = isStateConfig;
function bindActionToState(action, state) {
  var exec = action.exec;

  var boundAction = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, action), {
    exec: exec !== undefined ? function () {
      return exec(state.context, state.event, {
        action: action,
        state: state,
        _event: state._event
      });
    } : undefined
  });

  return boundAction;
}

var State =
/*#__PURE__*/

/** @class */
function () {
  /**
   * Creates a new State instance.
   * @param value The state value
   * @param context The extended state
   * @param historyValue The tree representing historical values of the state nodes
   * @param history The previous state
   * @param actions An array of action objects to execute as side-effects
   * @param activities A mapping of activities and whether they are started (`true`) or stopped (`false`).
   * @param meta
   * @param events Internal event queue. Should be empty with run-to-completion semantics.
   * @param configuration
   */
  function State(config) {
    var _this = this;

    var _a;

    this.actions = [];
    this.activities = _constants_js__WEBPACK_IMPORTED_MODULE_2__.EMPTY_ACTIVITY_MAP;
    this.meta = {};
    this.events = [];
    this.value = config.value;
    this.context = config.context;
    this._event = config._event;
    this._sessionid = config._sessionid;
    this.event = this._event.data;
    this.historyValue = config.historyValue;
    this.history = config.history;
    this.actions = config.actions || [];
    this.activities = config.activities || _constants_js__WEBPACK_IMPORTED_MODULE_2__.EMPTY_ACTIVITY_MAP;
    this.meta = (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_3__.getMeta)(config.configuration);
    this.events = config.events || [];
    this.matches = this.matches.bind(this);
    this.toStrings = this.toStrings.bind(this);
    this.configuration = config.configuration;
    this.transitions = config.transitions;
    this.children = config.children;
    this.done = !!config.done;
    this.tags = (_a = Array.isArray(config.tags) ? new Set(config.tags) : config.tags) !== null && _a !== void 0 ? _a : new Set();
    this.machine = config.machine;
    Object.defineProperty(this, 'nextEvents', {
      get: function () {
        return (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_3__.nextEvents)(_this.configuration);
      }
    });
  }
  /**
   * Creates a new State instance for the given `stateValue` and `context`.
   * @param stateValue
   * @param context
   */


  State.from = function (stateValue, context) {
    if (stateValue instanceof State) {
      if (stateValue.context !== context) {
        return new State({
          value: stateValue.value,
          context: context,
          _event: stateValue._event,
          _sessionid: null,
          historyValue: stateValue.historyValue,
          history: stateValue.history,
          actions: [],
          activities: stateValue.activities,
          meta: {},
          events: [],
          configuration: [],
          transitions: [],
          children: {}
        });
      }

      return stateValue;
    }

    var _event = _actions_js__WEBPACK_IMPORTED_MODULE_4__.initEvent;
    return new State({
      value: stateValue,
      context: context,
      _event: _event,
      _sessionid: null,
      historyValue: undefined,
      history: undefined,
      actions: [],
      activities: undefined,
      meta: undefined,
      events: [],
      configuration: [],
      transitions: [],
      children: {}
    });
  };
  /**
   * Creates a new State instance for the given `config`.
   * @param config The state config
   */


  State.create = function (config) {
    return new State(config);
  };
  /**
   * Creates a new `State` instance for the given `stateValue` and `context` with no actions (side-effects).
   * @param stateValue
   * @param context
   */


  State.inert = function (stateValue, context) {
    if (stateValue instanceof State) {
      if (!stateValue.actions.length) {
        return stateValue;
      }

      var _event = _actions_js__WEBPACK_IMPORTED_MODULE_4__.initEvent;
      return new State({
        value: stateValue.value,
        context: context,
        _event: _event,
        _sessionid: null,
        historyValue: stateValue.historyValue,
        history: stateValue.history,
        activities: stateValue.activities,
        configuration: stateValue.configuration,
        transitions: [],
        children: {}
      });
    }

    return State.from(stateValue, context);
  };
  /**
   * Returns an array of all the string leaf state node paths.
   * @param stateValue
   * @param delimiter The character(s) that separate each subpath in the string state node path.
   */


  State.prototype.toStrings = function (stateValue, delimiter) {
    var _this = this;

    if (stateValue === void 0) {
      stateValue = this.value;
    }

    if (delimiter === void 0) {
      delimiter = '.';
    }

    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(stateValue)) {
      return [stateValue];
    }

    var valueKeys = Object.keys(stateValue);
    return valueKeys.concat.apply(valueKeys, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__read)(valueKeys.map(function (key) {
      return _this.toStrings(stateValue[key], delimiter).map(function (s) {
        return key + delimiter + s;
      });
    })), false));
  };

  State.prototype.toJSON = function () {
    var _a = this;
        _a.configuration;
        _a.transitions;
        var tags = _a.tags;
        _a.machine;
        var jsonValues = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__rest)(_a, ["configuration", "transitions", "tags", "machine"]);

    return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, jsonValues), {
      tags: Array.from(tags)
    });
  };

  State.prototype.matches = function (parentStateValue) {
    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.matchesState)(parentStateValue, this.value);
  };
  /**
   * Whether the current state configuration has a state node with the specified `tag`.
   * @param tag
   */


  State.prototype.hasTag = function (tag) {
    return this.tags.has(tag);
  };
  /**
   * Determines whether sending the `event` will cause a non-forbidden transition
   * to be selected, even if the transitions have no actions nor
   * change the state value.
   *
   * @param event The event to test
   * @returns Whether the event will cause a transition
   */


  State.prototype.can = function (event) {
    var _a;

    if (_environment_js__WEBPACK_IMPORTED_MODULE_5__.IS_PRODUCTION) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(!!this.machine, "state.can(...) used outside of a machine-created State object; this will always return false.");
    }

    var transitionData = (_a = this.machine) === null || _a === void 0 ? void 0 : _a.getTransitionData(this, event);
    return !!(transitionData === null || transitionData === void 0 ? void 0 : transitionData.transitions.length) && // Check that at least one transition is not forbidden
    transitionData.transitions.some(function (t) {
      return t.target !== undefined || t.actions.length;
    });
  };

  return State;
}();




/***/ }),

/***/ "./node_modules/xstate/es/StateNode.js":
/*!*********************************************!*\
  !*** ./node_modules/xstate/es/StateNode.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StateNode: () => (/* binding */ StateNode)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./State.js */ "./node_modules/xstate/es/State.js");
/* harmony import */ var _actionTypes_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./actionTypes.js */ "./node_modules/xstate/es/actionTypes.js");
/* harmony import */ var _actions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./actions.js */ "./node_modules/xstate/es/actions.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./environment.js */ "./node_modules/xstate/es/environment.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ "./node_modules/xstate/es/constants.js");
/* harmony import */ var _stateUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stateUtils.js */ "./node_modules/xstate/es/stateUtils.js");
/* harmony import */ var _Actor_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Actor.js */ "./node_modules/xstate/es/Actor.js");
/* harmony import */ var _invokeUtils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./invokeUtils.js */ "./node_modules/xstate/es/invokeUtils.js");











var NULL_EVENT = '';
var STATE_IDENTIFIER = '#';
var WILDCARD = '*';
var EMPTY_OBJECT = {};

var isStateId = function (str) {
  return str[0] === STATE_IDENTIFIER;
};

var createDefaultOptions = function () {
  return {
    actions: {},
    guards: {},
    services: {},
    activities: {},
    delays: {}
  };
};

var validateArrayifiedTransitions = function (stateNode, event, transitions) {
  var hasNonLastUnguardedTarget = transitions.slice(0, -1).some(function (transition) {
    return !('cond' in transition) && !('in' in transition) && ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(transition.target) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isMachine)(transition.target));
  });
  var eventText = event === NULL_EVENT ? 'the transient event' : "event '".concat(event, "'");
  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(!hasNonLastUnguardedTarget, "One or more transitions for ".concat(eventText, " on state '").concat(stateNode.id, "' are unreachable. ") + "Make sure that the default transition is the last one defined.");
};

var StateNode =
/*#__PURE__*/

/** @class */
function () {
  function StateNode(
  /**
   * The raw config used to create the machine.
   */
  config, options,
  /**
   * The initial extended state
   */
  _context, // TODO: this is unsafe, but we're removing it in v5 anyway
  _stateInfo) {
    if (_context === void 0) {
      _context = 'context' in config ? config.context : undefined;
    }

    var _this = this;

    var _a;

    this.config = config;
    this._context = _context;
    /**
     * The order this state node appears. Corresponds to the implicit SCXML document order.
     */

    this.order = -1;
    this.__xstatenode = true;
    this.__cache = {
      events: undefined,
      relativeValue: new Map(),
      initialStateValue: undefined,
      initialState: undefined,
      on: undefined,
      transitions: undefined,
      candidates: {},
      delayedTransitions: undefined
    };
    this.idMap = {};
    this.tags = [];
    this.options = Object.assign(createDefaultOptions(), options);
    this.parent = _stateInfo === null || _stateInfo === void 0 ? void 0 : _stateInfo.parent;
    this.key = this.config.key || (_stateInfo === null || _stateInfo === void 0 ? void 0 : _stateInfo.key) || this.config.id || '(machine)';
    this.machine = this.parent ? this.parent.machine : this;
    this.path = this.parent ? this.parent.path.concat(this.key) : [];
    this.delimiter = this.config.delimiter || (this.parent ? this.parent.delimiter : _constants_js__WEBPACK_IMPORTED_MODULE_1__.STATE_DELIMITER);
    this.id = this.config.id || (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([this.machine.key], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(this.path), false).join(this.delimiter);
    this.version = this.parent ? this.parent.version : this.config.version;
    this.type = this.config.type || (this.config.parallel ? 'parallel' : this.config.states && Object.keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');
    this.schema = this.parent ? this.machine.schema : (_a = this.config.schema) !== null && _a !== void 0 ? _a : {};
    this.description = this.config.description;

    if (!_environment_js__WEBPACK_IMPORTED_MODULE_3__.IS_PRODUCTION) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(!('parallel' in this.config), "The \"parallel\" property is deprecated and will be removed in version 4.1. ".concat(this.config.parallel ? "Replace with `type: 'parallel'`" : "Use `type: '".concat(this.type, "'`"), " in the config for state node '").concat(this.id, "' instead."));
    }

    this.initial = this.config.initial;
    this.states = this.config.states ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValues)(this.config.states, function (stateConfig, key) {
      var _a;

      var stateNode = new StateNode(stateConfig, {}, undefined, {
        parent: _this,
        key: key
      });
      Object.assign(_this.idMap, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((_a = {}, _a[stateNode.id] = stateNode, _a), stateNode.idMap));
      return stateNode;
    }) : EMPTY_OBJECT; // Document order

    var order = 0;

    function dfs(stateNode) {
      var e_1, _a;

      stateNode.order = order++;

      try {
        for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)((0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getAllChildren)(stateNode)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var child = _c.value;
          dfs(child);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }

    dfs(this); // History config

    this.history = this.config.history === true ? 'shallow' : this.config.history || false;
    this._transient = !!this.config.always || (!this.config.on ? false : Array.isArray(this.config.on) ? this.config.on.some(function (_a) {
      var event = _a.event;
      return event === NULL_EVENT;
    }) : NULL_EVENT in this.config.on);
    this.strict = !!this.config.strict; // TODO: deprecate (entry)

    this.onEntry = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(this.config.entry || this.config.onEntry).map(function (action) {
      return (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.toActionObject)(action);
    }); // TODO: deprecate (exit)

    this.onExit = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(this.config.exit || this.config.onExit).map(function (action) {
      return (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.toActionObject)(action);
    });
    this.meta = this.config.meta;
    this.doneData = this.type === 'final' ? this.config.data : undefined;
    this.invoke = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(this.config.invoke).map(function (invokeConfig, i) {
      var _a, _b;

      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isMachine)(invokeConfig)) {
        var invokeId = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createInvokeId)(_this.id, i);
        _this.machine.options.services = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((_a = {}, _a[invokeId] = invokeConfig, _a), _this.machine.options.services);
        return (0,_invokeUtils_js__WEBPACK_IMPORTED_MODULE_6__.toInvokeDefinition)({
          src: invokeId,
          id: invokeId
        });
      } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(invokeConfig.src)) {
        var invokeId = invokeConfig.id || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createInvokeId)(_this.id, i);
        return (0,_invokeUtils_js__WEBPACK_IMPORTED_MODULE_6__.toInvokeDefinition)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, invokeConfig), {
          id: invokeId,
          src: invokeConfig.src
        }));
      } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isMachine)(invokeConfig.src) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(invokeConfig.src)) {
        var invokeId = invokeConfig.id || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createInvokeId)(_this.id, i);
        _this.machine.options.services = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((_b = {}, _b[invokeId] = invokeConfig.src, _b), _this.machine.options.services);
        return (0,_invokeUtils_js__WEBPACK_IMPORTED_MODULE_6__.toInvokeDefinition)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({
          id: invokeId
        }, invokeConfig), {
          src: invokeId
        }));
      } else {
        var invokeSource = invokeConfig.src;
        return (0,_invokeUtils_js__WEBPACK_IMPORTED_MODULE_6__.toInvokeDefinition)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({
          id: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createInvokeId)(_this.id, i)
        }, invokeConfig), {
          src: invokeSource
        }));
      }
    });
    this.activities = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(this.config.activities).concat(this.invoke).map(function (activity) {
      return (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.toActivityDefinition)(activity);
    });
    this.transition = this.transition.bind(this);
    this.tags = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(this.config.tags); // TODO: this is the real fix for initialization once
    // state node getters are deprecated
    // if (!this.parent) {
    //   this._init();
    // }
  }

  StateNode.prototype._init = function () {
    if (this.__cache.transitions) {
      return;
    }

    (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getAllStateNodes)(this).forEach(function (stateNode) {
      return stateNode.on;
    });
  };
  /**
   * Clones this state machine with custom options and context.
   *
   * @param options Options (actions, guards, activities, services) to recursively merge with the existing options.
   * @param context Custom context (will override predefined context)
   */


  StateNode.prototype.withConfig = function (options, context) {
    var _a = this.options,
        actions = _a.actions,
        activities = _a.activities,
        guards = _a.guards,
        services = _a.services,
        delays = _a.delays;
    return new StateNode(this.config, {
      actions: (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, actions), options.actions),
      activities: (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, activities), options.activities),
      guards: (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, guards), options.guards),
      services: (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, services), options.services),
      delays: (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, delays), options.delays)
    }, context !== null && context !== void 0 ? context : this.context);
  };
  /**
   * Clones this state machine with custom context.
   *
   * @param context Custom context (will override predefined context, not recursive)
   */


  StateNode.prototype.withContext = function (context) {
    return new StateNode(this.config, this.options, context);
  };

  Object.defineProperty(StateNode.prototype, "context", {
    get: function () {
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(this._context) ? this._context() : this._context;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "definition", {
    /**
     * The well-structured state node definition.
     */
    get: function () {
      return {
        id: this.id,
        key: this.key,
        version: this.version,
        context: this.context,
        type: this.type,
        initial: this.initial,
        history: this.history,
        states: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValues)(this.states, function (state) {
          return state.definition;
        }),
        on: this.on,
        transitions: this.transitions,
        entry: this.onEntry,
        exit: this.onExit,
        activities: this.activities || [],
        meta: this.meta,
        order: this.order || -1,
        data: this.doneData,
        invoke: this.invoke,
        description: this.description,
        tags: this.tags
      };
    },
    enumerable: false,
    configurable: true
  });

  StateNode.prototype.toJSON = function () {
    return this.definition;
  };

  Object.defineProperty(StateNode.prototype, "on", {
    /**
     * The mapping of events to transitions.
     */
    get: function () {
      if (this.__cache.on) {
        return this.__cache.on;
      }

      var transitions = this.transitions;
      return this.__cache.on = transitions.reduce(function (map, transition) {
        map[transition.eventType] = map[transition.eventType] || [];
        map[transition.eventType].push(transition);
        return map;
      }, {});
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "after", {
    get: function () {
      return this.__cache.delayedTransitions || (this.__cache.delayedTransitions = this.getDelayedTransitions(), this.__cache.delayedTransitions);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "transitions", {
    /**
     * All the transitions that can be taken from this state node.
     */
    get: function () {
      return this.__cache.transitions || (this.__cache.transitions = this.formatTransitions(), this.__cache.transitions);
    },
    enumerable: false,
    configurable: true
  });

  StateNode.prototype.getCandidates = function (eventName) {
    if (this.__cache.candidates[eventName]) {
      return this.__cache.candidates[eventName];
    }

    var transient = eventName === NULL_EVENT;
    var candidates = this.transitions.filter(function (transition) {
      var sameEventType = transition.eventType === eventName; // null events should only match against eventless transitions

      return transient ? sameEventType : sameEventType || transition.eventType === WILDCARD;
    });
    this.__cache.candidates[eventName] = candidates;
    return candidates;
  };
  /**
   * All delayed transitions from the config.
   */


  StateNode.prototype.getDelayedTransitions = function () {
    var _this = this;

    var afterConfig = this.config.after;

    if (!afterConfig) {
      return [];
    }

    var mutateEntryExit = function (delay, i) {
      var delayRef = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(delay) ? "".concat(_this.id, ":delay[").concat(i, "]") : delay;
      var eventType = (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.after)(delayRef, _this.id);

      _this.onEntry.push((0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.send)(eventType, {
        delay: delay
      }));

      _this.onExit.push((0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.cancel)(eventType));

      return eventType;
    };

    var delayedTransitions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(afterConfig) ? afterConfig.map(function (transition, i) {
      var eventType = mutateEntryExit(transition.delay, i);
      return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, transition), {
        event: eventType
      });
    }) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(Object.keys(afterConfig).map(function (delay, i) {
      var configTransition = afterConfig[delay];
      var resolvedTransition = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(configTransition) ? {
        target: configTransition
      } : configTransition;
      var resolvedDelay = !isNaN(+delay) ? +delay : delay;
      var eventType = mutateEntryExit(resolvedDelay, i);
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(resolvedTransition).map(function (transition) {
        return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, transition), {
          event: eventType,
          delay: resolvedDelay
        });
      });
    }));
    return delayedTransitions.map(function (delayedTransition) {
      var delay = delayedTransition.delay;
      return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, _this.formatTransition(delayedTransition)), {
        delay: delay
      });
    });
  };
  /**
   * Returns the state nodes represented by the current state value.
   *
   * @param state The state value or State instance
   */


  StateNode.prototype.getStateNodes = function (state) {
    var _a;

    var _this = this;

    if (!state) {
      return [];
    }

    var stateValue = state instanceof _State_js__WEBPACK_IMPORTED_MODULE_7__.State ? state.value : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toStateValue)(state, this.delimiter);

    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(stateValue)) {
      var initialStateValue = this.getStateNode(stateValue).initial;
      return initialStateValue !== undefined ? this.getStateNodes((_a = {}, _a[stateValue] = initialStateValue, _a)) : [this, this.states[stateValue]];
    }

    var subStateKeys = Object.keys(stateValue);
    var subStateNodes = [this];
    subStateNodes.push.apply(subStateNodes, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(subStateKeys.map(function (subStateKey) {
      return _this.getStateNode(subStateKey).getStateNodes(stateValue[subStateKey]);
    }))), false));
    return subStateNodes;
  };
  /**
   * Returns `true` if this state node explicitly handles the given event.
   *
   * @param event The event in question
   */


  StateNode.prototype.handles = function (event) {
    var eventType = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getEventType)(event);
    return this.events.includes(eventType);
  };
  /**
   * Resolves the given `state` to a new `State` instance relative to this machine.
   *
   * This ensures that `.events` and `.nextEvents` represent the correct values.
   *
   * @param state The state to resolve
   */


  StateNode.prototype.resolveState = function (state) {
    var stateFromConfig = state instanceof _State_js__WEBPACK_IMPORTED_MODULE_7__.State ? state : _State_js__WEBPACK_IMPORTED_MODULE_7__.State.create(state);
    var configuration = Array.from((0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getConfiguration)([], this.getStateNodes(stateFromConfig.value)));
    return new _State_js__WEBPACK_IMPORTED_MODULE_7__.State((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, stateFromConfig), {
      value: this.resolve(stateFromConfig.value),
      configuration: configuration,
      done: (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.isInFinalState)(configuration, this),
      tags: (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getTagsFromConfiguration)(configuration),
      machine: this.machine
    }));
  };

  StateNode.prototype.transitionLeafNode = function (stateValue, state, _event) {
    var stateNode = this.getStateNode(stateValue);
    var next = stateNode.next(state, _event);

    if (!next || !next.transitions.length) {
      return this.next(state, _event);
    }

    return next;
  };

  StateNode.prototype.transitionCompoundNode = function (stateValue, state, _event) {
    var subStateKeys = Object.keys(stateValue);
    var stateNode = this.getStateNode(subStateKeys[0]);

    var next = stateNode._transition(stateValue[subStateKeys[0]], state, _event);

    if (!next || !next.transitions.length) {
      return this.next(state, _event);
    }

    return next;
  };

  StateNode.prototype.transitionParallelNode = function (stateValue, state, _event) {
    var e_2, _a;

    var transitionMap = {};

    try {
      for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(Object.keys(stateValue)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var subStateKey = _c.value;
        var subStateValue = stateValue[subStateKey];

        if (!subStateValue) {
          continue;
        }

        var subStateNode = this.getStateNode(subStateKey);

        var next = subStateNode._transition(subStateValue, state, _event);

        if (next) {
          transitionMap[subStateKey] = next;
        }
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    var stateTransitions = Object.keys(transitionMap).map(function (key) {
      return transitionMap[key];
    });
    var enabledTransitions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(stateTransitions.map(function (st) {
      return st.transitions;
    }));
    var willTransition = stateTransitions.some(function (st) {
      return st.transitions.length > 0;
    });

    if (!willTransition) {
      return this.next(state, _event);
    }

    var configuration = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(Object.keys(transitionMap).map(function (key) {
      return transitionMap[key].configuration;
    }));
    return {
      transitions: enabledTransitions,
      exitSet: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(stateTransitions.map(function (t) {
        return t.exitSet;
      })),
      configuration: configuration,
      source: state,
      actions: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(Object.keys(transitionMap).map(function (key) {
        return transitionMap[key].actions;
      }))
    };
  };

  StateNode.prototype._transition = function (stateValue, state, _event) {
    // leaf node
    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(stateValue)) {
      return this.transitionLeafNode(stateValue, state, _event);
    } // hierarchical node


    if (Object.keys(stateValue).length === 1) {
      return this.transitionCompoundNode(stateValue, state, _event);
    } // orthogonal node


    return this.transitionParallelNode(stateValue, state, _event);
  };

  StateNode.prototype.getTransitionData = function (state, event) {
    return this._transition(state.value, state, (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(event));
  };

  StateNode.prototype.next = function (state, _event) {
    var e_3, _a;

    var _this = this;

    var eventName = _event.name;
    var actions = [];
    var nextStateNodes = [];
    var selectedTransition;

    try {
      for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(this.getCandidates(eventName)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var candidate = _c.value;
        var cond = candidate.cond,
            stateIn = candidate.in;
        var resolvedContext = state.context;
        var isInState = stateIn ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(stateIn) && isStateId(stateIn) ? // Check if in state by ID
        state.matches((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toStateValue)(this.getStateNodeById(stateIn).path, this.delimiter)) : // Check if in state by relative grandparent
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.matchesState)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toStateValue)(stateIn, this.delimiter), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.path)(this.path.slice(0, -2))(state.value)) : true;
        var guardPassed = false;

        try {
          guardPassed = !cond || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.evaluateGuard)(this.machine, cond, resolvedContext, _event, state);
        } catch (err) {
          throw new Error("Unable to evaluate guard '".concat(cond.name || cond.type, "' in transition for event '").concat(eventName, "' in state node '").concat(this.id, "':\n").concat(err.message));
        }

        if (guardPassed && isInState) {
          if (candidate.target !== undefined) {
            nextStateNodes = candidate.target;
          }

          actions.push.apply(actions, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(candidate.actions), false));
          selectedTransition = candidate;
          break;
        }
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    if (!selectedTransition) {
      return undefined;
    }

    if (!nextStateNodes.length) {
      return {
        transitions: [selectedTransition],
        exitSet: [],
        configuration: state.value ? [this] : [],
        source: state,
        actions: actions
      };
    }

    var allNextStateNodes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(nextStateNodes.map(function (stateNode) {
      return _this.getRelativeStateNodes(stateNode, state.historyValue);
    }));
    var isInternal = !!selectedTransition.internal;
    return {
      transitions: [selectedTransition],
      exitSet: isInternal ? [] : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(nextStateNodes.map(function (targetNode) {
        return _this.getPotentiallyReenteringNodes(targetNode);
      })),
      configuration: allNextStateNodes,
      source: state,
      actions: actions
    };
  }; // even though the name of this function mentions reentry nodes
  // we are pushing its result into `exitSet`
  // that's because what we exit might be reentered (it's an invariant of reentrancy)


  StateNode.prototype.getPotentiallyReenteringNodes = function (targetNode) {
    if (this.order < targetNode.order) {
      return [this];
    }

    var nodes = [];
    var marker = this;
    var possibleAncestor = targetNode;

    while (marker && marker !== possibleAncestor) {
      nodes.push(marker);
      marker = marker.parent;
    }

    if (marker !== possibleAncestor) {
      // we never got to `possibleAncestor`, therefore the initial `marker` "escapes" it
      // it's in a different part of the tree so no states will be reentered for such an external transition
      return [];
    }

    nodes.push(possibleAncestor);
    return nodes;
  };

  StateNode.prototype.getActions = function (resolvedConfig, isDone, transition, currentContext, _event, prevState, predictableExec) {
    var e_4, _a, e_5, _b;

    var _this = this;

    var prevConfig = prevState ? (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getConfiguration)([], this.getStateNodes(prevState.value)) : [];
    var entrySet = new Set();

    try {
      for (var _c = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(Array.from(resolvedConfig).sort(function (a, b) {
        return a.order - b.order;
      })), _d = _c.next(); !_d.done; _d = _c.next()) {
        var sn = _d.value;

        if (!(0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.has)(prevConfig, sn) || (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.has)(transition.exitSet, sn) || sn.parent && entrySet.has(sn.parent)) {
          entrySet.add(sn);
        }
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
      } finally {
        if (e_4) throw e_4.error;
      }
    }

    try {
      for (var prevConfig_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(prevConfig), prevConfig_1_1 = prevConfig_1.next(); !prevConfig_1_1.done; prevConfig_1_1 = prevConfig_1.next()) {
        var sn = prevConfig_1_1.value;

        if (!(0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.has)(resolvedConfig, sn) || (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.has)(transition.exitSet, sn.parent)) {
          transition.exitSet.push(sn);
        }
      }
    } catch (e_5_1) {
      e_5 = {
        error: e_5_1
      };
    } finally {
      try {
        if (prevConfig_1_1 && !prevConfig_1_1.done && (_b = prevConfig_1.return)) _b.call(prevConfig_1);
      } finally {
        if (e_5) throw e_5.error;
      }
    }

    transition.exitSet.sort(function (a, b) {
      return b.order - a.order;
    });
    var entryStates = Array.from(entrySet).sort(function (a, b) {
      return a.order - b.order;
    });
    var exitStates = new Set(transition.exitSet);
    var doneEvents = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(entryStates.map(function (sn) {
      var events = [];

      if (sn.type !== 'final') {
        return events;
      }

      var parent = sn.parent;

      if (!parent.parent) {
        return events;
      }

      events.push((0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.done)(sn.id, sn.doneData), // TODO: deprecate - final states should not emit done events for their own state.
      (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.done)(parent.id, sn.doneData ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapContext)(sn.doneData, currentContext, _event) : undefined));
      var grandparent = parent.parent;

      if (grandparent.type === 'parallel') {
        if ((0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getChildren)(grandparent).every(function (parentNode) {
          return (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.isInFinalState)(transition.configuration, parentNode);
        })) {
          events.push((0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.done)(grandparent.id));
        }
      }

      return events;
    }));
    var entryActions = entryStates.map(function (stateNode) {
      var entryActions = stateNode.onEntry;
      var invokeActions = stateNode.activities.map(function (activity) {
        return (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.start)(activity);
      });
      return {
        type: 'entry',
        actions: (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.toActionObjects)(predictableExec ? (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(entryActions), false), (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(invokeActions), false) : (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(invokeActions), false), (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(entryActions), false), _this.machine.options.actions)
      };
    }).concat({
      type: 'state_done',
      actions: doneEvents.map(function (event) {
        return (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.raise)(event);
      })
    });
    var exitActions = Array.from(exitStates).map(function (stateNode) {
      return {
        type: 'exit',
        actions: (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.toActionObjects)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(stateNode.onExit), false), (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(stateNode.activities.map(function (activity) {
          return (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.stop)(activity);
        })), false), _this.machine.options.actions)
      };
    });
    var actions = exitActions.concat({
      type: 'transition',
      actions: (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.toActionObjects)(transition.actions, this.machine.options.actions)
    }).concat(entryActions);

    if (isDone) {
      var stopActions = (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.toActionObjects)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(resolvedConfig), false).sort(function (a, b) {
        return b.order - a.order;
      }).map(function (stateNode) {
        return stateNode.onExit;
      })), this.machine.options.actions).filter(function (action) {
        return !(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isRaisableAction)(action);
      });
      return actions.concat({
        type: 'stop',
        actions: stopActions
      });
    }

    return actions;
  };
  /**
   * Determines the next state given the current `state` and sent `event`.
   *
   * @param state The current State instance or state value
   * @param event The event that was sent at the current state
   * @param context The current context (extended state) of the current state
   */


  StateNode.prototype.transition = function (state, event, context, exec) {
    if (state === void 0) {
      state = this.initialState;
    }

    var _event = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(event);

    var currentState;

    if (state instanceof _State_js__WEBPACK_IMPORTED_MODULE_7__.State) {
      currentState = context === undefined ? state : this.resolveState(_State_js__WEBPACK_IMPORTED_MODULE_7__.State.from(state, context));
    } else {
      var resolvedStateValue = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(state) ? this.resolve((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.pathToStateValue)(this.getResolvedPath(state))) : this.resolve(state);
      var resolvedContext = context !== null && context !== void 0 ? context : this.machine.context;
      currentState = this.resolveState(_State_js__WEBPACK_IMPORTED_MODULE_7__.State.from(resolvedStateValue, resolvedContext));
    }

    if (!_environment_js__WEBPACK_IMPORTED_MODULE_3__.IS_PRODUCTION && _event.name === WILDCARD) {
      throw new Error("An event cannot have the wildcard type ('".concat(WILDCARD, "')"));
    }

    if (this.strict) {
      if (!this.events.includes(_event.name) && !(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBuiltInEvent)(_event.name)) {
        throw new Error("Machine '".concat(this.id, "' does not accept event '").concat(_event.name, "'"));
      }
    }

    var stateTransition = this._transition(currentState.value, currentState, _event) || {
      transitions: [],
      configuration: [],
      exitSet: [],
      source: currentState,
      actions: []
    };
    var prevConfig = (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getConfiguration)([], this.getStateNodes(currentState.value));
    var resolvedConfig = stateTransition.configuration.length ? (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getConfiguration)(prevConfig, stateTransition.configuration) : prevConfig;
    stateTransition.configuration = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(resolvedConfig), false);
    return this.resolveTransition(stateTransition, currentState, currentState.context, exec, _event);
  };

  StateNode.prototype.resolveRaisedTransition = function (state, _event, originalEvent, predictableExec) {
    var _a;

    var currentActions = state.actions;
    state = this.transition(state, _event, undefined, predictableExec); // Save original event to state
    // TODO: this should be the raised event! Delete in V5 (breaking)

    state._event = originalEvent;
    state.event = originalEvent.data;

    (_a = state.actions).unshift.apply(_a, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(currentActions), false));

    return state;
  };

  StateNode.prototype.resolveTransition = function (stateTransition, currentState, context, predictableExec, _event) {
    var e_6, _a, e_7, _b;

    var _this = this;

    if (_event === void 0) {
      _event = _actions_js__WEBPACK_IMPORTED_MODULE_5__.initEvent;
    }

    var configuration = stateTransition.configuration; // Transition will "apply" if:
    // - this is the initial state (there is no current state)
    // - OR there are transitions

    var willTransition = !currentState || stateTransition.transitions.length > 0;
    var resolvedConfiguration = willTransition ? stateTransition.configuration : currentState ? currentState.configuration : [];
    var isDone = (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.isInFinalState)(resolvedConfiguration, this);
    var resolvedStateValue = willTransition ? (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getValue)(this.machine, configuration) : undefined;
    var historyValue = currentState ? currentState.historyValue ? currentState.historyValue : stateTransition.source ? this.machine.historyValue(currentState.value) : undefined : undefined;
    var actionBlocks = this.getActions(new Set(resolvedConfiguration), isDone, stateTransition, context, _event, currentState, predictableExec);
    var activities = currentState ? (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, currentState.activities) : {};

    try {
      for (var actionBlocks_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(actionBlocks), actionBlocks_1_1 = actionBlocks_1.next(); !actionBlocks_1_1.done; actionBlocks_1_1 = actionBlocks_1.next()) {
        var block = actionBlocks_1_1.value;

        try {
          for (var _c = (e_7 = void 0, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(block.actions)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var action = _d.value;

            if (action.type === _actionTypes_js__WEBPACK_IMPORTED_MODULE_8__.start) {
              activities[action.activity.id || action.activity.type] = action;
            } else if (action.type === _actionTypes_js__WEBPACK_IMPORTED_MODULE_8__.stop) {
              activities[action.activity.id || action.activity.type] = false;
            }
          }
        } catch (e_7_1) {
          e_7 = {
            error: e_7_1
          };
        } finally {
          try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
          } finally {
            if (e_7) throw e_7.error;
          }
        }
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (actionBlocks_1_1 && !actionBlocks_1_1.done && (_a = actionBlocks_1.return)) _a.call(actionBlocks_1);
      } finally {
        if (e_6) throw e_6.error;
      }
    }

    var _e = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)((0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.resolveActions)(this, currentState, context, _event, actionBlocks, predictableExec, this.machine.config.predictableActionArguments || this.machine.config.preserveActionOrder), 2),
        resolvedActions = _e[0],
        updatedContext = _e[1];

    var _f = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.partition)(resolvedActions, _utils_js__WEBPACK_IMPORTED_MODULE_0__.isRaisableAction), 2),
        raisedEvents = _f[0],
        nonRaisedActions = _f[1];

    var invokeActions = resolvedActions.filter(function (action) {
      var _a;

      return action.type === _actionTypes_js__WEBPACK_IMPORTED_MODULE_8__.start && ((_a = action.activity) === null || _a === void 0 ? void 0 : _a.type) === _actionTypes_js__WEBPACK_IMPORTED_MODULE_8__.invoke;
    });
    var children = invokeActions.reduce(function (acc, action) {
      acc[action.activity.id] = (0,_Actor_js__WEBPACK_IMPORTED_MODULE_9__.createInvocableActor)(action.activity, _this.machine, updatedContext, _event);
      return acc;
    }, currentState ? (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, currentState.children) : {});
    var nextState = new _State_js__WEBPACK_IMPORTED_MODULE_7__.State({
      value: resolvedStateValue || currentState.value,
      context: updatedContext,
      _event: _event,
      // Persist _sessionid between states
      _sessionid: currentState ? currentState._sessionid : null,
      historyValue: resolvedStateValue ? historyValue ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.updateHistoryValue)(historyValue, resolvedStateValue) : undefined : currentState ? currentState.historyValue : undefined,
      history: !resolvedStateValue || stateTransition.source ? currentState : undefined,
      actions: resolvedStateValue ? nonRaisedActions : [],
      activities: resolvedStateValue ? activities : currentState ? currentState.activities : {},
      events: [],
      configuration: resolvedConfiguration,
      transitions: stateTransition.transitions,
      children: children,
      done: isDone,
      tags: (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.getTagsFromConfiguration)(resolvedConfiguration),
      machine: this
    });
    var didUpdateContext = context !== updatedContext;
    nextState.changed = _event.name === _actionTypes_js__WEBPACK_IMPORTED_MODULE_8__.update || didUpdateContext; // Dispose of penultimate histories to prevent memory leaks

    var history = nextState.history;

    if (history) {
      delete history.history;
    } // There are transient transitions if the machine is not in a final state
    // and if some of the state nodes have transient ("always") transitions.


    var hasAlwaysTransitions = !isDone && (this._transient || configuration.some(function (stateNode) {
      return stateNode._transient;
    })); // If there are no enabled transitions, check if there are transient transitions.
    // If there are transient transitions, continue checking for more transitions
    // because an transient transition should be triggered even if there are no
    // enabled transitions.
    //
    // If we're already working on an transient transition then stop to prevent an infinite loop.
    //
    // Otherwise, if there are no enabled nor transient transitions, we are done.

    if (!willTransition && (!hasAlwaysTransitions || _event.name === NULL_EVENT)) {
      return nextState;
    }

    var maybeNextState = nextState;

    if (!isDone) {
      if (hasAlwaysTransitions) {
        maybeNextState = this.resolveRaisedTransition(maybeNextState, {
          type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_8__.nullEvent
        }, _event, predictableExec);
      }

      while (raisedEvents.length) {
        var raisedEvent = raisedEvents.shift();
        maybeNextState = this.resolveRaisedTransition(maybeNextState, raisedEvent._event, _event, predictableExec);
      }
    } // Detect if state changed


    var changed = maybeNextState.changed || (history ? !!maybeNextState.actions.length || didUpdateContext || typeof history.value !== typeof maybeNextState.value || !(0,_State_js__WEBPACK_IMPORTED_MODULE_7__.stateValuesEqual)(maybeNextState.value, history.value) : undefined);
    maybeNextState.changed = changed; // Preserve original history after raised events

    maybeNextState.history = history;
    return maybeNextState;
  };
  /**
   * Returns the child state node from its relative `stateKey`, or throws.
   */


  StateNode.prototype.getStateNode = function (stateKey) {
    if (isStateId(stateKey)) {
      return this.machine.getStateNodeById(stateKey);
    }

    if (!this.states) {
      throw new Error("Unable to retrieve child state '".concat(stateKey, "' from '").concat(this.id, "'; no child states exist."));
    }

    var result = this.states[stateKey];

    if (!result) {
      throw new Error("Child state '".concat(stateKey, "' does not exist on '").concat(this.id, "'"));
    }

    return result;
  };
  /**
   * Returns the state node with the given `stateId`, or throws.
   *
   * @param stateId The state ID. The prefix "#" is removed.
   */


  StateNode.prototype.getStateNodeById = function (stateId) {
    var resolvedStateId = isStateId(stateId) ? stateId.slice(STATE_IDENTIFIER.length) : stateId;

    if (resolvedStateId === this.id) {
      return this;
    }

    var stateNode = this.machine.idMap[resolvedStateId];

    if (!stateNode) {
      throw new Error("Child state node '#".concat(resolvedStateId, "' does not exist on machine '").concat(this.id, "'"));
    }

    return stateNode;
  };
  /**
   * Returns the relative state node from the given `statePath`, or throws.
   *
   * @param statePath The string or string array relative path to the state node.
   */


  StateNode.prototype.getStateNodeByPath = function (statePath) {
    if (typeof statePath === 'string' && isStateId(statePath)) {
      try {
        return this.getStateNodeById(statePath.slice(1));
      } catch (e) {// try individual paths
        // throw e;
      }
    }

    var arrayStatePath = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toStatePath)(statePath, this.delimiter).slice();
    var currentStateNode = this;

    while (arrayStatePath.length) {
      var key = arrayStatePath.shift();

      if (!key.length) {
        break;
      }

      currentStateNode = currentStateNode.getStateNode(key);
    }

    return currentStateNode;
  };
  /**
   * Resolves a partial state value with its full representation in this machine.
   *
   * @param stateValue The partial state value to resolve.
   */


  StateNode.prototype.resolve = function (stateValue) {
    var _a;

    var _this = this;

    if (!stateValue) {
      return this.initialStateValue || EMPTY_OBJECT; // TODO: type-specific properties
    }

    switch (this.type) {
      case 'parallel':
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValues)(this.initialStateValue, function (subStateValue, subStateKey) {
          return subStateValue ? _this.getStateNode(subStateKey).resolve(stateValue[subStateKey] || subStateValue) : EMPTY_OBJECT;
        });

      case 'compound':
        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(stateValue)) {
          var subStateNode = this.getStateNode(stateValue);

          if (subStateNode.type === 'parallel' || subStateNode.type === 'compound') {
            return _a = {}, _a[stateValue] = subStateNode.initialStateValue, _a;
          }

          return stateValue;
        }

        if (!Object.keys(stateValue).length) {
          return this.initialStateValue || {};
        }

        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValues)(stateValue, function (subStateValue, subStateKey) {
          return subStateValue ? _this.getStateNode(subStateKey).resolve(subStateValue) : EMPTY_OBJECT;
        });

      default:
        return stateValue || EMPTY_OBJECT;
    }
  };

  StateNode.prototype.getResolvedPath = function (stateIdentifier) {
    if (isStateId(stateIdentifier)) {
      var stateNode = this.machine.idMap[stateIdentifier.slice(STATE_IDENTIFIER.length)];

      if (!stateNode) {
        throw new Error("Unable to find state node '".concat(stateIdentifier, "'"));
      }

      return stateNode.path;
    }

    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toStatePath)(stateIdentifier, this.delimiter);
  };

  Object.defineProperty(StateNode.prototype, "initialStateValue", {
    get: function () {
      var _a;

      if (this.__cache.initialStateValue) {
        return this.__cache.initialStateValue;
      }

      var initialStateValue;

      if (this.type === 'parallel') {
        initialStateValue = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapFilterValues)(this.states, function (state) {
          return state.initialStateValue || EMPTY_OBJECT;
        }, function (stateNode) {
          return !(stateNode.type === 'history');
        });
      } else if (this.initial !== undefined) {
        if (!this.states[this.initial]) {
          throw new Error("Initial state '".concat(this.initial, "' not found on '").concat(this.key, "'"));
        }

        initialStateValue = (0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.isLeafNode)(this.states[this.initial]) ? this.initial : (_a = {}, _a[this.initial] = this.states[this.initial].initialStateValue, _a);
      } else {
        // The finite state value of a machine without child states is just an empty object
        initialStateValue = {};
      }

      this.__cache.initialStateValue = initialStateValue;
      return this.__cache.initialStateValue;
    },
    enumerable: false,
    configurable: true
  });

  StateNode.prototype.getInitialState = function (stateValue, context) {
    this._init(); // TODO: this should be in the constructor (see note in constructor)


    var configuration = this.getStateNodes(stateValue);
    return this.resolveTransition({
      configuration: configuration,
      exitSet: [],
      transitions: [],
      source: undefined,
      actions: []
    }, undefined, context !== null && context !== void 0 ? context : this.machine.context, undefined);
  };

  Object.defineProperty(StateNode.prototype, "initialState", {
    /**
     * The initial State instance, which includes all actions to be executed from
     * entering the initial state.
     */
    get: function () {
      var initialStateValue = this.initialStateValue;

      if (!initialStateValue) {
        throw new Error("Cannot retrieve initial state from simple state '".concat(this.id, "'."));
      }

      return this.getInitialState(initialStateValue);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "target", {
    /**
     * The target state value of the history state node, if it exists. This represents the
     * default state value to transition to if no history value exists yet.
     */
    get: function () {
      var target;

      if (this.type === 'history') {
        var historyConfig = this.config;

        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(historyConfig.target)) {
          target = isStateId(historyConfig.target) ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.pathToStateValue)(this.machine.getStateNodeById(historyConfig.target).path.slice(this.path.length - 1)) : historyConfig.target;
        } else {
          target = historyConfig.target;
        }
      }

      return target;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Returns the leaf nodes from a state path relative to this state node.
   *
   * @param relativeStateId The relative state path to retrieve the state nodes
   * @param history The previous state to retrieve history
   * @param resolve Whether state nodes should resolve to initial child state nodes
   */

  StateNode.prototype.getRelativeStateNodes = function (relativeStateId, historyValue, resolve) {
    if (resolve === void 0) {
      resolve = true;
    }

    return resolve ? relativeStateId.type === 'history' ? relativeStateId.resolveHistory(historyValue) : relativeStateId.initialStateNodes : [relativeStateId];
  };

  Object.defineProperty(StateNode.prototype, "initialStateNodes", {
    get: function () {
      var _this = this;

      if ((0,_stateUtils_js__WEBPACK_IMPORTED_MODULE_4__.isLeafNode)(this)) {
        return [this];
      } // Case when state node is compound but no initial state is defined


      if (this.type === 'compound' && !this.initial) {
        if (!_environment_js__WEBPACK_IMPORTED_MODULE_3__.IS_PRODUCTION) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(false, "Compound state node '".concat(this.id, "' has no initial state."));
        }

        return [this];
      }

      var initialStateNodePaths = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toStatePaths)(this.initialStateValue);
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(initialStateNodePaths.map(function (initialPath) {
        return _this.getFromRelativePath(initialPath);
      }));
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Retrieves state nodes from a relative path to this state node.
   *
   * @param relativePath The relative path from this state node
   * @param historyValue
   */

  StateNode.prototype.getFromRelativePath = function (relativePath) {
    if (!relativePath.length) {
      return [this];
    }

    var _a = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(relativePath),
        stateKey = _a[0],
        childStatePath = _a.slice(1);

    if (!this.states) {
      throw new Error("Cannot retrieve subPath '".concat(stateKey, "' from node with no states"));
    }

    var childStateNode = this.getStateNode(stateKey);

    if (childStateNode.type === 'history') {
      return childStateNode.resolveHistory();
    }

    if (!this.states[stateKey]) {
      throw new Error("Child state '".concat(stateKey, "' does not exist on '").concat(this.id, "'"));
    }

    return this.states[stateKey].getFromRelativePath(childStatePath);
  };

  StateNode.prototype.historyValue = function (relativeStateValue) {
    if (!Object.keys(this.states).length) {
      return undefined;
    }

    return {
      current: relativeStateValue || this.initialStateValue,
      states: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapFilterValues)(this.states, function (stateNode, key) {
        if (!relativeStateValue) {
          return stateNode.historyValue();
        }

        var subStateValue = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(relativeStateValue) ? undefined : relativeStateValue[key];
        return stateNode.historyValue(subStateValue || stateNode.initialStateValue);
      }, function (stateNode) {
        return !stateNode.history;
      })
    };
  };
  /**
   * Resolves to the historical value(s) of the parent state node,
   * represented by state nodes.
   *
   * @param historyValue
   */


  StateNode.prototype.resolveHistory = function (historyValue) {
    var _this = this;

    if (this.type !== 'history') {
      return [this];
    }

    var parent = this.parent;

    if (!historyValue) {
      var historyTarget = this.target;
      return historyTarget ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toStatePaths)(historyTarget).map(function (relativeChildPath) {
        return parent.getFromRelativePath(relativeChildPath);
      })) : parent.initialStateNodes;
    }

    var subHistoryValue = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.nestedPath)(parent.path, 'states')(historyValue).current;

    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(subHistoryValue)) {
      return [parent.getStateNode(subHistoryValue)];
    }

    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toStatePaths)(subHistoryValue).map(function (subStatePath) {
      return _this.history === 'deep' ? parent.getFromRelativePath(subStatePath) : [parent.states[subStatePath[0]]];
    }));
  };

  Object.defineProperty(StateNode.prototype, "stateIds", {
    /**
     * All the state node IDs of this state node and its descendant state nodes.
     */
    get: function () {
      var _this = this;

      var childStateIds = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(Object.keys(this.states).map(function (stateKey) {
        return _this.states[stateKey].stateIds;
      }));
      return [this.id].concat(childStateIds);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "events", {
    /**
     * All the event types accepted by this state node and its descendants.
     */
    get: function () {
      var e_8, _a, e_9, _b;

      if (this.__cache.events) {
        return this.__cache.events;
      }

      var states = this.states;
      var events = new Set(this.ownEvents);

      if (states) {
        try {
          for (var _c = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(Object.keys(states)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var stateId = _d.value;
            var state = states[stateId];

            if (state.states) {
              try {
                for (var _e = (e_9 = void 0, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(state.events)), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var event_1 = _f.value;
                  events.add("".concat(event_1));
                }
              } catch (e_9_1) {
                e_9 = {
                  error: e_9_1
                };
              } finally {
                try {
                  if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                } finally {
                  if (e_9) throw e_9.error;
                }
              }
            }
          }
        } catch (e_8_1) {
          e_8 = {
            error: e_8_1
          };
        } finally {
          try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
          } finally {
            if (e_8) throw e_8.error;
          }
        }
      }

      return this.__cache.events = Array.from(events);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "ownEvents", {
    /**
     * All the events that have transitions directly from this state node.
     *
     * Excludes any inert events.
     */
    get: function () {
      var events = new Set(this.transitions.filter(function (transition) {
        return !(!transition.target && !transition.actions.length && transition.internal);
      }).map(function (transition) {
        return transition.eventType;
      }));
      return Array.from(events);
    },
    enumerable: false,
    configurable: true
  });

  StateNode.prototype.resolveTarget = function (_target) {
    var _this = this;

    if (_target === undefined) {
      // an undefined target signals that the state node should not transition from that state when receiving that event
      return undefined;
    }

    return _target.map(function (target) {
      if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(target)) {
        return target;
      }

      var isInternalTarget = target[0] === _this.delimiter; // If internal target is defined on machine,
      // do not include machine key on target

      if (isInternalTarget && !_this.parent) {
        return _this.getStateNodeByPath(target.slice(1));
      }

      var resolvedTarget = isInternalTarget ? _this.key + target : target;

      if (_this.parent) {
        try {
          var targetStateNode = _this.parent.getStateNodeByPath(resolvedTarget);

          return targetStateNode;
        } catch (err) {
          throw new Error("Invalid transition definition for state node '".concat(_this.id, "':\n").concat(err.message));
        }
      } else {
        return _this.getStateNodeByPath(resolvedTarget);
      }
    });
  };

  StateNode.prototype.formatTransition = function (transitionConfig) {
    var _this = this;

    var normalizedTarget = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalizeTarget)(transitionConfig.target);
    var internal = 'internal' in transitionConfig ? transitionConfig.internal : normalizedTarget ? normalizedTarget.some(function (_target) {
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(_target) && _target[0] === _this.delimiter;
    }) : true;
    var guards = this.machine.options.guards;
    var target = this.resolveTarget(normalizedTarget);

    var transition = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, transitionConfig), {
      actions: (0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.toActionObjects)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(transitionConfig.actions)),
      cond: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toGuard)(transitionConfig.cond, guards),
      target: target,
      source: this,
      internal: internal,
      eventType: transitionConfig.event,
      toJSON: function () {
        return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, transition), {
          target: transition.target ? transition.target.map(function (t) {
            return "#".concat(t.id);
          }) : undefined,
          source: "#".concat(_this.id)
        });
      }
    });

    return transition;
  };

  StateNode.prototype.formatTransitions = function () {
    var e_10, _a;

    var _this = this;

    var onConfig;

    if (!this.config.on) {
      onConfig = [];
    } else if (Array.isArray(this.config.on)) {
      onConfig = this.config.on;
    } else {
      var _b = this.config.on,
          _c = WILDCARD,
          _d = _b[_c],
          wildcardConfigs = _d === void 0 ? [] : _d,
          strictTransitionConfigs_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__rest)(_b, [typeof _c === "symbol" ? _c : _c + ""]);

      onConfig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(Object.keys(strictTransitionConfigs_1).map(function (key) {
        if (!_environment_js__WEBPACK_IMPORTED_MODULE_3__.IS_PRODUCTION && key === NULL_EVENT) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(false, "Empty string transition configs (e.g., `{ on: { '': ... }}`) for transient transitions are deprecated. Specify the transition in the `{ always: ... }` property instead. " + "Please check the `on` configuration for \"#".concat(_this.id, "\"."));
        }

        var transitionConfigArray = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toTransitionConfigArray)(key, strictTransitionConfigs_1[key]);

        if (!_environment_js__WEBPACK_IMPORTED_MODULE_3__.IS_PRODUCTION) {
          validateArrayifiedTransitions(_this, key, transitionConfigArray);
        }

        return transitionConfigArray;
      }).concat((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toTransitionConfigArray)(WILDCARD, wildcardConfigs)));
    }

    var eventlessConfig = this.config.always ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toTransitionConfigArray)('', this.config.always) : [];
    var doneConfig = this.config.onDone ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toTransitionConfigArray)(String((0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.done)(this.id)), this.config.onDone) : [];

    if (!_environment_js__WEBPACK_IMPORTED_MODULE_3__.IS_PRODUCTION) {
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(!(this.config.onDone && !this.parent), "Root nodes cannot have an \".onDone\" transition. Please check the config of \"".concat(this.id, "\"."));
    }

    var invokeConfig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(this.invoke.map(function (invokeDef) {
      var settleTransitions = [];

      if (invokeDef.onDone) {
        settleTransitions.push.apply(settleTransitions, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toTransitionConfigArray)(String((0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.doneInvoke)(invokeDef.id)), invokeDef.onDone)), false));
      }

      if (invokeDef.onError) {
        settleTransitions.push.apply(settleTransitions, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toTransitionConfigArray)(String((0,_actions_js__WEBPACK_IMPORTED_MODULE_5__.error)(invokeDef.id)), invokeDef.onError)), false));
      }

      return settleTransitions;
    }));
    var delayedTransitions = this.after;
    var formattedTransitions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(doneConfig), false), (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(invokeConfig), false), (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(onConfig), false), (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(eventlessConfig), false).map(function (transitionConfig) {
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(transitionConfig).map(function (transition) {
        return _this.formatTransition(transition);
      });
    }));

    try {
      for (var delayedTransitions_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(delayedTransitions), delayedTransitions_1_1 = delayedTransitions_1.next(); !delayedTransitions_1_1.done; delayedTransitions_1_1 = delayedTransitions_1.next()) {
        var delayedTransition = delayedTransitions_1_1.value;
        formattedTransitions.push(delayedTransition);
      }
    } catch (e_10_1) {
      e_10 = {
        error: e_10_1
      };
    } finally {
      try {
        if (delayedTransitions_1_1 && !delayedTransitions_1_1.done && (_a = delayedTransitions_1.return)) _a.call(delayedTransitions_1);
      } finally {
        if (e_10) throw e_10.error;
      }
    }

    return formattedTransitions;
  };

  return StateNode;
}();




/***/ }),

/***/ "./node_modules/xstate/es/_virtual/_tslib.js":
/*!***************************************************!*\
  !*** ./node_modules/xstate/es/_virtual/_tslib.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __assign: () => (/* binding */ __assign),
/* harmony export */   __read: () => (/* binding */ __read),
/* harmony export */   __rest: () => (/* binding */ __rest),
/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),
/* harmony export */   __values: () => (/* binding */ __values)
/* harmony export */ });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}




/***/ }),

/***/ "./node_modules/xstate/es/actionTypes.js":
/*!***********************************************!*\
  !*** ./node_modules/xstate/es/actionTypes.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   after: () => (/* binding */ after),
/* harmony export */   assign: () => (/* binding */ assign),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   choose: () => (/* binding */ choose),
/* harmony export */   doneState: () => (/* binding */ doneState),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   errorExecution: () => (/* binding */ errorExecution),
/* harmony export */   errorPlatform: () => (/* binding */ errorPlatform),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   invoke: () => (/* binding */ invoke),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   nullEvent: () => (/* binding */ nullEvent),
/* harmony export */   pure: () => (/* binding */ pure),
/* harmony export */   raise: () => (/* binding */ raise),
/* harmony export */   send: () => (/* binding */ send),
/* harmony export */   start: () => (/* binding */ start),
/* harmony export */   stop: () => (/* binding */ stop),
/* harmony export */   update: () => (/* binding */ update)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "./node_modules/xstate/es/types.js");


var start = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Start;
var stop = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Stop;
var raise = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Raise;
var send = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Send;
var cancel = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Cancel;
var nullEvent = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.NullEvent;
var assign = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Assign;
var after = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.After;
var doneState = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.DoneState;
var log = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Log;
var init = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Init;
var invoke = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Invoke;
var errorExecution = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.ErrorExecution;
var errorPlatform = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.ErrorPlatform;
var error = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.ErrorCustom;
var update = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Update;
var choose = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Choose;
var pure = _types_js__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.Pure;




/***/ }),

/***/ "./node_modules/xstate/es/actions.js":
/*!*******************************************!*\
  !*** ./node_modules/xstate/es/actions.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   actionTypes: () => (/* reexport module object */ _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   after: () => (/* binding */ after),
/* harmony export */   assign: () => (/* binding */ assign),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   choose: () => (/* binding */ choose),
/* harmony export */   done: () => (/* binding */ done),
/* harmony export */   doneInvoke: () => (/* binding */ doneInvoke),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   escalate: () => (/* binding */ escalate),
/* harmony export */   forwardTo: () => (/* binding */ forwardTo),
/* harmony export */   getActionFunction: () => (/* binding */ getActionFunction),
/* harmony export */   initEvent: () => (/* binding */ initEvent),
/* harmony export */   isActionObject: () => (/* binding */ isActionObject),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   pure: () => (/* binding */ pure),
/* harmony export */   raise: () => (/* binding */ raise),
/* harmony export */   resolveActions: () => (/* binding */ resolveActions),
/* harmony export */   resolveLog: () => (/* binding */ resolveLog),
/* harmony export */   resolveRaise: () => (/* binding */ resolveRaise),
/* harmony export */   resolveSend: () => (/* binding */ resolveSend),
/* harmony export */   resolveStop: () => (/* binding */ resolveStop),
/* harmony export */   respond: () => (/* binding */ respond),
/* harmony export */   send: () => (/* binding */ send),
/* harmony export */   sendParent: () => (/* binding */ sendParent),
/* harmony export */   sendTo: () => (/* binding */ sendTo),
/* harmony export */   sendUpdate: () => (/* binding */ sendUpdate),
/* harmony export */   start: () => (/* binding */ start),
/* harmony export */   stop: () => (/* binding */ stop),
/* harmony export */   toActionObject: () => (/* binding */ toActionObject),
/* harmony export */   toActionObjects: () => (/* binding */ toActionObjects),
/* harmony export */   toActivityDefinition: () => (/* binding */ toActivityDefinition)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.js */ "./node_modules/xstate/es/types.js");
/* harmony import */ var _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actionTypes.js */ "./node_modules/xstate/es/actionTypes.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./environment.js */ "./node_modules/xstate/es/environment.js");








var initEvent = /*#__PURE__*/(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toSCXMLEvent)({
  type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.init
});
function getActionFunction(actionType, actionFunctionMap) {
  return actionFunctionMap ? actionFunctionMap[actionType] || undefined : undefined;
}
function toActionObject(action, actionFunctionMap) {
  var actionObject;

  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(action) || typeof action === 'number') {
    var exec = getActionFunction(action, actionFunctionMap);

    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(exec)) {
      actionObject = {
        type: action,
        exec: exec
      };
    } else if (exec) {
      actionObject = exec;
    } else {
      actionObject = {
        type: action,
        exec: undefined
      };
    }
  } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(action)) {
    actionObject = {
      // Convert action to string if unnamed
      type: action.name || action.toString(),
      exec: action
    };
  } else {
    var exec = getActionFunction(action.type, actionFunctionMap);

    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(exec)) {
      actionObject = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, action), {
        exec: exec
      });
    } else if (exec) {
      var actionType = exec.type || action.type;
      actionObject = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, exec), action), {
        type: actionType
      });
    } else {
      actionObject = action;
    }
  }

  return actionObject;
}
var toActionObjects = function (action, actionFunctionMap) {
  if (!action) {
    return [];
  }

  var actions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(action) ? action : [action];
  return actions.map(function (subAction) {
    return toActionObject(subAction, actionFunctionMap);
  });
};
function toActivityDefinition(action) {
  var actionObject = toActionObject(action);
  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({
    id: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(action) ? action : actionObject.id
  }, actionObject), {
    type: actionObject.type
  });
}
/**
 * Raises an event. This places the event in the internal event queue, so that
 * the event is immediately consumed by the machine in the current step.
 *
 * @param eventType The event to raise.
 */

function raise(event, options) {
  return {
    type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.raise,
    event: typeof event === 'function' ? event : (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toEventObject)(event),
    delay: options ? options.delay : undefined,
    id: options === null || options === void 0 ? void 0 : options.id
  };
}
function resolveRaise(action, ctx, _event, delaysMap) {
  var meta = {
    _event: _event
  };
  var resolvedEvent = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toSCXMLEvent)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(action.event) ? action.event(ctx, _event.data, meta) : action.event);
  var resolvedDelay;

  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(action.delay)) {
    var configDelay = delaysMap && delaysMap[action.delay];
    resolvedDelay = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;
  } else {
    resolvedDelay = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;
  }

  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, action), {
    type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.raise,
    _event: resolvedEvent,
    delay: resolvedDelay
  });
}
/**
 * Sends an event. This returns an action that will be read by an interpreter to
 * send the event in the next step, after the current step is finished executing.
 *
 * @deprecated Use the `sendTo(...)` action creator instead.
 *
 * @param event The event to send.
 * @param options Options to pass into the send event:
 *  - `id` - The unique send event identifier (used with `cancel()`).
 *  - `delay` - The number of milliseconds to delay the sending of the event.
 *  - `to` - The target of this event (by default, the machine the event was sent from).
 */

function send(event, options) {
  return {
    to: options ? options.to : undefined,
    type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.send,
    event: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(event) ? event : (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toEventObject)(event),
    delay: options ? options.delay : undefined,
    // TODO: don't auto-generate IDs here like that
    // there is too big chance of the ID collision
    id: options && options.id !== undefined ? options.id : (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(event) ? event.name : (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.getEventType)(event)
  };
}
function resolveSend(action, ctx, _event, delaysMap) {
  var meta = {
    _event: _event
  }; // TODO: helper function for resolving Expr

  var resolvedEvent = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toSCXMLEvent)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(action.event) ? action.event(ctx, _event.data, meta) : action.event);
  var resolvedDelay;

  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(action.delay)) {
    var configDelay = delaysMap && delaysMap[action.delay];
    resolvedDelay = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;
  } else {
    resolvedDelay = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;
  }

  var resolvedTarget = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(action.to) ? action.to(ctx, _event.data, meta) : action.to;
  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, action), {
    to: resolvedTarget,
    _event: resolvedEvent,
    event: resolvedEvent.data,
    delay: resolvedDelay
  });
}
/**
 * Sends an event to this machine's parent.
 *
 * @param event The event to send to the parent machine.
 * @param options Options to pass into the send event.
 */

function sendParent(event, options) {
  return send(event, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options), {
    to: _types_js__WEBPACK_IMPORTED_MODULE_3__.SpecialTargets.Parent
  }));
}
/**
 * Sends an event to an actor.
 *
 * @param actor The `ActorRef` to send the event to.
 * @param event The event to send, or an expression that evaluates to the event to send
 * @param options Send action options
 * @returns An XState send action object
 */

function sendTo(actor, event, options) {
  return send(event, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options), {
    to: actor
  }));
}
/**
 * Sends an update event to this machine's parent.
 */

function sendUpdate() {
  return sendParent(_actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.update);
}
/**
 * Sends an event back to the sender of the original event.
 *
 * @param event The event to send back to the sender
 * @param options Options to pass into the send event
 */

function respond(event, options) {
  return send(event, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options), {
    to: function (_, __, _a) {
      var _event = _a._event;
      return _event.origin; // TODO: handle when _event.origin is undefined
    }
  }));
}

var defaultLogExpr = function (context, event) {
  return {
    context: context,
    event: event
  };
};
/**
 *
 * @param expr The expression function to evaluate which will be logged.
 *  Takes in 2 arguments:
 *  - `ctx` - the current state context
 *  - `event` - the event that caused this action to be executed.
 * @param label The label to give to the logged expression.
 */


function log(expr, label) {
  if (expr === void 0) {
    expr = defaultLogExpr;
  }

  return {
    type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.log,
    label: label,
    expr: expr
  };
}
var resolveLog = function (action, ctx, _event) {
  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, action), {
    value: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(action.expr) ? action.expr : action.expr(ctx, _event.data, {
      _event: _event
    })
  });
};
/**
 * Cancels an in-flight `send(...)` action. A canceled sent action will not
 * be executed, nor will its event be sent, unless it has already been sent
 * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).
 *
 * @param sendId The `id` of the `send(...)` action to cancel.
 */

var cancel = function (sendId) {
  return {
    type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.cancel,
    sendId: sendId
  };
};
/**
 * Starts an activity.
 *
 * @param activity The activity to start.
 */

function start(activity) {
  var activityDef = toActivityDefinition(activity);
  return {
    type: _types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.Start,
    activity: activityDef,
    exec: undefined
  };
}
/**
 * Stops an activity.
 *
 * @param actorRef The activity to stop.
 */

function stop(actorRef) {
  var activity = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(actorRef) ? actorRef : toActivityDefinition(actorRef);
  return {
    type: _types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.Stop,
    activity: activity,
    exec: undefined
  };
}
function resolveStop(action, context, _event) {
  var actorRefOrString = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(action.activity) ? action.activity(context, _event.data) : action.activity;
  var resolvedActorRef = typeof actorRefOrString === 'string' ? {
    id: actorRefOrString
  } : actorRefOrString;
  var actionObject = {
    type: _types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.Stop,
    activity: resolvedActorRef
  };
  return actionObject;
}
/**
 * Updates the current context of the machine.
 *
 * @param assignment An object that represents the partial context to update.
 */

var assign = function (assignment) {
  return {
    type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.assign,
    assignment: assignment
  };
};
function isActionObject(action) {
  return typeof action === 'object' && 'type' in action;
}
/**
 * Returns an event type that represents an implicit event that
 * is sent after the specified `delay`.
 *
 * @param delayRef The delay in milliseconds
 * @param id The state node ID where this event is handled
 */

function after(delayRef, id) {
  var idSuffix = id ? "#".concat(id) : '';
  return "".concat(_types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.After, "(").concat(delayRef, ")").concat(idSuffix);
}
/**
 * Returns an event that represents that a final state node
 * has been reached in the parent state node.
 *
 * @param id The final state node's parent state node `id`
 * @param data The data to pass into the event
 */

function done(id, data) {
  var type = "".concat(_types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.DoneState, ".").concat(id);
  var eventObject = {
    type: type,
    data: data
  };

  eventObject.toString = function () {
    return type;
  };

  return eventObject;
}
/**
 * Returns an event that represents that an invoked service has terminated.
 *
 * An invoked service is terminated when it has reached a top-level final state node,
 * but not when it is canceled.
 *
 * @param id The final state node ID
 * @param data The data to pass into the event
 */

function doneInvoke(id, data) {
  var type = "".concat(_types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.DoneInvoke, ".").concat(id);
  var eventObject = {
    type: type,
    data: data
  };

  eventObject.toString = function () {
    return type;
  };

  return eventObject;
}
function error(id, data) {
  var type = "".concat(_types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.ErrorPlatform, ".").concat(id);
  var eventObject = {
    type: type,
    data: data
  };

  eventObject.toString = function () {
    return type;
  };

  return eventObject;
}
function pure(getActions) {
  return {
    type: _types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.Pure,
    get: getActions
  };
}
/**
 * Forwards (sends) an event to a specified service.
 *
 * @param target The target service to forward the event to.
 * @param options Options to pass into the send action creator.
 */

function forwardTo(target, options) {
  if (!_environment_js__WEBPACK_IMPORTED_MODULE_4__.IS_PRODUCTION && (!target || typeof target === 'function')) {
    var originalTarget_1 = target;

    target = function () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      var resolvedTarget = typeof originalTarget_1 === 'function' ? originalTarget_1.apply(void 0, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(args), false)) : originalTarget_1;

      if (!resolvedTarget) {
        throw new Error("Attempted to forward event to undefined actor. This risks an infinite loop in the sender.");
      }

      return resolvedTarget;
    };
  }

  return send(function (_, event) {
    return event;
  }, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options), {
    to: target
  }));
}
/**
 * Escalates an error by sending it as an event to this machine's parent.
 *
 * @param errorData The error data to send, or the expression function that
 * takes in the `context`, `event`, and `meta`, and returns the error data to send.
 * @param options Options to pass into the send action creator.
 */

function escalate(errorData, options) {
  return sendParent(function (context, event, meta) {
    return {
      type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.error,
      data: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(errorData) ? errorData(context, event, meta) : errorData
    };
  }, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, options), {
    to: _types_js__WEBPACK_IMPORTED_MODULE_3__.SpecialTargets.Parent
  }));
}
function choose(conds) {
  return {
    type: _types_js__WEBPACK_IMPORTED_MODULE_3__.ActionTypes.Choose,
    conds: conds
  };
}

var pluckAssigns = function (actionBlocks) {
  var e_1, _a;

  var assignActions = [];

  try {
    for (var actionBlocks_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(actionBlocks), actionBlocks_1_1 = actionBlocks_1.next(); !actionBlocks_1_1.done; actionBlocks_1_1 = actionBlocks_1.next()) {
      var block = actionBlocks_1_1.value;
      var i = 0;

      while (i < block.actions.length) {
        if (block.actions[i].type === _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.assign) {
          assignActions.push(block.actions[i]);
          block.actions.splice(i, 1);
          continue;
        }

        i++;
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (actionBlocks_1_1 && !actionBlocks_1_1.done && (_a = actionBlocks_1.return)) _a.call(actionBlocks_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  return assignActions;
};

function resolveActions(machine, currentState, currentContext, _event, actionBlocks, predictableExec, preserveActionOrder) {
  if (preserveActionOrder === void 0) {
    preserveActionOrder = false;
  }

  var assignActions = preserveActionOrder ? [] : pluckAssigns(actionBlocks);
  var updatedContext = assignActions.length ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.updateContext)(currentContext, _event, assignActions, currentState) : currentContext;
  var preservedContexts = preserveActionOrder ? [currentContext] : undefined;
  var deferredToBlockEnd = [];

  function handleAction(blockType, actionObject) {
    var _a;

    switch (actionObject.type) {
      case _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.raise:
        {
          var raisedAction = resolveRaise(actionObject, updatedContext, _event, machine.options.delays);

          if (predictableExec && typeof raisedAction.delay === 'number') {
            predictableExec(raisedAction, updatedContext, _event);
          }

          return raisedAction;
        }

      case _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.send:
        var sendAction = resolveSend(actionObject, updatedContext, _event, machine.options.delays); // TODO: fix ActionTypes.Init

        if (!_environment_js__WEBPACK_IMPORTED_MODULE_4__.IS_PRODUCTION) {
          var configuredDelay = actionObject.delay; // warn after resolving as we can create better contextual message here

          (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.warn)(!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(configuredDelay) || typeof sendAction.delay === 'number', // tslint:disable-next-line:max-line-length
          "No delay reference for delay expression '".concat(configuredDelay, "' was found on machine '").concat(machine.id, "'"));
        }

        if (predictableExec && sendAction.to !== _types_js__WEBPACK_IMPORTED_MODULE_3__.SpecialTargets.Internal) {
          if (blockType === 'entry') {
            deferredToBlockEnd.push(sendAction);
          } else {
            predictableExec(sendAction, updatedContext, _event);
          }
        }

        return sendAction;

      case _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.log:
        {
          var resolved = resolveLog(actionObject, updatedContext, _event);
          predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(resolved, updatedContext, _event);
          return resolved;
        }

      case _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.choose:
        {
          var chooseAction = actionObject;
          var matchedActions = (_a = chooseAction.conds.find(function (condition) {
            var guard = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toGuard)(condition.cond, machine.options.guards);
            return !guard || (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.evaluateGuard)(machine, guard, updatedContext, _event, !predictableExec ? currentState : undefined);
          })) === null || _a === void 0 ? void 0 : _a.actions;

          if (!matchedActions) {
            return [];
          }

          var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(resolveActions(machine, currentState, updatedContext, _event, [{
            type: blockType,
            actions: toActionObjects((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray)(matchedActions), machine.options.actions)
          }], predictableExec, preserveActionOrder), 2),
              resolvedActionsFromChoose = _b[0],
              resolvedContextFromChoose = _b[1];

          updatedContext = resolvedContextFromChoose;
          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);
          return resolvedActionsFromChoose;
        }

      case _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.pure:
        {
          var matchedActions = actionObject.get(updatedContext, _event.data);

          if (!matchedActions) {
            return [];
          }

          var _c = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(resolveActions(machine, currentState, updatedContext, _event, [{
            type: blockType,
            actions: toActionObjects((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray)(matchedActions), machine.options.actions)
          }], predictableExec, preserveActionOrder), 2),
              resolvedActionsFromPure = _c[0],
              resolvedContext = _c[1];

          updatedContext = resolvedContext;
          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);
          return resolvedActionsFromPure;
        }

      case _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.stop:
        {
          var resolved = resolveStop(actionObject, updatedContext, _event);
          predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(resolved, currentContext, _event);
          return resolved;
        }

      case _actionTypes_js__WEBPACK_IMPORTED_MODULE_0__.assign:
        {
          updatedContext = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.updateContext)(updatedContext, _event, [actionObject], !predictableExec ? currentState : undefined);
          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);
          break;
        }

      default:
        var resolvedActionObject = toActionObject(actionObject, machine.options.actions);
        var exec_1 = resolvedActionObject.exec;

        if (predictableExec) {
          predictableExec(resolvedActionObject, updatedContext, _event);
        } else if (exec_1 && preservedContexts) {
          var contextIndex_1 = preservedContexts.length - 1;

          var wrapped = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, resolvedActionObject), {
            exec: function (_ctx) {
              var args = [];

              for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
              }

              exec_1.apply(void 0, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([preservedContexts[contextIndex_1]], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__read)(args), false));
            }
          });

          resolvedActionObject = wrapped;
        }

        return resolvedActionObject;
    }
  }

  function processBlock(block) {
    var e_2, _a;

    var resolvedActions = [];

    try {
      for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_2__.__values)(block.actions), _c = _b.next(); !_c.done; _c = _b.next()) {
        var action = _c.value;
        var resolved = handleAction(block.type, action);

        if (resolved) {
          resolvedActions = resolvedActions.concat(resolved);
        }
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    deferredToBlockEnd.forEach(function (action) {
      predictableExec(action, updatedContext, _event);
    });
    deferredToBlockEnd.length = 0;
    return resolvedActions;
  }

  var resolvedActions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.flatten)(actionBlocks.map(processBlock));
  return [resolvedActions, updatedContext];
}




/***/ }),

/***/ "./node_modules/xstate/es/behaviors.js":
/*!*********************************************!*\
  !*** ./node_modules/xstate/es/behaviors.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fromPromise: () => (/* binding */ fromPromise),
/* harmony export */   fromReducer: () => (/* binding */ fromReducer),
/* harmony export */   spawnBehavior: () => (/* binding */ spawnBehavior)
/* harmony export */ });
/* harmony import */ var _actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actions.js */ "./node_modules/xstate/es/actions.js");
/* harmony import */ var _Actor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Actor.js */ "./node_modules/xstate/es/Actor.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");




/**
 * Returns an actor behavior from a reducer and its initial state.
 *
 * @param transition The pure reducer that returns the next state given the current state and event.
 * @param initialState The initial state of the reducer.
 * @returns An actor behavior
 */

function fromReducer(transition, initialState) {
  return {
    transition: transition,
    initialState: initialState
  };
}
function fromPromise(promiseFn) {
  var initialState = {
    error: undefined,
    data: undefined,
    status: 'pending'
  };
  return {
    transition: function (state, event, _a) {
      var parent = _a.parent,
          id = _a.id,
          observers = _a.observers;

      switch (event.type) {
        case 'fulfill':
          parent === null || parent === void 0 ? void 0 : parent.send((0,_actions_js__WEBPACK_IMPORTED_MODULE_0__.doneInvoke)(id, event.data));
          return {
            error: undefined,
            data: event.data,
            status: 'fulfilled'
          };

        case 'reject':
          parent === null || parent === void 0 ? void 0 : parent.send((0,_actions_js__WEBPACK_IMPORTED_MODULE_0__.error)(id, event.error));
          observers.forEach(function (observer) {
            observer.error(event.error);
          });
          return {
            error: event.error,
            data: undefined,
            status: 'rejected'
          };

        default:
          return state;
      }
    },
    initialState: initialState,
    start: function (_a) {
      var self = _a.self;
      promiseFn().then(function (data) {
        self.send({
          type: 'fulfill',
          data: data
        });
      }, function (reason) {
        self.send({
          type: 'reject',
          error: reason
        });
      });
      return initialState;
    }
  };
}
function spawnBehavior(behavior, options) {
  if (options === void 0) {
    options = {};
  }

  var state = behavior.initialState;
  var observers = new Set();
  var mailbox = [];
  var flushing = false;

  var flush = function () {
    if (flushing) {
      return;
    }

    flushing = true;

    while (mailbox.length > 0) {
      var event_1 = mailbox.shift();
      state = behavior.transition(state, event_1, actorCtx);
      observers.forEach(function (observer) {
        return observer.next(state);
      });
    }

    flushing = false;
  };

  var actor = (0,_Actor_js__WEBPACK_IMPORTED_MODULE_1__.toActorRef)({
    id: options.id,
    send: function (event) {
      mailbox.push(event);
      flush();
    },
    getSnapshot: function () {
      return state;
    },
    subscribe: function (next, handleError, complete) {
      var observer = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toObserver)(next, handleError, complete);
      observers.add(observer);
      observer.next(state);
      return {
        unsubscribe: function () {
          observers.delete(observer);
        }
      };
    }
  });
  var actorCtx = {
    parent: options.parent,
    self: actor,
    id: options.id || 'anonymous',
    observers: observers
  };
  state = behavior.start ? behavior.start(actorCtx) : state;
  return actor;
}




/***/ }),

/***/ "./node_modules/xstate/es/constants.js":
/*!*********************************************!*\
  !*** ./node_modules/xstate/es/constants.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_GUARD_TYPE: () => (/* binding */ DEFAULT_GUARD_TYPE),
/* harmony export */   EMPTY_ACTIVITY_MAP: () => (/* binding */ EMPTY_ACTIVITY_MAP),
/* harmony export */   STATE_DELIMITER: () => (/* binding */ STATE_DELIMITER),
/* harmony export */   TARGETLESS_KEY: () => (/* binding */ TARGETLESS_KEY)
/* harmony export */ });
var STATE_DELIMITER = '.';
var EMPTY_ACTIVITY_MAP = {};
var DEFAULT_GUARD_TYPE = 'xstate.guard';
var TARGETLESS_KEY = '';




/***/ }),

/***/ "./node_modules/xstate/es/devTools.js":
/*!********************************************!*\
  !*** ./node_modules/xstate/es/devTools.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getGlobal: () => (/* binding */ getGlobal),
/* harmony export */   registerService: () => (/* binding */ registerService)
/* harmony export */ });
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./environment.js */ "./node_modules/xstate/es/environment.js");


function getGlobal() {
  if (typeof globalThis !== 'undefined') {
    return globalThis;
  }

  if (typeof self !== 'undefined') {
    return self;
  }

  if (typeof window !== 'undefined') {
    return window;
  }

  if (typeof __webpack_require__.g !== 'undefined') {
    return __webpack_require__.g;
  }

  if (!_environment_js__WEBPACK_IMPORTED_MODULE_0__.IS_PRODUCTION) {
    console.warn('XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues');
  }
}

function getDevTools() {
  var global = getGlobal();

  if (global && '__xstate__' in global) {
    return global.__xstate__;
  }

  return undefined;
}

function registerService(service) {
  if (!getGlobal()) {
    return;
  }

  var devTools = getDevTools();

  if (devTools) {
    devTools.register(service);
  }
}




/***/ }),

/***/ "./node_modules/xstate/es/environment.js":
/*!***********************************************!*\
  !*** ./node_modules/xstate/es/environment.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IS_PRODUCTION: () => (/* binding */ IS_PRODUCTION)
/* harmony export */ });
var IS_PRODUCTION = "development" === 'production';




/***/ }),

/***/ "./node_modules/xstate/es/index.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActionTypes: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_10__.ActionTypes),
/* harmony export */   Interpreter: () => (/* reexport safe */ _interpreter_js__WEBPACK_IMPORTED_MODULE_2__.Interpreter),
/* harmony export */   InterpreterStatus: () => (/* reexport safe */ _interpreter_js__WEBPACK_IMPORTED_MODULE_2__.InterpreterStatus),
/* harmony export */   Machine: () => (/* reexport safe */ _Machine_js__WEBPACK_IMPORTED_MODULE_3__.Machine),
/* harmony export */   SpecialTargets: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_10__.SpecialTargets),
/* harmony export */   State: () => (/* reexport safe */ _State_js__WEBPACK_IMPORTED_MODULE_7__.State),
/* harmony export */   StateNode: () => (/* reexport safe */ _StateNode_js__WEBPACK_IMPORTED_MODULE_8__.StateNode),
/* harmony export */   actions: () => (/* reexport module object */ _actions_js__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   assign: () => (/* binding */ assign),
/* harmony export */   cancel: () => (/* binding */ cancel),
/* harmony export */   choose: () => (/* binding */ choose),
/* harmony export */   createMachine: () => (/* reexport safe */ _Machine_js__WEBPACK_IMPORTED_MODULE_3__.createMachine),
/* harmony export */   createSchema: () => (/* reexport safe */ _schema_js__WEBPACK_IMPORTED_MODULE_6__.createSchema),
/* harmony export */   doneInvoke: () => (/* binding */ doneInvoke),
/* harmony export */   forwardTo: () => (/* binding */ forwardTo),
/* harmony export */   interpret: () => (/* reexport safe */ _interpreter_js__WEBPACK_IMPORTED_MODULE_2__.interpret),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   mapState: () => (/* reexport safe */ _mapState_js__WEBPACK_IMPORTED_MODULE_4__.mapState),
/* harmony export */   matchState: () => (/* reexport safe */ _match_js__WEBPACK_IMPORTED_MODULE_5__.matchState),
/* harmony export */   matchesState: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_11__.matchesState),
/* harmony export */   pure: () => (/* binding */ pure),
/* harmony export */   raise: () => (/* binding */ raise),
/* harmony export */   send: () => (/* binding */ send),
/* harmony export */   sendParent: () => (/* binding */ sendParent),
/* harmony export */   sendTo: () => (/* binding */ sendTo),
/* harmony export */   sendUpdate: () => (/* binding */ sendUpdate),
/* harmony export */   spawn: () => (/* reexport safe */ _interpreter_js__WEBPACK_IMPORTED_MODULE_2__.spawn),
/* harmony export */   spawnBehavior: () => (/* reexport safe */ _behaviors_js__WEBPACK_IMPORTED_MODULE_9__.spawnBehavior),
/* harmony export */   stop: () => (/* binding */ stop),
/* harmony export */   t: () => (/* reexport safe */ _schema_js__WEBPACK_IMPORTED_MODULE_6__.t),
/* harmony export */   toActorRef: () => (/* reexport safe */ _Actor_js__WEBPACK_IMPORTED_MODULE_1__.toActorRef),
/* harmony export */   toEventObject: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_11__.toEventObject),
/* harmony export */   toObserver: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_11__.toObserver),
/* harmony export */   toSCXMLEvent: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_11__.toSCXMLEvent)
/* harmony export */ });
/* harmony import */ var _actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actions.js */ "./node_modules/xstate/es/actions.js");
/* harmony import */ var _Actor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Actor.js */ "./node_modules/xstate/es/Actor.js");
/* harmony import */ var _interpreter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interpreter.js */ "./node_modules/xstate/es/interpreter.js");
/* harmony import */ var _Machine_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Machine.js */ "./node_modules/xstate/es/Machine.js");
/* harmony import */ var _mapState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mapState.js */ "./node_modules/xstate/es/mapState.js");
/* harmony import */ var _match_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./match.js */ "./node_modules/xstate/es/match.js");
/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./schema.js */ "./node_modules/xstate/es/schema.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./State.js */ "./node_modules/xstate/es/State.js");
/* harmony import */ var _StateNode_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./StateNode.js */ "./node_modules/xstate/es/StateNode.js");
/* harmony import */ var _behaviors_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./behaviors.js */ "./node_modules/xstate/es/behaviors.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./types.js */ "./node_modules/xstate/es/types.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");















var assign = _actions_js__WEBPACK_IMPORTED_MODULE_0__.assign,
    cancel = _actions_js__WEBPACK_IMPORTED_MODULE_0__.cancel,
    send = _actions_js__WEBPACK_IMPORTED_MODULE_0__.send,
    sendTo = _actions_js__WEBPACK_IMPORTED_MODULE_0__.sendTo,
    sendParent = _actions_js__WEBPACK_IMPORTED_MODULE_0__.sendParent,
    sendUpdate = _actions_js__WEBPACK_IMPORTED_MODULE_0__.sendUpdate,
    forwardTo = _actions_js__WEBPACK_IMPORTED_MODULE_0__.forwardTo,
    doneInvoke = _actions_js__WEBPACK_IMPORTED_MODULE_0__.doneInvoke,
    raise = _actions_js__WEBPACK_IMPORTED_MODULE_0__.raise,
    log = _actions_js__WEBPACK_IMPORTED_MODULE_0__.log,
    pure = _actions_js__WEBPACK_IMPORTED_MODULE_0__.pure,
    choose = _actions_js__WEBPACK_IMPORTED_MODULE_0__.choose,
    stop = _actions_js__WEBPACK_IMPORTED_MODULE_0__.stop;




/***/ }),

/***/ "./node_modules/xstate/es/interpreter.js":
/*!***********************************************!*\
  !*** ./node_modules/xstate/es/interpreter.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Interpreter: () => (/* binding */ Interpreter),
/* harmony export */   InterpreterStatus: () => (/* binding */ InterpreterStatus),
/* harmony export */   interpret: () => (/* binding */ interpret),
/* harmony export */   spawn: () => (/* binding */ spawn)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.js */ "./node_modules/xstate/es/types.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./State.js */ "./node_modules/xstate/es/State.js");
/* harmony import */ var _actionTypes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./actionTypes.js */ "./node_modules/xstate/es/actionTypes.js");
/* harmony import */ var _actions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./actions.js */ "./node_modules/xstate/es/actions.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./environment.js */ "./node_modules/xstate/es/environment.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");
/* harmony import */ var _scheduler_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scheduler.js */ "./node_modules/xstate/es/scheduler.js");
/* harmony import */ var _Actor_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Actor.js */ "./node_modules/xstate/es/Actor.js");
/* harmony import */ var _registry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./registry.js */ "./node_modules/xstate/es/registry.js");
/* harmony import */ var _devTools_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./devTools.js */ "./node_modules/xstate/es/devTools.js");
/* harmony import */ var _serviceScope_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./serviceScope.js */ "./node_modules/xstate/es/serviceScope.js");
/* harmony import */ var _behaviors_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./behaviors.js */ "./node_modules/xstate/es/behaviors.js");














var DEFAULT_SPAWN_OPTIONS = {
  sync: false,
  autoForward: false
};
var InterpreterStatus;

(function (InterpreterStatus) {
  InterpreterStatus[InterpreterStatus["NotStarted"] = 0] = "NotStarted";
  InterpreterStatus[InterpreterStatus["Running"] = 1] = "Running";
  InterpreterStatus[InterpreterStatus["Stopped"] = 2] = "Stopped";
})(InterpreterStatus || (InterpreterStatus = {}));

var Interpreter =
/*#__PURE__*/

/** @class */
function () {
  /**
   * Creates a new Interpreter instance (i.e., service) for the given machine with the provided options, if any.
   *
   * @param machine The machine to be interpreted
   * @param options Interpreter options
   */
  function Interpreter(machine, options) {
    if (options === void 0) {
      options = Interpreter.defaultOptions;
    }

    var _this = this;

    this.machine = machine;
    this.delayedEventsMap = {};
    this.listeners = new Set();
    this.contextListeners = new Set();
    this.stopListeners = new Set();
    this.doneListeners = new Set();
    this.eventListeners = new Set();
    this.sendListeners = new Set();
    /**
     * Whether the service is started.
     */

    this.initialized = false;
    this.status = InterpreterStatus.NotStarted;
    this.children = new Map();
    this.forwardTo = new Set();
    this._outgoingQueue = [];
    /**
     * Alias for Interpreter.prototype.start
     */

    this.init = this.start;
    /**
     * Sends an event to the running interpreter to trigger a transition.
     *
     * An array of events (batched) can be sent as well, which will send all
     * batched events to the running interpreter. The listeners will be
     * notified only **once** when all events are processed.
     *
     * @param event The event(s) to send
     */

    this.send = function (event, payload) {
      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(event)) {
        _this.batch(event);

        return _this.state;
      }

      var _event = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toEventObject)(event, payload));

      if (_this.status === InterpreterStatus.Stopped) {
        // do nothing
        if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(false, "Event \"".concat(_event.name, "\" was sent to stopped service \"").concat(_this.machine.id, "\". This service has already reached its final state, and will not transition.\nEvent: ").concat(JSON.stringify(_event.data)));
        }

        return _this.state;
      }

      if (_this.status !== InterpreterStatus.Running && !_this.options.deferEvents) {
        throw new Error("Event \"".concat(_event.name, "\" was sent to uninitialized service \"").concat(_this.machine.id // tslint:disable-next-line:max-line-length
        , "\". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.\nEvent: ").concat(JSON.stringify(_event.data)));
      }

      _this.scheduler.schedule(function () {
        // Forward copy of event to child actors
        _this.forward(_event);

        var nextState = _this._nextState(_event);

        _this.update(nextState, _event);
      });

      return _this._state; // TODO: deprecate (should return void)
      // tslint:disable-next-line:semicolon
    };

    this.sendTo = function (event, to, immediate) {
      var isParent = _this.parent && (to === _types_js__WEBPACK_IMPORTED_MODULE_2__.SpecialTargets.Parent || _this.parent.id === to);
      var target = isParent ? _this.parent : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(to) ? to === _types_js__WEBPACK_IMPORTED_MODULE_2__.SpecialTargets.Internal ? _this : _this.children.get(to) || _registry_js__WEBPACK_IMPORTED_MODULE_3__.registry.get(to) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isActor)(to) ? to : undefined;

      if (!target) {
        if (!isParent) {
          throw new Error("Unable to send event to child '".concat(to, "' from service '").concat(_this.id, "'."));
        } // tslint:disable-next-line:no-console


        if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(false, "Service '".concat(_this.id, "' has no parent: unable to send event ").concat(event.type));
        }

        return;
      }

      if ('machine' in target) {
        // perhaps those events should be rejected in the parent
        // but atm it doesn't have easy access to all of the information that is required to do it reliably
        if (_this.status !== InterpreterStatus.Stopped || _this.parent !== target || // we need to send events to the parent from exit handlers of a machine that reached its final state
        _this.state.done) {
          // Send SCXML events to machines
          var scxmlEvent = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, event), {
            name: event.name === _actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.error ? "".concat((0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.error)(_this.id)) : event.name,
            origin: _this.sessionId
          });

          if (!immediate && _this.machine.config.predictableActionArguments) {
            _this._outgoingQueue.push([target, scxmlEvent]);
          } else {
            target.send(scxmlEvent);
          }
        }
      } else {
        // Send normal events to other targets
        if (!immediate && _this.machine.config.predictableActionArguments) {
          _this._outgoingQueue.push([target, event.data]);
        } else {
          target.send(event.data);
        }
      }
    };

    this._exec = function (action, context, _event, actionFunctionMap) {
      if (actionFunctionMap === void 0) {
        actionFunctionMap = _this.machine.options.actions;
      }

      var actionOrExec = action.exec || (0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.getActionFunction)(action.type, actionFunctionMap);
      var exec = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(actionOrExec) ? actionOrExec : actionOrExec ? actionOrExec.exec : action.exec;

      if (exec) {
        try {
          return exec(context, _event.data, !_this.machine.config.predictableActionArguments ? {
            action: action,
            state: _this.state,
            _event: _event
          } : {
            action: action,
            _event: _event
          });
        } catch (err) {
          if (_this.parent) {
            _this.parent.send({
              type: 'xstate.error',
              data: err
            });
          }

          throw err;
        }
      }

      switch (action.type) {
        case _actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.raise:
          {
            // if raise action reached the interpreter then it's a delayed one
            var sendAction_1 = action;

            _this.defer(sendAction_1);

            break;
          }

        case _actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.send:
          var sendAction = action;

          if (typeof sendAction.delay === 'number') {
            _this.defer(sendAction);

            return;
          } else {
            if (sendAction.to) {
              _this.sendTo(sendAction._event, sendAction.to, _event === _actions_js__WEBPACK_IMPORTED_MODULE_6__.initEvent);
            } else {
              _this.send(sendAction._event);
            }
          }

          break;

        case _actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.cancel:
          _this.cancel(action.sendId);

          break;

        case _actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.start:
          {
            if (_this.status !== InterpreterStatus.Running) {
              return;
            }

            var activity = action.activity; // If the activity will be stopped right after it's started
            // (such as in transient states)
            // don't bother starting the activity.

            if ( // in v4 with `predictableActionArguments` invokes are called eagerly when the `this.state` still points to the previous state
            !_this.machine.config.predictableActionArguments && !_this.state.activities[activity.id || activity.type]) {
              break;
            } // Invoked services


            if (activity.type === _types_js__WEBPACK_IMPORTED_MODULE_2__.ActionTypes.Invoke) {
              var invokeSource = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toInvokeSource)(activity.src);
              var serviceCreator = _this.machine.options.services ? _this.machine.options.services[invokeSource.type] : undefined;
              var id = activity.id,
                  data = activity.data;

              if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(!('forward' in activity), // tslint:disable-next-line:max-line-length
                "`forward` property is deprecated (found in invocation of '".concat(activity.src, "' in in machine '").concat(_this.machine.id, "'). ") + "Please use `autoForward` instead.");
              }

              var autoForward = 'autoForward' in activity ? activity.autoForward : !!activity.forward;

              if (!serviceCreator) {
                // tslint:disable-next-line:no-console
                if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
                  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(false, "No service found for invocation '".concat(activity.src, "' in machine '").concat(_this.machine.id, "'."));
                }

                return;
              }

              var resolvedData = data ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapContext)(data, context, _event) : undefined;

              if (typeof serviceCreator === 'string') {
                // TODO: warn
                return;
              }

              var source = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(serviceCreator) ? serviceCreator(context, _event.data, {
                data: resolvedData,
                src: invokeSource,
                meta: activity.meta
              }) : serviceCreator;

              if (!source) {
                // TODO: warn?
                return;
              }

              var options = void 0;

              if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isMachine)(source)) {
                source = resolvedData ? source.withContext(resolvedData) : source;
                options = {
                  autoForward: autoForward
                };
              }

              _this.spawn(source, id, options);
            } else {
              _this.spawnActivity(activity);
            }

            break;
          }

        case _actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.stop:
          {
            _this.stopChild(action.activity.id);

            break;
          }

        case _actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.log:
          var _a = action,
              label = _a.label,
              value = _a.value;

          if (label) {
            _this.logger(label, value);
          } else {
            _this.logger(value);
          }

          break;

        default:
          if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(false, "No implementation found for action type '".concat(action.type, "'"));
          }

          break;
      }
    };

    var resolvedOptions = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, Interpreter.defaultOptions), options);

    var clock = resolvedOptions.clock,
        logger = resolvedOptions.logger,
        parent = resolvedOptions.parent,
        id = resolvedOptions.id;
    var resolvedId = id !== undefined ? id : machine.id;
    this.id = resolvedId;
    this.logger = logger;
    this.clock = clock;
    this.parent = parent;
    this.options = resolvedOptions;
    this.scheduler = new _scheduler_js__WEBPACK_IMPORTED_MODULE_7__.Scheduler({
      deferEvents: this.options.deferEvents
    });
    this.sessionId = _registry_js__WEBPACK_IMPORTED_MODULE_3__.registry.bookId();
  }

  Object.defineProperty(Interpreter.prototype, "initialState", {
    get: function () {
      var _this = this;

      if (this._initialState) {
        return this._initialState;
      }

      return (0,_serviceScope_js__WEBPACK_IMPORTED_MODULE_8__.provide)(this, function () {
        _this._initialState = _this.machine.initialState;
        return _this._initialState;
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Interpreter.prototype, "state", {
    /**
     * @deprecated Use `.getSnapshot()` instead.
     */
    get: function () {
      if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(this.status !== InterpreterStatus.NotStarted, "Attempted to read state from uninitialized service '".concat(this.id, "'. Make sure the service is started first."));
      }

      return this._state;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Executes the actions of the given state, with that state's `context` and `event`.
   *
   * @param state The state whose actions will be executed
   * @param actionsConfig The action implementations to use
   */

  Interpreter.prototype.execute = function (state, actionsConfig) {
    var e_1, _a;

    try {
      for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(state.actions), _c = _b.next(); !_c.done; _c = _b.next()) {
        var action = _c.value;
        this.exec(action, state, actionsConfig);
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  };

  Interpreter.prototype.update = function (state, _event) {
    var e_2, _a, e_3, _b, e_4, _c, e_5, _d;

    var _this = this; // Attach session ID to state


    state._sessionid = this.sessionId; // Update state

    this._state = state; // Execute actions

    if ((!this.machine.config.predictableActionArguments || // this is currently required to execute initial actions as the `initialState` gets cached
    // we can't just recompute it (and execute actions while doing so) because we try to preserve identity of actors created within initial assigns
    _event === _actions_js__WEBPACK_IMPORTED_MODULE_6__.initEvent) && this.options.execute) {
      this.execute(this.state);
    } else {
      var item = void 0;

      while (item = this._outgoingQueue.shift()) {
        item[0].send(item[1]);
      }
    } // Update children


    this.children.forEach(function (child) {
      _this.state.children[child.id] = child;
    }); // Dev tools

    if (this.devTools) {
      this.devTools.send(_event.data, state);
    } // Execute listeners


    if (state.event) {
      try {
        for (var _e = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.eventListeners), _f = _e.next(); !_f.done; _f = _e.next()) {
          var listener = _f.value;
          listener(state.event);
        }
      } catch (e_2_1) {
        e_2 = {
          error: e_2_1
        };
      } finally {
        try {
          if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
    }

    try {
      for (var _g = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.listeners), _h = _g.next(); !_h.done; _h = _g.next()) {
        var listener = _h.value;
        listener(state, state.event);
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    try {
      for (var _j = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.contextListeners), _k = _j.next(); !_k.done; _k = _j.next()) {
        var contextListener = _k.value;
        contextListener(this.state.context, this.state.history ? this.state.history.context : undefined);
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
      } finally {
        if (e_4) throw e_4.error;
      }
    }

    if (this.state.done) {
      // get final child state node
      var finalChildStateNode = state.configuration.find(function (sn) {
        return sn.type === 'final' && sn.parent === _this.machine;
      });
      var doneData = finalChildStateNode && finalChildStateNode.doneData ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapContext)(finalChildStateNode.doneData, state.context, _event) : undefined;
      this._doneEvent = (0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.doneInvoke)(this.id, doneData);

      try {
        for (var _l = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.doneListeners), _m = _l.next(); !_m.done; _m = _l.next()) {
          var listener = _m.value;
          listener(this._doneEvent);
        }
      } catch (e_5_1) {
        e_5 = {
          error: e_5_1
        };
      } finally {
        try {
          if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
        } finally {
          if (e_5) throw e_5.error;
        }
      }

      this._stop();

      this._stopChildren();

      _registry_js__WEBPACK_IMPORTED_MODULE_3__.registry.free(this.sessionId);
    }
  };
  /*
   * Adds a listener that is notified whenever a state transition happens. The listener is called with
   * the next state and the event object that caused the state transition.
   *
   * @param listener The state listener
   */


  Interpreter.prototype.onTransition = function (listener) {
    this.listeners.add(listener); // Send current state to listener

    if (this.status === InterpreterStatus.Running) {
      listener(this.state, this.state.event);
    }

    return this;
  };

  Interpreter.prototype.subscribe = function (nextListenerOrObserver, _, // TODO: error listener
  completeListener) {
    var _this = this;

    var observer = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toObserver)(nextListenerOrObserver, _, completeListener);
    this.listeners.add(observer.next); // Send current state to listener

    if (this.status !== InterpreterStatus.NotStarted) {
      observer.next(this.state);
    }

    var completeOnce = function () {
      _this.doneListeners.delete(completeOnce);

      _this.stopListeners.delete(completeOnce);

      observer.complete();
    };

    if (this.status === InterpreterStatus.Stopped) {
      observer.complete();
    } else {
      this.onDone(completeOnce);
      this.onStop(completeOnce);
    }

    return {
      unsubscribe: function () {
        _this.listeners.delete(observer.next);

        _this.doneListeners.delete(completeOnce);

        _this.stopListeners.delete(completeOnce);
      }
    };
  };
  /**
   * Adds an event listener that is notified whenever an event is sent to the running interpreter.
   * @param listener The event listener
   */


  Interpreter.prototype.onEvent = function (listener) {
    this.eventListeners.add(listener);
    return this;
  };
  /**
   * Adds an event listener that is notified whenever a `send` event occurs.
   * @param listener The event listener
   */


  Interpreter.prototype.onSend = function (listener) {
    this.sendListeners.add(listener);
    return this;
  };
  /**
   * Adds a context listener that is notified whenever the state context changes.
   * @param listener The context listener
   */


  Interpreter.prototype.onChange = function (listener) {
    this.contextListeners.add(listener);
    return this;
  };
  /**
   * Adds a listener that is notified when the machine is stopped.
   * @param listener The listener
   */


  Interpreter.prototype.onStop = function (listener) {
    this.stopListeners.add(listener);
    return this;
  };
  /**
   * Adds a state listener that is notified when the statechart has reached its final state.
   * @param listener The state listener
   */


  Interpreter.prototype.onDone = function (listener) {
    if (this.status === InterpreterStatus.Stopped && this._doneEvent) {
      listener(this._doneEvent);
    } else {
      this.doneListeners.add(listener);
    }

    return this;
  };
  /**
   * Removes a listener.
   * @param listener The listener to remove
   */


  Interpreter.prototype.off = function (listener) {
    this.listeners.delete(listener);
    this.eventListeners.delete(listener);
    this.sendListeners.delete(listener);
    this.stopListeners.delete(listener);
    this.doneListeners.delete(listener);
    this.contextListeners.delete(listener);
    return this;
  };
  /**
   * Starts the interpreter from the given state, or the initial state.
   * @param initialState The state to start the statechart from
   */


  Interpreter.prototype.start = function (initialState) {
    var _this = this;

    if (this.status === InterpreterStatus.Running) {
      // Do not restart the service if it is already started
      return this;
    } // yes, it's a hack but we need the related cache to be populated for some things to work (like delayed transitions)
    // this is usually called by `machine.getInitialState` but if we rehydrate from a state we might bypass this call
    // we also don't want to call this method here as it resolves the full initial state which might involve calling assign actions
    // and that could potentially lead to some unwanted side-effects (even such as creating some rogue actors)


    this.machine._init();

    _registry_js__WEBPACK_IMPORTED_MODULE_3__.registry.register(this.sessionId, this);
    this.initialized = true;
    this.status = InterpreterStatus.Running;
    var resolvedState = initialState === undefined ? this.initialState : (0,_serviceScope_js__WEBPACK_IMPORTED_MODULE_8__.provide)(this, function () {
      return (0,_State_js__WEBPACK_IMPORTED_MODULE_9__.isStateConfig)(initialState) ? _this.machine.resolveState(initialState) : _this.machine.resolveState(_State_js__WEBPACK_IMPORTED_MODULE_9__.State.from(initialState, _this.machine.context));
    });

    if (this.options.devTools) {
      this.attachDev();
    }

    this.scheduler.initialize(function () {
      _this.update(resolvedState, _actions_js__WEBPACK_IMPORTED_MODULE_6__.initEvent);
    });
    return this;
  };

  Interpreter.prototype._stopChildren = function () {
    // TODO: think about converting those to actions
    this.children.forEach(function (child) {
      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(child.stop)) {
        child.stop();
      }
    });
    this.children.clear();
  };

  Interpreter.prototype._stop = function () {
    var e_6, _a, e_7, _b, e_8, _c, e_9, _d, e_10, _e;

    try {
      for (var _f = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.listeners), _g = _f.next(); !_g.done; _g = _f.next()) {
        var listener = _g.value;
        this.listeners.delete(listener);
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
      } finally {
        if (e_6) throw e_6.error;
      }
    }

    try {
      for (var _h = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.stopListeners), _j = _h.next(); !_j.done; _j = _h.next()) {
        var listener = _j.value; // call listener, then remove

        listener();
        this.stopListeners.delete(listener);
      }
    } catch (e_7_1) {
      e_7 = {
        error: e_7_1
      };
    } finally {
      try {
        if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
      } finally {
        if (e_7) throw e_7.error;
      }
    }

    try {
      for (var _k = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.contextListeners), _l = _k.next(); !_l.done; _l = _k.next()) {
        var listener = _l.value;
        this.contextListeners.delete(listener);
      }
    } catch (e_8_1) {
      e_8 = {
        error: e_8_1
      };
    } finally {
      try {
        if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
      } finally {
        if (e_8) throw e_8.error;
      }
    }

    try {
      for (var _m = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.doneListeners), _o = _m.next(); !_o.done; _o = _m.next()) {
        var listener = _o.value;
        this.doneListeners.delete(listener);
      }
    } catch (e_9_1) {
      e_9 = {
        error: e_9_1
      };
    } finally {
      try {
        if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
      } finally {
        if (e_9) throw e_9.error;
      }
    }

    if (!this.initialized) {
      // Interpreter already stopped; do nothing
      return this;
    }

    this.initialized = false;
    this.status = InterpreterStatus.Stopped;
    this._initialState = undefined;

    try {
      // we are going to stop within the current sync frame
      // so we can safely just cancel this here as nothing async should be fired anyway
      for (var _p = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(Object.keys(this.delayedEventsMap)), _q = _p.next(); !_q.done; _q = _p.next()) {
        var key = _q.value;
        this.clock.clearTimeout(this.delayedEventsMap[key]);
      }
    } catch (e_10_1) {
      e_10 = {
        error: e_10_1
      };
    } finally {
      try {
        if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
      } finally {
        if (e_10) throw e_10.error;
      }
    } // clear everything that might be enqueued


    this.scheduler.clear();
    this.scheduler = new _scheduler_js__WEBPACK_IMPORTED_MODULE_7__.Scheduler({
      deferEvents: this.options.deferEvents
    });
  };
  /**
   * Stops the interpreter and unsubscribe all listeners.
   *
   * This will also notify the `onStop` listeners.
   */


  Interpreter.prototype.stop = function () {
    // TODO: add warning for stopping non-root interpreters
    var _this = this; // grab the current scheduler as it will be replaced in _stop


    var scheduler = this.scheduler;

    this._stop(); // let what is currently processed to be finished


    scheduler.schedule(function () {
      // it feels weird to handle this here but we need to handle this even slightly "out of band"
      var _event = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)({
        type: 'xstate.stop'
      });

      var nextState = (0,_serviceScope_js__WEBPACK_IMPORTED_MODULE_8__.provide)(_this, function () {
        var exitActions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__read)(_this.state.configuration), false).sort(function (a, b) {
          return b.order - a.order;
        }).map(function (stateNode) {
          return (0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.toActionObjects)(stateNode.onExit, _this.machine.options.actions);
        }));

        var _a = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__read)((0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.resolveActions)(_this.machine, _this.state, _this.state.context, _event, [{
          type: 'exit',
          actions: exitActions
        }], _this.machine.config.predictableActionArguments ? _this._exec : undefined, _this.machine.config.predictableActionArguments || _this.machine.config.preserveActionOrder), 2),
            resolvedActions = _a[0],
            updatedContext = _a[1];

        var newState = new _State_js__WEBPACK_IMPORTED_MODULE_9__.State({
          value: _this.state.value,
          context: updatedContext,
          _event: _event,
          _sessionid: _this.sessionId,
          historyValue: undefined,
          history: _this.state,
          actions: resolvedActions.filter(function (action) {
            return !(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isRaisableAction)(action);
          }),
          activities: {},
          events: [],
          configuration: [],
          transitions: [],
          children: {},
          done: _this.state.done,
          tags: _this.state.tags,
          machine: _this.machine
        });
        newState.changed = true;
        return newState;
      });

      _this.update(nextState, _event);

      _this._stopChildren();

      _registry_js__WEBPACK_IMPORTED_MODULE_3__.registry.free(_this.sessionId);
    });
    return this;
  };

  Interpreter.prototype.batch = function (events) {
    var _this = this;

    if (this.status === InterpreterStatus.NotStarted && this.options.deferEvents) {
      // tslint:disable-next-line:no-console
      if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(false, "".concat(events.length, " event(s) were sent to uninitialized service \"").concat(this.machine.id, "\" and are deferred. Make sure .start() is called for this service.\nEvent: ").concat(JSON.stringify(event)));
      }
    } else if (this.status !== InterpreterStatus.Running) {
      throw new Error( // tslint:disable-next-line:max-line-length
      "".concat(events.length, " event(s) were sent to uninitialized service \"").concat(this.machine.id, "\". Make sure .start() is called for this service, or set { deferEvents: true } in the service options."));
    }

    if (!events.length) {
      return;
    }

    var exec = !!this.machine.config.predictableActionArguments && this._exec;
    this.scheduler.schedule(function () {
      var e_11, _a;

      var nextState = _this.state;
      var batchChanged = false;
      var batchedActions = [];

      var _loop_1 = function (event_1) {
        var _event = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(event_1);

        _this.forward(_event);

        nextState = (0,_serviceScope_js__WEBPACK_IMPORTED_MODULE_8__.provide)(_this, function () {
          return _this.machine.transition(nextState, _event, undefined, exec || undefined);
        });
        batchedActions.push.apply(batchedActions, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__read)(_this.machine.config.predictableActionArguments ? nextState.actions : nextState.actions.map(function (a) {
          return (0,_State_js__WEBPACK_IMPORTED_MODULE_9__.bindActionToState)(a, nextState);
        })), false));
        batchChanged = batchChanged || !!nextState.changed;
      };

      try {
        for (var events_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
          var event_1 = events_1_1.value;

          _loop_1(event_1);
        }
      } catch (e_11_1) {
        e_11 = {
          error: e_11_1
        };
      } finally {
        try {
          if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);
        } finally {
          if (e_11) throw e_11.error;
        }
      }

      nextState.changed = batchChanged;
      nextState.actions = batchedActions;

      _this.update(nextState, (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(events[events.length - 1]));
    });
  };
  /**
   * Returns a send function bound to this interpreter instance.
   *
   * @param event The event to be sent by the sender.
   */


  Interpreter.prototype.sender = function (event) {
    return this.send.bind(this, event);
  };

  Interpreter.prototype._nextState = function (event, exec) {
    var _this = this;

    if (exec === void 0) {
      exec = !!this.machine.config.predictableActionArguments && this._exec;
    }

    var _event = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(event);

    if (_event.name.indexOf(_actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.errorPlatform) === 0 && !this.state.nextEvents.some(function (nextEvent) {
      return nextEvent.indexOf(_actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.errorPlatform) === 0;
    })) {
      throw _event.data.data;
    }

    var nextState = (0,_serviceScope_js__WEBPACK_IMPORTED_MODULE_8__.provide)(this, function () {
      return _this.machine.transition(_this.state, _event, undefined, exec || undefined);
    });
    return nextState;
  };
  /**
   * Returns the next state given the interpreter's current state and the event.
   *
   * This is a pure method that does _not_ update the interpreter's state.
   *
   * @param event The event to determine the next state
   */


  Interpreter.prototype.nextState = function (event) {
    return this._nextState(event, false);
  };

  Interpreter.prototype.forward = function (event) {
    var e_12, _a;

    try {
      for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__values)(this.forwardTo), _c = _b.next(); !_c.done; _c = _b.next()) {
        var id = _c.value;
        var child = this.children.get(id);

        if (!child) {
          throw new Error("Unable to forward event '".concat(event, "' from interpreter '").concat(this.id, "' to nonexistant child '").concat(id, "'."));
        }

        child.send(event);
      }
    } catch (e_12_1) {
      e_12 = {
        error: e_12_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_12) throw e_12.error;
      }
    }
  };

  Interpreter.prototype.defer = function (sendAction) {
    var _this = this;

    var timerId = this.clock.setTimeout(function () {
      if ('to' in sendAction && sendAction.to) {
        _this.sendTo(sendAction._event, sendAction.to, true);
      } else {
        _this.send(sendAction._event);
      }
    }, sendAction.delay);

    if (sendAction.id) {
      this.delayedEventsMap[sendAction.id] = timerId;
    }
  };

  Interpreter.prototype.cancel = function (sendId) {
    this.clock.clearTimeout(this.delayedEventsMap[sendId]);
    delete this.delayedEventsMap[sendId];
  };

  Interpreter.prototype.exec = function (action, state, actionFunctionMap) {
    if (actionFunctionMap === void 0) {
      actionFunctionMap = this.machine.options.actions;
    }

    this._exec(action, state.context, state._event, actionFunctionMap);
  };

  Interpreter.prototype.removeChild = function (childId) {
    var _a;

    this.children.delete(childId);
    this.forwardTo.delete(childId); // this.state might not exist at the time this is called,
    // such as when a child is added then removed while initializing the state

    (_a = this.state) === null || _a === void 0 ? true : delete _a.children[childId];
  };

  Interpreter.prototype.stopChild = function (childId) {
    var child = this.children.get(childId);

    if (!child) {
      return;
    }

    this.removeChild(childId);

    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(child.stop)) {
      child.stop();
    }
  };

  Interpreter.prototype.spawn = function (entity, name, options) {
    if (this.status !== InterpreterStatus.Running) {
      return (0,_Actor_js__WEBPACK_IMPORTED_MODULE_10__.createDeferredActor)(entity, name);
    }

    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(entity)) {
      return this.spawnPromise(Promise.resolve(entity), name);
    } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(entity)) {
      return this.spawnCallback(entity, name);
    } else if ((0,_Actor_js__WEBPACK_IMPORTED_MODULE_10__.isSpawnedActor)(entity)) {
      return this.spawnActor(entity, name);
    } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isObservable)(entity)) {
      return this.spawnObservable(entity, name);
    } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isMachine)(entity)) {
      return this.spawnMachine(entity, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, options), {
        id: name
      }));
    } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBehavior)(entity)) {
      return this.spawnBehavior(entity, name);
    } else {
      throw new Error("Unable to spawn entity \"".concat(name, "\" of type \"").concat(typeof entity, "\"."));
    }
  };

  Interpreter.prototype.spawnMachine = function (machine, options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    var childService = new Interpreter(machine, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, this.options), {
      parent: this,
      id: options.id || machine.id
    }));

    var resolvedOptions = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, DEFAULT_SPAWN_OPTIONS), options);

    if (resolvedOptions.sync) {
      childService.onTransition(function (state) {
        _this.send(_actionTypes_js__WEBPACK_IMPORTED_MODULE_5__.update, {
          state: state,
          id: childService.id
        });
      });
    }

    var actor = childService;
    this.children.set(childService.id, actor);

    if (resolvedOptions.autoForward) {
      this.forwardTo.add(childService.id);
    }

    childService.onDone(function (doneEvent) {
      _this.removeChild(childService.id);

      _this.send((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(doneEvent, {
        origin: childService.id
      }));
    }).start();
    return actor;
  };

  Interpreter.prototype.spawnBehavior = function (behavior, id) {
    var actorRef = (0,_behaviors_js__WEBPACK_IMPORTED_MODULE_11__.spawnBehavior)(behavior, {
      id: id,
      parent: this
    });
    this.children.set(id, actorRef);
    return actorRef;
  };

  Interpreter.prototype.spawnPromise = function (promise, id) {
    var _a;

    var _this = this;

    var canceled = false;
    var resolvedData;
    promise.then(function (response) {
      if (!canceled) {
        resolvedData = response;

        _this.removeChild(id);

        _this.send((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)((0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.doneInvoke)(id, response), {
          origin: id
        }));
      }
    }, function (errorData) {
      if (!canceled) {
        _this.removeChild(id);

        var errorEvent = (0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.error)(id, errorData);

        try {
          // Send "error.platform.id" to this (parent).
          _this.send((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(errorEvent, {
            origin: id
          }));
        } catch (error) {
          (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.reportUnhandledExceptionOnInvocation)(errorData, error, id);

          if (_this.devTools) {
            _this.devTools.send(errorEvent, _this.state);
          }

          if (_this.machine.strict) {
            // it would be better to always stop the state machine if unhandled
            // exception/promise rejection happens but because we don't want to
            // break existing code so enforce it on strict mode only especially so
            // because documentation says that onError is optional
            _this.stop();
          }
        }
      }
    });
    var actor = (_a = {
      id: id,
      send: function () {
        return void 0;
      },
      subscribe: function (next, handleError, complete) {
        var observer = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toObserver)(next, handleError, complete);
        var unsubscribed = false;
        promise.then(function (response) {
          if (unsubscribed) {
            return;
          }

          observer.next(response);

          if (unsubscribed) {
            return;
          }

          observer.complete();
        }, function (err) {
          if (unsubscribed) {
            return;
          }

          observer.error(err);
        });
        return {
          unsubscribe: function () {
            return unsubscribed = true;
          }
        };
      },
      stop: function () {
        canceled = true;
      },
      toJSON: function () {
        return {
          id: id
        };
      },
      getSnapshot: function () {
        return resolvedData;
      }
    }, _a[_utils_js__WEBPACK_IMPORTED_MODULE_0__.symbolObservable] = function () {
      return this;
    }, _a);
    this.children.set(id, actor);
    return actor;
  };

  Interpreter.prototype.spawnCallback = function (callback, id) {
    var _a;

    var _this = this;

    var canceled = false;
    var receivers = new Set();
    var listeners = new Set();
    var emitted;

    var receive = function (e) {
      emitted = e;
      listeners.forEach(function (listener) {
        return listener(e);
      });

      if (canceled) {
        return;
      }

      _this.send((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(e, {
        origin: id
      }));
    };

    var callbackStop;

    try {
      callbackStop = callback(receive, function (newListener) {
        receivers.add(newListener);
      });
    } catch (err) {
      this.send((0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.error)(id, err));
    }

    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(callbackStop)) {
      // it turned out to be an async function, can't reliably check this before calling `callback`
      // because transpiled async functions are not recognizable
      return this.spawnPromise(callbackStop, id);
    }

    var actor = (_a = {
      id: id,
      send: function (event) {
        return receivers.forEach(function (receiver) {
          return receiver(event);
        });
      },
      subscribe: function (next) {
        var observer = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toObserver)(next);
        listeners.add(observer.next);
        return {
          unsubscribe: function () {
            listeners.delete(observer.next);
          }
        };
      },
      stop: function () {
        canceled = true;

        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(callbackStop)) {
          callbackStop();
        }
      },
      toJSON: function () {
        return {
          id: id
        };
      },
      getSnapshot: function () {
        return emitted;
      }
    }, _a[_utils_js__WEBPACK_IMPORTED_MODULE_0__.symbolObservable] = function () {
      return this;
    }, _a);
    this.children.set(id, actor);
    return actor;
  };

  Interpreter.prototype.spawnObservable = function (source, id) {
    var _a;

    var _this = this;

    var emitted;
    var subscription = source.subscribe(function (value) {
      emitted = value;

      _this.send((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)(value, {
        origin: id
      }));
    }, function (err) {
      _this.removeChild(id);

      _this.send((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)((0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.error)(id, err), {
        origin: id
      }));
    }, function () {
      _this.removeChild(id);

      _this.send((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toSCXMLEvent)((0,_actions_js__WEBPACK_IMPORTED_MODULE_6__.doneInvoke)(id), {
        origin: id
      }));
    });
    var actor = (_a = {
      id: id,
      send: function () {
        return void 0;
      },
      subscribe: function (next, handleError, complete) {
        return source.subscribe(next, handleError, complete);
      },
      stop: function () {
        return subscription.unsubscribe();
      },
      getSnapshot: function () {
        return emitted;
      },
      toJSON: function () {
        return {
          id: id
        };
      }
    }, _a[_utils_js__WEBPACK_IMPORTED_MODULE_0__.symbolObservable] = function () {
      return this;
    }, _a);
    this.children.set(id, actor);
    return actor;
  };

  Interpreter.prototype.spawnActor = function (actor, name) {
    this.children.set(name, actor);
    return actor;
  };

  Interpreter.prototype.spawnActivity = function (activity) {
    var implementation = this.machine.options && this.machine.options.activities ? this.machine.options.activities[activity.type] : undefined;

    if (!implementation) {
      if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(false, "No implementation found for activity '".concat(activity.type, "'"));
      } // tslint:disable-next-line:no-console


      return;
    } // Start implementation


    var dispose = implementation(this.state.context, activity);
    this.spawnEffect(activity.id, dispose);
  };

  Interpreter.prototype.spawnEffect = function (id, dispose) {
    var _a;

    this.children.set(id, (_a = {
      id: id,
      send: function () {
        return void 0;
      },
      subscribe: function () {
        return {
          unsubscribe: function () {
            return void 0;
          }
        };
      },
      stop: dispose || undefined,
      getSnapshot: function () {
        return undefined;
      },
      toJSON: function () {
        return {
          id: id
        };
      }
    }, _a[_utils_js__WEBPACK_IMPORTED_MODULE_0__.symbolObservable] = function () {
      return this;
    }, _a));
  };

  Interpreter.prototype.attachDev = function () {
    var global = (0,_devTools_js__WEBPACK_IMPORTED_MODULE_12__.getGlobal)();

    if (this.options.devTools && global) {
      if (global.__REDUX_DEVTOOLS_EXTENSION__) {
        var devToolsOptions = typeof this.options.devTools === 'object' ? this.options.devTools : undefined;
        this.devTools = global.__REDUX_DEVTOOLS_EXTENSION__.connect((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({
          name: this.id,
          autoPause: true,
          stateSanitizer: function (state) {
            return {
              value: state.value,
              context: state.context,
              actions: state.actions
            };
          }
        }, devToolsOptions), {
          features: (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({
            jump: false,
            skip: false
          }, devToolsOptions ? devToolsOptions.features : undefined)
        }), this.machine);
        this.devTools.init(this.state);
      } // add XState-specific dev tooling hook


      (0,_devTools_js__WEBPACK_IMPORTED_MODULE_12__.registerService)(this);
    }
  };

  Interpreter.prototype.toJSON = function () {
    return {
      id: this.id
    };
  };

  Interpreter.prototype[_utils_js__WEBPACK_IMPORTED_MODULE_0__.symbolObservable] = function () {
    return this;
  };

  Interpreter.prototype.getSnapshot = function () {
    if (this.status === InterpreterStatus.NotStarted) {
      return this.initialState;
    }

    return this._state;
  };
  /**
   * The default interpreter options:
   *
   * - `clock` uses the global `setTimeout` and `clearTimeout` functions
   * - `logger` uses the global `console.log()` method
   */


  Interpreter.defaultOptions = {
    execute: true,
    deferEvents: true,
    clock: {
      setTimeout: function (fn, ms) {
        return setTimeout(fn, ms);
      },
      clearTimeout: function (id) {
        return clearTimeout(id);
      }
    },
    logger: /*#__PURE__*/console.log.bind(console),
    devTools: false
  };
  Interpreter.interpret = interpret;
  return Interpreter;
}();

var resolveSpawnOptions = function (nameOrOptions) {
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isString)(nameOrOptions)) {
    return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, DEFAULT_SPAWN_OPTIONS), {
      name: nameOrOptions
    });
  }

  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_4__.__assign)({}, DEFAULT_SPAWN_OPTIONS), {
    name: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.uniqueId)()
  }), nameOrOptions);
};

function spawn(entity, nameOrOptions) {
  var resolvedOptions = resolveSpawnOptions(nameOrOptions);
  return (0,_serviceScope_js__WEBPACK_IMPORTED_MODULE_8__.consume)(function (service) {
    if (!_environment_js__WEBPACK_IMPORTED_MODULE_1__.IS_PRODUCTION) {
      var isLazyEntity = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isMachine)(entity) || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(entity);
      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.warn)(!!service || isLazyEntity, "Attempted to spawn an Actor (ID: \"".concat((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isMachine)(entity) ? entity.id : 'undefined', "\") outside of a service. This will have no effect."));
    }

    if (service) {
      return service.spawn(entity, resolvedOptions.name, resolvedOptions);
    } else {
      return (0,_Actor_js__WEBPACK_IMPORTED_MODULE_10__.createDeferredActor)(entity, resolvedOptions.name);
    }
  });
}
/**
 * Creates a new Interpreter instance for the given machine with the provided options, if any.
 *
 * @param machine The machine to interpret
 * @param options Interpreter options
 */

function interpret(machine, options) {
  var interpreter = new Interpreter(machine, options);
  return interpreter;
}




/***/ }),

/***/ "./node_modules/xstate/es/invokeUtils.js":
/*!***********************************************!*\
  !*** ./node_modules/xstate/es/invokeUtils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toInvokeDefinition: () => (/* binding */ toInvokeDefinition),
/* harmony export */   toInvokeSource: () => (/* binding */ toInvokeSource)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _actionTypes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./actionTypes.js */ "./node_modules/xstate/es/actionTypes.js");






function toInvokeSource(src) {
  if (typeof src === 'string') {
    var simpleSrc = {
      type: src
    };

    simpleSrc.toString = function () {
      return src;
    }; // v4 compat - TODO: remove in v5


    return simpleSrc;
  }

  return src;
}
function toInvokeDefinition(invokeConfig) {
  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__.__assign)({
    type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_1__.invoke
  }, invokeConfig), {
    toJSON: function () {
      invokeConfig.onDone;
          invokeConfig.onError;
          var invokeDef = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__.__rest)(invokeConfig, ["onDone", "onError"]);

      return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, invokeDef), {
        type: _actionTypes_js__WEBPACK_IMPORTED_MODULE_1__.invoke,
        src: toInvokeSource(invokeConfig.src)
      });
    }
  });
}




/***/ }),

/***/ "./node_modules/xstate/es/mapState.js":
/*!********************************************!*\
  !*** ./node_modules/xstate/es/mapState.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapState: () => (/* binding */ mapState)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");



function mapState(stateMap, stateId) {
  var e_1, _a;

  var foundStateId;

  try {
    for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__.__values)(Object.keys(stateMap)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var mappedStateId = _c.value;

      if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.matchesState)(mappedStateId, stateId) && (!foundStateId || stateId.length > foundStateId.length)) {
        foundStateId = mappedStateId;
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  return stateMap[foundStateId];
}




/***/ }),

/***/ "./node_modules/xstate/es/match.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/match.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   matchState: () => (/* binding */ matchState)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./State.js */ "./node_modules/xstate/es/State.js");



function matchState(state, patterns, defaultValue) {
  var e_1, _a;

  var resolvedState = _State_js__WEBPACK_IMPORTED_MODULE_0__.State.from(state, state instanceof _State_js__WEBPACK_IMPORTED_MODULE_0__.State ? state.context : undefined);

  try {
    for (var patterns_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(patterns), patterns_1_1 = patterns_1.next(); !patterns_1_1.done; patterns_1_1 = patterns_1.next()) {
      var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__read)(patterns_1_1.value, 2),
          stateValue = _b[0],
          getValue = _b[1];

      if (resolvedState.matches(stateValue)) {
        return getValue(resolvedState);
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (patterns_1_1 && !patterns_1_1.done && (_a = patterns_1.return)) _a.call(patterns_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  return defaultValue(resolvedState);
}




/***/ }),

/***/ "./node_modules/xstate/es/registry.js":
/*!********************************************!*\
  !*** ./node_modules/xstate/es/registry.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registry: () => (/* binding */ registry)
/* harmony export */ });
var children = /*#__PURE__*/new Map();
var sessionIdIndex = 0;
var registry = {
  bookId: function () {
    return "x:".concat(sessionIdIndex++);
  },
  register: function (id, actor) {
    children.set(id, actor);
    return id;
  },
  get: function (id) {
    return children.get(id);
  },
  free: function (id) {
    children.delete(id);
  }
};




/***/ }),

/***/ "./node_modules/xstate/es/scheduler.js":
/*!*********************************************!*\
  !*** ./node_modules/xstate/es/scheduler.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Scheduler: () => (/* binding */ Scheduler)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");


var defaultOptions = {
  deferEvents: false
};

var Scheduler =
/*#__PURE__*/

/** @class */
function () {
  function Scheduler(options) {
    this.processingEvent = false;
    this.queue = [];
    this.initialized = false;
    this.options = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, defaultOptions), options);
  }

  Scheduler.prototype.initialize = function (callback) {
    this.initialized = true;

    if (callback) {
      if (!this.options.deferEvents) {
        this.schedule(callback);
        return;
      }

      this.process(callback);
    }

    this.flushEvents();
  };

  Scheduler.prototype.schedule = function (task) {
    if (!this.initialized || this.processingEvent) {
      this.queue.push(task);
      return;
    }

    if (this.queue.length !== 0) {
      throw new Error('Event queue should be empty when it is not processing events');
    }

    this.process(task);
    this.flushEvents();
  };

  Scheduler.prototype.clear = function () {
    this.queue = [];
  };

  Scheduler.prototype.flushEvents = function () {
    var nextCallback = this.queue.shift();

    while (nextCallback) {
      this.process(nextCallback);
      nextCallback = this.queue.shift();
    }
  };

  Scheduler.prototype.process = function (callback) {
    this.processingEvent = true;

    try {
      callback();
    } catch (e) {
      // there is no use to keep the future events
      // as the situation is not anymore the same
      this.clear();
      throw e;
    } finally {
      this.processingEvent = false;
    }
  };

  return Scheduler;
}();




/***/ }),

/***/ "./node_modules/xstate/es/schema.js":
/*!******************************************!*\
  !*** ./node_modules/xstate/es/schema.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSchema: () => (/* binding */ createSchema),
/* harmony export */   t: () => (/* binding */ t)
/* harmony export */ });
function createSchema(schema) {
  return schema;
}
var t = createSchema;




/***/ }),

/***/ "./node_modules/xstate/es/serviceScope.js":
/*!************************************************!*\
  !*** ./node_modules/xstate/es/serviceScope.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   consume: () => (/* binding */ consume),
/* harmony export */   provide: () => (/* binding */ provide)
/* harmony export */ });
/**
 * Maintains a stack of the current service in scope.
 * This is used to provide the correct service to spawn().
 */
var serviceStack = [];
var provide = function (service, fn) {
  serviceStack.push(service);
  var result = fn(service);
  serviceStack.pop();
  return result;
};
var consume = function (fn) {
  return fn(serviceStack[serviceStack.length - 1]);
};




/***/ }),

/***/ "./node_modules/xstate/es/stateUtils.js":
/*!**********************************************!*\
  !*** ./node_modules/xstate/es/stateUtils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getAdjList: () => (/* binding */ getAdjList),
/* harmony export */   getAllChildren: () => (/* binding */ getAllChildren),
/* harmony export */   getAllStateNodes: () => (/* binding */ getAllStateNodes),
/* harmony export */   getChildren: () => (/* binding */ getChildren),
/* harmony export */   getConfiguration: () => (/* binding */ getConfiguration),
/* harmony export */   getMeta: () => (/* binding */ getMeta),
/* harmony export */   getTagsFromConfiguration: () => (/* binding */ getTagsFromConfiguration),
/* harmony export */   getValue: () => (/* binding */ getValue),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   isInFinalState: () => (/* binding */ isInFinalState),
/* harmony export */   isLeafNode: () => (/* binding */ isLeafNode),
/* harmony export */   nextEvents: () => (/* binding */ nextEvents)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/xstate/es/utils.js");



var isLeafNode = function (stateNode) {
  return stateNode.type === 'atomic' || stateNode.type === 'final';
};
function getAllChildren(stateNode) {
  return Object.keys(stateNode.states).map(function (key) {
    return stateNode.states[key];
  });
}
function getChildren(stateNode) {
  return getAllChildren(stateNode).filter(function (sn) {
    return sn.type !== 'history';
  });
}
function getAllStateNodes(stateNode) {
  var stateNodes = [stateNode];

  if (isLeafNode(stateNode)) {
    return stateNodes;
  }

  return stateNodes.concat((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(getChildren(stateNode).map(getAllStateNodes)));
}
function getConfiguration(prevStateNodes, stateNodes) {
  var e_1, _a, e_2, _b, e_3, _c, e_4, _d;

  var prevConfiguration = new Set(prevStateNodes);
  var prevAdjList = getAdjList(prevConfiguration);
  var configuration = new Set(stateNodes);

  try {
    // add all ancestors
    for (var configuration_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(configuration), configuration_1_1 = configuration_1.next(); !configuration_1_1.done; configuration_1_1 = configuration_1.next()) {
      var s = configuration_1_1.value;
      var m = s.parent;

      while (m && !configuration.has(m)) {
        configuration.add(m);
        m = m.parent;
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (configuration_1_1 && !configuration_1_1.done && (_a = configuration_1.return)) _a.call(configuration_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  var adjList = getAdjList(configuration);

  try {
    // add descendants
    for (var configuration_2 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(configuration), configuration_2_1 = configuration_2.next(); !configuration_2_1.done; configuration_2_1 = configuration_2.next()) {
      var s = configuration_2_1.value; // if previously active, add existing child nodes

      if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s).length)) {
        if (prevAdjList.get(s)) {
          prevAdjList.get(s).forEach(function (sn) {
            return configuration.add(sn);
          });
        } else {
          s.initialStateNodes.forEach(function (sn) {
            return configuration.add(sn);
          });
        }
      } else {
        if (s.type === 'parallel') {
          try {
            for (var _e = (e_3 = void 0, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(getChildren(s))), _f = _e.next(); !_f.done; _f = _e.next()) {
              var child = _f.value;

              if (!configuration.has(child)) {
                configuration.add(child);

                if (prevAdjList.get(child)) {
                  prevAdjList.get(child).forEach(function (sn) {
                    return configuration.add(sn);
                  });
                } else {
                  child.initialStateNodes.forEach(function (sn) {
                    return configuration.add(sn);
                  });
                }
              }
            }
          } catch (e_3_1) {
            e_3 = {
              error: e_3_1
            };
          } finally {
            try {
              if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
            } finally {
              if (e_3) throw e_3.error;
            }
          }
        }
      }
    }
  } catch (e_2_1) {
    e_2 = {
      error: e_2_1
    };
  } finally {
    try {
      if (configuration_2_1 && !configuration_2_1.done && (_b = configuration_2.return)) _b.call(configuration_2);
    } finally {
      if (e_2) throw e_2.error;
    }
  }

  try {
    // add all ancestors
    for (var configuration_3 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(configuration), configuration_3_1 = configuration_3.next(); !configuration_3_1.done; configuration_3_1 = configuration_3.next()) {
      var s = configuration_3_1.value;
      var m = s.parent;

      while (m && !configuration.has(m)) {
        configuration.add(m);
        m = m.parent;
      }
    }
  } catch (e_4_1) {
    e_4 = {
      error: e_4_1
    };
  } finally {
    try {
      if (configuration_3_1 && !configuration_3_1.done && (_d = configuration_3.return)) _d.call(configuration_3);
    } finally {
      if (e_4) throw e_4.error;
    }
  }

  return configuration;
}

function getValueFromAdj(baseNode, adjList) {
  var childStateNodes = adjList.get(baseNode);

  if (!childStateNodes) {
    return {}; // todo: fix?
  }

  if (baseNode.type === 'compound') {
    var childStateNode = childStateNodes[0];

    if (childStateNode) {
      if (isLeafNode(childStateNode)) {
        return childStateNode.key;
      }
    } else {
      return {};
    }
  }

  var stateValue = {};
  childStateNodes.forEach(function (csn) {
    stateValue[csn.key] = getValueFromAdj(csn, adjList);
  });
  return stateValue;
}

function getAdjList(configuration) {
  var e_5, _a;

  var adjList = new Map();

  try {
    for (var configuration_4 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(configuration), configuration_4_1 = configuration_4.next(); !configuration_4_1.done; configuration_4_1 = configuration_4.next()) {
      var s = configuration_4_1.value;

      if (!adjList.has(s)) {
        adjList.set(s, []);
      }

      if (s.parent) {
        if (!adjList.has(s.parent)) {
          adjList.set(s.parent, []);
        }

        adjList.get(s.parent).push(s);
      }
    }
  } catch (e_5_1) {
    e_5 = {
      error: e_5_1
    };
  } finally {
    try {
      if (configuration_4_1 && !configuration_4_1.done && (_a = configuration_4.return)) _a.call(configuration_4);
    } finally {
      if (e_5) throw e_5.error;
    }
  }

  return adjList;
}
function getValue(rootNode, configuration) {
  var config = getConfiguration([rootNode], configuration);
  return getValueFromAdj(rootNode, getAdjList(config));
}
function has(iterable, item) {
  if (Array.isArray(iterable)) {
    return iterable.some(function (member) {
      return member === item;
    });
  }

  if (iterable instanceof Set) {
    return iterable.has(item);
  }

  return false; // TODO: fix
}
function nextEvents(configuration) {
  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__read)(new Set((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__read)(configuration.map(function (sn) {
    return sn.ownEvents;
  })), false)))), false);
}
function isInFinalState(configuration, stateNode) {
  if (stateNode.type === 'compound') {
    return getChildren(stateNode).some(function (s) {
      return s.type === 'final' && has(configuration, s);
    });
  }

  if (stateNode.type === 'parallel') {
    return getChildren(stateNode).every(function (sn) {
      return isInFinalState(configuration, sn);
    });
  }

  return false;
}
function getMeta(configuration) {
  if (configuration === void 0) {
    configuration = [];
  }

  return configuration.reduce(function (acc, stateNode) {
    if (stateNode.meta !== undefined) {
      acc[stateNode.id] = stateNode.meta;
    }

    return acc;
  }, {});
}
function getTagsFromConfiguration(configuration) {
  return new Set((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.flatten)(configuration.map(function (sn) {
    return sn.tags;
  })));
}




/***/ }),

/***/ "./node_modules/xstate/es/types.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/types.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActionTypes: () => (/* binding */ ActionTypes),
/* harmony export */   SpecialTargets: () => (/* binding */ SpecialTargets)
/* harmony export */ });
var ActionTypes;

(function (ActionTypes) {
  ActionTypes["Start"] = "xstate.start";
  ActionTypes["Stop"] = "xstate.stop";
  ActionTypes["Raise"] = "xstate.raise";
  ActionTypes["Send"] = "xstate.send";
  ActionTypes["Cancel"] = "xstate.cancel";
  ActionTypes["NullEvent"] = "";
  ActionTypes["Assign"] = "xstate.assign";
  ActionTypes["After"] = "xstate.after";
  ActionTypes["DoneState"] = "done.state";
  ActionTypes["DoneInvoke"] = "done.invoke";
  ActionTypes["Log"] = "xstate.log";
  ActionTypes["Init"] = "xstate.init";
  ActionTypes["Invoke"] = "xstate.invoke";
  ActionTypes["ErrorExecution"] = "error.execution";
  ActionTypes["ErrorCommunication"] = "error.communication";
  ActionTypes["ErrorPlatform"] = "error.platform";
  ActionTypes["ErrorCustom"] = "xstate.error";
  ActionTypes["Update"] = "xstate.update";
  ActionTypes["Pure"] = "xstate.pure";
  ActionTypes["Choose"] = "xstate.choose";
})(ActionTypes || (ActionTypes = {}));

var SpecialTargets;

(function (SpecialTargets) {
  SpecialTargets["Parent"] = "#_parent";
  SpecialTargets["Internal"] = "#_internal";
})(SpecialTargets || (SpecialTargets = {}));




/***/ }),

/***/ "./node_modules/xstate/es/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/xstate/es/utils.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createInvokeId: () => (/* binding */ createInvokeId),
/* harmony export */   evaluateGuard: () => (/* binding */ evaluateGuard),
/* harmony export */   flatten: () => (/* binding */ flatten),
/* harmony export */   getActionType: () => (/* binding */ getActionType),
/* harmony export */   getEventType: () => (/* binding */ getEventType),
/* harmony export */   interopSymbols: () => (/* binding */ interopSymbols),
/* harmony export */   isActor: () => (/* binding */ isActor),
/* harmony export */   isArray: () => (/* binding */ isArray),
/* harmony export */   isBehavior: () => (/* binding */ isBehavior),
/* harmony export */   isBuiltInEvent: () => (/* binding */ isBuiltInEvent),
/* harmony export */   isFunction: () => (/* binding */ isFunction),
/* harmony export */   isMachine: () => (/* binding */ isMachine),
/* harmony export */   isObservable: () => (/* binding */ isObservable),
/* harmony export */   isPromiseLike: () => (/* binding */ isPromiseLike),
/* harmony export */   isRaisableAction: () => (/* binding */ isRaisableAction),
/* harmony export */   isStateLike: () => (/* binding */ isStateLike),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   keys: () => (/* binding */ keys),
/* harmony export */   mapContext: () => (/* binding */ mapContext),
/* harmony export */   mapFilterValues: () => (/* binding */ mapFilterValues),
/* harmony export */   mapValues: () => (/* binding */ mapValues),
/* harmony export */   matchesState: () => (/* binding */ matchesState),
/* harmony export */   nestedPath: () => (/* binding */ nestedPath),
/* harmony export */   normalizeTarget: () => (/* binding */ normalizeTarget),
/* harmony export */   partition: () => (/* binding */ partition),
/* harmony export */   path: () => (/* binding */ path),
/* harmony export */   pathToStateValue: () => (/* binding */ pathToStateValue),
/* harmony export */   pathsToStateValue: () => (/* binding */ pathsToStateValue),
/* harmony export */   reportUnhandledExceptionOnInvocation: () => (/* binding */ reportUnhandledExceptionOnInvocation),
/* harmony export */   symbolObservable: () => (/* binding */ symbolObservable),
/* harmony export */   toArray: () => (/* binding */ toArray),
/* harmony export */   toArrayStrict: () => (/* binding */ toArrayStrict),
/* harmony export */   toEventObject: () => (/* binding */ toEventObject),
/* harmony export */   toGuard: () => (/* binding */ toGuard),
/* harmony export */   toInvokeSource: () => (/* binding */ toInvokeSource),
/* harmony export */   toObserver: () => (/* binding */ toObserver),
/* harmony export */   toSCXMLEvent: () => (/* binding */ toSCXMLEvent),
/* harmony export */   toStatePath: () => (/* binding */ toStatePath),
/* harmony export */   toStatePaths: () => (/* binding */ toStatePaths),
/* harmony export */   toStateValue: () => (/* binding */ toStateValue),
/* harmony export */   toTransitionConfigArray: () => (/* binding */ toTransitionConfigArray),
/* harmony export */   uniqueId: () => (/* binding */ uniqueId),
/* harmony export */   updateContext: () => (/* binding */ updateContext),
/* harmony export */   updateHistoryStates: () => (/* binding */ updateHistoryStates),
/* harmony export */   updateHistoryValue: () => (/* binding */ updateHistoryValue),
/* harmony export */   warn: () => (/* binding */ warn)
/* harmony export */ });
/* harmony import */ var _virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_virtual/_tslib.js */ "./node_modules/xstate/es/_virtual/_tslib.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types.js */ "./node_modules/xstate/es/types.js");
/* harmony import */ var _actionTypes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actionTypes.js */ "./node_modules/xstate/es/actionTypes.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./node_modules/xstate/es/constants.js");
/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./environment.js */ "./node_modules/xstate/es/environment.js");






var _a;
function keys(value) {
  return Object.keys(value);
}
function matchesState(parentStateId, childStateId, delimiter) {
  if (delimiter === void 0) {
    delimiter = _constants_js__WEBPACK_IMPORTED_MODULE_0__.STATE_DELIMITER;
  }

  var parentStateValue = toStateValue(parentStateId, delimiter);
  var childStateValue = toStateValue(childStateId, delimiter);

  if (isString(childStateValue)) {
    if (isString(parentStateValue)) {
      return childStateValue === parentStateValue;
    } // Parent more specific than child


    return false;
  }

  if (isString(parentStateValue)) {
    return parentStateValue in childStateValue;
  }

  return Object.keys(parentStateValue).every(function (key) {
    if (!(key in childStateValue)) {
      return false;
    }

    return matchesState(parentStateValue[key], childStateValue[key]);
  });
}
function getEventType(event) {
  try {
    return isString(event) || typeof event === 'number' ? "".concat(event) : event.type;
  } catch (e) {
    throw new Error('Events must be strings or objects with a string event.type property.');
  }
}
function getActionType(action) {
  try {
    return isString(action) || typeof action === 'number' ? "".concat(action) : isFunction(action) ? action.name : action.type;
  } catch (e) {
    throw new Error('Actions must be strings or objects with a string action.type property.');
  }
}
function toStatePath(stateId, delimiter) {
  try {
    if (isArray(stateId)) {
      return stateId;
    }

    return stateId.toString().split(delimiter);
  } catch (e) {
    throw new Error("'".concat(stateId, "' is not a valid state path."));
  }
}
function isStateLike(state) {
  return typeof state === 'object' && 'value' in state && 'context' in state && 'event' in state && '_event' in state;
}
function toStateValue(stateValue, delimiter) {
  if (isStateLike(stateValue)) {
    return stateValue.value;
  }

  if (isArray(stateValue)) {
    return pathToStateValue(stateValue);
  }

  if (typeof stateValue !== 'string') {
    return stateValue;
  }

  var statePath = toStatePath(stateValue, delimiter);
  return pathToStateValue(statePath);
}
function pathToStateValue(statePath) {
  if (statePath.length === 1) {
    return statePath[0];
  }

  var value = {};
  var marker = value;

  for (var i = 0; i < statePath.length - 1; i++) {
    if (i === statePath.length - 2) {
      marker[statePath[i]] = statePath[i + 1];
    } else {
      marker[statePath[i]] = {};
      marker = marker[statePath[i]];
    }
  }

  return value;
}
function mapValues(collection, iteratee) {
  var result = {};
  var collectionKeys = Object.keys(collection);

  for (var i = 0; i < collectionKeys.length; i++) {
    var key = collectionKeys[i];
    result[key] = iteratee(collection[key], key, collection, i);
  }

  return result;
}
function mapFilterValues(collection, iteratee, predicate) {
  var e_1, _a;

  var result = {};

  try {
    for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(Object.keys(collection)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var key = _c.value;
      var item = collection[key];

      if (!predicate(item)) {
        continue;
      }

      result[key] = iteratee(item, key, collection);
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  return result;
}
/**
 * Retrieves a value at the given path.
 * @param props The deep path to the prop of the desired value
 */

var path = function (props) {
  return function (object) {
    var e_2, _a;

    var result = object;

    try {
      for (var props_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
        var prop = props_1_1.value;
        result = result[prop];
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    return result;
  };
};
/**
 * Retrieves a value at the given path via the nested accessor prop.
 * @param props The deep path to the prop of the desired value
 */

function nestedPath(props, accessorProp) {
  return function (object) {
    var e_3, _a;

    var result = object;

    try {
      for (var props_2 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(props), props_2_1 = props_2.next(); !props_2_1.done; props_2_1 = props_2.next()) {
        var prop = props_2_1.value;
        result = result[accessorProp][prop];
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (props_2_1 && !props_2_1.done && (_a = props_2.return)) _a.call(props_2);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    return result;
  };
}
function toStatePaths(stateValue) {
  if (!stateValue) {
    return [[]];
  }

  if (isString(stateValue)) {
    return [[stateValue]];
  }

  var result = flatten(Object.keys(stateValue).map(function (key) {
    var subStateValue = stateValue[key];

    if (typeof subStateValue !== 'string' && (!subStateValue || !Object.keys(subStateValue).length)) {
      return [[key]];
    }

    return toStatePaths(stateValue[key]).map(function (subPath) {
      return [key].concat(subPath);
    });
  }));
  return result;
}
function pathsToStateValue(paths) {
  var e_4, _a;

  var result = {};

  if (paths && paths.length === 1 && paths[0].length === 1) {
    return paths[0][0];
  }

  try {
    for (var paths_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(paths), paths_1_1 = paths_1.next(); !paths_1_1.done; paths_1_1 = paths_1.next()) {
      var currentPath = paths_1_1.value;
      var marker = result; // tslint:disable-next-line:prefer-for-of

      for (var i = 0; i < currentPath.length; i++) {
        var subPath = currentPath[i];

        if (i === currentPath.length - 2) {
          marker[subPath] = currentPath[i + 1];
          break;
        }

        marker[subPath] = marker[subPath] || {};
        marker = marker[subPath];
      }
    }
  } catch (e_4_1) {
    e_4 = {
      error: e_4_1
    };
  } finally {
    try {
      if (paths_1_1 && !paths_1_1.done && (_a = paths_1.return)) _a.call(paths_1);
    } finally {
      if (e_4) throw e_4.error;
    }
  }

  return result;
}
function flatten(array) {
  var _a;

  return (_a = []).concat.apply(_a, (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__spreadArray)([], (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__read)(array), false));
}
function toArrayStrict(value) {
  if (isArray(value)) {
    return value;
  }

  return [value];
}
function toArray(value) {
  if (value === undefined) {
    return [];
  }

  return toArrayStrict(value);
}
function mapContext(mapper, context, _event) {
  var e_5, _a;

  if (isFunction(mapper)) {
    return mapper(context, _event.data);
  }

  var result = {};

  try {
    for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(Object.keys(mapper)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var key = _c.value;
      var subMapper = mapper[key];

      if (isFunction(subMapper)) {
        result[key] = subMapper(context, _event.data);
      } else {
        result[key] = subMapper;
      }
    }
  } catch (e_5_1) {
    e_5 = {
      error: e_5_1
    };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
    } finally {
      if (e_5) throw e_5.error;
    }
  }

  return result;
}
function isBuiltInEvent(eventType) {
  return /^(done|error)\./.test(eventType);
}
function isPromiseLike(value) {
  if (value instanceof Promise) {
    return true;
  } // Check if shape matches the Promise/A+ specification for a "thenable".


  if (value !== null && (isFunction(value) || typeof value === 'object') && isFunction(value.then)) {
    return true;
  }

  return false;
}
function isBehavior(value) {
  return value !== null && typeof value === 'object' && 'transition' in value && typeof value.transition === 'function';
}
function partition(items, predicate) {
  var e_6, _a;

  var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__read)([[], []], 2),
      truthy = _b[0],
      falsy = _b[1];

  try {
    for (var items_1 = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
      var item = items_1_1.value;

      if (predicate(item)) {
        truthy.push(item);
      } else {
        falsy.push(item);
      }
    }
  } catch (e_6_1) {
    e_6 = {
      error: e_6_1
    };
  } finally {
    try {
      if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
    } finally {
      if (e_6) throw e_6.error;
    }
  }

  return [truthy, falsy];
}
function updateHistoryStates(hist, stateValue) {
  return mapValues(hist.states, function (subHist, key) {
    if (!subHist) {
      return undefined;
    }

    var subStateValue = (isString(stateValue) ? undefined : stateValue[key]) || (subHist ? subHist.current : undefined);

    if (!subStateValue) {
      return undefined;
    }

    return {
      current: subStateValue,
      states: updateHistoryStates(subHist, subStateValue)
    };
  });
}
function updateHistoryValue(hist, stateValue) {
  return {
    current: stateValue,
    states: updateHistoryStates(hist, stateValue)
  };
}
function updateContext(context, _event, assignActions, state) {
  if (!_environment_js__WEBPACK_IMPORTED_MODULE_2__.IS_PRODUCTION) {
    warn(!!context, 'Attempting to update undefined context');
  }

  var updatedContext = context ? assignActions.reduce(function (acc, assignAction) {
    var e_7, _a;

    var assignment = assignAction.assignment;
    var meta = {
      state: state,
      action: assignAction,
      _event: _event
    };
    var partialUpdate = {};

    if (isFunction(assignment)) {
      partialUpdate = assignment(acc, _event.data, meta);
    } else {
      try {
        for (var _b = (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__values)(Object.keys(assignment)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          var propAssignment = assignment[key];
          partialUpdate[key] = isFunction(propAssignment) ? propAssignment(acc, _event.data, meta) : propAssignment;
        }
      } catch (e_7_1) {
        e_7 = {
          error: e_7_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_7) throw e_7.error;
        }
      }
    }

    return Object.assign({}, acc, partialUpdate);
  }, context) : context;
  return updatedContext;
} // tslint:disable-next-line:no-empty

var warn = function () {};

if (!_environment_js__WEBPACK_IMPORTED_MODULE_2__.IS_PRODUCTION) {
  warn = function (condition, message) {
    var error = condition instanceof Error ? condition : undefined;

    if (!error && condition) {
      return;
    }

    if (console !== undefined) {
      var args = ["Warning: ".concat(message)];

      if (error) {
        args.push(error);
      } // tslint:disable-next-line:no-console


      console.warn.apply(console, args);
    }
  };
}
function isArray(value) {
  return Array.isArray(value);
} // tslint:disable-next-line:ban-types

function isFunction(value) {
  return typeof value === 'function';
}
function isString(value) {
  return typeof value === 'string';
}
function toGuard(condition, guardMap) {
  if (!condition) {
    return undefined;
  }

  if (isString(condition)) {
    return {
      type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_GUARD_TYPE,
      name: condition,
      predicate: guardMap ? guardMap[condition] : undefined
    };
  }

  if (isFunction(condition)) {
    return {
      type: _constants_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_GUARD_TYPE,
      name: condition.name,
      predicate: condition
    };
  }

  return condition;
}
function isObservable(value) {
  try {
    return 'subscribe' in value && isFunction(value.subscribe);
  } catch (e) {
    return false;
  }
}
var symbolObservable = /*#__PURE__*/function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
}(); // TODO: to be removed in v5, left it out just to minimize the scope of the change and maintain compatibility with older versions of integration paackages

var interopSymbols = (_a = {}, _a[symbolObservable] = function () {
  return this;
}, _a[Symbol.observable] = function () {
  return this;
}, _a);
function isMachine(value) {
  return !!value && '__xstatenode' in value;
}
function isActor(value) {
  return !!value && typeof value.send === 'function';
}
var uniqueId = /*#__PURE__*/function () {
  var currentId = 0;
  return function () {
    currentId++;
    return currentId.toString(16);
  };
}();
function toEventObject(event, payload // id?: TEvent['type']
) {
  if (isString(event) || typeof event === 'number') {
    return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__assign)({
      type: event
    }, payload);
  }

  return event;
}
function toSCXMLEvent(event, scxmlEvent) {
  if (!isString(event) && '$$type' in event && event.$$type === 'scxml') {
    return event;
  }

  var eventObject = toEventObject(event);
  return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__assign)({
    name: eventObject.type,
    data: eventObject,
    $$type: 'scxml',
    type: 'external'
  }, scxmlEvent);
}
function toTransitionConfigArray(event, configLike) {
  var transitions = toArrayStrict(configLike).map(function (transitionLike) {
    if (typeof transitionLike === 'undefined' || typeof transitionLike === 'string' || isMachine(transitionLike)) {
      return {
        target: transitionLike,
        event: event
      };
    }

    return (0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,_virtual_tslib_js__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, transitionLike), {
      event: event
    });
  });
  return transitions;
}
function normalizeTarget(target) {
  if (target === undefined || target === _constants_js__WEBPACK_IMPORTED_MODULE_0__.TARGETLESS_KEY) {
    return undefined;
  }

  return toArray(target);
}
function reportUnhandledExceptionOnInvocation(originalError, currentError, id) {
  if (!_environment_js__WEBPACK_IMPORTED_MODULE_2__.IS_PRODUCTION) {
    var originalStackTrace = originalError.stack ? " Stacktrace was '".concat(originalError.stack, "'") : '';

    if (originalError === currentError) {
      // tslint:disable-next-line:no-console
      console.error("Missing onError handler for invocation '".concat(id, "', error was '").concat(originalError, "'.").concat(originalStackTrace));
    } else {
      var stackTrace = currentError.stack ? " Stacktrace was '".concat(currentError.stack, "'") : ''; // tslint:disable-next-line:no-console

      console.error("Missing onError handler and/or unhandled exception/promise rejection for invocation '".concat(id, "'. ") + "Original error: '".concat(originalError, "'. ").concat(originalStackTrace, " Current error is '").concat(currentError, "'.").concat(stackTrace));
    }
  }
}
function evaluateGuard(machine, guard, context, _event, state) {
  var guards = machine.options.guards;
  var guardMeta = {
    state: state,
    cond: guard,
    _event: _event
  }; // TODO: do not hardcode!

  if (guard.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_GUARD_TYPE) {
    return ((guards === null || guards === void 0 ? void 0 : guards[guard.name]) || guard.predicate)(context, _event.data, guardMeta);
  }

  var condFn = guards === null || guards === void 0 ? void 0 : guards[guard.type];

  if (!condFn) {
    throw new Error("Guard '".concat(guard.type, "' is not implemented on machine '").concat(machine.id, "'."));
  }

  return condFn(context, _event.data, guardMeta);
}
function toInvokeSource(src) {
  if (typeof src === 'string') {
    return {
      type: src
    };
  }

  return src;
}
function toObserver(nextHandler, errorHandler, completionHandler) {
  var noop = function () {};

  var isObserver = typeof nextHandler === 'object';
  var self = isObserver ? nextHandler : null;
  return {
    next: ((isObserver ? nextHandler.next : nextHandler) || noop).bind(self),
    error: ((isObserver ? nextHandler.error : errorHandler) || noop).bind(self),
    complete: ((isObserver ? nextHandler.complete : completionHandler) || noop).bind(self)
  };
}
function createInvokeId(stateNodeId, index) {
  return "".concat(stateNodeId, ":invocation[").concat(index, "]");
}
function isRaisableAction(action) {
  return (action.type === _actionTypes_js__WEBPACK_IMPORTED_MODULE_3__.raise || action.type === _actionTypes_js__WEBPACK_IMPORTED_MODULE_3__.send && action.to === _types_js__WEBPACK_IMPORTED_MODULE_4__.SpecialTargets.Internal) && typeof action.delay !== 'number';
}




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!****************************!*\
  !*** ./src/AudioModule.js ***!
  \****************************/
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// import state machines for audio input and output
var _require = __webpack_require__(/*! xstate */ "./node_modules/xstate/es/index.js"),
  interpret = _require.interpret;
var _require2 = __webpack_require__(/*! ./state-machines/AudioInputMachine */ "./src/state-machines/AudioInputMachine.js"),
  audioInputMachine = _require2.audioInputMachine;
var _require3 = __webpack_require__(/*! ./state-machines/AudioOutputMachine */ "./src/state-machines/AudioOutputMachine.js"),
  audioOutputMachine = _require3.audioOutputMachine;
var _require4 = __webpack_require__(/*! ./LoggingModule */ "./src/LoggingModule.js"),
  serializeStateValue = _require4.serializeStateValue;

// depends on the injecting script (saypi.index.js) declaring the EventBus as a global variable
var EventBus = window.EventBus;

// audio output (Pi)
var audioElement = document.querySelector("audio");
if (!audioElement) {
  console.error("Audio element not found!");
} else {
  audioElement.preload = "auto"; // enable aggressive preloading of audio
}

var audioOutputActor = interpret(audioOutputMachine).onTransition(function (state) {
  if (state.changed) {
    var fromState = state.history ? serializeStateValue(state.history.value) : "N/A";
    var toState = serializeStateValue(state.value);
    console.log("Audio Output Machine transitioned from ".concat(fromState, " to ").concat(toState, " with ").concat(state.event.type));
    console.log(state.context);
  }
}).start();
function registerAudioPlaybackEvents(audio, actor) {
  var events = ["loadstart", "loadedmetadata", "canplaythrough", "play", "pause", "ended", "seeked", "emptied"];
  events.forEach(function (event) {
    audio.addEventListener(event, function () {
      return actor.send(event);
    });
  });
  audio.addEventListener("playing", function () {
    actor.send("play");
  });
}
registerAudioPlaybackEvents(audioElement, audioOutputActor);

// audio input (user)
var audioInputActor = interpret(audioInputMachine).onTransition(function (state) {
  if (state.changed) {
    var fromState = state.history ? serializeStateValue(state.history.value) : "N/A";
    var toState = serializeStateValue(state.value);
    console.log("Audio Input Machine transitioned from ".concat(fromState, " to ").concat(toState, " with ").concat(state.event.type));
    console.log(state.context);
  }
}).start();

/* These events are used to control/pass requests to the audio module from other modules */
function registerAudioCommands() {
  // audio input (recording) commands
  EventBus.on("audio:setupRecording", function (e) {
    audioInputActor.send("acquire");
  });
  EventBus.on("audio:tearDownRecording", function (e) {
    audioInputActor.send("release");
  });
  EventBus.on("audio:startRecording", function (e) {
    // Check if Pi is currently speaking and stop her audio
    audioOutputActor.send("pause");

    // Check if the MediaRecorder is acquired before starting?
    audioInputActor.send(["acquire", "start"]);
  });
  EventBus.on("audio:stopRecording", function (e) {
    audioInputActor.send("stopRequested");
    /* resume or cancel Pi's audio */
    /* TODO: reassess how to handle interruptions
    audioOutputActor.send("play"); // resume Pi's audio
    audioOutputActor.send("stop"); // cancel Pi's audio
    */
  });
  // audio input (recording) events (pass media recorder events -> audio input machine actor)
  EventBus.on("audio:dataavailable", function (detail) {
    audioInputActor.send(_objectSpread({
      type: "dataAvailable"
    }, detail));
  });
  EventBus.on("audio:input:stop", function (e) {
    audioInputActor.send("stop");
  });

  // audio output (playback) commands
  EventBus.on("audio:reload", function (e) {
    audioOutputActor.send("reload");
  });
}
registerAudioCommands();
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFBRTtJQUMzQzRTLGVBQWUsQ0FBQ25ELElBQUksQ0FBQyxNQUFNLENBQUM7RUFDOUIsQ0FBQyxDQUFDOztFQUVGO0VBQ0F2RixRQUFRLENBQUMwQyxFQUFFLENBQUMsY0FBYyxFQUFFLFVBQVU1TSxDQUFDLEVBQUU7SUFDdkNrUyxnQkFBZ0IsQ0FBQ3pDLElBQUksQ0FBQyxRQUFRLENBQUM7RUFDakMsQ0FBQyxDQUFDO0FBQ0o7QUFDQW9ELHFCQUFxQixDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL0ByaWNreTAxMjMvdmFkLXdlYi9kaXN0L19jb21tb24vZnJhbWUtcHJvY2Vzc29yLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvQHJpY2t5MDEyMy92YWQtd2ViL2Rpc3QvX2NvbW1vbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL0ByaWNreTAxMjMvdmFkLXdlYi9kaXN0L19jb21tb24vbG9nZ2luZy5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL0ByaWNreTAxMjMvdmFkLXdlYi9kaXN0L19jb21tb24vbWVzc2FnZXMuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvZGlzdC9fY29tbW9uL21vZGVscy5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL0ByaWNreTAxMjMvdmFkLXdlYi9kaXN0L19jb21tb24vbm9uLXJlYWwtdGltZS12YWQuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvZGlzdC9fY29tbW9uL3Jlc2FtcGxlci5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL0ByaWNreTAxMjMvdmFkLXdlYi9kaXN0L19jb21tb24vdXRpbHMuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvZGlzdC9hc3NldC1wYXRoLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvQHJpY2t5MDEyMy92YWQtd2ViL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy9Acmlja3kwMTIzL3ZhZC13ZWIvZGlzdC9tb2RlbC1mZXRjaGVyLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvQHJpY2t5MDEyMy92YWQtd2ViL2Rpc3QvcmVhbC10aW1lLXZhZC5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL0ByaWNreTAxMjMvdmFkLXdlYi9kaXN0L3V0aWxzLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9zcmMvQ29uZmlnTW9kdWxlLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9zcmMvTG9nZ2luZ01vZHVsZS5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vc3JjL1JlcXVlc3RJbnRlcmNlcHRvci5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vc3JjL1VzZXJBZ2VudE1vZHVsZS5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vc3JjL3N0YXRlLW1hY2hpbmVzL0F1ZGlvSW5wdXRNYWNoaW5lLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9zcmMvc3RhdGUtbWFjaGluZXMvQXVkaW9PdXRwdXRNYWNoaW5lLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0Lm1pbi5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vc3JjL0F1ZGlvRW5jb2Rlci50cyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vc3JjL1dhdkVuY29kZXIudHMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZXMvQWN0b3IuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZXMvTWFjaGluZS5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy9TdGF0ZS5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy9TdGF0ZU5vZGUuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZXMvX3ZpcnR1YWwvX3RzbGliLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMveHN0YXRlL2VzL2FjdGlvblR5cGVzLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMveHN0YXRlL2VzL2FjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZXMvYmVoYXZpb3JzLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMveHN0YXRlL2VzL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy9kZXZUb29scy5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy9lbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy9pbnRlcnByZXRlci5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy9pbnZva2VVdGlscy5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy9tYXBTdGF0ZS5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy9tYXRjaC5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy9yZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy9zY2hlZHVsZXIuanMiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC8uL25vZGVfbW9kdWxlcy94c3RhdGUvZXMvc2NoZW1hLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMveHN0YXRlL2VzL3NlcnZpY2VTY29wZS5qcyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9lcy9zdGF0ZVV0aWxzLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMveHN0YXRlL2VzL3R5cGVzLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvLi9ub2RlX21vZHVsZXMveHN0YXRlL2VzL3V0aWxzLmpzIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0L3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0L3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vc2F5cGktdXNlcnNjcmlwdC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3NheXBpLXVzZXJzY3JpcHQvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9zYXlwaS11c2Vyc2NyaXB0Ly4vc3JjL0F1ZGlvTW9kdWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcblNvbWUgb2YgdGhpcyBjb2RlLCB0b2dldGhlciB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMgZm91bmQgaW4gaW5kZXgudHMsXG53ZXJlIHRha2VuIChvciB0b29rIGluc3BpcmF0aW9uKSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zbmFrZXJzNC9zaWxlcm8tdmFkXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GcmFtZVByb2Nlc3NvciA9IGV4cG9ydHMudmFsaWRhdGVPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0RnJhbWVQcm9jZXNzb3JPcHRpb25zID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzXCIpO1xuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IFJFQ09NTUVOREVEX0ZSQU1FX1NBTVBMRVMgPSBbNTEyLCAxMDI0LCAxNTM2XTtcbmV4cG9ydHMuZGVmYXVsdEZyYW1lUHJvY2Vzc29yT3B0aW9ucyA9IHtcbiAgICBwb3NpdGl2ZVNwZWVjaFRocmVzaG9sZDogMC41LFxuICAgIG5lZ2F0aXZlU3BlZWNoVGhyZXNob2xkOiAwLjUgLSAwLjE1LFxuICAgIHByZVNwZWVjaFBhZEZyYW1lczogMSxcbiAgICByZWRlbXB0aW9uRnJhbWVzOiA4LFxuICAgIGZyYW1lU2FtcGxlczogMTUzNixcbiAgICBtaW5TcGVlY2hGcmFtZXM6IDMsXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIVJFQ09NTUVOREVEX0ZSQU1FX1NBTVBMRVMuaW5jbHVkZXMob3B0aW9ucy5mcmFtZVNhbXBsZXMpKSB7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2cud2FybihcIllvdSBhcmUgdXNpbmcgYW4gdW51c3VhbCBmcmFtZSBzaXplXCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wb3NpdGl2ZVNwZWVjaFRocmVzaG9sZCA8IDAgfHxcbiAgICAgICAgb3B0aW9ucy5uZWdhdGl2ZVNwZWVjaFRocmVzaG9sZCA+IDEpIHtcbiAgICAgICAgbG9nZ2luZ18xLmxvZy5lcnJvcihcInBvc3RpdmVTcGVlY2hUaHJlc2hvbGQgc2hvdWxkIGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVwiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubmVnYXRpdmVTcGVlY2hUaHJlc2hvbGQgPCAwIHx8XG4gICAgICAgIG9wdGlvbnMubmVnYXRpdmVTcGVlY2hUaHJlc2hvbGQgPiBvcHRpb25zLnBvc2l0aXZlU3BlZWNoVGhyZXNob2xkKSB7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2cuZXJyb3IoXCJuZWdhdGl2ZVNwZWVjaFRocmVzaG9sZCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCBwb3N0aXZlU3BlZWNoVGhyZXNob2xkXCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wcmVTcGVlY2hQYWRGcmFtZXMgPCAwKSB7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2cuZXJyb3IoXCJwcmVTcGVlY2hQYWRGcmFtZXMgc2hvdWxkIGJlIHBvc2l0aXZlXCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZWRlbXB0aW9uRnJhbWVzIDwgMCkge1xuICAgICAgICBsb2dnaW5nXzEubG9nLmVycm9yKFwicHJlU3BlZWNoUGFkRnJhbWVzIHNob3VsZCBiZSBwb3NpdGl2ZVwiKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlT3B0aW9ucyA9IHZhbGlkYXRlT3B0aW9ucztcbmNvbnN0IGNvbmNhdEFycmF5cyA9IChhcnJheXMpID0+IHtcbiAgICBjb25zdCBzaXplcyA9IGFycmF5cy5yZWR1Y2UoKG91dCwgbmV4dCkgPT4ge1xuICAgICAgICBvdXQucHVzaChvdXQuYXQoLTEpICsgbmV4dC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0sIFswXSk7XG4gICAgY29uc3Qgb3V0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHNpemVzLmF0KC0xKSk7XG4gICAgYXJyYXlzLmZvckVhY2goKGFyciwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcGxhY2UgPSBzaXplc1tpbmRleF07XG4gICAgICAgIG91dEFycmF5LnNldChhcnIsIHBsYWNlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0QXJyYXk7XG59O1xuY2xhc3MgRnJhbWVQcm9jZXNzb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsUHJvY2Vzc0Z1bmMsIG1vZGVsUmVzZXRGdW5jLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubW9kZWxQcm9jZXNzRnVuYyA9IG1vZGVsUHJvY2Vzc0Z1bmM7XG4gICAgICAgIHRoaXMubW9kZWxSZXNldEZ1bmMgPSBtb2RlbFJlc2V0RnVuYztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5zcGVha2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlZGVtcHRpb25Db3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXNldCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3BlYWtpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9CdWZmZXIgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubW9kZWxSZXNldEZ1bmMoKTtcbiAgICAgICAgICAgIHRoaXMucmVkZW1wdGlvbkNvdW50ZXIgPSAwO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBhdXNlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXN1bWUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5kU2VnbWVudCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvQnVmZmVyID0gdGhpcy5hdWRpb0J1ZmZlcjtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9CdWZmZXIgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHNwZWFraW5nID0gdGhpcy5zcGVha2luZztcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IHNwZWVjaEZyYW1lQ291bnQgPSBhdWRpb0J1ZmZlci5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyAraXRlbS5pc1NwZWVjaDtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgaWYgKHNwZWFraW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWVjaEZyYW1lQ291bnQgPj0gdGhpcy5vcHRpb25zLm1pblNwZWVjaEZyYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdWRpbyA9IGNvbmNhdEFycmF5cyhhdWRpb0J1ZmZlci5tYXAoKGl0ZW0pID0+IGl0ZW0uZnJhbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbXNnOiBtZXNzYWdlc18xLk1lc3NhZ2UuU3BlZWNoRW5kLCBhdWRpbyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbXNnOiBtZXNzYWdlc18xLk1lc3NhZ2UuVkFETWlzZmlyZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9jZXNzID0gYXN5bmMgKGZyYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvYnMgPSBhd2FpdCB0aGlzLm1vZGVsUHJvY2Vzc0Z1bmMoZnJhbWUpO1xuICAgICAgICAgICAgdGhpcy5hdWRpb0J1ZmZlci5wdXNoKHtcbiAgICAgICAgICAgICAgICBmcmFtZSxcbiAgICAgICAgICAgICAgICBpc1NwZWVjaDogcHJvYnMuaXNTcGVlY2ggPj0gdGhpcy5vcHRpb25zLnBvc2l0aXZlU3BlZWNoVGhyZXNob2xkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocHJvYnMuaXNTcGVlY2ggPj0gdGhpcy5vcHRpb25zLnBvc2l0aXZlU3BlZWNoVGhyZXNob2xkICYmXG4gICAgICAgICAgICAgICAgdGhpcy5yZWRlbXB0aW9uQ291bnRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVkZW1wdGlvbkNvdW50ZXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2JzLmlzU3BlZWNoID49IHRoaXMub3B0aW9ucy5wb3NpdGl2ZVNwZWVjaFRocmVzaG9sZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLnNwZWFraW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVha2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcHJvYnMsIG1zZzogbWVzc2FnZXNfMS5NZXNzYWdlLlNwZWVjaFN0YXJ0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvYnMuaXNTcGVlY2ggPCB0aGlzLm9wdGlvbnMubmVnYXRpdmVTcGVlY2hUaHJlc2hvbGQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWFraW5nICYmXG4gICAgICAgICAgICAgICAgKyt0aGlzLnJlZGVtcHRpb25Db3VudGVyID49IHRoaXMub3B0aW9ucy5yZWRlbXB0aW9uRnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRlbXB0aW9uQ291bnRlciA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVha2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF1ZGlvQnVmZmVyID0gdGhpcy5hdWRpb0J1ZmZlcjtcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvQnVmZmVyID0gW107XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BlZWNoRnJhbWVDb3VudCA9IGF1ZGlvQnVmZmVyLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyAraXRlbS5pc1NwZWVjaDtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoc3BlZWNoRnJhbWVDb3VudCA+PSB0aGlzLm9wdGlvbnMubWluU3BlZWNoRnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF1ZGlvID0gY29uY2F0QXJyYXlzKGF1ZGlvQnVmZmVyLm1hcCgoaXRlbSkgPT4gaXRlbS5mcmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBwcm9icywgbXNnOiBtZXNzYWdlc18xLk1lc3NhZ2UuU3BlZWNoRW5kLCBhdWRpbyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcHJvYnMsIG1zZzogbWVzc2FnZXNfMS5NZXNzYWdlLlZBRE1pc2ZpcmUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3BlYWtpbmcpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5hdWRpb0J1ZmZlci5sZW5ndGggPiB0aGlzLm9wdGlvbnMucHJlU3BlZWNoUGFkRnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9CdWZmZXIuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBwcm9icyB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmF1ZGlvQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG59XG5leHBvcnRzLkZyYW1lUHJvY2Vzc29yID0gRnJhbWVQcm9jZXNzb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcmFtZS1wcm9jZXNzb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnV0aWxzID0gdm9pZCAwO1xuY29uc3QgX3V0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmV4cG9ydHMudXRpbHMgPSB7XG4gICAgbWluRnJhbWVzRm9yVGFyZ2V0TVM6IF91dGlscy5taW5GcmFtZXNGb3JUYXJnZXRNUyxcbiAgICBhcnJheUJ1ZmZlclRvQmFzZTY0OiBfdXRpbHMuYXJyYXlCdWZmZXJUb0Jhc2U2NCxcbiAgICBlbmNvZGVXQVY6IF91dGlscy5lbmNvZGVXQVYsXG59O1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL25vbi1yZWFsLXRpbWUtdmFkXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mcmFtZS1wcm9jZXNzb3JcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21lc3NhZ2VzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9sb2dnaW5nXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb2RlbHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Jlc2FtcGxlclwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9nID0gZXhwb3J0cy5MT0dfUFJFRklYID0gdm9pZCAwO1xuZXhwb3J0cy5MT0dfUFJFRklYID0gXCJbVkFEXVwiO1xuY29uc3QgbGV2ZWxzID0gW1wiZXJyb3JcIiwgXCJkZWJ1Z1wiLCBcIndhcm5cIl07XG5mdW5jdGlvbiBnZXRMb2cobGV2ZWwpIHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc29sZVtsZXZlbF0oZXhwb3J0cy5MT0dfUFJFRklYLCAuLi5hcmdzKTtcbiAgICB9O1xufVxuY29uc3QgX2xvZyA9IGxldmVscy5yZWR1Y2UoKGFjYywgbGV2ZWwpID0+IHtcbiAgICBhY2NbbGV2ZWxdID0gZ2V0TG9nKGxldmVsKTtcbiAgICByZXR1cm4gYWNjO1xufSwge30pO1xuZXhwb3J0cy5sb2cgPSBfbG9nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVzc2FnZSA9IHZvaWQgMDtcbnZhciBNZXNzYWdlO1xuKGZ1bmN0aW9uIChNZXNzYWdlKSB7XG4gICAgTWVzc2FnZVtcIkF1ZGlvRnJhbWVcIl0gPSBcIkFVRElPX0ZSQU1FXCI7XG4gICAgTWVzc2FnZVtcIlNwZWVjaFN0YXJ0XCJdID0gXCJTUEVFQ0hfU1RBUlRcIjtcbiAgICBNZXNzYWdlW1wiVkFETWlzZmlyZVwiXSA9IFwiVkFEX01JU0ZJUkVcIjtcbiAgICBNZXNzYWdlW1wiU3BlZWNoRW5kXCJdID0gXCJTUEVFQ0hfRU5EXCI7XG59KShNZXNzYWdlID0gZXhwb3J0cy5NZXNzYWdlIHx8IChleHBvcnRzLk1lc3NhZ2UgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpbGVybyA9IHZvaWQgMDtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jbGFzcyBTaWxlcm8ge1xuICAgIGNvbnN0cnVjdG9yKG9ydCwgbW9kZWxGZXRjaGVyKSB7XG4gICAgICAgIHRoaXMub3J0ID0gb3J0O1xuICAgICAgICB0aGlzLm1vZGVsRmV0Y2hlciA9IG1vZGVsRmV0Y2hlcjtcbiAgICAgICAgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZy5kZWJ1ZyhcImluaXRpYWxpemluZyB2YWRcIik7XG4gICAgICAgICAgICBjb25zdCBtb2RlbEFycmF5QnVmZmVyID0gYXdhaXQgdGhpcy5tb2RlbEZldGNoZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3Nlc3Npb24gPSBhd2FpdCB0aGlzLm9ydC5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZShtb2RlbEFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3NyID0gbmV3IHRoaXMub3J0LlRlbnNvcihcImludDY0XCIsIFsxNjAwMG5dKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRfc3RhdGUoKTtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2cuZGVidWcoXCJ2YWQgaXMgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVzZXRfc3RhdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB6ZXJvZXMgPSBBcnJheSgyICogNjQpLmZpbGwoMCk7XG4gICAgICAgICAgICB0aGlzLl9oID0gbmV3IHRoaXMub3J0LlRlbnNvcihcImZsb2F0MzJcIiwgemVyb2VzLCBbMiwgMSwgNjRdKTtcbiAgICAgICAgICAgIHRoaXMuX2MgPSBuZXcgdGhpcy5vcnQuVGVuc29yKFwiZmxvYXQzMlwiLCB6ZXJvZXMsIFsyLCAxLCA2NF0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb2Nlc3MgPSBhc3luYyAoYXVkaW9GcmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdCA9IG5ldyB0aGlzLm9ydC5UZW5zb3IoXCJmbG9hdDMyXCIsIGF1ZGlvRnJhbWUsIFsxLCBhdWRpb0ZyYW1lLmxlbmd0aF0pO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRzID0ge1xuICAgICAgICAgICAgICAgIGlucHV0OiB0LFxuICAgICAgICAgICAgICAgIGg6IHRoaXMuX2gsXG4gICAgICAgICAgICAgICAgYzogdGhpcy5fYyxcbiAgICAgICAgICAgICAgICBzcjogdGhpcy5fc3IsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0gYXdhaXQgdGhpcy5fc2Vzc2lvbi5ydW4oaW5wdXRzKTtcbiAgICAgICAgICAgIHRoaXMuX2ggPSBvdXQuaG47XG4gICAgICAgICAgICB0aGlzLl9jID0gb3V0LmNuO1xuICAgICAgICAgICAgY29uc3QgW2lzU3BlZWNoXSA9IG91dC5vdXRwdXQuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IG5vdFNwZWVjaCA9IDEgLSBpc1NwZWVjaDtcbiAgICAgICAgICAgIHJldHVybiB7IG5vdFNwZWVjaCwgaXNTcGVlY2ggfTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlNpbGVybyA9IFNpbGVybztcbl9hID0gU2lsZXJvO1xuU2lsZXJvLm5ldyA9IGFzeW5jIChvcnQsIG1vZGVsRmV0Y2hlcikgPT4ge1xuICAgIGNvbnN0IG1vZGVsID0gbmV3IFNpbGVybyhvcnQsIG1vZGVsRmV0Y2hlcik7XG4gICAgYXdhaXQgbW9kZWwuaW5pdCgpO1xuICAgIHJldHVybiBtb2RlbDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBsYXRmb3JtQWdub3N0aWNOb25SZWFsVGltZVZBRCA9IGV4cG9ydHMuZGVmYXVsdE5vblJlYWxUaW1lVkFET3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IGZyYW1lX3Byb2Nlc3Nvcl8xID0gcmVxdWlyZShcIi4vZnJhbWUtcHJvY2Vzc29yXCIpO1xuY29uc3QgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VzXCIpO1xuY29uc3QgbW9kZWxzXzEgPSByZXF1aXJlKFwiLi9tb2RlbHNcIik7XG5jb25zdCByZXNhbXBsZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc2FtcGxlclwiKTtcbmV4cG9ydHMuZGVmYXVsdE5vblJlYWxUaW1lVkFET3B0aW9ucyA9IHtcbiAgICAuLi5mcmFtZV9wcm9jZXNzb3JfMS5kZWZhdWx0RnJhbWVQcm9jZXNzb3JPcHRpb25zLFxufTtcbmNsYXNzIFBsYXRmb3JtQWdub3N0aWNOb25SZWFsVGltZVZBRCB7XG4gICAgc3RhdGljIGFzeW5jIF9uZXcobW9kZWxGZXRjaGVyLCBvcnQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB2YWQgPSBuZXcgdGhpcyhtb2RlbEZldGNoZXIsIG9ydCwge1xuICAgICAgICAgICAgLi4uZXhwb3J0cy5kZWZhdWx0Tm9uUmVhbFRpbWVWQURPcHRpb25zLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHZhZC5pbml0KCk7XG4gICAgICAgIHJldHVybiB2YWQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1vZGVsRmV0Y2hlciwgb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubW9kZWxGZXRjaGVyID0gbW9kZWxGZXRjaGVyO1xuICAgICAgICB0aGlzLm9ydCA9IG9ydDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBhd2FpdCBtb2RlbHNfMS5TaWxlcm8ubmV3KHRoaXMub3J0LCB0aGlzLm1vZGVsRmV0Y2hlcik7XG4gICAgICAgICAgICB0aGlzLmZyYW1lUHJvY2Vzc29yID0gbmV3IGZyYW1lX3Byb2Nlc3Nvcl8xLkZyYW1lUHJvY2Vzc29yKG1vZGVsLnByb2Nlc3MsIG1vZGVsLnJlc2V0X3N0YXRlLCB7XG4gICAgICAgICAgICAgICAgZnJhbWVTYW1wbGVzOiB0aGlzLm9wdGlvbnMuZnJhbWVTYW1wbGVzLFxuICAgICAgICAgICAgICAgIHBvc2l0aXZlU3BlZWNoVGhyZXNob2xkOiB0aGlzLm9wdGlvbnMucG9zaXRpdmVTcGVlY2hUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgbmVnYXRpdmVTcGVlY2hUaHJlc2hvbGQ6IHRoaXMub3B0aW9ucy5uZWdhdGl2ZVNwZWVjaFRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICByZWRlbXB0aW9uRnJhbWVzOiB0aGlzLm9wdGlvbnMucmVkZW1wdGlvbkZyYW1lcyxcbiAgICAgICAgICAgICAgICBwcmVTcGVlY2hQYWRGcmFtZXM6IHRoaXMub3B0aW9ucy5wcmVTcGVlY2hQYWRGcmFtZXMsXG4gICAgICAgICAgICAgICAgbWluU3BlZWNoRnJhbWVzOiB0aGlzLm9wdGlvbnMubWluU3BlZWNoRnJhbWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmZyYW1lUHJvY2Vzc29yLnJlc3VtZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1biA9IGFzeW5jIGZ1bmN0aW9uKiAoaW5wdXRBdWRpbywgc2FtcGxlUmF0ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzYW1wbGVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBuYXRpdmVTYW1wbGVSYXRlOiBzYW1wbGVSYXRlLFxuICAgICAgICAgICAgICAgIHRhcmdldFNhbXBsZVJhdGU6IDE2MDAwLFxuICAgICAgICAgICAgICAgIHRhcmdldEZyYW1lU2l6ZTogdGhpcy5vcHRpb25zLmZyYW1lU2FtcGxlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXNhbXBsZXIgPSBuZXcgcmVzYW1wbGVyXzEuUmVzYW1wbGVyKHJlc2FtcGxlck9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgZnJhbWVzID0gcmVzYW1wbGVyLnByb2Nlc3MoaW5wdXRBdWRpbyk7XG4gICAgICAgICAgICBsZXQgc3RhcnQsIGVuZDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBbLi4uQXJyYXkoZnJhbWVzLmxlbmd0aCldLmtleXMoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGYgPSBmcmFtZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgeyBtc2csIGF1ZGlvIH0gPSBhd2FpdCB0aGlzLmZyYW1lUHJvY2Vzc29yLnByb2Nlc3MoZik7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChtc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLk1lc3NhZ2UuU3BlZWNoU3RhcnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IChpICogdGhpcy5vcHRpb25zLmZyYW1lU2FtcGxlcykgLyAxNjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuTWVzc2FnZS5TcGVlY2hFbmQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSAoKGkgKyAxKSAqIHRoaXMub3B0aW9ucy5mcmFtZVNhbXBsZXMpIC8gMTY7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB7IGF1ZGlvLCBzdGFydCwgZW5kIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgbXNnLCBhdWRpbyB9ID0gdGhpcy5mcmFtZVByb2Nlc3Nvci5lbmRTZWdtZW50KCk7XG4gICAgICAgICAgICBpZiAobXNnID09IG1lc3NhZ2VzXzEuTWVzc2FnZS5TcGVlY2hFbmQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvLFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IChmcmFtZXMubGVuZ3RoICogdGhpcy5vcHRpb25zLmZyYW1lU2FtcGxlcykgLyAxNixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAoMCwgZnJhbWVfcHJvY2Vzc29yXzEudmFsaWRhdGVPcHRpb25zKShvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLlBsYXRmb3JtQWdub3N0aWNOb25SZWFsVGltZVZBRCA9IFBsYXRmb3JtQWdub3N0aWNOb25SZWFsVGltZVZBRDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vbi1yZWFsLXRpbWUtdmFkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXNhbXBsZXIgPSB2b2lkIDA7XG5jb25zdCBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY2xhc3MgUmVzYW1wbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucHJvY2VzcyA9IChhdWRpb0ZyYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRGcmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2FtcGxlIG9mIGF1ZGlvRnJhbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0QnVmZmVyLnB1c2goc2FtcGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICgodGhpcy5pbnB1dEJ1ZmZlci5sZW5ndGggKiB0aGlzLm9wdGlvbnMudGFyZ2V0U2FtcGxlUmF0ZSkgL1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5uYXRpdmVTYW1wbGVSYXRlID5cbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGFyZ2V0RnJhbWVTaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0RnJhbWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMub3B0aW9ucy50YXJnZXRGcmFtZVNpemUpO1xuICAgICAgICAgICAgICAgIGxldCBvdXRwdXRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGlucHV0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChvdXRwdXRJbmRleCA8IHRoaXMub3B0aW9ucy50YXJnZXRGcmFtZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBudW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5wdXRJbmRleCA8XG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbih0aGlzLmlucHV0QnVmZmVyLmxlbmd0aCwgKChvdXRwdXRJbmRleCArIDEpICogdGhpcy5vcHRpb25zLm5hdGl2ZVNhbXBsZVJhdGUpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGFyZ2V0U2FtcGxlUmF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSB0aGlzLmlucHV0QnVmZmVyW2lucHV0SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0RnJhbWVbb3V0cHV0SW5kZXhdID0gc3VtIC8gbnVtO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0QnVmZmVyID0gdGhpcy5pbnB1dEJ1ZmZlci5zbGljZShpbnB1dEluZGV4KTtcbiAgICAgICAgICAgICAgICBvdXRwdXRGcmFtZXMucHVzaChvdXRwdXRGcmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0RnJhbWVzO1xuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5uYXRpdmVTYW1wbGVSYXRlIDwgMTYwMDApIHtcbiAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2cuZXJyb3IoXCJuYXRpdmVTYW1wbGVSYXRlIGlzIHRvbyBsb3cuIFNob3VsZCBoYXZlIDE2MDAwID0gdGFyZ2V0U2FtcGxlUmF0ZSA8PSBuYXRpdmVTYW1wbGVSYXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXRCdWZmZXIgPSBbXTtcbiAgICB9XG59XG5leHBvcnRzLlJlc2FtcGxlciA9IFJlc2FtcGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc2FtcGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW5jb2RlV0FWID0gZXhwb3J0cy5hcnJheUJ1ZmZlclRvQmFzZTY0ID0gZXhwb3J0cy5taW5GcmFtZXNGb3JUYXJnZXRNUyA9IHZvaWQgMDtcbmZ1bmN0aW9uIG1pbkZyYW1lc0ZvclRhcmdldE1TKHRhcmdldER1cmF0aW9uLCBmcmFtZVNhbXBsZXMsIHNyID0gMTYwMDApIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKCh0YXJnZXREdXJhdGlvbiAqIHNyKSAvIDEwMDAgLyBmcmFtZVNhbXBsZXMpO1xufVxuZXhwb3J0cy5taW5GcmFtZXNGb3JUYXJnZXRNUyA9IG1pbkZyYW1lc0ZvclRhcmdldE1TO1xuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NChidWZmZXIpIHtcbiAgICB2YXIgYmluYXJ5ID0gXCJcIjtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIHZhciBsZW4gPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYShiaW5hcnkpO1xufVxuZXhwb3J0cy5hcnJheUJ1ZmZlclRvQmFzZTY0ID0gYXJyYXlCdWZmZXJUb0Jhc2U2NDtcbi8qXG5UaGlzIHJlc3Qgb2YgdGhpcyB3YXMgbW9zdGx5IGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9saW50by1haS9XZWJWb2ljZVNES1xuKi9cbmZ1bmN0aW9uIGVuY29kZVdBVihzYW1wbGVzLCBmb3JtYXQgPSAzLCBzYW1wbGVSYXRlID0gMTYwMDAsIG51bUNoYW5uZWxzID0gMSwgYml0RGVwdGggPSAzMikge1xuICAgIHZhciBieXRlc1BlclNhbXBsZSA9IGJpdERlcHRoIC8gODtcbiAgICB2YXIgYmxvY2tBbGlnbiA9IG51bUNoYW5uZWxzICogYnl0ZXNQZXJTYW1wbGU7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig0NCArIHNhbXBsZXMubGVuZ3RoICogYnl0ZXNQZXJTYW1wbGUpO1xuICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgLyogUklGRiBpZGVudGlmaWVyICovXG4gICAgd3JpdGVTdHJpbmcodmlldywgMCwgXCJSSUZGXCIpO1xuICAgIC8qIFJJRkYgY2h1bmsgbGVuZ3RoICovXG4gICAgdmlldy5zZXRVaW50MzIoNCwgMzYgKyBzYW1wbGVzLmxlbmd0aCAqIGJ5dGVzUGVyU2FtcGxlLCB0cnVlKTtcbiAgICAvKiBSSUZGIHR5cGUgKi9cbiAgICB3cml0ZVN0cmluZyh2aWV3LCA4LCBcIldBVkVcIik7XG4gICAgLyogZm9ybWF0IGNodW5rIGlkZW50aWZpZXIgKi9cbiAgICB3cml0ZVN0cmluZyh2aWV3LCAxMiwgXCJmbXQgXCIpO1xuICAgIC8qIGZvcm1hdCBjaHVuayBsZW5ndGggKi9cbiAgICB2aWV3LnNldFVpbnQzMigxNiwgMTYsIHRydWUpO1xuICAgIC8qIHNhbXBsZSBmb3JtYXQgKHJhdykgKi9cbiAgICB2aWV3LnNldFVpbnQxNigyMCwgZm9ybWF0LCB0cnVlKTtcbiAgICAvKiBjaGFubmVsIGNvdW50ICovXG4gICAgdmlldy5zZXRVaW50MTYoMjIsIG51bUNoYW5uZWxzLCB0cnVlKTtcbiAgICAvKiBzYW1wbGUgcmF0ZSAqL1xuICAgIHZpZXcuc2V0VWludDMyKDI0LCBzYW1wbGVSYXRlLCB0cnVlKTtcbiAgICAvKiBieXRlIHJhdGUgKHNhbXBsZSByYXRlICogYmxvY2sgYWxpZ24pICovXG4gICAgdmlldy5zZXRVaW50MzIoMjgsIHNhbXBsZVJhdGUgKiBibG9ja0FsaWduLCB0cnVlKTtcbiAgICAvKiBibG9jayBhbGlnbiAoY2hhbm5lbCBjb3VudCAqIGJ5dGVzIHBlciBzYW1wbGUpICovXG4gICAgdmlldy5zZXRVaW50MTYoMzIsIGJsb2NrQWxpZ24sIHRydWUpO1xuICAgIC8qIGJpdHMgcGVyIHNhbXBsZSAqL1xuICAgIHZpZXcuc2V0VWludDE2KDM0LCBiaXREZXB0aCwgdHJ1ZSk7XG4gICAgLyogZGF0YSBjaHVuayBpZGVudGlmaWVyICovXG4gICAgd3JpdGVTdHJpbmcodmlldywgMzYsIFwiZGF0YVwiKTtcbiAgICAvKiBkYXRhIGNodW5rIGxlbmd0aCAqL1xuICAgIHZpZXcuc2V0VWludDMyKDQwLCBzYW1wbGVzLmxlbmd0aCAqIGJ5dGVzUGVyU2FtcGxlLCB0cnVlKTtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIC8vIFJhdyBQQ01cbiAgICAgICAgZmxvYXRUbzE2Qml0UENNKHZpZXcsIDQ0LCBzYW1wbGVzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvYXQzMih2aWV3LCA0NCwgc2FtcGxlcyk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLmVuY29kZVdBViA9IGVuY29kZVdBVjtcbmZ1bmN0aW9uIGludGVybGVhdmUoaW5wdXRMLCBpbnB1dFIpIHtcbiAgICB2YXIgbGVuZ3RoID0gaW5wdXRMLmxlbmd0aCArIGlucHV0Ui5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkobGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpbnB1dEluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4KytdID0gaW5wdXRMW2lucHV0SW5kZXhdO1xuICAgICAgICByZXN1bHRbaW5kZXgrK10gPSBpbnB1dFJbaW5wdXRJbmRleF07XG4gICAgICAgIGlucHV0SW5kZXgrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHdyaXRlRmxvYXQzMihvdXRwdXQsIG9mZnNldCwgaW5wdXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICBvdXRwdXQuc2V0RmxvYXQzMihvZmZzZXQsIGlucHV0W2ldLCB0cnVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmbG9hdFRvMTZCaXRQQ00ob3V0cHV0LCBvZmZzZXQsIGlucHV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKywgb2Zmc2V0ICs9IDIpIHtcbiAgICAgICAgdmFyIHMgPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgaW5wdXRbaV0pKTtcbiAgICAgICAgb3V0cHV0LnNldEludDE2KG9mZnNldCwgcyA8IDAgPyBzICogMHg4MDAwIDogcyAqIDB4N2ZmZiwgdHJ1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JpdGVTdHJpbmcodmlldywgb2Zmc2V0LCBzdHJpbmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIGksIHN0cmluZy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzZXRQYXRoID0gdm9pZCAwO1xuY29uc3QgY3VycmVudFNjcmlwdCA9IHdpbmRvdy5kb2N1bWVudC5jdXJyZW50U2NyaXB0O1xubGV0IGJhc2VQYXRoID0gXCJcIjtcbmlmIChjdXJyZW50U2NyaXB0KSB7XG4gICAgYmFzZVBhdGggPSBjdXJyZW50U2NyaXB0LnNyY1xuICAgICAgICAucmVwbGFjZSgvIy4qJC8sIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKVxuICAgICAgICAucmVwbGFjZSgvXFwvW15cXC9dKyQvLCBcIi9cIik7XG59XG5jb25zdCBhc3NldFBhdGggPSAoZmlsZSkgPT4ge1xuICAgIHJldHVybiBiYXNlUGF0aCArIGZpbGU7XG59O1xuZXhwb3J0cy5hc3NldFBhdGggPSBhc3NldFBhdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NldC1wYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHRSZWFsVGltZVZBRE9wdGlvbnMgPSBleHBvcnRzLkF1ZGlvTm9kZVZBRCA9IGV4cG9ydHMuTWljVkFEID0gZXhwb3J0cy5Ob25SZWFsVGltZVZBRCA9IGV4cG9ydHMuTWVzc2FnZSA9IGV4cG9ydHMuRnJhbWVQcm9jZXNzb3IgPSBleHBvcnRzLnV0aWxzID0gdm9pZCAwO1xuY29uc3Qgb3J0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJvbm54cnVudGltZS13ZWJcIikpO1xuY29uc3QgX2NvbW1vbl8xID0gcmVxdWlyZShcIi4vX2NvbW1vblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZyYW1lUHJvY2Vzc29yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfY29tbW9uXzEuRnJhbWVQcm9jZXNzb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfY29tbW9uXzEuTWVzc2FnZTsgfSB9KTtcbmNvbnN0IG1vZGVsX2ZldGNoZXJfMSA9IHJlcXVpcmUoXCIuL21vZGVsLWZldGNoZXJcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jbGFzcyBOb25SZWFsVGltZVZBRCBleHRlbmRzIF9jb21tb25fMS5QbGF0Zm9ybUFnbm9zdGljTm9uUmVhbFRpbWVWQUQge1xuICAgIHN0YXRpYyBhc3luYyBuZXcob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9uZXcobW9kZWxfZmV0Y2hlcl8xLm1vZGVsRmV0Y2hlciwgb3J0LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLk5vblJlYWxUaW1lVkFEID0gTm9uUmVhbFRpbWVWQUQ7XG5leHBvcnRzLnV0aWxzID0geyBhdWRpb0ZpbGVUb0FycmF5OiB1dGlsc18xLmF1ZGlvRmlsZVRvQXJyYXksIC4uLl9jb21tb25fMS51dGlscyB9O1xudmFyIHJlYWxfdGltZV92YWRfMSA9IHJlcXVpcmUoXCIuL3JlYWwtdGltZS12YWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaWNWQURcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWxfdGltZV92YWRfMS5NaWNWQUQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBdWRpb05vZGVWQURcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWxfdGltZV92YWRfMS5BdWRpb05vZGVWQUQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0UmVhbFRpbWVWQURPcHRpb25zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFsX3RpbWVfdmFkXzEuZGVmYXVsdFJlYWxUaW1lVkFET3B0aW9uczsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tb2RlbEZldGNoZXIgPSB2b2lkIDA7XG5jb25zdCBhc3NldF9wYXRoXzEgPSByZXF1aXJlKFwiLi9hc3NldC1wYXRoXCIpO1xuY29uc3QgbW9kZWxGZXRjaGVyID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1vZGVsVVJMID0gKDAsIGFzc2V0X3BhdGhfMS5hc3NldFBhdGgpKFwic2lsZXJvX3ZhZC5vbm54XCIpO1xuICAgIHJldHVybiBhd2FpdCBmZXRjaChtb2RlbFVSTCkudGhlbigocikgPT4gci5hcnJheUJ1ZmZlcigpKTtcbn07XG5leHBvcnRzLm1vZGVsRmV0Y2hlciA9IG1vZGVsRmV0Y2hlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVsLWZldGNoZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXVkaW9Ob2RlVkFEID0gZXhwb3J0cy5NaWNWQUQgPSBleHBvcnRzLmRlZmF1bHRSZWFsVGltZVZBRE9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBvcnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIm9ubnhydW50aW1lLXdlYlwiKSk7XG5jb25zdCBfY29tbW9uXzEgPSByZXF1aXJlKFwiLi9fY29tbW9uXCIpO1xuY29uc3QgbW9kZWxfZmV0Y2hlcl8xID0gcmVxdWlyZShcIi4vbW9kZWwtZmV0Y2hlclwiKTtcbmNvbnN0IGFzc2V0X3BhdGhfMSA9IHJlcXVpcmUoXCIuL2Fzc2V0LXBhdGhcIik7XG5jb25zdCBfZ2V0V29ya2xldFVSTCA9ICgpID0+IHtcbiAgICByZXR1cm4gKDAsIGFzc2V0X3BhdGhfMS5hc3NldFBhdGgpKFwidmFkLndvcmtsZXQuYnVuZGxlLm1pbi5qc1wiKTtcbn07XG5leHBvcnRzLmRlZmF1bHRSZWFsVGltZVZBRE9wdGlvbnMgPSB7XG4gICAgLi4uX2NvbW1vbl8xLmRlZmF1bHRGcmFtZVByb2Nlc3Nvck9wdGlvbnMsXG4gICAgb25GcmFtZVByb2Nlc3NlZDogKHByb2JhYmlsaXRpZXMpID0+IHsgfSxcbiAgICBvblZBRE1pc2ZpcmU6ICgpID0+IHtcbiAgICAgICAgX2NvbW1vbl8xLmxvZy5kZWJ1ZyhcIlZBRCBtaXNmaXJlXCIpO1xuICAgIH0sXG4gICAgb25TcGVlY2hTdGFydDogKCkgPT4ge1xuICAgICAgICBfY29tbW9uXzEubG9nLmRlYnVnKFwiRGV0ZWN0ZWQgc3BlZWNoIHN0YXJ0XCIpO1xuICAgIH0sXG4gICAgb25TcGVlY2hFbmQ6ICgpID0+IHtcbiAgICAgICAgX2NvbW1vbl8xLmxvZy5kZWJ1ZyhcIkRldGVjdGVkIHNwZWVjaCBlbmRcIik7XG4gICAgfSxcbiAgICB3b3JrbGV0VVJMOiBfZ2V0V29ya2xldFVSTCgpLFxuICAgIHN0cmVhbTogdW5kZWZpbmVkLFxufTtcbmNsYXNzIE1pY1ZBRCB7XG4gICAgc3RhdGljIGFzeW5jIG5ldyhvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgdmFkID0gbmV3IE1pY1ZBRCh7IC4uLmV4cG9ydHMuZGVmYXVsdFJlYWxUaW1lVkFET3B0aW9ucywgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgYXdhaXQgdmFkLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHZhZDtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmxpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0cmVhbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xuICAgICAgICAgICAgICAgICAgICBhdWRpbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLmFkZGl0aW9uYWxBdWRpb0NvbnN0cmFpbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWNob0NhbmNlbGxhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9HYWluQ29udHJvbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vaXNlU3VwcHJlc3Npb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSB0aGlzLm9wdGlvbnMuc3RyZWFtO1xuICAgICAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBuZXcgTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGUodGhpcy5hdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICAgICAgICBtZWRpYVN0cmVhbTogdGhpcy5zdHJlYW0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9Ob2RlVkFEID0gYXdhaXQgQXVkaW9Ob2RlVkFELm5ldyh0aGlzLmF1ZGlvQ29udGV4dCwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9Ob2RlVkFELnJlY2VpdmUoc291cmNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wYXVzZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXVkaW9Ob2RlVkFELnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmluZyA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hdWRpb05vZGVWQUQuc3RhcnQoKTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgKDAsIF9jb21tb25fMS52YWxpZGF0ZU9wdGlvbnMpKG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWljVkFEID0gTWljVkFEO1xuY2xhc3MgQXVkaW9Ob2RlVkFEIHtcbiAgICBzdGF0aWMgYXN5bmMgbmV3KGN0eCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHZhZCA9IG5ldyBBdWRpb05vZGVWQUQoY3R4LCB7XG4gICAgICAgICAgICAuLi5leHBvcnRzLmRlZmF1bHRSZWFsVGltZVZBRE9wdGlvbnMsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdmFkLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHZhZDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY3R4LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnBhdXNlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5mcmFtZVByb2Nlc3Nvci5wYXVzZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5mcmFtZVByb2Nlc3Nvci5yZXN1bWUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWNlaXZlID0gKG5vZGUpID0+IHtcbiAgICAgICAgICAgIG5vZGUuY29ubmVjdCh0aGlzLmVudHJ5Tm9kZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvY2Vzc0ZyYW1lID0gYXN5bmMgKGZyYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHByb2JzLCBtc2csIGF1ZGlvIH0gPSBhd2FpdCB0aGlzLmZyYW1lUHJvY2Vzc29yLnByb2Nlc3MoZnJhbWUpO1xuICAgICAgICAgICAgaWYgKHByb2JzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25GcmFtZVByb2Nlc3NlZChwcm9icyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKG1zZykge1xuICAgICAgICAgICAgICAgIGNhc2UgX2NvbW1vbl8xLk1lc3NhZ2UuU3BlZWNoU3RhcnQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vblNwZWVjaFN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgX2NvbW1vbl8xLk1lc3NhZ2UuVkFETWlzZmlyZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uVkFETWlzZmlyZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIF9jb21tb25fMS5NZXNzYWdlLlNwZWVjaEVuZDpcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25TcGVlY2hFbmQoYXVkaW8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jdHguYXVkaW9Xb3JrbGV0LmFkZE1vZHVsZSh0aGlzLm9wdGlvbnMud29ya2xldFVSTCk7XG4gICAgICAgICAgICBjb25zdCB2YWROb2RlID0gbmV3IEF1ZGlvV29ya2xldE5vZGUodGhpcy5jdHgsIFwidmFkLWhlbHBlci13b3JrbGV0XCIsIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzb3JPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lU2FtcGxlczogdGhpcy5vcHRpb25zLmZyYW1lU2FtcGxlcyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVudHJ5Tm9kZSA9IHZhZE5vZGU7XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IGF3YWl0IF9jb21tb25fMS5TaWxlcm8ubmV3KG9ydCwgbW9kZWxfZmV0Y2hlcl8xLm1vZGVsRmV0Y2hlcik7XG4gICAgICAgICAgICB0aGlzLmZyYW1lUHJvY2Vzc29yID0gbmV3IF9jb21tb25fMS5GcmFtZVByb2Nlc3Nvcihtb2RlbC5wcm9jZXNzLCBtb2RlbC5yZXNldF9zdGF0ZSwge1xuICAgICAgICAgICAgICAgIGZyYW1lU2FtcGxlczogdGhpcy5vcHRpb25zLmZyYW1lU2FtcGxlcyxcbiAgICAgICAgICAgICAgICBwb3NpdGl2ZVNwZWVjaFRocmVzaG9sZDogdGhpcy5vcHRpb25zLnBvc2l0aXZlU3BlZWNoVGhyZXNob2xkLFxuICAgICAgICAgICAgICAgIG5lZ2F0aXZlU3BlZWNoVGhyZXNob2xkOiB0aGlzLm9wdGlvbnMubmVnYXRpdmVTcGVlY2hUaHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgcmVkZW1wdGlvbkZyYW1lczogdGhpcy5vcHRpb25zLnJlZGVtcHRpb25GcmFtZXMsXG4gICAgICAgICAgICAgICAgcHJlU3BlZWNoUGFkRnJhbWVzOiB0aGlzLm9wdGlvbnMucHJlU3BlZWNoUGFkRnJhbWVzLFxuICAgICAgICAgICAgICAgIG1pblNwZWVjaEZyYW1lczogdGhpcy5vcHRpb25zLm1pblNwZWVjaEZyYW1lcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFkTm9kZS5wb3J0Lm9ubWVzc2FnZSA9IGFzeW5jIChldikgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXYuZGF0YT8ubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIF9jb21tb25fMS5NZXNzYWdlLkF1ZGlvRnJhbWU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBldi5kYXRhLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmFtZSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0ZyYW1lKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgKDAsIF9jb21tb25fMS52YWxpZGF0ZU9wdGlvbnMpKG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXVkaW9Ob2RlVkFEID0gQXVkaW9Ob2RlVkFEO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhbC10aW1lLXZhZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXVkaW9GaWxlVG9BcnJheSA9IHZvaWQgMDtcbmFzeW5jIGZ1bmN0aW9uIGF1ZGlvRmlsZVRvQXJyYXkoYXVkaW9GaWxlRGF0YSkge1xuICAgIGNvbnN0IGN0eCA9IG5ldyBPZmZsaW5lQXVkaW9Db250ZXh0KDEsIDEsIDQ0MTAwKTtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGxldCBhdWRpb0J1ZmZlciA9IG51bGw7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlbmRcIiwgKGV2KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdWRpb0RhdGEgPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgY3R4LmRlY29kZUF1ZGlvRGF0YShhdWRpb0RhdGEsIChidWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICBhdWRpb0J1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICBjdHhcbiAgICAgICAgICAgICAgICAgICAgLnN0YXJ0UmVuZGVyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHJlbmRlcmVkQnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVuZGVyaW5nIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICAgICAgICAgICAgICAgIHJlcygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFJlbmRlcmluZyBmYWlsZWQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3Igd2l0aCBkZWNvZGluZyBhdWRpbyBkYXRhOiAke2V9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihhdWRpb0ZpbGVEYXRhKTtcbiAgICB9KTtcbiAgICBpZiAoYXVkaW9CdWZmZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJzb21lIHNoaXRcIik7XG4gICAgfVxuICAgIGxldCBfYXVkaW9CdWZmZXIgPSBhdWRpb0J1ZmZlcjtcbiAgICBsZXQgb3V0ID0gbmV3IEZsb2F0MzJBcnJheShfYXVkaW9CdWZmZXIubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9hdWRpb0J1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IF9hdWRpb0J1ZmZlci5udW1iZXJPZkNoYW5uZWxzOyBqKyspIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIG91dFtpXSArPSBfYXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoailbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYXVkaW86IG91dCwgc2FtcGxlUmF0ZTogX2F1ZGlvQnVmZmVyLnNhbXBsZVJhdGUgfTtcbn1cbmV4cG9ydHMuYXVkaW9GaWxlVG9BcnJheSA9IGF1ZGlvRmlsZVRvQXJyYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJleHBvcnQgY29uc3QgY29uZmlnID0ge1xuICBhcHBTZXJ2ZXJVcmw6IHByb2Nlc3MuZW52LkFQUF9TRVJWRVJfVVJMLFxuICBhcGlTZXJ2ZXJVcmw6IHByb2Nlc3MuZW52LkFQSV9TRVJWRVJfVVJMLFxufTtcbiIsImV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVTdGF0ZVZhbHVlKHN0YXRlVmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZVZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHN0YXRlVmFsdWU7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXMoc3RhdGVWYWx1ZSlcbiAgICAubWFwKChrZXkpID0+IGAke2tleX06JHtzZXJpYWxpemVTdGF0ZVZhbHVlKHN0YXRlVmFsdWVba2V5XSl9YClcbiAgICAuam9pbihcIixcIik7XG59XG4iLCJpbXBvcnQgeyBjb25maWcgfSBmcm9tIFwiLi9Db25maWdNb2R1bGVcIjtcblxuY29uc3QgZmlsZXNUb1JlZGlyZWN0ID0gW1xuICBcInNpbGVyb192YWQub25ueFwiLFxuICBcIm9ydC13YXNtLXNpbWQud2FzbVwiLFxuICBcIm9ydC5taW4uanMubWFwXCIsXG5dO1xuXG4vLyBGdW5jdGlvbiB0byByZWRpcmVjdCBzcGVjaWZpYyBYTUxIdHRwUmVxdWVzdHNcbmZ1bmN0aW9uIHJlZGlyZWN0WE1MSHR0cFJlcXVlc3Qob3Blbikge1xuICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChcbiAgICBtZXRob2QsXG4gICAgdXJsLFxuICAgIGFzeW5jLFxuICAgIHVzZXIsXG4gICAgcGFzc3dvcmRcbiAgKSB7XG4gICAgY29uc3QgZmlsZW5hbWUgPSB1cmwuc3BsaXQoXCIvXCIpLnBvcCgpO1xuICAgIGlmIChmaWxlbmFtZSAmJiBmaWxlc1RvUmVkaXJlY3QuaW5jbHVkZXMoZmlsZW5hbWUpKSB7XG4gICAgICBhcmd1bWVudHNbMV0gPSBgJHtjb25maWcuYXBwU2VydmVyVXJsfS8ke2ZpbGVuYW1lfWA7XG4gICAgfVxuICAgIG9wZW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLy8gRnVuY3Rpb24gdG8gcmVkaXJlY3Qgc3BlY2lmaWMgZmV0Y2ggcmVxdWVzdHNcbmZ1bmN0aW9uIHJlZGlyZWN0RmV0Y2goX2ZldGNoKSB7XG4gIHdpbmRvdy5mZXRjaCA9IGZ1bmN0aW9uICh1cmwsIG9wdHMpIHtcbiAgICBjb25zdCBmaWxlbmFtZSA9IHVybC5zcGxpdChcIi9cIikucG9wKCk7XG4gICAgaWYgKGZpbGVuYW1lICYmIGZpbGVzVG9SZWRpcmVjdC5pbmNsdWRlcyhmaWxlbmFtZSkpIHtcbiAgICAgIGFyZ3VtZW50c1swXSA9IGAke2NvbmZpZy5hcHBTZXJ2ZXJVcmx9LyR7ZmlsZW5hbWV9YDtcbiAgICB9XG4gICAgcmV0dXJuIF9mZXRjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vLyBGdW5jdGlvbiB0byBzZXQgdXAgdGhlIGludGVyY2VwdG9yc1xuZXhwb3J0IGZ1bmN0aW9uIHNldHVwSW50ZXJjZXB0b3JzKCkge1xuICByZWRpcmVjdFhNTEh0dHBSZXF1ZXN0KFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5vcGVuKTtcbiAgcmVkaXJlY3RGZXRjaCh3aW5kb3cuZmV0Y2gpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICByZXR1cm4gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc01vYmlsZURldmljZSgpIHtcbiAgcmV0dXJuIChcbiAgICAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QoXG4gICAgICBuYXZpZ2F0b3IudXNlckFnZW50XG4gICAgKSB8fCB3aW5kb3cubWF0Y2hNZWRpYShcIihtYXgtd2lkdGg6IDc2OHB4KVwiKS5tYXRjaGVzXG4gICk7XG59XG5cbi8vIHRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHNob3cgdGhlIG1vYmlsZSB2aWV3IG9yIG5vdFxuZXhwb3J0IGZ1bmN0aW9uIGlzTW9iaWxlVmlldygpIHtcbiAgbGV0IHVzZXJWaWV3UHJlZmVyZW5jZSA9IG51bGw7XG5cbiAgdHJ5IHtcbiAgICB1c2VyVmlld1ByZWZlcmVuY2UgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInVzZXJWaWV3UHJlZmVyZW5jZVwiKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBhY2Nlc3MgbG9jYWxTdG9yYWdlOiBcIiwgZSk7XG4gIH1cblxuICBsZXQgcHJlZmVyc01vYmlsZSA9IGZhbHNlO1xuICBpZiAodXNlclZpZXdQcmVmZXJlbmNlKSB7XG4gICAgcHJlZmVyc01vYmlsZSA9IHVzZXJWaWV3UHJlZmVyZW5jZSA9PT0gXCJtb2JpbGVcIjtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBpc01vYmlsZURldmljZSBpcyBkZWZpbmVkIG9yIGltcG9ydGVkXG4gIHJldHVybiBpc01vYmlsZURldmljZSgpICYmIHByZWZlcnNNb2JpbGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleGl0TW9iaWxlTW9kZSgpIHtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1c2VyVmlld1ByZWZlcmVuY2VcIiwgXCJkZXNrdG9wXCIpOyAvLyBTYXZlIHByZWZlcmVuY2VcblxuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJtb2JpbGUtdmlld1wiKTtcbiAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZGVza3RvcC12aWV3XCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW50ZXJNb2JpbGVNb2RlKCkge1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInVzZXJWaWV3UHJlZmVyZW5jZVwiLCBcIm1vYmlsZVwiKTsgLy8gU2F2ZSBwcmVmZXJlbmNlXG5cbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZGVza3RvcC12aWV3XCIpO1xuICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJtb2JpbGUtdmlld1wiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFVzZXJBZ2VudEZsYWdzKCkge1xuICBjb25zdCBpc0ZpcmVmb3hBbmRyb2lkID1cbiAgICAvRmlyZWZveC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAvQW5kcm9pZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICBpZiAoaXNGaXJlZm94QW5kcm9pZCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImZpcmVmb3gtYW5kcm9pZFwiKTtcbiAgfVxuXG4gIGFkZERldmljZUZsYWdzKGVsZW1lbnQpO1xuICBhZGRWaWV3RmxhZ3MoZWxlbWVudCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGREZXZpY2VGbGFncyhlbGVtZW50KSB7XG4gIGlmIChpc01vYmlsZURldmljZSgpKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibW9iaWxlLWRldmljZVwiKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkVmlld0ZsYWdzKGVsZW1lbnQpIHtcbiAgaWYgKGlzTW9iaWxlVmlldygpKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZGVza3RvcC12aWV3XCIpO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm1vYmlsZS12aWV3XCIpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcIm1vYmlsZS12aWV3XCIpO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImRlc2t0b3Atdmlld1wiKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlTWFjaGluZSwgYWN0aW9ucyB9IGZyb20gXCJ4c3RhdGVcIjtcbmNvbnN0IHsgbG9nIH0gPSBhY3Rpb25zO1xuaW1wb3J0IHsgTWljVkFEIH0gZnJvbSBcIkByaWNreTAxMjMvdmFkLXdlYlwiO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSBcIi4uL0NvbmZpZ01vZHVsZVwiO1xuaW1wb3J0IHsgc2V0dXBJbnRlcmNlcHRvcnMgfSBmcm9tIFwiLi4vUmVxdWVzdEludGVyY2VwdG9yXCI7XG5pbXBvcnQgeyBjb252ZXJ0VG9XYXZCbG9iIH0gZnJvbSBcIi4uL0F1ZGlvRW5jb2RlclwiO1xuXG4vKiBzZXQgVVJMcyBmb3IgVkFEIHJlc291cmNlcyAqL1xuc2V0dXBJbnRlcmNlcHRvcnMoKTtcbmNvbnN0IGZ1bGxXb3JrbGV0VVJMID0gYCR7Y29uZmlnLmFwcFNlcnZlclVybH0vdmFkLndvcmtsZXQuYnVuZGxlLm1pbi5qc2A7XG5cbmNvbnN0IEV2ZW50QnVzID0gd2luZG93LkV2ZW50QnVzO1xuXG5sZXQgYXVkaW9NaW1lVHlwZSA9IFwiYXVkaW8vd2F2XCI7XG5sZXQgc3BlZWNoU3RhcnRUaW1lID0gMDtcbmNvbnN0IHRocmVzaG9sZCA9IDEwMDA7IC8vIDEwMDAgbXMgPSAxIHNlY29uZCwgYWJvdXQgdGhlIGxlbmd0aCBvZiBcIkhleSwgUGlcIlxuXG5sZXQgbWljcm9waG9uZTtcblxuYXN5bmMgZnVuY3Rpb24gc2V0dXBSZWNvcmRpbmcoY2FsbGJhY2spIHtcbiAgaWYgKG1pY3JvcGhvbmUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcbiAgICAgIGF1ZGlvOiB7XG4gICAgICAgIGNoYW5uZWxDb3VudDogMSxcbiAgICAgICAgZWNob0NhbmNlbGxhdGlvbjogdHJ1ZSxcbiAgICAgICAgYXV0b0dhaW5Db250cm9sOiB0cnVlLFxuICAgICAgICBub2lzZVN1cHByZXNzaW9uOiB0cnVlLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBtaWNyb3Bob25lID0gYXdhaXQgTWljVkFELm5ldyh7XG4gICAgICB3b3JrbGV0VVJMOiBmdWxsV29ya2xldFVSTCxcbiAgICAgIHN0cmVhbSxcbiAgICAgIHBvc2l0aXZlU3BlZWNoVGhyZXNob2xkOiAwLjgsXG4gICAgICBtaW5TcGVlY2hGcmFtZXM6IDUsXG4gICAgICBwcmVTcGVlY2hQYWRGcmFtZXM6IDEwLFxuICAgICAgb25TcGVlY2hTdGFydDogKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNwZWVjaCBzdGFydGVkXCIpO1xuICAgICAgICBzcGVlY2hTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgfSxcbiAgICAgIG9uU3BlZWNoRW5kOiAocmF3QXVkaW9EYXRhKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU3BlZWNoIGVuZGVkXCIpO1xuXG4gICAgICAgIGNvbnN0IGF1ZGlvQmxvYiA9IGNvbnZlcnRUb1dhdkJsb2IocmF3QXVkaW9EYXRhKTtcbiAgICAgICAgRXZlbnRCdXMuZW1pdChcImF1ZGlvOmRhdGFhdmFpbGFibGVcIiwgeyBibG9iOiBhdWRpb0Jsb2IgfSk7XG4gICAgICB9LFxuICAgICAgb25WQURNaXNmaXJlOiAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVkFEIG1pc2ZpcmUuIEF1ZGlvIHdhcyBub3Qgc3BlZWNoLlwiKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlZBRCBmYWlsZWQgdG8gbG9hZFwiLCBlcnIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRlYXJEb3duUmVjb3JkaW5nKCkge1xuICBpZiAobWljcm9waG9uZSkge1xuICAgIG1pY3JvcGhvbmUucGF1c2UoKTtcbiAgfVxuICBtaWNyb3Bob25lID0gbnVsbDtcbn1cblxuZXhwb3J0IGNvbnN0IGF1ZGlvSW5wdXRNYWNoaW5lID0gY3JlYXRlTWFjaGluZShcbiAge1xuICAgIC8qKiBAeHN0YXRlLWxheW91dCBONElncGdKZzVtRE9JQzVRRU1DdUVDV0I3QWtnT3dBZFVBWEFPZ0Njd0FiTVpXU0FZbVFHTUJIVkRTZ2JRQVlCZFJLQUpaWUdZdGp5Q1FBRDBRQkdBR3dCbVVnRllBTkNBQ2VpSlhJQWNwQlFIWUFuQXRQNmwrZ0N3MmxBSmdVMkF2aTgxcE11UWlWSXQybkJoNFVBd1FXSGhncEVFQWJsZ0ExcEdlMlBoRVpQNGM1RUZRQ0RGWXpNamk0Yng4eFZMQ29vV1NTREtJcWc2YU9najZ4bkpxQ3FvOHF0YktwandPRG00ZTZNaythV3daV1F4ZzVPUlk1S1FFVkFVQVpuTUF0bjdEM3FsKzQ0SEJPWGl4K1pYRnBkWGxZaEpTc2doeXhpb2Eyb2o5cXFUOTdRLVdkbzRLZ3lCSmJhK2RLY1JpVUdoME1EbklRaUs3aEc3eUI1cUJxSWZTdERvOEhoeUhqNld6Mkp4eWY2QWxMQXZhVUNCUkNBMEJpd1lqSWNqRWFFZ1M2VkJFSUd4eUZTV2V6R0o2TmZUbVVoeVZRS1JTbWJGS1pRdElsYkVsakFMa2loZ1poelREQkduRUxBRUFCS1lIWWNHSWtDWkxPdTFWdUpnVWFpVXZRVURqNWlIRnJSc0FvNkRuc0ZtTW5SbFhqbHV3VmtDVkt2SWFwQ0VBS3lBQWd0RmtCZ2xnQWpHakcyR3NzMjFCdzhOVDZWU21KUzhsRk5PMmtHd09jdzhCUUtIaVMzT0U5d0EyV2pQMFpBTUVNQjRFTUFaVTFCQTFXcVRGVk5vRnVjamtPYU1kdnpwaHNwaUZqZ2Vpa3JVcHJReDlEWkJpcGJiYXluYTFvWERVWmo4Y1QtREt5WUhOUVFrNVVWblRlbkh6d0xiMU1KWXI1WVgxZTlJeDJhNER0SzFMWWdEQjluQ1ZTRHZJSTRxTGE5b0lKNmJ6M09ZU2pPallYVEdLS2JpMW5nV0FRSEFVakVxTUo3OXZDcVlJQUF0QW8rYkVZK3BoVWJ5UERGczRUNm9iV3VFN09DdEQwQkErSEFXeXhiNXNPTmhHRmlxaGZIaXZ4TG5XSzVmbVNXU2NTbW9Ic3VtUmlJYm1VSDlOT3c2V0gwcWlxTmlWRktCK1FMeWsySEVYS2VoRnlRNCtnT0VXdGpLZm1Ra3FIQnI2Q2RwU2lxUHB2cmZoU0dCVW1BTWxucmNTaEtCbVNsNXZlNHJUc29EaHpoV1ZiU2t4OWFTZjZGS1VFR0laK1daNTVkSmFKZ0dLRmpRTWFRdUpSWG9NV0x1NXE1a3MycllkbDI2VWdlZXRqVGxSRGk1VkJUN0dLUTFqRmZPc1ZpY3hwSkphUXY0RVArZFZzbklKYXRCWkUyZXBPV1pPRzFFMmtDMEZiNkFvVmk1bVdhRXVFQUEgKi9cbiAgICBjb250ZXh0OiB7XG4gICAgICB3YWl0aW5nVG9TdG9wOiBmYWxzZSxcbiAgICB9LFxuICAgIGlkOiBcImF1ZGlvSW5wdXRcIixcbiAgICBpbml0aWFsOiBcInJlbGVhc2VkXCIsXG4gICAgc3RhdGVzOiB7XG4gICAgICByZWxlYXNlZDoge1xuICAgICAgICBvbjoge1xuICAgICAgICAgIGFjcXVpcmU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJhY3F1aXJpbmdcIixcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGFjcXVpcmluZzoge1xuICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICBcIkFjcXVpcmluZyB0aGUgbWljcm9waG9uZS4gV2FpdHMgdW50aWwgYXN5bmNocm9ub3VzIGNhbGwgaGFzIGNvbXBsZXRlZC5cIixcbiAgICAgICAgaW52b2tlOiB7XG4gICAgICAgICAgc3JjOiBcImFjcXVpcmVNaWNyb3Bob25lXCIsXG4gICAgICAgICAgb25Eb25lOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiYWNxdWlyZWRcIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRXJyb3I6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJyZWxlYXNlZFwiLFxuICAgICAgICAgICAgYWN0aW9uczogXCJsb2dFcnJvclwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgYWNxdWlyZWQ6IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTWljcm9waG9uZSBhY3F1aXJlZCBhbmQgcmVhZHkgdG8gc3RhcnQgcmVjb3JkaW5nLlwiLFxuICAgICAgICBpbml0aWFsOiBcImlkbGVcIixcbiAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgaWRsZToge1xuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IFwicmVjb3JkaW5nXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uczoge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGFydFJlY29yZGluZ1wiLFxuICAgICAgICAgICAgICAgICAgY29uZDogXCJtaWNyb3Bob25lQWNxdWlyZWRcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlY29yZGluZzoge1xuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgc3RvcFJlcXVlc3RlZDoge1xuICAgICAgICAgICAgICAgIHRhcmdldDogXCJwZW5kaW5nU3RvcFwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkYXRhQXZhaWxhYmxlOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uczoge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZW5kRGF0YVwiLFxuICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGludGVybmFsOiB0cnVlLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBlbmRpbmdTdG9wOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICAgXCJXYWl0aW5nIGZvciB0aGUgbWVkaWEgcmVjb3JkaW5nIGRldmljZSB0byBzdG9wIHJlY29yZGluZy5cIixcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIHN0b3A6IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IFwic3RvcHBlZFwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkYXRhQXZhaWxhYmxlOiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBcInN0b3BwZWRcIixcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInNlbmREYXRhXCIsXG4gICAgICAgICAgICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW50cnk6IFwicHJlcGFyZVN0b3BcIixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0b3BwZWQ6IHtcbiAgICAgICAgICAgIGVudHJ5OiBcIm5vdGlmeVN0b3BwZWRcIixcbiAgICAgICAgICAgIGFsd2F5czogXCJpZGxlXCIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICByZWxlYXNlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwicmVsZWFzZWRcIixcbiAgICAgICAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJyZWxlYXNlTWljcm9waG9uZVwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIHByZWRpY3RhYmxlQWN0aW9uQXJndW1lbnRzOiB0cnVlLFxuICAgIHByZXNlcnZlQWN0aW9uT3JkZXI6IHRydWUsXG4gIH0sXG4gIHtcbiAgICBhY3Rpb25zOiB7XG4gICAgICBzdGFydFJlY29yZGluZzogKGNvbnRleHQsIGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnRleHQucmVjb3JkaW5nU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAvLyBTdGFydCByZWNvcmRpbmdcbiAgICAgICAgaWYgKG1pY3JvcGhvbmUgJiYgbWljcm9waG9uZS5saXN0ZW5pbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgbWljcm9waG9uZS5zdGFydCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgRXZlbnRCdXMuZW1pdChcInNheXBpOnVzZXJTcGVha2luZ1wiKTtcbiAgICAgIH0sXG5cbiAgICAgIHByZXBhcmVTdG9wOiAoY29udGV4dCwgZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKG1pY3JvcGhvbmUgJiYgbWljcm9waG9uZS5saXN0ZW5pbmcgPT09IHRydWUpIHtcbiAgICAgICAgICBjb250ZXh0LndhaXRpbmdUb1N0b3AgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBub3RpZnlTdG9wcGVkOiAoY29udGV4dCwgZXZlbnQpID0+IHtcbiAgICAgICAgdmFyIHJlY29yZGluZ1N0b3BUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIHJlY29yZGluZ0R1cmF0aW9uID0gcmVjb3JkaW5nU3RvcFRpbWUgLSBjb250ZXh0LnJlY29yZGluZ1N0YXJ0VGltZTtcblxuICAgICAgICBFdmVudEJ1cy5lbWl0KFwic2F5cGk6dXNlckZpbmlzaGVkU3BlYWtpbmdcIiwge1xuICAgICAgICAgIGR1cmF0aW9uUmVjb3JkaW5nOiByZWNvcmRpbmdEdXJhdGlvbixcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBzZW5kRGF0YTogKGNvbnRleHQsIGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGF1ZGlvQmxvYiA9IGV2ZW50LmJsb2I7XG4gICAgICAgIGNvbnN0IHNpemVJbktiID0gKGF1ZGlvQmxvYi5ieXRlTGVuZ3RoIC8gMTAyNCkudG9GaXhlZCgyKTsgLy8gQ29udmVydCB0byBraWxvYnl0ZXMgYW5kIGtlZXAgMiBkZWNpbWFsIHBsYWNlc1xuICAgICAgICBjb25zb2xlLmxvZyhgU2VuZGluZyAke3NpemVJbktifWtiIG9mIGF1ZGlvIGRhdGEgdG8gc2VydmVyYCk7XG5cbiAgICAgICAgaWYgKGNvbnRleHQud2FpdGluZ1RvU3RvcCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG1pY3JvcGhvbmUucGF1c2UoKTtcbiAgICAgICAgICBjb250ZXh0LndhaXRpbmdUb1N0b3AgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB0aGUgc3RvcCB0aW1lIGFuZCBjYWxjdWxhdGUgdGhlIGR1cmF0aW9uXG4gICAgICAgIHZhciBzcGVlY2hTdG9wVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBzcGVlY2hEdXJhdGlvbiA9IHNwZWVjaFN0b3BUaW1lIC0gc3BlZWNoU3RhcnRUaW1lO1xuXG4gICAgICAgIC8vIElmIHRoZSBkdXJhdGlvbiBpcyBncmVhdGVyIHRoYW4gdGhlIHRocmVzaG9sZCwgdXBsb2FkIHRoZSBhdWRpbyBmb3IgdHJhbnNjcmlwdGlvblxuICAgICAgICBpZiAoc2l6ZUluS2IgPiAwKSB7XG4gICAgICAgICAgLy8gVXBsb2FkIHRoZSBhdWRpbyB0byB0aGUgc2VydmVyIGZvciB0cmFuc2NyaXB0aW9uXG4gICAgICAgICAgRXZlbnRCdXMuZW1pdChcInNheXBpOnVzZXJTdG9wcGVkU3BlYWtpbmdcIiwge1xuICAgICAgICAgICAgZHVyYXRpb246IHNwZWVjaER1cmF0aW9uLFxuICAgICAgICAgICAgYmxvYjogYXVkaW9CbG9iLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICByZWxlYXNlTWljcm9waG9uZTogKGNvbnRleHQsIGV2ZW50KSA9PiB7XG4gICAgICAgIHRlYXJEb3duUmVjb3JkaW5nKCk7XG4gICAgICB9LFxuXG4gICAgICBsb2dFcnJvcjogKGNvbnRleHQsIGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhY3F1aXJpbmcgbWljcm9waG9uZTogXCIsIGV2ZW50LmRhdGEpO1xuICAgICAgfSxcbiAgICB9LFxuICAgIHNlcnZpY2VzOiB7XG4gICAgICBhY3F1aXJlTWljcm9waG9uZTogKGNvbnRleHQsIGV2ZW50LCB7IHNlbmQgfSkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHNldHVwUmVjb3JkaW5nKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChtaWNyb3Bob25lKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJGYWlsZWQgdG8gYWNxdWlyZSBtaWNyb3Bob25lIHJlc291cmNlLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICB9LFxuICAgIGd1YXJkczoge1xuICAgICAgbWljcm9waG9uZUFjcXVpcmVkOiAoY29udGV4dCwgZXZlbnQpID0+IHtcbiAgICAgICAgcmV0dXJuIG1pY3JvcGhvbmUgIT09IG51bGw7XG4gICAgICB9LFxuICAgICAgaGFzRGF0YTogKGNvbnRleHQsIGV2ZW50KSA9PiB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmF1ZGlvRGF0YUNodW5rcy5sZW5ndGggPiAwO1xuICAgICAgfSxcbiAgICB9LFxuICAgIGRlbGF5czoge30sXG4gIH1cbik7XG4iLCJpbXBvcnQgeyBjcmVhdGVNYWNoaW5lLCBhc3NpZ24gfSBmcm9tIFwieHN0YXRlXCI7XG5pbXBvcnQgeyBpc1NhZmFyaSB9IGZyb20gXCIuLi9Vc2VyQWdlbnRNb2R1bGVcIjtcblxuY29uc3QgRXZlbnRCdXMgPSB3aW5kb3cuRXZlbnRCdXM7XG5cbmNvbnN0IGF1ZGlvRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJhdWRpb1wiKTtcbmlmICghYXVkaW9FbGVtZW50KSB7XG4gIGNvbnNvbGUuZXJyb3IoXCJBdWRpbyBlbGVtZW50IG5vdCBmb3VuZCBpbiBvdXRwdXQgbWFjaGluZSFcIik7XG59XG5cbmV4cG9ydCBjb25zdCBhdWRpb091dHB1dE1hY2hpbmUgPSBjcmVhdGVNYWNoaW5lKFxuICB7XG4gICAgLyoqIEB4c3RhdGUtbGF5b3V0IE40SWdwZ0pnNW1ET0lDNVFFTUN1RUNXQjdBOHFnTGdBNEVERVlBdG9maHBBTm9BTUF1b3FJVnJCdFZnSFlzZ0NlaUFMUUJHQU93QldBRFFnQUhvaEVCT0FDektBZE1yRUEyTFFBNEFUUHEwaUpXLVFGOXpNdEpsd0ZpK05SZ2dBYk1DUmRaa0VXUG1RQW5mQVptSkJBMkRpNWVVUGtFUXdrMWFRRkVSWDFGTlhvTStoTUFabm9KWFJGc3JVdHJkR3c4SWdJMVQyOE1iaWdQTHdoSWNqQS1DR1EtWUw1d3ptd28wQmlKZlJsQkJBS0V6UHBGRFBGZGJQMWxFcEFiY3ZzcW11YUlOWDh3YjM0U1FoZGtmbTdRM3NpK0dKRXNyUVRzbWJORXNkVHN5YkVERDd5Q291WFZ1MHFqazJrRFVSeE9kUWFoRFFzREFaMVk3RDZQQ3V5U005MFVJbjBHS015bStvMFFxbjBhaTBDMCt1bStoV0tWaFdaUUJEbXFUUkJZUDRFTEkzQzJjTENDTXUwUlJkd2tEd3hXSzBPUHllSVE0bm9hbjBFZysraSsrVUsrVCtOSXFkT0IyeVpMSUF4c2h1RXo4QUFMZnhZVkJRQTBjaTc5WkVJUlF5dFJpYlRUZWhhUExaYkx6TVhETVQyM1F6QjFraFctS24tVlViQmthNDdNK29rQzFjcTA4bTJvLW5vekdHWVc0cElJQjUzWW42VW5rb09sV3lob0hoMEhReUNIU094aUx4d1lLTExxSXBpUlptYkVac2JaWlM2TlNGUE55Z00tU2xGdGFBK25lUmtWaUFrWGFiR3VJZ1p5QlI1bnRpRzZLUlJ0OU9pelBLVzMyaVN6ZmtGaVRLNHZyVXNUN1pnTm1WbUZnQURXZENZUFRqU0lUcGo1WW5vMlF4ejBRUlNFbjItcjBHSXlqaU9JbGhVdHdXRE5QQW9RaGhlcjYxdSs5WUlFSVdoaWtJUmlFcWV3WXFoZVRpdUdBeUVMdGF5Z2pKbTJodktrSWg2RW9MYmRqK1o2am1xVFFRcVIzSm9YUnZyMmlJTnd5a1lKaG1HS3ZHSGtlSHlIcm91aktIaEk2MG1HVjZjWFdTNnhCSWFUSnM2MHFpWVNraGZIdStoRk82aWdzUXBsNWJEc2V3UUdNOElvWXVNUVVlb21sUEdLK2haRVNDd2dXQkVGaUtaSmJqaFptcjFNcHFHcVZvaWlycW9Nbk9xNjdyWkdLQ3pxSDIrYUJzTzFMbm1PNnJscWdNSVFDRjlrS0FKUkxpSzJhWWlyb0NYZ2U4S1ZEbjVoRlpUZVd6NWRhdVRlczUybVpoSWRxNWpWRkpRZVlRQSAqL1xuICAgIGlkOiBcImF1ZGlvT3V0cHV0XCIsXG4gICAgY29udGV4dDogeyBhdXRvcGxheTogZmFsc2UsIGF1ZGlvRWxlbWVudDogYXVkaW9FbGVtZW50IH0sXG4gICAgaW5pdGlhbDogXCJpZGxlXCIsXG5cbiAgICBzdGF0ZXM6IHtcbiAgICAgIGlkbGU6IHtcbiAgICAgICAgb246IHtcbiAgICAgICAgICBsb2Fkc3RhcnQ6IFwibG9hZGluZ1wiLFxuICAgICAgICB9LFxuICAgICAgfSxcblxuICAgICAgbG9hZGluZzoge1xuICAgICAgICBvbjoge1xuICAgICAgICAgIGxvYWRlZG1ldGFkYXRhOiBcImxvYWRlZFwiLFxuICAgICAgICB9LFxuICAgICAgfSxcblxuICAgICAgbG9hZGVkOiB7XG4gICAgICAgIGluaXRpYWw6IFwicmVhZHlcIixcblxuICAgICAgICBvbjoge1xuICAgICAgICAgIGVtcHRpZWQ6IFwiaWRsZVwiLFxuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXRlczoge1xuICAgICAgICAgIHJlYWR5OiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYEF1ZGlvIGhhcyBsb2FkZWQgYW5kIGlzIHJlYWR5IHRvIHN0YXJ0IHBsYXlpbmcgKGZ1cnRoZXIgYnVmZmVyaW5nIG1heSBiZSByZXF1aXJlZCB0byByZWFjaCB0aGUgZW5kKS5gLFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgcGxheTogXCJwbGF5aW5nXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW50cnk6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlbWl0RXZlbnRcIixcbiAgICAgICAgICAgICAgcGFyYW1zOiB7IGV2ZW50TmFtZTogXCJzYXlwaTpyZWFkeVwiIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBwbGF5aW5nOiB7XG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBwYXVzZTogXCJwYXVzZWRcIixcbiAgICAgICAgICAgICAgZW5kZWQ6IFwiZW5kZWRcIixcbiAgICAgICAgICAgICAgY2FucGxheXRocm91Z2g6IHsgdGFyZ2V0OiBcInBsYXlpbmdcIiwgaW50ZXJuYWw6IHRydWUgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbHdheXM6IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcInBhdXNlZFwiLFxuICAgICAgICAgICAgICBjb25kOiBcImlzU2FmYXJpQXV0b1BsYXlcIixcbiAgICAgICAgICAgICAgYWN0aW9uczogW1xuICAgICAgICAgICAgICAgIFwicmVxdWVzdFBhdXNlXCIsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJlbWl0RXZlbnRcIixcbiAgICAgICAgICAgICAgICAgIHBhcmFtczogeyBldmVudE5hbWU6IFwic2F5cGk6c2FmYXJpQmxvY2tlZFwiIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnRyeTogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlbWl0RXZlbnRcIixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHsgZXZlbnROYW1lOiBcInNheXBpOnBpU3BlYWtpbmdcIiB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4aXQ6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZW1pdEV2ZW50XCIsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7IGV2ZW50TmFtZTogXCJzYXlwaTpwaVN0b3BwZWRTcGVha2luZ1wiIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGFzc2lnbih7XG4gICAgICAgICAgICAgICAgYXV0b3BsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgYXVkaW9FbGVtZW50OiAoY29udGV4dCkgPT4gY29udGV4dC5hdWRpb0VsZW1lbnQsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgcGF1c2VkOiB7XG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBwbGF5OiBcInBsYXlpbmdcIixcbiAgICAgICAgICAgICAgcmVsb2FkOiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNhdWRpb091dHB1dC5sb2FkaW5nXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBSZWxvYWQgdGhlIGF1ZGlvIHN0cmVhbSBmb3IgU2FmYXJpLiBUaGlzIGlzIHRoZSBvbmx5IGNvbW1hbmQgdGhhdCBleHRlcm5hbCBtb2R1bGVzIGNhbiBzZW5kIHRoZSBtYWNoaW5lLmAsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW1xuICAgICAgICAgICAgICAgICAgYXNzaWduKChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvRWxlbWVudDogY29udGV4dC5hdWRpb0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIFwicmVxdWVzdFJlbG9hZFwiLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgY29uZDogXCJpc1NhZmFyaVwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZW5kZWQ6IHtcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIHNlZWtlZDoge1xuICAgICAgICAgICAgICAgIHRhcmdldDogXCIjYXVkaW9PdXRwdXQubG9hZGVkLnJlYWR5XCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBBbiBlbmRlZCB0cmFjayBpcyBzZWVrZWQgYmFjayB0byBlYXJsaWVyIGluIHRoZSB0cmFjay5gLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudHJ5OiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVtaXRFdmVudFwiLFxuICAgICAgICAgICAgICAgIHBhcmFtczogeyBldmVudE5hbWU6IFwic2F5cGk6cGlGaW5pc2hlZFNwZWFraW5nXCIgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBwcmVkaWN0YWJsZUFjdGlvbkFyZ3VtZW50czogdHJ1ZSxcbiAgICBwcmVzZXJ2ZUFjdGlvbk9yZGVyOiB0cnVlLFxuICB9LFxuICB7XG4gICAgYWN0aW9uczoge1xuICAgICAgZW1pdEV2ZW50OiAoY29udGV4dCwgZXZlbnQsIHsgYWN0aW9uIH0pID0+IHtcbiAgICAgICAgRXZlbnRCdXMuZW1pdChhY3Rpb24ucGFyYW1zLmV2ZW50TmFtZSk7XG4gICAgICB9LFxuICAgICAgcmVxdWVzdFBhdXNlOiAoY29udGV4dCwgZXZlbnQpID0+IHtcbiAgICAgICAgY29udGV4dC5hdWRpb0VsZW1lbnQucGF1c2UoKTtcbiAgICAgIH0sXG4gICAgICBzZWVrVG9FbmQ6IChjb250ZXh0LCBldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBhdWRpbyA9IGNvbnRleHQuYXVkaW9FbGVtZW50O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYXVkaW8uZHVyYXRpb24gJiZcbiAgICAgICAgICAhYXVkaW8uZW5kZWQgJiZcbiAgICAgICAgICBhdWRpby5jdXJyZW50VGltZSA8IGF1ZGlvLmR1cmF0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgIGF1ZGlvLmN1cnJlbnRUaW1lID0gYXVkaW8uZHVyYXRpb247IC8vIHNlZWsgdGhlIGF1ZGlvIHRvIHRoZSBlbmRcbiAgICAgICAgICBhdWRpby5wbGF5KCk7IC8vIHRyaWdnZXIgdGhlIGVuZGVkIGV2ZW50XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRCdXMuZW1pdChcInNheXBpOnBpRmluaXNoZWRTcGVha2luZ1wiKTtcbiAgICAgIH0sXG4gICAgICByZXF1ZXN0UmVsb2FkOiAoY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBhdWRpbyA9IGNvbnRleHQuYXVkaW9FbGVtZW50O1xuICAgICAgICBhdWRpby5sb2FkKCk7XG4gICAgICAgIGF1ZGlvLnBsYXkoKTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICBndWFyZHM6IHtcbiAgICAgIGlzU2FmYXJpOiAoY29udGV4dCwgZXZlbnQpID0+IHtcbiAgICAgICAgcmV0dXJuIGlzU2FmYXJpKCk7XG4gICAgICB9LFxuICAgICAgaXNTYWZhcmlBdXRvUGxheTogKGNvbnRleHQsIGV2ZW50KSA9PiB7XG4gICAgICAgIHJldHVybiBpc1NhZmFyaSgpICYmIGNvbnRleHQuYXV0b3BsYXk7XG4gICAgICB9LFxuICAgIH0sXG4gIH1cbik7XG4iLCIvKiFcbiogT05OWCBSdW50aW1lIFdlYiB2MS4xNS4xXG4qIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qL1xuIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5vcnQ9dCgpOmUub3J0PXQoKX0oc2VsZiwoKCk9PigoKT0+e3ZhciBfX3dlYnBhY2tfbW9kdWxlc19fPXs4NDUzOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtuLnIodCksbi5kKHQse0luZmVyZW5jZVNlc3Npb246KCk9PmYsVGVuc29yOigpPT5wLGVudjooKT0+YSxyZWdpc3RlckJhY2tlbmQ6KCk9Pml9KTtjb25zdCByPXt9LG89W10saT0oZSx0LG4pPT57aWYoIXR8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQuaW5pdHx8XCJmdW5jdGlvblwiIT10eXBlb2YgdC5jcmVhdGVTZXNzaW9uSGFuZGxlcil0aHJvdyBuZXcgVHlwZUVycm9yKFwibm90IGEgdmFsaWQgYmFja2VuZFwiKTt7Y29uc3QgaT1yW2VdO2lmKHZvaWQgMD09PWkpcltlXT17YmFja2VuZDp0LHByaW9yaXR5Om59O2Vsc2V7aWYoaS5wcmlvcml0eT5uKXJldHVybjtpZihpLnByaW9yaXR5PT09biYmaS5iYWNrZW5kIT09dCl0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWdpc3RlciBiYWNrZW5kIFwiJHtlfVwiIHVzaW5nIHByaW9yaXR5ICR7bn1gKX1pZihuPj0wKXtjb25zdCB0PW8uaW5kZXhPZihlKTstMSE9PXQmJm8uc3BsaWNlKHQsMSk7Zm9yKGxldCB0PTA7dDxvLmxlbmd0aDt0KyspaWYocltvW3RdXS5wcmlvcml0eTw9bilyZXR1cm4gdm9pZCBvLnNwbGljZSh0LDAsZSk7by5wdXNoKGUpfX19LGE9bmV3IGNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy53YXNtPXt9LHRoaXMud2ViZ2w9e30sdGhpcy53ZWJncHU9e30sdGhpcy5sb2dMZXZlbEludGVybmFsPVwid2FybmluZ1wifXNldCBsb2dMZXZlbChlKXtpZih2b2lkIDAhPT1lKXtpZihcInN0cmluZ1wiIT10eXBlb2YgZXx8LTE9PT1bXCJ2ZXJib3NlXCIsXCJpbmZvXCIsXCJ3YXJuaW5nXCIsXCJlcnJvclwiLFwiZmF0YWxcIl0uaW5kZXhPZihlKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7ZX1gKTt0aGlzLmxvZ0xldmVsSW50ZXJuYWw9ZX19Z2V0IGxvZ0xldmVsKCl7cmV0dXJuIHRoaXMubG9nTGV2ZWxJbnRlcm5hbH19LHM9bmV3IE1hcChbW1wiZmxvYXQzMlwiLEZsb2F0MzJBcnJheV0sW1widWludDhcIixVaW50OEFycmF5XSxbXCJpbnQ4XCIsSW50OEFycmF5XSxbXCJ1aW50MTZcIixVaW50MTZBcnJheV0sW1wiaW50MTZcIixJbnQxNkFycmF5XSxbXCJpbnQzMlwiLEludDMyQXJyYXldLFtcImJvb2xcIixVaW50OEFycmF5XSxbXCJmbG9hdDY0XCIsRmxvYXQ2NEFycmF5XSxbXCJ1aW50MzJcIixVaW50MzJBcnJheV1dKSx1PW5ldyBNYXAoW1tGbG9hdDMyQXJyYXksXCJmbG9hdDMyXCJdLFtVaW50OEFycmF5LFwidWludDhcIl0sW0ludDhBcnJheSxcImludDhcIl0sW1VpbnQxNkFycmF5LFwidWludDE2XCJdLFtJbnQxNkFycmF5LFwiaW50MTZcIl0sW0ludDMyQXJyYXksXCJpbnQzMlwiXSxbRmxvYXQ2NEFycmF5LFwiZmxvYXQ2NFwiXSxbVWludDMyQXJyYXksXCJ1aW50MzJcIl1dKTtsZXQgbD0hMTtjbGFzcyBje2NvbnN0cnVjdG9yKGUsdCxuKXtsZXQgcixvLGk7aWYoKCgpPT57aWYoIWwpe2w9ITA7Y29uc3QgZT1cInVuZGVmaW5lZFwiIT10eXBlb2YgQmlnSW50NjRBcnJheSYmXCJmdW5jdGlvblwiPT10eXBlb2YgQmlnSW50NjRBcnJheS5mcm9tLHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEJpZ1VpbnQ2NEFycmF5JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBCaWdVaW50NjRBcnJheS5mcm9tO2UmJihzLnNldChcImludDY0XCIsQmlnSW50NjRBcnJheSksdS5zZXQoQmlnSW50NjRBcnJheSxcImludDY0XCIpKSx0JiYocy5zZXQoXCJ1aW50NjRcIixCaWdVaW50NjRBcnJheSksdS5zZXQoQmlnVWludDY0QXJyYXksXCJ1aW50NjRcIikpfX0pKCksXCJzdHJpbmdcIj09dHlwZW9mIGUpaWYocj1lLGk9bixcInN0cmluZ1wiPT09ZSl7aWYoIUFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgc3RyaW5nIHRlbnNvcidzIGRhdGEgbXVzdCBiZSBhIHN0cmluZyBhcnJheS5cIik7bz10fWVsc2V7Y29uc3Qgbj1zLmdldChlKTtpZih2b2lkIDA9PT1uKXRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHRlbnNvciB0eXBlOiAke2V9LmApO2lmKEFycmF5LmlzQXJyYXkodCkpbz1uLmZyb20odCk7ZWxzZXtpZighKHQgaW5zdGFuY2VvZiBuKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBBICR7cn0gdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgJHtufWApO289dH19ZWxzZSBpZihpPXQsQXJyYXkuaXNBcnJheShlKSl7aWYoMD09PWUubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUZW5zb3IgdHlwZSBjYW5ub3QgYmUgaW5mZXJyZWQgZnJvbSBhbiBlbXB0eSBhcnJheS5cIik7Y29uc3QgdD10eXBlb2YgZVswXTtpZihcInN0cmluZ1wiPT09dClyPVwic3RyaW5nXCIsbz1lO2Vsc2V7aWYoXCJib29sZWFuXCIhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZWxlbWVudCB0eXBlIG9mIGRhdGEgYXJyYXk6ICR7dH0uYCk7cj1cImJvb2xcIixvPVVpbnQ4QXJyYXkuZnJvbShlKX19ZWxzZXtjb25zdCB0PXUuZ2V0KGUuY29uc3RydWN0b3IpO2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdGVuc29yIGRhdGE6ICR7ZS5jb25zdHJ1Y3Rvcn0uYCk7cj10LG89ZX1pZih2b2lkIDA9PT1pKWk9W28ubGVuZ3RoXTtlbHNlIGlmKCFBcnJheS5pc0FycmF5KGkpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHRlbnNvcidzIGRpbXMgbXVzdCBiZSBhIG51bWJlciBhcnJheVwiKTtjb25zdCBhPShlPT57bGV0IHQ9MTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl7Y29uc3Qgcj1lW25dO2lmKFwibnVtYmVyXCIhPXR5cGVvZiByfHwhTnVtYmVyLmlzU2FmZUludGVnZXIocikpdGhyb3cgbmV3IFR5cGVFcnJvcihgZGltc1ske259XSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdDogJHtyfWApO2lmKHI8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZGltc1ske259XSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIGdvdDogJHtyfWApO3QqPXJ9cmV0dXJuIHR9KShpKTtpZihhIT09by5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IncyBzaXplKCR7YX0pIGRvZXMgbm90IG1hdGNoIGRhdGEgbGVuZ3RoKCR7by5sZW5ndGh9KS5gKTt0aGlzLmRpbXM9aSx0aGlzLnR5cGU9cix0aGlzLmRhdGE9byx0aGlzLnNpemU9YX1zdGF0aWMgYnVmZmVyVG9UZW5zb3IoZSx0KXtpZih2b2lkIDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGJ1ZmZlciBtdXN0IGJlIGRlZmluZWRcIik7aWYodm9pZCAwPT09dC5oZWlnaHR8fHZvaWQgMD09PXQud2lkdGgpdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaGVpZ2h0IGFuZCB3aWR0aCBtdXN0IGJlIGRlZmluZWRcIik7aWYoXCJOSFdDXCI9PT10LnRlbnNvckxheW91dCl0aHJvdyBuZXcgRXJyb3IoXCJOSFdDIFRlbnNvciBsYXlvdXQgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7Y29uc3R7aGVpZ2h0Om4sd2lkdGg6cn09dCxvPXQubm9ybT8/e21lYW46MjU1LGJpYXM6MH07bGV0IGksYTtpPVwibnVtYmVyXCI9PXR5cGVvZiBvLm1lYW4/W28ubWVhbixvLm1lYW4sby5tZWFuLG8ubWVhbl06W28ubWVhblswXSxvLm1lYW5bMV0sby5tZWFuWzJdLG8ubWVhblszXT8/MjU1XSxhPVwibnVtYmVyXCI9PXR5cGVvZiBvLmJpYXM/W28uYmlhcyxvLmJpYXMsby5iaWFzLG8uYmlhc106W28uYmlhc1swXSxvLmJpYXNbMV0sby5iaWFzWzJdLG8uYmlhc1szXT8/MF07Y29uc3Qgcz12b2lkIDAhPT10LmJpdG1hcEZvcm1hdD90LmJpdG1hcEZvcm1hdDpcIlJHQkFcIix1PXZvaWQgMCE9PXQudGVuc29yRm9ybWF0JiZ2b2lkIDAhPT10LnRlbnNvckZvcm1hdD90LnRlbnNvckZvcm1hdDpcIlJHQlwiLGw9bipyLHA9XCJSR0JBXCI9PT11P25ldyBGbG9hdDMyQXJyYXkoNCpsKTpuZXcgRmxvYXQzMkFycmF5KDMqbCk7bGV0IGQ9NCxmPTAsaD0xLGc9MixtPTMsYj0wLHk9bCx3PTIqbCxfPS0xO1wiUkdCXCI9PT1zJiYoZD0zLGY9MCxoPTEsZz0yLG09LTEpLFwiUkdCQVwiPT09dT9fPTMqbDpcIlJCR1wiPT09dT8oYj0wLHc9bCx5PTIqbCk6XCJCR1JcIj09PXUmJih3PTAseT1sLGI9MipsKTtmb3IobGV0IHQ9MDt0PGw7dCsrLGYrPWQsZys9ZCxoKz1kLG0rPWQpcFtiKytdPShlW2ZdK2FbMF0pL2lbMF0scFt5KytdPShlW2hdK2FbMV0pL2lbMV0scFt3KytdPShlW2ddK2FbMl0pL2lbMl0sLTEhPT1fJiYtMSE9PW0mJihwW18rK109KGVbbV0rYVszXSkvaVszXSk7cmV0dXJuIG5ldyBjKFwiZmxvYXQzMlwiLHAsXCJSR0JBXCI9PT11P1sxLDQsbixyXTpbMSwzLG4scl0pfXN0YXRpYyBhc3luYyBmcm9tSW1hZ2UoZSx0KXtjb25zdCBuPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50JiZlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCxyPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBJbWFnZURhdGEmJmUgaW5zdGFuY2VvZiBJbWFnZURhdGEsbz1cInVuZGVmaW5lZFwiIT10eXBlb2YgSW1hZ2VCaXRtYXAmJmUgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCxpPVwic3RyaW5nXCI9PXR5cGVvZiBlO2xldCBhLHM9dD8/e307aWYobil7Y29uc3Qgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO24ud2lkdGg9ZS53aWR0aCxuLmhlaWdodD1lLmhlaWdodDtjb25zdCByPW4uZ2V0Q29udGV4dChcIjJkXCIpO2lmKG51bGw9PXIpdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKTt7bGV0IG49ZS5oZWlnaHQsbz1lLndpZHRoO2lmKHZvaWQgMCE9PXQmJnZvaWQgMCE9PXQucmVzaXplZEhlaWdodCYmdm9pZCAwIT09dC5yZXNpemVkV2lkdGgmJihuPXQucmVzaXplZEhlaWdodCxvPXQucmVzaXplZFdpZHRoKSx2b2lkIDAhPT10KXtpZihzPXQsdm9pZCAwIT09dC50ZW5zb3JGb3JtYXQpdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIFJHQkEgZm9yIEhUTUxJbWFnZUVsZW1lbnRcIik7aWYocy50ZW5zb3JGb3JtYXQ9XCJSR0JBXCIsdm9pZCAwIT09dC5oZWlnaHQmJnQuaGVpZ2h0IT09bil0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBpbnB1dCBjb25maWcgaGVpZ2h0IGRvZXNuJ3QgbWF0Y2ggSFRNTEltYWdlRWxlbWVudCBoZWlnaHRcIik7aWYocy5oZWlnaHQ9bix2b2lkIDAhPT10LndpZHRoJiZ0LndpZHRoIT09byl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBpbnB1dCBjb25maWcgd2lkdGggZG9lc24ndCBtYXRjaCBIVE1MSW1hZ2VFbGVtZW50IHdpZHRoXCIpO3Mud2lkdGg9b31lbHNlIHMudGVuc29yRm9ybWF0PVwiUkdCQVwiLHMuaGVpZ2h0PW4scy53aWR0aD1vO3IuZHJhd0ltYWdlKGUsMCwwKSxhPXIuZ2V0SW1hZ2VEYXRhKDAsMCxvLG4pLmRhdGF9fWVsc2V7aWYoIXIpe2lmKG8pe2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgaW1hZ2UgY29uZmlnIHdpdGggZm9ybWF0IGZvciBJbWFnZWJpdG1hcFwiKTtpZih2b2lkIDAhPT10LmJpdG1hcEZvcm1hdCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgZGVmaW5lZCBmb3IgSW1hZ2VCaXRtYXBcIik7Y29uc3Qgbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKTtpZihudWxsIT1uKXtjb25zdCByPWUuaGVpZ2h0LG89ZS53aWR0aDtpZihuLmRyYXdJbWFnZShlLDAsMCxvLHIpLGE9bi5nZXRJbWFnZURhdGEoMCwwLG8scikuZGF0YSx2b2lkIDAhPT10KXtpZih2b2lkIDAhPT10LmhlaWdodCYmdC5oZWlnaHQhPT1yKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyBoZWlnaHQgZG9lc24ndCBtYXRjaCBJbWFnZUJpdG1hcCBoZWlnaHRcIik7aWYocy5oZWlnaHQ9cix2b2lkIDAhPT10LndpZHRoJiZ0LndpZHRoIT09byl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBpbnB1dCBjb25maWcgd2lkdGggZG9lc24ndCBtYXRjaCBJbWFnZUJpdG1hcCB3aWR0aFwiKTtzLndpZHRoPW99ZWxzZSBzLmhlaWdodD1yLHMud2lkdGg9bztyZXR1cm4gYy5idWZmZXJUb1RlbnNvcihhLHMpfXRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9aWYoaSlyZXR1cm4gbmV3IFByb21pc2UoKChuLHIpPT57Y29uc3Qgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLGk9by5nZXRDb250ZXh0KFwiMmRcIik7aWYoIWV8fCFpKXJldHVybiByKCk7Y29uc3QgYT1uZXcgSW1hZ2U7YS5jcm9zc09yaWdpbj1cIkFub255bW91c1wiLGEuc3JjPWUsYS5vbmxvYWQ9KCk9PntvLndpZHRoPWEud2lkdGgsby5oZWlnaHQ9YS5oZWlnaHQsaS5kcmF3SW1hZ2UoYSwwLDAsby53aWR0aCxvLmhlaWdodCk7Y29uc3QgZT1pLmdldEltYWdlRGF0YSgwLDAsby53aWR0aCxvLmhlaWdodCk7aWYodm9pZCAwIT09dCl7aWYodm9pZCAwIT09dC5oZWlnaHQmJnQuaGVpZ2h0IT09by5oZWlnaHQpdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaW5wdXQgY29uZmlnIGhlaWdodCBkb2Vzbid0IG1hdGNoIGhlaWdodFwiKTtpZihzLmhlaWdodD1vLmhlaWdodCx2b2lkIDAhPT10LndpZHRoJiZ0LndpZHRoIT09by53aWR0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBpbnB1dCBjb25maWcgd2lkdGggZG9lc24ndCBtYXRjaCB3aWR0aFwiKTtzLndpZHRoPW8ud2lkdGh9ZWxzZSBzLmhlaWdodD1vLmhlaWdodCxzLndpZHRoPW8ud2lkdGg7bihjLmJ1ZmZlclRvVGVuc29yKGUuZGF0YSxzKSl9fSkpO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfXtjb25zdCBuPVwiUkdCQVwiO2xldCByLG87aWYodm9pZCAwIT09dCYmdm9pZCAwIT09dC5yZXNpemVkV2lkdGgmJnZvaWQgMCE9PXQucmVzaXplZEhlaWdodD8ocj10LnJlc2l6ZWRIZWlnaHQsbz10LnJlc2l6ZWRXaWR0aCk6KHI9ZS5oZWlnaHQsbz1lLndpZHRoKSx2b2lkIDAhPT10KXtpZihzPXQsdm9pZCAwIT09dC5iaXRtYXBGb3JtYXQmJnQuYml0bWFwRm9ybWF0IT09bil0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgUkdCQSBmb3IgSW1hZ2VEYXRhXCIpO3MuYml0bWFwRm9ybWF0PVwiUkdCQVwifWVsc2Ugcy5iaXRtYXBGb3JtYXQ9XCJSR0JBXCI7aWYocy5oZWlnaHQ9cixzLndpZHRoPW8sdm9pZCAwIT09dCl7Y29uc3QgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO3Qud2lkdGg9byx0LmhlaWdodD1yO2NvbnN0IG49dC5nZXRDb250ZXh0KFwiMmRcIik7aWYobnVsbD09bil0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpO24ucHV0SW1hZ2VEYXRhKGUsMCwwKSxhPW4uZ2V0SW1hZ2VEYXRhKDAsMCxvLHIpLmRhdGF9ZWxzZSBhPWUuZGF0YX19aWYodm9pZCAwIT09YSlyZXR1cm4gYy5idWZmZXJUb1RlbnNvcihhLHMpO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfXRvRGF0YVVSTChlKXtjb25zdCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7dC53aWR0aD10aGlzLmRpbXNbM10sdC5oZWlnaHQ9dGhpcy5kaW1zWzJdO2NvbnN0IG49dC5nZXRDb250ZXh0KFwiMmRcIik7aWYobnVsbCE9bil7bGV0IHIsbzt2b2lkIDAhPT1lPy50ZW5zb3JMYXlvdXQmJlwiTkhXQ1wiPT09ZS50ZW5zb3JMYXlvdXQ/KHI9dGhpcy5kaW1zWzJdLG89dGhpcy5kaW1zWzNdKToocj10aGlzLmRpbXNbM10sbz10aGlzLmRpbXNbMl0pO2NvbnN0IGk9dm9pZCAwIT09ZT8uZm9ybWF0P2UuZm9ybWF0OlwiUkdCXCIsYT1lPy5ub3JtO2xldCBzLHU7dm9pZCAwPT09YXx8dm9pZCAwPT09YS5tZWFuP3M9WzI1NSwyNTUsMjU1LDI1NV06XCJudW1iZXJcIj09dHlwZW9mIGEubWVhbj9zPVthLm1lYW4sYS5tZWFuLGEubWVhbixhLm1lYW5dOihzPVthLm1lYW5bMF0sYS5tZWFuWzFdLGEubWVhblsyXSwwXSx2b2lkIDAhPT1hLm1lYW5bM10mJihzWzNdPWEubWVhblszXSkpLHZvaWQgMD09PWF8fHZvaWQgMD09PWEuYmlhcz91PVswLDAsMCwwXTpcIm51bWJlclwiPT10eXBlb2YgYS5iaWFzP3U9W2EuYmlhcyxhLmJpYXMsYS5iaWFzLGEuYmlhc106KHU9W2EuYmlhc1swXSxhLmJpYXNbMV0sYS5iaWFzWzJdLDBdLHZvaWQgMCE9PWEuYmlhc1szXSYmKHVbM109YS5iaWFzWzNdKSk7Y29uc3QgbD1vKnI7bGV0IGM9MCxwPWwsZD0yKmwsZj0tMTtcIlJHQkFcIj09PWk/KGM9MCxwPWwsZD0yKmwsZj0zKmwpOlwiUkdCXCI9PT1pPyhjPTAscD1sLGQ9MipsKTpcIlJCR1wiPT09aSYmKGM9MCxkPWwscD0yKmwpO2ZvcihsZXQgZT0wO2U8bztlKyspZm9yKGxldCB0PTA7dDxyO3QrKyl7Y29uc3Qgcj0odGhpcy5kYXRhW2MrK10tdVswXSkqc1swXSxvPSh0aGlzLmRhdGFbcCsrXS11WzFdKSpzWzFdLGk9KHRoaXMuZGF0YVtkKytdLXVbMl0pKnNbMl0sYT0tMT09PWY/MjU1Oih0aGlzLmRhdGFbZisrXS11WzNdKSpzWzNdO24uZmlsbFN0eWxlPVwicmdiYShcIityK1wiLFwiK28rXCIsXCIraStcIixcIithK1wiKVwiLG4uZmlsbFJlY3QodCxlLDEsMSl9cmV0dXJuIHQudG9EYXRhVVJMKCl9dGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX10b0ltYWdlRGF0YShlKXtjb25zdCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpO2xldCBuO2lmKG51bGw9PXQpdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKTt7bGV0IHIsbyxpO3ZvaWQgMCE9PWU/LnRlbnNvckxheW91dCYmXCJOSFdDXCI9PT1lLnRlbnNvckxheW91dD8ocj10aGlzLmRpbXNbMl0sbz10aGlzLmRpbXNbMV0saT10aGlzLmRpbXNbM10pOihyPXRoaXMuZGltc1szXSxvPXRoaXMuZGltc1syXSxpPXRoaXMuZGltc1sxXSk7Y29uc3QgYT12b2lkIDAhPT1lJiZ2b2lkIDAhPT1lLmZvcm1hdD9lLmZvcm1hdDpcIlJHQlwiLHM9ZT8ubm9ybTtsZXQgdSxsO3ZvaWQgMD09PXN8fHZvaWQgMD09PXMubWVhbj91PVsyNTUsMjU1LDI1NSwyNTVdOlwibnVtYmVyXCI9PXR5cGVvZiBzLm1lYW4/dT1bcy5tZWFuLHMubWVhbixzLm1lYW4scy5tZWFuXToodT1bcy5tZWFuWzBdLHMubWVhblsxXSxzLm1lYW5bMl0sMjU1XSx2b2lkIDAhPT1zLm1lYW5bM10mJih1WzNdPXMubWVhblszXSkpLHZvaWQgMD09PXN8fHZvaWQgMD09PXMuYmlhcz9sPVswLDAsMCwwXTpcIm51bWJlclwiPT10eXBlb2Ygcy5iaWFzP2w9W3MuYmlhcyxzLmJpYXMscy5iaWFzLHMuYmlhc106KGw9W3MuYmlhc1swXSxzLmJpYXNbMV0scy5iaWFzWzJdLDBdLHZvaWQgMCE9PXMuYmlhc1szXSYmKGxbM109cy5iaWFzWzNdKSk7Y29uc3QgYz1vKnI7aWYodm9pZCAwIT09ZSl7aWYodm9pZCAwIT09ZS5oZWlnaHQmJmUuaGVpZ2h0IT09byl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBvdXRwdXQgY29uZmlnIGhlaWdodCBkb2Vzbid0IG1hdGNoIHRlbnNvciBoZWlnaHRcIik7aWYodm9pZCAwIT09ZS53aWR0aCYmZS53aWR0aCE9PXIpdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2Ugb3V0cHV0IGNvbmZpZyB3aWR0aCBkb2Vzbid0IG1hdGNoIHRlbnNvciB3aWR0aFwiKTtpZih2b2lkIDAhPT1lLmZvcm1hdCYmND09PWkmJlwiUkdCQVwiIT09ZS5mb3JtYXR8fDM9PT1pJiZcIlJHQlwiIT09ZS5mb3JtYXQmJlwiQkdSXCIhPT1lLmZvcm1hdCl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgZm9ybWF0IGRvZXNuJ3QgbWF0Y2ggaW5wdXQgdGVuc29yIGRpbXNcIil9Y29uc3QgcD00O2xldCBkPTAsZj0xLGg9MixnPTMsbT0wLGI9Yyx5PTIqYyx3PS0xO1wiUkdCQVwiPT09YT8obT0wLGI9Yyx5PTIqYyx3PTMqYyk6XCJSR0JcIj09PWE/KG09MCxiPWMseT0yKmMpOlwiUkJHXCI9PT1hJiYobT0wLHk9YyxiPTIqYyksbj10LmNyZWF0ZUltYWdlRGF0YShyLG8pO2ZvcihsZXQgZT0wO2U8bypyO2QrPXAsZis9cCxoKz1wLGcrPXAsZSsrKW4uZGF0YVtkXT0odGhpcy5kYXRhW20rK10tbFswXSkqdVswXSxuLmRhdGFbZl09KHRoaXMuZGF0YVtiKytdLWxbMV0pKnVbMV0sbi5kYXRhW2hdPSh0aGlzLmRhdGFbeSsrXS1sWzJdKSp1WzJdLG4uZGF0YVtnXT0tMT09PXc/MjU1Oih0aGlzLmRhdGFbdysrXS1sWzNdKSp1WzNdfXJldHVybiBufXJlc2hhcGUoZSl7cmV0dXJuIG5ldyBjKHRoaXMudHlwZSx0aGlzLmRhdGEsZSl9fWNvbnN0IHA9YztjbGFzcyBke2NvbnN0cnVjdG9yKGUpe3RoaXMuaGFuZGxlcj1lfWFzeW5jIHJ1bihlLHQsbil7Y29uc3Qgcj17fTtsZXQgbz17fTtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWV8fGUgaW5zdGFuY2VvZiBwfHxBcnJheS5pc0FycmF5KGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmVlZHMnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgdXNlIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cIik7bGV0IGk9ITA7aWYoXCJvYmplY3RcIj09dHlwZW9mIHQpe2lmKG51bGw9PT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC5cIik7aWYodCBpbnN0YW5jZW9mIHApdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYSBUZW5zb3JcIik7aWYoQXJyYXkuaXNBcnJheSh0KSl7aWYoMD09PXQubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGFuIGVtcHR5IGFycmF5LlwiKTtpPSExO2Zvcihjb25zdCBlIG9mIHQpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgbXVzdCBiZSBhIHN0cmluZyBhcnJheSBvciBhbiBvYmplY3QuXCIpO2lmKC0xPT09dGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKGUpKXRocm93IG5ldyBSYW5nZUVycm9yKGAnZmV0Y2hlcycgY29udGFpbnMgaW52YWxpZCBvdXRwdXQgbmFtZTogJHtlfS5gKTtyW2VdPW51bGx9aWYoXCJvYmplY3RcIj09dHlwZW9mIG4mJm51bGwhPT1uKW89bjtlbHNlIGlmKHZvaWQgMCE9PW4pdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZXtsZXQgZT0hMTtjb25zdCBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpO2Zvcihjb25zdCBuIG9mIHRoaXMub3V0cHV0TmFtZXMpaWYoLTEhPT1hLmluZGV4T2Yobikpe2NvbnN0IG89dFtuXTsobnVsbD09PW98fG8gaW5zdGFuY2VvZiBwKSYmKGU9ITAsaT0hMSxyW25dPW8pfWlmKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBuJiZudWxsIT09bilvPW47ZWxzZSBpZih2b2lkIDAhPT1uKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2Ugbz10fX1lbHNlIGlmKHZvaWQgMCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMV06IG11c3QgYmUgJ2ZldGNoZXMnIG9yICdvcHRpb25zJy5cIik7Zm9yKGNvbnN0IHQgb2YgdGhpcy5pbnB1dE5hbWVzKWlmKHZvaWQgMD09PWVbdF0pdGhyb3cgbmV3IEVycm9yKGBpbnB1dCAnJHt0fScgaXMgbWlzc2luZyBpbiAnZmVlZHMnLmApO2lmKGkpZm9yKGNvbnN0IGUgb2YgdGhpcy5vdXRwdXROYW1lcylyW2VdPW51bGw7Y29uc3QgYT1hd2FpdCB0aGlzLmhhbmRsZXIucnVuKGUscixvKSxzPXt9O2Zvcihjb25zdCBlIGluIGEpT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoYSxlKSYmKHNbZV09bmV3IHAoYVtlXS50eXBlLGFbZV0uZGF0YSxhW2VdLmRpbXMpKTtyZXR1cm4gc31zdGF0aWMgYXN5bmMgY3JlYXRlKGUsdCxuLGkpe2xldCBhLHM9e307aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKGE9ZSxcIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXQpcz10O2Vsc2UgaWYodm9pZCAwIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KXtpZihhPWUsXCJvYmplY3RcIj09dHlwZW9mIHQmJm51bGwhPT10KXM9dDtlbHNlIGlmKHZvaWQgMCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZXtpZighKGUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcnx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyJiZlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlICdwYXRoJyBvciAnYnVmZmVyJy5cIik7e2NvbnN0IHI9ZTtsZXQgbz0wLHU9ZS5ieXRlTGVuZ3RoO2lmKFwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT09dClzPXQ7ZWxzZSBpZihcIm51bWJlclwiPT10eXBlb2YgdCl7aWYobz10LCFOdW1iZXIuaXNTYWZlSW50ZWdlcihvKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlT2Zmc2V0JyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO2lmKG88MHx8bz49ci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZU9mZnNldCcgaXMgb3V0IG9mIHJhbmdlIFswLCAke3IuYnl0ZUxlbmd0aH0pLmApO2lmKHU9ZS5ieXRlTGVuZ3RoLW8sXCJudW1iZXJcIj09dHlwZW9mIG4pe2lmKHU9biwhTnVtYmVyLmlzU2FmZUludGVnZXIodSkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtpZih1PD0wfHxvK3U+ci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZUxlbmd0aCcgaXMgb3V0IG9mIHJhbmdlICgwLCAke3IuYnl0ZUxlbmd0aC1vfV0uYCk7aWYoXCJvYmplY3RcIj09dHlwZW9mIGkmJm51bGwhPT1pKXM9aTtlbHNlIGlmKHZvaWQgMCE9PWkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZih2b2lkIDAhPT1uKXRocm93IG5ldyBUeXBlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhIG51bWJlci5cIil9ZWxzZSBpZih2b2lkIDAhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO2E9bmV3IFVpbnQ4QXJyYXkocixvLHUpfX1jb25zdCB1PShzLmV4ZWN1dGlvblByb3ZpZGVyc3x8W10pLm1hcCgoZT0+XCJzdHJpbmdcIj09dHlwZW9mIGU/ZTplLm5hbWUpKSxsPWF3YWl0KGFzeW5jIGU9Pntjb25zdCB0PTA9PT1lLmxlbmd0aD9vOmUsbj1bXTtmb3IoY29uc3QgZSBvZiB0KXtjb25zdCB0PXJbZV07aWYodCl7aWYodC5pbml0aWFsaXplZClyZXR1cm4gdC5iYWNrZW5kO2lmKHQuYWJvcnRlZCljb250aW51ZTtjb25zdCByPSEhdC5pbml0UHJvbWlzZTt0cnl7cmV0dXJuIHJ8fCh0LmluaXRQcm9taXNlPXQuYmFja2VuZC5pbml0KCkpLGF3YWl0IHQuaW5pdFByb21pc2UsdC5pbml0aWFsaXplZD0hMCx0LmJhY2tlbmR9Y2F0Y2gobyl7cnx8bi5wdXNoKHtuYW1lOmUsZXJyOm99KSx0LmFib3J0ZWQ9ITB9ZmluYWxseXtkZWxldGUgdC5pbml0UHJvbWlzZX19fXRocm93IG5ldyBFcnJvcihgbm8gYXZhaWxhYmxlIGJhY2tlbmQgZm91bmQuIEVSUjogJHtuLm1hcCgoZT0+YFske2UubmFtZX1dICR7ZS5lcnJ9YCkpLmpvaW4oXCIsIFwiKX1gKX0pKHUpLGM9YXdhaXQgbC5jcmVhdGVTZXNzaW9uSGFuZGxlcihhLHMpO3JldHVybiBuZXcgZChjKX1zdGFydFByb2ZpbGluZygpe3RoaXMuaGFuZGxlci5zdGFydFByb2ZpbGluZygpfWVuZFByb2ZpbGluZygpe3RoaXMuaGFuZGxlci5lbmRQcm9maWxpbmcoKX1nZXQgaW5wdXROYW1lcygpe3JldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lc31nZXQgb3V0cHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE5hbWVzfX1jb25zdCBmPWR9LDU3MTY6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO3QuUj12b2lkIDA7Y29uc3Qgcj1uKDYwMjcpLG89bigxNzIzKTt0LlI9bmV3IGNsYXNze2FzeW5jIGluaXQoKXt9YXN5bmMgY3JlYXRlU2Vzc2lvbkhhbmRsZXIoZSx0KXtjb25zdCBuPW5ldyByLlNlc3Npb24odCk7cmV0dXJuIGF3YWl0IG4ubG9hZE1vZGVsKGUpLG5ldyBvLk9ubnhqc1Nlc3Npb25IYW5kbGVyKG4pfX19LDI4MTg6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO3QuYzg9dC5yWD12b2lkIDA7Y29uc3Qgcj1uKDg0NTMpLG89big1MzgxKSxpPW4oOTU0NCksYT1uKDY2NDApO3Quclg9KCk9PntpZigoXCJudW1iZXJcIiE9dHlwZW9mIHIuZW52Lndhc20uaW5pdFRpbWVvdXR8fHIuZW52Lndhc20uaW5pdFRpbWVvdXQ8MCkmJihyLmVudi53YXNtLmluaXRUaW1lb3V0PTApLFwiYm9vbGVhblwiIT10eXBlb2Ygci5lbnYud2FzbS5zaW1kJiYoci5lbnYud2FzbS5zaW1kPSEwKSxcImJvb2xlYW5cIiE9dHlwZW9mIHIuZW52Lndhc20ucHJveHkmJihyLmVudi53YXNtLnByb3h5PSExKSxcIm51bWJlclwiIT10eXBlb2Ygci5lbnYud2FzbS5udW1UaHJlYWRzfHwhTnVtYmVyLmlzSW50ZWdlcihyLmVudi53YXNtLm51bVRocmVhZHMpfHxyLmVudi53YXNtLm51bVRocmVhZHM8PTApe2NvbnN0IGU9XCJ1bmRlZmluZWRcIj09dHlwZW9mIG5hdmlnYXRvcj8oMCxvLmNwdXMpKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O3IuZW52Lndhc20ubnVtVGhyZWFkcz1NYXRoLm1pbig0LE1hdGguY2VpbCgoZXx8MSkvMikpfX0sdC5jOD1uZXcgY2xhc3N7YXN5bmMgaW5pdCgpeygwLHQuclgpKCksYXdhaXQoMCxpLmluaXRXYXNtKSgpfWFzeW5jIGNyZWF0ZVNlc3Npb25IYW5kbGVyKGUsdCl7Y29uc3Qgbj1uZXcgYS5Pbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXI7cmV0dXJuIGF3YWl0IG4ubG9hZE1vZGVsKGUsdCksUHJvbWlzZS5yZXNvbHZlKG4pfX19LDEwNTc6ZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQsbixyKXt2b2lkIDA9PT1yJiYocj1uKTt2YXIgbz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbik7byYmIShcImdldFwiaW4gbz8hdC5fX2VzTW9kdWxlOm8ud3JpdGFibGV8fG8uY29uZmlndXJhYmxlKXx8KG89e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbbl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixvKX06ZnVuY3Rpb24oZSx0LG4scil7dm9pZCAwPT09ciYmKHI9biksZVtyXT10W25dfSksbz10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG4gaW4gZSlcImRlZmF1bHRcIj09PW58fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pfHxyKHQsZSxuKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbyhuKDg0NTMpLHQpO2NvbnN0IGk9big4NDUzKTt7Y29uc3QgZT1uKDU3MTYpLlI7KDAsaS5yZWdpc3RlckJhY2tlbmQpKFwid2ViZ2xcIixlLC0xMCl9e2NvbnN0IGU9bigyODE4KS5jODsoMCxpLnJlZ2lzdGVyQmFja2VuZCkoXCJjcHVcIixlLDEwKSwoMCxpLnJlZ2lzdGVyQmFja2VuZCkoXCJ3YXNtXCIsZSwxMCksKDAsaS5yZWdpc3RlckJhY2tlbmQpKFwieG5ucGFja1wiLGUsOSl9fSw0OTEwOihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXk9dm9pZCAwO2NsYXNzIG57Y29uc3RydWN0b3IoZSl7T2JqZWN0LmFzc2lnbih0aGlzLGUpfWdldCBjYWNoZUtleSgpe3JldHVybiB0aGlzLl9jYWNoZUtleXx8KHRoaXMuX2NhY2hlS2V5PU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLnNvcnQoKS5tYXAoKGU9PmAke3RoaXNbZV19YCkpLmpvaW4oXCI7XCIpKSx0aGlzLl9jYWNoZUtleX19dC5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXk9ZT0+bmV3IG4oZSl9LDY4NzQ6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuQXR0cmlidXRlPXZvaWQgMDtjb25zdCByPW4oMTQ0Niksbz1uKDEyODcpLGk9big5MjQwKSxhPW4oNzI3Myk7dmFyIHM9by5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO2NsYXNzIHV7Y29uc3RydWN0b3IoZSl7aWYodGhpcy5fYXR0cmlidXRlcz1uZXcgTWFwLG51bGwhPWUpe2Zvcihjb25zdCB0IG9mIGUpdCBpbnN0YW5jZW9mIHIub25ueC5BdHRyaWJ1dGVQcm90bz90aGlzLl9hdHRyaWJ1dGVzLnNldCh0Lm5hbWUsW3UuZ2V0VmFsdWUodCksdS5nZXRUeXBlKHQpXSk6dCBpbnN0YW5jZW9mIHMuQXR0cmlidXRlJiZ0aGlzLl9hdHRyaWJ1dGVzLnNldCh0Lm5hbWUoKSxbdS5nZXRWYWx1ZSh0KSx1LmdldFR5cGUodCldKTtpZih0aGlzLl9hdHRyaWJ1dGVzLnNpemU8ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZHVwbGljYXRlZCBhdHRyaWJ1dGUgbmFtZXNcIil9fXNldChlLHQsbil7dGhpcy5fYXR0cmlidXRlcy5zZXQoZSxbbix0XSl9ZGVsZXRlKGUpe3RoaXMuX2F0dHJpYnV0ZXMuZGVsZXRlKGUpfWdldEZsb2F0KGUsdCl7cmV0dXJuIHRoaXMuZ2V0KGUsXCJmbG9hdFwiLHQpfWdldEludChlLHQpe3JldHVybiB0aGlzLmdldChlLFwiaW50XCIsdCl9Z2V0U3RyaW5nKGUsdCl7cmV0dXJuIHRoaXMuZ2V0KGUsXCJzdHJpbmdcIix0KX1nZXRUZW5zb3IoZSx0KXtyZXR1cm4gdGhpcy5nZXQoZSxcInRlbnNvclwiLHQpfWdldEZsb2F0cyhlLHQpe3JldHVybiB0aGlzLmdldChlLFwiZmxvYXRzXCIsdCl9Z2V0SW50cyhlLHQpe3JldHVybiB0aGlzLmdldChlLFwiaW50c1wiLHQpfWdldFN0cmluZ3MoZSx0KXtyZXR1cm4gdGhpcy5nZXQoZSxcInN0cmluZ3NcIix0KX1nZXRUZW5zb3JzKGUsdCl7cmV0dXJuIHRoaXMuZ2V0KGUsXCJ0ZW5zb3JzXCIsdCl9Z2V0KGUsdCxuKXtjb25zdCByPXRoaXMuX2F0dHJpYnV0ZXMuZ2V0KGUpO2lmKHZvaWQgMD09PXIpe2lmKHZvaWQgMCE9PW4pcmV0dXJuIG47dGhyb3cgbmV3IEVycm9yKGByZXF1aXJlZCBhdHRyaWJ1dGUgbm90IGZvdW5kOiAke2V9YCl9aWYoclsxXSE9PXQpdGhyb3cgbmV3IEVycm9yKGB0eXBlIG1pc21hdGNoOiBleHBlY3RlZCAke3R9IGJ1dCBnb3QgJHtyWzFdfWApO3JldHVybiByWzBdfXN0YXRpYyBnZXRUeXBlKGUpe2NvbnN0IHQ9ZSBpbnN0YW5jZW9mIHIub25ueC5BdHRyaWJ1dGVQcm90bz9lLnR5cGU6ZS50eXBlKCk7c3dpdGNoKHQpe2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVQ6cmV0dXJuXCJmbG9hdFwiO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UOnJldHVyblwiaW50XCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkc6cmV0dXJuXCJzdHJpbmdcIjtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUjpyZXR1cm5cInRlbnNvclwiO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOnJldHVyblwiZmxvYXRzXCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlRTOnJldHVyblwiaW50c1wiO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HUzpyZXR1cm5cInN0cmluZ3NcIjtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6cmV0dXJuXCJ0ZW5zb3JzXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGF0dHJpYnV0ZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0OiAke3Iub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW3RdfWApfX1zdGF0aWMgZ2V0VmFsdWUoZSl7Y29uc3QgdD1lIGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP2UudHlwZTplLnR5cGUoKTtpZih0PT09ci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuR1JBUEh8fHQ9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSFMpdGhyb3cgbmV3IEVycm9yKFwiZ3JhcGggYXR0cmlidXRlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0XCIpO2NvbnN0IG49dGhpcy5nZXRWYWx1ZU5vQ2hlY2soZSk7aWYodD09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVCYmYS5Mb25nVXRpbC5pc0xvbmcobikpcmV0dXJuIGEuTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKG4pO2lmKHQ9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlRTKXtjb25zdCBlPW4sdD1uZXcgQXJyYXkoZS5sZW5ndGgpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtjb25zdCByPWVbbl07dFtuXT1hLkxvbmdVdGlsLmxvbmdUb051bWJlcihyKX1yZXR1cm4gdH1pZih0PT09ci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SKXJldHVybiBlIGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP2kuVGVuc29yLmZyb21Qcm90byhuKTppLlRlbnNvci5mcm9tT3J0VGVuc29yKG4pO2lmKHQ9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1JTKXtpZihlIGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvKXJldHVybiBuLm1hcCgoZT0+aS5UZW5zb3IuZnJvbVByb3RvKGUpKSk7aWYoZSBpbnN0YW5jZW9mIHMuQXR0cmlidXRlKXJldHVybiBuLm1hcCgoZT0+aS5UZW5zb3IuZnJvbU9ydFRlbnNvcihlKSkpfWlmKHQ9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkcmJmUgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8pe2NvbnN0IGU9bjtyZXR1cm4oMCxhLmRlY29kZVV0ZjhTdHJpbmcpKGUpfXJldHVybiB0PT09ci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HUyYmZSBpbnN0YW5jZW9mIHIub25ueC5BdHRyaWJ1dGVQcm90bz9uLm1hcChhLmRlY29kZVV0ZjhTdHJpbmcpOm59c3RhdGljIGdldFZhbHVlTm9DaGVjayhlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHIub25ueC5BdHRyaWJ1dGVQcm90bz90aGlzLmdldFZhbHVlTm9DaGVja0Zyb21Pbm54Rm9ybWF0KGUpOnRoaXMuZ2V0VmFsdWVOb0NoZWNrRnJvbU9ydEZvcm1hdChlKX1zdGF0aWMgZ2V0VmFsdWVOb0NoZWNrRnJvbU9ubnhGb3JtYXQoZSl7c3dpdGNoKGUudHlwZSl7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVDpyZXR1cm4gZS5mO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UOnJldHVybiBlLmk7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkc6cmV0dXJuIGUucztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUjpyZXR1cm4gZS50O2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuR1JBUEg6cmV0dXJuIGUuZztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkZMT0FUUzpyZXR1cm4gZS5mbG9hdHM7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlRTOnJldHVybiBlLmludHM7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTOnJldHVybiBlLnN0cmluZ3M7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1JTOnJldHVybiBlLnRlbnNvcnM7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSFM6cmV0dXJuIGUuZ3JhcGhzO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBhdHRyaWJ1dGUgdHlwZTogJHtyLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVtlLnR5cGVdfWApfX1zdGF0aWMgZ2V0VmFsdWVOb0NoZWNrRnJvbU9ydEZvcm1hdChlKXtzd2l0Y2goZS50eXBlKCkpe2Nhc2Ugcy5BdHRyaWJ1dGVUeXBlLkZMT0FUOnJldHVybiBlLmYoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5JTlQ6cmV0dXJuIGUuaSgpO2Nhc2Ugcy5BdHRyaWJ1dGVUeXBlLlNUUklORzpyZXR1cm4gZS5zKCk7Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuVEVOU09SOnJldHVybiBlLnQoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5HUkFQSDpyZXR1cm4gZS5nKCk7Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOnJldHVybiBlLmZsb2F0c0FycmF5KCk7Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuSU5UUzp7Y29uc3QgdD1bXTtmb3IobGV0IG49MDtuPGUuaW50c0xlbmd0aCgpO24rKyl0LnB1c2goZS5pbnRzKG4pKTtyZXR1cm4gdH1jYXNlIHMuQXR0cmlidXRlVHlwZS5TVFJJTkdTOntjb25zdCB0PVtdO2ZvcihsZXQgbj0wO248ZS5zdHJpbmdzTGVuZ3RoKCk7bisrKXQucHVzaChlLnN0cmluZ3MobikpO3JldHVybiB0fWNhc2Ugcy5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6e2NvbnN0IHQ9W107Zm9yKGxldCBuPTA7bjxlLnRlbnNvcnNMZW5ndGgoKTtuKyspdC5wdXNoKGUudGVuc29ycyhuKSk7cmV0dXJuIHR9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGF0dHJpYnV0ZSB0eXBlOiAke3MuQXR0cmlidXRlVHlwZVtlLnR5cGUoKV19YCl9fX10LkF0dHJpYnV0ZT11fSwxOTc1OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnJlc29sdmVCYWNrZW5kPXQuYmFja2VuZD12b2lkIDA7Y29uc3Qgcj1uKDQ0MTgpLG89bmV3IE1hcDthc3luYyBmdW5jdGlvbiBpKGUpe2NvbnN0IG49dC5iYWNrZW5kO2lmKHZvaWQgMCE9PW5bZV0mJmZ1bmN0aW9uKGUpe2NvbnN0IHQ9ZTtyZXR1cm5cImluaXRpYWxpemVcImluIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuaW5pdGlhbGl6ZSYmXCJjcmVhdGVTZXNzaW9uSGFuZGxlclwiaW4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC5jcmVhdGVTZXNzaW9uSGFuZGxlciYmXCJkaXNwb3NlXCJpbiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmRpc3Bvc2V9KG5bZV0pKXtjb25zdCB0PW5bZV07bGV0IHI9dC5pbml0aWFsaXplKCk7aWYoXCJvYmplY3RcIj09dHlwZW9mIHImJlwidGhlblwiaW4gciYmKHI9YXdhaXQgcikscilyZXR1cm4gby5zZXQoZSx0KSx0fX10LmJhY2tlbmQ9e3dlYmdsOm5ldyByLldlYkdMQmFja2VuZH0sdC5yZXNvbHZlQmFja2VuZD1hc3luYyBmdW5jdGlvbiBlKHQpe2lmKCF0KXJldHVybiBlKFtcIndlYmdsXCJdKTt7Y29uc3QgZT1cInN0cmluZ1wiPT10eXBlb2YgdD9bdF06dDtmb3IoY29uc3QgdCBvZiBlKXtjb25zdCBlPW8uZ2V0KHQpO2lmKGUpcmV0dXJuIGU7Y29uc3Qgbj1hd2FpdCBpKHQpO2lmKG4pcmV0dXJuIG59fXRocm93IG5ldyBFcnJvcihcIm5vIGF2YWlsYWJsZSBiYWNrZW5kIHRvIHVzZVwiKX19LDQ0MTg6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuV2ViR0xCYWNrZW5kPXZvaWQgMDtjb25zdCByPW4oODQ1Myksbz1uKDEzMTUpLGk9bigyMTcxKSxhPW4oMzM4OSk7dC5XZWJHTEJhY2tlbmQ9Y2xhc3N7Z2V0IGNvbnRleHRJZCgpe3JldHVybiByLmVudi53ZWJnbC5jb250ZXh0SWR9c2V0IGNvbnRleHRJZChlKXtyLmVudi53ZWJnbC5jb250ZXh0SWQ9ZX1nZXQgbWF0bXVsTWF4QmF0Y2hTaXplKCl7cmV0dXJuIHIuZW52LndlYmdsLm1hdG11bE1heEJhdGNoU2l6ZX1zZXQgbWF0bXVsTWF4QmF0Y2hTaXplKGUpe3IuZW52LndlYmdsLm1hdG11bE1heEJhdGNoU2l6ZT1lfWdldCB0ZXh0dXJlQ2FjaGVNb2RlKCl7cmV0dXJuIHIuZW52LndlYmdsLnRleHR1cmVDYWNoZU1vZGV9c2V0IHRleHR1cmVDYWNoZU1vZGUoZSl7ci5lbnYud2ViZ2wudGV4dHVyZUNhY2hlTW9kZT1lfWdldCBwYWNrKCl7cmV0dXJuIHIuZW52LndlYmdsLnBhY2t9c2V0IHBhY2soZSl7ci5lbnYud2ViZ2wucGFjaz1lfWdldCBhc3luYygpe3JldHVybiByLmVudi53ZWJnbC5hc3luY31zZXQgYXN5bmMoZSl7ci5lbnYud2ViZ2wuYXN5bmM9ZX1pbml0aWFsaXplKCl7dHJ5e3JldHVybiB0aGlzLmdsQ29udGV4dD0oMCxhLmNyZWF0ZVdlYkdMQ29udGV4dCkodGhpcy5jb250ZXh0SWQpLFwibnVtYmVyXCIhPXR5cGVvZiB0aGlzLm1hdG11bE1heEJhdGNoU2l6ZSYmKHRoaXMubWF0bXVsTWF4QmF0Y2hTaXplPTE2KSxcInN0cmluZ1wiIT10eXBlb2YgdGhpcy50ZXh0dXJlQ2FjaGVNb2RlJiYodGhpcy50ZXh0dXJlQ2FjaGVNb2RlPVwiZnVsbFwiKSxcImJvb2xlYW5cIiE9dHlwZW9mIHRoaXMucGFjayYmKHRoaXMucGFjaz0hMSksXCJib29sZWFuXCIhPXR5cGVvZiB0aGlzLmFzeW5jJiYodGhpcy5hc3luYz0hMSksby5Mb2dnZXIuc2V0V2l0aEVudihyLmVudiksby5Mb2dnZXIudmVyYm9zZShcIldlYkdMQmFja2VuZFwiLGBDcmVhdGVkIFdlYkdMQ29udGV4dDogJHt0eXBlb2YgdGhpcy5nbENvbnRleHR9IHdpdGggbWF0bXVsTWF4QmF0Y2hTaXplOiAke3RoaXMubWF0bXVsTWF4QmF0Y2hTaXplfTsgdGV4dHVyZUNhY2hlTW9kZTogJHt0aGlzLnRleHR1cmVDYWNoZU1vZGV9OyBwYWNrOiAke3RoaXMucGFja307IGFzeW5jOiAke3RoaXMuYXN5bmN9LmApLCEwfWNhdGNoKGUpe3JldHVybiBvLkxvZ2dlci53YXJuaW5nKFwiV2ViR0xCYWNrZW5kXCIsYFVuYWJsZSB0byBpbml0aWFsaXplIFdlYkdMQmFja2VuZC4gJHtlfWApLCExfX1jcmVhdGVTZXNzaW9uSGFuZGxlcihlKXtyZXR1cm4gbmV3IGkuV2ViR0xTZXNzaW9uSGFuZGxlcih0aGlzLGUpfWRpc3Bvc2UoKXt0aGlzLmdsQ29udGV4dC5kaXNwb3NlKCl9fX0sNjg1OTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Db29yZHNHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oNzI3Myksbz1uKDE5OTcpLGk9big2NzU3KSxhPW4oNzYxOCkscz1uKDQzMik7Y2xhc3MgdSBleHRlbmRzIG8uR2xzbExpYntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKX1nZXRGdW5jdGlvbnMoKXtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLm9mZnNldFRvQ29vcmRzKCkpLHRoaXMuY29vcmRzVG9PZmZzZXQoKSksdGhpcy50b1ZlYygpKSx0aGlzLnZhbHVlRnJvbSgpKSx0aGlzLmdldENvbW1vblV0aWxGdW5jcygpKSx0aGlzLmdldElucHV0c1NhbXBsaW5nU25pcHBldHMoKSksdGhpcy5nZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1vZmZzZXRUb0Nvb3Jkcygpe3JldHVybntvZmZzZXRUb0Nvb3JkczpuZXcgby5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIHZlYzIgb2Zmc2V0VG9Db29yZHMoaW50IG9mZnNldCwgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XFxuICAgICAgICBpbnQgdCA9IG9mZnNldCAvIHdpZHRoO1xcbiAgICAgICAgaW50IHMgPSBvZmZzZXQgLSB0KndpZHRoO1xcbiAgICAgICAgdmVjMiBjb29yZHMgPSAodmVjMihzLHQpICsgdmVjMigwLjUsMC41KSkgLyB2ZWMyKHdpZHRoLCBoZWlnaHQpO1xcbiAgICAgICAgcmV0dXJuIGNvb3JkcztcXG4gICAgICB9XFxuICAgICAgXCIpfX1jb29yZHNUb09mZnNldCgpe3JldHVybntjb29yZHNUb09mZnNldDpuZXcgby5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIGludCBjb29yZHNUb09mZnNldCh2ZWMyIGNvb3JkcywgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XFxuICAgICAgICBmbG9hdCBzID0gY29vcmRzLnMgKiBmbG9hdCh3aWR0aCk7XFxuICAgICAgICBmbG9hdCB0ID0gY29vcmRzLnQgKiBmbG9hdChoZWlnaHQpO1xcbiAgICAgICAgaW50IG9mZnNldCA9IGludCh0KSAqIHdpZHRoICsgaW50KHMpO1xcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcXG4gICAgICB9XFxuICAgICAgXCIpfX1nZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoKXtjb25zdCBlPXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O3JldHVybiBlLmlzUGFja2VkP3RoaXMuZ2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KGUpOnRoaXMuZ2V0VW5wYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoZSl9Z2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KGUpe2NvbnN0IHQ9ZS51bnBhY2tlZFNoYXBlLG49W2Uud2lkdGgsZS5oZWlnaHRdLHI9e30sYT1cImdldE91dHB1dENvb3Jkc1wiO3N3aXRjaCh0Lmxlbmd0aCl7Y2FzZSAwOnJbYV09dGhpcy5nZXRPdXRwdXRTY2FsYXJDb29yZHMoKTticmVhaztjYXNlIDE6clthXT10aGlzLmdldE91dHB1dFBhY2tlZDFEQ29vcmRzKHQsbik7YnJlYWs7Y2FzZSAyOnJbYV09dGhpcy5nZXRPdXRwdXRQYWNrZWQyRENvb3Jkcyh0LG4pO2JyZWFrO2Nhc2UgMzpyW2FdPXRoaXMuZ2V0T3V0cHV0UGFja2VkM0RDb29yZHModCxuKTticmVhaztkZWZhdWx0OnJbYV09dGhpcy5nZXRPdXRwdXRQYWNrZWRORENvb3Jkcyh0LG4pfWNvbnN0IHM9YFxcbiAgICAgIHZvaWQgc2V0T3V0cHV0KHZlYzQgdmFsKSB7XFxuICAgICAgICAkeygwLGkuZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKS5vdXRwdXR9ID0gdmFsO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gci5mbG9hdFRleHR1cmVTZXRSR0JBPW5ldyBvLkdsc2xMaWJSb3V0aW5lKHMpLHJ9Z2V0VW5wYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoZSl7Y29uc3QgdD1lLnVucGFja2VkU2hhcGUsbj1bZS53aWR0aCxlLmhlaWdodF0scj17fSxhPVwiZ2V0T3V0cHV0Q29vcmRzXCI7c3dpdGNoKHQubGVuZ3RoKXtjYXNlIDA6clthXT10aGlzLmdldE91dHB1dFNjYWxhckNvb3JkcygpO2JyZWFrO2Nhc2UgMTpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQxRENvb3Jkcyh0LG4pO2JyZWFrO2Nhc2UgMjpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQyRENvb3Jkcyh0LG4pO2JyZWFrO2Nhc2UgMzpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQzRENvb3Jkcyh0LG4pO2JyZWFrO2Nhc2UgNDpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ0RENvb3Jkcyh0LG4pO2JyZWFrO2Nhc2UgNTpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ1RENvb3Jkcyh0LG4pO2JyZWFrO2Nhc2UgNjpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ2RENvb3Jkcyh0LG4pO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvdXRwdXQgZGltZW5zaW9uYWxpdHk6ICR7dC5sZW5ndGh9YCl9Y29uc3Qgcz1gXFxuICAgICAgICB2b2lkIHNldE91dHB1dChmbG9hdCB2YWwpIHtcXG4gICAgICAgICAgJHsoMCxpLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikub3V0cHV0fSA9IHZlYzQodmFsLCAwLCAwLCAwKTtcXG4gICAgICAgIH1cXG4gICAgYDtyZXR1cm4gci5mbG9hdFRleHR1cmVTZXRSPW5ldyBvLkdsc2xMaWJSb3V0aW5lKHMpLHJ9Z2V0T3V0cHV0U2NhbGFyQ29vcmRzKCl7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiAwO1xcbiAgICAgIH1cXG4gICAgXCIpfWdldE91dHB1dFBhY2tlZDFEQ29vcmRzKGUsdCl7Y29uc3Qgbj10O2xldCByPVwiXCI7cmV0dXJuIDE9PT1uWzBdPyhyPWBcXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgICByZXR1cm4gMiAqIGludChUZXhDb29yZHMueSAqICR7blsxXX0uMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGAsbmV3IG8uR2xzbExpYlJvdXRpbmUocikpOjE9PT1uWzFdPyhyPWBcXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgICByZXR1cm4gMiAqIGludChUZXhDb29yZHMueCAqICR7blswXX0uMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGAsbmV3IG8uR2xzbExpYlJvdXRpbmUocikpOihyPWBcXG4gICAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7blswXX0sICR7blsxXX0pKTtcXG4gICAgICAgICAgcmV0dXJuIDIgKiAocmVzVGV4UkMueSAqICR7blswXX0gKyByZXNUZXhSQy54KTtcXG4gICAgICAgIH1cXG4gICAgICBgLG5ldyBvLkdsc2xMaWJSb3V0aW5lKHIpKX1nZXRPdXRwdXRQYWNrZWQyRENvb3JkcyhlLHQpe2xldCBuPVwiXCI7aWYoci5BcnJheVV0aWwuYXJyYXlzRXF1YWwoZSx0KSlyZXR1cm4gbj1gXFxuICAgICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIHJldHVybiAyICogaXZlYzIoVGV4Q29vcmRzLnh5ICogdmVjMigke3RbMF19LCAke3RbMV19KSk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgby5HbHNsTGliUm91dGluZShuKTtjb25zdCBpPXQsYT1NYXRoLmNlaWwoZVsxXS8yKTtyZXR1cm4gbj1gXFxuICAgICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtpWzBdfSwgJHtpWzFdfSkpO1xcblxcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtpWzBdfSArIHJlc1RleFJDLng7XFxuXFxuICAgICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcXG4gICAgICAgICAgaW50IHIgPSBpbW9kKGluZGV4LCAke2F9KSAqIDI7XFxuICAgICAgICAgIGludCBjID0gMiAqIChpbmRleCAvICR7YX0pO1xcblxcbiAgICAgICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgby5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRQYWNrZWQzRENvb3JkcyhlLHQpe2NvbnN0IG49W3RbMF0sdFsxXV0scj1NYXRoLmNlaWwoZVsyXS8yKSxpPXIqTWF0aC5jZWlsKGVbMV0vMiksYT1gXFxuICAgICAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtuWzBdfSwgJHtuWzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtuWzBdfSArIHJlc1RleFJDLng7XFxuXFxuICAgICAgICAgIGludCBiID0gaW5kZXggLyAke2l9O1xcbiAgICAgICAgICBpbmRleCAtPSBiICogJHtpfTtcXG5cXG4gICAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxcbiAgICAgICAgICBpbnQgciA9IGltb2QoaW5kZXgsICR7cn0pICogMjtcXG4gICAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHtyfSk7XFxuXFxuICAgICAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShhKX1nZXRPdXRwdXRQYWNrZWRORENvb3JkcyhlLHQpe2NvbnN0IG49W3RbMF0sdFsxXV0scj1NYXRoLmNlaWwoZVtlLmxlbmd0aC0xXS8yKSxpPXIqTWF0aC5jZWlsKGVbZS5sZW5ndGgtMl0vMik7bGV0IGE9aSxzPVwiXCIsdT1cImIsIHIsIGNcIjtmb3IobGV0IHQ9Mjt0PGUubGVuZ3RoLTE7dCsrKWEqPWVbZS5sZW5ndGgtdC0xXSxzPWBcXG4gICAgICBpbnQgYiR7dH0gPSBpbmRleCAvICR7YX07XFxuICAgICAgaW5kZXggLT0gYiR7dH0gKiAke2F9O1xcbiAgICBgK3MsdT1gYiR7dH0sIGArdTtjb25zdCBsPWBcXG4gICAgICBpdmVjJHtlLmxlbmd0aH0gZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtuWzBdfSwgJHtuWzFdfSkpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7blswXX0gKyByZXNUZXhSQy54O1xcblxcbiAgICAgICAgJHtzfVxcblxcbiAgICAgICAgaW50IGIgPSBpbmRleCAvICR7aX07XFxuICAgICAgICBpbmRleCAtPSBiICogJHtpfTtcXG5cXG4gICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcXG4gICAgICAgIGludCByID0gaW1vZChpbmRleCwgJHtyfSkgKiAyO1xcbiAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHtyfSk7XFxuXFxuICAgICAgICByZXR1cm4gaXZlYyR7ZS5sZW5ndGh9KCR7dX0pO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUobCl9Z2V0T3V0cHV0VW5wYWNrZWQxRENvb3JkcyhlLHQpe2NvbnN0IG49YFxcbiAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RbMF19LCAke3RbMV19KSk7XFxuICAgICAgICAgIHJldHVybiByZXNUZXhSQy55ICogJHt0WzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUobil9Z2V0T3V0cHV0VW5wYWNrZWQyRENvb3JkcyhlLHQpe2NvbnN0IG49YFxcbiAgICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7dFswXX0sICR7dFsxXX0pKTtcXG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dFswXX0gKyByZXNUZXhSQy54O1xcbiAgICAgICAgICBpbnQgciA9IGluZGV4IC8gJHtlWzFdfTtcXG4gICAgICAgICAgaW50IGMgPSBpbmRleCAtIHIgKiAke2VbMV19O1xcbiAgICAgICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUobil9Z2V0T3V0cHV0VW5wYWNrZWQzRENvb3JkcyhlLHQpe2xldCBuPVwiXCI7Y29uc3Qgcj1lLmxlbmd0aDtsZXQgaT1udWxsO3I8MiYmKGk9W10pLGk9bmV3IEFycmF5KHItMSksaVtyLTJdPWVbci0xXTtmb3IobGV0IHQ9ci0zO3Q+PTA7LS10KWlbdF09aVt0KzFdKmVbdCsxXTtjb25zdCBhPVtcInJcIixcImNcIixcImRcIl0scz1pLm1hcCgoKGUsdCk9PmBpbnQgJHthW3RdfSA9IGluZGV4IC8gJHtlfTsgJHt0PT09aS5sZW5ndGgtMT9gaW50ICR7YVt0KzFdfSA9IGluZGV4IC0gJHthW3RdfSAqICR7ZX1gOmBpbmRleCAtPSAke2FbdF19ICogJHtlfWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RbMF19LCAke3RbMV19KSk7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke3RbMF19ICsgcmVzVGV4UkMueDtcXG4gICAgICAgICAgJHtzfVxcbiAgICAgICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgby5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRVbnBhY2tlZDREQ29vcmRzKGUsdCl7bGV0IG49XCJcIjtjb25zdCByPWUubGVuZ3RoO2xldCBpPW51bGw7cjwyJiYoaT1bXSksaT1uZXcgQXJyYXkoci0xKSxpW3ItMl09ZVtyLTFdO2ZvcihsZXQgdD1yLTM7dD49MDstLXQpaVt0XT1pW3QrMV0qZVt0KzFdO2NvbnN0IGE9W1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIl0scz1pLm1hcCgoKGUsdCk9PmBpbnQgJHthW3RdfSA9IGluZGV4IC8gJHtlfTsgJHt0PT09aS5sZW5ndGgtMT9gaW50ICR7YVt0KzFdfSA9IGluZGV4IC0gJHthW3RdfSAqICR7ZX1gOmBpbmRleCAtPSAke2FbdF19ICogJHtlfWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICBpdmVjNCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0WzBdfSwgJHt0WzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHt0WzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICAgICR7c31cXG4gICAgICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcXG4gICAgICAgIH1cXG4gICAgICBgLG5ldyBvLkdsc2xMaWJSb3V0aW5lKG4pfWdldE91dHB1dFVucGFja2VkNURDb29yZHMoZSx0KXtsZXQgbj1cIlwiO2NvbnN0IHI9ZS5sZW5ndGg7bGV0IGk9bnVsbDtyPDImJihpPVtdKSxpPW5ldyBBcnJheShyLTEpLGlbci0yXT1lW3ItMV07Zm9yKGxldCB0PXItMzt0Pj0wOy0tdClpW3RdPWlbdCsxXSplW3QrMV07Y29uc3QgYT1bXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiLFwiZDNcIl0scz1pLm1hcCgoKGUsdCk9PmBpbnQgJHthW3RdfSA9IGluZGV4IC8gJHtlfTsgJHt0PT09aS5sZW5ndGgtMT9gaW50ICR7YVt0KzFdfSA9IGluZGV4IC0gJHthW3RdfSAqICR7ZX1gOmBpbmRleCAtPSAke2FbdF19ICogJHtlfWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICBpdmVjNSBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0WzBdfSwgJHt0WzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHt0WzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICAgICR7c31cXG4gICAgICAgICAgcmV0dXJuIGl2ZWM1KHIsIGMsIGQsIGQyLCBkMyk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgby5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRVbnBhY2tlZDZEQ29vcmRzKGUsdCl7bGV0IG49XCJcIjtjb25zdCByPWUubGVuZ3RoO2xldCBpPW51bGw7cjwyJiYoaT1bXSksaT1uZXcgQXJyYXkoci0xKSxpW3ItMl09ZVtyLTFdO2ZvcihsZXQgdD1yLTM7dD49MDstLXQpaVt0XT1pW3QrMV0qZVt0KzFdO2NvbnN0IGE9W1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIixcImQzXCIsXCJkNFwiXSxzPWkubWFwKCgoZSx0KT0+YGludCAke2FbdF19ID0gaW5kZXggLyAke2V9OyAke3Q9PT1pLmxlbmd0aC0xP2BpbnQgJHthW3QrMV19ID0gaW5kZXggLSAke2FbdF19ICogJHtlfWA6YGluZGV4IC09ICR7YVt0XX0gKiAke2V9YH07YCkpLmpvaW4oXCJcIik7cmV0dXJuIG49YFxcbiAgICAgaXZlYzYgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RbMF19LCAke3RbMV19KSk7XFxuICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dFswXX0gKyByZXNUZXhSQy54O1xcbiAgICAgICAgICR7c31cXG4gICAgICAgICByZXR1cm4gaXZlYzYociwgYywgZCwgZDIsIGQzLCBkNCk7XFxuICAgICAgIH1cXG4gICAgIGAsbmV3IG8uR2xzbExpYlJvdXRpbmUobil9Z2V0Q29tbW9uVXRpbEZ1bmNzKCl7Y29uc3QgZT17fTtsZXQgdD1cInV2RnJvbUZsYXRcIjtlW3RdPW5ldyBvLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgIHZlYzIgdXZGcm9tRmxhdChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLyB0ZXhOdW1SO1xcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLSB0ZXhDICogdGV4TnVtUjtcXG4gICAgICAvLyBUT0RPOiBzd2FwIHRleFIsIHRleEMgb3JkZXIgaW4gZm9sbG93aW5nIGZ1bmN0aW9uIHNvIHJvdyBpcyBjb3JyZXNwb25kaW5nIHRvIHUgYW5kIGNvbHVtbiBpcyBjb3JyZXNwb25kaW5nIHRvXFxuICAgICAgLy8gICAgICAgdi5cXG4gICAgICByZXR1cm4gKHZlYzIodGV4UiwgdGV4QykgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1SLCB0ZXhOdW1DKTtcXG4gICAgfVxcbiAgICBcIiksdD1cInBhY2tlZFVWZnJvbTFEXCIsZVt0XT1uZXcgby5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIHZlYzIgcGFja2VkVVZmcm9tMUQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcXG4gICAgICAgIGludCB0ZXhlbEluZGV4ID0gaW5kZXggLyAyO1xcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxuICAgICAgfVxcbiAgICAgIFwiKSx0PVwicGFja2VkVVZmcm9tMkRcIixlW3RdPW5ldyBvLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20yRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIGludCB0ZXhlbEluZGV4ID0gKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxuICAgICAgfVxcbiAgICAgIFwiKSx0PVwicGFja2VkVVZmcm9tM0RcIixlW3RdPW5ldyBvLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20zRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsXFxuICAgICAgICAgIGludCB0ZXhlbHNJbkJhdGNoLCBpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgYixcXG4gICAgICAgICAgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgaW50IGluZGV4ID0gYiAqIHRleGVsc0luQmF0Y2ggKyAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XFxuICAgICAgICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gICAgICAgIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbiAgICAgIH1cXG4gICAgICBcIiksdD1cInNhbXBsZVRleHR1cmVcIjtjb25zdCBuPSgwLGkuZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtyZXR1cm4gZVt0XT1uZXcgby5HbHNsTGliUm91dGluZShgXFxuICAgICAgICBmbG9hdCBzYW1wbGVUZXh0dXJlKHNhbXBsZXIyRCB0ZXh0dXJlU2FtcGxlciwgdmVjMiB1dikge1xcbiAgICAgICAgICAgIHJldHVybiAke24udGV4dHVyZTJEfSh0ZXh0dXJlU2FtcGxlciwgdXYpLnI7XFxuICAgICAgICB9YCksZX1nZXRJbnB1dHNTYW1wbGluZ1NuaXBwZXRzKCl7Y29uc3QgZT17fSx0PXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgobixyKT0+e2NvbnN0IG89dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbcl0saT0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSkobik7by5pc1BhY2tlZD9lW2ldPXRoaXMuZ2V0UGFja2VkU2FtcGxlckZyb21JbnB1dChpLG4sbyk6ZVtpXT10aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChpLG4sbyk7Y29uc3QgYT0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZUF0T3V0Q29vcmRzKShuKTtvLnVucGFja2VkU2hhcGUubGVuZ3RoPD10LnVucGFja2VkU2hhcGUubGVuZ3RoJiYoby5pc1BhY2tlZD9lW2FdPXRoaXMuZ2V0UGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKGEsbyx0LG4pOmVbYV09dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhhLG8sdCxuKSl9KSksZX1nZXRQYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHMoZSx0LG4saSl7Y29uc3QgYT10LnVucGFja2VkU2hhcGUsdT1uLnVucGFja2VkU2hhcGUsbD1pLGM9KDAscy5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWUpKGwpLHA9YS5sZW5ndGgsZD11Lmxlbmd0aCxmPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGEsdSksaD0oMCxzLmdldENvb3Jkc0RhdGFUeXBlKShkKSxnPWQtcDtsZXQgbTtjb25zdCBiPSgwLHMuZ2V0R2xDaGFubmVscykoKTttPTA9PT1wP1wiXCI6ZDwyJiZmLmxlbmd0aD49MT9cImNvb3JkcyA9IDA7XCI6Zi5tYXAoKGU9PmBjb29yZHMuJHtiW2UrZ119ID0gMDtgKSkuam9pbihcIlxcblwiKTtsZXQgeT1cIlwiO3k9ZDwyJiZwPjA/XCJjb29yZHNcIjphLm1hcCgoKGUsdCk9PmBjb29yZHMuJHtiW3QrZ119YCkpLmpvaW4oXCIsIFwiKTtsZXQgdz1cInJldHVybiBvdXRwdXRWYWx1ZTtcIjtjb25zdCBfPTE9PT1yLlNoYXBlVXRpbC5zaXplKGEpLHY9MT09PXIuU2hhcGVVdGlsLnNpemUodSk7aWYoMSE9PXB8fF98fHYpe2lmKF8mJiF2KXc9MT09PWQ/XCJcXG4gICAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueCwgMC4sIDAuKTtcXG4gICAgICAgIFwiOlwiXFxuICAgICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1xcbiAgICAgICAgXCI7ZWxzZSBpZihmLmxlbmd0aCl7Y29uc3QgZT1wLTIsdD1wLTE7Zi5pbmRleE9mKGUpPi0xJiZmLmluZGV4T2YodCk+LTE/dz1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1wiOmYuaW5kZXhPZihlKT4tMT93PVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSwgb3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSk7XCI6Zi5pbmRleE9mKHQpPi0xJiYodz1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh4LCBvdXRwdXRWYWx1ZS56eik7XCIpfX1lbHNlIHc9XCJcXG4gICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh5LCBvdXRwdXRWYWx1ZS54eSk7XFxuICAgICAgXCI7Y29uc3QgeD1gXFxuICAgICAgdmVjNCAke2V9KCkge1xcbiAgICAgICAgJHtofSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIFxcbiAgICAgICAgaW50IGxhc3REaW0gPSBjb29yZHMuJHtiW2QtMV19O1xcbiAgICAgICAgY29vcmRzLiR7YltkLTFdfSA9IGNvb3Jkcy4ke2JbZC0yXX07XFxuICAgICAgICBjb29yZHMuJHtiW2QtMl19ID0gbGFzdERpbTtcXG4gICAgICBcXG4gICAgICAgICR7bX1cXG4gICAgICAgIHZlYzQgb3V0cHV0VmFsdWUgPSAke2N9KCR7eX0pO1xcbiAgICAgICAgJHt3fVxcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUoeCxbXCJjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHNcIl0pfWdldFVucGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKGUsdCxuLGkpe2NvbnN0IGE9W24ud2lkdGgsbi5oZWlnaHRdLHU9W3Qud2lkdGgsdC5oZWlnaHRdLGw9dC51bnBhY2tlZFNoYXBlLmxlbmd0aCxjPW4udW5wYWNrZWRTaGFwZS5sZW5ndGgscD10LnVucGFja2VkU2hhcGUsZD1uLnVucGFja2VkU2hhcGUsZj0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSkoaSk7aWYobD09PWMmJnIuQXJyYXlVdGlsLmFycmF5c0VxdWFsKHUsYSkpe2NvbnN0IHQ9YFxcbiAgICAgICAgICBmbG9hdCAke2V9KCkge1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7aX0sIFRleENvb3Jkcyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKHQsW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Y29uc3QgaD0oMCxzLmdldENvb3Jkc0RhdGFUeXBlKShjKSxnPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKHAsZCksbT1jLWw7bGV0IGI7Y29uc3QgeT0oMCxzLmdldEdsQ2hhbm5lbHMpKCk7Yj0wPT09bD9cIlwiOmM8MiYmZy5sZW5ndGg+PTE/XCJjb29yZHMgPSAwO1wiOmcubWFwKChlPT5gY29vcmRzLiR7eVtlK21dfSA9IDA7YCkpLmpvaW4oXCJcXG5cIik7bGV0IHc9XCJcIjt3PWM8MiYmbD4wP1wiY29vcmRzXCI6dC51bnBhY2tlZFNoYXBlLm1hcCgoKGUsdCk9PmBjb29yZHMuJHt5W3QrbV19YCkpLmpvaW4oXCIsIFwiKTtjb25zdCBfPWBcXG4gICAgICAgIGZsb2F0ICR7ZX0oKSB7XFxuICAgICAgICAgICR7aH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgICR7Yn1cXG4gICAgICAgICAgcmV0dXJuICR7Zn0oJHt3fSk7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUoXyxbXCJjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHNcIl0pfWdldFBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZSx0LG4pe3N3aXRjaChuLnVucGFja2VkU2hhcGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlclNjYWxhcihlLHQpO2Nhc2UgMTpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyMUQoZSx0LG4pO2Nhc2UgMjpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyMkQoZSx0LG4pO2Nhc2UgMzpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyM0QoZSx0LG4pO2RlZmF1bHQ6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlck5EKGUsdCxuKX19Z2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGUsdCxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZTtzd2l0Y2goci5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIoZSx0LG4pO2Nhc2UgMTpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIxRChlLHQsbik7Y2FzZSAyOnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjJEKGUsdCxuKTtjYXNlIDM6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyM0QoZSx0LG4pO2Nhc2UgNDpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI0RChlLHQsbik7Y2FzZSA1OnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjVEKGUsdCxuKTtjYXNlIDY6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyNkQoZSx0LG4pO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkaW1lbnNpb24gJHtyLmxlbmd0aH0tRGApfX1nZXRQYWNrZWRTYW1wbGVyU2NhbGFyKGUsdCl7Y29uc3Qgbj1gXFxuICAgICAgICAgIHZlYzQgJHtlfSgpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHsoMCxpLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfSgke3R9LCBoYWxmQ1IpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShuKX1nZXRQYWNrZWRTYW1wbGVyMUQoZSx0LG4pe2NvbnN0IHI9W24ud2lkdGgsbi5oZWlnaHRdLGE9W3JbMV0sclswXV0scz0oMCxpLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbiksdT1gdmVjNCAke2V9KGludCBpbmRleCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20xRChcXG4gICAgICAke2FbMF19LCAke2FbMV19LCBpbmRleCk7XFxuICAgICAgcmV0dXJuICR7cy50ZXh0dXJlMkR9KCR7dH0sIHV2KTtcXG4gICAgfWA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKHUsW1wiY29vcmRpbmF0ZXMucGFja2VkVVZmcm9tMURcIl0pfWdldFBhY2tlZFNhbXBsZXIyRChlLHQsbil7Y29uc3QgYT1uLnVucGFja2VkU2hhcGUscz1bbi53aWR0aCxuLmhlaWdodF0sdT0oMCxpLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbiksbD1zWzBdLGM9c1sxXTtpZihudWxsIT1zJiZyLkFycmF5VXRpbC5hcnJheXNFcXVhbChhLHMpKXtjb25zdCBuPWB2ZWM0ICR7ZX0oaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKCR7Y30uMCwgJHtsfS4wKTtcXG4gICAgICAgIHJldHVybiAke3UudGV4dHVyZTJEfSgke3R9LCB1dik7XFxuICAgICAgfWA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKG4pfWNvbnN0IHA9cyxkPU1hdGguY2VpbChhWzFdLzIpLGY9YHZlYzQgJHtlfShpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTJEKCR7cFsxXX0sICR7cFswXX0sICR7ZH0sIHJvdywgY29sKTtcXG4gICAgICByZXR1cm4gJHt1LnRleHR1cmUyRH0oJHt0fSwgdXYpO1xcbiAgICB9YDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUoZixbXCJjb29yZGluYXRlcy5wYWNrZWRVVmZyb20yRFwiXSl9Z2V0UGFja2VkU2FtcGxlcjNEKGUsdCxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZSxhPVtuLndpZHRoLG4uaGVpZ2h0XSx1PVthWzBdLGFbMV1dLGw9KDAsaS5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO2lmKDE9PT1yWzBdKXtjb25zdCBpPXIuc2xpY2UoMSksYT1bMSwyXSx1PSgwLHMuc3F1ZWV6ZUlucHV0U2hhcGUpKHIsaSksbD1bXCJiXCIsXCJyb3dcIixcImNvbFwiXSxjPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO2MudW5wYWNrZWRTaGFwZT11O2NvbnN0IHA9dGhpcy5nZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KGUsdCxjKSxkPWAke3Aucm91dGluZUJvZHl9XFxuICAgICAgdmVjNCAke2V9KGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICByZXR1cm4gJHtlfSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKGwsYSl9KTtcXG4gICAgICB9IGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKGQscC5kZXBlbmRlbmNpZXMpfWNvbnN0IGM9dVswXSxwPXVbMV0sZD1NYXRoLmNlaWwoclsyXS8yKSxmPWB2ZWM0ICR7ZX0oaW50IGIsIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tM0QoXFxuICAgICAgICAke3B9LCAke2N9LCAke2QqTWF0aC5jZWlsKHJbMV0vMil9LCAke2R9LCBiLCByb3csIGNvbCk7XFxuICAgICAgcmV0dXJuICR7bC50ZXh0dXJlMkR9KCR7dH0sIHV2KTt9YDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUoZixbXCJjb29yZGluYXRlcy5wYWNrZWRVVmZyb20zRFwiXSl9Z2V0UGFja2VkU2FtcGxlck5EKGUsdCxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZSxhPXIubGVuZ3RoLHM9W24ud2lkdGgsbi5oZWlnaHRdLHU9KDAsaS5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pLGw9W3NbMF0sc1sxXV0sYz1sWzFdLHA9bFswXSxkPU1hdGguY2VpbChyW2EtMV0vMik7bGV0IGY9ZCpNYXRoLmNlaWwoclthLTJdLzIpLGg9XCJpbnQgYiwgaW50IHJvdywgaW50IGNvbFwiLGc9YGIgKiAke2Z9ICsgKHJvdyAvIDIpICogJHtkfSArIChjb2wgLyAyKWA7Zm9yKGxldCBlPTI7ZTxhLTE7ZSsrKWg9YGludCBiJHtlfSwgYCtoLGYqPXJbYS1lLTFdLGc9YGIke2V9ICogJHtmfSArIGArZztjb25zdCBtPWB2ZWM0ICR7ZX0oJHtofSkge1xcbiAgICAgIGludCBpbmRleCA9ICR7Z307XFxuICAgICAgaW50IHRleFIgPSBpbmRleCAvICR7cH07XFxuICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiAke3B9O1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKCR7cH0sICR7Y30pO1xcbiAgICAgIHJldHVybiAke3UudGV4dHVyZTJEfSgke3R9LCB1dik7XFxuICAgIH1gO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShtKX1nZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIoZSx0LG4pe2NvbnN0W3IsaV09W24ud2lkdGgsbi5oZWlnaHRdO2lmKDE9PT1yJiYxPT09aSl7Y29uc3Qgbj1gXFxuICAgICAgICAgIGZsb2F0ICR7ZX0oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHt0fSwgaGFsZkNSKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBhPWBcXG4gICAgICAgIGZsb2F0ICR7ZX0oKSB7XFxuICAgICAgICAgIGludCBvZmZzZXRfJHt0fSA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtyfSwgJHtpfSk7XFxuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7cn0sICR7aX0sIG9mZnNldF8ke3R9KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHt0fSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKGEsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXRcIl0pfWdldFVucGFja2VkU2FtcGxlcjFEKGUsdCxuKXtjb25zdCByPW4ud2lkdGgsaT1uLmhlaWdodDtpZigxPT09aSYmMT09PXIpe2NvbnN0IG49YFxcbiAgICAgICAgZmxvYXQgJHtlfShpbnQgaW5kZXgpIHtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHt0fSwgaGFsZkNSKTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShuLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWlmKDE9PT1pKXtjb25zdCBuPWBcXG4gICAgICAgICAgZmxvYXQgJHtlfShpbnQgaW5kZXgpIHtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXgpICsgMC41KSAvICR7cn0uMCwgMC41KTtcXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke3R9LCB1dik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKG4sW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9aWYoMT09PXIpe2NvbnN0IG49YFxcbiAgICAgICAgICBmbG9hdCAke2V9KGludCBpbmRleCkge1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4KSArIDAuNSkgLyAke2l9LjApO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7dH0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBhPWBcXG4gICAgICAgIGZsb2F0ICR7ZX0oaW50IGluZGV4KSB7XFxuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7cn0sICR7aX0sIGluZGV4KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHt0fSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKGEsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyMkQoZSx0LG4pe2NvbnN0IGk9bi51bnBhY2tlZFNoYXBlLHU9W24uaGVpZ2h0LG4ud2lkdGhdO2lmKG51bGwhPXUmJnIuQXJyYXlVdGlsLmFycmF5c0VxdWFsKGksdSkpe2NvbnN0IG49YFxcbiAgICAgICAgICBmbG9hdCAke2V9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIocm93LCBjb2wpICsgaGFsZkNSKSAvIHZlYzIoJHt1WzFdfS4wLCAke3VbMF19LjApO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7dH0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdHtuZXdTaGFwZTpsLGtlcHREaW1zOmN9PSgwLGEuc3F1ZWV6ZVNoYXBlKShpKSxwPWw7aWYocC5sZW5ndGg8aS5sZW5ndGgpe2NvbnN0IHI9KDAscy5zcXVlZXplSW5wdXRTaGFwZSkoaSxwKSxhPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO2EudW5wYWNrZWRTaGFwZT1yO2NvbnN0IHU9W1wiY29sXCIsXCJyb3dcIl0sbD1gXFxuICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZSx0LGEpLnJvdXRpbmVCb2R5fVxcbiAgICAgICAgICBmbG9hdCAke2V9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHtlfSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKHUsYyl9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUobCxbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBkPXVbMV0sZj11WzBdO2lmKDE9PT1mKXtjb25zdCBuPWBcXG4gICAgICAgICAgZmxvYXQgJHtlfShpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgICAgaW50IG9mZnNldF8ke3R9ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke2R9LCAke2Z9KTtcXG4gICAgICAgICAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMzKHJvdywgY29sLCBvZmZzZXRfJHt0fSksIHZlYzMoJHtpWzFdfSwgMSwgMSkpO1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGluZGV4ICsgMC41KSAvICR7ZH0uMCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHt0fSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShuLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX1pZigxPT09ZCl7Y29uc3Qgbj1gXFxuICAgICAgICAgIGZsb2F0ICR7ZX0oaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICAgIGludCBvZmZzZXRfJHt0fSA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtkfSwgJHtmfSk7XFxuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7dH0pLCB2ZWMzKCR7aVsxXX0sIDEsIDEpKTtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoaW5kZXggKyAwLjUpIC8gJHtmfS4wLCAwLjUpO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7dH0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Y29uc3QgaD1gXFxuICAgICAgICBmbG9hdCAke2V9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgaW50IGluZGV4ID0gY29sICogJHtpWzFdfSArIHJvdztcXG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtkfSwgJHtmfSwgaW5kZXgpO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke3R9LCB1dik7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUoaCxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyM0QoZSx0LG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLGk9clsxXSpyWzJdLHU9clsyXSx7bmV3U2hhcGU6bCxrZXB0RGltczpjfT0oMCxhLnNxdWVlemVTaGFwZSkocikscD1sO2lmKHAubGVuZ3RoPHIubGVuZ3RoKXtjb25zdCBpPSgwLHMuc3F1ZWV6ZUlucHV0U2hhcGUpKHIscCksYT1bXCJiYXRjaFwiLFwiY29sXCIsXCJyb3dcIl0sdT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG4pKTt1LnVucGFja2VkU2hhcGU9aTtjb25zdCBsPXRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGUsdCx1KSxkPWMucmV2ZXJzZSgpLGY9YFxcbiAgICAgICAgICAke2wucm91dGluZUJvZHl9XFxuICAgICAgICAgIGZsb2F0ICR7ZX0oaW50IGJhdGNoLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgICAgcmV0dXJuICR7ZX0oJHsoMCxzLmdldFNxdWVlemVkUGFyYW1zKShhLGQpfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKGYsbC5kZXBlbmRlbmNpZXMpfWNvbnN0IGQ9YFxcbiAgICAgICAgICBmbG9hdCAke2V9KGludCBkZXB0aCwgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgICAgICAgICBpbnQgaW5kZXggPSBkZXB0aCAqICR7aX0gKyBjb2wgKiAke3V9ICsgcm93O1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7bi53aWR0aH0sICR7bi5oZWlnaHR9LCBpbmRleCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHt0fSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUoZCxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyNEQoZSx0LG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLGk9clszXSxhPXJbMl0qaSxzPWBcXG4gICAgICAgIGZsb2F0ICR7ZX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7clsxXSphfSArIGNvbCAqICR7YX0gK1xcbiAgICAgICAgICAgICAgZGVwdGgyICogJHtpfSArIGRlcHRoO1xcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke24ud2lkdGh9LCAke24uaGVpZ2h0fSwgaW5kZXgpO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke3R9LCB1dik7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUocyxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1nZXRVbnBhY2tlZFNhbXBsZXI1RChlLHQsbil7Y29uc3Qgcj1uLnVucGFja2VkU2hhcGUsaT1yWzRdLHU9clszXSppLGw9clsyXSp1LGM9clsxXSpsLHtuZXdTaGFwZTpwLGtlcHREaW1zOmR9PSgwLGEuc3F1ZWV6ZVNoYXBlKShyKTtpZihwLmxlbmd0aDxyLmxlbmd0aCl7Y29uc3QgaT0oMCxzLnNxdWVlemVJbnB1dFNoYXBlKShyLHApLGE9W1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIixcImRlcHRoM1wiXSx1PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO3UudW5wYWNrZWRTaGFwZT1pO2NvbnN0IGw9YFxcbiAgICAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGUsdCx1KS5yb3V0aW5lQm9keX1cXG4gICAgICAgICAgZmxvYXQgJHtlfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHtlfSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKGEsZCl9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUobCxbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCJdKX1jb25zdCBmPWBcXG4gICAgICAgIGZsb2F0ICR7ZX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7Y30gKyBjb2wgKiAke2x9ICsgZGVwdGggKiAke3V9ICtcXG4gICAgICAgICAgZGVwdGgzICogJHtpfSArIGRlcHRoMjtcXG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtuLndpZHRofSwgJHtuLmhlaWdodH0sIGluZGV4KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHt0fSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKGYsW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyNkQoZSx0LG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLGk9cls1XSx1PXJbNF0qaSxsPXJbM10qdSxjPXJbMl0qbCxwPXJbMV0qYyx7bmV3U2hhcGU6ZCxrZXB0RGltczpmfT0oMCxhLnNxdWVlemVTaGFwZSkocik7aWYoZC5sZW5ndGg8ci5sZW5ndGgpe2NvbnN0IGk9KDAscy5zcXVlZXplSW5wdXRTaGFwZSkocixkKSxhPVtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCIsXCJkZXB0aDNcIixcImRlcHRoNFwiXSx1PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO3UudW5wYWNrZWRTaGFwZT1pO2NvbnN0IGw9YFxcbiAgICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZSx0LHUpLnJvdXRpbmVCb2R5fVxcbiAgICAgICAgICAgIGZsb2F0ICR7ZX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuICR7ZX0oJHsoMCxzLmdldFNxdWVlemVkUGFyYW1zKShhLGYpfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShsLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIl0pfWNvbnN0IGg9YFxcbiAgICAgICAgICBmbG9hdCAke2V9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICAgICAgaW50IGluZGV4ID0gcm93ICogJHtwfSArIGNvbCAqICR7Y30gKyBkZXB0aCAqICR7bH0gK1xcbiAgICAgICAgICAgIGRlcHRoMiAqICR7dX0gKyBkZXB0aDMgKiAke2l9ICsgZGVwdGg0O1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7bi53aWR0aH0sICR7bi5oZWlnaHR9LCBpbmRleCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHt0fSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShoLFtcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIixcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX10b1ZlYygpe2NvbnN0IGU9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQsdD1lLnNoYXBlLmxlbmd0aCxuPWUuc3RyaWRlcyxyPWUud2lkdGgsaT1lLmhlaWdodCxhPVtdO2ZvcihsZXQgZT0wO2U8dC0xOysrZSlhLnB1c2goYFxcbiAgICAgICAgY1ske2V9XSA9IG9mZnNldCAvICR7bltlXX07YCksYS5wdXNoKGBcXG4gICAgICAgIG9mZnNldCAtPSBjWyR7ZX1dICogJHtuW2VdfTtgKTthLnB1c2goYFxcbiAgICAgICAgY1ske3QtMX1dID0gb2Zmc2V0O2ApO2NvbnN0IHM9YFxcbiAgICAgIHZvaWQgdG9WZWModmVjMiB0ZXhDb29yZHMsIG91dCBpbnQgY1ske3R9XSkge1xcbiAgICAgICAgaW50IG9mZnNldCA9IGNvb3Jkc1RvT2Zmc2V0KHRleENvb3JkcywgJHtyfSwgJHtpfSk7XFxuICAgICAgICAke2Euam9pbihcIlwiKX1cXG4gICAgICB9XFxuICAgICAgdm9pZCB0b1ZlYyhpbnQgb2Zmc2V0LCBvdXQgaW50IGNbJHt0fV0pIHtcXG4gICAgICAgICR7YS5qb2luKFwiXCIpfVxcbiAgICAgIH1cXG4gICAgYDtyZXR1cm57dG9WZWM6bmV3IG8uR2xzbExpYlJvdXRpbmUocyxbXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9fXZhbHVlRnJvbSgpe2NvbnN0IGU9e307cmV0dXJuIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKCh0LG4pPT57Y29uc3Qgcj10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tuXSxpPShyLnVucGFja2VkU2hhcGUubGVuZ3RoPjA/ci51bnBhY2tlZFNoYXBlOnIuc2hhcGUpLmxlbmd0aDtsZXQgYT1gXyR7dH1gO2VbYV09bmV3IG8uR2xzbExpYlJvdXRpbmUodGhpcy5nZXRWYWx1ZUZyb21TaW5nbGUodCxpLHIud2lkdGgsci5oZWlnaHQsITEpLFtgc2hhcGVVdGlscy5pbmRpY2VzVG9PZmZzZXQke2F9YCxcImNvb3JkaW5hdGVzLm9mZnNldFRvQ29vcmRzXCIsXCJmcmFnY29sb3IuZ2V0Q29sb3JBc0Zsb2F0XCJdKSxhKz1cIl9UXCIsZVthXT1uZXcgby5HbHNsTGliUm91dGluZSh0aGlzLmdldFZhbHVlRnJvbVNpbmdsZSh0LGksci53aWR0aCxyLmhlaWdodCwhMCksW2BzaGFwZVV0aWxzLmluZGljZXNUb09mZnNldCR7YX1gLFwiY29vcmRpbmF0ZXMub2Zmc2V0VG9Db29yZHNcIixcImZyYWdjb2xvci5nZXRDb2xvckFzRmxvYXRcIl0pfSkpLGV9Z2V0VmFsdWVGcm9tU2luZ2xlKGUsdCxuLHIsbyl7bGV0IGE9YF8ke2V9YDtyZXR1cm4gbyYmKGErPVwiX1RcIiksYFxcbiAgICAgICAgZmxvYXQgJHthfShpbnQgbVske3R9XSkge1xcbiAgICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0JHthfShtKTtcXG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7bn0sICR7cn0pO1xcbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgkeygwLGkuZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKS50ZXh0dXJlMkR9KCR7ZX0sIGNvb3JkcykpO1xcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBgfWdldFBhY2tlZFZhbHVlRnJvbShlLHQsbixyLG8pe2xldCBhPWBfJHtlfV9QYWNrYDtyZXR1cm4gbyYmKGErPVwiX1RcIiksYFxcbiAgICAgICAgdmVjNCAke2F9KGludCBtWyR7dH1dKSB7XFxuICAgICAgICAgIGludCBvZmZzZXQgPSBpbmRpY2VzVG9PZmZzZXRfJHtlfShtKTtcXG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7bn0sICR7cn0pO1xcbiAgICAgICAgICByZXR1cm4gJHsoMCxpLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfSgke2V9LCBjb29yZHMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgYH19dC5Db29yZHNHbHNsTGliPXV9LDE5OTc6KGUsdCk9PntcInVzZSBzdHJpY3RcIjt2YXIgbjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlRvcG9sb2dpY2FsU29ydEdsc2xSb3V0aW5lcz10Lkdsc2xMaWJSb3V0aW5lTm9kZT10Lkdsc2xMaWJSb3V0aW5lPXQuR2xzbExpYj10Lkdsc2xDb250ZXh0PXQuRnVuY3Rpb25UeXBlPXZvaWQgMCwobj10LkZ1bmN0aW9uVHlwZXx8KHQuRnVuY3Rpb25UeXBlPXt9KSlbbi5WYWx1ZUJhc2VkPTBdPVwiVmFsdWVCYXNlZFwiLG5bbi5Qb3NpdGlvbmFsPTFdPVwiUG9zaXRpb25hbFwiLHQuR2xzbENvbnRleHQ9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4scil7dGhpcy5nbENvbnRleHQ9ZSx0aGlzLnByb2dyYW1JbmZvPXQsdGhpcy5pbnB1dFRleHR1cmVMYXlvdXRzPW4sdGhpcy5vdXRwdXRUZXh0dXJlTGF5b3V0PXJ9fSx0Lkdsc2xMaWI9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5jb250ZXh0PWV9fSx0Lkdsc2xMaWJSb3V0aW5lPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5yb3V0aW5lQm9keT1lLHRoaXMuZGVwZW5kZW5jaWVzPXR9fSx0Lkdsc2xMaWJSb3V0aW5lTm9kZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbil7dGhpcy5uYW1lPWUsdGhpcy5kZXBlbmRlbmNpZXM9bnx8W10sdCYmKHRoaXMucm91dGluZUJvZHk9dCl9YWRkRGVwZW5kZW5jeShlKXtlJiZ0aGlzLmRlcGVuZGVuY2llcy5wdXNoKGUpfX0sdC5Ub3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXM9Y2xhc3N7c3RhdGljIHJldHVybk9yZGVyZWROb2RlcyhlKXtpZighZXx8MD09PWUubGVuZ3RoKXJldHVybltdO2lmKDE9PT1lLmxlbmd0aClyZXR1cm4gZTtjb25zdCB0PW5ldyBTZXQsbj1uZXcgU2V0LHI9bmV3IEFycmF5O3JldHVybiB0aGlzLmNyZWF0ZU9yZGVyZWROb2RlcyhlLHQsbixyKSxyfXN0YXRpYyBjcmVhdGVPcmRlcmVkTm9kZXMoZSx0LG4scil7Zm9yKGxldCBvPTA7bzxlLmxlbmd0aDsrK28pdGhpcy5kZnNUcmF2ZXJzZShlW29dLHQsbixyKX1zdGF0aWMgZGZzVHJhdmVyc2UoZSx0LG4scil7aWYoIWV8fG4uaGFzKGUubmFtZSkpcmV0dXJuO2lmKHQuaGFzKGUubmFtZSkpdGhyb3cgbmV3IEVycm9yKFwiQ3ljbGljIGRlcGVuZGVuY3kgZGV0ZWN0ZWQuIENhbid0IHRvcG9sb2dpY2FsbHkgc29ydCByb3V0aW5lcyBuZWVkZWQgZm9yIHNoYWRlci5cIik7dC5hZGQoZS5uYW1lKTtjb25zdCBvPWUuZGVwZW5kZW5jaWVzO2lmKG8mJm8ubGVuZ3RoPjApZm9yKGxldCBlPTA7ZTxvLmxlbmd0aDsrK2UpdGhpcy5kZnNUcmF2ZXJzZShvW2VdLHQsbixyKTtyLnB1c2goZSksbi5hZGQoZS5uYW1lKSx0LmRlbGV0ZShlLm5hbWUpfX19LDEzNzE6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuRW5jb2RpbmdHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oMTk5Nyk7Y2xhc3MgbyBleHRlbmRzIHIuR2xzbExpYntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKX1nZXRGdW5jdGlvbnMoKXtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHRoaXMuZW5jb2RlRmxvYXQzMigpKSx0aGlzLmRlY29kZUZsb2F0MzIoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1lbmNvZGVGbG9hdDMyKCl7cmV0dXJue2VuY29kZTpuZXcgci5HbHNsTGliUm91dGluZShcImhpZ2hwIHZlYzQgZW5jb2RlKGhpZ2hwIGZsb2F0IGYpIHtcXG4gICAgICAgIHJldHVybiB2ZWM0KGYsIDAuMCwgMC4wLCAwLjApO1xcbiAgICAgIH1cXG4gICAgICAgIFwiKX19ZGVjb2RlRmxvYXQzMigpe3JldHVybntkZWNvZGU6bmV3IHIuR2xzbExpYlJvdXRpbmUoXCJoaWdocCBmbG9hdCBkZWNvZGUoaGlnaHAgdmVjNCByZ2JhKSB7XFxuICAgICAgICByZXR1cm4gcmdiYS5yO1xcbiAgICAgIH1cXG4gICAgICAgIFwiKX19ZW5jb2RlVWludDgoKXtjb25zdCBlPW8uaXNMaXR0bGVFbmRpYW4oKT9cInJnYmEucmdiYT1yZ2JhLmFiZ3I7XCI6XCJcIjtyZXR1cm57ZW5jb2RlOm5ldyByLkdsc2xMaWJSb3V0aW5lKGBcXG4gICAgICBoaWdocCB2ZWM0IGVuY29kZShoaWdocCBmbG9hdCBmKSB7XFxuICAgICAgICBoaWdocCBmbG9hdCBGID0gYWJzKGYpO1xcbiAgICAgICAgaGlnaHAgZmxvYXQgU2lnbiA9IHN0ZXAoMC4wLC1mKTtcXG4gICAgICAgIGhpZ2hwIGZsb2F0IEV4cG9uZW50ID0gZmxvb3IobG9nMihGKSk7XFxuICAgICAgICBoaWdocCBmbG9hdCBNYW50aXNzYSA9IChleHAyKC0gRXhwb25lbnQpICogRik7XFxuICAgICAgICBFeHBvbmVudCA9IGZsb29yKGxvZzIoRikgKyAxMjcuMCkgKyBmbG9vcihsb2cyKE1hbnRpc3NhKSk7XFxuICAgICAgICBoaWdocCB2ZWM0IHJnYmE7XFxuICAgICAgICByZ2JhWzBdID0gMTI4LjAgKiBTaWduICArIGZsb29yKEV4cG9uZW50KmV4cDIoLTEuMCkpO1xcbiAgICAgICAgcmdiYVsxXSA9IDEyOC4wICogbW9kKEV4cG9uZW50LDIuMCkgKyBtb2QoZmxvb3IoTWFudGlzc2EqMTI4LjApLDEyOC4wKTtcXG4gICAgICAgIHJnYmFbMl0gPSBmbG9vcihtb2QoZmxvb3IoTWFudGlzc2EqZXhwMigyMy4wIC04LjApKSxleHAyKDguMCkpKTtcXG4gICAgICAgIHJnYmFbM10gPSBmbG9vcihleHAyKDIzLjApKm1vZChNYW50aXNzYSxleHAyKC0xNS4wKSkpO1xcbiAgICAgICAgJHtlfVxcbiAgICAgICAgcmdiYSA9IHJnYmEgLyAyNTUuMDsgLy8gdmFsdWVzIG5lZWQgdG8gYmUgbm9ybWFsaXplZCB0byBbMCwxXVxcbiAgICAgICAgcmV0dXJuIHJnYmE7XFxuICAgIH1cXG4gICAgICAgIGApfX1kZWNvZGVVaW50OCgpe2NvbnN0IGU9by5pc0xpdHRsZUVuZGlhbigpP1wicmdiYS5yZ2JhPXJnYmEuYWJncjtcIjpcIlwiO3JldHVybntkZWNvZGU6bmV3IHIuR2xzbExpYlJvdXRpbmUoYFxcbiAgICAgICAgaGlnaHAgZmxvYXQgZGVjb2RlKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgICAgICAgICByZ2JhID0gcmdiYSAqIDI1NS4wOyAvLyB2YWx1ZXMgbmVlZCB0byBiZSBkZS1ub3JtYWxpemVkIGZyb20gWzAsMV0gdG8gWzAsMjU1XVxcbiAgICAgICAgICAke2V9XFxuICAgICAgICAgIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyOC4wLHJnYmFbMF0pKjIuMDtcXG4gICAgICAgICAgaGlnaHAgZmxvYXQgRXhwb25lbnQgPSAyLjAgKiBtb2QocmdiYVswXSwxMjguMCkgKyBzdGVwKDEyOC4wLHJnYmFbMV0pIC0gMTI3LjA7XFxuICAgICAgICAgIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMV0sMTI4LjApKjY1NTM2LjAgKyByZ2JhWzJdKjI1Ni4wICtyZ2JhWzNdICsgZmxvYXQoMHg4MDAwMDApO1xcbiAgICAgICAgICBoaWdocCBmbG9hdCBSZXN1bHQgPSAgU2lnbiAqIGV4cDIoRXhwb25lbnQpICogKE1hbnRpc3NhICogZXhwMigtMjMuMCApKTtcXG4gICAgICAgICAgcmV0dXJuIFJlc3VsdDtcXG4gICAgICB9XFxuICAgICAgICBgKX19c3RhdGljIGlzTGl0dGxlRW5kaWFuKCl7Y29uc3QgZT1uZXcgQXJyYXlCdWZmZXIoNCksdD1uZXcgVWludDMyQXJyYXkoZSksbj1uZXcgVWludDhBcnJheShlKTtpZih0WzBdPTM3MzU5Mjg1NTksMjM5PT09blswXSlyZXR1cm4hMDtpZigyMjI9PT1uWzBdKXJldHVybiExO3Rocm93IG5ldyBFcnJvcihcInVua25vd24gZW5kaWFubmVzc1wiKX19dC5FbmNvZGluZ0dsc2xMaWI9b30sMjY5MTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5GcmFnQ29sb3JHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oMTk5Nyksbz1uKDY3NTcpO2NsYXNzIGkgZXh0ZW5kcyByLkdsc2xMaWJ7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSl9Z2V0RnVuY3Rpb25zKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLnNldEZyYWdDb2xvcigpKSx0aGlzLmdldENvbG9yQXNGbG9hdCgpKX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fXNldEZyYWdDb2xvcigpe2NvbnN0IGU9KDAsby5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO3JldHVybntzZXRGcmFnQ29sb3I6bmV3IHIuR2xzbExpYlJvdXRpbmUoYFxcbiAgICAgICAgdm9pZCBzZXRGcmFnQ29sb3IoZmxvYXQgdmFsdWUpIHtcXG4gICAgICAgICAgICAke2Uub3V0cHV0fSA9IGVuY29kZSh2YWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICBgLFtcImVuY29kaW5nLmVuY29kZVwiXSl9fWdldENvbG9yQXNGbG9hdCgpe3JldHVybntnZXRDb2xvckFzRmxvYXQ6bmV3IHIuR2xzbExpYlJvdXRpbmUoXCJcXG4gICAgICAgIGZsb2F0IGdldENvbG9yQXNGbG9hdCh2ZWM0IGNvbG9yKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZShjb2xvcik7XFxuICAgICAgICB9XFxuICAgICAgICBcIixbXCJlbmNvZGluZy5kZWNvZGVcIl0pfX19dC5GcmFnQ29sb3JHbHNsTGliPWl9LDM4Nzg6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnJlcGxhY2VJbmxpbmVzPXZvaWQgMDtjb25zdCBuPS9AaW5saW5lW1xcc1xcblxccl0rKFxcdyspW1xcc1xcblxccl0rKFswLTlhLXpBLVpfXSspXFxzKlxcKChbXildKilcXClcXHMqeygoW159XXxbXFxuXFxyXSkqKX0vZ207dC5yZXBsYWNlSW5saW5lcz1mdW5jdGlvbihlKXtjb25zdCB0PXt9O2xldCByO2Zvcig7bnVsbCE9PShyPW4uZXhlYyhlKSk7KXtjb25zdCBlPXJbM10uc3BsaXQoXCIsXCIpLm1hcCgoZT0+e2NvbnN0IHQ9ZS50cmltKCkuc3BsaXQoXCIgXCIpO3JldHVybiB0JiYyPT09dC5sZW5ndGg/e3R5cGU6dFswXSxuYW1lOnRbMV19Om51bGx9KSkuZmlsdGVyKChlPT5udWxsIT09ZSkpO3RbclsyXV09e3BhcmFtczplLGJvZHk6cls0XX19Zm9yKGNvbnN0IG4gaW4gdCl7Y29uc3Qgbz1cIihcXFxcdyspP1xcXFxzKyhbXzAtOWEtekEtWl0rKVxcXFxzKz1cXFxccytfX0ZVTkNfX1xcXFwoKC4qKVxcXFwpXFxcXHMqO1wiLnJlcGxhY2UoXCJfX0ZVTkNfX1wiLG4pLGk9bmV3IFJlZ0V4cChvLFwiZ21cIik7Zm9yKDtudWxsIT09KHI9aS5leGVjKGUpKTspe2NvbnN0IG89clsxXSxpPXJbMl0sYT1yWzNdLnNwbGl0KFwiLFwiKSxzPW8/YCR7b30gJHtpfTtgOlwiXCI7bGV0IHU9dFtuXS5ib2R5LGw9XCJcIjt0W25dLnBhcmFtcy5mb3JFYWNoKCgoZSx0KT0+e2UmJihsKz1gJHtlLnR5cGV9ICR7ZS5uYW1lfSA9ICR7YVt0XX07XFxuYCl9KSksdT1gJHtsfVxcbiAke3V9YCx1PXUucmVwbGFjZShcInJldHVyblwiLGAke2l9ID0gYCk7Y29uc3QgYz1gXFxuICAgICAgJHtzfVxcbiAgICAgIHtcXG4gICAgICAgICR7dX1cXG4gICAgICB9XFxuICAgICAgYDtlPWUucmVwbGFjZShyWzBdLGMpfX1yZXR1cm4gZS5yZXBsYWNlKG4sXCJcIil9fSw4ODk3OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lkdsc2xQcmVwcm9jZXNzb3I9dm9pZCAwO2NvbnN0IHI9bigxOTk3KSxvPW4oMzg3OCksaT1uKDEyNDgpLGE9big2NzU3KTt0Lkdsc2xQcmVwcm9jZXNzb3I9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sbyl7dGhpcy5saWJzPXt9LHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGg9e30sdGhpcy5jb250ZXh0PW5ldyByLkdsc2xDb250ZXh0KGUsdCxuLG8pLE9iamVjdC5rZXlzKGkuZ2xzbFJlZ2lzdHJ5KS5mb3JFYWNoKChlPT57Y29uc3QgdD1uZXcgaS5nbHNsUmVnaXN0cnlbZV0odGhpcy5jb250ZXh0KTt0aGlzLmxpYnNbZV09dH0pKTtjb25zdCBhPXRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGg7Zm9yKGNvbnN0IGUgaW4gdGhpcy5saWJzKXtjb25zdCB0PXRoaXMubGlic1tlXS5nZXRGdW5jdGlvbnMoKTtmb3IoY29uc3QgbiBpbiB0KXtjb25zdCBvPWUrXCIuXCIrbjtsZXQgaTthW29dPyhpPWFbb10saS5yb3V0aW5lQm9keT10W25dLnJvdXRpbmVCb2R5KTooaT1uZXcgci5HbHNsTGliUm91dGluZU5vZGUobyx0W25dLnJvdXRpbmVCb2R5KSxhW29dPWkpO2NvbnN0IHM9dFtuXS5kZXBlbmRlbmNpZXM7aWYocylmb3IobGV0IGU9MDtlPHMubGVuZ3RoOysrZSlpZihhW3NbZV1dKWkuYWRkRGVwZW5kZW5jeShhW3NbZV1dKTtlbHNle2NvbnN0IHQ9bmV3IHIuR2xzbExpYlJvdXRpbmVOb2RlKHNbZV0pO2Fbc1tlXV09dCxpLmFkZERlcGVuZGVuY3kodCl9fX19cHJlcHJvY2Vzcygpe2NvbnN0IGU9dGhpcy5jb250ZXh0LnByb2dyYW1JbmZvO2xldCB0PWUuc2hhZGVyU291cmNlO3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaGFzTWFpbnx8KHQ9YCR7dH1cXG4gICAgICAkeygwLGEuZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24sdGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoKX1gKSx0PSgwLG8ucmVwbGFjZUlubGluZXMpKHQpLGAkeygwLGEuZ2V0RnJhZ1NoYWRlclByZWFtYmxlKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pfVxcbiAgICAke3RoaXMuZ2V0VW5pZm9ybXMoZS5pbnB1dE5hbWVzLGUudmFyaWFibGVzKX1cXG4gICAgJHt0aGlzLmdldEltcG9ydHModCl9XFxuICAgICR7dH1gfWdldEltcG9ydHMoZSl7Y29uc3QgdD10aGlzLnNlbGVjdEdsc2xMaWJSb3V0aW5lc1RvQmVJbmNsdWRlZChlKTtpZigwPT09dC5sZW5ndGgpcmV0dXJuXCJcIjtsZXQgbj1cIlwiO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7KytlKXtpZighdFtlXS5yb3V0aW5lQm9keSl0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgYm9keSBmb3IgdGhlIEdsc2wgTGlicmFyeSByb3V0aW5lOiAke3RbZV0ubmFtZX1gKTtuKz10W2VdLnJvdXRpbmVCb2R5K1wiXFxuXCJ9cmV0dXJuIG59c2VsZWN0R2xzbExpYlJvdXRpbmVzVG9CZUluY2x1ZGVkKGUpe2NvbnN0IHQ9W107cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGgpLmZvckVhY2goKG49Pntjb25zdCByPW4uc3BsaXQoXCIuXCIpWzFdOy0xIT09ZS5pbmRleE9mKHIpJiZ0LnB1c2godGhpcy5nbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaFtuXSl9KSksci5Ub3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXMucmV0dXJuT3JkZXJlZE5vZGVzKHQpfWdldFVuaWZvcm1zKGUsdCl7Y29uc3Qgbj1bXTtpZihlKWZvcihjb25zdCB0IG9mIGUpbi5wdXNoKGB1bmlmb3JtIHNhbXBsZXIyRCAke3R9O2ApO2lmKHQpZm9yKGNvbnN0IGUgb2YgdCluLnB1c2goYHVuaWZvcm0gJHtlLnR5cGV9ICR7ZS5uYW1lfSR7ZS5hcnJheUxlbmd0aD9gWyR7ZS5hcnJheUxlbmd0aH1dYDpcIlwifTtgKTtyZXR1cm4gbi5qb2luKFwiXFxuXCIpfX19LDEyNDg6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2xzbFJlZ2lzdHJ5PXZvaWQgMDtjb25zdCByPW4oNjg1OSksbz1uKDEzNzEpLGk9bigyNjkxKSxhPW4oOTE4Mykscz1uKDkzMTQpO3QuZ2xzbFJlZ2lzdHJ5PXtlbmNvZGluZzpvLkVuY29kaW5nR2xzbExpYixmcmFnY29sb3I6aS5GcmFnQ29sb3JHbHNsTGliLHZlYzpzLlZlY0dsc2xMaWIsc2hhcGVVdGlsczphLlNoYXBlVXRpbHNHbHNsTGliLGNvb3JkaW5hdGVzOnIuQ29vcmRzR2xzbExpYn19LDkxODM6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuU2hhcGVVdGlsc0dsc2xMaWI9dm9pZCAwO2NvbnN0IHI9bigxOTk3KTtjbGFzcyBvIGV4dGVuZHMgci5HbHNsTGlie2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpfWdldEZ1bmN0aW9ucygpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdGhpcy5iY2FzdEluZGV4KCkpLHRoaXMuYmNhc3RNYXRtdWxJbmRleCgpKSx0aGlzLm9mZnNldFRvSW5kaWNlcygpKSx0aGlzLmluZGljZXNUb09mZnNldCgpKSx0aGlzLmluY3JlbWVudEluZGljZXMoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1iY2FzdEluZGV4KCl7Y29uc3QgZT10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGgsdD17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKG4sbyk9Pntjb25zdCBpPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW29dLnVucGFja2VkU2hhcGU7aWYoaS5sZW5ndGg8PWUpe2NvbnN0IG89aS5sZW5ndGgsYT1lLW8scz1gYmNhc3RJbmRpY2VzXyR7bn1gO2xldCB1PVwiXCI7Zm9yKGxldCBlPTA7ZTxvOysrZSl1Kz1gXFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7ZX1dID0gaW50KCBtb2QoZmxvYXQoYmNhc3RlZEluZGljZXNbJHthK2V9XSksICR7aVtlXX0uMCkgKTtcXG4gICAgICAgICAgYDtjb25zdCBsPWBcXG4gICAgICAgIHZvaWQgJHtzfSAoaW50IGJjYXN0ZWRJbmRpY2VzWyR7ZX1dLCBvdXQgaW50IHJlYWxJbmRpY2VzWyR7b31dKSB7XFxuICAgICAgICAgICR7dX1cXG4gICAgICAgIH1cXG4gICAgICAgIGA7dFtzXT1uZXcgci5HbHNsTGliUm91dGluZShsKX19KSksdH1iY2FzdE1hdG11bEluZGV4KCl7Y29uc3QgZT10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGgsdD17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKG4sbyk9Pntjb25zdCBpPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW29dLnNoYXBlO2lmKCEoaS5sZW5ndGg8Mnx8aS5sZW5ndGg+ZSkpe2NvbnN0IG89aS5sZW5ndGgsYT1lLW8scz1gYmNhc3RNYXRtdWxJbmRpY2VzXyR7bn1gO2xldCB1PVwiXCI7Zm9yKGxldCBlPTA7ZTxvLTI7KytlKXUrPWBcXG4gICAgICAgICAgcmVhbEluZGljZXNbJHtlfV0gPSBpbnQoIG1vZChmbG9hdChiY2FzdGVkSW5kaWNlc1ske2ErZX1dKSwgJHtpW2VdfS4wKSApO1xcbiAgICAgICAgICBgO2NvbnN0IGw9YFxcbiAgICAgICAgdm9pZCAke3N9KGludCBiY2FzdGVkSW5kaWNlc1ske2V9XSwgb3V0IGludCByZWFsSW5kaWNlc1ske299XSkge1xcbiAgICAgICAgICAke3V9XFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7by0xfV0gPSBiY2FzdGVkSW5kaWNlc1ske2UtMX1dO1xcbiAgICAgICAgICByZWFsSW5kaWNlc1ske28tMn1dID0gYmNhc3RlZEluZGljZXNbJHtlLTJ9XTtcXG4gICAgICAgIH1cXG4gICAgICAgIGA7dFtzXT1uZXcgci5HbHNsTGliUm91dGluZShsKX19KSksdH1pbmRpY2VzVG9PZmZzZXQoKXtjb25zdCBlPXt9O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgodCxuKT0+e2NvbnN0IGk9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc2hhcGUsYT10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tuXS5zdHJpZGVzLHM9aS5sZW5ndGg7bGV0IHU9YGluZGljZXNUb09mZnNldF8ke3R9YDtlW3VdPW5ldyByLkdsc2xMaWJSb3V0aW5lKG8uaW5kZXhUb09mZnNldFNpbmdsZSh1LHMsYSkpLHU9YGluZGljZXNUb09mZnNldF8ke3R9X1RgLGVbdV09bmV3IHIuR2xzbExpYlJvdXRpbmUoby5pbmRleFRvT2Zmc2V0U2luZ2xlKHUscyxhLnNsaWNlKCkucmV2ZXJzZSgpKSl9KSksZX1zdGF0aWMgaW5kZXhUb09mZnNldFNpbmdsZShlLHQsbil7bGV0IHI9XCJcIjtmb3IobGV0IGU9dC0xO2U+PTA7LS1lKXIrPWBcXG4gICAgICAgIG9mZnNldCArPSBpbmRpY2VzWyR7ZX1dICogJHtuW2VdfTtcXG4gICAgICAgIGA7cmV0dXJuYFxcbiAgICAgIGludCAke2V9KGludCBpbmRpY2VzWyR7dH1dKSB7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcXG4gICAgICAgICR7cn1cXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XFxuICAgICAgfVxcbiAgICAgIGB9b2Zmc2V0VG9JbmRpY2VzKCl7Y29uc3QgZT17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKHQsbik9Pntjb25zdCBpPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW25dLnNoYXBlLGE9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc3RyaWRlcyxzPWkubGVuZ3RoO2xldCB1PWBvZmZzZXRUb0luZGljZXNfJHt0fWA7ZVt1XT1uZXcgci5HbHNsTGliUm91dGluZShvLm9mZnNldFRvSW5kaWNlc1NpbmdsZSh1LHMsYSkpLHU9YG9mZnNldFRvSW5kaWNlc18ke3R9X1RgLGVbdV09bmV3IHIuR2xzbExpYlJvdXRpbmUoby5vZmZzZXRUb0luZGljZXNTaW5nbGUodSxzLGEuc2xpY2UoKS5yZXZlcnNlKCkpKX0pKSxlfXN0YXRpYyBvZmZzZXRUb0luZGljZXNTaW5nbGUoZSx0LG4pe2NvbnN0IHI9W107Zm9yKGxldCBlPTA7ZTx0LTE7KytlKXIucHVzaChgXFxuICAgICAgaW5kaWNlc1ske2V9XSA9IG9mZnNldCAvICR7bltlXX07YCksci5wdXNoKGBcXG4gICAgICAgIG9mZnNldCAtPSBpbmRpY2VzWyR7ZX1dICogJHtuW2VdfTtgKTtyZXR1cm4gci5wdXNoKGBcXG4gICAgICBpbmRpY2VzWyR7dC0xfV0gPSBvZmZzZXQ7YCksYFxcbiAgICAgIHZvaWQgJHtlfShpbnQgb2Zmc2V0LCBvdXQgaW50IGluZGljZXNbJHt0fV0pIHtcXG4gICAgICAgICR7ci5qb2luKFwiXCIpfVxcbiAgICAgIH1cXG4gICAgICBgfWluY3JlbWVudEluZGljZXMoKXtjb25zdCBlPXt9O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgodCxuKT0+e2NvbnN0IG89dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc2hhcGUsaT1vLmxlbmd0aCxhPWBpbmNyZW1lbnRJbmRpY2VzXyR7dH1gO2xldCBzPVwiXCI7Zm9yKGxldCBlPTA7ZTxpOysrZSlzKz1gXFxuICAgICAgICBzaGFwZVske2V9XSA9ICR7b1tlXX07YDtjb25zdCB1PWBcXG4gICAgICAgIHZvaWQgJHthfShpbnQgYXhpcywgb3V0IGludCBpbmRpY2VzWyR7aX1dKSB7XFxuICAgICAgICAgIGludCBzaGFwZVske2l9XTtcXG4gICAgICAgICAgJHtzfTtcXG4gICAgICAgICAgZm9yKGludCBpID0gJHtpfSAtMSA7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICAgICAgaWYoaSA+IGF4aXMpIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIGluZGljZXNbaV0gKz0gMTtcXG4gICAgICAgICAgICBpZihpbmRpY2VzW2ldIDwgc2hhcGVbaV0pIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbmRpY2VzW2ldID0gMDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgYDtlW2FdPW5ldyByLkdsc2xMaWJSb3V0aW5lKHUpfSkpLGV9fXQuU2hhcGVVdGlsc0dsc2xMaWI9b30sNjc1NzooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluPXQuZ2V0RnJhZ1NoYWRlclByZWFtYmxlPXQuZ2V0VmVydGV4U2hhZGVyU291cmNlPXQuZ2V0R2xzbD12b2lkIDA7Y29uc3Qgbj17dmVyc2lvbjpcIlwiLGF0dHJpYnV0ZTpcImF0dHJpYnV0ZVwiLHZhcnlpbmdWZXJ0ZXg6XCJ2YXJ5aW5nXCIsdmFyeWluZ0ZyYWc6XCJ2YXJ5aW5nXCIsdGV4dHVyZTJEOlwidGV4dHVyZTJEXCIsb3V0cHV0OlwiZ2xfRnJhZ0NvbG9yXCIsb3V0cHV0RGVjbGFyYXRpb246XCJcIn0scj17dmVyc2lvbjpcIiN2ZXJzaW9uIDMwMCBlc1wiLGF0dHJpYnV0ZTpcImluXCIsdmFyeWluZ1ZlcnRleDpcIm91dFwiLHZhcnlpbmdGcmFnOlwiaW5cIix0ZXh0dXJlMkQ6XCJ0ZXh0dXJlXCIsb3V0cHV0Olwib3V0cHV0Q29sb3JcIixvdXRwdXREZWNsYXJhdGlvbjpcIm91dCB2ZWM0IG91dHB1dENvbG9yO1wifTtmdW5jdGlvbiBvKGUpe3JldHVybiAxPT09ZT9uOnJ9dC5nZXRHbHNsPW8sdC5nZXRWZXJ0ZXhTaGFkZXJTb3VyY2U9ZnVuY3Rpb24oZSl7Y29uc3QgdD1vKGUpO3JldHVybmAke3QudmVyc2lvbn1cXG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgICAgJHt0LmF0dHJpYnV0ZX0gdmVjMyBwb3NpdGlvbjtcXG4gICAgICAke3QuYXR0cmlidXRlfSB2ZWMyIHRleHR1cmVDb29yZDtcXG5cXG4gICAgICAke3QudmFyeWluZ1ZlcnRleH0gdmVjMiBUZXhDb29yZHM7XFxuXFxuICAgICAgdm9pZCBtYWluKClcXG4gICAgICB7XFxuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMS4wKTtcXG4gICAgICAgICAgVGV4Q29vcmRzID0gdGV4dHVyZUNvb3JkO1xcbiAgICAgIH1gfSx0LmdldEZyYWdTaGFkZXJQcmVhbWJsZT1mdW5jdGlvbihlKXtjb25zdCB0PW8oZSk7cmV0dXJuYCR7dC52ZXJzaW9ufVxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBpbnQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XFxuICAgICR7dC52YXJ5aW5nRnJhZ30gdmVjMiBUZXhDb29yZHM7XFxuICAgICR7dC5vdXRwdXREZWNsYXJhdGlvbn1cXG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcXG5cXG4gICAgLy8gQ3VzdG9tIHZlY3RvciB0eXBlcyB0byBoYW5kbGUgaGlnaGVyIGRpbWVuYWxpdGllcy5cXG4gICAgc3RydWN0IGl2ZWM1XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgfTtcXG5cXG4gICAgc3RydWN0IGl2ZWM2XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgICBpbnQgdjtcXG4gICAgfTtcXG5cXG4gICAgaW50IGltb2QoaW50IHgsIGludCB5KSB7XFxuICAgICAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcXG4gICAgfVxcblxcbiAgICBgfSx0LmdldERlZmF1bHRGcmFnU2hhZGVyTWFpbj1mdW5jdGlvbihlLHQpe3JldHVybmBcXG4gIHZvaWQgbWFpbigpIHtcXG4gICAgaW50IGluZGljZXNbJHt0fV07XFxuICAgIHRvVmVjKFRleENvb3JkcywgaW5kaWNlcyk7XFxuICAgIHZlYzQgcmVzdWx0ID0gdmVjNChwcm9jZXNzKGluZGljZXMpKTtcXG4gICAgJHtvKGUpLm91dHB1dH0gPSByZXN1bHQ7XFxuICB9XFxuICBgfX0sOTMxNDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5WZWNHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oMTk5Nyk7Y2xhc3MgbyBleHRlbmRzIHIuR2xzbExpYntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fWdldEZ1bmN0aW9ucygpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHRoaXMuYmluYXJ5VmVjRnVuY3Rpb25zKCkpLHRoaXMuY29weVZlYygpKSx0aGlzLnNldFZlY0l0ZW0oKSksdGhpcy5nZXRWZWNJdGVtKCkpfWJpbmFyeVZlY0Z1bmN0aW9ucygpe2NvbnN0IGU9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoLHQ9e2FkZDpcIis9XCIsc3ViOlwiLT1cIixtdWw6XCIqPVwiLGRpdjpcIi89XCJ9LG49e307Zm9yKGNvbnN0IG8gaW4gdCl7Y29uc3QgaT1gJHtvfVZlY2A7bGV0IGE9XCJcIjtmb3IobGV0IG49MDtuPGU7KytuKWErPWBcXG4gICAgICAgICAgZGVzdFske259XSAke3Rbb119IHNyY1ske259XTtcXG4gICAgICAgICAgYDtjb25zdCBzPWBcXG4gICAgICAgIHZvaWQgJHtpfShpbnQgc3JjWyR7ZX1dLCBvdXQgaW50IGRlc3RbJHtlfV0pIHtcXG4gICAgICAgICAgJHthfVxcbiAgICAgICAgfVxcbiAgICAgICAgYDtuW2ldPW5ldyByLkdsc2xMaWJSb3V0aW5lKHMpfXJldHVybiBufWNvcHlWZWMoKXtjb25zdCBlPXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aDtsZXQgdD1cIlwiO2ZvcihsZXQgbj0wO248ZTsrK24pdCs9YFxcbiAgICAgICAgZGVzdFske259XSA9IHNyY1ske259XTtcXG4gICAgICAgIGA7Y29uc3Qgbj1gXFxuICAgICAgdm9pZCBjb3B5VmVjKGludCBzcmNbJHtlfV0sIG91dCBpbnQgZGVzdFske2V9XSkge1xcbiAgICAgICAgJHt0fVxcbiAgICAgIH1cXG4gICAgICBgO3JldHVybntjb3B5VmVjOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX1zZXRWZWNJdGVtKCl7Y29uc3QgZT10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGg7bGV0IHQ9YFxcbiAgICAgICAgaWYoaW5kZXggPCAwKVxcbiAgICAgICAgICAgIGluZGV4ID0ke2V9ICsgaW5kZXg7XFxuICAgICAgICBpZiAoaW5kZXggPT0gMClcXG4gICAgICAgICAgICBtWzBdID0gdmFsdWU7XFxuICAgICAgICBgO2ZvcihsZXQgbj0xO248ZS0xOysrbil0Kz1gXFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAke259KVxcbiAgICAgICAgICAgIG1bJHtufV0gPSB2YWx1ZTtcXG4gICAgICAgICAgICBgO3QrPWBcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgICBtWyR7ZS0xfV0gPSB2YWx1ZTtcXG4gICAgICAgIGA7Y29uc3Qgbj1gXFxuICAgICAgdm9pZCBzZXRWZWNJdGVtKG91dCBpbnQgbVske2V9XSwgaW50IGluZGV4LCBpbnQgdmFsdWUpIHtcXG4gICAgICAgICR7dH1cXG4gICAgICB9XFxuICAgICAgICBgO3JldHVybntzZXRWZWNJdGVtOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX1nZXRWZWNJdGVtKCl7Y29uc3QgZT10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGg7bGV0IHQ9YFxcbiAgICAgICAgaWYoaW5kZXggPCAwKVxcbiAgICAgICAgICAgIGluZGV4ID0gJHtlfSArIGluZGV4O1xcbiAgICAgICAgaWYgKGluZGV4ID09IDApXFxuICAgICAgICAgICAgcmV0dXJuIG1bMF07XFxuICAgICAgYDtmb3IobGV0IG49MTtuPGUtMTsrK24pdCs9YFxcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gJHtufSlcXG4gICAgICAgICAgICByZXR1cm4gbVske259XTtcXG4gICAgICBgO3QrPWBcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgICByZXR1cm4gbVske2UtMX1dO1xcbiAgICAgICAgYDtjb25zdCBuPWBcXG4gICAgICBpbnQgZ2V0VmVjSXRlbShpbnQgbVske2V9XSwgaW50IGluZGV4KSB7XFxuICAgICAgICAke3R9XFxuICAgICAgfVxcbiAgICBgO3JldHVybntnZXRWZWNJdGVtOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX19dC5WZWNHbHNsTGliPW99LDc4NjA6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuV2ViR0xJbmZlcmVuY2VIYW5kbGVyPXZvaWQgMDtjb25zdCByPW4oMTMxNSksbz1uKDkyNDApLGk9big3MjczKSxhPW4oOSkscz1uKDczNzkpLHU9bigyNDg4KSxsPW4oNTQwKSxjPW4oMzMxNCkscD1uKDU2MzkpO3QuV2ViR0xJbmZlcmVuY2VIYW5kbGVyPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuc2Vzc2lvbj1lLHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwLHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXB9Y2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGUsdCl7cmV0dXJuKDAsYy5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQpKHRoaXMuc2Vzc2lvbi5sYXlvdXRTdHJhdGVneSxlLHQpfWV4ZWN1dGVQcm9ncmFtKGUsdCl7aWYodC5sZW5ndGg8ZS5pbnB1dE5hbWVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYElucHV0IHNpemUgbXVzdG4ndCBiZSBsZXNzIHRoYW4gJHtlLmlucHV0TmFtZXMubGVuZ3RofS5gKTtpZihlLmlucHV0TmFtZXMubGVuZ3RoIT09ZS5pbnB1dFR5cGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBuYW1lcyBzaXplIGRvZXMgbm90IG1hdGNoIGlucHV0IHR5cGVzXCIpO2NvbnN0IG49W107Zm9yKGxldCByPTA7cjxlLmlucHV0TmFtZXMubGVuZ3RoOysrciluW3JdPXRoaXMuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YSh0W3JdLGUuaW5wdXRUeXBlc1tyXSk7Y29uc3Qgcj0oKGUsdCk9Pntjb25zdCBuPXQubWFwKChlPT5gJHtlLnVucGFja2VkU2hhcGUuam9pbihcIixcIil9OyR7ZS53aWR0aH14JHtlLmhlaWdodH1gKSkuam9pbihcIl9cIik7bGV0IHI9ZS5uYW1lO3JldHVybiBlLmNhY2hlSGludCYmKHIrPVwiW1wiK2UuY2FjaGVIaW50K1wiXVwiKSxyKz1cIjpcIituLHJ9KShlLG4pO2xldCBvPXRoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5nZXRBcnRpZmFjdChyKTtjb25zdCBpPW8/by5wcm9ncmFtSW5mbzpcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmdldD9lLmdldCgpOmUsYT0oMCxjLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tVGV4dHVyZVR5cGUpKHRoaXMuc2Vzc2lvbi5sYXlvdXRTdHJhdGVneSxpLm91dHB1dC5kaW1zLGkub3V0cHV0LnRleHR1cmVUeXBlKSxzPXRoaXMuY3JlYXRlVGV4dHVyZURhdGEoYSxpLm91dHB1dC50eXBlKTtyZXR1cm4gb3x8KG89dGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKGksbixzKSx0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuc2V0QXJ0aWZhY3QocixvKSksdGhpcy5ydW5Qcm9ncmFtKG8sbixzKSxzfXJ1bihlLHQpe3JldHVybiB0aGlzLmV4ZWN1dGVQcm9ncmFtKGUsdCkudGVuc29yfXJ1blByb2dyYW0oZSx0LG4pe2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKWlmKCEhdFtuXS5pc1BhY2tlZCE9KGUucHJvZ3JhbUluZm8uaW5wdXRUeXBlc1tuXT09PXAuVGV4dHVyZVR5cGUucGFja2VkKSl0aHJvdyBuZXcgRXJyb3IoYGlucHV0WyR7bn1dIHByb3BlcnR5IHBhY2tlZCBpbmNvbnNpc3RlbnRgKTtpZighIW4uaXNQYWNrZWQhPShlLnByb2dyYW1JbmZvLm91dHB1dC50ZXh0dXJlVHlwZT09PXAuVGV4dHVyZVR5cGUucGFja2VkKSl0aHJvdyBuZXcgRXJyb3IoXCJvdXRwdXQgcHJvcGVydHkgcGFja2VkIGluY29uc2lzdGVudFwiKTt0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIucnVuKGUsdCxuKX1nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGUsdCl7bGV0IG49dGhpcy5nZXRUZXh0dXJlRGF0YShlLmRhdGFJZCx0PT09cC5UZXh0dXJlVHlwZS5wYWNrZWQpO2lmKCFuJiYobj10aGlzLmdldFRleHR1cmVEYXRhKGUuZGF0YUlkLHQhPT1wLlRleHR1cmVUeXBlLnBhY2tlZCksbikpcmV0dXJuIHQ9PT1wLlRleHR1cmVUeXBlLnBhY2tlZD90aGlzLnBhY2sobik6dGhpcy51bnBhY2sobik7aWYoIW4pe2NvbnN0IHI9KDAsYy5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksZS5kaW1zLHQpO2lmKHQ9PT1wLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24pe2NvbnN0IG49MSxyPTQsbz1lLmRpbXM7aWYoND09PW8ubGVuZ3RoKXtjb25zdCBpPVtvWzBdLE1hdGguY2VpbChvWzFdKm9bMl0qb1szXS9yKV0sYT0oMCxjLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tVGV4dHVyZVR5cGUpKHRoaXMuc2Vzc2lvbi5sYXlvdXRTdHJhdGVneSxpLHQpO2xldCBzPWUubnVtYmVyRGF0YTtpZihvWzFdKm9bMl0qb1szXSVyIT0wKXtjb25zdCB0PW9bMF0saT1vWzFdKm9bMl0qb1szXSxhPU1hdGguY2VpbChpKm4vcikqcjtzPW5ldyBGbG9hdDMyQXJyYXkodCphKTtmb3IobGV0IHI9MDtyPHQ7KytyKXtjb25zdCB0PXIqaSxvPXIqYStyJW4qaTtzLnNldChlLm51bWJlckRhdGEuc3ViYXJyYXkodCx0K2kpLG8pfX1yZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YShhLGUudHlwZSxzLGUsMSl9fWlmKHQ9PT1wLlRleHR1cmVUeXBlLnBhY2tlZCl7Y29uc3QgdD0oMCxjLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUpKHRoaXMuc2Vzc2lvbi5sYXlvdXRTdHJhdGVneSxlLmRpbXMsMSxbXSx7cmV2ZXJzZVdIOiEwfSkscj10aGlzLmNyZWF0ZVRleHR1cmVEYXRhKHQsZS50eXBlLGUubnVtYmVyRGF0YSxlLDEpO249dGhpcy5wYWNrKHIpfWVsc2Ugbj10aGlzLmNyZWF0ZVRleHR1cmVEYXRhKHIsZS50eXBlLGUubnVtYmVyRGF0YSxlLDEpfXJldHVybiBufWNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dEJpbmRUZW5zb3IoZSx0LG4scil7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGEoZSx0LG4sciwxKX1jcmVhdGVUZXh0dXJlRGF0YShlLHQsbixvLGkpe3IuTG9nZ2VyLnZlcmJvc2UoXCJJbmZlcmVuY2VIYW5kbGVyXCIsYENyZWF0aW5nIFRleHR1cmVEYXRhOiBsYXlvdXQ6WyR7SlNPTi5zdHJpbmdpZnkoZSl9XWApO2NvbnN0IGE9dGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLmNyZWF0ZVRleHR1cmVGcm9tTGF5b3V0KHQsZSxuLGkpO3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUoZSx0LGEsbyl9cmVzaGFwZVVucGFja2VkKGUsdCl7Y29uc3Qgbj10aGlzLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoZSxwLlRleHR1cmVUeXBlLnVucGFja2VkKSxyPXtjaGFubmVsczpuLmNoYW5uZWxzLGhlaWdodDpuLmhlaWdodCx3aWR0aDpuLndpZHRoLHNoYXBlOjAhPT10Lmxlbmd0aD90OlsxXSxzdHJpZGVzOmkuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHQpLHVucGFja2VkU2hhcGU6dH07cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZShyLGUudHlwZSxuLnRleHR1cmUpLnRlbnNvcn1yZXNoYXBlUGFja2VkKGUsdCl7Y29uc3Qgbj10aGlzLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoZSxwLlRleHR1cmVUeXBlLnBhY2tlZCk7aWYoKDAscy5pc1Jlc2hhcGVDaGVhcCkoZS5kaW1zLHQpKXtjb25zdCByPXtjaGFubmVsczpuLmNoYW5uZWxzLGhlaWdodDpuLmhlaWdodCx3aWR0aDpuLndpZHRoLHNoYXBlOjAhPT10Lmxlbmd0aD90OlsxXSxzdHJpZGVzOmkuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHQpLHVucGFja2VkU2hhcGU6dCxpc1BhY2tlZDohMH07cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZShyLGUudHlwZSxuLnRleHR1cmUpLnRlbnNvcn1jb25zdCByPSgwLHMucHJvY2Vzc0RpbXMzRCkoZS5kaW1zKSxvPSgwLHMucHJvY2Vzc0RpbXMzRCkodCksYT10aGlzLnJlc2hhcGVQYWNrZWQoZSxyKSx1PXRoaXMucnVuKCgwLHMuY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbUluZm9Mb2FkZXIpKHRoaXMsYSxvKSxbYV0pO3JldHVybiB0aGlzLnJlc2hhcGVQYWNrZWQodSx0KX1jYXN0KGUsdCl7Y29uc3Qgbj10aGlzLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoZSxwLlRleHR1cmVUeXBlLnVucGFja2VkKTtyZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKG4sdCxuLnRleHR1cmUpLnRlbnNvcn1jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKGUsdCxuLHIsaSl7Y29uc3QgYT1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse3RlbnNvcjpyfHxuZXcgby5UZW5zb3IoZS51bnBhY2tlZFNoYXBlLHQsKGU9PnRoaXMucmVhZFRleHR1cmUoYSkpLChhc3luYyBlPT50aGlzLnJlYWRUZXh0dXJlQXN5bmMoYSkpLHZvaWQgMCxpKSx0ZXh0dXJlOm59KTtyZXR1cm4gdGhpcy5zZXRUZXh0dXJlRGF0YShhLnRlbnNvci5kYXRhSWQsYSxlLmlzUGFja2VkKSxhfWdldFRleHR1cmVEYXRhKGUsdD0hMSl7cmV0dXJuIHRoaXMuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGUpP3RoaXMuc2Vzc2lvbi5nZXRUZXh0dXJlRGF0YShlLHQpOnQ/dGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldChlKTp0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQoZSl9c2V0VGV4dHVyZURhdGEoZSx0LG49ITEpe3RoaXMuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGUpP3RoaXMuc2Vzc2lvbi5zZXRUZXh0dXJlRGF0YShlLHQsbik6KG4/dGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlOnRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlKS5zZXQoZSx0KX1pc1RleHR1cmVMYXlvdXRDYWNoZWQoZSx0PSExKXtyZXR1cm4hIXRoaXMuZ2V0VGV4dHVyZURhdGEoZS5kYXRhSWQsdCl9ZGlzcG9zZSgpe3RoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5jbGVhckFjdGl2ZVRleHR1cmVzKCksdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2goKGU9PnRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZShlKSkpLHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwLHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2goKGU9PnRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZShlKSkpLHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXB9cmVhZFRleHR1cmUoZSl7cmV0dXJuIGUuaXNQYWNrZWQ/dGhpcy5yZWFkVGV4dHVyZSh0aGlzLnVucGFjayhlKSk6dGhpcy5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LmlzRmxvYXQzMkRvd25sb2FkU3VwcG9ydGVkP3RoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVGV4dHVyZShlLGUudGVuc29yLnR5cGUsZS5jaGFubmVscyk6dGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlYWRVaW50OFRleHR1cmVBc0Zsb2F0KCgwLHUuZW5jb2RlQXNVaW50OCkodGhpcyxlKSl9YXN5bmMgcmVhZFRleHR1cmVBc3luYyhlKXtyZXR1cm4gZS5pc1BhY2tlZD90aGlzLnJlYWRUZXh0dXJlQXN5bmModGhpcy51bnBhY2soZSkpOnRoaXMuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZD90aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmVBc3luYyhlLGUudGVuc29yLnR5cGUsZS5jaGFubmVscyk6dGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlYWRVaW50OFRleHR1cmVBc0Zsb2F0KCgwLHUuZW5jb2RlQXNVaW50OCkodGhpcyxlKSl9cGFjayhlKXtyZXR1cm4gdGhpcy5leGVjdXRlUHJvZ3JhbSgoMCxhLmNyZWF0ZVBhY2tQcm9ncmFtSW5mb0xvYWRlcikodGhpcyxlLnRlbnNvciksW2UudGVuc29yXSl9dW5wYWNrKGUpe3JldHVybiB0aGlzLmV4ZWN1dGVQcm9ncmFtKCgwLGwuY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm9Mb2FkZXIpKHRoaXMsZS50ZW5zb3IpLFtlLnRlbnNvcl0pfX19LDQxMTA6ZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQsbixyKXt2b2lkIDA9PT1yJiYocj1uKTt2YXIgbz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbik7byYmIShcImdldFwiaW4gbz8hdC5fX2VzTW9kdWxlOm8ud3JpdGFibGV8fG8uY29uZmlndXJhYmxlKXx8KG89e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbbl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixvKX06ZnVuY3Rpb24oZSx0LG4scil7dm9pZCAwPT09ciYmKHI9biksZVtyXT10W25dfSksbz10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSl9OmZ1bmN0aW9uKGUsdCl7ZS5kZWZhdWx0PXR9KSxpPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIG4gaW4gZSlcImRlZmF1bHRcIiE9PW4mJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pJiZyKHQsZSxuKTtyZXR1cm4gbyh0LGUpLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuV0VCR0xfT1BfUkVTT0xWRV9SVUxFUz12b2lkIDA7Y29uc3QgYT1uKDg4MTcpLHM9aShuKDUxOTQpKSx1PW4oNDc1MiksbD1uKDY2NjgpLGM9big5NzU0KSxwPW4oNTA0MiksZD1uKDY3NDIpLGY9big0MTI1KSxoPW4oNjE0OSksZz1uKDUzNzgpLG09big2OTgxKSxiPW4oNzQxMykseT1uKDcwMDYpLHc9big4Mjc2KSxfPW4oNTU2NSksdj1uKDI4MzQpLHg9bigxMDEwKSxUPW4oODEyNiksUz1uKDI4MDEpLE89big1NjUpLEE9bigyNDQ0KSxFPW4oODE1KSxJPW4oNTY0KSwkPW4oNTQxNiksUD1uKDEyNDApLEQ9big1OTQ0KSxrPW4oNTcwNyksQz1pKG4oOTA4NykpLFI9big3ODYyKSxNPW4oMzk4MCk7dC5XRUJHTF9PUF9SRVNPTFZFX1JVTEVTPVtbXCJBYnNcIixcIlwiLFwiNitcIixDLmFic10sW1wiQWNvc1wiLFwiXCIsXCI3K1wiLEMuYWNvc10sW1wiQWRkXCIsXCJcIixcIjcrXCIscy5hZGRdLFtcIkFuZFwiLFwiXCIsXCI3K1wiLHMuYW5kXSxbXCJBc2luXCIsXCJcIixcIjcrXCIsQy5hc2luXSxbXCJBdGFuXCIsXCJcIixcIjcrXCIsQy5hdGFuXSxbXCJBdmVyYWdlUG9vbFwiLFwiXCIsXCI3K1wiLHYuYXZlcmFnZVBvb2wsdi5wYXJzZUF2ZXJhZ2VQb29sQXR0cmlidXRlc10sW1wiQmF0Y2hOb3JtYWxpemF0aW9uXCIsXCJcIixcIjcrXCIsYS5iYXRjaE5vcm1hbGl6YXRpb24sYS5wYXJzZUJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXNdLFtcIkNhc3RcIixcIlwiLFwiNitcIix1LmNhc3QsdS5wYXJzZUNhc3RBdHRyaWJ1dGVzXSxbXCJDZWlsXCIsXCJcIixcIjYrXCIsQy5jZWlsXSxbXCJDbGlwXCIsXCJcIixcIjYtMTBcIixDLmNsaXAsQy5wYXJzZUNsaXBBdHRyaWJ1dGVzXSxbXCJDbGlwXCIsXCJcIixcIjExK1wiLEMuY2xpcFYxMV0sW1wiQ29uY2F0XCIsXCJcIixcIjQrXCIsbC5jb25jYXQsbC5wYXJzZUNvbmNhdEF0dHJpYnV0ZXNdLFtcIkNvbnZcIixcIlwiLFwiMStcIixjLmNvbnYsYy5wYXJzZUNvbnZBdHRyaWJ1dGVzXSxbXCJDb252VHJhbnNwb3NlXCIsXCJcIixcIjErXCIscC5jb252VHJhbnNwb3NlLHAucGFyc2VDb252VHJhbnNwb3NlQXR0cmlidXRlc10sW1wiQ29zXCIsXCJcIixcIjcrXCIsQy5jb3NdLFtcIkRpdlwiLFwiXCIsXCI3K1wiLHMuZGl2XSxbXCJEcm9wb3V0XCIsXCJcIixcIjcrXCIsQy5pZGVudGl0eV0sW1wiRGVwdGhUb1NwYWNlXCIsXCJcIixcIjErXCIsZC5kZXB0aFRvU3BhY2UsZC5wYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXNdLFtcIkVxdWFsXCIsXCJcIixcIjcrXCIscy5lcXVhbF0sW1wiRWx1XCIsXCJcIixcIjYrXCIsQy5lbHUsQy5wYXJzZUVsdUF0dHJpYnV0ZXNdLFtcIkV4cFwiLFwiXCIsXCI2K1wiLEMuZXhwXSxbXCJGbGF0dGVuXCIsXCJcIixcIjErXCIsZi5mbGF0dGVuLGYucGFyc2VGbGF0dGVuQXR0cmlidXRlc10sW1wiRmxvb3JcIixcIlwiLFwiNitcIixDLmZsb29yXSxbXCJGdXNlZENvbnZcIixcImNvbS5taWNyb3NvZnRcIixcIjErXCIsYy5jb252LGMucGFyc2VDb252QXR0cmlidXRlc10sW1wiR2F0aGVyXCIsXCJcIixcIjErXCIsaC5nYXRoZXIsaC5wYXJzZUdhdGhlckF0dHJpYnV0ZXNdLFtcIkdlbW1cIixcIlwiLFwiNy0xMFwiLGcuZ2VtbSxnLnBhcnNlR2VtbUF0dHJpYnV0ZXNWN10sW1wiR2VtbVwiLFwiXCIsXCIxMStcIixnLmdlbW0sZy5wYXJzZUdlbW1BdHRyaWJ1dGVzVjExXSxbXCJHbG9iYWxBdmVyYWdlUG9vbFwiLFwiXCIsXCIxK1wiLHYuZ2xvYmFsQXZlcmFnZVBvb2wsdi5wYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlc10sW1wiR2xvYmFsTWF4UG9vbFwiLFwiXCIsXCIxK1wiLHYuZ2xvYmFsTWF4UG9vbF0sW1wiR3JlYXRlclwiLFwiXCIsXCI3K1wiLHMuZ3JlYXRlcl0sW1wiSWRlbnRpdHlcIixcIlwiLFwiMStcIixDLmlkZW50aXR5XSxbXCJJbWFnZVNjYWxlclwiLFwiXCIsXCIxK1wiLG0uaW1hZ2VTY2FsZXIsbS5wYXJzZUltYWdlU2NhbGVyQXR0cmlidXRlc10sW1wiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsXCJcIixcIjYrXCIsYi5pbnN0YW5jZU5vcm1hbGl6YXRpb24sYi5wYXJzZUluc3RhbmNlTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXNdLFtcIkxlYWt5UmVsdVwiLFwiXCIsXCI2K1wiLEMubGVha3lSZWx1LEMucGFyc2VMZWFreVJlbHVBdHRyaWJ1dGVzXSxbXCJMZXNzXCIsXCJcIixcIjcrXCIscy5sZXNzXSxbXCJMUk5cIixcIlwiLFwiMStcIix5Lmxybix5LnBhcnNlTHJuQXR0cmlidXRlc10sW1wiTG9nXCIsXCJcIixcIjYrXCIsQy5sb2ddLFtcIk1hdE11bFwiLFwiXCIsXCIxK1wiLHcubWF0TXVsLHcucGFyc2VNYXRNdWxBdHRyaWJ1dGVzXSxbXCJNYXhQb29sXCIsXCJcIixcIjErXCIsdi5tYXhQb29sLHYucGFyc2VNYXhQb29sQXR0cmlidXRlc10sW1wiTXVsXCIsXCJcIixcIjcrXCIscy5tdWxdLFtcIk5lZ1wiLFwiXCIsXCI2K1wiLEMubmVnXSxbXCJOb3RcIixcIlwiLFwiMStcIixDLm5vdF0sW1wiT3JcIixcIlwiLFwiNytcIixzLm9yXSxbXCJQYWRcIixcIlwiLFwiMi0xMFwiLF8ucGFkVjIsXy5wYXJzZVBhZEF0dHJpYnV0ZXNWMl0sW1wiUGFkXCIsXCJcIixcIjExK1wiLF8ucGFkVjExLF8ucGFyc2VQYWRBdHRyaWJ1dGVzVjExXSxbXCJQb3dcIixcIlwiLFwiNytcIixzLnBvd10sW1wiUFJlbHVcIixcIlwiLFwiNytcIixzLnBSZWx1XSxbXCJSZWR1Y2VMb2dTdW1cIixcIlwiLFwiMStcIix4LnJlZHVjZUxvZ1N1bSx4LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlTWF4XCIsXCJcIixcIjErXCIseC5yZWR1Y2VNYXgseC5wYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFtcIlJlZHVjZU1lYW5cIixcIlwiLFwiMStcIix4LnJlZHVjZU1lYW4seC5wYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFtcIlJlZHVjZU1pblwiLFwiXCIsXCIxK1wiLHgucmVkdWNlTWluLHgucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxbXCJSZWR1Y2VQcm9kXCIsXCJcIixcIjErXCIseC5yZWR1Y2VQcm9kLHgucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxbXCJSZWR1Y2VTdW1cIixcIlwiLFwiMS0xMlwiLHgucmVkdWNlU3VtLHgucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxbXCJSZWR1Y2VTdW1TcXVhcmVcIixcIlwiLFwiMStcIix4LnJlZHVjZUxvZ1N1bVNxdWFyZSx4LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVsdVwiLFwiXCIsXCI2K1wiLEMucmVsdV0sW1wiUmVzaGFwZVwiLFwiXCIsXCI1K1wiLFQucmVzaGFwZV0sW1wiUmVzaXplXCIsXCJcIixcIjEwXCIsUy5yZXNpemUsUy5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTBdLFtcIlJlc2l6ZVwiLFwiXCIsXCIxMStcIixTLnJlc2l6ZSxTLnBhcnNlUmVzaXplQXR0cmlidXRlc1YxMV0sW1wiU2hhcGVcIixcIlwiLFwiMStcIixPLnNoYXBlXSxbXCJTaWdtb2lkXCIsXCJcIixcIjYrXCIsQy5zaWdtb2lkXSxbXCJTaW5cIixcIlwiLFwiNytcIixDLnNpbl0sW1wiU2xpY2VcIixcIlwiLFwiMTArXCIsQS5zbGljZVYxMF0sW1wiU2xpY2VcIixcIlwiLFwiMS05XCIsQS5zbGljZSxBLnBhcnNlU2xpY2VBdHRyaWJ1dGVzXSxbXCJTb2Z0bWF4XCIsXCJcIixcIjEtMTJcIixFLnNvZnRtYXgsRS5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzXSxbXCJTb2Z0bWF4XCIsXCJcIixcIjEzK1wiLEUuc29mdG1heFYxMyxFLnBhcnNlU29mdG1heEF0dHJpYnV0ZXNWMTNdLFtcIlNwbGl0XCIsXCJcIixcIjItMTJcIixJLnNwbGl0LEkucGFyc2VTcGxpdEF0dHJpYnV0ZXNdLFtcIlNxcnRcIixcIlwiLFwiNitcIixDLnNxcnRdLFtcIlNxdWVlemVcIixcIlwiLFwiMS0xMlwiLCQuc3F1ZWV6ZSwkLnBhcnNlU3F1ZWV6ZUF0dHJpYnV0ZXNdLFtcIlNxdWVlemVcIixcIlwiLFwiMTMrXCIsJC5zcXVlZXplVjEzXSxbXCJTdWJcIixcIlwiLFwiNytcIixzLnN1Yl0sW1wiU3VtXCIsXCJcIixcIjYrXCIsUC5zdW1dLFtcIlRhblwiLFwiXCIsXCI3K1wiLEMudGFuXSxbXCJUYW5oXCIsXCJcIixcIjYrXCIsQy50YW5oXSxbXCJUaWxlXCIsXCJcIixcIjYrXCIsRC50aWxlXSxbXCJUcmFuc3Bvc2VcIixcIlwiLFwiMStcIixrLnRyYW5zcG9zZSxrLnBhcnNlVHJhbnNwb3NlQXR0cmlidXRlc10sW1wiVXBzYW1wbGVcIixcIlwiLFwiNy04XCIsTS51cHNhbXBsZSxNLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzVjddLFtcIlVwc2FtcGxlXCIsXCJcIixcIjlcIixNLnVwc2FtcGxlLE0ucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWOV0sW1wiVW5zcXVlZXplXCIsXCJcIixcIjEtMTJcIixSLnVuc3F1ZWV6ZSxSLnBhcnNlVW5zcXVlZXplQXR0cmlidXRlc10sW1wiVW5zcXVlZXplXCIsXCJcIixcIjEzK1wiLFIudW5zcXVlZXplVjEzXSxbXCJYb3JcIixcIlwiLFwiNytcIixzLnhvcl1dfSw4ODE3OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlQmF0Y2hOb3JtYWxpemF0aW9uQXR0cmlidXRlcz10LmJhdGNoTm9ybWFsaXphdGlvbj12b2lkIDA7Y29uc3Qgcj1uKDQ5MTApLG89big2NzU3KSxpPW4oNTYzOSksYT17bmFtZTpcIkJhdGNoTm9ybWFsaXphdGlvblwiLGlucHV0TmFtZXM6W1wiQVwiLFwiU2NhbGVcIixcIkJcIixcIk1lYW5cIixcIlZhcmlhbmNlXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O3QuYmF0Y2hOb3JtYWxpemF0aW9uPShlLHQsbik9Pih1KHQpLFtlLnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+cyhlLHQsbil9KSx0KV0pLHQucGFyc2VCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzPWU9Pntjb25zdCB0PWUuYXR0cmlidXRlcy5nZXRGbG9hdChcImVwc2lsb25cIiwxZS01KSxuPWUuYXR0cmlidXRlcy5nZXRGbG9hdChcIm1vbWVudHVtXCIsLjkpLG89ZS5hdHRyaWJ1dGVzLmdldEludChcInNwYXRpYWxcIiwxKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2Vwc2lsb246dCxtb21lbnR1bTpuLHNwYXRpYWw6b30pfTtjb25zdCBzPShlLHQsbik9Pntjb25zdCByPSgwLG8uZ2V0R2xzbCkoZS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLHM9dFswXS5kaW1zLmxlbmd0aCxbdSxsXT1lLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh0WzFdLmRpbXMsaS5UZXh0dXJlVHlwZS51bnBhY2tlZCksYz1gXFxuICBmbG9hdCBwcm9jZXNzKGludFske3N9XSBpbmRpY2VzKSB7XFxuICAgIHZlYzIgcG9zaXRpb24gPSBvZmZzZXRUb0Nvb3JkcyhpbmRpY2VzWzFdLCAke3V9LCAke2x9KTtcXG4gICAgZmxvYXQgc2NhbGUgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oU2NhbGUsIHBvc2l0aW9uKSk7XFxuICAgIGZsb2F0IG1lYW4gPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oTWVhbiwgcG9zaXRpb24pKTtcXG4gICAgZmxvYXQgdmFyaWFuY2UgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oVmFyaWFuY2UsIHBvc2l0aW9uKSk7XFxuICAgIGZsb2F0IGIgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oQiwgcG9zaXRpb24pKTtcXG5cXG4gICAgcmV0dXJuIHNjYWxlICogKCAoX0EoaW5kaWNlcykgLSBtZWFuKSAvIHNxcnQodmFyaWFuY2UgKyBmbG9hdCgke24uZXBzaWxvbn0pKSApICsgYjtcXG4gIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse291dHB1dDp7ZGltczp0WzBdLmRpbXMsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmN9KX0sdT1lPT57aWYoIWV8fDUhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaE5vcm1hbGl6YXRpb24gcmVxdWlyZXMgNSBpbnB1dHMuXCIpO2NvbnN0IHQ9ZVswXSxuPWVbMV0scj1lWzJdLG89ZVszXSxpPWVbNF07aWYodC5kaW1zLmxlbmd0aDwzfHwxIT09bi5kaW1zLmxlbmd0aHx8MSE9PXIuZGltcy5sZW5ndGh8fDEhPT1vLmRpbXMubGVuZ3RofHwxIT09aS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHNoYXBlLlwiKTtpZihuLmRpbXNbMF0hPT10LmRpbXNbMV18fHIuZGltc1swXSE9PXQuZGltc1sxXXx8by5kaW1zWzBdIT09dC5kaW1zWzFdfHxpLmRpbXNbMF0hPT10LmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYoXCJmbG9hdDMyXCIhPT10LnR5cGUmJlwiZmxvYXQ2NFwiIT09dC50eXBlfHxcImZsb2F0MzJcIiE9PW4udHlwZSYmXCJmbG9hdDY0XCIhPT1uLnR5cGV8fFwiZmxvYXQzMlwiIT09ci50eXBlJiZcImZsb2F0NjRcIiE9PXIudHlwZXx8XCJmbG9hdDMyXCIhPT1vLnR5cGUmJlwiZmxvYXQ2NFwiIT09by50eXBlfHxcImZsb2F0MzJcIiE9PWkudHlwZSYmXCJmbG9hdDY0XCIhPT1pLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfX0sNTE5NDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC54b3I9dC5zdWI9dC5wUmVsdT10LnBvdz10Lm9yPXQubXVsPXQubGVzcz10LmdyZWF0ZXI9dC5lcXVhbD10LmRpdj10LmFuZD10LmFkZD10Lmdsc2xQUmVsdT10Lmdsc2xQb3c9dC5nbHNsWG9yPXQuZ2xzbE9yPXQuZ2xzbEFuZD10Lmdsc2xMZXNzPXQuZ2xzbEdyZWF0ZXI9dC5nbHNsRXF1YWw9dC5nbHNsU3ViPXQuZ2xzbE11bD10Lmdsc2xEaXY9dC5nbHNsQWRkPXZvaWQgMDtjb25zdCByPW4oNzI3Myksbz1uKDE5OTcpLGk9big2NzU3KSxhPW4oNTYzOSk7ZnVuY3Rpb24gcygpe2NvbnN0IGU9XCJhZGRfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBhICsgYjtcXG4gIH1cXG4gIHZlYzQgJHtlfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2MSArIHYyO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiB1KCl7Y29uc3QgZT1cImRpdl9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGEgLyBiO1xcbiAgfVxcbiAgdmVjNCAke2V9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgcmV0dXJuIHYxIC8gdjI7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGwoKXtjb25zdCBlPVwibXVsX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gYSAqIGI7XFxuICB9XFxuICB2ZWM0ICR7ZX0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdjEgKiB2MjtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gYygpe2NvbnN0IGU9XCJzdWJfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBhIC0gYjtcXG4gIH1cXG4gIHZlYzQgJHtlfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2MSAtIHYyO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBwKCl7Y29uc3QgZT1cImVxdWFsX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gZmxvYXQoYSA9PSBiKTtcXG4gIH1cXG4gIHZlYzQgJHtlfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KGVxdWFsKHYxLCB2MikpO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBkKCl7Y29uc3QgZT1cImdyZWF0ZXJfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdChhID4gYik7XFxuICB9XFxuICB2ZWM0ICR7ZX0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdmVjNCggdjEuciA+IHYyLnIgLFxcbiAgICAgIHYxLmcgPiB2Mi5nLFxcbiAgICAgIHYxLmIgPiB2Mi5iLFxcbiAgICAgIHYxLmEgPiB2Mi5hICk7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGYoKXtjb25zdCBlPVwibGVzc19cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGZsb2F0KGEgPCBiKTtcXG4gIH1cXG4gIHZlYzQgJHtlfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KCB2MS5yIDwgdjIuciAsXFxuICAgICAgICAgICAgICAgIHYxLmcgPCB2Mi5nLFxcbiAgICAgICAgICAgICAgICB2MS5iIDwgdjIuYixcXG4gICAgICAgICAgICAgICAgdjEuYSA8IHYyLmEgKTtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gaCgpe2NvbnN0IGU9XCJhbmRfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSAmJiBib29sKGIpICk7XFxuICB9XFxuICB2ZWM0ICR7ZX0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcXG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XFxuICAgIHJldHVybiB2ZWM0KCBiMS5yICYmIGIyLnIgLFxcbiAgICAgICAgICAgICAgICBiMS5nICYmIGIyLmcsXFxuICAgICAgICAgICAgICAgIGIxLmIgJiYgYjIuYixcXG4gICAgICAgICAgICAgICAgYjEuYSAmJiBiMi5hICk7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGcoKXtjb25zdCBlPVwib3JfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSB8fCBib29sKGIpICk7XFxuICB9XFxuICB2ZWM0ICR7ZX0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcXG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XFxuICAgIHJldHVybiB2ZWM0KCBiMS5yIHx8IGIyLnIgLFxcbiAgICAgICAgICAgICAgICBiMS5nIHx8IGIyLmcsXFxuICAgICAgICAgICAgICAgIGIxLmIgfHwgYjIuYixcXG4gICAgICAgICAgICAgICAgYjEuYSB8fCBiMi5hICk7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIG0oKXtjb25zdCBlPVwieG9yX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gZmxvYXQoIGJvb2woYSkgXl4gYm9vbChiKSApO1xcbiAgfVxcbiAgdmVjNCAke2V9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgYnZlYzQgYjEgPSBidmVjNCh2MSk7XFxuICAgIGJ2ZWM0IGIyID0gYnZlYzQodjIpO1xcbiAgICByZXR1cm4gdmVjNCggYjEuciBeXiBiMi5yICxcXG4gICAgICAgICAgICAgICAgYjEuZyBeXiBiMi5nLFxcbiAgICAgICAgICAgICAgICBiMS5iIF5eIGIyLmIsXFxuICAgICAgICAgICAgICAgIGIxLmEgXl4gYjIuYSApO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBiKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2NvbnN0IHQ9YCR7ZX1fYDtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke3R9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuICR7ZX0oYSwgYik7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gJHtlfSh2MSwgdjIpO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX0oXCJwb3dcIil9ZnVuY3Rpb24geSgpe2NvbnN0IGU9XCJwcmVsdV9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGEgPCAwLjAgPyBhICogYjogYTtcXG4gIH1cXG4gIHZlYzQgJHtlfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KFxcbiAgICAgIHYxLnIgPCAwLjAgPyB2MS5yICogdjIucjogdjEucixcXG4gICAgICB2MS5nIDwgMC4wID8gdjEuZyAqIHYyLmc6IHYxLmcsXFxuICAgICAgdjEuYiA8IDAuMCA/IHYxLmIgKiB2Mi5iOiB2MS5iLFxcbiAgICAgIHYxLmEgPCAwLjAgPyB2MS5hICogdjIuYTogdjEuYVxcbiAgICAgICk7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fXQuZ2xzbEFkZD1zLHQuZ2xzbERpdj11LHQuZ2xzbE11bD1sLHQuZ2xzbFN1Yj1jLHQuZ2xzbEVxdWFsPXAsdC5nbHNsR3JlYXRlcj1kLHQuZ2xzbExlc3M9Zix0Lmdsc2xBbmQ9aCx0Lmdsc2xPcj1nLHQuZ2xzbFhvcj1tLHQuZ2xzbFBvdz1iLHQuZ2xzbFBSZWx1PXk7Y29uc3Qgdz0oZSx0LG4scj10WzBdLnR5cGUsbyk9Pntjb25zdCBpPWUuc2Vzc2lvbi5wYWNrP2EuVGV4dHVyZVR5cGUucGFja2VkOmEuVGV4dHVyZVR5cGUudW5wYWNrZWQ7cmV0dXJue25hbWU6bi5uYW1lLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOltpLGldLGNhY2hlSGludDpvLGdldDooKT0+XyhlLHQsbixyKX19LF89KGUsdCxuLG89dFswXS50eXBlKT0+e2NvbnN0IHM9ZS5zZXNzaW9uLnBhY2s/YS5UZXh0dXJlVHlwZS5wYWNrZWQ6YS5UZXh0dXJlVHlwZS51bnBhY2tlZCx1PSFyLlNoYXBlVXRpbC5hcmVFcXVhbCh0WzBdLmRpbXMsdFsxXS5kaW1zKTtsZXQgbD10WzBdLmRpbXM7Y29uc3QgYz1lLnNlc3Npb24ucGFjaztpZih1KXtjb25zdCBhPXIuQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUodFswXS5kaW1zLHRbMV0uZGltcywhMSk7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bD1hO2NvbnN0IHU9bC5sZW5ndGgscD0wIT09dFswXS5kaW1zLmxlbmd0aD90WzBdLmRpbXMubGVuZ3RoOjEsZD0wIT09dFsxXS5kaW1zLmxlbmd0aD90WzFdLmRpbXMubGVuZ3RoOjEsZj0wIT09dFswXS5kaW1zLmxlbmd0aD9cImJjYXN0SW5kaWNlc19BKGluZGljZXMsIGFpbmRpY2VzKTtcIjpcImFpbmRpY2VzWzBdID0gMDtcIixoPTAhPT10WzFdLmRpbXMubGVuZ3RoP1wiYmNhc3RJbmRpY2VzX0IoaW5kaWNlcywgYmluZGljZXMpO1wiOlwiYmluZGljZXNbMF0gPSAwO1wiLGc9KDAsaS5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksbT1jP2BcXG4gICAgICAke24uYm9keX1cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgYiA9IGdldEJBdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke24ubmFtZX0oYSwgYik7XFxuICAgICAgICAke2cub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9YDpgXFxuICAgICAgJHtuLmJvZHl9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3V9XSkge1xcbiAgICAgICAgaW50IGFpbmRpY2VzWyR7cH1dO1xcbiAgICAgICAgaW50IGJpbmRpY2VzWyR7ZH1dO1xcbiAgICAgICAgJHtmfVxcbiAgICAgICAgJHtofVxcbiAgICAgICAgcmV0dXJuICR7bi5uYW1lfShfQShhaW5kaWNlcyksIF9CKGJpbmRpY2VzKSk7XFxuICAgICAgfWA7cmV0dXJue25hbWU6bi5uYW1lLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOltzLHNdLG91dHB1dDp7ZGltczpsLHR5cGU6byx0ZXh0dXJlVHlwZTpzfSxzaGFkZXJTb3VyY2U6bSxoYXNNYWluOmN9fWNvbnN0IHA9KDAsaS5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksZD1gXFxuICAgICR7bi5ib2R5fVxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgdmVjNCB2MSA9ICR7cC50ZXh0dXJlMkR9KEEsIFRleENvb3Jkcyk7XFxuICAgICAgdmVjNCB2MiA9ICR7cC50ZXh0dXJlMkR9KEIsIFRleENvb3Jkcyk7XFxuICAgICAgdmVjNCByZXN1bHQgPSAke24ubmFtZX0odjEsIHYyKTtcXG4gICAgICAke3Aub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgfVxcbiAgICBgO3JldHVybntuYW1lOm4ubmFtZSxpbnB1dE5hbWVzOltcIkFcIixcIkJcIl0saW5wdXRUeXBlczpbcyxzXSxvdXRwdXQ6e2RpbXM6dFswXS5kaW1zLHR5cGU6byx0ZXh0dXJlVHlwZTpzfSxzaGFkZXJTb3VyY2U6ZCxoYXNNYWluOiEwfX07dC5hZGQ9KGUsdCk9PltlLnJ1bih3KGUsdCxzKCkpLHQpXSx0LmFuZD0oZSx0KT0+W2UucnVuKHcoZSx0LGgoKSxcImJvb2xcIiksdCldLHQuZGl2PShlLHQpPT5bZS5ydW4odyhlLHQsdSgpKSx0KV0sdC5lcXVhbD0oZSx0KT0+W2UucnVuKHcoZSx0LHAoKSxcImJvb2xcIiksdCldLHQuZ3JlYXRlcj0oZSx0KT0+W2UucnVuKHcoZSx0LGQoKSxcImJvb2xcIiksdCldLHQubGVzcz0oZSx0KT0+W2UucnVuKHcoZSx0LGYoKSxcImJvb2xcIiksdCldLHQubXVsPShlLHQpPT5bZS5ydW4odyhlLHQsbCgpKSx0KV0sdC5vcj0oZSx0KT0+W2UucnVuKHcoZSx0LGcoKSxcImJvb2xcIiksdCldLHQucG93PShlLHQpPT5bZS5ydW4odyhlLHQsYigpKSx0KV0sdC5wUmVsdT0oZSx0KT0+W2UucnVuKHcoZSx0LHkoKSksdCldLHQuc3ViPShlLHQpPT5bZS5ydW4odyhlLHQsYygpKSx0KV0sdC54b3I9KGUsdCk9PltlLnJ1bih3KGUsdCxtKCksXCJib29sXCIpLHQpXX0sNDc1MjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZUNhc3RBdHRyaWJ1dGVzPXQuY2FzdD12b2lkIDA7Y29uc3Qgcj1uKDcyNzMpO3QuY2FzdD0oZSx0LG4pPT4obyh0KSxbZS5jYXN0KHRbMF0sbildKSx0LnBhcnNlQ2FzdEF0dHJpYnV0ZXM9ZT0+ci5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8oZS5hdHRyaWJ1dGVzLmdldEludChcInRvXCIpKTtjb25zdCBvPWU9PntpZighZXx8MSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNhc3QgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoXCJzdHJpbmdcIj09PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0sNDU5NTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5jcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDY3NTcpLG89big1NjM5KSxpPW4oNDMyKSxhPW4oNTYxNCk7dC5jcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mb0xvYWRlcj0oZSx0LG4pPT57Y29uc3QgdT0obD10Lmxlbmd0aCxjPW4uY2FjaGVLZXkse25hbWU6XCJDb25jYXQgKHBhY2tlZClcIixpbnB1dE5hbWVzOkFycmF5LmZyb20oe2xlbmd0aDpsfSwoKGUsdCk9PmBYJHt0fWApKSxpbnB1dFR5cGVzOkFycmF5KGwpLmZpbGwoby5UZXh0dXJlVHlwZS5wYWNrZWQpLGNhY2hlSGludDpjfSk7dmFyIGwsYztyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtnZXQ6KCk9PigoZSx0LG4sdSk9Pntjb25zdCBsPW5bMF0uZGltcy5zbGljZSgpO2lmKHU+PWwubGVuZ3RofHx1PC0xKmwubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImF4aXMgc3BlY2lmaWVkIGZvciBjb25jYXQgZG9lc24ndCBtYXRjaCBpbnB1dCBkaW1lbnNpb25hbGl0eVwiKTt1PDAmJih1PWwubGVuZ3RoK3UpO2NvbnN0IGM9bC5zbGljZSgwKTtmb3IobGV0IGU9MTtlPG4ubGVuZ3RoO2UrKyl7Y29uc3QgdD1uW2VdLmRpbXMuc2xpY2UoKTtmb3IobGV0IGU9MDtlPGwubGVuZ3RoO2UrKylpZihlPT09dSljW3VdKz10W2VdO2Vsc2UgaWYobFtlXSE9PXRbZV0pdGhyb3cgbmV3IEVycm9yKFwibm9uIGNvbmNhdCBkaW1lbnNpb25zIG11c3QgbWF0Y2hcIil9Y29uc3QgcD1jLmxlbmd0aCxkPSgwLGEuZ2V0Q2hhbm5lbHMpKFwiY29vcmRzXCIscCksZj0oMCxpLmdldENvb3Jkc0RhdGFUeXBlKShwKSxoPSgwLGEudW5wYWNrRnJvbUNoYW5uZWwpKCksZz1uLm1hcCgoZT0+ZS5kaW1zKSksbT0oMCxpLmdldEdsQ2hhbm5lbHMpKHApLGI9bmV3IEFycmF5KGcubGVuZ3RoLTEpO2JbMF09Z1swXVt1XTtmb3IobGV0IGU9MTtlPGIubGVuZ3RoO2UrKyliW2VdPWJbZS0xXStnW2VdW3VdO2NvbnN0IHk9bVt1XSx3PW0uc2xpY2UoLTIpLF89bS5qb2luKCk7bGV0IHY9YGlmICgke3l9IDwgJHtiWzBdfSkge1xcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXFxuICAgICAgICAgICAgZ2V0WDAoJHtffSksIHZlYzIoJHt3LmpvaW4oKX0pKTtcXG4gICAgICAgIH1gO2ZvcihsZXQgZT0xO2U8Yi5sZW5ndGg7ZSsrKXtjb25zdCB0PWJbZS0xXTt2Kz1gXFxuICAgICAgICAgICAgaWYgKCR7eX0gPCAke2JbZV19ICAmJiAke3l9ID49ICR7YltlLTFdfSkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXFxuICAgICAgICAgICAgICAgIGdldFgke2V9KCR7cyhtLHksdCl9KSxcXG4gICAgICAgICAgICAgICAgdmVjMigke3Modyx5LHQpfSkpO1xcbiAgICAgICAgICAgIH1gfWNvbnN0IHg9Yi5sZW5ndGgsVD1iW2IubGVuZ3RoLTFdO3YrPWBcXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICAgIGdldFgke3h9KCR7cyhtLHksVCl9KSxcXG4gICAgICAgICAgICAgIHZlYzIoJHtzKHcseSxUKX0pKTtgO2NvbnN0IFM9KDAsci5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksTz1gXFxuICAgICAgICAgICR7aH1cXG4gICAgICAgICAgZmxvYXQgZ2V0VmFsdWUoJHttLm1hcCgoZT0+XCJpbnQgXCIrZSkpfSkge1xcbiAgICAgICAgICAgICR7dn1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICAgJHtmfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgICBpbnQgbGFzdERpbSA9IGNvb3Jkcy4ke21bcC0xXX07XFxuICAgICAgICAgICAgY29vcmRzLiR7bVtwLTFdfSA9IGNvb3Jkcy4ke21bcC0yXX07XFxuICAgICAgICAgICAgY29vcmRzLiR7bVtwLTJdfSA9IGxhc3REaW07XFxuXFxuICAgICAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KGdldFZhbHVlKCR7ZH0pLCAwLiwgMC4sIDAuKTtcXG5cXG4gICAgICAgICAgICAke2RbcC0xXX0gPSAke2RbcC0xXX0gKyAxO1xcbiAgICAgICAgICAgIGlmICgke2RbcC0xXX0gPCAke2NbcC0xXX0pIHtcXG4gICAgICAgICAgICAgIHJlc3VsdC5nID0gZ2V0VmFsdWUoJHtkfSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICR7ZFtwLTJdfSA9ICR7ZFtwLTJdfSArIDE7XFxuICAgICAgICAgICAgaWYgKCR7ZFtwLTJdfSA8ICR7Y1twLTJdfSkge1xcbiAgICAgICAgICAgICAgcmVzdWx0LmEgPSBnZXRWYWx1ZSgke2R9KTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgJHtkW3AtMV19ID0gJHtkW3AtMV19IC0gMTtcXG4gICAgICAgICAgICBpZiAoJHtkW3AtMl19IDwgJHtjW3AtMl19ICYmXFxuICAgICAgICAgICAgICAgICR7ZFtwLTFdfSA8ICR7Y1twLTFdfSkge1xcbiAgICAgICAgICAgICAgcmVzdWx0LmIgPSBnZXRWYWx1ZSgke2R9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgJHtTLm91dHB1dH0gPSByZXN1bHQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7b3V0cHV0OntkaW1zOmMsdHlwZTpuWzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS5wYWNrZWR9LHNoYWRlclNvdXJjZTpPLGhhc01haW46ITB9KX0pKGUsdSx0LG4uYXhpcyl9KX07Y29uc3Qgcz0oZSx0LG4pPT57Y29uc3Qgcj1lLmluZGV4T2YodCk7cmV0dXJuIGUubWFwKCgoZSx0KT0+dD09PXI/YCR7ZX0gLSAke259YDplKSkuam9pbigpfX0sNjY2ODooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZUNvbmNhdEF0dHJpYnV0ZXM9dC5jb25jYXQ9dm9pZCAwO2NvbnN0IHI9big0OTEwKSxvPW4oNTYzOSksaT1uKDQ1OTUpO3QuY29uY2F0PShlLHQsbik9PihwKHQpLGUuc2Vzc2lvbi5wYWNrJiZ0WzBdLmRpbXMubGVuZ3RoPjE/W2UucnVuKCgwLGkuY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXIpKGUsdCxuKSx0KV06W2UucnVuKGEoZSx0LG4pLHQpXSk7Y29uc3QgYT0oZSx0LG4pPT57Y29uc3Qgcj0oaT10Lmxlbmd0aCxhPW4uY2FjaGVLZXkse25hbWU6XCJDb25jYXRcIixpbnB1dE5hbWVzOkFycmF5LmZyb20oe2xlbmd0aDppfSwoKGUsdCk9PmBYJHt0fWApKSxpbnB1dFR5cGVzOkFycmF5KGkpLmZpbGwoby5UZXh0dXJlVHlwZS51bnBhY2tlZCksY2FjaGVIaW50OmF9KTt2YXIgaSxhO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+KChlLHQsbixyKT0+e2NvbnN0IGk9blswXS5kaW1zLnNsaWNlKCk7aWYocj49aS5sZW5ndGh8fHI8LTEqaS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhpcyBzcGVjaWZpZWQgZm9yIGNvbmNhdCBkb2Vzbid0IG1hdGNoIGlucHV0IGRpbWVuc2lvbmFsaXR5XCIpO3I8MCYmKHI9aS5sZW5ndGgrcik7Y29uc3QgYT1pLnNsaWNlKDApO2ZvcihsZXQgZT0xO2U8bi5sZW5ndGg7ZSsrKXtjb25zdCB0PW5bZV0uZGltcy5zbGljZSgpO2ZvcihsZXQgZT0wO2U8aS5sZW5ndGg7ZSsrKWlmKGU9PT1yKWFbcl0rPXRbZV07ZWxzZSBpZihpW2VdIT09dFtlXSl0aHJvdyBuZXcgRXJyb3IoXCJub24gY29uY2F0IGRpbWVuc2lvbnMgbXVzdCBtYXRjaFwiKX1jb25zdCBwPWEubGVuZ3RoLGQ9bmV3IEFycmF5KG4ubGVuZ3RoKTtsZXQgZj0wO2ZvcihsZXQgZT0wO2U8ZC5sZW5ndGg7KytlKWYrPW5bZV0uZGltc1tyXSxkW2VdPWY7bGV0IGg9XCJcIjtoPW4ubGVuZ3RoPDU/cyhkKTp1KGQpO2NvbnN0IGc9YFxcbiAgICAgICAgJHtsKG4ubGVuZ3RoLHApfVxcbiAgICAgICAgJHtjKGQpfVxcbiAgICAgICAgJHtofVxcbiAgICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3B9XSkge1xcbiAgICAgICAgICBpbnQgdGV4dHVyZUluZGV4ID0gZ2V0VGV4dHVyZVdoZXJlRGF0YVJlc2lkZXMgKGluZGljZXNbJHtyfV0pO1xcblxcbiAgICAgICAgICBpZih0ZXh0dXJlSW5kZXggIT0gMCkge1xcbiAgICAgICAgICAgIGluZGljZXNbJHtyfV0gPSBpbmRpY2VzWyR7cn1dIC0gaW50KGdldFNpemVJbkNvbmNhdEF4aXNWYWx1ZUZyb21JbmRleCh0ZXh0dXJlSW5kZXgtaW50KDEpKSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIGZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZSh0ZXh0dXJlSW5kZXgsIGluZGljZXMpO1xcbiAgICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7b3V0cHV0OntkaW1zOmEsdHlwZTpuWzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmd9KX0pKDAscix0LG4uYXhpcyl9KX0scz1lPT5gaW50IGdldFRleHR1cmVXaGVyZURhdGFSZXNpZGVzKGludCBpbmRleCkge1xcbiAgICAgICR7ZS5tYXAoKChlLHQpPT5gaWYoaW5kZXg8JHtlfSkge3JldHVybiAke3R9O31cXG5gKSkuam9pbihcIlwiKX1cXG4gICAgfWAsdT1lPT5zKGUpLGw9KGUsdCk9Pntjb25zdCBuPVtgZmxvYXQgZmV0Y2hEYXRhRnJvbUNvcnJlY3RUZXh0dXJlKGludCB0ZXh0dXJlSW5kZXgsIGludCBpbmRpY2VzWyR7dH1dKSB7YF07Zm9yKGxldCB0PTA7dDxlOysrdCkwPT09dD9uLnB1c2goYFxcdGlmICh0ZXh0dXJlSW5kZXggPT0gJHt0fSkgeyByZXR1cm4gX1gke3R9KGluZGljZXMpOyB9YCk6dD09PWUtMT9uLnB1c2goYFxcdGVsc2UgeyByZXR1cm4gX1gke3R9KGluZGljZXMpOyB9YCk6bi5wdXNoKGBcXHRlbHNlIGlmICh0ZXh0dXJlSW5kZXggPT0gJHt0fSkgeyByZXR1cm4gX1gke3R9KGluZGljZXMpOyB9YCk7cmV0dXJuIG4ucHVzaChcIlxcdH1cIiksbi5qb2luKFwiXFxuXCIpfSxjPWU9Pntjb25zdCB0PVtcImludCBnZXRTaXplSW5Db25jYXRBeGlzVmFsdWVGcm9tSW5kZXgoaW50IGluZGV4KSB7XCJdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7KytuKTA9PT1uP3QucHVzaChgXFx0aWYgKGluZGV4ID09ICR7bn0pIHsgcmV0dXJuICR7ZVtuXX07IH1gKTpuPT09ZS5sZW5ndGgtMT90LnB1c2goYFxcdGVsc2UgeyByZXR1cm4gJHtlW25dfTsgfWApOnQucHVzaChgXFx0ZWxzZSBpZiAoaW5kZXggPT0gJHtufSkgeyByZXR1cm4gJHtlW25dfTsgfWApO3JldHVybiB0LnB1c2goXCJcXHR9XCIpLHQuam9pbihcIlxcblwiKX07dC5wYXJzZUNvbmNhdEF0dHJpYnV0ZXM9ZT0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtheGlzOmUuYXR0cmlidXRlcy5nZXRJbnQoXCJheGlzXCIpfSk7Y29uc3QgcD1lPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7Y29uc3QgdD1lWzBdLnR5cGUsbj1lWzBdLmRpbXMubGVuZ3RoO2lmKFwic3RyaW5nXCI9PT10KXRocm93IG5ldyBFcnJvcihcInN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7Zm9yKGNvbnN0IHIgb2YgZSl7aWYoci50eXBlIT09dCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBiZSBvbmUgdHlwZVwiKTtpZihyLmRpbXMubGVuZ3RoIT09bil0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpfX19LDc4MjU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oMTMxNSksbz1uKDY3NTcpLGk9big1NjM5KSxhPW4oOTc1NCkscz1uKDIxNTApO3QuY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyPShlLHQsbik9Pntjb25zdCB1PShsPXQubGVuZ3RoPjIsYz1uLmNhY2hlS2V5LHtuYW1lOlwiR3JvdXBlZENvbnZcIixpbnB1dE5hbWVzOmw/W1wiWFwiLFwiV1wiLFwiQmlhc1wiXTpbXCJYXCIsXCJXXCJdLGlucHV0VHlwZXM6bD9baS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWRdOltpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDpjfSk7dmFyIGwsYztyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtnZXQ6KCk9PigoZSx0LG4sdSk9Pntjb25zdCBsPXQubGVuZ3RoPjI/XCJ2YWx1ZSArPSBnZXRCaWFzKG91dHB1dF9jaGFubmVsKTtcIjpcIlwiLGM9dFswXS5kaW1zLnNsaWNlKCkscD10WzFdLmRpbXMuc2xpY2UoKSxkPXBbMF0vdS5ncm91cDtyLkxvZ2dlci52ZXJib3NlKFwiR3JvdXBlZENvbnZcIixgYXV0cFBhZDoke3UuYXV0b1BhZH0sIGRpbGF0aW9uczoke3UuZGlsYXRpb25zfSwgZ3JvdXA6JHt1Lmdyb3VwfSwga2VybmVsU2hhcGU6JHt1Lmtlcm5lbFNoYXBlfSwgcGFkczoke3UucGFkc30sIHN0cmlkZXM6JHt1LnN0cmlkZXN9YCk7Y29uc3QgZj0oMCxhLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShjLHAsdS5kaWxhdGlvbnMsdS5wYWRzLHUuc3RyaWRlcyksaD0oMCxvLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx7YWN0aXZhdGlvbkZ1bmN0aW9uOmcsYXBwbHlBY3RpdmF0aW9uOm19PSgwLHMuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKHUpLGI9YFxcbiAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKCR7dS5zdHJpZGVzWzBdfSwgJHt1LnN0cmlkZXNbMV19KTtcXG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3UucGFkc1swXX0sICR7dS5wYWRzWzFdfSk7XFxuICAke2d9XFxuICB2b2lkIG1haW4oKSB7XFxuICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgaW50IG91dHB1dF9jaGFubmVsID0gY29vcmRzLnk7XFxuICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy56dyAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICBpbnQgZ3JvdXBfaWQgPSBvdXRwdXRfY2hhbm5lbCAvICR7ZH07XFxuXFxuICAgIGZsb2F0IHZhbHVlID0gMC4wO1xcbiAgICBmb3IgKGludCB3SW5DaGFubmVsID0gMDsgd0luQ2hhbm5lbCA8ICR7cFsxXX07IHdJbkNoYW5uZWwrKykge1xcbiAgICAgIGludCBpbnB1dF9jaGFubmVsID0gZ3JvdXBfaWQgKiAke3BbMV19ICsgd0luQ2hhbm5lbDtcXG4gICAgICBmb3IgKGludCB3SGVpZ2h0ID0gMDsgd0hlaWdodCA8ICR7cFsyXX07IHdIZWlnaHQrKykge1xcbiAgICAgICAgaW50IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiAke3UuZGlsYXRpb25zWzBdfTtcXG5cXG4gICAgICAgIGlmICh4SGVpZ2h0IDwgMCB8fCB4SGVpZ2h0ID49ICR7Y1syXX0pIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKGludCB3V2lkdGggPSAwOyB3V2lkdGggPCAke3BbM119OyB3V2lkdGgrKykge1xcbiAgICAgICAgICBpbnQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiAke3UuZGlsYXRpb25zWzFdfTtcXG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDAgfHwgeFdpZHRoID49ICR7Y1szXX0pIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgaW5wdXRfY2hhbm5lbCwgeFdpZHRoLCB4SGVpZ2h0KTtcXG4gICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcob3V0cHV0X2NoYW5uZWwsIHdJbkNoYW5uZWwsIHdXaWR0aCwgd0hlaWdodCk7XFxuICAgICAgICAgIHZhbHVlICs9IHhWYWwqd1ZhbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgJHtsfVxcbiAgICAke219XFxuICAgICR7aC5vdXRwdXR9ID0gdmVjNCh2YWx1ZSwgLjAsIC4wLCAuMCk7XFxuICB9XFxuYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtvdXRwdXQ6e2RpbXM6Zix0eXBlOnRbMF0udHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6YixoYXNNYWluOiEwfSl9KShlLHQsdSxuKX0pfX0sNzcwODooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5jb252MkRQYWNrZWQ9dC5jb252MkRQYWNrZWRQb2ludHdpc2U9dm9pZCAwO2NvbnN0IHI9big5NzU0KSxvPW4oNTk1MCksaT1uKDU2MzIpO3QuY29udjJEUGFja2VkUG9pbnR3aXNlPShlLHQsbik9Pntjb25zdCBvPXRbMF0uZGltcyxhPXRbMV0uZGltcyxzPSgwLHIuY2FsY3VsYXRlT3V0cHV0U2hhcGUpKG8sYSxuLmRpbGF0aW9ucyxuLnBhZHMsbi5zdHJpZGVzKSx1PWUucmVzaGFwZVBhY2tlZCh0WzBdLFtvWzFdLG9bMl0qb1szXV0pLGw9ZS5yZXNoYXBlUGFja2VkKHRbMV0sW2FbMF0sYVsxXV0pLGM9dC5sZW5ndGg+Mj9bbCx1LHRbMl1dOltsLHVdLHA9ZS5ydW4oKDAsaS5jcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcikoZSxjLG4pLGMpO3JldHVybiBlLnJlc2hhcGVQYWNrZWQocCxzKX0sdC5jb252MkRQYWNrZWQ9KGUsdCxuKT0+e2NvbnN0IGE9dFswXS5kaW1zLHM9dFsxXS5kaW1zLHU9KDAsci5jYWxjdWxhdGVPdXRwdXRTaGFwZSkoYSxzLG4uZGlsYXRpb25zLG4ucGFkcyxuLnN0cmlkZXMpLGw9ZS5ydW4oKDAsby5jcmVhdGVQYWNrZWRJbTJDb2xQcm9ncmFtSW5mb0xvYWRlcikoZSx0WzBdLHRbMV0sdSxuKSxbdFswXV0pLGM9ZS5yZXNoYXBlUGFja2VkKHRbMV0sW3NbMF0sc1sxXSpzWzJdKnNbM11dKSxwPTM9PT10Lmxlbmd0aD9bYyxsLHRbMl1dOltjLGxdLGQ9ZS5ydW4oKDAsaS5jcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcikoZSxwLG4pLHApO3JldHVybiBlLnJlc2hhcGVQYWNrZWQoZCx1KX19LDUwNDI6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VDb252VHJhbnNwb3NlQXR0cmlidXRlcz10LmNvbnZUcmFuc3Bvc2U9dm9pZCAwO2NvbnN0IHI9big0OTEwKSxvPW4oNjc1NyksaT1uKDU2MzkpLGE9bigyMTUwKSxzPShlLHQsbixyLG8saSk9PihlLTEpKnQrbisoci0xKSpvKzEtaSx1PShlLHQsbixyLG8pPT57Y29uc3QgaT1NYXRoLmZsb29yKGUvMik7XCJTQU1FX1VQUEVSXCI9PT10PyhuW3JdPWksbltvXT1lLWkpOlwiU0FNRV9MT1dFUlwiPT09dCYmKG5bcl09ZS1pLG5bb109aSl9O3QuY29udlRyYW5zcG9zZT0oZSx0LG4pPT4oZCh0LG4pLGwoZSx0LG4pKTtjb25zdCBsPShlLHQsbik9Pntjb25zdCByPXAobix0KTtyZXR1cm5bYyhlLHQscildfSxjPShlLHQsbik9PmUucnVuKCgoZSx0LG4pPT57Y29uc3Qgcj0ocz10Lmxlbmd0aD4yLHU9bi5jYWNoZUtleSx7bmFtZTpcIkNvbnZUcmFuc3Bvc2VcIixpbnB1dE5hbWVzOnM/W1wiWFwiLFwiV1wiLFwiQlwiXTpbXCJYXCIsXCJXXCJdLGlucHV0VHlwZXM6cz9baS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWRdOltpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDp1fSk7dmFyIHMsdTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHtnZXQ6KCk9PigoZSx0LG4scik9Pntjb25zdCBzPXQubGVuZ3RoPjI/XCJnZXRCKG91dHB1dF9jaGFubmVsKVwiOlwiMC4wXCIsdT10WzBdLmRpbXMsbD10WzFdLmRpbXMsYz1sWzFdLHA9bFswXS9yLmdyb3VwLGQ9W3RbMF0uZGltc1swXSx0WzFdLmRpbXNbMV0qci5ncm91cCwuLi5yLm91dHB1dFNoYXBlXSxmPSgwLG8uZ2V0R2xzbCkoZS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLHthY3RpdmF0aW9uRnVuY3Rpb246aCxhcHBseUFjdGl2YXRpb246Z309KDAsYS5nZXRBY3RpdmF0aW9uU25pcHBldCkociksbT1gXFxuICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoJHtyLnN0cmlkZXNbMF19LCAke3Iuc3RyaWRlc1sxXX0pO1xcbiAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKCR7ci5wYWRzWzBdfSwgJHtyLnBhZHNbMV19KTtcXG4gICR7aH1cXG4gIHZvaWQgbWFpbigpIHtcXG4gICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICBpbnQgb3V0cHV0X2NoYW5uZWwgPSBjb29yZHMueTtcXG5cXG4gICAgaXZlYzIgbG9jID0gY29vcmRzLnp3ICsgcGFkcztcXG5cXG4gICAgaW50IGdyb3VwX2lkID0gb3V0cHV0X2NoYW5uZWwgLyAke2N9O1xcbiAgICBpbnQgd091dENoYW5uZWwgPSBvdXRwdXRfY2hhbm5lbCAtIGdyb3VwX2lkICogJHtjfTtcXG5cXG4gICAgZmxvYXQgdmFsdWUgPSAke3N9O1xcbiAgICBmb3IgKGludCBpbkNoYW5uZWxPZmZzZXQgPSAwOyBpbkNoYW5uZWxPZmZzZXQgPCAke3B9OyBpbkNoYW5uZWxPZmZzZXQrKykge1xcbiAgICAgIGludCBpbnB1dF9jaGFubmVsID0gZ3JvdXBfaWQgKiAke3B9ICsgaW5DaGFubmVsT2Zmc2V0O1xcbiAgICAgIGZvciAoaW50IHdXT2ZmID0gMDsgd1dPZmYgPCAke2xbMl19OyB3V09mZisrKSB7XFxuICAgICAgICBmb3IgKGludCB3SE9mZiA9IDA7IHdIT2ZmIDwgJHtsWzNdfTsgd0hPZmYrKykge1xcbiAgICAgICAgICBpdmVjMiB3T2ZmID0gaXZlYzIod1dPZmYgKiAke3IuZGlsYXRpb25zWzBdfSwgd0hPZmYgKiAke3IuZGlsYXRpb25zWzFdfSk7XFxuICAgICAgICAgIGl2ZWMyIHdMb2MgPSBsb2MgLSB3T2ZmO1xcbiAgICAgICAgICBpdmVjMiB3TG9jSW4gPSB3TG9jIC8gc3RyaWRlcztcXG4gICAgICAgICAgaWYgKFxcbiAgICAgICAgICAgIHdMb2NJbiAqIHN0cmlkZXMgPT0gd0xvYyAmJlxcbiAgICAgICAgICAgIHdMb2NJbi54ID49IDAgJiYgd0xvY0luLnggPCAke3VbMl19ICYmXFxuICAgICAgICAgICAgd0xvY0luLnkgPj0gMCAmJiB3TG9jSW4ueSA8ICR7dVszXX1cXG4gICAgICAgICAgKSB7XFxuICAgICAgICAgICAgZmxvYXQgeFZhbCA9IGdldFgoYmF0Y2gsIGlucHV0X2NoYW5uZWwsIHdMb2NJbi55LCB3TG9jSW4ueCk7XFxuICAgICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcoaW5wdXRfY2hhbm5lbCwgd091dENoYW5uZWwsIHdIT2ZmLCB3V09mZik7XFxuICAgICAgICAgICAgdmFsdWUgKz0geFZhbCAqIHdWYWw7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgJHtnfVxcbiAgICAke2Yub3V0cHV0fSA9IHZlYzQodmFsdWUsIC4wLCAuMCwgLjApO1xcbiAgfVxcbmA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7b3V0cHV0OntkaW1zOmQsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOm0saGFzTWFpbjohMH0pfSkoZSx0LHIsbil9KX0pKGUsdCxuKSx0KSxwPShlLHQpPT57Y29uc3Qgbj1lLmtlcm5lbFNoYXBlLnNsaWNlKCk7aWYoMD09PWUua2VybmVsU2hhcGUubGVuZ3RoKWZvcihsZXQgZT0yO2U8dFsxXS5kaW1zLmxlbmd0aDsrK2Upbi5wdXNoKHRbMV0uZGltc1tlXSk7Y29uc3Qgcj1lLnBhZHMuc2xpY2UoKSxvPWUub3V0cHV0U2hhcGUuc2xpY2UoKTsoKGUsdCxuLHIsbyxpLGEsbCk9Pntjb25zdCBjPWUubGVuZ3RoLTIscD0wPT09bC5sZW5ndGg7Zm9yKGxldCBkPTA7ZDxjOysrZCl7Y29uc3QgZj1wP2VbZCsyXSppW2RdOmxbZF0saD1zKGVbZCsyXSxpW2RdLG9bZF0sdFtkXSxuW2RdLGYpO3UoaCxyLG8sZCxkK2MpLHAmJmwucHVzaChpW2RdKihlW2QrMl0tMSkrYVtkXSsodFtkXS0xKSpuW2RdKzEtb1tkXS1vW2QrY10pfX0pKHRbMF0uZGltcyxuLGUuZGlsYXRpb25zLGUuYXV0b1BhZCxyLGUuc3RyaWRlcyxlLm91dHB1dFBhZGRpbmcsbyk7Y29uc3QgaT1PYmplY3QuYXNzaWduKHt9LGUpO3JldHVybiBPYmplY3QuYXNzaWduKGkse2tlcm5lbFNoYXBlOm4scGFkczpyLG91dHB1dFNoYXBlOm8sY2FjaGVLZXk6ZS5jYWNoZUtleX0pLGl9O3QucGFyc2VDb252VHJhbnNwb3NlQXR0cmlidXRlcz1lPT57Y29uc3QgdD1lLmF0dHJpYnV0ZXMsbj0oMCxhLnBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcykodCksbz10LmdldFN0cmluZyhcImF1dG9fcGFkXCIsXCJOT1RTRVRcIiksaT10LmdldEludHMoXCJkaWxhdGlvbnNcIixbMSwxXSkscz10LmdldEludChcImdyb3VwXCIsMSksdT10LmdldEludHMoXCJrZXJuZWxfc2hhcGVcIixbXSksbD10LmdldEludHMoXCJvdXRwdXRfcGFkZGluZ1wiLFswLDBdKSxjPXQuZ2V0SW50cyhcIm91dHB1dF9zaGFwZVwiLFtdKSxwPXQuZ2V0SW50cyhcInBhZHNcIixbMCwwLDAsMF0pLGQ9dC5nZXRJbnRzKFwic3RyaWRlc1wiLFsxLDFdKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoT2JqZWN0LmFzc2lnbih7YXV0b1BhZDpvLGRpbGF0aW9uczppLGdyb3VwOnMsa2VybmVsU2hhcGU6dSxvdXRwdXRQYWRkaW5nOmwsb3V0cHV0U2hhcGU6YyxwYWRzOnAsc3RyaWRlczpkfSxuKSl9O2NvbnN0IGQ9KGUsdCk9PntpZighZXx8MiE9PWUubGVuZ3RoJiYzIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKDQhPT1lWzBdLmRpbXMubGVuZ3RofHw0IT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udlwiKTtpZihlWzBdLmRpbXNbMV0hPT1lWzFdLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtjb25zdCBuPWVbMV0uZGltc1sxXSp0Lmdyb3VwO2lmKDM9PT1lLmxlbmd0aCYmKDEhPT1lWzJdLmRpbXMubGVuZ3RofHxlWzJdLmRpbXNbMF0hPT1uKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJpYXNcIik7Y29uc3Qgcj1lWzBdLmRpbXMubGVuZ3RoLTI7aWYodC5kaWxhdGlvbnMubGVuZ3RoIT09cil0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtyfURgKTtpZih0LnN0cmlkZXMubGVuZ3RoIT09cil0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7cn1EYCk7aWYodC5wYWRzLmxlbmd0aCE9PTIqcil0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7MipyfURgKTtpZih0Lm91dHB1dFBhZGRpbmcubGVuZ3RoIT09cil0aHJvdyBuZXcgRXJyb3IoYG91dHB1dF9wYWRkaW5nIHNob3VsZCBiZSAke3J9RGApO2lmKDAhPT10Lmtlcm5lbFNoYXBlLmxlbmd0aCYmdC5rZXJuZWxTaGFwZS5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXJuZWwgc2hhcGVcIik7aWYoMCE9PXQub3V0cHV0U2hhcGUubGVuZ3RoJiZ0Lm91dHB1dFNoYXBlLmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG91dHB1dCBzaGFwZVwiKTtpZihcImZsb2F0MzJcIiE9PWVbMF0udHlwZXx8XCJmbG9hdDMyXCIhPT1lWzFdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ29udlRyYW5zcG9zZSBpbnB1dChYLFcpIHNob3VsZCBiZSBmbG9hdCB0ZW5zb3JcIik7aWYoMz09PWUubGVuZ3RoJiZcImZsb2F0MzJcIiE9PWVbMl0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJDb252VHJhbnNwb3NlIGlucHV0KGJpYXMpIHNob3VsZCBiZSBmbG9hdCB0ZW5zb3JcIil9fSw5NzU0OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlQ29udkF0dHJpYnV0ZXM9dC5jb252PXQuY2FsY3VsYXRlT3V0cHV0U2hhcGU9dm9pZCAwO2NvbnN0IHI9big0OTEwKSxvPW4oNzI3MyksaT1uKDc4MjUpLGE9big3NzA4KSxzPW4oMzI4MSksdT1uKDIxNTApLGw9bigxNjI1KSxjPW4oODI3Nik7dC5jYWxjdWxhdGVPdXRwdXRTaGFwZT0oZSx0LG4scixvKT0+e2NvbnN0IGk9ZVswXSxhPWUuc2xpY2UoMikscz1hLmxlbmd0aCx1PXRbMF0sbD10LnNsaWNlKDIpLm1hcCgoKGUsdCk9PmUrKGUtMSkqKG5bdF0tMSkpKSxjPWEubWFwKCgoZSx0KT0+ZStyW3RdK3JbdCtzXSkpLm1hcCgoKGUsdCk9Pk1hdGguZmxvb3IoKGUtbFt0XStvW3RdKS9vW3RdKSkpO3JldHVybltpLHVdLmNvbmNhdCguLi5jKX0sdC5jb252PShlLHQsbik9PihnKHQsbikscChlLHQsbikpO2NvbnN0IHA9KGUsdCxuKT0+e2NvbnN0IHI9aChuLHQpLG89ZS5zZXNzaW9uLnBhY2sscz0xPT09ci5rZXJuZWxTaGFwZVswXSYmMT09PXIua2VybmVsU2hhcGVbMV07cmV0dXJuIHIuZ3JvdXA+MT9bZS5ydW4oKDAsaS5jcmVhdGVVbnBhY2tlZEdyb3VwZWRDb252UHJvZ3JhbUluZm9Mb2FkZXIpKGUsdCxyKSx0KV06cyYmbz9bZChlLHQscildOm8mJjQ9PT10WzBdLmRpbXMubGVuZ3RoJiYxPT09dFswXS5kaW1zWzBdJiYhcz9bKDAsYS5jb252MkRQYWNrZWQpKGUsdCxyKV06W2YoZSx0LHIpXX0sZD0oZSxuLHIpPT57Y29uc3Qgbz1uWzBdLmRpbXMsaT1uWzFdLmRpbXMsYT0oMCx0LmNhbGN1bGF0ZU91dHB1dFNoYXBlKShvLGksci5kaWxhdGlvbnMsci5wYWRzLHIuc3RyaWRlcykscz1lLnJlc2hhcGVVbnBhY2tlZChuWzBdLFtvWzFdLG9bMl0qb1szXV0pLHU9ZS5yZXNoYXBlVW5wYWNrZWQoblsxXSxbaVswXSxpWzFdXSksbD1uLmxlbmd0aD4yP1t1LHMsblsyXV06W3Usc10scD1lLnJ1bigoMCxjLmNyZWF0ZU1hdG11bFByb2dyYW1JbmZvTG9hZGVyKShsLHIpLGwpO3JldHVybiBlLnJlc2hhcGVVbnBhY2tlZChwLGEpfSxmPShlLG4scik9Pntjb25zdCBvPW5bMF0uZGltcyxpPW5bMV0uZGltcyxhPSgwLHQuY2FsY3VsYXRlT3V0cHV0U2hhcGUpKG8saSxyLmRpbGF0aW9ucyxyLnBhZHMsci5zdHJpZGVzKSx1PWUucnVuKCgwLGwuY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXIpKGUsblswXSxuWzFdLGEsciksW25bMF1dKSxjPTM9PT1uLmxlbmd0aD9bdSxuWzFdLG5bMl1dOlt1LG5bMV1dO3JldHVybiBlLnJ1bigoMCxzLmNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlcikoZSxuLGEsciksYyl9LGg9KGUsdCk9Pntjb25zdCBuPWUua2VybmVsU2hhcGUuc2xpY2UoKTtpZigwPT09ZS5rZXJuZWxTaGFwZS5sZW5ndGgpZm9yKGxldCBlPTI7ZTx0WzFdLmRpbXMubGVuZ3RoOysrZSluLnB1c2godFsxXS5kaW1zW2VdKTtjb25zdCByPWUucGFkcy5zbGljZSgpO28uUG9vbENvbnZVdGlsLmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0WzBdLmRpbXMsZS5zdHJpZGVzLGUuZGlsYXRpb25zLG4scixlLmF1dG9QYWQpO2NvbnN0IGk9T2JqZWN0LmFzc2lnbih7fSxlKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihpLHtrZXJuZWxTaGFwZTpuLHBhZHM6cixjYWNoZUtleTplLmNhY2hlS2V5fSksaX07dC5wYXJzZUNvbnZBdHRyaWJ1dGVzPWU9Pntjb25zdCB0PWUuYXR0cmlidXRlcyxuPSgwLHUucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKSh0KSxvPXQuZ2V0U3RyaW5nKFwiYXV0b19wYWRcIixcIk5PVFNFVFwiKSxpPXQuZ2V0SW50cyhcImRpbGF0aW9uc1wiLFsxLDFdKSxhPXQuZ2V0SW50KFwiZ3JvdXBcIiwxKSxzPXQuZ2V0SW50cyhcImtlcm5lbF9zaGFwZVwiLFtdKSxsPXQuZ2V0SW50cyhcInBhZHNcIixbMCwwLDAsMF0pLGM9dC5nZXRJbnRzKFwic3RyaWRlc1wiLFsxLDFdKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoT2JqZWN0LmFzc2lnbih7YXV0b1BhZDpvLGRpbGF0aW9uczppLGdyb3VwOmEsa2VybmVsU2hhcGU6cyxwYWRzOmwsc3RyaWRlczpjfSxuKSl9O2NvbnN0IGc9KGUsdCk9PntpZighZXx8MiE9PWUubGVuZ3RoJiYzIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKDQhPT1lWzBdLmRpbXMubGVuZ3RofHw0IT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udlwiKTtpZihlWzBdLmRpbXNbMV0hPT1lWzFdLmRpbXNbMV0qdC5ncm91cCl0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2lmKDM9PT1lLmxlbmd0aCYmKDEhPT1lWzJdLmRpbXMubGVuZ3RofHxlWzFdLmRpbXNbMF0hPT1lWzJdLmRpbXNbMF0pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmlhc1wiKTtjb25zdCBuPWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke259RGApO2lmKHQuc3RyaWRlcy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtufURgKTtpZih0LnBhZHMubGVuZ3RoIT09MipuKXRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHsyKm59RGApO2lmKDAhPT10Lmtlcm5lbFNoYXBlLmxlbmd0aCYmdC5rZXJuZWxTaGFwZS5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXJuZWwgc2hhcGVcIik7aWYoXCJmbG9hdDMyXCIhPT1lWzBdLnR5cGV8fFwiZmxvYXQzMlwiIT09ZVsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkNvbnYgaW5wdXQoWCxXKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpO2lmKDM9PT1lLmxlbmd0aCYmXCJmbG9hdDMyXCIhPT1lWzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ29udiBpbnB1dChiaWFzKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfX0sNjc0MjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXM9dC5kZXB0aFRvU3BhY2U9dm9pZCAwO2NvbnN0IHI9big1NzA3KTt0LmRlcHRoVG9TcGFjZT0oZSx0LG4pPT57byh0KTtjb25zdCBpPW4uYmxvY2tzaXplLGE9aSppLHM9XCJEQ1JcIj09PW4ubW9kZT9bMCwzLDQsMSw1LDJdOlswLDEsNCwyLDUsM10sdT1cIkRDUlwiPT09bi5tb2RlP1t0WzBdLmRpbXNbMF0saSxpLHRbMF0uZGltc1sxXS9hLHRbMF0uZGltc1syXSx0WzBdLmRpbXNbM11dOlt0WzBdLmRpbXNbMF0sdFswXS5kaW1zWzFdL2EsaSxpLHRbMF0uZGltc1syXSx0WzBdLmRpbXNbM11dLGw9ZS5yZXNoYXBlVW5wYWNrZWQodFswXSx1KSxjPXtwZXJtOnMsY2FjaGVLZXk6YCR7c31gfSxbcF09KDAsci50cmFuc3Bvc2UpKGUsW2xdLGMpLGQ9W3RbMF0uZGltc1swXSx0WzBdLmRpbXNbMV0vYSx0WzBdLmRpbXNbMl0qaSx0WzBdLmRpbXNbM10qaV07cmV0dXJuW2UucmVzaGFwZVVucGFja2VkKHAsZCldfSx0LnBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlcz1lPT57Y29uc3QgdD1lLmF0dHJpYnV0ZXMuZ2V0SW50KFwiYmxvY2tzaXplXCIpO2lmKHQ8MSl0aHJvdyBuZXcgRXJyb3IoYGJsb2Nrc2l6ZSBtdXN0IGJlID49IDEsIGJ1dCBnb3QgOiAke3R9IGZvciBEZXB0aFRvU3BhY2VgKTtjb25zdCBuPWUuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJtb2RlXCIsXCJEQ1JcIik7aWYoXCJEQ1JcIiE9PW4mJlwiQ1JEXCIhPT1uKXRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIG1vZGU6ICR7bn0gZm9yIERlcHRoVG9TcGFjZWApO3JldHVybnttb2RlOm4sYmxvY2tzaXplOnR9fTtjb25zdCBvPWU9PntpZigxIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBEZXB0aFRvU3BhY2UgZXhwZWN0IDEgaW5wdXRzLCBidXQgZ290ICR7ZS5sZW5ndGh9YCk7aWYoXCJzdHJpbmdcIj09PWVbMF0udHlwZXx8NCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcHRoVG9TcGFjZSBpbnB1dCBzaG91bGQgYmUgYSA0LUQgbnVtZXJpYyB0ZW5zb3JcIil9fSwzMjgxOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDcyNzMpLG89big2NzU3KSxpPW4oNTYzOSksYT1uKDIxNTApLHM9bigxNjI1KTt0LmNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlcj0oZSx0LG4sdSk9Pntjb25zdCBsPSgoZSx0KT0+KHtuYW1lOlwiQ29udkRvdFByb2R1Y3RcIixpbnB1dE5hbWVzOmU/W1wiSW0yQ29sXCIsXCJLXCIsXCJCXCJdOltcIkltMkNvbFwiLFwiS1wiXSxpbnB1dFR5cGVzOmU/W2kuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uLGkuVGV4dHVyZVR5cGUudW5wYWNrZWRdOltpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbl0sY2FjaGVLZXk6dC5hY3RpdmF0aW9uQ2FjaGVLZXl9KSkodC5sZW5ndGg+Mix1KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGwpLHtnZXQ6KCk9PigoZSx0LG4sdSxsKT0+e2NvbnN0IGM9blswXS5kaW1zLHA9blsxXS5kaW1zLGQ9W3BbMF0sTWF0aC5jZWlsKGNbMV0qcFsyXSpwWzNdLzQpXSxmPSgwLHMuY2FsY3VsYXRlSW0yQ29sRGltcykoYyxwLHUpLFtoLGddPWUuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGQsaS5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKSxtPXIuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGYpLFtiLHldPWUuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGYsaS5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKSx3PXUubGVuZ3RoLF89bi5sZW5ndGg8Mz9cIjAuMFwiOlwiX0IoYilcIix2PU1hdGguY2VpbChjWzFdKnBbMl0qcFszXS80KSx7YWN0aXZhdGlvbkZ1bmN0aW9uOngsYXBwbHlBY3RpdmF0aW9uOlR9PSgwLGEuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKGwpLFM9KDAsby5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksTz1gXFxuJHt4fVxcbmZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHt3fV0pIHtcXG4gIGludCBiWzFdO1xcbiAgYlswXSA9IGluZGljZXNbMV07XFxuICBpbnQgaW0yY29sWzRdO1xcbiAgaW0yY29sWzBdID0gaW5kaWNlc1swXTtcXG4gIGltMmNvbFsxXSA9IGluZGljZXNbMl07XFxuICBpbTJjb2xbMl0gPSBpbmRpY2VzWzNdO1xcbiAgaW50IGltMmNvbE9mZnNldCA9IGltMmNvbFswXSAqICR7bVswXX0gKyBpbTJjb2xbMV0gKiAke21bMV19ICsgaW0yY29sWzJdICogJHttWzJdfTtcXG4gIGludCBrZXJuZWxPZmZzZXQgPSBpbmRpY2VzWzFdICogJHtkWzFdfTtcXG4gIGZsb2F0IHZhbHVlID0gJHtffTtcXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgJHt2fTsgKytpKSB7XFxuICAgIHZlYzIgaW0yY29sQ29vcmRzID0gb2Zmc2V0VG9Db29yZHMoaW0yY29sT2Zmc2V0LCAke2J9LCAke3l9KTtcXG4gICAgdmVjMiBrZXJuZWxDb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhrZXJuZWxPZmZzZXQsICR7aH0sICR7Z30pO1xcbiAgICB2YWx1ZSArPSBkb3QoJHtTLnRleHR1cmUyRH0oSW0yQ29sLCBpbTJjb2xDb29yZHMpLCAke1MudGV4dHVyZTJEfShLLCBrZXJuZWxDb29yZHMpKTtcXG4gICAgKytpbTJjb2xPZmZzZXQ7XFxuICAgICsra2VybmVsT2Zmc2V0O1xcbiAgfVxcbiAgJHtUfVxcbiAgcmV0dXJuIHZhbHVlO1xcbn1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dDp7ZGltczp1LHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpPfSl9KShlLGwsdCxuLHUpfSl9fSw0MTI1OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlRmxhdHRlbkF0dHJpYnV0ZXM9dC5mbGF0dGVuPXZvaWQgMDtjb25zdCByPW4oNzI3Myk7dC5mbGF0dGVuPShlLHQsbik9PntvKHQsbik7Y29uc3QgaT1yLlNoYXBlVXRpbC5mbGF0dGVuU2hhcGUodFswXS5kaW1zLG4pO3JldHVybltlLnJlc2hhcGVVbnBhY2tlZCh0WzBdLGkpXX0sdC5wYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzPWU9PmUuYXR0cmlidXRlcy5nZXRJbnQoXCJheGlzXCIsMSk7Y29uc3Qgbz0oZSx0KT0+e2lmKCFlfHwxIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRmxhdHRlbiByZXF1aXJlcyAxIGlucHV0LlwiKTtjb25zdCBuPWVbMF0uZGltcy5sZW5ndGg7aWYoMD09PW4pdGhyb3cgbmV3IEVycm9yKFwic2NhbGFyIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkLlwiKTtpZih0PC1ufHx0Pm4pdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBheGlzXCIpO2lmKFwic3RyaW5nXCI9PT1lWzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkLlwiKX19LDIxNTA6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzPXQuZ2V0QWN0aXZhdGlvblNuaXBwZXQ9dm9pZCAwO2NvbnN0IHI9big3MjczKSxvPW4oOTA4Nyk7dC5nZXRBY3RpdmF0aW9uU25pcHBldD1mdW5jdGlvbihlKXtsZXQgdDtzd2l0Y2goZS5hY3RpdmF0aW9uKXtjYXNlXCJSZWx1XCI6dD0oMCxvLmdsc2xSZWx1KSgpO2JyZWFrO2Nhc2VcIlNpZ21vaWRcIjp0PSgwLG8uZ2xzbFNpZ21vaWQpKCk7YnJlYWs7Y2FzZVwiQ2xpcFwiOnQ9KDAsby5nbHNsQ2xpcCkoZS5jbGlwTWluLGUuY2xpcE1heCk7YnJlYWs7ZGVmYXVsdDpyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOlwiXCIsYXBwbHlBY3RpdmF0aW9uOlwiXCJ9fWNvbnN0IG49dC5uYW1lO3JldHVybnthY3RpdmF0aW9uRnVuY3Rpb246dC5ib2R5LGFwcGx5QWN0aXZhdGlvbjpgdmFsdWUgPSAke259Xyh2YWx1ZSk7YH19LHQucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzPWU9Pntjb25zdCB0PWUuZ2V0U3RyaW5nKFwiYWN0aXZhdGlvblwiLFwiXCIpO2lmKFwiQ2xpcFwiPT09dCl7Y29uc3RbbixvXT1lLmdldEZsb2F0cyhcImFjdGl2YXRpb25fcGFyYW1zXCIsW3IuTUlOX0NMSVAsci5NQVhfQ0xJUF0pO3JldHVybnthY3RpdmF0aW9uOnQsY2xpcE1heDpvLGNsaXBNaW46bixhY3RpdmF0aW9uQ2FjaGVLZXk6YCR7dH06JHtufSwke299YH19cmV0dXJue2FjdGl2YXRpb246dCxhY3RpdmF0aW9uQ2FjaGVLZXk6dH19fSw2MTQ5OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlR2F0aGVyQXR0cmlidXRlcz10LmdhdGhlcj12b2lkIDA7Y29uc3Qgcj1uKDQ5MTApLG89big2MTQ1KSxpPW4oNzI3MyksYT1uKDU2MzkpO3QuZ2F0aGVyPShlLHQsbik9PihsKHQsbi5heGlzKSxbZS5ydW4odShlLHQsbiksdCldKSx0LnBhcnNlR2F0aGVyQXR0cmlidXRlcz1lPT4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F4aXM6ZS5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwwKX0pO2NvbnN0IHM9e25hbWU6XCJHYXRoZXJcIixpbnB1dE5hbWVzOltcIkFcIixcIkJcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZCxhLlRleHR1cmVUeXBlLnVucGFja2VkXX0sdT0oZSx0LG4pPT57Y29uc3Qgcj1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2NhY2hlSGludDpuLmNhY2hlS2V5fSk7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7Z2V0OigpPT4oKGUsdCxuLHIpPT57Y29uc3Qgbz1uWzBdLmRpbXMuc2xpY2UoKSxzPW5bMV0uZGltcy5zbGljZSgpLHU9bmV3IEFycmF5KG8ubGVuZ3RoK3MubGVuZ3RoLTEpO3I9aS5TaGFwZVV0aWwubm9ybWFsaXplQXhpcyhyLG8ubGVuZ3RoKTtjb25zdCBsPVtdO2ZvcihsZXQgZT0wO2U8dS5sZW5ndGg7ZSsrKWU8cj8odVtlXT1vW2VdLGwucHVzaChgaW5wdXRJZHhbJHtlfV0gPSBvdXRwdXRJZHhbJHtlfV07YCkpOmU8citzLmxlbmd0aD8odVtlXT1zW2Utcl0sbC5wdXNoKGBpbmRleERhdGFJZHhbJHtlLXJ9XSA9IG91dHB1dElkeFske2V9XTtgKSk6KHVbZV09b1tlLXMubGVuZ3RoKzFdLGwucHVzaChgaW5wdXRJZHhbJHtlLXMubGVuZ3RoKzF9XSA9IG91dHB1dElkeFske2V9XTtgKSk7Y29uc3QgYz1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7dS5sZW5ndGh8fDF9XSkge1xcbiAgICAgICAgaW50IGlucHV0SWR4WyR7by5sZW5ndGh9XTtcXG4gICAgICAgIGludCBpbmRleERhdGFJZHhbJHtzLmxlbmd0aHx8MX1dO1xcbiAgICAgICAgaW5kZXhEYXRhSWR4WzBdID0gMDtcXG4gICAgICAgICR7bC5qb2luKFwiXFxuICAgICAgICBcIil9XFxuICAgICAgICBpbnQgaWR4ID0gaW50KF9CKGluZGV4RGF0YUlkeCkpO1xcbiAgICAgICAgaW5wdXRJZHhbJHtyfV0gPSBpZHggPCAwID8gaWR4ICsgJHtvW3JdfSA6IGlkeDtcXG4gICAgICAgIHJldHVybiBfQShpbnB1dElkeCk7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7b3V0cHV0OntkaW1zOnUsdHlwZTpuWzBdLnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmN9KX0pKDAscix0LG4uYXhpcyl9KX0sbD0oZSx0KT0+e2lmKCFlfHwyIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtjb25zdCBuPWVbMF0uZGltcy5sZW5ndGg7aWYobjwxKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKHQ8LW58fHQ+bi0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXhpcy5cIik7aWYoLTE9PT1vLk5VTUJFUl9UWVBFUy5pbmRleE9mKGVbMF0udHlwZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWlkIGlucHV0IHR5cGUuXCIpO2lmKFwiaW50MzJcIiE9PWVbMV0udHlwZSYmXCJpbnQxNlwiIT09ZVsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFpZCBpbnB1dCB0eXBlLlwiKX19LDUzNzg6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VHZW1tQXR0cmlidXRlc1YxMT10LnBhcnNlR2VtbUF0dHJpYnV0ZXNWNz10LmdlbW09dm9pZCAwO2NvbnN0IHI9big0OTEwKSxvPW4oNzI3MyksaT1uKDU2MzkpO3QuZ2VtbT0oZSx0LG4pPT4obCh0LG4pLFtlLnJ1bihzKHQsbiksdCldKTtjb25zdCBhPShlLHQpPT57Y29uc3Qgbj0wIT09ZS5hdHRyaWJ1dGVzLmdldEludChcInRyYW5zQVwiLDApLG89MCE9PWUuYXR0cmlidXRlcy5nZXRJbnQoXCJ0cmFuc0JcIiwwKSxpPWUuYXR0cmlidXRlcy5nZXRGbG9hdChcImFscGhhXCIsMSksYT1lLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJiZXRhXCIsMSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHt0cmFuc0E6bix0cmFuc0I6byxhbHBoYTppLGJldGE6YSxpc09wdGlvbmFsQzp0fSl9O3QucGFyc2VHZW1tQXR0cmlidXRlc1Y3PWU9PmEoZSwhMSksdC5wYXJzZUdlbW1BdHRyaWJ1dGVzVjExPWU9PmEoZSwhMCk7Y29uc3Qgcz0oZSx0KT0+e2NvbnN0IG49e25hbWU6XCJHZW1tXCIsaW5wdXROYW1lczozPT09ZS5sZW5ndGg/W1wiQVwiLFwiQlwiLFwiQ1wiXTpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6Mz09PWUubGVuZ3RoP1tpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZF06W2kuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZF0sa2V5OnQuY2FjaGVLZXl9O3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+dShuLGUsdCl9KX0sdT0oZSx0LG4pPT57Y29uc3Qgcj10WzBdLmRpbXMuc2xpY2UoKSxhPXRbMV0uZGltcy5zbGljZSgpLFtzLHVdPW8uR2VtbVV0aWwuZ2V0U2hhcGVPZkdlbW1SZXN1bHQocixuLnRyYW5zQSxhLG4udHJhbnNCLDM9PT10Lmxlbmd0aD90WzJdLmRpbXM6dm9pZCAwKSxsPVtzLHVdO2lmKCFsKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCBjPXJbci5sZW5ndGgtMV0scD1cIlwiO24udHJhbnNBJiYoYz1yWzBdKSxuLnRyYW5zQSYmbi50cmFuc0I/cD1cInZhbHVlICs9IF9BX1QoYSkgKiBfQl9UKGIpO1wiOm4udHJhbnNBJiYhbi50cmFuc0I/cD1cInZhbHVlICs9IF9BX1QoYSkgKiBfQihiKTtcIjohbi50cmFuc0EmJm4udHJhbnNCP3A9XCJ2YWx1ZSArPSBfQShhKSAqIF9CX1QoYik7XCI6bi50cmFuc0F8fG4udHJhbnNCfHwocD1cInZhbHVlICs9IF9BKGEpICogX0IoYik7XCIpO2NvbnN0IGQ9bC5sZW5ndGgsZj1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2R9XSkge1xcbiAgICAgICAgICBpbnQgYVske2R9XTtcXG4gICAgICAgICAgaW50IGJbJHtkfV07XFxuICAgICAgICAgICR7Mz09PXQubGVuZ3RoP2BpbnQgY1ske3RbMl0uZGltcy5sZW5ndGh9XTtgOlwiXCJ9XFxuXFxuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgYSk7XFxuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgYik7XFxuICAgICAgICAgICR7Mz09PXQubGVuZ3RoP1wiYmNhc3RJbmRpY2VzX0MoaW5kaWNlcywgYyk7XCI6XCJcIn1cXG5cXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSAwLjA7XFxuICAgICAgICAgIGZvciAoaW50IGs9MDsgazwke2N9OyArK2spIHtcXG4gICAgICAgICAgICAgIGFbJHtkLTF9XSA9IGs7XFxuICAgICAgICAgICAgICBiWyR7ZC0yfV0gPSBrO1xcbiAgICAgICAgICAgICAgJHtwfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiBhbHBoYTtcXG4gICAgICAgICAgJHszPT09dC5sZW5ndGg/XCJ2YWx1ZSArPSBiZXRhICogX0MoYyk7XCI6XCJcIn1cXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpsLHR5cGU6dFswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHZhcmlhYmxlczpbe25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmbG9hdFwiLGRhdGE6bi5hbHBoYX0se25hbWU6XCJiZXRhXCIsdHlwZTpcImZsb2F0XCIsZGF0YTpuLmJldGF9XSxzaGFkZXJTb3VyY2U6Zn0pfSxsPShlLHQpPT57aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbWlzc2luZ1wiKTtpZih0LmlzT3B0aW9uYWxDJiYoZS5sZW5ndGg8Mnx8ZS5sZW5ndGg+MykpdGhyb3cgbmV3IEVycm9yKFwiSW52YWlkIGlucHV0IHNoYXBlLlwiKTtpZighdC5pc09wdGlvbmFsQyYmMyE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkdlbW0gcmVxdWlyZXMgMyBpbnB1dHNcIik7aWYoMz09PWUubGVuZ3RoJiYxIT09ZVsyXS5kaW1zLmxlbmd0aCYmMiE9PWVbMl0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZSBvZiBDXCIpO2lmKFwiZmxvYXQzMlwiIT09ZVswXS50eXBlJiZcImZsb2F0NjRcIiE9PWVbMF0udHlwZXx8XCJmbG9hdDMyXCIhPT1lWzFdLnR5cGUmJlwiZmxvYXQ2NFwiIT09ZVsxXS50eXBlfHwzPT09ZS5sZW5ndGgmJlwiZmxvYXQzMlwiIT09ZVsyXS50eXBlJiZcImZsb2F0NjRcIiE9PWVbMl0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKGVbMF0udHlwZSE9PWVbMV0udHlwZXx8Mz09PWUubGVuZ3RoJiZlWzBdLnR5cGUhPT1lWzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZXMgYXJlIG1pc21hdGNoZWRcIil9fSw1OTUwOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNjc1Nyksbz1uKDU2MzkpLGk9big1NjE0KTt0LmNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvTG9hZGVyPShlLHQsbixhLHMpPT57Y29uc3QgdT0obD1zLmNhY2hlS2V5LHtuYW1lOlwiSW0yQ29sIChwYWNrZWQpXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUucGFja2VkXSxjYWNoZUhpbnQ6bH0pO3ZhciBsO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse2dldDooKT0+KChlLHQsbixhLHMsdSk9Pntjb25zdCBsPW4uZGltcyxjPWEuZGltcyxwPXMubGVuZ3RoLGQ9W2NbMV0qY1syXSpjWzNdLHNbMl0qc1szXV0sZj1jWzJdKmNbM10saD0oMCxpLnVucGFja0Zyb21DaGFubmVsKSgpLGc9KDAsci5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7bGV0IG09XCJcIjtmb3IobGV0IGU9MDtlPD0xO2UrKylmb3IobGV0IHQ9MDt0PD0xO3QrKyltKz1gXFxuICAgICAgICAgICAgYmxvY2tJbmRleCA9IHJjLnggKyAke3R9O1xcbiAgICAgICAgICAgIHBvcyA9IHJjLnkgKyAke2V9O1xcblxcbiAgICAgICAgICAgIGlmKGJsb2NrSW5kZXggPCAke2RbMV19ICYmIHBvcyA8ICR7ZFswXX0pIHtcXG4gICAgICAgICAgICAgIG9mZnNldFkgPSBpbnQoYmxvY2tJbmRleCAvICgke3NbcC0xXX0pKSAqICR7dS5zdHJpZGVzWzBdfSAtXFxuICAgICAgICAgICAgICAgICR7dS5wYWRzWzBdfTtcXG4gICAgICAgICAgICAgIGQwID0gb2Zmc2V0WSArICR7dS5kaWxhdGlvbnNbMF19ICogKGltb2QocG9zLCAke2Z9KSAvICR7Y1syXX0pO1xcblxcbiAgICAgICAgICAgICAgaWYoZDAgPCAke2xbMl19ICYmIGQwID49IDApIHtcXG4gICAgICAgICAgICAgICAgb2Zmc2V0WCA9IGltb2QoYmxvY2tJbmRleCwgJHtzW3AtMV19KSAqICR7dS5zdHJpZGVzWzFdfSAtXFxuICAgICAgICAgICAgICAgICAgJHt1LnBhZHNbMV19O1xcbiAgICAgICAgICAgICAgICBkMSA9IG9mZnNldFggKyAke3UuZGlsYXRpb25zWzFdfSAqIGltb2QoaW1vZChwb3MsICR7Zn0pLCAke2NbMl19KTtcXG5cXG4gICAgICAgICAgICAgICAgaWYoZDEgPCAke2xbM119ICYmIGQxID49IDApIHtcXG5cXG4gICAgICAgICAgICAgICAgICBjaCA9IGludChmbG9hdChwb3MpLyAke2Z9Lik7XFxuICAgICAgICAgICAgICAgICAgICBpbm5lckRpbXMgPSB2ZWMyKGQwLCBkMSk7XFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbJHsyKmUrdH1dID0gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0QSgwLCBjaCwgaW50KGlubmVyRGltcy54KSxcXG4gICAgICAgICAgICAgICAgICAgICAgaW50KGlubmVyRGltcy55KSksIGlubmVyRGltcyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGA7Y29uc3QgYj1gXFxuICAgICAgJHtofVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLjApO1xcbiAgICAgICAgICBpbnQgYmxvY2tJbmRleCwgcG9zLCBvZmZzZXRZLCBkMCwgb2Zmc2V0WCwgZDEsIGNoO1xcbiAgICAgICAgICB2ZWMyIGlubmVyRGltcztcXG4gICAgICAgICAgJHttfVxcbiAgICAgICAgICAke2cub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgICAgICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXQ6e2RpbXM6ZCx0eXBlOm4udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnBhY2tlZH0sc2hhZGVyU291cmNlOmIsaGFzTWFpbjohMH0pfSkoZSx1LHQsbixhLHMpfSl9fSwxNjI1OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNhbGN1bGF0ZUltMkNvbERpbXM9dC5jcmVhdGVJbTJDb2xQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDU2MzkpO3QuY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXI9KGUsbixvLGksYSk9Pntjb25zdCBzPSh1PWEuY2FjaGVLZXkse25hbWU6XCJJbTJDb2xcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbci5UZXh0dXJlVHlwZS51bnBhY2tlZF0sY2FjaGVIaW50OnV9KTt2YXIgdTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtnZXQ6KCk9PigoZSxuLG8saSxhLHMpPT57Y29uc3QgdT1vLmRpbXMsbD1pLmRpbXMsYz1hLmxlbmd0aCxwPSgwLHQuY2FsY3VsYXRlSW0yQ29sRGltcykodSxsLGEsNCksZD1gXFxuICAgICAgICBjb25zdCBpbnQgWEMgPSAke3VbMV19O1xcbiAgICAgICAgY29uc3QgaW50IFhIID0gJHt1WzJdfTtcXG4gICAgICAgIGNvbnN0IGludCBYVyA9ICR7dVszXX07XFxuICAgICAgICBjb25zdCBpbnQgS0ggPSAke3Mua2VybmVsU2hhcGVbMF19O1xcbiAgICAgICAgY29uc3QgaW50IEtXID0gJHtzLmtlcm5lbFNoYXBlWzFdfTtcXG4gICAgICAgIGNvbnN0IGludCBkaWxhdGlvbkggPSAke3MuZGlsYXRpb25zWzBdfTtcXG4gICAgICAgIGNvbnN0IGludCBkaWxhdGlvblcgPSAke3MuZGlsYXRpb25zWzFdfTtcXG4gICAgICAgIGNvbnN0IGludCBzdHJpZGVIID0gJHtzLnN0cmlkZXNbMF19O1xcbiAgICAgICAgY29uc3QgaW50IHN0cmlkZVcgPSAke3Muc3RyaWRlc1sxXX07XFxuICAgICAgICBjb25zdCBpbnQgcGFkSCA9ICR7cy5wYWRzWzBdfTtcXG4gICAgICAgIGNvbnN0IGludCBwYWRXID0gJHtzLnBhZHNbMV19O1xcbiAgICAgICAgY29uc3QgaW50IEtIS1cgPSBLSCpLVztcXG4gICAgICAgIGNvbnN0IGludCBYQ0tIS1cgPSBYQyAqIEtIS1c7XFxuICAgICAgICBjb25zdCBpbnQgb3V0cHV0Q2hhbm5lbHMgPSA0O1xcbiAgICAgICAgdmVjNCBwcm9jZXNzKGludCBpbmRpY2VzWyR7Y31dKSB7XFxuICAgICAgICAgIGludCBiICA9IGluZGljZXNbMF07IC8vIGJhdGNoIHNpemVcXG4gICAgICAgICAgaW50IG9oID0gaW5kaWNlc1sxXSAqIHN0cmlkZUggLSBwYWRIOyAvL291dHB1dCBoZWlnaHRcXG4gICAgICAgICAgaW50IG93ID0gaW5kaWNlc1syXSAqIHN0cmlkZVcgLSBwYWRXOyAvL291dHB1dCB3aWR0aFxcbiAgICAgICAgICBpbnQgcCA9IGluZGljZXNbM10gKiBvdXRwdXRDaGFubmVsczsgLy9wYXRjaFxcbiAgICAgICAgICB2ZWM0IHZhbHVlID0gdmVjNCgwLjApO1xcbiAgICAgICAgICBmb3IoaW50IGk9MDsgaSA8IG91dHB1dENoYW5uZWxzOyArK2kpIHtcXG4gICAgICAgICAgICBpZihwIDwgWENLSEtXKSB7XFxuICAgICAgICAgICAgICBpbnQgcGF0Y2hDID0gcCAvIEtIS1c7XFxuICAgICAgICAgICAgICBpbnQgcGF0Y2hIID0gKHAgLSBwYXRjaEMqS0hLVykgLyBLVztcXG4gICAgICAgICAgICAgIGludCBwYXRjaFcgPSAocCAtIHBhdGNoQypLSEtXKSAtIHBhdGNoSCAqIEtXO1xcbiAgICAgICAgICAgICAgaW50IHhoMiA9IG9oICsgcGF0Y2hIICogZGlsYXRpb25IO1xcbiAgICAgICAgICAgICAgaW50IHh3MiA9IG93ICsgcGF0Y2hXICogZGlsYXRpb25XO1xcbiAgICAgICAgICAgICAgaW50IHhbJHt1Lmxlbmd0aH1dO1xcbiAgICAgICAgICAgICAgeFswXSA9IGI7XFxuICAgICAgICAgICAgICB4WzFdID0gcGF0Y2hDO1xcbiAgICAgICAgICAgICAgeFsyXSA9IHhoMjtcXG4gICAgICAgICAgICAgIHhbM10gPSB4dzI7XFxuICAgICAgICAgICAgICBpZih4aDIgPj0gMCAmJlxcbiAgICAgICAgICAgICAgICAgIHhoMiA8IFhIICYmXFxuICAgICAgICAgICAgICAgICAgeHcyID49IDAgJiZcXG4gICAgICAgICAgICAgICAgICB4dzIgPCBYVykge1xcbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IF9YKHgpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICArK3A7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtvdXRwdXQ6e2RpbXM6cCx0eXBlOm8udHlwZSx0ZXh0dXJlVHlwZTpyLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb259LHNoYWRlclNvdXJjZTpkfSl9KSgwLHMsbixvLGksYSl9KX0sdC5jYWxjdWxhdGVJbTJDb2xEaW1zPShlLHQsbixyPTQpPT5bblswXSxuWzJdLG5bM10sTWF0aC5jZWlsKGVbMV0qdFsyXSp0WzNdL3IpXX0sNjk4MTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZUltYWdlU2NhbGVyQXR0cmlidXRlcz10LmltYWdlU2NhbGVyPXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDU2MzkpO3QuaW1hZ2VTY2FsZXI9KGUsdCxuKT0+KHUodCksW2UucnVuKGEoZSx0LG4pLHQpXSksdC5wYXJzZUltYWdlU2NhbGVyQXR0cmlidXRlcz1lPT57Y29uc3QgdD1lLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJzY2FsZVwiKSxuPWUuYXR0cmlidXRlcy5nZXRGbG9hdHMoXCJiaWFzXCIpO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7c2NhbGU6dCxiaWFzOm59KX07Y29uc3QgaT17bmFtZTpcIkltYWdlU2NhbGVyXCIsaW5wdXROYW1lczpbXCJYXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWRdfSxhPShlLHQsbik9Pntjb25zdCByPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxpKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXl9KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHtnZXQ6KCk9PigoZSx0LG4scik9Pntjb25zdCBpPW5bMF0uZGltcy5zbGljZSgpLGE9aS5sZW5ndGgsdT1gXFxuICAgICAgJHtzKHIuYmlhcy5sZW5ndGgpfVxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHthfV0pIHtcXG4gICAgICAgIHJldHVybiBfWChpbmRpY2VzKSAqIHNjYWxlICsgZ2V0QmlhcyhiaWFzLCBpbmRpY2VzWzFdKTtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXQ6e2RpbXM6aSx0eXBlOm5bMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnVucGFja2VkfSx2YXJpYWJsZXM6W3tuYW1lOlwiYmlhc1wiLHR5cGU6XCJmbG9hdFwiLGFycmF5TGVuZ3RoOnIuYmlhcy5sZW5ndGgsZGF0YTpyLmJpYXN9LHtuYW1lOlwic2NhbGVcIix0eXBlOlwiZmxvYXRcIixkYXRhOnIuc2NhbGV9XSxzaGFkZXJTb3VyY2U6dX0pfSkoMCxyLHQsbil9KX0scz1lPT57Y29uc3QgdD1bYGZsb2F0IGdldEJpYXMoZmxvYXQgYmlhc1ske2V9XSwgaW50IGNoYW5uZWwpIHtgXTtmb3IobGV0IG49MDtuPGU7KytuKTA9PT1uP3QucHVzaChgXFx0aWYgKGNoYW5uZWwgPT0gJHtufSkgeyByZXR1cm4gYmlhc1ske259XTsgfWApOm49PT1lLTE/dC5wdXNoKGBcXHRlbHNlIHsgcmV0dXJuIGJpYXNbJHtufV07IH1gKTp0LnB1c2goYFxcdGVsc2UgaWYgKGNoYW5uZWwgPT0gJHtufSkgeyByZXR1cm4gYmlhc1ske259XTsgfWApO3JldHVybiB0LnB1c2goXCJcXHR9XCIpLHQuam9pbihcIlxcblwiKX0sdT1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZVNjYWxlciByZXF1aXJlcyAxIGlucHV0LlwiKTtpZig0IT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHNoYXBlLlwiKTtpZihcImZsb2F0MzJcIiE9PWVbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT1lWzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX19LDc0MTM6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VJbnN0YW5jZU5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzPXQuaW5zdGFuY2VOb3JtYWxpemF0aW9uPXZvaWQgMDtjb25zdCByPW4oNjc1Nyksbz1uKDU2MzkpO3QuaW5zdGFuY2VOb3JtYWxpemF0aW9uPShlLHQsbik9PntsKHQpO2NvbnN0IHI9ZS5ydW4oYSh0WzBdKSx0KTtyZXR1cm5bZS5ydW4odShlLHRbMF0sbixyLmRpbXMpLFt0WzBdLHIsdFsxXSx0WzJdXSldfSx0LnBhcnNlSW5zdGFuY2VOb3JtYWxpemF0aW9uQXR0cmlidXRlcz1lPT5lLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJlcHNpbG9uXCIsMWUtNSk7Y29uc3QgaT17bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvbl9NZWFuQW5kVmFyaWFuY2VcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19LGE9ZT0+T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGkpLHtnZXQ6KCk9PigoZSx0KT0+e2NvbnN0IG49dC5kaW1zLnNsaWNlKCkscj1uWzFdLGk9blsyXSpuWzNdLGE9W25bMF0scl0scz1gXFxuICAgICAgdmVjNCBwcm9jZXNzKGludFsyXSBpbmRpY2VzKSB7XFxuICAgICAgICB2ZWM0IHYgPSB2ZWM0KDAuMCk7XFxuICAgICAgICBpbnQgYVs0XTtcXG4gICAgICAgIGFbMF0gPSBpbmRpY2VzWzBdO1xcbiAgICAgICAgYVsxXSA9IGluZGljZXNbMV07XFxuICAgICAgICBmbG9hdCB0ZW1wID0gMC4wO1xcbiAgICAgICAgZm9yKGludCBhMj0wOyBhMjwke25bMl19OyBhMisrKSB7XFxuICAgICAgICAgIGFbMl0gPSBhMjtcXG4gICAgICAgICAgZm9yKGludCBhMz0wOyBhMzwke25bM119OyBhMysrKSB7XFxuICAgICAgICAgICAgYVszXSA9IGEzO1xcbiAgICAgICAgICAgIGZsb2F0IHggPSBfWChhKTtcXG4gICAgICAgICAgICB0ZW1wICs9IHg7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGZsb2F0IG1lYW4gPSB0ZW1wIC8gZmxvYXQoJHtpfSk7XFxuICAgICAgICB0ZW1wID0gMC4wO1xcbiAgICAgICAgZm9yKGludCBhMj0wOyBhMjwke25bMl19OyBhMisrKSB7XFxuICAgICAgICAgIGFbMl0gPSBhMjtcXG4gICAgICAgICAgZm9yKGludCBhMz0wOyBhMzwke25bM119OyBhMysrKSB7XFxuICAgICAgICAgICAgYVszXSA9IGEzO1xcbiAgICAgICAgICAgIGZsb2F0IHggPSBfWChhKTtcXG4gICAgICAgICAgICB0ZW1wICs9ICh4IC0gbWVhbikgKiAoeCAtIG1lYW4pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICB2LnIgPSBtZWFuO1xcbiAgICAgICAgdi5nID0gdGVtcCAvIGZsb2F0KCR7aX0pO1xcblxcbiAgICAgICAgcmV0dXJuIHY7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOmEsdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9ufSxzaGFkZXJTb3VyY2U6c30pfSkoaSxlKX0pLHM9e25hbWU6XCJJbnN0YW5jZU5vcm1hbGl6YXRpb25fQ29tcHV0ZU91dHB1dFwiLGlucHV0TmFtZXM6W1wiWFwiLFwiTWVhbkFuZFZhcmlhbmNlXCIsXCJTY2FsZVwiLFwiQlwiXSxpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbixvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdfSx1PShlLHQsbixpKT0+e2NvbnN0IGE9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtjYWNoZUhpbnQ6YCR7bn1gfSk7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx7Z2V0OigpPT4oKGUsdCxuLGksYSk9Pntjb25zdCBzPSgwLHIuZ2V0R2xzbCkoZS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLFt1LGxdPWUuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGEsby5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKSxbYyxwXT1bdS80LGxdLGQ9YFxcbiAgICAgIHZlYzQgZ2V0X01lYW5BbmRWYXJpYW5jZShpbnRbMl0gbXYpIHtcXG4gICAgICAgIGludCBvZmZzZXQgPSBpbmRpY2VzVG9PZmZzZXRfTWVhbkFuZFZhcmlhbmNlKG12KTtcXG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke2N9LCAke3B9KTtcXG4gICAgICAgIHJldHVybiAke3MudGV4dHVyZTJEfShNZWFuQW5kVmFyaWFuY2UsIGNvb3Jkcyk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WzRdIGluZGljZXMpIHtcXG4gICAgICAgIGludCBtdlsyXTtcXG4gICAgICAgIG12WzBdID0gaW5kaWNlc1swXTtcXG4gICAgICAgIG12WzFdID0gaW5kaWNlc1sxXTtcXG4gICAgICAgIHZlYzQgbWVhbl9hbmRfdmFyaWFuY2UgPSBnZXRfTWVhbkFuZFZhcmlhbmNlKG12KTtcXG4gICAgICAgIGZsb2F0IG1lYW4gPSBtZWFuX2FuZF92YXJpYW5jZS5yO1xcbiAgICAgICAgZmxvYXQgdmFyaWFuY2UgPSBtZWFuX2FuZF92YXJpYW5jZS5nO1xcblxcbiAgICAgICAgaW50IHNiWzFdO1xcbiAgICAgICAgc2JbMF0gPSBpbmRpY2VzWzFdO1xcbiAgICAgICAgZmxvYXQgc2NhbGUgPSBfU2NhbGUoc2IpO1xcbiAgICAgICAgZmxvYXQgYiA9IF9CKHNiKTtcXG5cXG4gICAgICAgIHJldHVybiBzY2FsZSAqIChfWChpbmRpY2VzKSAtIG1lYW4pIC8gc3FydCh2YXJpYW5jZSArIGVwc2lsb24pICsgYjtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXQ6e2RpbXM6bi5kaW1zLHR5cGU6bi50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHZhcmlhYmxlczpbe25hbWU6XCJlcHNpbG9uXCIsdHlwZTpcImZsb2F0XCIsZGF0YTppfV0sc2hhZGVyU291cmNlOmR9KX0pKGUsYSx0LG4saSl9KX0sbD1lPT57aWYoIWV8fDMhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb24gcmVxdWlyZXMgMyBpbnB1dHMuXCIpO2NvbnN0IHQ9ZVswXSxuPWVbMV0scj1lWzJdO2lmKHQuZGltcy5sZW5ndGg8M3x8MSE9PW4uZGltcy5sZW5ndGh8fDEhPT1yLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKG4uZGltc1swXSE9PXQuZGltc1sxXXx8ci5kaW1zWzBdIT09dC5kaW1zWzFdKXRocm93IG5ldyBFcnJvcihcIklucHV0IHNoYXBlcyBhcmUgbWlzbWF0Y2hlZC5cIik7aWYoXCJmbG9hdDMyXCIhPT10LnR5cGUmJlwiZmxvYXQ2NFwiIT09dC50eXBlfHxcImZsb2F0MzJcIiE9PW4udHlwZSYmXCJmbG9hdDY0XCIhPT1uLnR5cGV8fFwiZmxvYXQzMlwiIT09ci50eXBlJiZcImZsb2F0NjRcIiE9PXIudHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKDQhPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk9ubHkgc3VwcG9ydCA0LUQgaW5wdXQgc2hhcGUuXCIpfX0sNzAwNjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5jcmVhdGVMcm5Qcm9ncmFtSW5mb0xvYWRlcj10LnBhcnNlTHJuQXR0cmlidXRlcz10Lmxybj12b2lkIDA7Y29uc3Qgcj1uKDQ5MTApLG89big1NjM5KTt0Lmxybj0oZSx0LG4pPT4ocyh0KSxbZS5ydW4oYSh0LG4pLHQpXSksdC5wYXJzZUxybkF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiYWxwaGFcIiwxZS00KSxuPWUuYXR0cmlidXRlcy5nZXRGbG9hdChcImJldGFcIiwuNzUpLG89ZS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiYmlhc1wiLDEpLGk9ZS5hdHRyaWJ1dGVzLmdldEludChcInNpemVcIik7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHthbHBoYTp0LGJldGE6bixiaWFzOm8sc2l6ZTppfSl9O2NvbnN0IGk9e25hbWU6XCJMUk5cIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2Z1bmN0aW9uIGEoZSx0KXtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGkpLHtjYWNoZUhpbnQ6dC5jYWNoZUtleSxnZXQ6KCk9PmZ1bmN0aW9uKGUsdCl7Y29uc3Qgbj1lWzBdLmRpbXNbMV0scj1lWzBdLmRpbXMubGVuZ3RoLGE9LU1hdGguZmxvb3IoKHQuc2l6ZS0xKS8yKSxzPU1hdGguY2VpbCgodC5zaXplLTEpLzIpLHU9YGZsb2F0KCR7dC5hbHBoYX0pIC8gZmxvYXQoJHt0LnNpemV9KWAsbD1gXFxuICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyfV0pIHtcXG4gICAgICAgIGludCBjID0gaW5kaWNlc1sxXTtcXG4gICAgICAgIGZsb2F0IHggPSBfWChpbmRpY2VzKTtcXG4gICAgICAgIGZsb2F0IHNxdWFyZV9zdW0gPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gJHthfTsgaSA8PSAke3N9OyBpKyspIHtcXG4gICAgICAgICAgaW50IGlkeCA9IGMgKyBpO1xcbiAgICAgICAgICBpZiAoYyA+PSAwICYmIGMgPCAke259KSB7XFxuICAgICAgICAgICAgaW5kaWNlc1sxXSA9IGlkeDtcXG4gICAgICAgICAgICBmbG9hdCBqID0gX1goaW5kaWNlcyk7XFxuICAgICAgICAgICAgc3F1YXJlX3N1bSArPSBqICogajtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHggLyBwb3coZmxvYXQoJHt0LmJpYXN9KSArICR7dX0gKiBzcXVhcmVfc3VtLCBmbG9hdCgke3QuYmV0YX0pKTtcXG4gICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxpKSx7Y2FjaGVIaW50OnQuY2FjaGVLZXksb3V0cHV0OntkaW1zOmVbMF0uZGltcyx0eXBlOmVbMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6bH0pfShlLHQpfSl9dC5jcmVhdGVMcm5Qcm9ncmFtSW5mb0xvYWRlcj1hO2NvbnN0IHM9ZT0+e2lmKCFlfHwxIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTFJOIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKDQhPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcignY3VycmVudGx5IG9ubHkgc3VwcG9ydCBMUk4gZm9yIGlucHV0IHdpdGggXCJOQ0hXXCIgZm9ybWF0Jyk7aWYoXCJmbG9hdDMyXCIhPT1lWzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGJlIGZsb2F0IHR5cGVcIil9fSw1NjMyOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNzI3Myksbz1uKDY3NTcpLGk9big1NjM5KSxhPW4oNDMyKSxzPW4oMjE1MCksdT1uKDgyNzYpO3QuY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXI9KGUsdCxuKT0+e2NvbnN0IGw9KGM9dC5sZW5ndGg+MixwPW4uYWN0aXZhdGlvbkNhY2hlS2V5LHtuYW1lOlwiTWF0TXVsIChwYWNrZWQpXCIsaW5wdXROYW1lczpjP1tcIkFcIixcIkJcIixcIkJpYXNcIl06W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOmM/W2kuVGV4dHVyZVR5cGUucGFja2VkLGkuVGV4dHVyZVR5cGUucGFja2VkLGkuVGV4dHVyZVR5cGUucGFja2VkXTpbaS5UZXh0dXJlVHlwZS5wYWNrZWQsaS5UZXh0dXJlVHlwZS5wYWNrZWRdLGNhY2hlSGludDpwfSk7dmFyIGMscDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGwpLHtnZXQ6KCk9PigoZSx0LG4sbCk9Pntjb25zdCBjPW4ubGVuZ3RoPjIscD1jP1widmFsdWUgKz0gZ2V0Qmlhc0Zvck1hdG11bCgpO1wiOlwiXCIsZD1uWzBdLmRpbXMsZj1uWzFdLmRpbXMsaD1yLkJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGQsZiwhMCksZz0hci5TaGFwZVV0aWwuYXJlRXF1YWwoblswXS5kaW1zLG5bMV0uZGltcyk7aWYoIWgpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtjb25zdCBtPWRbZC5sZW5ndGgtMV0sYj1NYXRoLmNlaWwobS8yKSx5PWQubGVuZ3RoLHc9Zi5sZW5ndGgsXz0oMCxvLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx2PSgwLGEuZ2V0Q29vcmRzRGF0YVR5cGUpKGgubGVuZ3RoKSx4PWgubGVuZ3RoLFQ9KDAsYS5nZXRHbENoYW5uZWxzKSgpLHthY3RpdmF0aW9uRnVuY3Rpb246UyxhcHBseUFjdGl2YXRpb246T309KDAscy5nZXRBY3RpdmF0aW9uU25pcHBldCkobCksQT1jP2AkeygwLHUuZ2V0Qmlhc0Zvck1hdG11bCkodixULG5bMl0uZGltcyxoLCEwKX1gOlwiXCIsRT1nP2Ake2Z1bmN0aW9uKGUsdCxuLG8pe2xldCBpPVtdLGE9W107Y29uc3Qgcz1uWzBdLmRpbXMsdT1uWzFdLmRpbXMsbD1zLmxlbmd0aCxjPXUubGVuZ3RoLHA9by5sZW5ndGgsZD1wLWwsZj1wLWM7aT1zLm1hcCgoKGUsbik9PmBjb29yZHMuJHt0W24rZF19YCkpLGlbbC0xXT1cImkqMlwiLGkuam9pbihcIiwgXCIpLGE9dS5tYXAoKChlLG4pPT5gY29vcmRzLiR7dFtuK2ZdfWApKSxhW2MtMl09XCJpKjJcIixhLmpvaW4oXCIsIFwiKTtjb25zdCBoPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKHMsbyksZz1yLkJyb2FkY2FzdFV0aWwuZ2V0QnJvYWRjYXN0RGltcyh1LG8pLG09aC5tYXAoKGU9PmBjb29yZHMuJHt0W2UrZF19ID0gMDtgKSkuam9pbihcIlxcblwiKSxiPWcubWFwKChlPT5gY29vcmRzLiR7dFtlK2ZdfSA9IDA7YCkpLmpvaW4oXCJcXG5cIikseT1gaW50IGxhc3REaW0gPSBjb29yZHMuJHt0W3AtMV19O1xcbiAgY29vcmRzLiR7dFtwLTFdfSA9IGNvb3Jkcy4ke3RbcC0yXX07XFxuICBjb29yZHMuJHt0W3AtMl19ID0gbGFzdERpbTtgO3JldHVybmBcXG52ZWM0IGdldEFBdE91dENvb3Jkc01hdG11bChpbnQgaSkge1xcbiAgJHtlfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICR7eX1cXG4gICR7bX1cXG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRBKCR7aX0pO1xcbiAgcmV0dXJuIG91dHB1dFZhbHVlO1xcbn1cXG5cXG52ZWM0IGdldEJBdE91dENvb3Jkc01hdG11bChpbnQgaSkge1xcbiAgJHtlfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICR7eX1cXG4gICR7Yn1cXG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRCKCR7YX0pO1xcbiAgcmV0dXJuIG91dHB1dFZhbHVlO1xcbn1gfSh2LFQsbixoKX1gOlwiXCIsST1nP1wiZ2V0QUF0T3V0Q29vcmRzTWF0bXVsKGkpXCI6YGdldEEoJHtmdW5jdGlvbihlLHQpe2xldCBuPVwiXCI7Zm9yKGxldCByPTA7cjx0LTI7cisrKW4rPWByYy4ke2Vbcl19LCBgO3JldHVybiBuKz1gcmMuJHtlW3QtMl19LCBpKjJgLG59KFQseSl9KWAsJD1nP1wiZ2V0QkF0T3V0Q29vcmRzTWF0bXVsKGkpXCI6YGdldEIoJHtmdW5jdGlvbihlLHQpe2xldCBuPVwiXCI7Zm9yKGxldCByPTA7cjx0LTI7cisrKW4rPWByYy4ke2Vbcl19LCBgO3JldHVybiBuKz1gaSoyLCByYy4ke2VbdC0xXX1gLG59KFQsdyl9KWAsUD1gXFxuICAgICAgICAgICAgJHtFfVxcbiAgICAgICAgICAgICR7QX1cXG4gICAgICAgICAgICAke1N9XFxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICAgJHtnP1wiXCI6YCR7dn0gcmMgPVxcbiAgICAgICAgICBnZXRPdXRwdXRDb29yZHMoKTsgaW50IGxhc3REaW0gPSByYy4ke1RbeC0xXX07IHJjLiR7VFt4LTFdfSA9XFxuICAgICAgICAgIHJjLiR7VFt4LTJdfTsgcmMuJHtUW3gtMl19ID0gbGFzdERpbTtcXG4gICAgICBgfVxcblxcbiAgICAgICAgICAgICAgdmVjNCB2YWx1ZSA9IHZlYzQoMCk7XFxuICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7Yn07IGkrKykge1xcbiAgICAgICAgICAgICAgICB2ZWM0IGEgPSAke0l9O1xcbiAgICAgICAgICAgICAgICB2ZWM0IGIgPSAkeyR9O1xcblxcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAoYS5ycmJiICogYi5yZ3JnKTtcXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gKGEuZ2dhYSAqIGIuYmFiYSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAke3B9XFxuICAgICAgICAgICAgICAke099XFxuICAgICAgICAgICAgICAke18ub3V0cHV0fSA9IHZhbHVlO1xcbiAgICAgICAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dDp7ZGltczpoLHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUucGFja2VkfSxzaGFkZXJTb3VyY2U6UCxoYXNNYWluOiEwfSl9KShlLGwsdCxuKX0pfX0sODI3NjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRCaWFzRm9yTWF0bXVsPXQuY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXI9dC5wYXJzZU1hdE11bEF0dHJpYnV0ZXM9dC5tYXRNdWw9dm9pZCAwO2NvbnN0IHI9big3MjczKSxvPW4oNTYzOSksaT1uKDQzMiksYT1uKDIxNTApLHM9big1NjMyKTt0Lm1hdE11bD0oZSx0LG4pPT4oYyh0KSxlLnNlc3Npb24ucGFjaz9bZS5ydW4oKDAscy5jcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcikoZSx0LG4pLHQpXTpbZS5ydW4obCh0LG4pLHQpXSksdC5wYXJzZU1hdE11bEF0dHJpYnV0ZXM9ZT0+KDAsYS5wYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpKGUuYXR0cmlidXRlcyk7Y29uc3QgdT0oZSx0KT0+KHtuYW1lOlwiTWF0TXVsXCIsaW5wdXROYW1lczplP1tcIkFcIixcIkJcIixcIkJpYXNcIl06W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOmU/W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkXTpbby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6dH0pO2Z1bmN0aW9uIGwoZSx0KXtjb25zdCBuPXUoZS5sZW5ndGg+Mix0LmFjdGl2YXRpb25DYWNoZUtleSk7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7Z2V0OigpPT5mdW5jdGlvbihlLHQsbil7Y29uc3Qgcz10WzBdLmRpbXMsdT10WzFdLmRpbXMsbD1yLkJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKHMsdSwhMCk7aWYoIWwpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtjb25zdCBjPSgwLGkuZ2V0Q29vcmRzRGF0YVR5cGUpKGwubGVuZ3RoKSxkPSgwLGkuZ2V0R2xDaGFubmVscykoKSx7YWN0aXZhdGlvbkZ1bmN0aW9uOmYsYXBwbHlBY3RpdmF0aW9uOmh9PSgwLGEuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKG4pLGc9dC5sZW5ndGg+MixtPWc/XCJ2YWx1ZSArPSBnZXRCaWFzRm9yTWF0bXVsKCk7XCI6XCJcIixiPWc/YCR7cChjLGQsdFsyXS5kaW1zLGwsITEpfWA6XCJcIix5PWwubGVuZ3RoLHc9cy5sZW5ndGgsXz11Lmxlbmd0aCx2PWBcXG4gICAgJHtmfVxcbiAgICAke2J9XFxuICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHt5fV0pIHtcXG4gICAgICAgIGludCBhWyR7d31dO1xcbiAgICAgICAgaW50IGJbJHtffV07XFxuICAgICAgICBiY2FzdE1hdG11bEluZGljZXNfQShpbmRpY2VzLCBhKTtcXG4gICAgICAgIGJjYXN0TWF0bXVsSW5kaWNlc19CKGluZGljZXMsIGIpO1xcblxcbiAgICAgICAgZmxvYXQgdmFsdWU7XFxuICAgICAgICBmb3IgKGludCBrPTA7IGs8JHtzW3MubGVuZ3RoLTFdfTsgKytrKSB7XFxuICAgICAgICAgICAgYVske3ctMX1dID0gaztcXG4gICAgICAgICAgICBiWyR7Xy0yfV0gPSBrO1xcbiAgICAgICAgICAgIHZhbHVlICs9IF9BKGEpICogX0IoYik7XFxuICAgICAgICB9XFxuICAgICAgICAke219XFxuICAgICAgICAke2h9XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpsLHR5cGU6dFswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTp2fSl9KG4sZSx0KX0pfXQuY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXI9bDtjb25zdCBjPWU9PntpZighZXx8MiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk1hdE11bCByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zW2VbMF0uZGltcy5sZW5ndGgtMV0hPT1lWzFdLmRpbXNbZVsxXS5kaW1zLmxlbmd0aC0yXSl0aHJvdyBuZXcgRXJyb3IoXCJzaGFyZWQgZGltZW5zaW9uIGRvZXMgbm90IG1hdGNoLlwiKTtpZihcImZsb2F0MzJcIiE9PWVbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT1lWzBdLnR5cGV8fFwiZmxvYXQzMlwiIT09ZVsxXS50eXBlJiZcImZsb2F0NjRcIiE9PWVbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dHMgc2hvdWxkIGJlIGZsb2F0IHR5cGVcIik7aWYoZVswXS50eXBlIT09ZVsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcImlucHV0cyB0eXBlcyBzaG91bGQgbWF0Y2hcIil9O2Z1bmN0aW9uIHAoZSx0LG4sbyxpKXtsZXQgYT1cIlwiO2NvbnN0IHM9bi5sZW5ndGgsdT1vLmxlbmd0aCxsPXUtczthPXU8MiYmcz4wP1wiY29vcmRzXCI6bi5tYXAoKChlLG4pPT5gY29vcmRzLiR7dFtuK2xdfWApKS5qb2luKFwiLCBcIik7Y29uc3QgYz1yLkJyb2FkY2FzdFV0aWwuZ2V0QnJvYWRjYXN0RGltcyhuLG8pLm1hcCgoZT0+YGNvb3Jkcy4ke3RbZStsXX0gPSAwO2ApKS5qb2luKFwiXFxuXCIpO2xldCBwPVwidmVjNChvdXRwdXRWYWx1ZS54eCwgb3V0cHV0VmFsdWUueXkpXCI7cmV0dXJuIDE9PT1yLlNoYXBlVXRpbC5zaXplKG4pJiYocD1cInZlYzQob3V0cHV0VmFsdWUueClcIiksaT9gXFxudmVjNCBnZXRCaWFzRm9yTWF0bXVsKCkge1xcbiAgJHtlfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICR7Y31cXG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRCaWFzKCR7YX0pO1xcbiAgcmV0dXJuICR7cH07XFxufWA6YFxcbmZsb2F0IGdldEJpYXNGb3JNYXRtdWwoKSB7XFxuICAke2V9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgJHtjfVxcbiAgcmV0dXJuIGdldEJpYXMoY29vcmRzLngpO1xcbn1gfXQuZ2V0Qmlhc0Zvck1hdG11bD1wfSw5OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNyZWF0ZVBhY2tQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDY3NTcpLG89big1NjM5KSxpPW4oNDMyKSxhPW4oNTYxNCkscz17bmFtZTpcInBhY2tcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZFJldmVyc2VkXX07dC5jcmVhdGVQYWNrUHJvZ3JhbUluZm9Mb2FkZXI9KGUsdCk9Pk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Z2V0OigpPT4oKGUsdCk9Pntjb25zdCBuPSgwLHIuZ2V0R2xzbCkoZS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLHU9dC5kaW1zLGw9dS5sZW5ndGgsYz10LmRpbXMubGVuZ3RoLHA9KDAsaS5nZXRDb29yZHNEYXRhVHlwZSkoYyksZD0oMCxhLmdldENoYW5uZWxzKShcInJjXCIsYyksZj0oaD1jLGc9ZCxtPXVbdS5sZW5ndGgtMl0sYj11W3UubGVuZ3RoLTFdLDA9PT1ofHwxPT09aD9cIlwiOmBcXG4gICAgaW50IHIgPSAke2dbaC0yXX07XFxuICAgIGludCBjID0gJHtnW2gtMV19O1xcbiAgICBpbnQgcnAxID0gJHtnW2gtMl19ICsgMTtcXG4gICAgaW50IGNwMSA9ICR7Z1toLTFdfSArIDE7XFxuICAgIGJvb2wgckVkZ2UgPSBycDEgPj0gJHtifTtcXG4gICAgYm9vbCBjRWRnZSA9IGNwMSA+PSAke219O1xcbiAgICBgKTt2YXIgaCxnLG0sYjtsZXQgeTt5PTA9PT1sP1sxLDFdOjE9PT1sP1t1WzBdLDFdOlt1W2MtMV0sdVtjLTJdXTtjb25zdCB3PWZ1bmN0aW9uKGUsdCxuKXtpZigwPT09ZSlyZXR1cm5cImZhbHNlXCI7aWYoMT09PWUpcmV0dXJuYHJjID4gJHt0WzBdfWA7bGV0IHI9XCJcIjtmb3IobGV0IG89ZS0yO288ZTtvKyspcis9YCR7bltvXX0gPj0gJHt0W28tZSsyXX1gLG88ZS0xJiYocis9XCJ8fFwiKTtyZXR1cm4gcn0oYyx5LGQpLF89ZnVuY3Rpb24oZSx0KXtjb25zdCBuPWUubGVuZ3RoO2lmKDA9PT1uKXJldHVyblwiZ2V0QSgpLCAwLCAwLCAwXCI7aWYoMT09PW4pcmV0dXJuYGdldEEocmMpLFxcbiAgICAgICAgICAgIHJjICsgMSA+PSAke2VbMF19ID8gMC4gOiBnZXRBKHJjICsgMSksXFxuICAgICAgICAgICAgMCwgMGA7bGV0IHI9XCJcIjtpZihuPjIpZm9yKGxldCBlPTA7ZTxuLTI7KytlKXIrPWAke3RbZV19LGA7cmV0dXJuYGdldEEoJHtyfXIsIGMpLFxcbiAgICAgICAgICByRWRnZSA/IDAuIDogZ2V0QSgke3J9cnAxLCBjKSxcXG4gICAgICAgICAgY0VkZ2UgPyAwLiA6IGdldEEoJHtyfXIsIGNwMSksXFxuICAgICAgICAgIHJFZGdlIHx8IGNFZGdlID8gMC4gOiBnZXRBKCR7cn1ycDEsIGNwMSlgfSh1LGQpLHY9YFxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAke3B9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICAgIGlmKCR7d30pIHtcXG4gICAgICAgICAgICAke24ub3V0cHV0fSA9IHZlYzQoMCk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgJHtmfVxcblxcbiAgICAgICAgICAgICR7bi5vdXRwdXR9ID0gdmVjNCgke199KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7aGFzTWFpbjohMCxvdXRwdXQ6e2RpbXM6dC5kaW1zLHR5cGU6dC50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUucGFja2VkfSxzaGFkZXJTb3VyY2U6dn0pfSkoZSx0KX0pfSw1NjE0OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnVucGFja0Zyb21DaGFubmVsPXQuZ2V0Q2hhbm5lbHM9dC5nZXRWZWNDaGFubmVscz12b2lkIDA7Y29uc3Qgcj1uKDQzMik7ZnVuY3Rpb24gbyhlLHQpe3JldHVybigwLHIuZ2V0R2xDaGFubmVscykodCkubWFwKCh0PT5gJHtlfS4ke3R9YCkpfXQuZ2V0VmVjQ2hhbm5lbHM9byx0LmdldENoYW5uZWxzPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDE9PT10P1tlXTpvKGUsdCl9LHQudW5wYWNrRnJvbUNoYW5uZWw9ZnVuY3Rpb24oKXtyZXR1cm5cIlxcbiAgICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgaW50IGRpbSkge1xcbiAgICAgIGludCBtb2RDb29yZCA9IGltb2QoZGltLCAyKTtcXG4gICAgICByZXR1cm4gbW9kQ29vcmQgPT0gMCA/IGZyYWcuciA6IGZyYWcuZztcXG4gICAgfVxcblxcbiAgICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgdmVjMiBpbm5lckRpbXMpIHtcXG4gICAgICB2ZWMyIG1vZENvb3JkID0gbW9kKGlubmVyRGltcywgMi4pO1xcbiAgICAgIHJldHVybiBtb2RDb29yZC54ID09IDAuID9cXG4gICAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5yIDogZnJhZy5nKSA6XFxuICAgICAgICAobW9kQ29vcmQueSA9PSAwLiA/IGZyYWcuYiA6IGZyYWcuYSk7XFxuICAgIH1cXG4gIFwifX0sNTU2NTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZVBhZEF0dHJpYnV0ZXNWMTE9dC5wYWRWMTE9dC5wYXJzZVBhZEF0dHJpYnV0ZXNWMj10LnBhZFYyPXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDcyNzMpLGk9big2NzU3KSxhPW4oNTYzOSkscz17bmFtZTpcIlBhZFwiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkXX07dC5wYWRWMj0oZSx0LG4pPT4oYyh0KSxbZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9PmwoZSx0WzBdLG4pfSksdCldKSx0LnBhcnNlUGFkQXR0cmlidXRlc1YyPWU9Pntjb25zdCB0PWUuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJtb2RlXCIsXCJjb25zdGFudFwiKSxuPWUuYXR0cmlidXRlcy5nZXRGbG9hdChcInZhbHVlXCIsMCksbz1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcInBhZHNcIik7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHttb2RlOnQsdmFsdWU6bixwYWRzOm99KX0sdC5wYWRWMTE9KGUsbixyKT0+e3Aobik7Y29uc3Qgbz11KGUsbixyKTtyZXR1cm4oMCx0LnBhZFYyKShlLFtuWzBdXSxvKX0sdC5wYXJzZVBhZEF0dHJpYnV0ZXNWMTE9ZT0+ZS5hdHRyaWJ1dGVzLmdldFN0cmluZyhcIm1vZGVcIixcImNvbnN0YW50XCIpO2NvbnN0IHU9KGUsdCxuKT0+e2lmKCFlLnNlc3Npb24uaXNJbml0aWFsaXplcih0WzFdLmRhdGFJZCl8fHQubGVuZ3RoPj0zJiYhZS5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIodFsyXS5kYXRhSWQpKXRocm93IG5ldyBFcnJvcihcImR5bmFtaWMgcGFkIGF0dHJpYnV0ZXMgYXJlIG5vdCBhbGxvd2VkXCIpO2NvbnN0IG89QXJyYXkuZnJvbSh0WzFdLmludGVnZXJEYXRhKSxpPXQubGVuZ3RoPj0zP3RbMl0uZmxvYXREYXRhWzBdOjA7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHttb2RlOm4scGFkczpvLHZhbHVlOml9KX0sbD0oZSx0LG4pPT57Y29uc3Qgcj1vLlNoYXBlVXRpbC5wYWRTaGFwZSh0LmRpbXMuc2xpY2UoKSxuLnBhZHMpLGk9ci5sZW5ndGgscz1gXFxuICAgICAgJHtkKGUsdCxuKX1cXG4gICAgICBmbG9hdCBwcm9jZXNzKGludFske2l9XSBpbmRpY2VzKSB7XFxuICAgICAgICAgIHJldHVybiBwYWRBKGluZGljZXMpO1xcbiAgICAgIH1gO3JldHVybntuYW1lOlwiUGFkXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2EuVGV4dHVyZVR5cGUudW5wYWNrZWRdLG91dHB1dDp7ZGltczpyLHR5cGU6dC50eXBlLHRleHR1cmVUeXBlOmEuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpzfX0sYz1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJQYWQgcmVxdWlyZXMgMSBpbnB1dFwiKTtpZihcImZsb2F0MzJcIiE9PWVbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT1lWzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0scD1lPT57aWYoIWV8fDIhPT1lLmxlbmd0aCYmMyE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlBhZCByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKFwiaW50MzJcIiE9PWVbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKGUubGVuZ3RoPj0zJiZcInN0cmluZ1wiPT09ZVsyXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9LGQ9KGUsdCxuKT0+e2NvbnN0IHI9KDAsaS5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksW3MsdV09ZS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQodC5kaW1zLGEuVGV4dHVyZVR5cGUudW5wYWNrZWQpLGw9by5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXModC5kaW1zKTtzd2l0Y2gobi5tb2RlKXtjYXNlXCJjb25zdGFudFwiOnJldHVybiBmKHIsdC5kaW1zLGwscyx1LG4ucGFkcyxuLnZhbHVlKTtjYXNlXCJyZWZsZWN0XCI6cmV0dXJuIGgocix0LmRpbXMsbCxzLHUsbi5wYWRzKTtjYXNlXCJlZGdlXCI6cmV0dXJuIGcocix0LmRpbXMsbCxzLHUsbi5wYWRzKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbW9kZVwiKX19LGY9KGUsdCxuLHIsbyxpLGEpPT57Y29uc3Qgcz10Lmxlbmd0aDtsZXQgdT1cIlwiO2ZvcihsZXQgZT1zLTE7ZT49MDstLWUpdSs9YFxcbiAgICAgICAgayA9IG1bJHtlfV0gLSAke2lbZV19O1xcbiAgICAgICAgaWYgKGsgPCAwKSAgcmV0dXJuIGNvbnN0YW50O1xcbiAgICAgICAgaWYgKGsgPj0gJHt0W2VdfSkgcmV0dXJuIGNvbnN0YW50O1xcbiAgICAgICAgb2Zmc2V0ICs9IGsgKiAke25bZV19O1xcbiAgICAgICAgYDtyZXR1cm5gXFxuICAgICAgZmxvYXQgcGFkQShpbnQgbVske3N9XSkge1xcbiAgICAgICAgY29uc3QgZmxvYXQgY29uc3RhbnQgPSBmbG9hdCgke2F9KTtcXG4gICAgICAgIGludCBvZmZzZXQgPSAwO1xcbiAgICAgICAgaW50IGsgPSAwO1xcbiAgICAgICAgJHt1fVxcbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7cn0sICR7b30pO1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHtlLnRleHR1cmUyRH0oQSwgY29vcmRzKSk7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGB9LGg9KGUsdCxuLHIsbyxpKT0+e2NvbnN0IGE9dC5sZW5ndGg7bGV0IHM9XCJcIjtmb3IobGV0IGU9YS0xO2U+PTA7LS1lKXMrPWBcXG4gICAgICAgIGsgPSBtWyR7ZX1dIC0gJHtpW2VdfTtcXG4gICAgICAgIGlmIChrIDwgMCkgeyBrID0gLWs7IH1cXG4gICAgICAgIHtcXG4gICAgICAgICAgY29uc3QgaW50IF8ybl8xID0gJHsyKih0W2VdLTEpfTtcXG4gICAgICAgICAgayA9IGludCggbW9kKCBmbG9hdChrKSwgZmxvYXQoXzJuXzEpICkgKSA7XFxuICAgICAgICAgIGlmKGsgPj0gJHt0W2VdfSkgeyBrID0gXzJuXzEgLSBrOyB9XFxuICAgICAgICB9XFxuICAgICAgICBvZmZzZXQgKz0gayAqICR7bltlXX07XFxuICAgICAgICBgO3JldHVybmBcXG4gICAgICBmbG9hdCBwYWRBKGludCBtWyR7YX1dKSB7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcXG4gICAgICAgIGludCBrID0gMDtcXG4gICAgICAgICR7c31cXG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke3J9LCAke299KTtcXG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7ZS50ZXh0dXJlMkR9KEEsIGNvb3JkcykpO1xcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH1cXG4gICAgICBgfSxnPShlLHQsbixyLG8saSk9Pntjb25zdCBhPXQubGVuZ3RoO2xldCBzPVwiXCI7Zm9yKGxldCBlPWEtMTtlPj0wOy0tZSlzKz1gXFxuICAgICAgICBrID0gbVske2V9XSAtICR7aVtlXX07XFxuICAgICAgICBpZiAoayA8IDApICBrID0gMDtcXG4gICAgICAgIGlmIChrID49ICR7dFtlXX0pIGsgPSAke3RbZV0tMX07XFxuICAgICAgICBvZmZzZXQgKz0gayAqICR7bltlXX07XFxuICAgICAgYDtyZXR1cm5gXFxuICAgICAgZmxvYXQgcGFkQShpbnQgbVske2F9XSkge1xcbiAgICAgICAgaW50IG9mZnNldCA9IDA7XFxuICAgICAgICBpbnQgayA9IDA7XFxuICAgICAgICAke3N9XFxuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHtyfSwgJHtvfSk7XFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke2UudGV4dHVyZTJEfShBLCBjb29yZHMpKTtcXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9XFxuICAgICAgYH19LDI4MzQ6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2xvYmFsTWF4UG9vbD10LnBhcnNlTWF4UG9vbEF0dHJpYnV0ZXM9dC5tYXhQb29sPXQucGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXM9dC5nbG9iYWxBdmVyYWdlUG9vbD10LnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzPXQuYXZlcmFnZVBvb2w9dm9pZCAwO2NvbnN0IHI9big0OTEwKSxvPW4oNzI3MyksaT1uKDU2MzkpO3QuYXZlcmFnZVBvb2w9KGUsdCxuKT0+e3AodCk7Y29uc3Qgcj17bmFtZTpcIkF2ZXJhZ2VQb29sXCIsaW5wdXROYW1lczpbXCJYXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDpuLmNhY2hlS2V5fTtyZXR1cm5bZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHtnZXQ6KCk9PmEodCxyLCExLG4pfSksdCldfSx0LnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzPWU9Pntjb25zdCB0PWUuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJhdXRvX3BhZFwiLFwiTk9UU0VUXCIpLG49ZS5hdHRyaWJ1dGVzLmdldEludChcImNlaWxfbW9kZVwiLDApLG89MCE9PWUuYXR0cmlidXRlcy5nZXRJbnQoXCJjb3VudF9pbmNsdWRlX3BhZFwiLDApLGk9ZS5hdHRyaWJ1dGVzLmdldEludHMoXCJrZXJuZWxfc2hhcGVcIiksYT1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcInN0cmlkZXNcIixbXSkscz1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcInBhZHNcIixbXSk7aWYoMCE9PW4pdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBBdmVyYWdlUG9vbFwiKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F1dG9QYWQ6dCxjZWlsTW9kZTpuLGNvdW50SW5jbHVkZVBhZDpvLGtlcm5lbFNoYXBlOmksc3RyaWRlczphLHBhZHM6c30pfTtjb25zdCBhPShlLHQsbixyKT0+e2NvbnN0W2Esc109dShlLHIsbiksbD1vLlNoYXBlVXRpbC5zaXplKGEua2VybmVsU2hhcGUpO2xldCBjPVwiXCI7YS5jb3VudEluY2x1ZGVQYWQ/Yys9YHZhbHVlIC89IGZsb2F0KCR7bH0pO2A6Yys9YHZhbHVlIC89IGZsb2F0KCR7bH0gLSBwYWQpO2A7Y29uc3QgcD1gXFxuICAgICAgICAke2QoZVswXS5kaW1zLGEsXCJ2YWx1ZSArPSBfWCh4KTtcIixjLFwiMC4wXCIpfVxcbiAgICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7b3V0cHV0OntkaW1zOnMsdHlwZTplWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnB9KX07dC5nbG9iYWxBdmVyYWdlUG9vbD0oZSx0LG4pPT57cCh0KTtjb25zdCByPXtuYW1lOlwiR2xvYmFsQXZlcmFnZVBvb2xcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZF0sY2FjaGVIaW50OmAke24uY291bnRJbmNsdWRlUGFkfWB9O3JldHVybltlLnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+YSh0LHIsITAsbil9KSx0KV19LHQucGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9MCE9PWUuYXR0cmlidXRlcy5nZXRJbnQoXCJjb3VudF9pbmNsdWRlX3BhZFwiLDApO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXV0b1BhZDpcIlwiLGNlaWxNb2RlOjAsY291bnRJbmNsdWRlUGFkOnQsa2VybmVsU2hhcGU6W10sc3RyaWRlczpbXSxwYWRzOltdfSl9LHQubWF4UG9vbD0oZSx0LG4pPT57cCh0KTtjb25zdCByPXtuYW1lOlwiTWF4UG9vbFwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6bi5jYWNoZUtleX07cmV0dXJuW2UucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7Z2V0OigpPT5zKHQsciwhMSxuKX0pLHQpXX0sdC5wYXJzZU1heFBvb2xBdHRyaWJ1dGVzPWU9Pntjb25zdCB0PWUuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJhdXRvX3BhZFwiLFwiTk9UU0VUXCIpLG49ZS5hdHRyaWJ1dGVzLmdldEludChcImNlaWxfbW9kZVwiLDApLG89ZS5hdHRyaWJ1dGVzLmdldEludHMoXCJrZXJuZWxfc2hhcGVcIiksaT1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcInN0cmlkZXNcIixbXSksYT1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcInBhZHNcIixbXSkscz1lLmF0dHJpYnV0ZXMuZ2V0SW50KFwic3RvcmFnZV9vcmRlclwiLDApLHU9ZS5hdHRyaWJ1dGVzLmdldEludHMoXCJkaWxhdGlvbnNcIixbXSk7aWYoMCE9PXMpdGhyb3cgbmV3IEVycm9yKFwiY29sdW1uIG1ham9yIHN0b3JhZ2Ugb3JkZXIgaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7aWYoMCE9PW4pdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXV0b1BhZDp0LGNlaWxNb2RlOm4sY291bnRJbmNsdWRlUGFkOiExLGtlcm5lbFNoYXBlOm8sc3RyaWRlczppLHBhZHM6YSxzdG9yYWdlT3JkZXI6cyxkaWxhdGlvbnM6dX0pfTtjb25zdCBzPShlLHQsbixyKT0+e2NvbnN0W28sYV09dShlLHIsbikscz1gXFxuICAgICAgJHtkKGVbMF0uZGltcyxvLFwiXFxuICAgICAgdmFsdWUgPSBtYXgoX1goeCksIHZhbHVlKTtcXG4gICAgXCIsXCJcIixcIi0xZTVcIil9XFxuICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7b3V0cHV0OntkaW1zOmEsdHlwZTplWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnN9KX0sdT0oZSx0LG4pPT57Y29uc3Qgcj1lWzBdLmRpbXMuc2xpY2UoKSxpPU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsXCJkaWxhdGlvbnNcIiksYT10Lmtlcm5lbFNoYXBlLnNsaWNlKCkscz10LnN0cmlkZXMuc2xpY2UoKSx1PWk/dC5kaWxhdGlvbnMuc2xpY2UoKTpbXSxsPXQucGFkcy5zbGljZSgpO28uUG9vbENvbnZVdGlsLmFkanVzdFBvb2xBdHRyaWJ1dGVzKG4scixhLHMsdSxsKTtjb25zdCBjPW8uUG9vbENvbnZVdGlsLmNvbXB1dGVQb29sT3V0cHV0U2hhcGUobixyLHMsdSxhLGwsdC5hdXRvUGFkKSxwPU9iamVjdC5hc3NpZ24oe30sdCk7cmV0dXJuIGk/T2JqZWN0LmFzc2lnbihwLHtrZXJuZWxTaGFwZTphLHN0cmlkZXM6cyxwYWRzOmwsZGlsYXRpb25zOnUsY2FjaGVLZXk6dC5jYWNoZUtleX0pOk9iamVjdC5hc3NpZ24ocCx7a2VybmVsU2hhcGU6YSxzdHJpZGVzOnMscGFkczpsLGNhY2hlS2V5OnQuY2FjaGVLZXl9KSxbcCxjXX0sbD17YXV0b1BhZDpcIlwiLGNlaWxNb2RlOjAsY291bnRJbmNsdWRlUGFkOiExLGtlcm5lbFNoYXBlOltdLHN0cmlkZXM6W10scGFkczpbXSxzdG9yYWdlT3JkZXI6MCxkaWxhdGlvbnM6W10sY2FjaGVLZXk6XCJcIn0sYz17bmFtZTpcIkdsb2JhbE1heFBvb2xcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O3QuZ2xvYmFsTWF4UG9vbD0oZSx0KT0+KHAodCksW2UucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxjKSx7Z2V0OigpPT5zKHQsYywhMCxsKX0pLHQpXSk7Y29uc3QgcD1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJQb29sIG9wcyByZXF1aXJlcyAxIGlucHV0LlwiKTtpZihcImZsb2F0MzJcIiE9PWVbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT1lWzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0sZD0oZSx0LG4scixpKT0+e2NvbnN0IGE9ZS5sZW5ndGg7aWYodC5rZXJuZWxTaGFwZS5sZW5ndGg8PTIpe2NvbnN0IG89dC5rZXJuZWxTaGFwZVt0Lmtlcm5lbFNoYXBlLmxlbmd0aC0xXSxzPXQuc3RyaWRlc1t0LnN0cmlkZXMubGVuZ3RoLTFdLHU9dC5wYWRzW3QucGFkcy5sZW5ndGgvMi0xXSxsPXQucGFkc1t0LnBhZHMubGVuZ3RoLTFdLGM9ZVthLTFdO2xldCBwPVwiXCIsZD1cIlwiLGY9XCJcIjtpZihwPXUrbCE9PTA/YFxcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7b307IGkrKykge1xcbiAgICAgICAgICAgIHhbJHthfSAtIDFdID0gaW5kaWNlc1ske2F9IC0gMV0gKiAke3N9IC0gJHt1fSArIGk7XFxuICAgICAgICAgICAgaWYgKHhbJHthfSAtIDFdIDwgMCB8fCB4WyR7YX0gLSAxXSA+PSAke2N9KSB7XFxuICAgICAgICAgICAgICBwYWQrKztcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAke259XFxuICAgICAgICAgIH1gOmBcXG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke299OyBpKyspIHtcXG4gICAgICAgICAgICB4WyR7YX0gLSAxXSA9IGluZGljZXNbJHthfSAtIDFdICogJHtzfSAtICR7dX0gKyBpO1xcbiAgICAgICAgICAgICR7bn1cXG4gICAgICAgICAgfWAsMj09PXQua2VybmVsU2hhcGUubGVuZ3RoKXtjb25zdCBuPXQua2VybmVsU2hhcGVbdC5rZXJuZWxTaGFwZS5sZW5ndGgtMl0scj10LnN0cmlkZXNbdC5zdHJpZGVzLmxlbmd0aC0yXSxpPXQucGFkc1t0LnBhZHMubGVuZ3RoLzItMl0scz10LnBhZHNbdC5wYWRzLmxlbmd0aC0yXSx1PWVbYS0yXTtkPWkrcyE9PTA/YFxcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgJHtufTsgaisrKSB7XFxuICAgICAgICAgICAgICB4WyR7YX0gLSAyXSA9IGluZGljZXNbJHthfSAtIDJdICogJHtyfSAtICR7aX0gKyBqO1xcbiAgICAgICAgICAgICAgaWYgKHhbJHthfSAtIDJdIDwgMCB8fCB4WyR7YX0gLSAyXSA+PSAke3V9KSB7XFxuICAgICAgICAgICAgICAgIHBhZCs9ICR7b307XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICBgOmBcXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8ICR7bn07IGorKykge1xcbiAgICAgICAgICAgICAgeFske2F9IC0gMl0gPSBpbmRpY2VzWyR7YX0gLSAyXSAqICR7cn0gLSAke2l9ICsgajtcXG4gICAgICAgICAgICBgLGY9XCJcXG4gICAgICAgICAgfVxcbiAgICAgICAgXCJ9cmV0dXJuYFxcbiAgICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2F9XSkge1xcbiAgICAgICAgICBpbnQgeFske2F9XTtcXG4gICAgICAgICAgY29weVZlYyhpbmRpY2VzLCB4KTtcXG5cXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSAke2l9O1xcbiAgICAgICAgICBpbnQgcGFkID0gMDtcXG4gICAgICAgICAgJHtkfVxcbiAgICAgICAgICAke3B9XFxuICAgICAgICAgICR7Zn1cXG4gICAgICAgICAgJHtyfVxcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgYH17Y29uc3Qgcz1vLlNoYXBlVXRpbC5zaXplKHQua2VybmVsU2hhcGUpLHU9by5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXModC5rZXJuZWxTaGFwZSksbD11Lmxlbmd0aCxjPXQucGFkcy5sZW5ndGgscD1oKGwpLGQ9ZihlLFwiaW5wdXREaW1zXCIpLGc9Zih0LnBhZHMsXCJwYWRzXCIpLG09Zih1LFwia2VybmVsU3RyaWRlc1wiKSxiPWYodC5zdHJpZGVzLFwic3RyaWRlc1wiKTtsZXQgeT1cIlwiO3JldHVybiB5PXQucGFkcy5yZWR1Y2UoKChlLHQpPT5lK3QpKT9gXFxuICAgICAgICAgICAgaWYgKHhbal0gPj0gaW5wdXREaW1zW2pdIHx8IHhbal0gPCAwKSB7XFxuICAgICAgICAgICAgICBwYWQrKztcXG4gICAgICAgICAgICAgIGlzUGFkID0gdHJ1ZTtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoIWlzUGFkKSB7XFxuICAgICAgICAgICAgJHtufVxcbiAgICAgICAgICB9YDpgXFxuICAgICAgICAgIH1cXG4gICAgICAgICAgJHtufVxcbiAgICAgICAgYCxgXFxuICAgICAgICAke3B9XFxuICAgICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7YX1dKSB7XFxuICAgICAgICAgIGludCB4WyR7YX1dO1xcbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIHgpO1xcbiAgICAgICAgICBpbnQgb2Zmc2V0WyR7bH1dO1xcbiAgICAgICAgICBpbnQgcGFkc1ske2N9XTtcXG4gICAgICAgICAgaW50IGlucHV0RGltc1ske2F9XTtcXG4gICAgICAgICAgaW50IGtlcm5lbFN0cmlkZXNbJHtsfV07XFxuICAgICAgICAgIGludCBzdHJpZGVzWyR7bH1dO1xcbiAgICAgICAgICAke2d9XFxuICAgICAgICAgICR7ZH1cXG4gICAgICAgICAgJHtifVxcbiAgICAgICAgICAke219XFxuXFxuICAgICAgICAgIGZsb2F0IHZhbHVlID0gJHtpfTtcXG4gICAgICAgICAgaW50IHBhZCA9IDA7XFxuICAgICAgICAgIGJvb2wgaXNQYWQgPSBmYWxzZTtcXG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke3N9OyBpKyspIHtcXG4gICAgICAgICAgICBvZmZzZXRUb0luZGljZXMoaSwga2VybmVsU3RyaWRlcywgb2Zmc2V0KTtcXG4gICAgICAgICAgICBpc1BhZCA9IGZhbHNlO1xcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAke2F9IC0gJHtsfTsgaiA8ICR7YX07IGorKykge1xcbiAgICAgICAgICAgICAgeFtqXSA9IGluZGljZXNbal0gKiBzdHJpZGVzW2ogLSAke2F9ICsgJHtsfV1cXG4gICAgICAgICAgICAgICAgKyBvZmZzZXRbaiAtICR7YX0gKyAke2x9XSAtIHBhZHNbaiAtIDJdO1xcbiAgICAgICAgICAgICAgJHt5fVxcbiAgICAgICAgICB9XFxuICAgICAgICAgICR7cn1cXG5cXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIGB9fSxmPShlLHQpPT57bGV0IG49XCJcIjtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyluKz1gXFxuICAgICAgJHt0fVske3J9XSA9ICR7ZVtyXX07XFxuICAgIGA7cmV0dXJuIG59LGg9ZT0+YFxcbiAgdm9pZCBvZmZzZXRUb0luZGljZXMoaW50IG9mZnNldCwgaW50WyR7ZX1dIHN0cmlkZXMsIG91dCBpbnRbJHtlfV0gaW5kaWNlcykge1xcbiAgICBpZiAoJHtlfSA9PSAwKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtlfSAtIDE7ICsraSkge1xcbiAgICAgIGluZGljZXNbaV0gPSBvZmZzZXQgLyBzdHJpZGVzW2ldO1xcbiAgICAgIG9mZnNldCAtPSBpbmRpY2VzW2ldICogc3RyaWRlc1tpXTtcXG4gICAgfVxcbiAgICBpbmRpY2VzWyR7ZX0gLSAxXSA9IG9mZnNldDtcXG4gIH1gfSwxMDEwOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnJlZHVjZUxvZ1N1bVNxdWFyZT10LnJlZHVjZUxvZ1N1bT10LnJlZHVjZVByb2Q9dC5yZWR1Y2VNaW49dC5yZWR1Y2VNYXg9dC5yZWR1Y2VNZWFuPXQucmVkdWNlU3VtPXQucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzPXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDYxNDUpLGk9big3MjczKSxhPW4oNTYzOSkscz0oZSx0LG4scixvKT0+e2wodCk7Y29uc3QgaT17bmFtZTpyLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkXX07cmV0dXJuW2UucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxpKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT51KGUsdCxuLHIsbyxpKX0pLHQpXX07dC5wYXJzZVJlZHVjZUF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5hdHRyaWJ1dGVzLmdldEludHMoXCJheGVzXCIsW10pLG49MT09PWUuYXR0cmlidXRlcy5nZXRJbnQoXCJrZWVwZGltc1wiLDEpO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXhlczp0LGtlZXBEaW1zOm59KX07Y29uc3QgdT0oZSx0LG4scixvLHMpPT57Y29uc3QgdT1bXSxsPXRbMF0uZGltcy5sZW5ndGh8fDEsYz1bXSxwPWkuU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXMobi5heGVzLHRbMF0uZGltcy5sZW5ndGgpLGQ9byh0LHApO2xldCBmPWRbMV07Zm9yKGxldCBlPTA7ZTx0WzBdLmRpbXMubGVuZ3RoO2UrKylwLmluZGV4T2YoZSk+PTB8fDA9PT1wLmxlbmd0aD8obi5rZWVwRGltcyYmdS5wdXNoKDEpLGY9YFxcbiAgICAgICAgICBmb3IoaW50IGoke2V9ID0gMDsgaiR7ZX0gPCAke3RbMF0uZGltc1tlXX07IGoke2V9KyspIHtcXG4gICAgICAgICAgICBpbnB1dElkeFske2V9XSA9IGoke2V9O1xcbiAgICAgICAgICAgICR7Zn1cXG4gICAgICAgICAgfWApOihjLnB1c2goYGlucHV0SWR4WyR7ZX1dID0gb3V0cHV0SWR4WyR7dS5sZW5ndGh9XTtgKSx1LnB1c2godFswXS5kaW1zW2VdKSk7Y29uc3QgaD1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7dS5sZW5ndGh8fDF9XSkge1xcbiAgICAgICAgZmxvYXQgdmFsdWU7ICAgICAgICAgICAgICAgICAvLyBmaW5hbCByZXN1bHRcXG4gICAgICAgIGludCBpbnB1dElkeFske2x9XTsgICAgICAvLyBhZGRyZXNzaW5nIGlucHV0IGRhdGFcXG4gICAgICAgICR7Yy5qb2luKFwiXFxuXCIpfVxcbiAgICAgICAgJHtkWzBdfSAgICAgICAvLyBpbml0IG9wcyBmb3IgcmVkdWNlIG1heC9taW5cXG4gICAgICAgICR7Zn1cXG4gICAgICAgICR7ZFsyXX0gICAgICAgLy8gZmluYWwgY29tcHV0YXRpb24gZm9yIHJlZHVjZSBtZWFuXFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7b3V0cHV0OntkaW1zOnUsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmh9KX0sbD1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJSZWR1Y2Ugb3AgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoLTE9PT1vLk5VTUJFUl9UWVBFUy5pbmRleE9mKGVbMF0udHlwZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX07dC5yZWR1Y2VTdW09KGUsdCxuKT0+cyhlLHQsbixcIlJlZHVjZVN1bVwiLCgoKT0+W1widmFsdWUgPSAwLjA7XCIsXCJ2YWx1ZSArPSBfQShpbnB1dElkeCk7XCIsXCJcIl0pKSx0LnJlZHVjZU1lYW49KGUsdCxuKT0+cyhlLHQsbixcIlJlZHVjZU1lYW5cIiwoKGUsdCk9PntsZXQgbj0xO2ZvcihsZXQgcj0wO3I8ZVswXS5kaW1zLmxlbmd0aDtyKyspKHQuaW5kZXhPZihyKT49MHx8MD09PXQubGVuZ3RoKSYmKG4qPWVbMF0uZGltc1tyXSk7cmV0dXJuW1widmFsdWUgPSAwLjA7XCIsXCJ2YWx1ZSArPSBfQShpbnB1dElkeCk7XCIsYHZhbHVlIC89ICR7bn0uO2BdfSkpLHQucmVkdWNlTWF4PShlLHQsbik9PnMoZSx0LG4sXCJSZWR1Y2VNYXhcIiwoKGUsdCk9Pntjb25zdCBuPVtdO2ZvcihsZXQgcj0wO3I8ZVswXS5kaW1zLmxlbmd0aDtyKyspKHQuaW5kZXhPZihyKT49MHx8MD09PXQubGVuZ3RoKSYmbi5wdXNoKGBpbnB1dElkeFske3J9XSA9IDA7YCk7cmV0dXJuW2Ake24uam9pbihcIlxcblwiKX1cXG52YWx1ZSA9IF9BKGlucHV0SWR4KTtgLFwidmFsdWUgPSBtYXgodmFsdWUsIF9BKGlucHV0SWR4KSk7XCIsXCJcIl19KSksdC5yZWR1Y2VNaW49KGUsdCxuKT0+cyhlLHQsbixcIlJlZHVjZU1pblwiLCgoZSx0KT0+e2NvbnN0IG49W107Zm9yKGxldCByPTA7cjxlWzBdLmRpbXMubGVuZ3RoO3IrKykodC5pbmRleE9mKHIpPj0wfHwwPT09dC5sZW5ndGgpJiZuLnB1c2goYGlucHV0SWR4WyR7cn1dID0gMDtgKTtyZXR1cm5bYCR7bi5qb2luKFwiXFxuXCIpfVxcbnZhbHVlID0gX0EoaW5wdXRJZHgpO2AsXCJ2YWx1ZSA9IG1pbih2YWx1ZSwgX0EoaW5wdXRJZHgpKTtcIixcIlwiXX0pKSx0LnJlZHVjZVByb2Q9KGUsdCxuKT0+cyhlLHQsbixcIlJlZHVjZVByb2RcIiwoKCk9PltcInZhbHVlID0gMS4wO1wiLFwidmFsdWUgKj0gX0EoaW5wdXRJZHgpO1wiLFwiXCJdKSksdC5yZWR1Y2VMb2dTdW09KGUsdCxuKT0+cyhlLHQsbixcIlJlZHVjZUxvZ1N1bVwiLCgoKT0+W1widmFsdWUgPSAwLjA7XCIsXCJ2YWx1ZSArPSBfQShpbnB1dElkeCk7XCIsXCJ2YWx1ZSA9IGxvZyh2YWx1ZSk7XCJdKSksdC5yZWR1Y2VMb2dTdW1TcXVhcmU9KGUsdCxuKT0+cyhlLHQsbixcIlJlZHVjZUxvZ1N1bVNxdWFyZVwiLCgoKT0+W1wiZmxvYXQgdDsgdmFsdWUgPSAwLjA7XCIsXCJ0ID0gX0EoaW5wdXRJZHgpOyB2YWx1ZSArPSB0ICogdDtcIixcIlwiXSkpfSw3Mzc5OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmlzUmVzaGFwZUNoZWFwPXQucHJvY2Vzc0RpbXMzRD10LmNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNzI3Myksbz1uKDY3NTcpLGk9big1NjM5KSxhPW4oNTYxNCk7dC5jcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtSW5mb0xvYWRlcj0oZSx0LG4pPT57Y29uc3Qgcz0oZT0+KHtuYW1lOlwiUmVzaGFwZSAocGFja2VkKVwiLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUucGFja2VkXSxpbnB1dE5hbWVzOltcIkFcIl0sY2FjaGVIaW50OmAke2V9YH0pKShuKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtnZXQ6KCk9PigoZSx0LG4scyk9Pntjb25zdCB1PXQuZGltcyxsPXM7bGV0IGM9XCJcIjtmb3IobGV0IGU9MDtlPDQ7ZSsrKXtsZXQgdD1cIlwiO3N3aXRjaChlKXtjYXNlIDA6dD1cIm91dHB1dENvb3JkcyA9IHJjO1wiO2JyZWFrO2Nhc2UgMTp0PVwib3V0cHV0Q29vcmRzID0gaXZlYzMocmMueCwgcmMueSsxLCByYy56KTtcIjticmVhaztjYXNlIDI6dD1cIm91dHB1dENvb3JkcyA9IGl2ZWMzKHJjLngsIHJjLnksIHJjLnorMSk7XCI7YnJlYWs7Y2FzZSAzOnQ9XCJvdXRwdXRDb29yZHMgPSBpdmVjMyhyYy54LCByYy55KzEsIHJjLnorMSk7XCI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3J9Yys9YFxcbiAgICAgICAgJHt0fVxcbiAgICAgICAgJHtlPjA/XCJpZihvdXRwdXRDb29yZHMueSA8IHJvd3MgJiYgb3V0cHV0Q29vcmRzLnogPCBjb2xzKXtcIjpcIlwifVxcbiAgICAgICAgICBpbnQgZmxhdHRlbmVkSW5kZXggPSBnZXRGbGF0dGVuZWRJbmRleChvdXRwdXRDb29yZHMpO1xcblxcbiAgICAgICAgICBpdmVjMyBpbnB1dFJDID0gaW5wdXRDb29yZHNGcm9tUmVzaGFwZWRPdXRDb29yZHMoZmxhdHRlbmVkSW5kZXgpO1xcbiAgICAgICAgICB2ZWMyIGlubmVyRGltcyA9IHZlYzIoZmxvYXQoaW5wdXRSQy55KSxmbG9hdChpbnB1dFJDLnopKTtcXG5cXG4gICAgICAgICAgcmVzdWx0WyR7ZX1dID0gZ2V0Q2hhbm5lbChnZXRBKGlucHV0UkMueCwgaW5wdXRSQy55LCBpbnB1dFJDLnopLCBpbm5lckRpbXMpO1xcblxcbiAgICAgICAgJHtlPjA/XCJ9XCI6XCJcIn1cXG4gICAgICBgfWNvbnN0IHA9KDAsby5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksZD1gXFxuICAgICAgJHtmdW5jdGlvbihlKXtjb25zdCB0PXIuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGUpLG49W1wiYlwiLFwiclwiLFwiY1wiXSxvPVwiaW5kZXhcIjtyZXR1cm5gXFxuICAgIGl2ZWMzIGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGludCBpbmRleCkge1xcbiAgICAgICR7dC5tYXAoKChlLHIpPT5gaW50ICR7bltyXX0gPSAke299IC8gJHtlfTsgJHtyPT09dC5sZW5ndGgtMT9gaW50ICR7bltyKzFdfSA9ICR7b30gLSAke25bcl19ICogJHtlfWA6YGluZGV4IC09ICR7bltyXX0gKiAke2V9YH07YCkpLmpvaW4oXCJcIil9XFxuICAgICAgcmV0dXJuIGl2ZWMzKGIsIHIsIGMpO1xcbiAgICB9XFxuICBgfSh1KX1cXG4gICAgICAke2Z1bmN0aW9uKGUpe2NvbnN0IHQ9ci5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZSk7cmV0dXJuYFxcbiAgaW50IGdldEZsYXR0ZW5lZEluZGV4KGl2ZWMzIGNvb3Jkcykge1xcbiAgICAvLyByZXZlcnNlIHksIHogb3JkZXJcXG4gICAgcmV0dXJuIGNvb3Jkcy54ICogJHt0WzBdfSArIGNvb3Jkcy56ICogJHt0WzFdfSArIGNvb3Jkcy55O1xcbiAgfVxcbmB9KGwpfVxcbiAgICAgICR7KDAsYS51bnBhY2tGcm9tQ2hhbm5lbCkoKX1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuMCk7XFxuXFxuICAgICAgICBpdmVjMyBvdXRwdXRDb29yZHM7XFxuICAgICAgICBpbnQgcm93cyA9ICR7bFsyXX07XFxuICAgICAgICBpbnQgY29scyA9ICR7bFsxXX07XFxuXFxuICAgICAgICAke2N9XFxuICAgICAgICAke3Aub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7b3V0cHV0OntkaW1zOmwsdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS5wYWNrZWR9LHNoYWRlclNvdXJjZTpkLGhhc01haW46ITB9KX0pKGUsdCxzLG4pfSl9LHQucHJvY2Vzc0RpbXMzRD1mdW5jdGlvbihlKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuWzEsMSwxXTtsZXQgdD0xO2ZvcihsZXQgbj0wO248ZS5sZW5ndGgtMjsrK24pdCo9ZVtuXTtyZXR1cm5bdCxlLmxlbmd0aD4xP2VbZS5sZW5ndGgtMl06MSxlW2UubGVuZ3RoLTFdXX0sdC5pc1Jlc2hhcGVDaGVhcD1mdW5jdGlvbihlLHQpe2xldCBuPSExO3JldHVybiBuPTA9PT1lLmxlbmd0aHx8MD09PXQubGVuZ3RofHwoZS5sZW5ndGg8Mnx8dC5sZW5ndGg8Mj9lW2UubGVuZ3RoLTFdPT09dFt0Lmxlbmd0aC0xXTplW2UubGVuZ3RoLTFdPT09dFt0Lmxlbmd0aC0xXSYmZVtlLmxlbmd0aC0yXT09PXRbdC5sZW5ndGgtMl0pLG59fSw4MTI2OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnJlc2hhcGU9dm9pZCAwO2NvbnN0IHI9big3MjczKTt0LnJlc2hhcGU9KGUsdCk9Pntjb25zdCBuPXIuU2hhcGVVdGlsLmNhbGN1bGF0ZVJlc2hhcGVkRGltcyh0WzBdLmRpbXMsdFsxXS5pbnRlZ2VyRGF0YSk7cmV0dXJuIGUuc2Vzc2lvbi5wYWNrP1tlLnJlc2hhcGVQYWNrZWQodFswXSxuKV06W2UucmVzaGFwZVVucGFja2VkKHRbMF0sbildfX0sMjgwMTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTE9dC5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTA9dC5yZXNpemU9dm9pZCAwO2NvbnN0IHI9big2NzU3KSxvPW4oNTYzOSksaT1uKDQzMiksYT1uKDU2MTQpLHM9bigzOTgwKSx1PXtuYW1lOlwiUmVzaXplXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUucGFja2VkXX07dC5yZXNpemU9KGUsdCxuKT0+KCgwLHMudmFsaWRhdGVJbnB1dHMpKHQsbiksW2UucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT5sKGUsdCxuKX0pLHQpXSksdC5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTA9ZT0+KDAscy5wYXJzZVVwc2FtcGxlQXR0cmlidXRlcykoZSwxMCksdC5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTE9ZT0+KDAscy5wYXJzZVVwc2FtcGxlQXR0cmlidXRlcykoZSwxMSk7Y29uc3QgbD0oZSx0LG4pPT57Y29uc3Qgcz0oMCxyLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxbbCxwXT1jKHQsbik7aWYobC5ldmVyeSgoZT0+MT09PWUpKSYmXCJ0Zl9jcm9wX2FuZF9yZXNpemVcIiE9PW4uY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUpcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7b3V0cHV0OntkaW1zOnAsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS5wYWNrZWR9LGhhc01haW46ITAsc2hhZGVyU291cmNlOmB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IHYgPSAke3MudGV4dHVyZTJEfShYLCBUZXhDb29yZHMpO1xcbiAgICAgICAgICAgICAgICAgICAgJHtzLm91dHB1dH0gPSB2O1xcbiAgICAgICAgICAgICAgICB9YH0pO2NvbnN0IGQ9cC5sZW5ndGg7aWYoZDwyKXRocm93IG5ldyBFcnJvcihgb3V0cHV0IGRpbWVuc2lvbiBzaG91bGQgYmUgYXQgbGVhc3QgMiwgYnV0IGdvdCAke2R9YCk7Y29uc3QgZj1wW2QtMl0saD1wW2QtMV0sZz10WzBdLmRpbXM7aWYoZCE9PWcubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgb3V0cHV0IGRpbWVuc2lvbiBzaG91bGQgbWF0Y2ggaW5wdXQgJHtnLmxlbmd0aH0sIGJ1dCBnb3QgJHtkfWApO2NvbnN0IG09Z1tkLTJdLGI9Z1tkLTFdLHk9bFtkLTJdLHc9bFtkLTFdO2xldCBfPVwiXCI7aWYoXCJsaW5lYXJcIiE9PW4ubW9kZSl0aHJvdyBuZXcgRXJyb3IoYHJlc2l6ZSAocGFja2VkKSBkb2VzIG5vdCBzdXBwb3J0IG1vZGU6ICcke24ubW9kZX0nYCk7c3dpdGNoKG4uY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUpe2Nhc2VcImFzeW1tZXRyaWNcIjpfPVwiXFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpIC8gc2NhbGVXSFdIO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBcIjticmVhaztjYXNlXCJoYWxmX3BpeGVsXCI6Xz1cIlxcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2ZWM0KGNvb3JkcykgKyAwLjUpIC8gc2NhbGVXSFdIIC0gMC41O1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBcIjticmVhaztjYXNlXCJweXRvcmNoX2hhbGZfcGl4ZWxcIjpfPWBcXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgZ2V0U291cmNlRnJhY0luZGV4KGl2ZWM0IGNvb3Jkcykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgZmNvb3JkcyA9IHZlYzQoY29vcmRzKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtofS4wID4gMS4wID8gKGZjb29yZHMueCArIDAuNSkgLyBzY2FsZVdIV0gueCAtIDAuNSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtmfS4wID4gMS4wID8gKGZjb29yZHMueSArIDAuNSkgLyBzY2FsZVdIV0gueSAtIDAuNSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtofS4wID4gMS4wID8gKGZjb29yZHMueiArIDAuNSkgLyBzY2FsZVdIV0gueiAtIDAuNSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtmfS4wID4gMS4wID8gKGZjb29yZHMudyArIDAuNSkgLyBzY2FsZVdIV0gudyAtIDAuNSA6IDAuMFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgYDticmVhaztjYXNlXCJhbGlnbl9jb3JuZXJzXCI6Xz1gXFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHJlc2l6ZWQgPSB2ZWM0KCR7aH0uMCAtIDEuMCwgJHtmfS4wIC0gMS4wLCAke2h9LjAgLSAxLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7Zn0uMCAtIDEuMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBvcmlnaW5hbCA9IHZlYzQoJHtifS4wIC0gMS4wLCAke219LjAgLSAxLjAsICR7Yn0uMCAtIDEuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHttfS4wIC0gMS4wKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IG5ld19zY2FsZSA9IG9yaWdpbmFsIC8gcmVzaXplZDtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpICogbmV3X3NjYWxlO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBgO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGByZXNpemUgKHBhY2tlZCkgZG9lcyBub3Qgc3VwcG9ydCBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHtuLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlfSdgKX1jb25zdCB2PSgwLGkuZ2V0Q29vcmRzRGF0YVR5cGUpKGQpLHg9YFxcbiAgICAgICAgICAgIGNvbnN0IHZlYzIgaW5wdXRXSCA9IHZlYzIoJHttfS4wLCAke2J9LjApO1xcbiAgICAgICAgICAgIGNvbnN0IHZlYzQgc2NhbGVXSFdIID0gdmVjNChmbG9hdCgke3l9KSwgZmxvYXQoJHt3fSksIGZsb2F0KCR7eX0pLCBmbG9hdCgke3d9KSk7XFxuICAgICAgICAgICAgJHsoMCxhLnVucGFja0Zyb21DaGFubmVsKSgpfVxcbiAgICAgICAgICAgICR7X31cXG4gICAgICAgICAgICBmbG9hdCBnZXRBVmFsdWUoaW50IHgxMCwgaW50IHIsIGludCBjLCBpbnQgZCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRBKHgxMCwgciwgYywgZCksIHZlYzIoYywgZCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICAgICAgICR7dn0gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgICAgICAgICAgaW50IGJhdGNoID0gcmNbMF07XFxuICAgICAgICAgICAgICAgIGludCBkZXB0aCA9IHJjWzFdO1xcblxcbiAgICAgICAgICAgICAgICAvLyByZXRyaWV2ZSB0aGUgNCBjb29yZGluYXRlcyB0aGF0IGlzIHVzZWQgaW4gdGhlIDQgcGFja2VkIG91dHB1dCB2YWx1ZXMuXFxuICAgICAgICAgICAgICAgIGl2ZWM0IGNvb3JkcyA9IGl2ZWM0KHJjLnd6LCByYy53ICsgMSwgcmMueiArIDEpO1xcblxcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHNvdXJjZSBpbmRleCBpbiBmcmFjdGlvblxcbiAgICAgICAgICAgICAgICB2ZWM0IHNvdXJjZUZyYWMgPSBnZXRTb3VyY2VGcmFjSW5kZXgoY29vcmRzKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBsb3dlciBhbmQgdXBwZXIgYm91bmQgb2YgdGhlIDQgdmFsdWVzIHRoYXQgd2lsbCBiZSBwYWNrZWQgaW50byBvbmUgdGV4ZWwuXFxuICAgICAgICAgICAgICAgIGl2ZWM0IHgwMCA9IGl2ZWM0KG1heChzb3VyY2VGcmFjLnh5LCB2ZWMyKDAuMCkpLCBtaW4oaW5wdXRXSCAtIDEuMCwgY2VpbChzb3VyY2VGcmFjLnh5KSkpO1xcbiAgICAgICAgICAgICAgICBpdmVjNCB4MDEgPSBpdmVjNChtYXgoc291cmNlRnJhYy54dywgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy54dykpKTtcXG4gICAgICAgICAgICAgICAgaXZlYzQgeDEwID0gaXZlYzQobWF4KHNvdXJjZUZyYWMuenksIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMuenkpKSk7XFxuICAgICAgICAgICAgICAgIGl2ZWM0IHgxMSA9IGl2ZWM0KG1heChzb3VyY2VGcmFjLnp3LCB2ZWMyKDAuMCkpLCBtaW4oaW5wdXRXSCAtIDEuMCwgY2VpbChzb3VyY2VGcmFjLnp3KSkpO1xcblxcbiAgICAgICAgICAgICAgICBib29sIGhhc05leHRSb3cgPSByYy53IDwgJHtmLTF9O1xcbiAgICAgICAgICAgICAgICBib29sIGhhc05leHRDb2wgPSByYy56IDwgJHtoLTF9O1xcblxcbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIHRvcC1sZWZ0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxcbiAgICAgICAgICAgICAgICB2ZWM0IHRvcExlZnQgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLngsIHgwMC55KSxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueCwgeDAxLnkpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC54LCB4MTAueSkgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS54LCB4MTEueSkgOiAwLjApO1xcblxcbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIHRvcC1yaWdodCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcXG4gICAgICAgICAgICAgICAgdmVjNCB0b3BSaWdodCA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueCwgeDAwLncpLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS54LCB4MDEudykgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLngsIHgxMC53KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLngsIHgxMS53KSA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIHBhY2sgeDAwLCB4MDEsIHgxMCwgeDExJ3MgYm90dG9tLWxlZnQgY29ybmVyIGludG8gb25lIHZlYzQgc3RydWN0dXJlXFxuICAgICAgICAgICAgICAgIHZlYzQgYm90dG9tTGVmdCA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueiwgeDAwLnkpLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS56LCB4MDEueSkgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLnosIHgxMC55KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLnosIHgxMS55KSA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIHBhY2sgeDAwLCB4MDEsIHgxMCwgeDExJ3MgYm90dG9tLXJpZ2h0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbVJpZ2h0ID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgIGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMC56LCB4MDAudyksXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLnosIHgwMS53KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTAueiwgeDEwLncpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTEueiwgeDExLncpIDogMC4wKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBpbnRlcnBvbGF0aW9uIGZyYWN0aW9uIG9uIHUgYW5kIHYgZGlyZWN0aW9uXFxuICAgICAgICAgICAgICAgIHZlYzQgZnJhYyA9IHZlYzQoc291cmNlRnJhYykgLSBmbG9vcihzb3VyY2VGcmFjKTtcXG4gICAgICAgICAgICAgICAgdmVjNCBjbGFtcEZyYWMgPSBjbGFtcChmcmFjLCB2ZWM0KDAuMCksIHZlYzQoMS4wKSk7XFxuXFxuICAgICAgICAgICAgICAgIHZlYzQgdG9wID0gbWl4KHRvcExlZnQsIHRvcFJpZ2h0LCBjbGFtcEZyYWMueXd5dyk7XFxuICAgICAgICAgICAgICAgIHZlYzQgYm90dG9tID0gbWl4KGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCBjbGFtcEZyYWMueXd5dyk7XFxuICAgICAgICAgICAgICAgIHZlYzQgbmV3VmFsdWUgPSBtaXgodG9wLCBib3R0b20sIGNsYW1wRnJhYy54eHp6KTtcXG5cXG4gICAgICAgICAgICAgICAgJHtzLm91dHB1dH0gPSB2ZWM0KG5ld1ZhbHVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse291dHB1dDp7ZGltczpwLHR5cGU6dFswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUucGFja2VkfSxoYXNNYWluOiEwLHNoYWRlclNvdXJjZTp4fSl9LGM9KGUsdCk9Pntjb25zdCBuPWVbMF0uZGltcztsZXQgcixvPXQuc2NhbGVzO2lmKDA9PT1vLmxlbmd0aCl7Y29uc3QgaT1lW3Quc2NhbGVzSW5wdXRJZHhdO2lmKGkmJjAhPT1pLnNpemUpe2lmKGVbdC5zaXplc0lucHV0SWR4XSl0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBvZiBzY2FsZXMgb3Igc2l6ZXMgbXVzdCBiZSBwcm92aWRlZCBhcyBpbnB1dC5cIik7bz1wKGksdC5tb2RlLHQuaXNSZXNpemUpfWVsc2V7Y29uc3QgaT1lW3Quc2l6ZXNJbnB1dElkeF07aWYoIWl8fDA9PT1pLnNpemUpdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIHNjYWxlcyBvciBzaXplcyBNVVNUIGJlIHByb3ZpZGVkIGFzIGlucHV0LlwiKTtyPUFycmF5LmZyb20oaS5pbnRlZ2VyRGF0YSksbz1kKHIsbix0Lm1vZGUsdC5pc1Jlc2l6ZSl9fWVsc2UgaWYoZVt0LnNpemVzSW5wdXRJZHhdKXRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIG9mIHNjYWxlcyBvciBzaXplcyBtdXN0IGJlIHByb3ZpZGVkIGFzIGlucHV0LlwiKTtjb25zdCBpPXJ8fG4ubWFwKCgoZSx0KT0+TWF0aC5mbG9vcihlKm9bdF0pKSk7cmV0dXJuW28saV19LHA9KGUsdCxuKT0+e2NvbnN0IHI9QXJyYXkuZnJvbShlLmZsb2F0RGF0YSk7cmV0dXJuKDAscy5zY2FsZXNWYWxpZGF0aW9uKShyLHQsbikscn0sZD0oZSx0LG4scik9Pntjb25zdCBvPXQubGVuZ3RoLGk9bmV3IEFycmF5KG8pO2ZvcihsZXQgbj0wLHI9bztuPHI7bisrKWlmKDA9PT10W25dKXtpZigwIT09ZVtuXSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBkaW0gaXMgemVybyBidXQgcmVxdWlyZWQgb3V0cHV0IGRpbSBpcyBub24temVyby5cIik7aVtuXT0xfWVsc2UgaVtuXT1lW25dL3Rbbl07cmV0dXJuKDAscy5zY2FsZXNWYWxpZGF0aW9uKShpLG4sciksaX19LDU2NTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5zaGFwZT12b2lkIDA7Y29uc3Qgcj1uKDkyNDApO3Quc2hhcGU9KGUsdCk9PihvKHQpLFtuZXcgci5UZW5zb3IoW3RbMF0uZGltcy5sZW5ndGhdLFwiaW50MzJcIix2b2lkIDAsdm9pZCAwLG5ldyBJbnQzMkFycmF5KHRbMF0uZGltcykpXSk7Y29uc3Qgbz1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZSByZXF1aXJlcyAxIGlucHV0LlwiKX19LDI0NDQ6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuc2xpY2VWMTA9dC5wYXJzZVNsaWNlQXR0cmlidXRlcz10LnNsaWNlPXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDYxNDUpLGk9big3MjczKSxhPW4oNTYzOSkscz17bmFtZTpcIlNsaWNlXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2EuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTt0LnNsaWNlPShlLHQsbik9PihsKHQpLFtlLnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+dShlLHRbMF0sbil9KSx0KV0pLHQucGFyc2VTbGljZUF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5hdHRyaWJ1dGVzLmdldEludHMoXCJzdGFydHNcIiksbj1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcImVuZHNcIiksbz1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcImF4ZXNcIixbXSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtzdGFydHM6dCxlbmRzOm4sYXhlczpvfSl9O2NvbnN0IHU9KGUsdCxuKT0+e2NvbnN0IHI9MD09PW4uYXhlcy5sZW5ndGg/dC5kaW1zLnNsaWNlKDApLm1hcCgoKGUsdCk9PnQpKTpuLmF4ZXMsbz1pLlNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKHIsdC5kaW1zLmxlbmd0aCksdT1uLnN0YXJ0cy5tYXAoKChlLG4pPT5lPnQuZGltc1tvW25dXS0xP3QuZGltc1tvW25dXTppLlNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGUsdC5kaW1zW29bbl1dKSkpLGw9bi5lbmRzLm1hcCgoKGUsbik9PmU+dC5kaW1zW29bbl1dLTE/dC5kaW1zW29bbl1dOmkuU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoZSx0LmRpbXNbb1tuXV0pKSksYz10LmRpbXMuc2xpY2UoKSxwPVtdO2ZvcihsZXQgZT0wO2U8by5sZW5ndGg7ZSsrKWNbb1tlXV09bFtlXS11W2VdLHVbZV0+MCYmcC5wdXNoKGBvdXRwdXRJZHhbJHtvW2VdfV0gKz0gJHt1W2VdfTtgKTtjb25zdCBkPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHtjLmxlbmd0aH1dKSB7XFxuICAgICAgICAke3Auam9pbihcIlxcbiAgICAgIFwiKX1cXG4gICAgICAgIHJldHVybiBfQShvdXRwdXRJZHgpO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse291dHB1dDp7ZGltczpjLHR5cGU6dC50eXBlLHRleHR1cmVUeXBlOmEuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpkfSl9LGw9ZT0+e2lmKCFlfHwxIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiU2xpY2UgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoLTE9PT1vLk5VTUJFUl9UWVBFUy5pbmRleE9mKGVbMF0udHlwZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX07dC5zbGljZVYxMD0oZSx0KT0+e3AodCk7Y29uc3Qgbj1jKGUsdCk7cmV0dXJuW2UucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT51KGUsdFswXSxuKX0pLFt0WzBdXSldfTtjb25zdCBjPShlLHQpPT57aWYoIWUuc2Vzc2lvbi5pc0luaXRpYWxpemVyKHRbMV0uZGF0YUlkKXx8IWUuc2Vzc2lvbi5pc0luaXRpYWxpemVyKHRbMl0uZGF0YUlkKXx8dC5sZW5ndGg+PTQmJiFlLnNlc3Npb24uaXNJbml0aWFsaXplcih0WzNdLmRhdGFJZCl8fHQubGVuZ3RoPj01JiYhZS5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIodFs0XS5kYXRhSWQpKXRocm93IG5ldyBFcnJvcihcImR5bmFtaWMgc2xpY2UgYXR0cmlidXRlcyBhcmUgbm90IGFsbG93ZWRcIik7aWYodC5sZW5ndGg+PTUmJnRbNF0uaW50ZWdlckRhdGEuc29tZSgoZT0+MSE9PWUpKSl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgbm9uLTEgc3RlcHMgaXMgbm90IHN1cHBvcnRlZCBmb3IgU2xpY2VcIik7Y29uc3Qgbj1BcnJheS5mcm9tKHRbMV0uaW50ZWdlckRhdGEpLHI9QXJyYXkuZnJvbSh0WzJdLmludGVnZXJEYXRhKSxvPXQubGVuZ3RoPj00P0FycmF5LmZyb20odFszXS5pbnRlZ2VyRGF0YSk6W107cmV0dXJue3N0YXJ0czpuLGVuZHM6cixheGVzOm8sY2FjaGVLZXk6YCR7b307JHtufTske3J9YH19LHA9ZT0+e2lmKCFlfHxlLmxlbmd0aDwzfHxlLmxlbmd0aD41KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgbnVtYmVyLlwiKTtpZihcImludDMyXCIhPT1lWzFdLnR5cGV8fDEhPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoXCJpbnQzMlwiIT09ZVsyXS50eXBlfHwxIT09ZVsyXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKGUubGVuZ3RoPj00JiYoXCJpbnQzMlwiIT09ZVszXS50eXBlfHwxIT09ZVszXS5kaW1zLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZihlLmxlbmd0aD49NSYmKFwiaW50MzJcIiE9PWVbNF0udHlwZXx8MSE9PWVbNF0uZGltcy5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSw4MTU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuc29mdG1heFYxMz10LnBhcnNlU29mdG1heEF0dHJpYnV0ZXNWMTM9dC5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzPXQuc29mdG1heD12b2lkIDA7Y29uc3Qgcj1uKDQ5MTApLG89big3MjczKSxpPW4oNjc1NyksYT1uKDU2MzkpLHM9big1NzA3KSx1PXtuYW1lOlwiU29mdG1heENvbXB1dGVNYXhcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19LGw9e25hbWU6XCJTb2Z0bWF4Q29tcHV0ZVNjYWxlXCIsaW5wdXROYW1lczpbXCJBXCIsXCJNYXhcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZCxhLlRleHR1cmVUeXBlLnVucGFja2VkXX0sYz17bmFtZTpcIlNvZnRNYXhcIixpbnB1dE5hbWVzOltcIkFcIixcIk1heFwiLFwiTm9ybVwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkLGEuVGV4dHVyZVR5cGUudW5wYWNrZWQsYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O3Quc29mdG1heD0oZSx0LG4pPT57Zyh0KTtjb25zdCByPXRbMF0uZGltcy5zbGljZSgpLGk9by5TaGFwZVV0aWwubm9ybWFsaXplQXhpcyhuLmF4aXMsci5sZW5ndGgpLGE9by5TaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKHIsaSkscz1vLlNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihyLGkpO3JldHVybiBwKGUsdCxuLGEscyl9LHQucGFyc2VTb2Z0bWF4QXR0cmlidXRlcz1lPT4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F4aXM6ZS5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwxKX0pLHQucGFyc2VTb2Z0bWF4QXR0cmlidXRlc1YxMz1lPT4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F4aXM6ZS5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwtMSl9KSx0LnNvZnRtYXhWMTM9KGUsdCxuKT0+e2codCk7Y29uc3QgaT10WzBdLmRpbXMuc2xpY2UoKSxhPW8uU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMobi5heGlzLGkubGVuZ3RoKSx1PWkubGVuZ3RoLGw9YSE9PXUtMSxjPVtdO2xldCBkLGY9W10saD1bXTtsJiYoZj1BcnJheS5mcm9tKHtsZW5ndGg6dX0pLm1hcCgoKGUsdCk9PnQpKSxmW2FdPXUtMSxmW3UtMV09YSxmLm1hcCgoZT0+Yy5wdXNoKGlbZV0pKSksZD0oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe3Blcm06Zn0pLGg9KDAscy50cmFuc3Bvc2UpKGUsdCxkKSk7Y29uc3QgbT1sP28uU2hhcGVVdGlsLnNpemVUb0RpbWVuc2lvbihjLHUtMSk6by5TaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKGksdS0xKSxiPWw/by5TaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oYyx1LTEpOm8uU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKGksdS0xKSx5PXAoZSxsP2g6dCxuLG0sYik7cmV0dXJuIGw/KDAscy50cmFuc3Bvc2UpKGUseSxkKTp5fTtjb25zdCBwPShlLHQsbixyLG8pPT57Y29uc3QgaT1kKGUsdFswXSxyLG8sW3JdKSxhPWUucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT5pfSksdCkscz1mKGUsdFswXSxyLG8saS5vdXRwdXQuZGltcyxbcl0pLHA9ZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGwpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9PnN9KSxbdFswXSxhXSksZz1oKGUsdFswXSxyLG8saS5vdXRwdXQuZGltcyxzLm91dHB1dC5kaW1zKTtyZXR1cm5bZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGMpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9Pmd9KSxbdFswXSxhLHBdKV19LGQ9KGUsdCxuLHIsbyk9Pntjb25zdFtzLGxdPWUuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KHQuZGltcyxhLlRleHR1cmVUeXBlLnVucGFja2VkKSxjPW8ubGVuZ3RoO2lmKG48MXx8cjwxKXRocm93IG5ldyBFcnJvcihcIkxvZ2ljYWwgcm93IGNvdW50IE4gYW5kIGZlYXR1cmUgY291bnQgRCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpO2lmKDEhPT1vLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgb3V0cHV0IHNob3VsZCBiZSAxXCIpO2lmKG9bMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50XCIpO2NvbnN0IHA9KDAsaS5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksZD1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtjfV0gaW5kaWNlcykge1xcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke3J9O1xcblxcbiAgICAgICAgZmxvYXQgbWF4ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7cC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCwgJHtzfSxcXG4gICAgICAgICR7bH0gKSkpO1xcbiAgICAgICAgZm9yKGludCBpPTE7IGk8JHtyfTsgKytpKVxcbiAgICAgICAge1xcbiAgICAgICAgICBmbG9hdCBjdXJyZW50ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7cC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCArIGksXFxuICAgICAgICAgICAgJHtzfSwgJHtsfSkpKTtcXG4gICAgICAgICAgaWYoY3VycmVudCA+IG1heClcXG4gICAgICAgICAgbWF4ID0gY3VycmVudDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBtYXg7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7b3V0cHV0OntkaW1zOm8sdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmR9KX0sZj0oZSx0LG4scixvLHMpPT57Y29uc3RbdSxjXT1lLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh0LmRpbXMsYS5UZXh0dXJlVHlwZS51bnBhY2tlZCkscD1zLmxlbmd0aDtpZihuPDF8fHI8MSl0aHJvdyBuZXcgRXJyb3IoXCJMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKTtpZigxIT09cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uYWxpdHkgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgMVwiKTtpZihzWzBdIT09bil0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZSBvZiB0aGUgb3V0cHV0IHNob3VsZCBiZSBlcXVhbCB0byBsb2dpY2FsIHJvdyBjb3VudFwiKTtpZigxIT09by5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uYWxpdHkgb2YgdGhlIGludGVybWVkaWF0ZSByZXN1bHRzIHNob3VsZCBiZSAxXCIpO2lmKG9bMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnRcIik7Y29uc3QgZD1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtwfV0gaW5kaWNlcykge1xcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke3J9O1xcblxcbiAgICAgICAgZmxvYXQgbm9ybV9mYWN0b3IgPSAwLjA7XFxuICAgICAgICBmbG9hdCBtYXggPSBfTWF4KGluZGljZXMpO1xcbiAgICAgICAgZm9yKGludCBpPTA7IGk8JHtyfTsgKytpKVxcbiAgICAgICAge1xcbiAgICAgICAgICBub3JtX2ZhY3RvciArPSBleHAoZ2V0Q29sb3JBc0Zsb2F0KCR7KDAsaS5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfShBLCBvZmZzZXRUb0Nvb3Jkcyhsb2dpY2FsX3Jvd19zdGFydF9vZmZzZXQgKyBpLFxcbiAgICAgICAgICAgICR7dX0sICR7Y30pKSkgLSBtYXgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIG5vcm1fZmFjdG9yO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbCkse291dHB1dDp7ZGltczpzLHR5cGU6dC50eXBlLHRleHR1cmVUeXBlOmEuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpkfSl9LGg9KGUsdCxuLHIsbyxpKT0+e2NvbnN0W3MsdV09ZS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQodC5kaW1zLGEuVGV4dHVyZVR5cGUudW5wYWNrZWQpLGw9dC5kaW1zLmxlbmd0aDtpZihuPDF8fHI8MSl0aHJvdyBuZXcgRXJyb3IoXCJMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKTtpZigxIT09by5sZW5ndGh8fDEhPT1pLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDFcIik7aWYob1swXSE9PW58fGlbMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnRcIik7Y29uc3QgcD1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtsfV0gaW5kaWNlcykge1xcblxcbiAgICAgIC8vIGdldCBvZmZzZXQgb2YgY3VycmVudCBsb2dpY2FsIHRlbnNvciBpbmRleCBmcm9tIHRoZSAyLUQgdGV4dHVyZSBjb29yZGluYXRlcyAoVGV4Q29vcmRzKVxcbiAgICAgIGludCBvZmZzZXQgPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7c30sICR7dX0pO1xcblxcbiAgICAgIC8vZGV0ZXJtaW5lIHRoZSBsb2dpY2FsIHJvdyBmb3IgdGhpcyBpbmRleFxcbiAgICAgIGludCBsb2dpY2FsX3Jvd19pbmRleFsxXTtcXG4gICAgICBsb2dpY2FsX3Jvd19pbmRleFswXSA9IG9mZnNldCAvICR7cn07XFxuXFxuICAgICAgZmxvYXQgbm9ybV9mYWN0b3IgPSBfTm9ybShsb2dpY2FsX3Jvd19pbmRleCk7XFxuXFxuICAgICAgLy8gYXZvaWQgcG9zc2libGUgZGl2aXNpb24gYnkgMFxcbiAgICAgIC8vIGlmIG5vcm1fZmFjb3IgaXMgMCwgYWxsIGVsZW1lbnRzIGFyZSB6ZXJvXFxuICAgICAgLy8gaWYgc28sIHJldHVybiAwXFxuICAgICAgaWYobm9ybV9mYWN0b3IgPT0gMC4wKVxcbiAgICAgICAgcmV0dXJuIDAuMDtcXG5cXG4gICAgICByZXR1cm4gZXhwKF9BKGluZGljZXMpIC0gX01heChsb2dpY2FsX3Jvd19pbmRleCkpIC8gbm9ybV9mYWN0b3I7XFxuICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYykse291dHB1dDp7ZGltczp0LmRpbXMsdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnB9KX0sZz1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTb2Z0bWF4IHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwiZmxvYXQzMlwiIT09ZVswXS50eXBlJiZcImZsb2F0NjRcIiE9PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGVcIil9fSw1NjQ6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VTcGxpdEF0dHJpYnV0ZXM9dC5zcGxpdD12b2lkIDA7Y29uc3Qgcj1uKDQ5MTApLG89big3MjczKSxpPW4oNTYzOSksYT17bmFtZTpcIlNwbGl0XCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTt0LnNwbGl0PShlLHQsbik9PntsKHQpO2NvbnN0IHI9by5TaGFwZVV0aWwubm9ybWFsaXplQXhpcyhuLmF4aXMsdFswXS5kaW1zLmxlbmd0aCksaT1zKGUsdCxyLG4pLGM9W107Zm9yKGxldCBvPTA7bzxpOysrbyljLnB1c2goZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtjYWNoZUhpbnQ6YCR7bi5jYWNoZUtleX07JHtvfWAsZ2V0OigpPT51KGUsdFswXSxuLHIsbyl9KSx0KSk7cmV0dXJuIGN9LHQucGFyc2VTcGxpdEF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwwKSxuPWUuYXR0cmlidXRlcy5nZXRJbnRzKFwic3BsaXRcIixbXSksbz1lLm91dHB1dHMubGVuZ3RoO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXhpczp0LHNwbGl0Om4sbnVtT3V0cHV0czpvfSl9O2NvbnN0IHM9KGUsdCxuLHIpPT57Y29uc3RbLGldPW8uU3BsaXRVdGlsLnNwbGl0U2hhcGUodFswXS5kaW1zLG4sci5zcGxpdCxyLm51bU91dHB1dHMpO3JldHVybiBpLmxlbmd0aH0sdT0oZSx0LG4scixzKT0+e2NvbnN0W3UsbF09by5TcGxpdFV0aWwuc3BsaXRTaGFwZSh0LmRpbXMscixuLnNwbGl0LG4ubnVtT3V0cHV0cyksYz1sW3NdLHA9dVtzXSxkPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cC5sZW5ndGh9XSkge1xcbiAgICAgICAgaW5kaWNlc1ske3J9XSArPSAke2N9O1xcbiAgICAgICAgcmV0dXJuIF9BKGluZGljZXMpO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtjYWNoZUhpbnQ6YCR7bi5jYWNoZUtleX06JHtzfWAsb3V0cHV0OntkaW1zOnAsdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmR9KX0sbD1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTcGxpdCByZXF1aXJlcyBvbmUgaW5wdXQuXCIpO2lmKFwiaW50OFwiIT09ZVswXS50eXBlJiZcInVpbnQ4XCIhPT1lWzBdLnR5cGUmJlwiaW50MTZcIiE9PWVbMF0udHlwZSYmXCJ1aW50MTZcIiE9PWVbMF0udHlwZSYmXCJpbnQzMlwiIT09ZVswXS50eXBlJiZcInVpbnQzMlwiIT09ZVswXS50eXBlJiZcImZsb2F0MzJcIiE9PWVbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT1lWzBdLnR5cGUmJlwiYm9vbFwiIT09ZVswXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSw1NDE2OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlU3F1ZWV6ZUF0dHJpYnV0ZXM9dC5zcXVlZXplVjEzPXQuc3F1ZWV6ZT12b2lkIDA7Y29uc3Qgcj1uKDcyNzMpO3Quc3F1ZWV6ZT0oZSx0LG4pPT57byh0KTtjb25zdCBpPXIuU2hhcGVVdGlsLnNxdWVlemVTaGFwZSh0WzBdLmRpbXMsbik7cmV0dXJuW2UucmVzaGFwZVVucGFja2VkKHRbMF0saSldfSx0LnNxdWVlemVWMTM9KGUsbik9PihpKG4pLCgwLHQuc3F1ZWV6ZSkoZSxbblswXV0sQXJyYXkuZnJvbShuWzFdLmludGVnZXJEYXRhKSkpLHQucGFyc2VTcXVlZXplQXR0cmlidXRlcz1lPT5lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcImF4ZXNcIik7Y29uc3Qgbz1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTcXVlZXplIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwic3RyaW5nXCI9PT1lWzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSxpPWU9PntpZighZXx8MiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNxdWVlemUgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKFwiaW50MzJcIiE9PWVbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0sMTI0MDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5zdW09dm9pZCAwO2NvbnN0IHI9big2NzU3KSxvPW4oNTYzOSk7dC5zdW09KGUsdCk9PnthKHQpO2NvbnN0IG49e25hbWU6XCJTdW1cIixpbnB1dE5hbWVzOnQubWFwKCgoZSx0KT0+YFgke3R9YCkpLGlucHV0VHlwZXM6bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG8uVGV4dHVyZVR5cGUudW5wYWNrZWQpfTtyZXR1cm5bZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtnZXQ6KCk9PmkoZSx0LG4pfSksdCldfTtjb25zdCBpPShlLHQsbik9Pntjb25zdCBpPSgwLHIuZ2V0R2xzbCkoZS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLGE9dFswXS5kaW1zLnNsaWNlKCkscz1gXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke3QubWFwKCgoZSx0KT0+YCR7aS50ZXh0dXJlMkR9KFgke3R9LFRleENvb3JkcylgKSkuam9pbihcIiArIFwiKX07XFxuICAgICAgICAke2kub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7b3V0cHV0OntkaW1zOmEsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0saGFzTWFpbjohMCxzaGFkZXJTb3VyY2U6c30pfSxhPWU9PntpZighZXx8MD09PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlN1bSByZXF1aXJlcyBpbnB1dHMuXCIpO2NvbnN0IHQ9ZVswXS5kaW1zLmxlbmd0aDtmb3IobGV0IG49MTtuPGUubGVuZ3RoO24rKyl7aWYodCE9PWVbbl0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc2hhcGVzIGFyZSBtaXNtYXRjaGVkLlwiKTtmb3IobGV0IHI9MDtyPHQ7cisrKWlmKGVbMF0uZGltc1tyXSE9PWVbbl0uZGltc1tyXSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBzaGFwZXMgYXJlIG5vdCBtYXRjaGVkLlwiKX1pZihcImZsb2F0MzJcIiE9PWVbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT1lWzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtmb3IobGV0IHQ9MTt0PGUubGVuZ3RoO3QrKylpZihlWzBdLnR5cGUhPT1lW3RdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZXMgYXJlIG5vdCBtYXRjaGVkLlwiKX19LDU5NDQ6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQudGlsZT12b2lkIDA7Y29uc3Qgcj1uKDYxNDUpLG89big1NjM5KTt0LnRpbGU9KGUsdCk9PnthKHQpO2NvbnN0IG49e25hbWU6XCJUaWxlXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWRdfTtyZXR1cm5bZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtnZXQ6KCk9PmkoZSx0LG4pfSksdCldfTtjb25zdCBpPShlLHQsbik9Pntjb25zdCByPXRbMF0uZGltcy5zbGljZSgpLGk9bmV3IEFycmF5KHIubGVuZ3RoKSxhPVtdO2ZvcihsZXQgZT0wO2U8ci5sZW5ndGg7ZSsrKWlbZV09cltlXSp0WzFdLm51bWJlckRhdGFbZV0sYS5wdXNoKGBpbnB1dElkeFske2V9XSA9IGludChtb2QoZmxvYXQob3V0cHV0SWR4WyR7ZX1dKSwgJHtyW2VdfS4pKTtgKTtjb25zdCBzPWkubGVuZ3RoLHU9YFxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IG91dHB1dElkeFske3N9XSkge1xcbiAgICAgICAgaW50IGlucHV0SWR4WyR7c31dO1xcbiAgICAgICAgJHthLmpvaW4oXCJcXG5cIil9XFxuICAgICAgICByZXR1cm4gX0EoaW5wdXRJZHgpO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtvdXRwdXQ6e2RpbXM6aSx0eXBlOnRbMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6dX0pfSxhPWU9PntpZighZXx8MiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRpbGUgcmVxdWlyZXMgMiBpbnB1dC5cIik7aWYoMSE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNlY29uZCBpbnB1dCBzaGFwZSBtdXN0IDEgZGltZW5zaW9uLlwiKTtpZihlWzFdLmRpbXNbMF0hPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKC0xPT09ci5OVU1CRVJfVFlQRVMuaW5kZXhPZihlWzBdLnR5cGUpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoXCJpbnQzMlwiIT09ZVsxXS50eXBlJiZcImludDE2XCIhPT1lWzFdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXBlYXQgdHlwZS5cIil9fSw1NzA3OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlVHJhbnNwb3NlQXR0cmlidXRlcz10LnRyYW5zcG9zZT12b2lkIDA7Y29uc3Qgcj1uKDQ5MTApLG89big3MjczKSxpPW4oNTYzOSksYT17bmFtZTpcIlRyYW5zcG9zZVwiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkXX07dC50cmFuc3Bvc2U9KGUsdCxuKT0+KHAodCksW2UucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT5zKGUsdFswXSxuLnBlcm0pfSksdCldKSx0LnBhcnNlVHJhbnNwb3NlQXR0cmlidXRlcz1lPT4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe3Blcm06ZS5hdHRyaWJ1dGVzLmdldEludHMoXCJwZXJtXCIsW10pfSk7Y29uc3Qgcz0oZSx0LG4pPT57Y29uc3Qgcj10LmRpbXM7bj11KHIsbik7Y29uc3Qgbz1sKHIsbikscz1yLmxlbmd0aCxwPWBcXG4gICAgICAke2MoXCJwZXJtXCIsbixzKX1cXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7c31dKSB7XFxuICAgICAgICBpbnQgYVske3N9XTtcXG4gICAgICAgIHBlcm0oYSwgaW5kaWNlcyk7XFxuICAgICAgICByZXR1cm4gX0EoYSk7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx7b3V0cHV0OntkaW1zOm8sdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnB9KX0sdT0oZSx0KT0+KHQmJnQubGVuZ3RoIT09ZS5sZW5ndGgmJih0PVsuLi5lLmtleXMoKV0ucmV2ZXJzZSgpKSx0KSxsPShlLHQpPT4odD11KGUsdCksby5TaGFwZVV0aWwuc29ydEJhc2VkT25QZXJtKGUsdCkpLGM9KGUsdCxuKT0+e2NvbnN0IHI9W107ci5wdXNoKGB2b2lkICR7ZX0ob3V0IGludCBhWyR7bn1dLCBpbnQgc3JjWyR7bn1dKSB7YCk7Zm9yKGxldCBlPTA7ZTxuOysrZSlyLnB1c2goYFxcdGFbJHt0W2VdfV09c3JjWyR7ZX1dO2ApO3JldHVybiByLnB1c2goXCJcXHR9XCIpLHIuam9pbihcIlxcblwiKX0scD1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3Bvc2UgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoXCJmbG9hdDMyXCIhPT1lWzBdLnR5cGUmJlwiZmxvYXQ2NFwiIT09ZVswXS50eXBlKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNob3VsZCBiZSBmbG9hdCB0ZW5zb3JcIil9fSwyNDg4OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmVuY29kZUFzVWludDg9dm9pZCAwO2NvbnN0IHI9big2NzU3KSxvPW4oNTYzOSk7dC5lbmNvZGVBc1VpbnQ4PShlLHQpPT57Y29uc3Qgbj10LnNoYXBlLGk9KDAsci5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksYT1gXFxuICAgIGNvbnN0IGZsb2F0IEZMT0FUX01BWCA9IDEuNzAxNDExODRlMzg7XFxuICAgIGNvbnN0IGZsb2F0IEZMT0FUX01JTiA9IDEuMTc1NDk0MzVlLTM4O1xcblxcbiAgICBib29sIGlzTmFOKGZsb2F0IHZhbCkge1xcbiAgICAgIHJldHVybiAodmFsIDwgMS4wIHx8IDAuMCA8IHZhbCB8fCB2YWwgPT0gMC4wKSA/IGZhbHNlIDogdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBoaWdocCB2ZWM0IGVuY29kZUFzVWludDgoaGlnaHAgZmxvYXQgdikge1xcbiAgICAgIGlmIChpc05hTih2KSkge1xcbiAgICAgICAgcmV0dXJuIHZlYzQoMjU1LCAyNTUsIDI1NSwgMjU1KTtcXG4gICAgICB9XFxuXFxuICAgICAgaGlnaHAgZmxvYXQgYXYgPSBhYnModik7XFxuXFxuICAgICAgaWYoYXYgPCBGTE9BVF9NSU4pIHtcXG4gICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuICAgICAgfSBlbHNlIGlmKHYgPiBGTE9BVF9NQVgpIHtcXG4gICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAxMjguMCwgMTI3LjApIC8gMjU1LjA7XFxuICAgICAgfSBlbHNlIGlmKHYgPCAtRkxPQVRfTUFYKSB7XFxuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgIDEyOC4wLCAyNTUuMCkgLyAyNTUuMDtcXG4gICAgICB9XFxuXFxuICAgICAgaGlnaHAgdmVjNCBjID0gdmVjNCgwLDAsMCwwKTtcXG5cXG4gICAgICBoaWdocCBmbG9hdCBlID0gZmxvb3IobG9nMihhdikpO1xcbiAgICAgIGhpZ2hwIGZsb2F0IG0gPSBleHAyKGZyYWN0KGxvZzIoYXYpKSkgLSAxLjA7XFxuXFxuICAgICAgY1syXSA9IGZsb29yKDEyOC4wICogbSk7XFxuICAgICAgbSAtPSBjWzJdIC8gMTI4LjA7XFxuICAgICAgY1sxXSA9IGZsb29yKDMyNzY4LjAgKiBtKTtcXG4gICAgICBtIC09IGNbMV0gLyAzMjc2OC4wO1xcbiAgICAgIGNbMF0gPSBmbG9vcig4Mzg4NjA4LjAgKiBtKTtcXG5cXG4gICAgICBoaWdocCBmbG9hdCBlYmlhcyA9IGUgKyAxMjcuMDtcXG4gICAgICBjWzNdID0gZmxvb3IoZWJpYXMgLyAyLjApO1xcbiAgICAgIGViaWFzIC09IGNbM10gKiAyLjA7XFxuICAgICAgY1syXSArPSBmbG9vcihlYmlhcykgKiAxMjguMDtcXG5cXG4gICAgICBjWzNdICs9IDEyOC4wICogc3RlcCgwLjAsIC12KTtcXG5cXG4gICAgICByZXR1cm4gYyAvIDI1NS4wO1xcbiAgICB9XFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBmbG9hdCB2YWx1ZSA9ICR7aS50ZXh0dXJlMkR9KFgsVGV4Q29vcmRzKS5yO1xcbiAgICAgICR7aS5vdXRwdXR9ID0gZW5jb2RlQXNVaW50OCh2YWx1ZSk7XFxuICAgIH1gLHM9e25hbWU6XCJVaW50OEVuY29kZVwiLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWRdLGlucHV0TmFtZXM6W1wiWFwiXSxvdXRwdXQ6e2RpbXM6bix0eXBlOnQudGVuc29yLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS5kb3dubG9hZFVpbnQ4QXNGbG9hdH0sc2hhZGVyU291cmNlOmEsaGFzTWFpbjohMH07cmV0dXJuIGUuZXhlY3V0ZVByb2dyYW0ocyxbdC50ZW5zb3JdKX19LDkwODc6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQudGFuaD10LnRhbj10LnNxcnQ9dC5zaW49dC5zaWdtb2lkPXQucmVsdT10Lm5vdD10Lm5lZz10LmxvZz10LnBhcnNlTGVha3lSZWx1QXR0cmlidXRlcz10LmxlYWt5UmVsdT10LmlkZW50aXR5PXQuZmxvb3I9dC5leHA9dC5wYXJzZUVsdUF0dHJpYnV0ZXM9dC5lbHU9dC5jb3M9dC5jZWlsPXQuY2xpcFYxMT10LnBhcnNlQ2xpcEF0dHJpYnV0ZXM9dC5jbGlwPXQuYXRhbj10LmFzaW49dC5hY29zPXQuYWJzPXQuZ2xzbFRhbmg9dC5nbHNsVGFuPXQuZ2xzbFNxcnQ9dC5nbHNsU2lnbW9pZD10Lmdsc2xSZWx1PXQuZ2xzbFNpbj10Lmdsc2xOb3Q9dC5nbHNsTmVnPXQuZ2xzbExvZz10Lmdsc2xMZWFreVJlbHU9dC5nbHNsSWRlbnRpdHk9dC5nbHNsQ2xpcD10Lmdsc2xGbG9vcj10Lmdsc2xFeHA9dC5nbHNsRWx1PXQuZ2xzbENvcz10Lmdsc2xDZWlsPXQuZ2xzbEF0YW49dC5nbHNsQXNpbj10Lmdsc2xBY29zPXQuZ2xzbEFicz12b2lkIDA7Y29uc3Qgcj1uKDQ5MTApLG89big3MjczKSxpPW4oMTk5NyksYT1uKDY3NTcpLHM9big1NjM5KTtmdW5jdGlvbiB1KCl7cmV0dXJuICQoXCJhYnNcIil9ZnVuY3Rpb24gbCgpe3JldHVybiAkKFwiYWNvc1wiKX1mdW5jdGlvbiBjKCl7cmV0dXJuICQoXCJhc2luXCIpfWZ1bmN0aW9uIHAoKXtyZXR1cm4gJChcImF0YW5cIil9ZnVuY3Rpb24gZCgpe3JldHVybiAkKFwiY2VpbFwiKX1mdW5jdGlvbiBmKCl7cmV0dXJuICQoXCJjb3NcIil9ZnVuY3Rpb24gaChlKXtjb25zdCB0PVwiZWx1XCI7cmV0dXJue2JvZHk6YFxcbiAgY29uc3QgZmxvYXQgYWxwaGEgPSBmbG9hdCgke2V9KTtcXG5cXG4gIGZsb2F0ICR7dH1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIGEgPj0gMC4wID8gYTogKGV4cChhKSAtIDEuMCkgKiBhbHBoYTtcXG4gIH1cXG4gIHZlYzQgJHt0fV8odmVjNCB2KSB7XFxuICAgIHJldHVybiB2ZWM0KCR7dH1fKHYueCksICR7dH1fKHYueSksICR7dH1fKHYueiksICR7dH1fKHYudykpO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBnKCl7cmV0dXJuICQoXCJleHBcIil9ZnVuY3Rpb24gbSgpe3JldHVybiAkKFwiZmxvb3JcIil9ZnVuY3Rpb24gYihlLHQpe2NvbnN0IG49XCJjbGlwXCI7cmV0dXJue2JvZHk6YFxcbiAgY29uc3QgZmxvYXQgbWluID0gZmxvYXQoJHtlfSk7XFxuICBjb25zdCBmbG9hdCBtYXggPSBmbG9hdCgke3R9KTtcXG5cXG4gIGZsb2F0ICR7bn1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIGNsYW1wKGEsIG1pbiwgbWF4KTtcXG4gIH1cXG4gIHZlYzQgJHtufV8odmVjNCB2KSB7XFxuICAgIHJldHVybiBjbGFtcCh2LCBtaW4sIG1heCk7XFxuICB9XFxuICBgLG5hbWU6bix0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIHkoKXtjb25zdCBlPVwiaW5kZW50aXR5XCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gYTtcXG4gIH1cXG4gIHZlYzQgJHtlfV8odmVjNCB2KSB7XFxuICAgIHJldHVybiB2O1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiB3KGUpe2NvbnN0IHQ9XCJsZWFreVJlbHVcIjtyZXR1cm57Ym9keTpgXFxuICBjb25zdCBmbG9hdCBhbHBoYSA9IGZsb2F0KCR7ZX0pO1xcblxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gYSA8IDAuMCA/IGEgKiBhbHBoYSA6IGE7XFxuICB9XFxuICB2ZWM0ICR7dH1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gdmVjNCgke3R9Xyh2LngpLCAke3R9Xyh2LnkpLCAke3R9Xyh2LnopLCAke3R9Xyh2LncpKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gXygpe3JldHVybiAkKFwibG9nXCIpfWZ1bmN0aW9uIHYoKXtjb25zdCBlPVwibmVnXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gLWE7XFxuICB9XFxuICB2ZWM0ICR7ZX1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gLXY7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIHgoKXtjb25zdCBlPVwibm90XCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gZmxvYXQoICEgYm9vbChhKSApO1xcbiAgfVxcbiAgYm9vbCAke2V9Xyhib29sIGEpIHtcXG4gICAgcmV0dXJuICFhO1xcbiAgfVxcbiAgdmVjNCAke2V9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIHZlYzQoIWJvb2wodi54KSwgIWJvb2wodi55KSwgIWJvb2wodi56KSwgIWJvb2wodi53KSk7XFxuICB9XFxuICBidmVjNCAke2V9XyhidmVjNCB2KSB7XFxuICAgIHJldHVybiBidmVjNCghdi54LCAhdi55LCAhdi56LCAhdi53KTtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gVCgpe3JldHVybiAkKFwic2luXCIpfWZ1bmN0aW9uIFMoKXtjb25zdCBlPVwicmVsdVwiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIG1heCggYSwgMC4wICk7XFxuICB9XFxuICB2ZWM0ICR7ZX1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gbWF4KCB2LCAwLjAgKTtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gTygpe2NvbnN0IGU9XCJzaWdtb2lkXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtYSkpO1xcbiAgfVxcbiAgdmVjNCAke2V9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIDEuMCAvICgxLjAgKyBleHAoLXYpKTtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gQSgpe3JldHVybiAkKFwic3FydFwiKX1mdW5jdGlvbiBFKCl7cmV0dXJuICQoXCJ0YW5cIil9ZnVuY3Rpb24gSSgpe2NvbnN0IGU9XCJ0YW5oXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfV8oZmxvYXQgYSkge1xcbiAgICBhID0gY2xhbXAoYSwgLTEwLiwgMTAuKTtcXG4gICAgYSA9IGV4cCgyLiphKTtcXG4gICAgcmV0dXJuIChhIC0gMS4pIC8gKGEgKyAxLik7XFxuICB9XFxuICB2ZWM0ICR7ZX1fKHZlYzQgdikge1xcbiAgICB2ID0gY2xhbXAodiwgLTEwLiwgMTAuKTtcXG4gICAgdiA9IGV4cCgyLip2KTtcXG4gICAgcmV0dXJuICh2IC0gMS4pIC8gKHYgKyAxLik7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uICQoZSl7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gJHtlfShhKTtcXG4gIH1cXG4gIHZlYzQgJHtlfV8odmVjNCB2KSB7XFxuICAgIHJldHVybiAke2V9KHYpO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX10Lmdsc2xBYnM9dSx0Lmdsc2xBY29zPWwsdC5nbHNsQXNpbj1jLHQuZ2xzbEF0YW49cCx0Lmdsc2xDZWlsPWQsdC5nbHNsQ29zPWYsdC5nbHNsRWx1PWgsdC5nbHNsRXhwPWcsdC5nbHNsRmxvb3I9bSx0Lmdsc2xDbGlwPWIsdC5nbHNsSWRlbnRpdHk9eSx0Lmdsc2xMZWFreVJlbHU9dyx0Lmdsc2xMb2c9Xyx0Lmdsc2xOZWc9dix0Lmdsc2xOb3Q9eCx0Lmdsc2xTaW49VCx0Lmdsc2xSZWx1PVMsdC5nbHNsU2lnbW9pZD1PLHQuZ2xzbFNxcnQ9QSx0Lmdsc2xUYW49RSx0Lmdsc2xUYW5oPUk7Y29uc3QgUD0oZSx0LG4scik9Pntjb25zdCBvPWUuc2Vzc2lvbi5wYWNrP3MuVGV4dHVyZVR5cGUucGFja2VkOnMuVGV4dHVyZVR5cGUudW5wYWNrZWQsaT17bmFtZTpuLm5hbWUsaW5wdXRUeXBlczpbb10saW5wdXROYW1lczpbXCJBXCJdLGNhY2hlSGludDpyfTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGkpLHtnZXQ6KCk9PigoZSx0LG4scik9Pntjb25zdCBvPWUuc2Vzc2lvbi5wYWNrP3MuVGV4dHVyZVR5cGUucGFja2VkOnMuVGV4dHVyZVR5cGUudW5wYWNrZWQsaT0oMCxhLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXQ6e2RpbXM6bi5kaW1zLHR5cGU6bi50eXBlLHRleHR1cmVUeXBlOm99LHNoYWRlclNvdXJjZTpgXFxuICAgICAke3IuYm9keX1cXG4gICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgdmVjNCB2ID0gJHtpLnRleHR1cmUyRH0oQSwgVGV4Q29vcmRzKTtcXG4gICAgICAgdiA9ICR7ci5uYW1lfV8odik7XFxuICAgICAgICR7aS5vdXRwdXR9ID0gdjtcXG4gICAgIH1cXG4gICAgIGAsaGFzTWFpbjohMH0pfSkoZSxpLHQsbil9KX07dC5hYnM9KGUsdCk9PltlLnJ1bihQKGUsdFswXSx1KCkpLHQpXSx0LmFjb3M9KGUsdCk9PltlLnJ1bihQKGUsdFswXSxsKCkpLHQpXSx0LmFzaW49KGUsdCk9PltlLnJ1bihQKGUsdFswXSxjKCkpLHQpXSx0LmF0YW49KGUsdCk9PltlLnJ1bihQKGUsdFswXSxwKCkpLHQpXSx0LmNsaXA9KGUsdCxuKT0+W2UucnVuKFAoZSx0WzBdLGIobi5taW4sbi5tYXgpLG4uY2FjaGVLZXkpLHQpXSx0LnBhcnNlQ2xpcEF0dHJpYnV0ZXM9ZT0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHttaW46ZS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibWluXCIsby5NSU5fQ0xJUCksbWF4OmUuYXR0cmlidXRlcy5nZXRGbG9hdChcIm1heFwiLG8uTUFYX0NMSVApfSksdC5jbGlwVjExPShlLG4pPT57Y29uc3Qgcj1EKGUsbik7cmV0dXJuKDAsdC5jbGlwKShlLFtuWzBdXSxyKX07Y29uc3QgRD0oZSx0KT0+e2lmKHQubGVuZ3RoPj0zJiYoIWUuc2Vzc2lvbi5pc0luaXRpYWxpemVyKHRbMV0uZGF0YUlkKXx8IWUuc2Vzc2lvbi5pc0luaXRpYWxpemVyKHRbMl0uZGF0YUlkKSkpdGhyb3cgbmV3IEVycm9yKFwiZHluYW1pYyBjbGlwIGF0dHJpYnV0ZXMgYXJlIG5vdCBhbGxvd2VkXCIpO2NvbnN0IG49dC5sZW5ndGg+PTM/dFsxXS5udW1iZXJEYXRhWzBdOm8uTUlOX0NMSVAsaT10Lmxlbmd0aD49Mz90WzJdLm51bWJlckRhdGFbMF06by5NQVhfQ0xJUDtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe21pbjpuLG1heDppfSl9O3QuY2VpbD0oZSx0KT0+W2UucnVuKFAoZSx0WzBdLGQoKSksdCldLHQuY29zPShlLHQpPT5bZS5ydW4oUChlLHRbMF0sZigpKSx0KV0sdC5lbHU9KGUsdCxuKT0+W2UucnVuKFAoZSx0WzBdLGgobi5hbHBoYSksbi5jYWNoZUtleSksdCldLHQucGFyc2VFbHVBdHRyaWJ1dGVzPWU9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YWxwaGE6ZS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiYWxwaGFcIiwxKX0pLHQuZXhwPShlLHQpPT5bZS5ydW4oUChlLHRbMF0sZygpKSx0KV0sdC5mbG9vcj0oZSx0KT0+W2UucnVuKFAoZSx0WzBdLG0oKSksdCldLHQuaWRlbnRpdHk9KGUsdCk9PltlLnJ1bihQKGUsdFswXSx5KCkpLHQpXSx0LmxlYWt5UmVsdT0oZSx0LG4pPT5bZS5ydW4oUChlLHRbMF0sdyhuLmFscGhhKSxuLmNhY2hlS2V5KSx0KV0sdC5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXM9ZT0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHthbHBoYTplLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJhbHBoYVwiLC4wMSl9KSx0LmxvZz0oZSx0KT0+W2UucnVuKFAoZSx0WzBdLF8oKSksdCldLHQubmVnPShlLHQpPT5bZS5ydW4oUChlLHRbMF0sdigpKSx0KV0sdC5ub3Q9KGUsdCk9PltlLnJ1bihQKGUsdFswXSx4KCkpLHQpXSx0LnJlbHU9KGUsdCk9PltlLnJ1bihQKGUsdFswXSxTKCkpLHQpXSx0LnNpZ21vaWQ9KGUsdCk9PltlLnJ1bihQKGUsdFswXSxPKCkpLHQpXSx0LnNpbj0oZSx0KT0+W2UucnVuKFAoZSx0WzBdLFQoKSksdCldLHQuc3FydD0oZSx0KT0+W2UucnVuKFAoZSx0WzBdLEEoKSksdCldLHQudGFuPShlLHQpPT5bZS5ydW4oUChlLHRbMF0sRSgpKSx0KV0sdC50YW5oPShlLHQpPT5bZS5ydW4oUChlLHRbMF0sSSgpKSx0KV19LDU0MDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5jcmVhdGVVbnBhY2tQcm9ncmFtSW5mb0xvYWRlcj10LmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvPXZvaWQgMDtjb25zdCByPW4oNjc1Nyksbz1uKDU2MzkpLGk9big0MzIpLGE9big1NjE0KSxzPXtuYW1lOlwidW5wYWNrXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUucGFja2VkXX07dC5jcmVhdGVVbnBhY2tQcm9ncmFtSW5mbz0oZSx0KT0+e2NvbnN0IG49dC5kaW1zLmxlbmd0aCx1PSgwLGEuZ2V0Q2hhbm5lbHMpKFwicmNcIixuKSxsPXUuc2xpY2UoLTIpLGM9KDAsaS5nZXRDb29yZHNEYXRhVHlwZSkobikscD0oMCxhLnVucGFja0Zyb21DaGFubmVsKSgpLGQ9MD09PXQuZGltcy5sZW5ndGg/XCJcIjpmdW5jdGlvbihlLHQpe2lmKDE9PT1lKXJldHVyblwicmNcIjtsZXQgbj1cIlwiO2ZvcihsZXQgcj0wO3I8ZTtyKyspbis9dFtyXSxyPGUtMSYmKG4rPVwiLFwiKTtyZXR1cm4gbn0obix1KSxmPW48PTE/XCJyY1wiOmB2ZWMyKCR7bC5qb2luKFwiLFwiKX0pYCxoPWBcXG4gICAgJHtwfVxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgJHtjfSByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAvLyBTYW1wbGUgdGhlIHRleHR1cmUgd2l0aCB0aGUgY29vcmRzIHRvIGdldCB0aGUgcmdiYSBjaGFubmVsIHZhbHVlLlxcbiAgICAgICB2ZWM0IHBhY2tlZElucHV0ID0gZ2V0QSgke2R9KTtcXG5cXG4gICAgICAgJHsoMCxyLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKS5vdXRwdXR9ID0gdmVjNChnZXRDaGFubmVsKHBhY2tlZElucHV0LCAke2Z9KSwgMCwgMCwgMCk7XFxuICAgICB9XFxuICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtoYXNNYWluOiEwLG91dHB1dDp7ZGltczp0LmRpbXMsdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmh9KX0sdC5jcmVhdGVVbnBhY2tQcm9ncmFtSW5mb0xvYWRlcj0oZSxuKT0+T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtnZXQ6KCk9PigwLHQuY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm8pKGUsbil9KX0sNzg2MjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZVVuc3F1ZWV6ZUF0dHJpYnV0ZXM9dC51bnNxdWVlemVWMTM9dC51bnNxdWVlemU9dm9pZCAwO2NvbnN0IHI9big3MjczKTt0LnVuc3F1ZWV6ZT0oZSx0LG4pPT57byh0KTtjb25zdCBpPXIuU2hhcGVVdGlsLnVuc3F1ZWV6ZVNoYXBlKHRbMF0uZGltcyxuKTtyZXR1cm5bZS5yZXNoYXBlVW5wYWNrZWQodFswXSxpKV19LHQudW5zcXVlZXplVjEzPShlLG4pPT4oaShuKSwoMCx0LnVuc3F1ZWV6ZSkoZSxbblswXV0sQXJyYXkuZnJvbShuWzFdLmludGVnZXJEYXRhKSkpLHQucGFyc2VVbnNxdWVlemVBdHRyaWJ1dGVzPWU9PmUuYXR0cmlidXRlcy5nZXRJbnRzKFwiYXhlc1wiKTtjb25zdCBvPWU9PntpZighZXx8MSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlVuc3F1ZWV6ZSByZXF1aXJlcyAxIGlucHV0LlwiKTtpZihcInN0cmluZ1wiPT09ZVswXS50eXBlKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgdGVuc29yIHR5cGVzLlwiKX0saT1lPT57aWYoIWV8fDIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJVbnNxdWVlemUgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKFwiaW50MzJcIiE9PWVbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0sMzk4MDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5zY2FsZXNWYWxpZGF0aW9uPXQudmFsaWRhdGVJbnB1dHM9dC5wYXJzZVVwc2FtcGxlQXR0cmlidXRlcz10LnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzVjk9dC5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3PXQudXBzYW1wbGU9dm9pZCAwO2NvbnN0IHI9big0OTEwKSxvPW4oNjc1NyksaT1uKDU2MzkpLGE9e25hbWU6XCJVcHNhbXBsZVwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkXX07dC51cHNhbXBsZT0oZSxuLHIpPT4oKDAsdC52YWxpZGF0ZUlucHV0cykobixyKSxbZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtjYWNoZUhpbnQ6ci5jYWNoZUtleSxnZXQ6KCk9PnMoZSxuLHIpfSksbildKSx0LnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzVjc9ZT0+KDAsdC5wYXJzZVVwc2FtcGxlQXR0cmlidXRlcykoZSw3KSx0LnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzVjk9ZT0+KDAsdC5wYXJzZVVwc2FtcGxlQXR0cmlidXRlcykoZSw5KSx0LnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzPShlLG4pPT57Y29uc3Qgbz1uPj0xMCxpPWUuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJtb2RlXCIsXCJuZWFyZXN0XCIpO2lmKFwibmVhcmVzdFwiIT09aSYmXCJsaW5lYXJcIiE9PWkmJihuPDExfHxcImN1YmljXCIhPT1pKSl0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBtb2RlOiAke2l9YCk7bGV0IGE9W107bjw5JiYoYT1lLmF0dHJpYnV0ZXMuZ2V0RmxvYXRzKFwic2NhbGVzXCIpLCgwLHQuc2NhbGVzVmFsaWRhdGlvbikoYSxpLG8pKTtjb25zdCBzPWUuYXR0cmlidXRlcy5nZXRGbG9hdChcImV4dHJhcG9sYXRpb25fdmFsdWVcIiwwKSx1PW4+MTA/ZS5hdHRyaWJ1dGVzLmdldFN0cmluZyhcImNvb3JkaW5hdGVfdHJhbnNmb3JtYXRpb25fbW9kZVwiLFwiaGFsZl9waXhlbFwiKTpcImFzeW1tZXRyaWNcIjtpZigtMT09PVtcImFzeW1tZXRyaWNcIixcInB5dG9yY2hfaGFsZl9waXhlbFwiLFwidGZfaGFsZl9waXhlbF9mb3Jfbm5cIixcImFsaWduX2Nvcm5lcnNcIixcInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiLFwiaGFsZl9waXhlbFwiXS5pbmRleE9mKHUpKXRocm93IG5ldyBFcnJvcihgY29vcmRpbmF0ZV90cmFuc2Zvcm1fbW9kZSAnJHt1fScgaXMgbm90IHN1cHBvcnRlZGApO2NvbnN0IGw9XCJ0Zl9jcm9wX2FuZF9yZXNpemVcIj09PXUsYz1sLHA9XCJuZWFyZXN0XCI9PT1pJiZuPj0xMT9lLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwibmVhcmVzdF9tb2RlXCIsXCJyb3VuZF9wcmVmZXJfZmxvb3JcIik6XCJcIjtpZigtMT09PVtcInJvdW5kX3ByZWZlcl9mbG9vclwiLFwicm91bmRfcHJlZmVyX2NlaWxcIixcImZsb29yXCIsXCJjZWlsXCIsXCJcIl0uaW5kZXhPZihwKSl0aHJvdyBuZXcgRXJyb3IoYG5lYXJlc3RfbW9kZSAnJHtwfScgaXMgbm90IHN1cHBvcnRlZGApO2NvbnN0IGQ9ZS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiY3ViaWNfY29lZmZfYVwiLC0uNzUpLGY9MCE9PWUuYXR0cmlidXRlcy5nZXRJbnQoXCJleGNsdWRlX291dHNpZGVcIiwwKTtpZihmJiZcImN1YmljXCIhPT1pKXRocm93IG5ldyBFcnJvcihcImV4Y2x1ZGVfb3V0c2lkZSBjYW4gYmUgc2V0IHRvIDEgb25seSB3aGVuIG1vZGUgaXMgQ1VCSUMuXCIpO2NvbnN0IGg9bjwxMXx8XCJuZWFyZXN0XCI9PT1pJiZcImFzeW1tZXRyaWNcIj09PXUmJlwiZmxvb3JcIj09PXA7bGV0IGc9MCxtPTAsYj0wO3JldHVybiBuPjEwP2UuaW5wdXRzLmxlbmd0aD4yPyhnPTEsbT0yLGI9Myk6KG09MSxiPTIpOjk9PT1uJiYobT0xKSwoMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe29wc2V0Om4saXNSZXNpemU6byxtb2RlOmksc2NhbGVzOmEsZXh0cmFwb2xhdGlvblZhbHVlOnMsY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6dSx1c2VFeHRyYXBvbGF0aW9uOmMsbmVlZFJvaUlucHV0OmwsbmVhcmVzdE1vZGU6cCxjdWJpY0NvZWZmaWNpZW50QTpkLGV4Y2x1ZGVPdXRzaWRlOmYsdXNlTmVhcmVzdDJ4T3B0aW1pemF0aW9uOmgscm9pSW5wdXRJZHg6ZyxzY2FsZXNJbnB1dElkeDptLHNpemVzSW5wdXRJZHg6Yn0pfTtjb25zdCBzPShlLHQsbik9Pntjb25zdCByPSgwLG8uZ2V0R2xzbCkoZS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLFtzLHVdPWUuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KHRbMF0uZGltcyxpLlRleHR1cmVUeXBlLnVucGFja2VkKSxsPXRbMF0uZGltcy5tYXAoKChlLHQpPT5NYXRoLmZsb29yKGUqbi5zY2FsZXNbdF0pKSksW2MscF09ZS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQobCxpLlRleHR1cmVUeXBlLnVucGFja2VkKSxkPWwubGVuZ3RoLGY9bmV3IEFycmF5KGQpLGg9bmV3IEFycmF5KGQpO2xldCBnPWBcXG4gICAgICBpbnQgb3V0cHV0X3BpdGNoZXNbJHtkfV07XFxuICAgICAgaW50IGlucHV0X3BpdGNoZXNbJHtkfV07XFxuICAgICAgYDtmb3IobGV0IGU9ZC0xO2U+PTA7ZS0tKWZbZV09ZT09PWQtMT8xOmZbZSsxXSpsW2UrMV0saFtlXT1lPT09ZC0xPzE6aFtlKzFdKnRbMF0uZGltc1tlKzFdLGcrPWBcXG4gICAgICAgIG91dHB1dF9waXRjaGVzWyR7ZX1dID0gJHtmW2VdfTtcXG4gICAgICAgIGlucHV0X3BpdGNoZXNbJHtlfV0gPSAke2hbZV19O1xcbiAgICAgICAgYDtjb25zdCBtPWBcXG4gICAgICBmbG9hdCBnZXRJbnB1dEZsb2F0KGludCBpbmRleCkge1xcbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhpbmRleCwgJHtzfSwgJHt1fSk7XFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke3IudGV4dHVyZTJEfShYLCBjb29yZHMpKTtcXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9XFxuICAgICAgYCxiPVwibmVhcmVzdFwiPT09bi5tb2RlP2BcXG4gICAgJHttfVxcbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7ZH1dKSB7XFxuICAgICAgaW50IGlucHV0X2luZGV4ID0gMDtcXG4gICAgICBpbnQgb3V0cHV0X2luZGV4ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke2N9LCAke3B9KTtcXG5cXG4gICAgICAke2d9XFxuXFxuICAgICAgaW50IGQsIG07XFxuICAgICAgZm9yIChpbnQgZGltID0gMDsgZGltIDwgJHtkfTsgKytkaW0pIHtcXG4gICAgICAgIGQgPSBvdXRwdXRfaW5kZXggLyBvdXRwdXRfcGl0Y2hlc1tkaW1dO1xcbiAgICAgICAgbSA9IG91dHB1dF9pbmRleCAtIGQgKiBvdXRwdXRfcGl0Y2hlc1tkaW1dO1xcbiAgICAgICAgb3V0cHV0X2luZGV4ID0gbTtcXG5cXG4gICAgICAgIGlmIChzY2FsZXNbZGltXSAhPSAxICYmIGQgPiAwKSB7XFxuICAgICAgICAgIGludCBkMiA9IGQgLyBzY2FsZXNbZGltXTtcXG4gICAgICAgICAgbSA9IGQgLSBkMiAqIHNjYWxlc1tkaW1dO1xcbiAgICAgICAgICBkID0gZDI7XFxuICAgICAgICB9XFxuICAgICAgICBpbnB1dF9pbmRleCArPSBpbnB1dF9waXRjaGVzW2RpbV0gKiBkO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XFxuICAgIH1gOjQ9PT1kP2BcXG4gICAgJHttfVxcbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWzRdKSB7XFxuICAgICAgaW50IGlucHV0X2luZGV4ID0gMDtcXG4gICAgICBpbnQgb3V0cHV0X2luZGV4ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke2N9LCAke3B9KTtcXG5cXG4gICAgICAke2d9XFxuXFxuICAgICAgaW50IG07XFxuICAgICAgaW50IGluZGV4X29mX2RpbTAsIGluZGV4X29mX2RpbTEsIGluZGV4X29mX2RpbTIsIGluZGV4X29mX2RpbTM7XFxuICAgICAgaW5kZXhfb2ZfZGltMCA9IG91dHB1dF9pbmRleCAvIG91dHB1dF9waXRjaGVzWzBdO1xcbiAgICAgIG0gPSBvdXRwdXRfaW5kZXggLSBpbmRleF9vZl9kaW0wICogb3V0cHV0X3BpdGNoZXNbMF07XFxuICAgICAgaW5kZXhfb2ZfZGltMSA9IG0gLyBvdXRwdXRfcGl0Y2hlc1sxXTtcXG4gICAgICBtID0gbSAtIGluZGV4X29mX2RpbTEgKiBvdXRwdXRfcGl0Y2hlc1sxXTtcXG4gICAgICBpbmRleF9vZl9kaW0yID0gbSAvIG91dHB1dF9waXRjaGVzWzJdO1xcbiAgICAgIG0gPSBtIC0gaW5kZXhfb2ZfZGltMiAqIG91dHB1dF9waXRjaGVzWzJdO1xcbiAgICAgIGluZGV4X29mX2RpbTMgPSBtO1xcblxcbiAgICAgIGludCBpbmRleF9vZl9pbnB1dF9kaW0yLCBpbmRleF9vZl9pbnB1dF9kaW0zLCB4X29mZnNldCwgeV9vZmZzZXQ7XFxuICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMiA9IGluZGV4X29mX2RpbTIgLyBzY2FsZXNbMl07XFxuICAgICAgeV9vZmZzZXQgPSBpbmRleF9vZl9kaW0yIC0gaW5kZXhfb2ZfaW5wdXRfZGltMiAqIHNjYWxlc1syXTtcXG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0zID0gaW5kZXhfb2ZfZGltMyAvIHNjYWxlc1szXTtcXG4gICAgICB4X29mZnNldCA9IGluZGV4X29mX2RpbTMgLSBpbmRleF9vZl9pbnB1dF9kaW0zICogc2NhbGVzWzNdO1xcblxcbiAgICAgIGlucHV0X2luZGV4ID0gaW5kZXhfb2ZfZGltMCAqIGlucHV0X3BpdGNoZXNbMF0gK1xcbiAgICAgICAgICAgIGluZGV4X29mX2RpbTEgKiBpbnB1dF9waXRjaGVzWzFdICtcXG4gICAgICAgICAgICBpbmRleF9vZl9pbnB1dF9kaW0yICogaW5wdXRfcGl0Y2hlc1syXSArXFxuICAgICAgICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMztcXG5cXG4gICAgICBmbG9hdCB4MDAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4KTtcXG4gICAgICBmbG9hdCB4MTAsIHgwMSwgeDExO1xcblxcbiAgICAgIGJvb2wgZW5kX29mX2RpbTIgPSBmYWxzZTtcXG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMiA9PSAoJHt0WzBdLmRpbXNbMl19IC0gMSkpIHtcXG4gICAgICAgIC8vIEl0J3MgdGhlIGVuZCBpbiBkaW1lbnNpb24gMlxcbiAgICAgICAgeDAxID0geDAwO1xcbiAgICAgICAgZW5kX29mX2RpbTIgPSB0cnVlO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB4MDEgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgaW5wdXRfcGl0Y2hlc1syXSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpbmRleF9vZl9pbnB1dF9kaW0zID09IChpbnB1dF9waXRjaGVzWzJdIC0gMSkpIHtcXG4gICAgICAgIC8vIEl0J3MgdGhlIGVuZCBpbiBkaW1lbnNpb24gM1xcbiAgICAgICAgeDEwID0geDAwO1xcbiAgICAgICAgeDExID0geDAxO1xcbiAgICAgIH1cXG4gICAgICBlbHNlIHtcXG4gICAgICAgIHgxMCA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyAxKTtcXG4gICAgICAgIHgxMSA9IGVuZF9vZl9kaW0yID8geDEwIDogZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMl0gKyAxKTtcXG4gICAgICB9XFxuXFxuICAgICAgZmxvYXQgeTAgPSB4MDAgKyBmbG9hdCh5X29mZnNldCkgKiAoeDAxIC0geDAwKSAvIGZsb2F0KHNjYWxlc1syXSk7XFxuICAgICAgZmxvYXQgeTEgPSB4MTAgKyBmbG9hdCh5X29mZnNldCkgKiAoeDExIC0geDEwKSAvIGZsb2F0KHNjYWxlc1syXSk7XFxuICAgICAgcmV0dXJuIHkwICsgZmxvYXQoeF9vZmZzZXQpICogKHkxIC0geTApIC8gZmxvYXQoc2NhbGVzWzNdKTtcXG4gICAgfWA6YFxcbiAgICAke219XFxuICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbMl0pIHtcXG4gICAgICBpbnQgaW5wdXRfaW5kZXggPSAwO1xcbiAgICAgIGludCBvdXRwdXRfaW5kZXggPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7Y30sICR7cH0pO1xcblxcbiAgICAgICR7Z31cXG5cXG4gICAgICBpbnQgbTtcXG4gICAgICBpbnQgaW5kZXhfb2ZfZGltMCwgaW5kZXhfb2ZfZGltMTtcXG4gICAgICBpbmRleF9vZl9kaW0wID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbMF07XFxuICAgICAgbSA9IG91dHB1dF9pbmRleCAtIGluZGV4X29mX2RpbTAgKiBvdXRwdXRfcGl0Y2hlc1swXTtcXG4gICAgICBpbmRleF9vZl9kaW0xID0gbTtcXG5cXG4gICAgICBpbnQgaW5kZXhfb2ZfaW5wdXRfZGltMCwgaW5kZXhfb2ZfaW5wdXRfZGltMSwgeF9vZmZzZXQsIHlfb2Zmc2V0O1xcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTAgPSBpbmRleF9vZl9kaW0wIC8gc2NhbGVzWzBdO1xcbiAgICAgIHlfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMCAtIGluZGV4X29mX2lucHV0X2RpbTAgKiBzY2FsZXNbMF07XFxuICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMSA9IGluZGV4X29mX2RpbTEgLyBzY2FsZXNbMV07XFxuICAgICAgeF9vZmZzZXQgPSBpbmRleF9vZl9kaW0xIC0gaW5kZXhfb2ZfaW5wdXRfZGltMSAqIHNjYWxlc1sxXTtcXG5cXG4gICAgICBpbnB1dF9pbmRleCA9IGluZGV4X29mX2lucHV0X2RpbTAgKiBpbnB1dF9waXRjaGVzWzBdICsgaW5kZXhfb2ZfaW5wdXRfZGltMTtcXG5cXG4gICAgICBmbG9hdCB4MDAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4KTtcXG4gICAgICBmbG9hdCB4MTAsIHgwMSwgeDExO1xcblxcbiAgICAgIGJvb2wgZW5kX29mX2RpbTAgPSBmYWxzZTtcXG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMCA9PSAoJHt0WzBdLmRpbXNbMF19IC0gMSkpIHtcXG4gICAgICAgIC8vIEl0J3MgdGhlIGVuZCBpbiBkaW1lbnNpb24gMFxcbiAgICAgICAgeDAxID0geDAwO1xcbiAgICAgICAgZW5kX29mX2RpbTAgPSB0cnVlO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB4MDEgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgaW5wdXRfcGl0Y2hlc1swXSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpbmRleF9vZl9pbnB1dF9kaW0xID09IChpbnB1dF9waXRjaGVzWzBdIC0gMSkpIHtcXG4gICAgICAgIC8vIEl0J3MgdGhlIGVuZCBpbiBkaW1lbnNpb24gMVxcbiAgICAgICAgeDEwID0geDAwO1xcbiAgICAgICAgeDExID0geDAxO1xcbiAgICAgIH1cXG4gICAgICBlbHNlIHtcXG4gICAgICAgIHgxMCA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyAxKTtcXG4gICAgICAgIHgxMSA9IGVuZF9vZl9kaW0wID8geDEwIDogZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMF0gKyAxKTtcXG4gICAgICB9XFxuXFxuICAgICAgZmxvYXQgeTAgPSB4MDAgKyBmbG9hdCh5X29mZnNldCkgKiAoeDAxIC0geDAwKSAvIGZsb2F0KHNjYWxlc1swXSk7XFxuICAgICAgZmxvYXQgeTEgPSB4MTAgKyBmbG9hdCh5X29mZnNldCkgKiAoeDExIC0geDEwKSAvIGZsb2F0KHNjYWxlc1swXSk7XFxuICAgICAgcmV0dXJuIHkwICsgZmxvYXQoeF9vZmZzZXQpICogKHkxIC0geTApIC8gZmxvYXQoc2NhbGVzWzFdKTtcXG4gICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx7b3V0cHV0OntkaW1zOmwsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmIsdmFyaWFibGVzOlt7bmFtZTpcInNjYWxlc1wiLHR5cGU6XCJpbnRcIixhcnJheUxlbmd0aDpuLnNjYWxlcy5sZW5ndGgsZGF0YTpuLnNjYWxlcy5tYXAoKGU9Pk1hdGguY2VpbChlKSkpfV19KX07dC52YWxpZGF0ZUlucHV0cz0oZSx0KT0+e2lmKCFlfHx0Lm9wc2V0PDkmJjEhPT1lLmxlbmd0aHx8dC5vcHNldD49OSYmdC5vcHNldDwxMSYmMiE9PWUubGVuZ3RofHx0Lm9wc2V0Pj0xMSYmZS5sZW5ndGg8Mil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0cy5cIik7aWYodC5zY2FsZXMubGVuZ3RoPjAmJmVbMF0uZGltcy5sZW5ndGghPT10LnNjYWxlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYoXCJzdHJpbmdcIj09PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHRlbnNvciB0eXBlcy5cIil9LHQuc2NhbGVzVmFsaWRhdGlvbj0oZSx0LG4pPT57aWYobil7Zm9yKGNvbnN0IHQgb2YgZSlpZih0PD0wKXRocm93IG5ldyBFcnJvcihcIlNjYWxlIHZhbHVlIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gMC5cIil9ZWxzZSBmb3IoY29uc3QgdCBvZiBlKWlmKHQ8MSl0aHJvdyBuZXcgRXJyb3IoXCJTY2FsZSB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEuXCIpO2lmKCEoXCJsaW5lYXJcIiE9PXQmJlwiY3ViaWNcIiE9PXR8fDI9PT1lLmxlbmd0aHx8ND09PWUubGVuZ3RoJiYxPT09ZVswXSYmMT09PWVbMV0pKXRocm93IG5ldyBFcnJvcihgJ0xpbmVhcicgbW9kZSBhbmQgJ0N1YmljJyBtb2RlIG9ubHkgc3VwcG9ydCAyLUQgaW5wdXRzICgnQmlsaW5lYXInLCAnQmljdWJpYycpICAgICAgICAgb3IgNC1EIGlucHV0cyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIG91dGVybW9zdCAyIHNjYWxlIHZhbHVlcyBiZWluZyAxICAgICAgICAgaW4gdGhlICR7bj9cIlJlc2l6ZVwiOlwiVXBzYW1wbGVcIn0gb3BlYXJ0b3IuYCl9fSwyNzU3OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlByb2dyYW1NYW5hZ2VyPXZvaWQgMDtjb25zdCByPW4oODQ1Myksbz1uKDEzMTUpLGk9big4ODk3KSxhPW4oNjc1Nyk7dC5Qcm9ncmFtTWFuYWdlcj1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbil7dGhpcy5wcm9maWxlcj1lLHRoaXMuZ2xDb250ZXh0PXQsdGhpcy50ZXh0dXJlTGF5b3V0U3RyYXRlZ3k9bix0aGlzLnJlcG89bmV3IE1hcCx0aGlzLmF0dHJpYnV0ZXNCb3VuZD0hMX1nZXRBcnRpZmFjdChlKXtyZXR1cm4gdGhpcy5yZXBvLmdldChlKX1zZXRBcnRpZmFjdChlLHQpe3RoaXMucmVwby5zZXQoZSx0KX1ydW4oZSx0LG4pe3ZhciByO3RoaXMucHJvZmlsZXIuZXZlbnQoXCJvcFwiLGBQcm9ncmFtTWFuYWdlci5ydW4gJHtudWxsIT09KHI9ZS5wcm9ncmFtSW5mby5uYW1lKSYmdm9pZCAwIT09cj9yOlwidW5rbm93biBrZXJuZWxcIn1gLCgoKT0+e3ZhciByO2NvbnN0IGk9dGhpcy5nbENvbnRleHQuZ2wsYT1lLnByb2dyYW07aS51c2VQcm9ncmFtKGEpO3RyeXt0aGlzLmJpbmRPdXRwdXQobiksdGhpcy5hdHRyaWJ1dGVzQm91bmR8fHRoaXMuYmluZEF0dHJpYnV0ZXMoZS5hdHRyaWJMb2NhdGlvbnMpLHRoaXMuYmluZFVuaWZvcm1zKGUudW5pZm9ybUxvY2F0aW9ucyxudWxsIT09KHI9ZS5wcm9ncmFtSW5mby52YXJpYWJsZXMpJiZ2b2lkIDAhPT1yP3I6W10sdCl9Y2F0Y2godCl7dGhyb3cgby5Mb2dnZXIuZXJyb3IoXCJQcm9ncmFtTWFuYWdlclwiLGUucHJvZ3JhbUluZm8uc2hhZGVyU291cmNlKSx0fXRoaXMucHJvZmlsZXIuZXZlbnQoXCJiYWNrZW5kXCIsXCJHbENvbnRleHQuZHJhdygpXCIsKCgpPT57dGhpcy5nbENvbnRleHQuZHJhdygpfSkpfSksdGhpcy5nbENvbnRleHQpfWRpc3Bvc2UoKXt0aGlzLnZlcnRleFNoYWRlciYmdGhpcy5nbENvbnRleHQuZGVsZXRlU2hhZGVyKHRoaXMudmVydGV4U2hhZGVyKSx0aGlzLnJlcG8uZm9yRWFjaCgoZT0+dGhpcy5nbENvbnRleHQuZGVsZXRlUHJvZ3JhbShlLnByb2dyYW0pKSl9YnVpbGQoZSx0LG4pe3JldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KFwiYmFja2VuZFwiLFwiUHJvZ3JhbU1hbmFnZXIuYnVpbGRcIiwoKCk9Pntjb25zdCByPW5ldyBpLkdsc2xQcmVwcm9jZXNzb3IodGhpcy5nbENvbnRleHQsZSx0LG4pLG89ci5wcmVwcm9jZXNzKCksYT10aGlzLmNvbXBpbGUobyk7cmV0dXJue3Byb2dyYW1JbmZvOmUscHJvZ3JhbTphLHVuaWZvcm1Mb2NhdGlvbnM6dGhpcy5nZXRVbmlmb3JtTG9jYXRpb25zKGEsci5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMsci5jb250ZXh0LnByb2dyYW1JbmZvLnZhcmlhYmxlcyksYXR0cmliTG9jYXRpb25zOnRoaXMuZ2V0QXR0cmliTG9jYXRpb25zKGEpfX0pKX1jb21waWxlKGUpe2lmKCF0aGlzLnZlcnRleFNoYWRlcil7by5Mb2dnZXIudmVyYm9zZShcIlByb3JncmFtTWFuYWdlclwiLFwiQ29tcGlsaW5nIGFuZCBjYWNoaW5nIFZlcnRleCBzaGFkZXIgZm9yIHRoZSBmaXJzdCB0aW1lXCIpO2NvbnN0IGU9KDAsYS5nZXRWZXJ0ZXhTaGFkZXJTb3VyY2UpKHRoaXMuZ2xDb250ZXh0LnZlcnNpb24pO3RoaXMudmVydGV4U2hhZGVyPXRoaXMuZ2xDb250ZXh0LmNvbXBpbGVTaGFkZXIoZSx0aGlzLmdsQ29udGV4dC5nbC5WRVJURVhfU0hBREVSKX1yLmVudi5kZWJ1ZyYmby5Mb2dnZXIudmVyYm9zZShcIlByb3JncmFtTWFuYWdlclwiLGBGcmFnU2hhZGVyOlxcbiR7ZX1cXG5gKTtjb25zdCB0PXRoaXMuZ2xDb250ZXh0LmNvbXBpbGVTaGFkZXIoZSx0aGlzLmdsQ29udGV4dC5nbC5GUkFHTUVOVF9TSEFERVIpLG49dGhpcy5nbENvbnRleHQuY3JlYXRlUHJvZ3JhbSh0aGlzLnZlcnRleFNoYWRlcix0KTtyZXR1cm4gdGhpcy5nbENvbnRleHQuZGVsZXRlU2hhZGVyKHQpLG59YmluZE91dHB1dChlKXtjb25zdCB0PWUud2lkdGgsbj1lLmhlaWdodDtvLkxvZ2dlci52ZXJib3NlKFwiUHJvcmdyYW1NYW5hZ2VyXCIsYEJpbmRpbmcgb3V0cHV0IHRleHR1cmUgdG8gRnJhbWVidWZmZXI6IHcvaD0ke3R9LyR7bn0sIHNoYXBlPSR7ZS5zaGFwZX0sIHR5cGU9JHtlLnRlbnNvci50eXBlfWApLHRoaXMuZ2xDb250ZXh0LmF0dGFjaEZyYW1lYnVmZmVyKGUudGV4dHVyZSx0LG4pfWJpbmRBdHRyaWJ1dGVzKGUpe2NvbnN0IHQ9ZS5wb3NpdGlvbixuPWUudGV4dHVyZUNvb3JkO3RoaXMuZ2xDb250ZXh0LnNldFZlcnRleEF0dHJpYnV0ZXModCxuKSx0aGlzLmF0dHJpYnV0ZXNCb3VuZD0hMH1iaW5kVW5pZm9ybXMoZSx0LG4pe3ZhciByO2NvbnN0IG89dGhpcy5nbENvbnRleHQuZ2w7bGV0IGk9MDtmb3IoY29uc3R7bmFtZTphLHR5cGU6cyxsb2NhdGlvbjp1LGFycmF5TGVuZ3RoOmx9b2YgZSl7Y29uc3QgZT1udWxsPT09KHI9dC5maW5kKChlPT5lLm5hbWU9PT1hKSkpfHx2b2lkIDA9PT1yP3ZvaWQgMDpyLmRhdGE7aWYoXCJzYW1wbGVyMkRcIiE9PXMmJiFlKXRocm93IG5ldyBFcnJvcihgdmFyaWFibGUgJyR7YX0nIGRvZXMgbm90IGhhdmUgZGF0YSBkZWZpbmVkIGluIHByb2dyYW0gaW5mb2ApO3N3aXRjaChzKXtjYXNlXCJzYW1wbGVyMkRcIjp0aGlzLmJpbmRUZXh0dXJlKG5baV0sdSxpKSxpKys7YnJlYWs7Y2FzZVwiZmxvYXRcIjpsP28udW5pZm9ybTFmdih1LGUpOm8udW5pZm9ybTFmKHUsZSk7YnJlYWs7Y2FzZVwiaW50XCI6bD9vLnVuaWZvcm0xaXYodSxlKTpvLnVuaWZvcm0xaSh1LGUpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbmlmb3JtIG5vdCBpbXBsZW1lbnRlZDogJHtzfWApfX19YmluZFRleHR1cmUoZSx0LG4pe3RoaXMuZ2xDb250ZXh0LmJpbmRUZXh0dXJlVG9Vbmlmb3JtKGUudGV4dHVyZSxuLHQpfWdldEF0dHJpYkxvY2F0aW9ucyhlKXtyZXR1cm57cG9zaXRpb246dGhpcy5nZXRBdHRyaWJMb2NhdGlvbihlLFwicG9zaXRpb25cIiksdGV4dHVyZUNvb3JkOnRoaXMuZ2V0QXR0cmliTG9jYXRpb24oZSxcInRleHR1cmVDb29yZFwiKX19Z2V0VW5pZm9ybUxvY2F0aW9ucyhlLHQsbil7Y29uc3Qgcj1bXTtpZih0KWZvcihjb25zdCBuIG9mIHQpci5wdXNoKHtuYW1lOm4sdHlwZTpcInNhbXBsZXIyRFwiLGxvY2F0aW9uOnRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKGUsbil9KTtpZihuKWZvcihjb25zdCB0IG9mIG4pci5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7bG9jYXRpb246dGhpcy5nZXRVbmlmb3JtTG9jYXRpb24oZSx0Lm5hbWUpfSkpO3JldHVybiByfWdldFVuaWZvcm1Mb2NhdGlvbihlLHQpe2NvbnN0IG49dGhpcy5nbENvbnRleHQuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGUsdCk7aWYobnVsbD09PW4pdGhyb3cgbmV3IEVycm9yKGBVbmlmb3JtICR7dH0gbm90IGZvdW5kLmApO3JldHVybiBufWdldEF0dHJpYkxvY2F0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZ2xDb250ZXh0LmdsLmdldEF0dHJpYkxvY2F0aW9uKGUsdCl9fX0sMjE3MTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5XZWJHTFNlc3Npb25IYW5kbGVyPXZvaWQgMDtjb25zdCByPW4oMTMxNSksbz1uKDU4ODEpLGk9big3ODYwKSxhPW4oNDExMCkscz1uKDI3NTcpLHU9big3NjE4KSxsPW4oNTI0Myk7dC5XZWJHTFNlc3Npb25IYW5kbGVyPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5iYWNrZW5kPWUsdGhpcy5jb250ZXh0PXQsdGhpcy5sYXlvdXRTdHJhdGVneT1uZXcgdS5QcmVmZXJMb2dpY2FsU3RyYXRlZ3koZS5nbENvbnRleHQubWF4VGV4dHVyZVNpemUpLHRoaXMucHJvZ3JhbU1hbmFnZXI9bmV3IHMuUHJvZ3JhbU1hbmFnZXIodGhpcy5jb250ZXh0LnByb2ZpbGVyLGUuZ2xDb250ZXh0LHRoaXMubGF5b3V0U3RyYXRlZ3kpLHRoaXMudGV4dHVyZU1hbmFnZXI9bmV3IGwuVGV4dHVyZU1hbmFnZXIoZS5nbENvbnRleHQsdGhpcy5sYXlvdXRTdHJhdGVneSx0aGlzLmNvbnRleHQucHJvZmlsZXIse3JldXNlVGV4dHVyZXM6XCJmdWxsXCI9PT1lLnRleHR1cmVDYWNoZU1vZGV9KSx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwLHRoaXMucGFjaz1lLnBhY2ssdGhpcy5wYWNrMnVucGFja01hcD1uZXcgTWFwLHRoaXMudW5wYWNrMnBhY2tNYXA9bmV3IE1hcH1jcmVhdGVJbmZlcmVuY2VIYW5kbGVyKCl7cmV0dXJuIG5ldyBpLldlYkdMSW5mZXJlbmNlSGFuZGxlcih0aGlzKX1vbkdyYXBoSW5pdGlhbGl6ZWQoZSl7Y29uc3QgdD1lLmdldFZhbHVlcygpLmZpbHRlcigoZT0+LTE9PT1lLmZyb20mJmUudGVuc29yKSkubWFwKChlPT5lLnRlbnNvci5kYXRhSWQpKTt0aGlzLmluaXRpYWxpemVycz1uZXcgU2V0KHQpfWlzSW5pdGlhbGl6ZXIoZSl7cmV0dXJuISF0aGlzLmluaXRpYWxpemVycyYmdGhpcy5pbml0aWFsaXplcnMuaGFzKGUpfWFkZEluaXRpYWxpemVyKGUpe3RoaXMuaW5pdGlhbGl6ZXJzLmFkZChlKX1nZXRUZXh0dXJlRGF0YShlLHQpe3JldHVybiB0P3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQoZSk6dGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KGUpfXNldFRleHR1cmVEYXRhKGUsdCxuPSExKXtyLkxvZ2dlci52ZXJib3NlKFwiV2ViR0xTZXNzaW9uSGFuZGxlclwiLFwiU3RvcmluZyBUZXh0dXJlIGRhdGEgaW4gY2FjaGVcIiksbj90aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuc2V0KGUsdCk6dGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuc2V0KGUsdCl9ZGlzcG9zZSgpe3RoaXMucHJvZ3JhbU1hbmFnZXIuZGlzcG9zZSgpLHRoaXMudGV4dHVyZU1hbmFnZXIuY2xlYXJBY3RpdmVUZXh0dXJlcygpLHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKChlPT50aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKGUsITApKSksdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXAsdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCgoZT0+dGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZShlLCEwKSkpLHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXB9cmVzb2x2ZShlLHQsbil7Y29uc3Qgcj0oMCxvLnJlc29sdmVPcGVyYXRvcikoZSx0LGEuV0VCR0xfT1BfUkVTT0xWRV9SVUxFUyk7cmV0dXJue2ltcGw6ci5vcEltcGwsY29udGV4dDpyLm9wSW5pdD9yLm9wSW5pdChlLG4pOmV9fX19LDk2MjI6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuVWludDhEYXRhRW5jb2Rlcj10LlJHQkFGbG9hdERhdGFFbmNvZGVyPXQuUmVkRmxvYXQzMkRhdGFFbmNvZGVyPXZvaWQgMDtjb25zdCByPW4oMTMxNSk7dC5SZWRGbG9hdDMyRGF0YUVuY29kZXI9Y2xhc3N7Y29uc3RydWN0b3IoZSx0PTEpe2lmKDE9PT10KXRoaXMuaW50ZXJuYWxGb3JtYXQ9ZS5SMzJGLHRoaXMuZm9ybWF0PWUuUkVELHRoaXMudGV4dHVyZVR5cGU9ZS5GTE9BVCx0aGlzLmNoYW5uZWxTaXplPXQ7ZWxzZXtpZig0IT09dCl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnVtYmVyIG9mIGNoYW5uZWxzOiAke3R9YCk7dGhpcy5pbnRlcm5hbEZvcm1hdD1lLlJHQkEzMkYsdGhpcy5mb3JtYXQ9ZS5SR0JBLHRoaXMudGV4dHVyZVR5cGU9ZS5GTE9BVCx0aGlzLmNoYW5uZWxTaXplPXR9fWVuY29kZShlLHQpe2xldCBuLG87cmV0dXJuIGUuY29uc3RydWN0b3IhPT1GbG9hdDMyQXJyYXkmJihyLkxvZ2dlci53YXJuaW5nKFwiRW5jb2RlclwiLFwiZGF0YSB3YXMgbm90IG9mIHR5cGUgRmxvYXQzMjsgY3JlYXRpbmcgbmV3IEZsb2F0MzJBcnJheVwiKSxvPW5ldyBGbG9hdDMyQXJyYXkoZSkpLHQqdGhpcy5jaGFubmVsU2l6ZT5lLmxlbmd0aD8oci5Mb2dnZXIud2FybmluZyhcIkVuY29kZXJcIixcIlNvdXJjZSBkYXRhIHRvbyBzbWFsbC4gQWxsb2NhdGluZyBsYXJnZXIgYXJyYXlcIiksbz1lLG49dGhpcy5hbGxvY2F0ZSh0KnRoaXMuY2hhbm5lbFNpemUpLG8uZm9yRWFjaCgoKGUsdCk9Pm5bdF09ZSkpKToobz1lLG49byksbn1hbGxvY2F0ZShlKXtyZXR1cm4gbmV3IEZsb2F0MzJBcnJheSg0KmUpfWRlY29kZShlLHQpe3JldHVybiAxPT09dGhpcy5jaGFubmVsU2l6ZT9lLmZpbHRlcigoKGUsdCk9PnQlND09MCkpLnN1YmFycmF5KDAsdCk6ZS5zdWJhcnJheSgwLHQpfX0sdC5SR0JBRmxvYXREYXRhRW5jb2Rlcj1jbGFzc3tjb25zdHJ1Y3RvcihlLHQ9MSxuKXtpZigxIT09dCYmNCE9PXQpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHt0fWApO3RoaXMuaW50ZXJuYWxGb3JtYXQ9ZS5SR0JBLHRoaXMuZm9ybWF0PWUuUkdCQSx0aGlzLmNoYW5uZWxTaXplPXQsdGhpcy50ZXh0dXJlVHlwZT1ufHxlLkZMT0FUfWVuY29kZShlLHQpe2xldCBuPWU7cmV0dXJuIDE9PT10aGlzLmNoYW5uZWxTaXplJiYoci5Mb2dnZXIudmVyYm9zZShcIkVuY29kZXJcIixcIkV4cGxvZGluZyBpbnRvIGEgbGFyZ2VyIGFycmF5XCIpLG49dGhpcy5hbGxvY2F0ZSh0KSxlLmZvckVhY2goKChlLHQpPT5uWzQqdF09ZSkpKSxufWFsbG9jYXRlKGUpe3JldHVybiBuZXcgRmxvYXQzMkFycmF5KDQqZSl9ZGVjb2RlKGUsdCl7cmV0dXJuIDE9PT10aGlzLmNoYW5uZWxTaXplP2UuZmlsdGVyKCgoZSx0KT0+dCU0PT0wKSkuc3ViYXJyYXkoMCx0KTplLnN1YmFycmF5KDAsdCl9fSx0LlVpbnQ4RGF0YUVuY29kZXI9Y2xhc3N7Y29uc3RydWN0b3IoZSx0PTEpe2lmKHRoaXMuY2hhbm5lbFNpemU9NCwxPT09dCl0aGlzLmludGVybmFsRm9ybWF0PWUuQUxQSEEsdGhpcy5mb3JtYXQ9ZS5BTFBIQSx0aGlzLnRleHR1cmVUeXBlPWUuVU5TSUdORURfQllURSx0aGlzLmNoYW5uZWxTaXplPXQ7ZWxzZXtpZig0IT09dCl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnVtYmVyIG9mIGNoYW5uZWxzOiAke3R9YCk7dGhpcy5pbnRlcm5hbEZvcm1hdD1lLlJHQkEsdGhpcy5mb3JtYXQ9ZS5SR0JBLHRoaXMudGV4dHVyZVR5cGU9ZS5VTlNJR05FRF9CWVRFLHRoaXMuY2hhbm5lbFNpemU9dH19ZW5jb2RlKGUsdCl7cmV0dXJuIG5ldyBVaW50OEFycmF5KGUuYnVmZmVyLGUuYnl0ZU9mZnNldCxlLmJ5dGVMZW5ndGgpfWFsbG9jYXRlKGUpe3JldHVybiBuZXcgVWludDhBcnJheShlKnRoaXMuY2hhbm5lbFNpemUpfWRlY29kZShlLHQpe2lmKGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KXJldHVybiBlLnN1YmFycmF5KDAsdCk7dGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFycmF5IHR5cGU6ICR7ZS5jb25zdHJ1Y3Rvcn1gKX19fSw3NjE4OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldEJhdGNoRGltPXQuc2l6ZVRvU3F1YXJpc2hTaGFwZT10LmdldFJvd3NDb2xzPXQuc2l6ZUZyb21TaGFwZT10LmlzSW50PXQucGFyc2VBeGlzUGFyYW09dC5zcXVlZXplU2hhcGU9dC5QcmVmZXJMb2dpY2FsU3RyYXRlZ3k9dC5BbHdheXNLZWVwT3JpZ2luYWxTaXplU3RyYXRlZ3k9dm9pZCAwO2NvbnN0IHI9bigxMzE1KSxvPW4oNzI3Myk7ZnVuY3Rpb24gaShlLHQpe2NvbnN0IG49W10scj1bXSxvPW51bGwhPXQmJkFycmF5LmlzQXJyYXkodCkmJjA9PT10Lmxlbmd0aCxpPW51bGw9PXR8fG8/bnVsbDphKHQsZSkuc29ydCgpO2xldCBzPTA7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDsrK3Qpe2lmKG51bGwhPWkpe2lmKGlbc109PT10JiYxIT09ZVt0XSl0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNxdWVlemUgYXhpcyAke3R9IHNpbmNlIGl0cyBkaW0gJyR7ZVt0XX0nIGlzIG5vdCAxYCk7KG51bGw9PWlbc118fGlbc10+dCkmJjE9PT1lW3RdJiYobi5wdXNoKGVbdF0pLHIucHVzaCh0KSksaVtzXTw9dCYmcysrfTEhPT1lW3RdJiYobi5wdXNoKGVbdF0pLHIucHVzaCh0KSl9cmV0dXJue25ld1NoYXBlOm4sa2VwdERpbXM6cn19ZnVuY3Rpb24gYShlLHQpe2NvbnN0IG49dC5sZW5ndGg7cmV0dXJuIGU9bnVsbD09ZT90Lm1hcCgoKGUsdCk9PnQpKTpbXS5jb25jYXQoZSksKDAsby5hc3NlcnQpKGUuZXZlcnkoKGU9PmU+PS1uJiZlPG4pKSwoKCk9PmBBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbiByYW5nZSBbLSR7bn0sICR7bn0pIGJ1dCBnb3QgYXhpcyAke2V9YCkpLCgwLG8uYXNzZXJ0KShlLmV2ZXJ5KHMpLCgoKT0+YEFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGludGVnZXJzIGJ1dCBnb3QgYXhpcyAke2V9YCkpLGUubWFwKChlPT5lPDA/bitlOmUpKX1mdW5jdGlvbiBzKGUpe3JldHVybiBlJTE9PTB9ZnVuY3Rpb24gdShlKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIDE7bGV0IHQ9ZVswXTtmb3IobGV0IG49MTtuPGUubGVuZ3RoO24rKyl0Kj1lW25dO3JldHVybiB0fWZ1bmN0aW9uIGwoZSl7Y29uc3QgdD1NYXRoLmNlaWwoTWF0aC5zcXJ0KGUpKTtyZXR1cm5bdCxNYXRoLmNlaWwoZS90KV19dC5BbHdheXNLZWVwT3JpZ2luYWxTaXplU3RyYXRlZ3k9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5tYXhUZXh0dXJlU2l6ZT1lfWNvbXB1dGVUZXh0dXJlV0goZSx0KXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuWzEsMV07Y29uc3Qgbj10aGlzLm1heFRleHR1cmVTaXplO2lmKHQmJnZvaWQgMCE9PXQuYnJlYWtBeGlzKXtjb25zdCBvPXQuYnJlYWtBeGlzPj1lLmxlbmd0aD8xOmUuc2xpY2UodC5icmVha0F4aXMpLnJlZHVjZSgoKGUsdCk9PmUqdCkpLGk9dC5icmVha0F4aXM8PTA/MTplLnNsaWNlKDAsdC5icmVha0F4aXMpLnJlZHVjZSgoKGUsdCk9PmUqdCkpO2lmKCEobz5ufHxpPm4pKXJldHVybltvLGldO3IuTG9nZ2VyLnZlcmJvc2UoXCJUZXh0dXJlTGF5b3V0XCIsYEdpdmVuIHdpZHRoL2hlaWdodCBwcmVmZXJlbmNlcyB3ZXJlIHVuYXR0YWluYWJsZTogc2hhcGU6JHtlfSwgYnJlYWtBeGlzOiR7dC5icmVha0F4aXN9YCl9Y29uc3Qgbz1lLnJlZHVjZSgoKGUsdCk9PmUqdCkpO2xldCBpPU1hdGguZmxvb3IoTWF0aC5zcXJ0KG8pKTtmb3IoO2k8biYmaTxvJiZvJWkhPTA7aSsrKTtpZihpPj1ufHxvJWkhPTApdGhyb3cgbmV3IEVycm9yKGBUaGUgZ2l2ZW4gZGltZW5zaW9ucyBhcmUgb3V0c2lkZSB0aGlzIEdQVSdzIGJvdW5kYXJpZXM6ICR7ZX1gKTtyZXR1cm5baSxvL2ldfX0sdC5QcmVmZXJMb2dpY2FsU3RyYXRlZ3k9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5tYXhUZXh0dXJlU2l6ZT1lfWNvbXB1dGVUZXh0dXJlV0goZSx0KXtjb25zdCBuPXRoaXMuY29tcHV0ZVRleHR1cmUoZSx0KTtyZXR1cm4gdCYmdC5pc1BhY2tlZCYmKG5bMF0vPTIsblsxXS89MiksdCYmdC5yZXZlcnNlV0g/W25bMV0sblswXV06bn1jb21wdXRlVGV4dHVyZShlLHQpe2NvbnN0IG49dCYmdC5pc1BhY2tlZDtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIG4/WzIsMl06WzEsMV07bGV0IG89dGhpcy5tYXhUZXh0dXJlU2l6ZTtpZih0JiZ2b2lkIDAhPT10LmJyZWFrQXhpcyl7Y29uc3Qgbj10LmJyZWFrQXhpcz49ZS5sZW5ndGg/MTplLnNsaWNlKHQuYnJlYWtBeGlzKS5yZWR1Y2UoKChlLHQpPT5lKnQpKSxpPXQuYnJlYWtBeGlzPD0wPzE6ZS5zbGljZSgwLHQuYnJlYWtBeGlzKS5yZWR1Y2UoKChlLHQpPT5lKnQpKTtpZighKG4+b3x8aT5vKSlyZXR1cm5bbixpXTtyLkxvZ2dlci52ZXJib3NlKFwiVGV4dHVyZUxheW91dFwiLGBHaXZlbiB3aWR0aC9oZWlnaHQgcHJlZmVyZW5jZXMgd2VyZSB1bmF0dGFpbmFibGU6IHNoYXBlOiR7ZX0sIGJyZWFrQXhpczoke3QuYnJlYWtBeGlzfWApfWxldCBhPWUuc2xpY2UoMCk7aWYobiYmKG8qPTIsYT1hLm1hcCgoKGUsdCk9PnQ+PWEubGVuZ3RoLTI/YVt0XSUyPT0wP2FbdF06YVt0XSsxOmFbdF0pKSwxPT09YS5sZW5ndGgmJihhPVsyLGFbMF1dKSksMiE9PWEubGVuZ3RoKXtjb25zdCBlPWkoYSk7YT1lLm5ld1NoYXBlfWNvbnN0IHM9dShhKTtyZXR1cm4gYS5sZW5ndGg8PTEmJnM8PW8/WzEsc106Mj09PWEubGVuZ3RoJiZhWzBdPD1vJiZhWzFdPD1vP2E6Mz09PWEubGVuZ3RoJiZhWzBdKmFbMV08PW8mJmFbMl08PW8/W2FbMF0qYVsxXSxhWzJdXTozPT09YS5sZW5ndGgmJmFbMF08PW8mJmFbMV0qYVsyXTw9bz9bYVswXSxhWzFdKmFbMl1dOjQ9PT1hLmxlbmd0aCYmYVswXSphWzFdKmFbMl08PW8mJmFbM108PW8/W2FbMF0qYVsxXSphWzJdLGFbM11dOjQ9PT1hLmxlbmd0aCYmYVswXTw9byYmYVsxXSphWzJdKmFbM108PW8/W2FbMF0sYVsxXSphWzJdKmFbM11dOm4/bChzLzQpLm1hcCgoZT0+MiplKSk6bChzKX19LHQuc3F1ZWV6ZVNoYXBlPWksdC5wYXJzZUF4aXNQYXJhbT1hLHQuaXNJbnQ9cyx0LnNpemVGcm9tU2hhcGU9dSx0LmdldFJvd3NDb2xzPWZ1bmN0aW9uKGUpe2lmKDA9PT1lLmxlbmd0aCl0aHJvdyBFcnJvcihcIkNhbm5vdCBnZXQgcm93cyBhbmQgY29sdW1ucyBvZiBhbiBlbXB0eSBzaGFwZSBhcnJheS5cIik7cmV0dXJuW2UubGVuZ3RoPjE/ZVtlLmxlbmd0aC0yXToxLGVbZS5sZW5ndGgtMV1dfSx0LnNpemVUb1NxdWFyaXNoU2hhcGU9bCx0LmdldEJhdGNoRGltPWZ1bmN0aW9uKGUsdD0yKXtyZXR1cm4gdShlLnNsaWNlKDAsZS5sZW5ndGgtdCkpfX0sMzMxNDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0PXQuY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZT12b2lkIDA7Y29uc3Qgcj1uKDcyNzMpLG89big1NjM5KTt0LmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tVGV4dHVyZVR5cGU9KGUsbixyKT0+e2NvbnN0IGk9cj09PW8uVGV4dHVyZVR5cGUudW5wYWNrZWR8fHI9PT1vLlRleHR1cmVUeXBlLnVucGFja2VkUmV2ZXJzZWQ/MTo0LGE9cj09PW8uVGV4dHVyZVR5cGUucGFja2VkLHM9cj09PW8uVGV4dHVyZVR5cGUudW5wYWNrZWRSZXZlcnNlZHx8cj09PW8uVGV4dHVyZVR5cGUucGFja2VkLHU9cj09PW8uVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbj9uLmxlbmd0aC0xOnZvaWQgMCxsPXI9PT1vLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24/bi5tYXAoKChlLHQpPT50PT09bi5sZW5ndGgtMT80KmU6ZSkpOnZvaWQgMDtyZXR1cm4oMCx0LmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUpKGUsbixpLGwse2lzUGFja2VkOmEscmV2ZXJzZVdIOnMsYnJlYWtBeGlzOnV9KX0sdC5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQ9KGUsbixyKT0+e2NvbnN0IG89KDAsdC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKShlLG4scik7cmV0dXJuW28ud2lkdGgsby5oZWlnaHRdfSx0LmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGU9KGUsdCxuPTEsbyxpKT0+e2NvbnN0IGE9ISghaXx8IWkuaXNQYWNrZWQpLFtzLHVdPWUuY29tcHV0ZVRleHR1cmVXSChhJiZvfHx0LGkpLGw9dC5sZW5ndGg7bGV0IGM9dC5zbGljZSgwKTtpZigwPT09bCYmKGM9WzFdKSwxPT09bilvPXQ7ZWxzZSBpZihhKXtpZig0IT09bil0aHJvdyBuZXcgRXJyb3IoXCJhIHBhY2tlZCB0ZXh0dXJlIG11c3QgYmUgNC1jaGFubmVsXCIpO289dCxsPjAmJihjW2wtMV09TWF0aC5jZWlsKGNbbC0xXS8yKSksbD4xJiYoY1tsLTJdPU1hdGguY2VpbChjW2wtMl0vMikpfWVsc2UgaWYoIW8pdGhyb3cgbmV3IEVycm9yKFwiVW5wYWNrZWQgc2hhcGUgaXMgbmVlZGVkIHdoZW4gdXNpbmcgY2hhbm5lbHMgPiAxXCIpO3JldHVybnt3aWR0aDpzLGhlaWdodDp1LGNoYW5uZWxzOm4saXNQYWNrZWQ6YSxzaGFwZTpjLHN0cmlkZXM6ci5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoYyksdW5wYWNrZWRTaGFwZTpvLHJldmVyc2VkV0g6aSYmaS5yZXZlcnNlV0h9fX0sNTI0MzooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5UZXh0dXJlTWFuYWdlcj12b2lkIDA7Y29uc3Qgcj1uKDEzMTUpO3QuVGV4dHVyZU1hbmFnZXI9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4scil7dGhpcy5nbENvbnRleHQ9ZSx0aGlzLmxheW91dFN0cmF0ZWd5PXQsdGhpcy5wcm9maWxlcj1uLHRoaXMuY29uZmlnPXIsdGhpcy5wZW5kaW5nUmVhZD1uZXcgTWFwLHIucmV1c2VUZXh0dXJlcyYmKHRoaXMuaW5Vc2VUZXh0dXJlcz1uZXcgTWFwLHRoaXMuaWRsZVRleHR1cmVzPW5ldyBNYXAsdGhpcy50ZXh0dXJlTG9va3VwPW5ldyBNYXApfWNyZWF0ZVRleHR1cmVGcm9tTGF5b3V0KGUsdCxuLG8pe2NvbnN0IGk9dGhpcy50b0VuY29kZXJUeXBlKGUpLGE9dGhpcy5nbENvbnRleHQuZ2V0RW5jb2RlcihpLHQuY2hhbm5lbHN8fDEsbyk7aWYodC5pc1BhY2tlZCYmMT09PW8pdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO2NvbnN0IHM9dC53aWR0aCx1PXQuaGVpZ2h0O2xldCBsLGM7aWYodGhpcy5jb25maWcucmV1c2VUZXh0dXJlcyl7bD1gJHtzfXgke3V9XyR7YS5mb3JtYXR9XyR7YS5pbnRlcm5hbEZvcm1hdH1fJHthLnRleHR1cmVUeXBlfWAsYz10aGlzLmluVXNlVGV4dHVyZXMuZ2V0KGwpLGN8fChjPVtdLHRoaXMuaW5Vc2VUZXh0dXJlcy5zZXQobCxjKSk7Y29uc3QgdD10aGlzLmlkbGVUZXh0dXJlcy5nZXQobCk7aWYodCYmdC5sZW5ndGg+MCl7Y29uc3Qgcj10LnBvcCgpO3JldHVybiBjLnB1c2gociksMT09PW8mJnRoaXMuZ2xDb250ZXh0LnVwZGF0ZVRleHR1cmUocixzLHUsYSx0aGlzLnRvVGV4dHVyZURhdGEoZSxuKSkscn19ci5Mb2dnZXIudmVyYm9zZShcIlRleHR1cmVNYW5hZ2VyXCIsYENyZWF0aW5nIG5ldyB0ZXh0dXJlIG9mIHNpemUgJHt0LndpZHRofXgke3QuaGVpZ2h0fWApO2NvbnN0IHA9dGhpcy5nbENvbnRleHQuYWxsb2NhdGVUZXh0dXJlKHMsdSxhLHRoaXMudG9UZXh0dXJlRGF0YShlLG4pKTtyZXR1cm4gdGhpcy5jb25maWcucmV1c2VUZXh0dXJlcyYmKGMucHVzaChwKSx0aGlzLnRleHR1cmVMb29rdXAuc2V0KHAsbCkpLHB9cmVhZFRleHR1cmUoZSx0LG4pe3JldHVybiBufHwobj0xKSx0aGlzLnByb2ZpbGVyLmV2ZW50KFwiYmFja2VuZFwiLFwiVGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmVcIiwoKCk9Pntjb25zdCByPWUuc2hhcGUucmVkdWNlKCgoZSx0KT0+ZSp0KSkqbixvPXRoaXMuZ2xDb250ZXh0LnJlYWRUZXh0dXJlKGUudGV4dHVyZSxlLndpZHRoLGUuaGVpZ2h0LHIsdGhpcy50b0VuY29kZXJUeXBlKHQpLG4pO3JldHVybiB0aGlzLnRvVGVuc29yRGF0YSh0LG8pfSkpfWFzeW5jIHJlYWRUZXh0dXJlQXN5bmMoZSx0LG4pe2NvbnN0IHI9ZS50ZW5zb3IuZGF0YUlkO2lmKG58fChuPTEpLHRoaXMucGVuZGluZ1JlYWQuaGFzKHIpKXtjb25zdCBlPXRoaXMucGVuZGluZ1JlYWQuZ2V0KHIpO3JldHVybiBuZXcgUHJvbWlzZSgodD0+bnVsbD09ZT92b2lkIDA6ZS5wdXNoKHQpKSl9cmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoXCJiYWNrZW5kXCIsXCJUZXh0dXJlTWFuYWdlci5yZWFkVGV4dHVyZUFzeW5jXCIsKGFzeW5jKCk9Pnt0aGlzLnBlbmRpbmdSZWFkLnNldChyLFtdKTtjb25zdCBvPWUuc2hhcGUucmVkdWNlKCgoZSx0KT0+ZSp0KSkqbjthd2FpdCB0aGlzLmdsQ29udGV4dC5jcmVhdGVBbmRXYWl0Rm9yRmVuY2UoKTtjb25zdCBpPXRoaXMuZ2xDb250ZXh0LnJlYWRUZXh0dXJlKGUudGV4dHVyZSxlLndpZHRoLGUuaGVpZ2h0LG8sdGhpcy50b0VuY29kZXJUeXBlKHQpLG4pLGE9dGhpcy50b1RlbnNvckRhdGEodCxpKSxzPXRoaXMucGVuZGluZ1JlYWQuZ2V0KHIpO3JldHVybiB0aGlzLnBlbmRpbmdSZWFkLmRlbGV0ZShyKSxudWxsPT1zfHxzLmZvckVhY2goKGU9PmUoYSkpKSxhfSkpfXJlYWRVaW50OFRleHR1cmVBc0Zsb2F0KGUpe3JldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KFwiYmFja2VuZFwiLFwiVGV4dHVyZU1hbmFnZXIucmVhZFVpbnQ4VGV4dHVyZUFzRmxvYXRcIiwoKCk9Pntjb25zdCB0PWUuc2hhcGUucmVkdWNlKCgoZSx0KT0+ZSp0KSksbj10aGlzLmdsQ29udGV4dC5yZWFkVGV4dHVyZShlLnRleHR1cmUsZS53aWR0aCxlLmhlaWdodCw0KnQsXCJieXRlXCIsNCk7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobi5idWZmZXIsbi5ieXRlT2Zmc2V0LHQpfSkpfXJlbGVhc2VUZXh0dXJlKGUsdCl7bGV0IG47aWYodGhpcy5jb25maWcucmV1c2VUZXh0dXJlcyYmKG49dGhpcy50ZXh0dXJlTG9va3VwLmdldChlLnRleHR1cmUpLG4pKXt0JiZ0aGlzLnRleHR1cmVMb29rdXAuZGVsZXRlKG4pO2NvbnN0IHI9dGhpcy5pblVzZVRleHR1cmVzLmdldChuKTtpZihyKXtjb25zdCB0PXIuaW5kZXhPZihlLnRleHR1cmUpO2lmKC0xIT09dCl7ci5zcGxpY2UodCwxKTtsZXQgbz10aGlzLmlkbGVUZXh0dXJlcy5nZXQobik7b3x8KG89W10sdGhpcy5pZGxlVGV4dHVyZXMuc2V0KG4sbykpLG8ucHVzaChlLnRleHR1cmUpfX19biYmIXR8fChyLkxvZ2dlci52ZXJib3NlKFwiVGV4dHVyZU1hbmFnZXJcIixgRGVsZXRpbmcgdGV4dHVyZSBvZiBzaXplICR7ZS53aWR0aH14JHtlLmhlaWdodH1gKSx0aGlzLmdsQ29udGV4dC5kZWxldGVUZXh0dXJlKGUudGV4dHVyZSkpfXRvVGVuc29yRGF0YShlLHQpe3N3aXRjaChlKXtjYXNlXCJpbnQxNlwiOnJldHVybiB0IGluc3RhbmNlb2YgSW50MTZBcnJheT90OkludDE2QXJyYXkuZnJvbSh0KTtjYXNlXCJpbnQzMlwiOnJldHVybiB0IGluc3RhbmNlb2YgSW50MzJBcnJheT90OkludDMyQXJyYXkuZnJvbSh0KTtjYXNlXCJpbnQ4XCI6cmV0dXJuIHQgaW5zdGFuY2VvZiBJbnQ4QXJyYXk/dDpJbnQ4QXJyYXkuZnJvbSh0KTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gdCBpbnN0YW5jZW9mIFVpbnQxNkFycmF5P3Q6VWludDE2QXJyYXkuZnJvbSh0KTtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gdCBpbnN0YW5jZW9mIFVpbnQzMkFycmF5P3Q6VWludDMyQXJyYXkuZnJvbSh0KTtjYXNlXCJ1aW50OFwiOmNhc2VcImJvb2xcIjpyZXR1cm4gdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/dDpVaW50OEFycmF5LmZyb20odCk7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiB0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5P3Q6RmxvYXQzMkFycmF5LmZyb20odCk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiB0IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5P3Q6RmxvYXQ2NEFycmF5LmZyb20odCk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckRhdGEgdHlwZSAke2V9IGlzIG5vdCBzdXBwb3J0ZWRgKX19dG9UZXh0dXJlRGF0YShlLHQpe2lmKHQpcmV0dXJuIHQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXk/dDpuZXcgRmxvYXQzMkFycmF5KHQpfXRvRW5jb2RlclR5cGUoZSl7cmV0dXJuXCJmbG9hdFwifWNsZWFyQWN0aXZlVGV4dHVyZXMoKXt0aGlzLmdsQ29udGV4dC5jbGVhckFjdGl2ZVRleHR1cmVzKCl9fX0sNTYzOTooZSx0KT0+e1widXNlIHN0cmljdFwiO3ZhciBuO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuVGV4dHVyZVR5cGU9dm9pZCAwLChuPXQuVGV4dHVyZVR5cGV8fCh0LlRleHR1cmVUeXBlPXt9KSlbbi51bnBhY2tlZD0wXT1cInVucGFja2VkXCIsbltuLnVucGFja2VkUmV2ZXJzZWQ9MV09XCJ1bnBhY2tlZFJldmVyc2VkXCIsbltuLnBhY2tlZD0yXT1cInBhY2tlZFwiLG5bbi5kb3dubG9hZFVpbnQ4QXNGbG9hdD0zXT1cImRvd25sb2FkVWludDhBc0Zsb2F0XCIsbltuLnBhY2tlZExhc3REaW1lbnNpb249NF09XCJwYWNrZWRMYXN0RGltZW5zaW9uXCJ9LDQzMjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRHbENoYW5uZWxzPXQuZ2V0Q29vcmRzRGF0YVR5cGU9dC5nZXRTcXVlZXplZFBhcmFtcz10LnNxdWVlemVJbnB1dFNoYXBlPXQuZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHM9dC5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWU9dC5yZXBlYXRlZFRyeT10LmdldFBhY2tlZFNoYXBlPXZvaWQgMDtjb25zdCByPW4oNzI3Myk7dC5nZXRQYWNrZWRTaGFwZT1mdW5jdGlvbihlKXtjb25zdCB0PWUubGVuZ3RoO3JldHVybiBlLnNsaWNlKDAsdC0xKS5jb25jYXQoZVt0LTFdLzQpfSx0LnJlcGVhdGVkVHJ5PWFzeW5jIGZ1bmN0aW9uKGUsdD0oZT0+MCksbil7cmV0dXJuIG5ldyBQcm9taXNlKCgocixvKT0+e2xldCBpPTA7Y29uc3QgYT0oKT0+e2lmKGUoKSlyZXR1cm4gdm9pZCByKCk7aSsrO2NvbnN0IHM9dChpKTtudWxsIT1uJiZpPj1uP28oKTpzZXRUaW1lb3V0KGEscyl9O2EoKX0pKX0sdC5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWU9ZnVuY3Rpb24oZSl7cmV0dXJuKDAsci5hc3NlcnQpKHZvaWQgMCE9PWUmJjAhPT1lLmxlbmd0aCwoKCk9PlwiZW1wdHkgc3RyaW5nIGZvdW5kIGZvciBzYW1wbGVyIG5hbWVcIikpLFwiZ2V0XCIrZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStlLnNsaWNlKDEpfSx0LmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZUF0T3V0Q29vcmRzPWZ1bmN0aW9uKGUpe3JldHVybigwLHIuYXNzZXJ0KSh2b2lkIDAhPT1lJiYwIT09ZS5sZW5ndGgsKCgpPT5cImVtcHR5IHN0cmluZyBmb3VuZCBmb3Igc2FtcGxlciBuYW1lXCIpKSxcImdldFwiK2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKStcIkF0T3V0Q29vcmRzXCJ9LHQuc3F1ZWV6ZUlucHV0U2hhcGU9ZnVuY3Rpb24oZSx0KXtsZXQgbj1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGUpKTtyZXR1cm4gbj10LG59LHQuZ2V0U3F1ZWV6ZWRQYXJhbXM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC5tYXAoKHQ9PmVbdF0pKS5qb2luKFwiLCBcIil9LHQuZ2V0Q29vcmRzRGF0YVR5cGU9ZnVuY3Rpb24oZSl7aWYoZTw9MSlyZXR1cm5cImludFwiO2lmKDI9PT1lKXJldHVyblwiaXZlYzJcIjtpZigzPT09ZSlyZXR1cm5cIml2ZWMzXCI7aWYoND09PWUpcmV0dXJuXCJpdmVjNFwiO2lmKDU9PT1lKXJldHVyblwiaXZlYzVcIjtpZig2PT09ZSlyZXR1cm5cIml2ZWM2XCI7dGhyb3cgRXJyb3IoYEdQVSBmb3IgcmFuayAke2V9IGlzIG5vdCB5ZXQgc3VwcG9ydGVkYCl9LHQuZ2V0R2xDaGFubmVscz1mdW5jdGlvbihlPTYpe3JldHVybltcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl0uc2xpY2UoMCxlKX19LDMzODk6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlTmV3V2ViR0xDb250ZXh0PXQuY3JlYXRlV2ViR0xDb250ZXh0PXZvaWQgMDtjb25zdCByPW4oMTMxNSksbz1uKDM1MjQpLGk9e307ZnVuY3Rpb24gYShlKXtjb25zdCB0PWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGRvY3VtZW50KXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgT2Zmc2NyZWVuQ2FudmFzKXRocm93IG5ldyBUeXBlRXJyb3IoXCJmYWlsZWQgdG8gY3JlYXRlIGNhbnZhczogT2Zmc2NyZWVuQ2FudmFzIGlzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKX1jb25zdCBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7cmV0dXJuIGUud2lkdGg9MSxlLmhlaWdodD0xLGV9KCk7bGV0IG47Y29uc3QgaT17YWxwaGE6ITEsZGVwdGg6ITEsYW50aWFsaWFzOiExLHN0ZW5jaWw6ITEscHJlc2VydmVEcmF3aW5nQnVmZmVyOiExLHByZW11bHRpcGxpZWRBbHBoYTohMSxmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiExfTtpZigoIWV8fFwid2ViZ2wyXCI9PT1lKSYmKG49dC5nZXRDb250ZXh0KFwid2ViZ2wyXCIsaSksbikpdHJ5e3JldHVybiBuZXcgby5XZWJHTENvbnRleHQobiwyKX1jYXRjaChlKXtyLkxvZ2dlci53YXJuaW5nKFwiR2xDb250ZXh0RmFjdG9yeVwiLGBmYWlsZWQgdG8gY3JlYXRlIFdlYkdMQ29udGV4dCB1c2luZyBjb250ZXh0SWQgJ3dlYmdsMicuIEVycm9yOiAke2V9YCl9aWYoKCFlfHxcIndlYmdsXCI9PT1lKSYmKG49dC5nZXRDb250ZXh0KFwid2ViZ2xcIixpKXx8dC5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsaSksbikpdHJ5e3JldHVybiBuZXcgby5XZWJHTENvbnRleHQobiwxKX1jYXRjaChlKXtyLkxvZ2dlci53YXJuaW5nKFwiR2xDb250ZXh0RmFjdG9yeVwiLGBmYWlsZWQgdG8gY3JlYXRlIFdlYkdMQ29udGV4dCB1c2luZyBjb250ZXh0SWQgJ3dlYmdsJyBvciAnZXhwZXJpbWVudGFsLXdlYmdsJy4gRXJyb3I6ICR7ZX1gKX10aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBpcyBub3Qgc3VwcG9ydGVkXCIpfXQuY3JlYXRlV2ViR0xDb250ZXh0PWZ1bmN0aW9uIGUodCl7bGV0IG47dCYmXCJ3ZWJnbDJcIiE9PXR8fCEoXCJ3ZWJnbDJcImluIGkpP3QmJlwid2ViZ2xcIiE9PXR8fCEoXCJ3ZWJnbFwiaW4gaSl8fChuPWkud2ViZ2wpOm49aS53ZWJnbDIsbj1ufHxhKHQpLHQ9dHx8MT09PW4udmVyc2lvbj9cIndlYmdsXCI6XCJ3ZWJnbDJcIjtjb25zdCByPW4uZ2w7cmV0dXJuIGlbdF09bixyLmlzQ29udGV4dExvc3QoKT8oZGVsZXRlIGlbdF0sZSh0KSk6KHIuZGlzYWJsZShyLkRFUFRIX1RFU1QpLHIuZGlzYWJsZShyLlNURU5DSUxfVEVTVCksci5kaXNhYmxlKHIuQkxFTkQpLHIuZGlzYWJsZShyLkRJVEhFUiksci5kaXNhYmxlKHIuUE9MWUdPTl9PRkZTRVRfRklMTCksci5kaXNhYmxlKHIuU0FNUExFX0NPVkVSQUdFKSxyLmVuYWJsZShyLlNDSVNTT1JfVEVTVCksci5lbmFibGUoci5DVUxMX0ZBQ0UpLHIuY3VsbEZhY2Uoci5CQUNLKSxuKX0sdC5jcmVhdGVOZXdXZWJHTENvbnRleHQ9YX0sMzUyNDpmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCxuLHIpe3ZvaWQgMD09PXImJihyPW4pO3ZhciBvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxuKTtvJiYhKFwiZ2V0XCJpbiBvPyF0Ll9fZXNNb2R1bGU6by53cml0YWJsZXx8by5jb25maWd1cmFibGUpfHwobz17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtuXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLG8pfTpmdW5jdGlvbihlLHQsbixyKXt2b2lkIDA9PT1yJiYocj1uKSxlW3JdPXRbbl19KSxvPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOnR9KX06ZnVuY3Rpb24oZSx0KXtlLmRlZmF1bHQ9dH0pLGk9dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgbiBpbiBlKVwiZGVmYXVsdFwiIT09biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbikmJnIodCxlLG4pO3JldHVybiBvKHQsZSksdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5XZWJHTENvbnRleHQ9dC5saW5lYXJTZWFyY2hMYXN0VHJ1ZT12b2lkIDA7Y29uc3QgYT1uKDg0NTMpLHM9aShuKDk2MjIpKSx1PW4oNDMyKTtmdW5jdGlvbiBsKGUpe2xldCB0PTA7Zm9yKDt0PGUubGVuZ3RoJiZlW3RdKCk7Kyt0KTtyZXR1cm4gdC0xfXQubGluZWFyU2VhcmNoTGFzdFRydWU9bCx0LldlYkdMQ29udGV4dD1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMuZnJhbWVCdWZmZXJCb3VuZD0hMSx0aGlzLml0ZW1zVG9Qb2xsPVtdLHRoaXMuZ2w9ZSx0aGlzLnZlcnNpb249dCx0aGlzLmdldEV4dGVuc2lvbnMoKSx0aGlzLnZlcnRleGJ1ZmZlcj10aGlzLmNyZWF0ZVZlcnRleGJ1ZmZlcigpLHRoaXMuZnJhbWVidWZmZXI9dGhpcy5jcmVhdGVGcmFtZWJ1ZmZlcigpLHRoaXMucXVlcnlWaXRhbFBhcmFtZXRlcnMoKX1hbGxvY2F0ZVRleHR1cmUoZSx0LG4scil7Y29uc3Qgbz10aGlzLmdsLGk9by5jcmVhdGVUZXh0dXJlKCk7by5iaW5kVGV4dHVyZShvLlRFWFRVUkVfMkQsaSksby50ZXhQYXJhbWV0ZXJpKG8uVEVYVFVSRV8yRCxvLlRFWFRVUkVfTUlOX0ZJTFRFUixvLk5FQVJFU1QpLG8udGV4UGFyYW1ldGVyaShvLlRFWFRVUkVfMkQsby5URVhUVVJFX01BR19GSUxURVIsby5ORUFSRVNUKSxvLnRleFBhcmFtZXRlcmkoby5URVhUVVJFXzJELG8uVEVYVFVSRV9XUkFQX1Msby5DTEFNUF9UT19FREdFKSxvLnRleFBhcmFtZXRlcmkoby5URVhUVVJFXzJELG8uVEVYVFVSRV9XUkFQX1Qsby5DTEFNUF9UT19FREdFKTtjb25zdCBhPXI/bi5lbmNvZGUocixlKnQpOm51bGw7cmV0dXJuIG8udGV4SW1hZ2UyRChvLlRFWFRVUkVfMkQsMCxuLmludGVybmFsRm9ybWF0LGUsdCwwLG4uZm9ybWF0LG4udGV4dHVyZVR5cGUsYSksdGhpcy5jaGVja0Vycm9yKCksaX11cGRhdGVUZXh0dXJlKGUsdCxuLHIsbyl7Y29uc3QgaT10aGlzLmdsO2kuYmluZFRleHR1cmUoaS5URVhUVVJFXzJELGUpO2NvbnN0IGE9ci5lbmNvZGUobyx0Km4pO2kudGV4U3ViSW1hZ2UyRChpLlRFWFRVUkVfMkQsMCwwLDAsdCxuLHIuZm9ybWF0LHIudGV4dHVyZVR5cGUsYSksdGhpcy5jaGVja0Vycm9yKCl9YXR0YWNoRnJhbWVidWZmZXIoZSx0LG4pe2NvbnN0IHI9dGhpcy5nbDtyLmJpbmRUZXh0dXJlKHIuVEVYVFVSRV8yRCxlKSxyLmJpbmRGcmFtZWJ1ZmZlcihyLkZSQU1FQlVGRkVSLHRoaXMuZnJhbWVidWZmZXIpLHIuZnJhbWVidWZmZXJUZXh0dXJlMkQoci5GUkFNRUJVRkZFUixyLkNPTE9SX0FUVEFDSE1FTlQwLHIuVEVYVFVSRV8yRCxlLDApLHRoaXMuY2hlY2tFcnJvcigpLHIudmlld3BvcnQoMCwwLHQsbiksci5zY2lzc29yKDAsMCx0LG4pfXJlYWRUZXh0dXJlKGUsdCxuLHIsbyxpKXtjb25zdCBhPXRoaXMuZ2w7aXx8KGk9MSksdGhpcy5mcmFtZUJ1ZmZlckJvdW5kfHx0aGlzLmF0dGFjaEZyYW1lYnVmZmVyKGUsdCxuKTtjb25zdCBzPXRoaXMuZ2V0RW5jb2RlcihvLGkpLHU9cy5hbGxvY2F0ZSh0Km4pO3JldHVybiBhLmJpbmRUZXh0dXJlKGEuVEVYVFVSRV8yRCxlKSxhLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGEuRlJBTUVCVUZGRVIsYS5DT0xPUl9BVFRBQ0hNRU5UMCxhLlRFWFRVUkVfMkQsZSwwKSxhLnJlYWRQaXhlbHMoMCwwLHQsbixhLlJHQkEscy50ZXh0dXJlVHlwZSx1KSx0aGlzLmNoZWNrRXJyb3IoKSxzLmRlY29kZSh1LHIpfWlzRnJhbWVidWZmZXJSZWFkeSgpe3JldHVybiEwfWdldEFjdGl2ZVRleHR1cmUoKXtjb25zdCBlPXRoaXMuZ2w7cmV0dXJuXCJURVhUVVJFXCIrKGUuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuQUNUSVZFX1RFWFRVUkUpLWUuVEVYVFVSRTApfWdldFRleHR1cmVCaW5kaW5nKCl7cmV0dXJuIHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuVEVYVFVSRV9CSU5ESU5HXzJEKX1nZXRGcmFtZWJ1ZmZlckJpbmRpbmcoKXtyZXR1cm4gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5GUkFNRUJVRkZFUl9CSU5ESU5HKX1zZXRWZXJ0ZXhBdHRyaWJ1dGVzKGUsdCl7Y29uc3Qgbj10aGlzLmdsO24udmVydGV4QXR0cmliUG9pbnRlcihlLDMsbi5GTE9BVCwhMSwyMCwwKSxuLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGUpLC0xIT09dCYmKG4udmVydGV4QXR0cmliUG9pbnRlcih0LDIsbi5GTE9BVCwhMSwyMCwxMiksbi5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0KSksdGhpcy5jaGVja0Vycm9yKCl9Y3JlYXRlUHJvZ3JhbShlLHQpe2NvbnN0IG49dGhpcy5nbCxyPW4uY3JlYXRlUHJvZ3JhbSgpO3JldHVybiBuLmF0dGFjaFNoYWRlcihyLGUpLG4uYXR0YWNoU2hhZGVyKHIsdCksbi5saW5rUHJvZ3JhbShyKSxyfWNvbXBpbGVTaGFkZXIoZSx0KXtjb25zdCBuPXRoaXMuZ2wscj1uLmNyZWF0ZVNoYWRlcih0KTtpZighcil0aHJvdyBuZXcgRXJyb3IoYGNyZWF0ZVNoYWRlcigpIHJldHVybmVkIG51bGwgd2l0aCB0eXBlICR7dH1gKTtpZihuLnNoYWRlclNvdXJjZShyLGUpLG4uY29tcGlsZVNoYWRlcihyKSwhMT09PW4uZ2V0U2hhZGVyUGFyYW1ldGVyKHIsbi5DT01QSUxFX1NUQVRVUykpdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6ICR7bi5nZXRTaGFkZXJJbmZvTG9nKHIpfVxcblNoYWRlciBzb3VyY2U6XFxuJHtlfWApO3JldHVybiByfWRlbGV0ZVNoYWRlcihlKXt0aGlzLmdsLmRlbGV0ZVNoYWRlcihlKX1iaW5kVGV4dHVyZVRvVW5pZm9ybShlLHQsbil7Y29uc3Qgcj10aGlzLmdsO3IuYWN0aXZlVGV4dHVyZShyLlRFWFRVUkUwK3QpLHRoaXMuY2hlY2tFcnJvcigpLHIuYmluZFRleHR1cmUoci5URVhUVVJFXzJELGUpLHRoaXMuY2hlY2tFcnJvcigpLHIudW5pZm9ybTFpKG4sdCksdGhpcy5jaGVja0Vycm9yKCl9ZHJhdygpe3RoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLlRSSUFOR0xFX1NUUklQLDAsNCksdGhpcy5jaGVja0Vycm9yKCl9Y2hlY2tFcnJvcigpe2lmKGEuZW52LmRlYnVnKXtjb25zdCBlPXRoaXMuZ2wsdD1lLmdldEVycm9yKCk7bGV0IG49XCJcIjtzd2l0Y2godCl7Y2FzZSBlLk5PX0VSUk9SOnJldHVybjtjYXNlIGUuSU5WQUxJRF9FTlVNOm49XCJJTlZBTElEX0VOVU1cIjticmVhaztjYXNlIGUuSU5WQUxJRF9WQUxVRTpuPVwiSU5WQUxJRF9WQUxVRVwiO2JyZWFrO2Nhc2UgZS5JTlZBTElEX09QRVJBVElPTjpuPVwiSU5WQUxJRF9PUEVSQVRJT05cIjticmVhaztjYXNlIGUuSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046bj1cIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OXCI7YnJlYWs7Y2FzZSBlLk9VVF9PRl9NRU1PUlk6bj1cIk9VVF9PRl9NRU1PUllcIjticmVhaztjYXNlIGUuQ09OVEVYVF9MT1NUX1dFQkdMOm49XCJDT05URVhUX0xPU1RfV0VCR0xcIjticmVhaztkZWZhdWx0Om49YFVua25vd24gV2ViR0wgRXJyb3I6ICR7dC50b1N0cmluZygxNil9YH10aHJvdyBuZXcgRXJyb3Iobil9fWRlbGV0ZVRleHR1cmUoZSl7dGhpcy5nbC5kZWxldGVUZXh0dXJlKGUpfWRlbGV0ZVByb2dyYW0oZSl7dGhpcy5nbC5kZWxldGVQcm9ncmFtKGUpfWdldEVuY29kZXIoZSx0LG49MCl7aWYoMj09PXRoaXMudmVyc2lvbilyZXR1cm4gbmV3IHMuUmVkRmxvYXQzMkRhdGFFbmNvZGVyKHRoaXMuZ2wsdCk7c3dpdGNoKGUpe2Nhc2VcImZsb2F0XCI6cmV0dXJuIDE9PT1ufHx0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZD9uZXcgcy5SR0JBRmxvYXREYXRhRW5jb2Rlcih0aGlzLmdsLHQpOm5ldyBzLlJHQkFGbG9hdERhdGFFbmNvZGVyKHRoaXMuZ2wsdCx0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24uSEFMRl9GTE9BVF9PRVMpO2Nhc2VcImludFwiOnRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtjYXNlXCJieXRlXCI6cmV0dXJuIG5ldyBzLlVpbnQ4RGF0YUVuY29kZXIodGhpcy5nbCx0KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhVHlwZTogJHtlfWApfX1jbGVhckFjdGl2ZVRleHR1cmVzKCl7Y29uc3QgZT10aGlzLmdsO2ZvcihsZXQgdD0wO3Q8dGhpcy5tYXhUZXh0dXJlSW1hZ2VVbml0czsrK3QpZS5hY3RpdmVUZXh0dXJlKGUuVEVYVFVSRTArdCksZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsbnVsbCl9ZGlzcG9zZSgpe2lmKHRoaXMuZGlzcG9zZWQpcmV0dXJuO2NvbnN0IGU9dGhpcy5nbDtlLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLG51bGwpLGUuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlciksZS5iaW5kQnVmZmVyKGUuQVJSQVlfQlVGRkVSLG51bGwpLGUuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4YnVmZmVyKSxlLmJpbmRCdWZmZXIoZS5FTEVNRU5UX0FSUkFZX0JVRkZFUixudWxsKSxlLmZpbmlzaCgpLHRoaXMuZGlzcG9zZWQ9ITB9Y3JlYXRlRGVmYXVsdEdlb21ldHJ5KCl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWy0xLDEsMCwwLDEsLTEsLTEsMCwwLDAsMSwxLDAsMSwxLDEsLTEsMCwxLDBdKX1jcmVhdGVWZXJ0ZXhidWZmZXIoKXtjb25zdCBlPXRoaXMuZ2wsdD1lLmNyZWF0ZUJ1ZmZlcigpO2lmKCF0KXRocm93IG5ldyBFcnJvcihcImNyZWF0ZUJ1ZmZlcigpIHJldHVybmVkIG51bGxcIik7Y29uc3Qgbj10aGlzLmNyZWF0ZURlZmF1bHRHZW9tZXRyeSgpO3JldHVybiBlLmJpbmRCdWZmZXIoZS5BUlJBWV9CVUZGRVIsdCksZS5idWZmZXJEYXRhKGUuQVJSQVlfQlVGRkVSLG4sZS5TVEFUSUNfRFJBVyksdGhpcy5jaGVja0Vycm9yKCksdH1jcmVhdGVGcmFtZWJ1ZmZlcigpe2NvbnN0IGU9dGhpcy5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO2lmKCFlKXRocm93IG5ldyBFcnJvcihcImNyZWF0ZUZyYW1lYnVmZmVyIHJldHVybmVkIG51bGxcIik7cmV0dXJuIGV9cXVlcnlWaXRhbFBhcmFtZXRlcnMoKXtjb25zdCBlPXRoaXMuZ2w7aWYodGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyPXRoaXMuY2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpLHRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkPXRoaXMuY2hlY2tSZW5kZXJGbG9hdDMyKCksdGhpcy5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZD10aGlzLmNoZWNrRmxvYXQzMkRvd25sb2FkKCksMT09PXRoaXMudmVyc2lvbiYmIXRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiYmIXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkKXRocm93IG5ldyBFcnJvcihcImJvdGggZmxvYXQzMiBhbmQgZmxvYXQxNiBUZXh0dXJlVHlwZSBhcmUgbm90IHN1cHBvcnRlZFwiKTt0aGlzLmlzQmxlbmRTdXBwb3J0ZWQ9IXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkfHx0aGlzLmNoZWNrRmxvYXQzMkJsZW5kKCksdGhpcy5tYXhUZXh0dXJlU2l6ZT1lLmdldFBhcmFtZXRlcihlLk1BWF9URVhUVVJFX1NJWkUpLHRoaXMubWF4VGV4dHVyZUltYWdlVW5pdHM9ZS5nZXRQYXJhbWV0ZXIoZS5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksdGhpcy52ZXJzaW9ufWdldEV4dGVuc2lvbnMoKXsyPT09dGhpcy52ZXJzaW9uPyh0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpLHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKSk6KHRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIiksdGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKSl9Y2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpe2NvbnN0IGU9dGhpcy5nbCx0PWUuY3JlYXRlVGV4dHVyZSgpO2UuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELHQpO2NvbnN0IG49Mj09PXRoaXMudmVyc2lvbj9lLlJHQkEzMkY6ZS5SR0JBO2UudGV4SW1hZ2UyRChlLlRFWFRVUkVfMkQsMCxuLDEsMSwwLGUuUkdCQSxlLkZMT0FULG51bGwpO2NvbnN0IHI9ZS5jcmVhdGVGcmFtZWJ1ZmZlcigpO2UuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsciksZS5mcmFtZWJ1ZmZlclRleHR1cmUyRChlLkZSQU1FQlVGRkVSLGUuQ09MT1JfQVRUQUNITUVOVDAsZS5URVhUVVJFXzJELHQsMCk7Y29uc3Qgbz1lLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZS5GUkFNRUJVRkZFUik9PT1lLkZSQU1FQlVGRkVSX0NPTVBMRVRFO3JldHVybiBlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCxudWxsKSxlLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLG51bGwpLGUuZGVsZXRlVGV4dHVyZSh0KSxlLmRlbGV0ZUZyYW1lYnVmZmVyKHIpLG99Y2hlY2tSZW5kZXJGbG9hdDMyKCl7aWYoMj09PXRoaXMudmVyc2lvbil7aWYoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbilyZXR1cm4hMX1lbHNlIGlmKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbilyZXR1cm4hMTtyZXR1cm4gdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyfWNoZWNrRmxvYXQzMkRvd25sb2FkKCl7aWYoMj09PXRoaXMudmVyc2lvbil7aWYoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbilyZXR1cm4hMX1lbHNle2lmKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbilyZXR1cm4hMTtpZighdGhpcy5nbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXRcIikpcmV0dXJuITF9cmV0dXJuIHRoaXMuaXNGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcn1jaGVja0Zsb2F0MzJCbGVuZCgpe2NvbnN0IGU9dGhpcy5nbDtsZXQgdCxuLHIsbyxpO3RyeXt0PWUuY3JlYXRlVGV4dHVyZSgpLG49ZS5jcmVhdGVGcmFtZWJ1ZmZlcigpLGUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELHQpO2NvbnN0IGE9Mj09PXRoaXMudmVyc2lvbj9lLlJHQkEzMkY6ZS5SR0JBO3JldHVybiBlLnRleEltYWdlMkQoZS5URVhUVVJFXzJELDAsYSwxLDEsMCxlLlJHQkEsZS5GTE9BVCxudWxsKSxlLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLG4pLGUuZnJhbWVidWZmZXJUZXh0dXJlMkQoZS5GUkFNRUJVRkZFUixlLkNPTE9SX0FUVEFDSE1FTlQwLGUuVEVYVFVSRV8yRCx0LDApLGUuZW5hYmxlKGUuQkxFTkQpLHI9ZS5jcmVhdGVTaGFkZXIoZS5WRVJURVhfU0hBREVSKSwhIXImJihlLnNoYWRlclNvdXJjZShyLFwidm9pZCBtYWluKCl7fVwiKSxlLmNvbXBpbGVTaGFkZXIociksbz1lLmNyZWF0ZVNoYWRlcihlLkZSQUdNRU5UX1NIQURFUiksISFvJiYoZS5zaGFkZXJTb3VyY2UobyxcInByZWNpc2lvbiBoaWdocCBmbG9hdDt2b2lkIG1haW4oKXtnbF9GcmFnQ29sb3I9dmVjNCgwLjUpO31cIiksZS5jb21waWxlU2hhZGVyKG8pLGk9ZS5jcmVhdGVQcm9ncmFtKCksISFpJiYoZS5hdHRhY2hTaGFkZXIoaSxyKSxlLmF0dGFjaFNoYWRlcihpLG8pLGUubGlua1Byb2dyYW0oaSksZS51c2VQcm9ncmFtKGkpLGUuZHJhd0FycmF5cyhlLlBPSU5UUywwLDEpLGUuZ2V0RXJyb3IoKT09PWUuTk9fRVJST1IpKSl9ZmluYWxseXtlLmRpc2FibGUoZS5CTEVORCksaSYmZS5kZWxldGVQcm9ncmFtKGkpLHImJmUuZGVsZXRlU2hhZGVyKHIpLG8mJmUuZGVsZXRlU2hhZGVyKG8pLG4mJihlLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLG51bGwpLGUuZGVsZXRlRnJhbWVidWZmZXIobikpLHQmJihlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCxudWxsKSxlLmRlbGV0ZVRleHR1cmUodCkpfX1iZWdpblRpbWVyKCl7aWYoMj09PXRoaXMudmVyc2lvbiYmdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pe2NvbnN0IGU9dGhpcy5nbCx0PXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uLG49ZS5jcmVhdGVRdWVyeSgpO3JldHVybiBlLmJlZ2luUXVlcnkodC5USU1FX0VMQVBTRURfRVhULG4pLG59dGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5cIil9ZW5kVGltZXIoKXtpZigyIT09dGhpcy52ZXJzaW9ufHwhdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiKTt7Y29uc3QgZT10aGlzLmdsLHQ9dGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb247ZS5lbmRRdWVyeSh0LlRJTUVfRUxBUFNFRF9FWFQpfX1pc1RpbWVyUmVzdWx0QXZhaWxhYmxlKGUpe2xldCB0PSExLG49ITE7aWYoMiE9PXRoaXMudmVyc2lvbnx8IXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKXRocm93IG5ldyBFcnJvcihcIldlYkdMMSBwcm9maWxpbmcgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIik7e2NvbnN0IHI9dGhpcy5nbCxvPXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uO3Q9ci5nZXRRdWVyeVBhcmFtZXRlcihlLHIuUVVFUllfUkVTVUxUX0FWQUlMQUJMRSksbj1yLmdldFBhcmFtZXRlcihvLkdQVV9ESVNKT0lOVF9FWFQpfXJldHVybiB0JiYhbn1nZXRUaW1lclJlc3VsdChlKXtsZXQgdD0wO2lmKDIhPT10aGlzLnZlcnNpb24pdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiKTt7Y29uc3Qgbj10aGlzLmdsO3Q9bi5nZXRRdWVyeVBhcmFtZXRlcihlLG4uUVVFUllfUkVTVUxUKSxuLmRlbGV0ZVF1ZXJ5KGUpfXJldHVybiB0LzFlNn1hc3luYyB3YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKGUpe3JldHVybiBhd2FpdCgwLHUucmVwZWF0ZWRUcnkpKCgoKT0+dGhpcy5pc1RpbWVyUmVzdWx0QXZhaWxhYmxlKGUpKSksdGhpcy5nZXRUaW1lclJlc3VsdChlKX1hc3luYyBjcmVhdGVBbmRXYWl0Rm9yRmVuY2UoKXtjb25zdCBlPXRoaXMuY3JlYXRlRmVuY2UodGhpcy5nbCk7cmV0dXJuIHRoaXMucG9sbEZlbmNlKGUpfWNyZWF0ZUZlbmNlKGUpe2xldCB0O2NvbnN0IG49ZSxyPW4uZmVuY2VTeW5jKG4uU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsMCk7cmV0dXJuIGUuZmx1c2goKSx0PW51bGw9PT1yPygpPT4hMDooKT0+e2NvbnN0IGU9bi5jbGllbnRXYWl0U3luYyhyLDAsMCk7cmV0dXJuIGU9PT1uLkFMUkVBRFlfU0lHTkFMRUR8fGU9PT1uLkNPTkRJVElPTl9TQVRJU0ZJRUR9LHtxdWVyeTpyLGlzRmVuY2VQYXNzZWQ6dH19YXN5bmMgcG9sbEZlbmNlKGUpe3JldHVybiBuZXcgUHJvbWlzZSgodD0+e3RoaXMuYWRkSXRlbVRvUG9sbCgoKCk9PmUuaXNGZW5jZVBhc3NlZCgpKSwoKCk9PnQoKSkpfSkpfXBvbGxJdGVtcygpe2NvbnN0IGU9bCh0aGlzLml0ZW1zVG9Qb2xsLm1hcCgoZT0+ZS5pc0RvbmVGbikpKTtmb3IobGV0IHQ9MDt0PD1lOysrdCl7Y29uc3R7cmVzb2x2ZUZuOmV9PXRoaXMuaXRlbXNUb1BvbGxbdF07ZSgpfXRoaXMuaXRlbXNUb1BvbGw9dGhpcy5pdGVtc1RvUG9sbC5zbGljZShlKzEpfWFzeW5jIGFkZEl0ZW1Ub1BvbGwoZSx0KXt0aGlzLml0ZW1zVG9Qb2xsLnB1c2goe2lzRG9uZUZuOmUscmVzb2x2ZUZuOnR9KSx0aGlzLml0ZW1zVG9Qb2xsLmxlbmd0aD4xfHxhd2FpdCgwLHUucmVwZWF0ZWRUcnkpKCgoKT0+KHRoaXMucG9sbEl0ZW1zKCksMD09PXRoaXMuaXRlbXNUb1BvbGwubGVuZ3RoKSkpfX19LDY0OTY6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuRXhlY3V0aW9uUGxhbj12b2lkIDA7Y29uc3Qgcj1uKDEzMTUpO2NsYXNzIG97Y29uc3RydWN0b3IoZSx0KXt0aGlzLm9wPWUsdGhpcy5ub2RlPXR9fXQuRXhlY3V0aW9uUGxhbj1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbil7dGhpcy5ncmFwaD1lLHRoaXMucHJvZmlsZXI9bix0aGlzLmluaXRpYWxpemUodCl9aW5pdGlhbGl6ZShlKXt0aGlzLnByb2ZpbGVyLmV2ZW50KFwic2Vzc2lvblwiLFwiRXhlY3V0aW9uUGxhbi5pbml0aWFsaXplXCIsKCgpPT57Y29uc3QgdD10aGlzLmdyYXBoLmdldE5vZGVzKCk7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2l6ZSBvZiBub2RlcyBhbmQgT1BzIGRvIG5vdCBtYXRjaC5cIik7dGhpcy5fb3BzPWUubWFwKCgoZSxuKT0+bmV3IG8oZSx0W25dKSkpLHRoaXMucmVzZXQoKSx0aGlzLl9zdGFydGVyPVtdLHRoaXMuX29wcy5mb3JFYWNoKCgoZSx0KT0+e2xldCBuPSEwO2Zvcihjb25zdCB0IG9mIGUubm9kZS5pbnB1dHMpaWYoIXRoaXMuX3ZhbHVlc1t0XSYmLTE9PT10aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpLmluZGV4T2YodCkpe249ITE7YnJlYWt9biYmdGhpcy5fc3RhcnRlci5wdXNoKHQpfSkpfSkpfXJlc2V0KCl7dGhpcy5fdmFsdWVzPXRoaXMuZ3JhcGguZ2V0VmFsdWVzKCkubWFwKChlPT5lLnRlbnNvcikpfWFzeW5jIGV4ZWN1dGUoZSx0KXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIkV4ZWN1dGlvblBsYW4uZXhlY3V0ZVwiLChhc3luYygpPT57dGhpcy5yZXNldCgpO2NvbnN0IG49ZS5jcmVhdGVJbmZlcmVuY2VIYW5kbGVyKCksbz10aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpO2lmKHQubGVuZ3RoIT09by5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBudW1iZXIgb2YgaW5wdXQgdGVuc29ycyBkb24ndCBtYXRjaCB0aGUgbnVtYmVyIG9mIGlucHV0cyB0byB0aGUgbW9kZWw6IGFjdHVhbDogJHt0Lmxlbmd0aH0gZXhwZWN0ZWQ6ICR7by5sZW5ndGh9YCk7dC5mb3JFYWNoKCgoZSx0KT0+e2NvbnN0IG49b1t0XTt0aGlzLl92YWx1ZXNbbl09ZX0pKTtjb25zdCBpPXRoaXMuX3N0YXJ0ZXIuc2xpY2UoMCksYT10aGlzLmdyYXBoLmdldFZhbHVlcygpLHM9dGhpcy5ncmFwaC5nZXROb2RlcygpO2xldCB1PTA7Zm9yKDt1PGkubGVuZ3RoOyl7Y29uc3QgZT1pW3UrK10sdD10aGlzLl9vcHNbZV0sbz10Lm5vZGUuaW5wdXRzLm1hcCgoZT0+dGhpcy5fdmFsdWVzW2VdKSk7aWYoLTEhPT1vLmluZGV4T2Yodm9pZCAwKSl0aHJvdyBuZXcgRXJyb3IoYHVucmVzb2x2ZWQgaW5wdXQgZGV0ZWN0ZWQ6IG9wOiAke3Qubm9kZX1gKTtjb25zdCBsPW87ci5Mb2dnZXIudmVyYm9zZShcIkV4ZWNQbGFuXCIsYFJ1bmluZyBvcDoke3Qubm9kZS5uYW1lfSAoJHtsLm1hcCgoKGUsbik9PmAnJHt0Lm5vZGUuaW5wdXRzW25dfSc6ICR7ZS50eXBlfVske2UuZGltcy5qb2luKFwiLFwiKX1dYCkpLmpvaW4oXCIsIFwiKX0pYCk7Y29uc3QgYz1hd2FpdCB0aGlzLnByb2ZpbGVyLmV2ZW50KFwibm9kZVwiLHQubm9kZS5uYW1lLChhc3luYygpPT50Lm9wLmltcGwobixsLHQub3AuY29udGV4dCkpKTtpZihjLmxlbmd0aCE9PXQubm9kZS5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgc2l6ZSBvZiBvdXRwdXQgZG9lcyBub3QgbWF0Y2ggbW9kZWwgZGVmaW5pdGlvbi5cIik7Yy5mb3JFYWNoKCgoZSxuKT0+e2NvbnN0IHI9dC5ub2RlLm91dHB1dHNbbl07aWYodGhpcy5fdmFsdWVzW3JdKXRocm93IG5ldyBFcnJvcihgb3V0cHV0IFske3J9XSBhbHJlYWR5IGhhcyB2YWx1ZTogb3A6JHt0Lm5vZGUubmFtZX1gKTt0aGlzLl92YWx1ZXNbcl09ZX0pKTtjb25zdCBwPW5ldyBTZXQ7Yy5mb3JFYWNoKCgoZSxuKT0+e2NvbnN0IHI9dC5ub2RlLm91dHB1dHNbbl07Zm9yKGNvbnN0IGUgb2YgYVtyXS50byl7Y29uc3QgdD1zW2VdO2xldCBuPSEwO2Zvcihjb25zdCBlIG9mIHQuaW5wdXRzKWlmKCF0aGlzLl92YWx1ZXNbZV0pe249ITE7YnJlYWt9biYmcC5hZGQoZSl9fSkpLGkucHVzaCguLi5wKX1jb25zdCBsPVtdO2ZvcihsZXQgZT0wO2U8dGhpcy5ncmFwaC5nZXRPdXRwdXRJbmRpY2VzKCkubGVuZ3RoO2UrKyl7Y29uc3QgdD10aGlzLmdyYXBoLmdldE91dHB1dEluZGljZXMoKVtlXSxuPXRoaXMuX3ZhbHVlc1t0XTtpZih2b2lkIDA9PT1uKXRocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgb3V0cHV0IFske3R9XSBkb2VzIG5vdCBoYXZlIHZhbHVlYCk7MD09PXQ/YXdhaXQgbi5nZXREYXRhKCk6bi5kYXRhLGwucHVzaChuKX1yZXR1cm4gci5Mb2dnZXIudmVyYm9zZShcIkV4ZWNQbGFuXCIsXCJkaXNwb3Npbmcgb2YgaW5mZXJlbmNlSGFuZGxlclwiKSxuLmRpc3Bvc2UoKSxsfSkpfX19LDQ2NjI6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuR3JhcGg9dm9pZCAwO2NvbnN0IHI9bigxNDQ2KSxvPW4oNjg3NCksaT1uKDEyODcpLGE9big5MjQwKSxzPW4oNzI3Myk7dmFyIHU9aS5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO3QuR3JhcGg9e2Zyb206KGUsdCk9Pm5ldyBwKGUsdCl9O2NsYXNzIGx7Y29uc3RydWN0b3IoZSl7dGhpcy5fZnJvbT12b2lkIDAsdGhpcy5fdG89W10sdGhpcy50ZW5zb3I9dm9pZCAwLHRoaXMudHlwZT12b2lkIDAsZSYmKHRoaXMudHlwZT1zLlByb3RvVXRpbC50ZW5zb3JWYWx1ZVR5cGVGcm9tUHJvdG8oZS50eXBlLnRlbnNvclR5cGUpKX1nZXQgZnJvbSgpe3JldHVybiB0aGlzLl9mcm9tfWdldCB0bygpe3JldHVybiB0aGlzLl90b319Y2xhc3MgY3tjb25zdHJ1Y3RvcihlLHQpe2UgaW5zdGFuY2VvZiByLm9ubnguTm9kZVByb3RvPyh0aGlzLm5hbWU9ZS5uYW1lLHRoaXMub3BUeXBlPWUub3BUeXBlLHRoaXMuYXR0cmlidXRlcz1uZXcgby5BdHRyaWJ1dGUoZS5hdHRyaWJ1dGUpKTplIGluc3RhbmNlb2YgdS5Ob2RlJiYodGhpcy5uYW1lPW51bGwhPXQ/dDplLm5hbWUoKSx0aGlzLm9wVHlwZT1lLm9wVHlwZSgpLHRoaXMuYXR0cmlidXRlcz1uZXcgby5BdHRyaWJ1dGUocy5Qcm90b1V0aWwudGVuc29yQXR0cmlidXRlc0Zyb21PUlRGb3JtYXQoZSkpKSx0aGlzLmlucHV0cz1bXSx0aGlzLm91dHB1dHM9W10sdGhpcy5leGVjdXRlTm9kZT0hMH19Y2xhc3MgcHtjb25zdHJ1Y3RvcihlLHQpe2lmKCFlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJncmFwaCBpcyBlbXB0eVwiKTt0aGlzLmJ1aWxkR3JhcGgoZSksdGhpcy50cmFuc2Zvcm1HcmFwaCh0KSx0aGlzLmNoZWNrSXNBY3ljbGljKCl9Z2V0SW5wdXRJbmRpY2VzKCl7cmV0dXJuIHRoaXMuX2FsbElucHV0SW5kaWNlc31nZXRJbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX2FsbElucHV0TmFtZXN9Z2V0T3V0cHV0SW5kaWNlcygpe3JldHVybiB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzfWdldE91dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX2FsbE91dHB1dE5hbWVzfWdldFZhbHVlcygpe3JldHVybiB0aGlzLl9hbGxEYXRhfWdldE5vZGVzKCl7cmV0dXJuIHRoaXMuX25vZGVzfWJ1aWxkR3JhcGgoZSl7aWYoZSBpbnN0YW5jZW9mIHIub25ueC5HcmFwaFByb3RvKXRoaXMuYnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KGUpO2Vsc2V7aWYoIShlIGluc3RhbmNlb2YgdS5HcmFwaCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdyYXBoIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cIik7dGhpcy5idWlsZEdyYXBoRnJvbU9ydEZvcm1hdChlKX19YnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KGUpe2NvbnN0IHQ9bmV3IE1hcDt0aGlzLl9hbGxEYXRhPVtdLHRoaXMuX2FsbElucHV0SW5kaWNlcz1bXSx0aGlzLl9hbGxJbnB1dE5hbWVzPVtdLHRoaXMuX2FsbE91dHB1dEluZGljZXM9W10sdGhpcy5fYWxsT3V0cHV0TmFtZXM9W10sdGhpcy5fbm9kZXM9W107Y29uc3Qgbj1uZXcgTWFwO2lmKCFlLmlucHV0KXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGlucHV0XCIpO2NvbnN0IHI9W107Zm9yKGNvbnN0IG4gb2YgZS5pbnB1dCl7aWYodC5oYXMobi5uYW1lKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgaW5wdXQgbmFtZTogJHtuLm5hbWV9YCk7Y29uc3QgZT10aGlzLl9hbGxEYXRhLnB1c2gobmV3IGwobikpLTE7dC5zZXQobi5uYW1lLGUpLHIucHVzaChuLm5hbWUpfWlmKCFlLmluaXRpYWxpemVyKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGluaXRpYWxpemVyXCIpO2Zvcihjb25zdCBuIG9mIGUuaW5pdGlhbGl6ZXIpe2xldCBlPXQuZ2V0KG4ubmFtZSk7aWYodm9pZCAwPT09ZSl7Y29uc3Qgcj1uZXcgbDtyLnR5cGU9e3NoYXBlOntkaW1zOnMuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tUHJvdG8obi5kaW1zKX0sdGVuc29yVHlwZTpzLlByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhuLmRhdGFUeXBlKX0sZT10aGlzLl9hbGxEYXRhLnB1c2gociktMSx0LnNldChuLm5hbWUsZSl9dGhpcy5fYWxsRGF0YVtlXS5fZnJvbT0tMSx0aGlzLl9hbGxEYXRhW2VdLnRlbnNvcj1hLlRlbnNvci5mcm9tUHJvdG8obil9Zm9yKGxldCBlPTA7ZTx0aGlzLl9hbGxEYXRhLmxlbmd0aDtlKyspdGhpcy5fYWxsRGF0YVtlXS50ZW5zb3J8fCh0aGlzLl9hbGxJbnB1dEluZGljZXMucHVzaChlKSx0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2gocltlXSkpO2lmKCFlLm91dHB1dCl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBvdXRwdXRcIik7Zm9yKGNvbnN0IG4gb2YgZS5vdXRwdXQpe2lmKHQuaGFzKG4ubmFtZSkpdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG91dHB1dCBuYW1lOiAke24ubmFtZX1gKTtjb25zdCBlPXRoaXMuX2FsbERhdGEucHVzaChuZXcgbChuKSktMTt0LnNldChuLm5hbWUsZSksdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5wdXNoKGUpLHRoaXMuX2FsbE91dHB1dE5hbWVzLnB1c2gobi5uYW1lKX1pZighZS5ub2RlKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGVcIik7Zm9yKGNvbnN0IHQgb2YgZS5ub2RlKXtpZighdC5uYW1lKWZvcihsZXQgZT0wOztlKyspe2NvbnN0IHI9YHVubmFtZWRfJHt0Lm9wVHlwZX1fJHtlfWA7aWYoIW4uaGFzKHIpKXt0Lm5hbWU9cjticmVha319aWYobi5oYXModC5uYW1lKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgbm9kZSBuYW1lOiAke3QubmFtZX1gKTtjb25zdCBlPXRoaXMuX25vZGVzLnB1c2gobmV3IGModCkpLTE7bi5zZXQodC5uYW1lLGUpfWZvcihsZXQgbj0wO248dGhpcy5fbm9kZXMubGVuZ3RoO24rKyl7Y29uc3Qgcj10aGlzLl9ub2Rlc1tuXSxvPWUubm9kZVtuXTtpZighby5vdXRwdXQpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIG91dHB1dCBmb3Igbm9kZTogJHtvLm5hbWV9YCk7Zm9yKGNvbnN0IGUgb2Ygby5vdXRwdXQpe2xldCBpPXQuZ2V0KGUpO2lmKHZvaWQgMD09PWkmJihpPXRoaXMuX2FsbERhdGEucHVzaChuZXcgbCktMSx0LnNldChlLGkpKSxyLm91dHB1dHMucHVzaChpKSx2b2lkIDAhPT10aGlzLl9hbGxEYXRhW2ldLl9mcm9tKXRocm93IG5ldyBFcnJvcihgbXVsdGlwbGUgbm9kZXMgb3V0cHV0IHRvIG9uZSBkYXRhIHZhbHVlOiAke2l9YCk7aWYodGhpcy5fYWxsRGF0YVtpXS5fZnJvbT1uLFwiQ29uc3RhbnRcIj09PW8ub3BUeXBlKXtpZighby5hdHRyaWJ1dGV8fDEhPT1vLmF0dHJpYnV0ZS5sZW5ndGh8fCFvLmF0dHJpYnV0ZVswXS50KXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgYXR0cmlidXRlcyBvciBtaXNzaW5nIHRlbnNvciB2YWx1ZSBpbiBhdHRyaWJ1dGVzIGZvciB0aGlzIENvbnN0YW50IG9wZXJhdG9yXCIpO2lmKCFvLm91dHB1dHx8MSE9PW8ub3V0cHV0Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIG91dHB1dCBvciBpbmNvcnJlY3QgbnVtYmVyIG9mIG91dHB1dHMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3JcIik7ci5vdXRwdXRzLnBvcCgpLHIuZXhlY3V0ZU5vZGU9ITEsdGhpcy5fYWxsRGF0YVtpXS5fZnJvbT0tMSx0aGlzLl9hbGxEYXRhW2ldLnRlbnNvcj1hLlRlbnNvci5mcm9tUHJvdG8oby5hdHRyaWJ1dGVbMF0udCl9fX1mb3IobGV0IG49MDtuPHRoaXMuX25vZGVzLmxlbmd0aDtuKyspe2NvbnN0IHI9dGhpcy5fbm9kZXNbbl0sbz1lLm5vZGVbbl07aWYoIW8uaW5wdXQpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGlucHV0IGZvciBub2RlOiAke28ubmFtZX1gKTtmb3IoY29uc3QgZSBvZiBvLmlucHV0KXtjb25zdCBpPXQuZ2V0KGUpO2lmKHZvaWQgMD09PWkpe2lmKFwiXCI9PT1lJiYzPT09by5pbnB1dC5sZW5ndGgmJlwiUmVzaXplXCI9PT1vLm9wVHlwZSljb250aW51ZTt0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBpbnB1dCAnJHtlfScgZm9yIG5vZGU6ICR7by5uYW1lfWApfXIuaW5wdXRzLnB1c2goaSksdGhpcy5fYWxsRGF0YVtpXS5fdG8ucHVzaChuKX19cmV0dXJuITB9YnVpbGRHcmFwaEZyb21PcnRGb3JtYXQoZSl7dmFyIHQsbixyO2NvbnN0IG89bmV3IE1hcDt0aGlzLl9hbGxEYXRhPVtdLHRoaXMuX2FsbElucHV0SW5kaWNlcz1bXSx0aGlzLl9hbGxJbnB1dE5hbWVzPVtdLHRoaXMuX2FsbE91dHB1dEluZGljZXM9W10sdGhpcy5fYWxsT3V0cHV0TmFtZXM9W10sdGhpcy5fbm9kZXM9W107Y29uc3QgaT1uZXcgTWFwLHA9W107Zm9yKGxldCBpPTA7aTxlLmlucHV0c0xlbmd0aCgpO2krKyl7Y29uc3QgYT1lLmlucHV0cyhpKTtpZihvLmhhcyhhKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgaW5wdXQgbmFtZTogJHthfWApO2ZvcihsZXQgaT0wO2k8ZS5ub2RlQXJnc0xlbmd0aCgpO2krKylpZigobnVsbD09PSh0PWUubm9kZUFyZ3MoaSkpfHx2b2lkIDA9PT10P3ZvaWQgMDp0Lm5hbWUoKSk9PT1hKXtjb25zdCB0PW5ldyBsO2lmKChudWxsPT09KHI9bnVsbD09PShuPWUubm9kZUFyZ3MoaSkpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLnR5cGUoKSl8fHZvaWQgMD09PXI/dm9pZCAwOnIudmFsdWVUeXBlKCkpIT09dS5UeXBlSW5mb1ZhbHVlLnRlbnNvcl90eXBlKXRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgdHlwZSBmb3IgdGhlIG5vZGVBcmcuXCIpO2NvbnN0IGM9ZS5ub2RlQXJncyhpKS50eXBlKCkudmFsdWUobmV3IHUuVGVuc29yVHlwZUFuZFNoYXBlKSxkPXMuUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGMuZWxlbVR5cGUoKSksZj1jLnNoYXBlKCksaD1bXTtmb3IobGV0IGU9MDtlPGYuZGltTGVuZ3RoKCk7ZSsrKWgucHVzaChzLkxvbmdVdGlsLmxvbmdUb051bWJlcihmLmRpbShlKS52YWx1ZSgpLmRpbVZhbHVlKCkpKTt0LnR5cGU9e3NoYXBlOntkaW1zOmh9LHRlbnNvclR5cGU6ZH07Y29uc3QgZz10aGlzLl9hbGxEYXRhLnB1c2godCktMTtvLnNldChhLGcpLHAucHVzaChhKX19Zm9yKGxldCB0PTA7dDxlLmluaXRpYWxpemVyc0xlbmd0aCgpO3QrKyl7Y29uc3Qgbj1lLmluaXRpYWxpemVycyh0KTtsZXQgcj1vLmdldChuLm5hbWUoKSk7aWYodm9pZCAwPT09cil7Y29uc3QgZT1uZXcgbCx0PXMuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tT1JURm9ybWF0KG4pLGk9cy5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8obi5kYXRhVHlwZSgpKTtlLnR5cGU9e3NoYXBlOntkaW1zOnR9LHRlbnNvclR5cGU6aX0scj10aGlzLl9hbGxEYXRhLnB1c2goZSktMSxvLnNldChuLm5hbWUoKSxyKX10aGlzLl9hbGxEYXRhW3JdLl9mcm9tPS0xLHRoaXMuX2FsbERhdGFbcl0udGVuc29yPWEuVGVuc29yLmZyb21PcnRUZW5zb3Iobil9Zm9yKGxldCBlPTA7ZTx0aGlzLl9hbGxEYXRhLmxlbmd0aDtlKyspdGhpcy5fYWxsRGF0YVtlXS50ZW5zb3J8fCh0aGlzLl9hbGxJbnB1dEluZGljZXMucHVzaChlKSx0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2gocFtlXSkpO2ZvcihsZXQgdD0wO3Q8ZS5vdXRwdXRzTGVuZ3RoKCk7dCsrKXtjb25zdCBuPWUub3V0cHV0cyh0KTtpZihvLmhhcyhuKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgb3V0cHV0IG5hbWU6ICR7bn1gKTtjb25zdCByPXRoaXMuX2FsbERhdGEucHVzaChuZXcgbCktMTtvLnNldChuLHIpLHRoaXMuX2FsbE91dHB1dEluZGljZXMucHVzaChyKSx0aGlzLl9hbGxPdXRwdXROYW1lcy5wdXNoKG4pfWlmKCFlLm5vZGVzKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGVcIik7Zm9yKGxldCB0PTA7dDxlLm5vZGVzTGVuZ3RoKCk7dCsrKXtjb25zdCBuPWUubm9kZXModCk7bGV0IHI9bi5uYW1lKCk7aWYoIXIpZm9yKGxldCBlPTA7cj1gdW5uYW1lZF8ke24ub3BUeXBlKCl9XyR7ZX1gLGkuaGFzKHIpO2UrKyk7aWYoaS5oYXMocikpdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG5vZGUgbmFtZTogJHtyfWApO2NvbnN0IG89dGhpcy5fbm9kZXMucHVzaChuZXcgYyhuLHIpKS0xO2kuc2V0KHIsbyl9Zm9yKGxldCB0PTA7dDx0aGlzLl9ub2Rlcy5sZW5ndGg7dCsrKXtjb25zdCBuPXRoaXMuX25vZGVzW3RdLHI9ZS5ub2Rlcyh0KTtpZihudWxsPT1yKXRocm93IG5ldyBFcnJvcihgTm8gbm9kZSBleGlzdHMgYXQgaW5kZXggJHt0fWApO2lmKDA9PT0obnVsbD09cj92b2lkIDA6ci5vdXRwdXRzTGVuZ3RoKCkpKXRocm93IG5ldyBFcnJvcihgbWlzc2luZyBvdXRwdXQgZm9yIG5vZGU6ICR7ci5uYW1lfWApO2ZvcihsZXQgZT0wO2U8KG51bGw9PXI/dm9pZCAwOnIub3V0cHV0c0xlbmd0aCgpKTtlKyspe2NvbnN0IGk9bnVsbD09cj92b2lkIDA6ci5vdXRwdXRzKGUpO2xldCBzPW8uZ2V0KGkpO2lmKHZvaWQgMD09PXMmJihzPXRoaXMuX2FsbERhdGEucHVzaChuZXcgbCktMSxvLnNldChpLHMpKSxuLm91dHB1dHMucHVzaChzKSx2b2lkIDAhPT10aGlzLl9hbGxEYXRhW3NdLl9mcm9tKXRocm93IG5ldyBFcnJvcihgbXVsdGlwbGUgbm9kZXMgb3V0cHV0IHRvIG9uZSBkYXRhIHZhbHVlOiAke3N9YCk7aWYodGhpcy5fYWxsRGF0YVtzXS5fZnJvbT10LFwiQ29uc3RhbnRcIj09PXIub3BUeXBlKCkpe2lmKDEhPT1yLmF0dHJpYnV0ZXNMZW5ndGgoKXx8IXIuYXR0cmlidXRlcygwKS50KCkpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBhdHRyaWJ1dGVzIG9yIG1pc3NpbmcgdGVuc29yIHZhbHVlIGluIGF0dHJpYnV0ZXMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3JcIik7aWYoMSE9PXIub3V0cHV0c0xlbmd0aCgpKXRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgb3V0cHV0IG9yIGluY29ycmVjdCBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvclwiKTtuLm91dHB1dHMucG9wKCksbi5leGVjdXRlTm9kZT0hMSx0aGlzLl9hbGxEYXRhW3NdLl9mcm9tPS0xLHRoaXMuX2FsbERhdGFbc10udGVuc29yPWEuVGVuc29yLmZyb21PcnRUZW5zb3Ioci5hdHRyaWJ1dGVzKDApLnQoKSl9fX1mb3IobGV0IHQ9MDt0PHRoaXMuX25vZGVzLmxlbmd0aDt0Kyspe2NvbnN0IG49dGhpcy5fbm9kZXNbdF0scj1lLm5vZGVzKHQpO2lmKDA9PT1yLmlucHV0c0xlbmd0aCgpKXRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCBmb3Igbm9kZTogJHtyLm5hbWV9YCk7Zm9yKGxldCBlPTA7ZTxyLmlucHV0c0xlbmd0aCgpO2UrKyl7Y29uc3QgaT1yLmlucHV0cyhlKSxhPW8uZ2V0KGkpO2lmKHZvaWQgMD09PWEpdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgaW5wdXQgJyR7aX0nIGZvciBub2RlOiAke3IubmFtZSgpfWApO24uaW5wdXRzLnB1c2goYSksdGhpcy5fYWxsRGF0YVthXS5fdG8ucHVzaCh0KX19fWNoZWNrSXNBY3ljbGljKCl7Y29uc3QgZT1uZXcgU2V0O3RoaXMuX2FsbElucHV0SW5kaWNlcy5mb3JFYWNoKCh0PT57dGhpcy5fYWxsRGF0YVt0XS5fdG8uZm9yRWFjaCgodD0+e2UuYWRkKHQpfSkpfSkpO2NvbnN0IHQ9QXJyYXkuZnJvbShlKSxuPW5ldyBBcnJheSh0aGlzLl9ub2Rlcy5sZW5ndGgpLmZpbGwoXCJ3aGl0ZVwiKTtmb3IoO3QubGVuZ3RoPjA7KXtjb25zdCBlPXQucG9wKCk7XCJncmF5XCI9PT1uW2VdP25bZV09XCJibGFja1wiOih0LnB1c2goZSksbltlXT1cImdyYXlcIix0aGlzLl9ub2Rlc1tlXS5vdXRwdXRzLmZvckVhY2goKHI9Pntjb25zdCBvPXRoaXMuX2FsbERhdGFbcl07aWYodm9pZCAwIT09by50ZW5zb3IpdGhyb3cgbmV3IEVycm9yKFwibm9kZSBvdXRwdXRzIHNob3VsZCBub3QgYmUgaW5pdGlhbGl6ZWRcIik7aWYoby5fZnJvbSE9PWUpdGhyb3cgbmV3IEVycm9yKFwiZnJvbSBwcm9wZXJ0eSBvZiB0aGUgVmFsdWUgb2JqZWN0IGRvZXNuJ3QgbWF0Y2ggaW5kZXggb2YgTm9kZSBiZWluZyBwcm9jZXNzZWRcIik7by5fdG8uZm9yRWFjaCgoZT0+e2lmKFwiZ3JheVwiPT09bltlXSl0aHJvdyBuZXcgRXJyb3IoXCJtb2RlbCBncmFwaCBpcyBjeWNsaWNcIik7XCJ3aGl0ZVwiPT09bltlXSYmdC5wdXNoKGUpfSkpfSkpKX19dHJhbnNmb3JtR3JhcGgoZSl7dGhpcy5yZW1vdmVBbGxJZGVudGl0eU5vZGVzKCksdGhpcy5yZW1vdmVBbGxEcm9wb3V0Tm9kZXMoKSx0aGlzLmZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCksZSYmZS50cmFuc2Zvcm1HcmFwaCh0aGlzKSx0aGlzLmZpbmFsaXplR3JhcGgoKX1maW5hbGl6ZUdyYXBoKCl7bGV0IGU9MDtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9ub2Rlcy5sZW5ndGgsMCk7bGV0IG49MDtmb3IobGV0IGU9MDtlPHRoaXMuX25vZGVzLmxlbmd0aDtlKyspdFtlXT1uLHRoaXMuX25vZGVzW2VdLmV4ZWN1dGVOb2RlPyhuIT09ZSYmKHRoaXMuX25vZGVzW25dPXRoaXMuX25vZGVzW2VdKSxuKyspOnRoaXMuX25vZGVzW2VdLm91dHB1dHMuZm9yRWFjaCgoZT0+e3RoaXMuX2FsbERhdGFbZV0uX2Zyb209LTJ9KSk7dGhpcy5fbm9kZXMuc3BsaWNlKG4sdGhpcy5fbm9kZXMubGVuZ3RoLW4pO2ZvcihsZXQgZT0wO2U8dGhpcy5fYWxsRGF0YS5sZW5ndGg7ZSsrKXtjb25zdCBuPXRoaXMuX2FsbERhdGFbZV07dm9pZCAwIT09bi5fZnJvbSYmLTEhPT1uLl9mcm9tJiYtMiE9PW4uX2Zyb20mJihuLl9mcm9tPXRbbi5fZnJvbV0pO2ZvcihsZXQgZT0wO2U8bi5fdG8ubGVuZ3RoO2UrKyl7aWYoIShuLl90b1tlXT49MCkpdGhyb3cgbmV3IEVycm9yKFwiVHJ5aW5nIHRvIHVwZGF0ZSBhIHJlbW92ZWQgbm9kZVwiKTtuLl90b1tlXT10W24uX3RvW2VdXX19ZT0wO2ZvcihsZXQgdD0wO3Q8dGhpcy5fYWxsRGF0YS5sZW5ndGg7dCsrKWlmKC0yIT09dGhpcy5fYWxsRGF0YVt0XS5mcm9tfHwtMSE9PXRoaXMuX2FsbE91dHB1dEluZGljZXMuaW5kZXhPZih0K2UpKXtpZihlPjApe2xldCBuPS0xO3ZvaWQgMCE9PXRoaXMuX2FsbERhdGFbdF0uZnJvbSYmLTEhPT10aGlzLl9hbGxEYXRhW3RdLmZyb20/KG49dGhpcy5fbm9kZXNbdGhpcy5fYWxsRGF0YVt0XS5mcm9tXS5vdXRwdXRzLmluZGV4T2YodCtlKSwtMSE9PW4mJih0aGlzLl9ub2Rlc1t0aGlzLl9hbGxEYXRhW3RdLmZyb21dLm91dHB1dHNbbl09dCkpOihuPXRoaXMuX2FsbElucHV0SW5kaWNlcy5pbmRleE9mKHQrZSksLTEhPT1uJiYodGhpcy5fYWxsSW5wdXRJbmRpY2VzW25dPXQpKSx0aGlzLl9hbGxEYXRhW3RdLnRvLmZvckVhY2goKHI9PntuPXRoaXMuX25vZGVzW3JdLmlucHV0cy5pbmRleE9mKHQrZSksLTEhPT1uJiYodGhpcy5fbm9kZXNbcl0uaW5wdXRzW25dPXQpfSkpLDA9PT10aGlzLl9hbGxEYXRhW3RdLnRvLmxlbmd0aCYmKG49dGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5pbmRleE9mKHQrZSksLTEhPT1uJiYodGhpcy5fYWxsT3V0cHV0SW5kaWNlc1tuXT10KSl9fWVsc2UgZSsrLHRoaXMuX2FsbERhdGEuc3BsaWNlKHQsMSksdC0tfWRlbGV0ZU5vZGUoZSl7Y29uc3QgdD10aGlzLl9ub2Rlc1tlXTtpZih0Lm91dHB1dHMubGVuZ3RoPjEpZm9yKGxldCBlPTE7ZTx0Lm91dHB1dHMubGVuZ3RoO2UrKylpZih0aGlzLl9hbGxEYXRhW3Qub3V0cHV0c1tlXV0udG8ubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBkZWxldGlvbiB3aXRoIG1vcmUgdGhhbiBvbmUgb3V0cHV0IGNvbm5lY3RlZCB0byBvdGhlciBub2RlcyBpcyBub3Qgc3VwcG9ydGVkLiBcIik7dC5leGVjdXRlTm9kZT0hMTtjb25zdCBuPXQuaW5wdXRzWzBdLHI9dC5vdXRwdXRzWzBdLG89dGhpcy5fYWxsRGF0YVtyXS50bztmb3IobGV0IG49MDtuPHQuaW5wdXRzLmxlbmd0aDtuKyspe2NvbnN0IHI9dGhpcy5fYWxsRGF0YVt0LmlucHV0c1tuXV0udG8uaW5kZXhPZihlKTtpZigtMT09PXIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIFZhbHVlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIGN1cnJlbnQgTm9kZSBpbiBpdCdzICd0bycgcHJvcGVydHkgXCIpO3RoaXMuX2FsbERhdGFbdC5pbnB1dHNbbl1dLnRvLnNwbGljZShyLDEpfXRoaXMuX2FsbERhdGFbcl0uX3RvPVtdO2NvbnN0IGk9dGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5pbmRleE9mKHIpO2lmKC0xIT09aSYmKHRoaXMuX2FsbE91dHB1dEluZGljZXNbaV09biksbyYmby5sZW5ndGg+MClmb3IoY29uc3QgZSBvZiBvKXtjb25zdCB0PXRoaXMuX25vZGVzW2VdLmlucHV0cy5pbmRleE9mKHIpO2lmKC0xPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgTm9kZSBvYmplY3QgZG9lc24ndCBoYXZlIHRoZSBvdXRwdXQgVmFsdWUgaW4gaXQncyAnaW5wdXRzJyBwcm9wZXJ0eSBcIik7dGhpcy5fbm9kZXNbZV0uaW5wdXRzW3RdPW4sdGhpcy5fYWxsRGF0YVtuXS50by5wdXNoKGUpfX1yZW1vdmVBbGxEcm9wb3V0Tm9kZXMoKXtsZXQgZT0wO2Zvcihjb25zdCB0IG9mIHRoaXMuX25vZGVzKXtpZihcIkRyb3BvdXRcIj09PXQub3BUeXBlKXtpZigxIT09dC5pbnB1dHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkRyb3BvdXQgbm9kZXMgc2hvdWxkIG9ubHkgY29udGFpbiBvbmUgaW5wdXQuIFwiKTtpZigxIT09dC5vdXRwdXRzLmxlbmd0aCYmMiE9PXQub3V0cHV0cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRHJvcG91dCBub2RlcyBzaG91bGQgY29udGFpbiBlaXRoZXIgMSBvciAyIG91dHB1dChzKVwiKTtpZigyPT09dC5vdXRwdXRzLmxlbmd0aCYmMCE9PXRoaXMuX2FsbERhdGFbdC5vdXRwdXRzWzFdXS5fdG8ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkRyb3BvdXQgbm9kZXMncyBzZWNvbmQgb3V0cHV0IHNob3VsZCBub3QgYmUgcmVmZXJlbmNlZCBieSBvdGhlciBub2Rlc1wiKTt0aGlzLmRlbGV0ZU5vZGUoZSl9ZSsrfX1yZW1vdmVBbGxJZGVudGl0eU5vZGVzKCl7bGV0IGU9MDtmb3IoY29uc3QgdCBvZiB0aGlzLl9ub2RlcylcIklkZW50aXR5XCI9PT10Lm9wVHlwZSYmdGhpcy5kZWxldGVOb2RlKGUpLGUrK31pc0FjdGl2YXRpb24oZSl7c3dpdGNoKGUub3BUeXBlKXtjYXNlXCJSZWx1XCI6Y2FzZVwiU2lnbW9pZFwiOmNhc2VcIkNsaXBcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdXNlQ29udkFjdGl2YXRpb25Ob2Rlcygpe2Zvcihjb25zdCBlIG9mIHRoaXMuX25vZGVzKWlmKFwiQ29udlwiPT09ZS5vcFR5cGUpe2NvbnN0IHQ9dGhpcy5fYWxsRGF0YVtlLm91dHB1dHNbMF1dLl90bztpZigxPT09dC5sZW5ndGgmJnRoaXMuaXNBY3RpdmF0aW9uKHRoaXMuX25vZGVzW3RbMF1dKSl7Y29uc3Qgbj10aGlzLl9ub2Rlc1t0WzBdXTtpZihcIkNsaXBcIj09PW4ub3BUeXBlKWlmKDE9PT1uLmlucHV0cy5sZW5ndGgpdHJ5e2UuYXR0cmlidXRlcy5zZXQoXCJhY3RpdmF0aW9uX3BhcmFtc1wiLFwiZmxvYXRzXCIsW24uYXR0cmlidXRlcy5nZXRGbG9hdChcIm1pblwiKSxuLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJtYXhcIildKX1jYXRjaCh0KXtlLmF0dHJpYnV0ZXMuc2V0KFwiYWN0aXZhdGlvbl9wYXJhbXNcIixcImZsb2F0c1wiLFtzLk1JTl9DTElQLHMuTUFYX0NMSVBdKX1lbHNle2lmKCEobi5pbnB1dHMubGVuZ3RoPj0zJiZ2b2lkIDAhPT10aGlzLl9hbGxEYXRhW24uaW5wdXRzWzFdXS50ZW5zb3ImJnZvaWQgMCE9PXRoaXMuX2FsbERhdGFbbi5pbnB1dHNbMl1dLnRlbnNvcikpY29udGludWU7ZS5hdHRyaWJ1dGVzLnNldChcImFjdGl2YXRpb25fcGFyYW1zXCIsXCJmbG9hdHNcIixbdGhpcy5fYWxsRGF0YVtuLmlucHV0c1sxXV0udGVuc29yLmZsb2F0RGF0YVswXSx0aGlzLl9hbGxEYXRhW24uaW5wdXRzWzJdXS50ZW5zb3IuZmxvYXREYXRhWzBdXSl9ZS5hdHRyaWJ1dGVzLnNldChcImFjdGl2YXRpb25cIixcInN0cmluZ1wiLG4ub3BUeXBlKSx0aGlzLmRlbGV0ZU5vZGUodFswXSl9fX19fSwxMzE1OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5ub3c9dC5Qcm9maWxlcj10LkxvZ2dlcj12b2lkIDA7Y29uc3Qgbj17dmVyYm9zZToxZTMsaW5mbzoyZTMsd2FybmluZzo0ZTMsZXJyb3I6NWUzLGZhdGFsOjZlM30scj17bm9uZTpuZXcgY2xhc3N7bG9nKGUsdCxuKXt9fSxjb25zb2xlOm5ldyBjbGFzc3tsb2coZSx0LG4pe2NvbnNvbGUubG9nKGAke3RoaXMuY29sb3IoZSl9ICR7bj9cIlx1MDAxYlszNW1cIituK1wiXHUwMDFiWzBtIFwiOlwiXCJ9JHt0fWApfWNvbG9yKGUpe3N3aXRjaChlKXtjYXNlXCJ2ZXJib3NlXCI6cmV0dXJuXCJcdTAwMWJbMzQ7NDBtdlx1MDAxYlswbVwiO2Nhc2VcImluZm9cIjpyZXR1cm5cIlx1MDAxYlszMm1pXHUwMDFiWzBtXCI7Y2FzZVwid2FybmluZ1wiOnJldHVyblwiXHUwMDFiWzMwOzQzbXdcdTAwMWJbMG1cIjtjYXNlXCJlcnJvclwiOnJldHVyblwiXHUwMDFiWzMxOzQwbWVcdTAwMWJbMG1cIjtjYXNlXCJmYXRhbFwiOnJldHVyblwiXHUwMDFiWzEwMW1mXHUwMDFiWzBtXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHNldmVyaXR5OiAke2V9YCl9fX19LG89e3Byb3ZpZGVyOlwiY29uc29sZVwiLG1pbmltYWxTZXZlcml0eTpcIndhcm5pbmdcIixsb2dEYXRlVGltZTohMCxsb2dTb3VyY2VMb2NhdGlvbjohMX07bGV0IGk9e1wiXCI6b307ZnVuY3Rpb24gYShlLHQsbixyKXtpZih2b2lkIDA9PT10KXJldHVybiBvPWUse3ZlcmJvc2U6YS52ZXJib3NlLmJpbmQobnVsbCxvKSxpbmZvOmEuaW5mby5iaW5kKG51bGwsbyksd2FybmluZzphLndhcm5pbmcuYmluZChudWxsLG8pLGVycm9yOmEuZXJyb3IuYmluZChudWxsLG8pLGZhdGFsOmEuZmF0YWwuYmluZChudWxsLG8pfTtpZih2b2lkIDA9PT1uKXMoZSx0KTtlbHNlIGlmKFwibnVtYmVyXCI9PXR5cGVvZiBuJiZ2b2lkIDA9PT1yKXMoZSx0KTtlbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBuJiZ2b2lkIDA9PT1yKXMoZSxuLDAsdCk7ZWxzZXtpZihcInN0cmluZ1wiIT10eXBlb2Ygbnx8XCJudW1iZXJcIiE9dHlwZW9mIHIpdGhyb3cgbmV3IFR5cGVFcnJvcihcImlucHV0IGlzIHZhbGlkXCIpO3MoZSxuLDAsdCl9dmFyIG99ZnVuY3Rpb24gcyhlLHQsbyxhKXtjb25zdCBzPWlbYXx8XCJcIl18fGlbXCJcIl07bltlXTxuW3MubWluaW1hbFNldmVyaXR5XXx8KHMubG9nRGF0ZVRpbWUmJih0PWAkeyhuZXcgRGF0ZSkudG9JU09TdHJpbmcoKX18JHt0fWApLHMubG9nU291cmNlTG9jYXRpb24scltzLnByb3ZpZGVyXS5sb2coZSx0LGEpKX0hZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlKXtpPXt9LG4oXCJcIixlfHx7fSl9ZnVuY3Rpb24gbihlLG4pe2lmKFwiKlwiPT09ZSl0KG4pO2Vsc2V7Y29uc3QgdD1pW2VdfHxvO2lbZV09e3Byb3ZpZGVyOm4ucHJvdmlkZXJ8fHQucHJvdmlkZXIsbWluaW1hbFNldmVyaXR5Om4ubWluaW1hbFNldmVyaXR5fHx0Lm1pbmltYWxTZXZlcml0eSxsb2dEYXRlVGltZTp2b2lkIDA9PT1uLmxvZ0RhdGVUaW1lP3QubG9nRGF0ZVRpbWU6bi5sb2dEYXRlVGltZSxsb2dTb3VyY2VMb2NhdGlvbjp2b2lkIDA9PT1uLmxvZ1NvdXJjZUxvY2F0aW9uP3QubG9nU291cmNlTG9jYXRpb246bi5sb2dTb3VyY2VMb2NhdGlvbn19fWUudmVyYm9zZT1mdW5jdGlvbih0LG4pe2UoXCJ2ZXJib3NlXCIsdCxuKX0sZS5pbmZvPWZ1bmN0aW9uKHQsbil7ZShcImluZm9cIix0LG4pfSxlLndhcm5pbmc9ZnVuY3Rpb24odCxuKXtlKFwid2FybmluZ1wiLHQsbil9LGUuZXJyb3I9ZnVuY3Rpb24odCxuKXtlKFwiZXJyb3JcIix0LG4pfSxlLmZhdGFsPWZ1bmN0aW9uKHQsbil7ZShcImZhdGFsXCIsdCxuKX0sZS5yZXNldD10LGUuc2V0PW4sZS5zZXRXaXRoRW52PWZ1bmN0aW9uKGUpe2NvbnN0IHQ9e307ZS5sb2dMZXZlbCYmKHQubWluaW1hbFNldmVyaXR5PWUubG9nTGV2ZWwpLG4oXCJcIix0KX19KGF8fChhPXt9KSksdC5Mb2dnZXI9YTtjbGFzcyB1e2NvbnN0cnVjdG9yKGUsdCxuLHIsbyxpKXt0aGlzLmNhdGVnb3J5PWUsdGhpcy5uYW1lPXQsdGhpcy5zdGFydFRpbWU9bix0aGlzLmVuZENhbGxiYWNrPXIsdGhpcy50aW1lcj1vLHRoaXMuY3R4PWl9YXN5bmMgZW5kKCl7cmV0dXJuIHRoaXMuZW5kQ2FsbGJhY2sodGhpcyl9YXN5bmMgY2hlY2tUaW1lcigpe2lmKHZvaWQgMD09PXRoaXMuY3R4fHx2b2lkIDA9PT10aGlzLnRpbWVyKXRocm93IG5ldyBFcnJvcihcIk5vIHdlYmdsIHRpbWVyIGZvdW5kXCIpO3JldHVybiB0aGlzLmN0eC5lbmRUaW1lcigpLHRoaXMuY3R4LndhaXRGb3JRdWVyeUFuZEdldFRpbWUodGhpcy50aW1lcil9fWNsYXNzIGx7Y29uc3RydWN0b3IoZSx0LG4scil7dGhpcy5jYXRlZ29yeT1lLHRoaXMubmFtZT10LHRoaXMuc3RhcnRUaW1lPW4sdGhpcy5lbmRUaW1lPXJ9fXQuUHJvZmlsZXI9Y2xhc3N7c3RhdGljIGNyZWF0ZShlKXtyZXR1cm4gdm9pZCAwPT09ZT9uZXcgdGhpczpuZXcgdGhpcyhlLm1heE51bWJlckV2ZW50cyxlLmZsdXNoQmF0Y2hTaXplLGUuZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzKX1jb25zdHJ1Y3RvcihlLHQsbil7dGhpcy5fc3RhcnRlZD0hMSx0aGlzLl9mbHVzaFBvaW50ZXI9MCx0aGlzLl9zdGFydGVkPSExLHRoaXMuX21heE51bWJlckV2ZW50cz12b2lkIDA9PT1lPzFlNDplLHRoaXMuX2ZsdXNoQmF0Y2hTaXplPXZvaWQgMD09PXQ/MTA6dCx0aGlzLl9mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHM9dm9pZCAwPT09bj81ZTM6bn1zdGFydCgpe3RoaXMuX3N0YXJ0ZWQ9ITAsdGhpcy5fdGltaW5nRXZlbnRzPVtdLHRoaXMuX2ZsdXNoVGltZT0oMCx0Lm5vdykoKSx0aGlzLl9mbHVzaFBvaW50ZXI9MH1zdG9wKCl7Zm9yKHRoaXMuX3N0YXJ0ZWQ9ITE7dGhpcy5fZmx1c2hQb2ludGVyPHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGg7dGhpcy5fZmx1c2hQb2ludGVyKyspdGhpcy5sb2dPbmVFdmVudCh0aGlzLl90aW1pbmdFdmVudHNbdGhpcy5fZmx1c2hQb2ludGVyXSl9ZXZlbnQoZSx0LG4scil7Y29uc3Qgbz10aGlzLl9zdGFydGVkP3RoaXMuYmVnaW4oZSx0LHIpOnZvaWQgMDtsZXQgaT0hMTtjb25zdCBhPW4oKTtpZihhJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLnRoZW4pcmV0dXJuIGk9ITAsbmV3IFByb21pc2UoKChlLHQpPT57YS50aGVuKChhc3luYyB0PT57byYmYXdhaXQgby5lbmQoKSxlKHQpfSksKGFzeW5jIGU9PntvJiZhd2FpdCBvLmVuZCgpLHQoZSl9KSl9KSk7aWYoIWkmJm8pe2NvbnN0IGU9by5lbmQoKTtpZihlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnRoZW4pcmV0dXJuIG5ldyBQcm9taXNlKCgodCxuKT0+e2UudGhlbigoKCk9Pnt0KGEpfSksKGU9PntuKGUpfSkpfSkpfXJldHVybiBhfWJlZ2luKGUsbixyKXtpZighdGhpcy5fc3RhcnRlZCl0aHJvdyBuZXcgRXJyb3IoXCJwcm9maWxlciBpcyBub3Qgc3RhcnRlZCB5ZXRcIik7aWYodm9pZCAwPT09cil7Y29uc3Qgcj0oMCx0Lm5vdykoKTtyZXR1cm4gdGhpcy5mbHVzaChyKSxuZXcgdShlLG4sciwoZT0+dGhpcy5lbmRTeW5jKGUpKSl9e2NvbnN0IHQ9ci5iZWdpblRpbWVyKCk7cmV0dXJuIG5ldyB1KGUsbiwwLChhc3luYyBlPT50aGlzLmVuZChlKSksdCxyKX19YXN5bmMgZW5kKGUpe2NvbnN0IHQ9YXdhaXQgZS5jaGVja1RpbWVyKCk7dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDx0aGlzLl9tYXhOdW1iZXJFdmVudHMmJih0aGlzLl90aW1pbmdFdmVudHMucHVzaChuZXcgbChlLmNhdGVnb3J5LGUubmFtZSxlLnN0YXJ0VGltZSx0KSksdGhpcy5mbHVzaCh0KSl9ZW5kU3luYyhlKXtjb25zdCBuPSgwLHQubm93KSgpO3RoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGg8dGhpcy5fbWF4TnVtYmVyRXZlbnRzJiYodGhpcy5fdGltaW5nRXZlbnRzLnB1c2gobmV3IGwoZS5jYXRlZ29yeSxlLm5hbWUsZS5zdGFydFRpbWUsbikpLHRoaXMuZmx1c2gobikpfWxvZ09uZUV2ZW50KGUpe3QuTG9nZ2VyLnZlcmJvc2UoYFByb2ZpbGVyLiR7ZS5jYXRlZ29yeX1gLGAkeyhlLmVuZFRpbWUtZS5zdGFydFRpbWUpLnRvRml4ZWQoMil9bXMgb24gZXZlbnQgJyR7ZS5uYW1lfScgYXQgJHtlLmVuZFRpbWUudG9GaXhlZCgyKX1gKX1mbHVzaChlKXtpZih0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoLXRoaXMuX2ZsdXNoUG9pbnRlcj49dGhpcy5fZmx1c2hCYXRjaFNpemV8fGUtdGhpcy5fZmx1c2hUaW1lPj10aGlzLl9mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHMpe2Zvcihjb25zdCBlPXRoaXMuX2ZsdXNoUG9pbnRlcjt0aGlzLl9mbHVzaFBvaW50ZXI8ZSt0aGlzLl9mbHVzaEJhdGNoU2l6ZSYmdGhpcy5fZmx1c2hQb2ludGVyPHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGg7dGhpcy5fZmx1c2hQb2ludGVyKyspdGhpcy5sb2dPbmVFdmVudCh0aGlzLl90aW1pbmdFdmVudHNbdGhpcy5fZmx1c2hQb2ludGVyXSk7dGhpcy5fZmx1c2hUaW1lPSgwLHQubm93KSgpfX1nZXQgc3RhcnRlZCgpe3JldHVybiB0aGlzLl9zdGFydGVkfX0sdC5ub3c9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHBlcmZvcm1hbmNlJiZwZXJmb3JtYW5jZS5ub3c/KCk9PnBlcmZvcm1hbmNlLm5vdygpOkRhdGUubm93fSwxNzQ1OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1vZGVsPXZvaWQgMDtjb25zdCByPW4oNTY4Niksbz1uKDE0NDYpLGk9big0NjYyKSxhPW4oMTI4Nykscz1uKDcyNzMpO3ZhciB1PWEub25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZiczt0Lk1vZGVsPWNsYXNze2NvbnN0cnVjdG9yKCl7fWxvYWQoZSx0LG4pe2lmKCFuKXRyeXtyZXR1cm4gdm9pZCB0aGlzLmxvYWRGcm9tT25ueEZvcm1hdChlLHQpfWNhdGNoKGUpe2lmKHZvaWQgMCE9PW4pdGhyb3cgZX10aGlzLmxvYWRGcm9tT3J0Rm9ybWF0KGUsdCl9bG9hZEZyb21Pbm54Rm9ybWF0KGUsdCl7Y29uc3Qgbj1vLm9ubnguTW9kZWxQcm90by5kZWNvZGUoZSk7aWYocy5Mb25nVXRpbC5sb25nVG9OdW1iZXIobi5pclZlcnNpb24pPDMpdGhyb3cgbmV3IEVycm9yKFwib25seSBzdXBwb3J0IE9OTlggbW9kZWwgd2l0aCBJUl9WRVJTSU9OPj0zXCIpO3RoaXMuX29wc2V0cz1uLm9wc2V0SW1wb3J0Lm1hcCgoZT0+KHtkb21haW46ZS5kb21haW4sdmVyc2lvbjpzLkxvbmdVdGlsLmxvbmdUb051bWJlcihlLnZlcnNpb24pfSkpKSx0aGlzLl9ncmFwaD1pLkdyYXBoLmZyb20obi5ncmFwaCx0KX1sb2FkRnJvbU9ydEZvcm1hdChlLHQpe2NvbnN0IG49bmV3IHIuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcihlKSxvPXUuSW5mZXJlbmNlU2Vzc2lvbi5nZXRSb290QXNJbmZlcmVuY2VTZXNzaW9uKG4pLm1vZGVsKCk7aWYocy5Mb25nVXRpbC5sb25nVG9OdW1iZXIoby5pclZlcnNpb24oKSk8Myl0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IHN1cHBvcnQgT05OWCBtb2RlbCB3aXRoIElSX1ZFUlNJT04+PTNcIik7dGhpcy5fb3BzZXRzPVtdO2ZvcihsZXQgZT0wO2U8by5vcHNldEltcG9ydExlbmd0aCgpO2UrKyl7Y29uc3QgdD1vLm9wc2V0SW1wb3J0KGUpO3RoaXMuX29wc2V0cy5wdXNoKHtkb21haW46bnVsbD09dD92b2lkIDA6dC5kb21haW4oKSx2ZXJzaW9uOnMuTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHQudmVyc2lvbigpKX0pfXRoaXMuX2dyYXBoPWkuR3JhcGguZnJvbShvLmdyYXBoKCksdCl9Z2V0IGdyYXBoKCl7cmV0dXJuIHRoaXMuX2dyYXBofWdldCBvcHNldHMoKXtyZXR1cm4gdGhpcy5fb3BzZXRzfX19LDYxNDU6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkZMT0FUX1RZUEVTPXQuSU5UX1RZUEVTPXQuTlVNQkVSX1RZUEVTPXZvaWQgMCx0Lk5VTUJFUl9UWVBFUz1bXCJmbG9hdDMyXCIsXCJmbG9hdDY0XCIsXCJpbnQzMlwiLFwiaW50MTZcIixcImludDhcIixcInVpbnQxNlwiLFwidWludDMyXCIsXCJ1aW50OFwiXSx0LklOVF9UWVBFUz1bXCJpbnQzMlwiLFwiaW50MTZcIixcImludDhcIixcInVpbnQxNlwiLFwidWludDMyXCIsXCJ1aW50OFwiXSx0LkZMT0FUX1RZUEVTPVtcImZsb2F0MzJcIixcImZsb2F0NjRcIl19LDU4ODE6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKGUsdCl7aWYodC5lbmRzV2l0aChcIitcIikpe2NvbnN0IG49TnVtYmVyLnBhcnNlSW50KHQuc3Vic3RyaW5nKDAsdC5sZW5ndGgtMSksMTApO3JldHVybiFpc05hTihuKSYmbjw9ZX1pZigyPT09dC5zcGxpdChcIi1cIikubGVuZ3RoKXtjb25zdCBuPXQuc3BsaXQoXCItXCIpLHI9TnVtYmVyLnBhcnNlSW50KG5bMF0sMTApLG89TnVtYmVyLnBhcnNlSW50KG5bMV0sMTApO3JldHVybiFpc05hTihyKSYmIWlzTmFOKG8pJiZyPD1lJiZlPD1vfXJldHVybiBOdW1iZXIucGFyc2VJbnQodCwxMCk9PT1lfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucmVzb2x2ZU9wZXJhdG9yPXZvaWQgMCx0LnJlc29sdmVPcGVyYXRvcj1mdW5jdGlvbihlLHQscil7Zm9yKGNvbnN0IG8gb2Ygcil7Y29uc3Qgcj1vWzBdLGk9b1sxXSxhPW9bMl0scz1vWzNdLHU9b1s0XTtpZihlLm9wVHlwZT09PXIpZm9yKGNvbnN0IGUgb2YgdClpZigoZS5kb21haW49PT1pfHxcImFpLm9ubnhcIj09PWUuZG9tYWluJiZcIlwiPT09aSkmJm4oZS52ZXJzaW9uLGEpKXJldHVybntvcEltcGw6cyxvcEluaXQ6dX19dGhyb3cgbmV3IFR5cGVFcnJvcihgY2Fubm90IHJlc29sdmUgb3BlcmF0b3IgJyR7ZS5vcFR5cGV9JyB3aXRoIG9wc2V0czogJHt0Lm1hcCgoZT0+YCR7ZS5kb21haW58fFwiYWkub25ueFwifSB2JHtlLnZlcnNpb259YCkpLmpvaW4oXCIsIFwiKX1gKX19LDEyODc6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQub25ueHJ1bnRpbWU9dm9pZCAwO2NvbnN0IHI9big1Njg2KTt2YXIgbyxpO289dC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pLGZ1bmN0aW9uKGUpe2xldCB0OyFmdW5jdGlvbihlKXtlW2UuVU5ERUZJTkVEPTBdPVwiVU5ERUZJTkVEXCIsZVtlLkZMT0FUPTFdPVwiRkxPQVRcIixlW2UuSU5UPTJdPVwiSU5UXCIsZVtlLlNUUklORz0zXT1cIlNUUklOR1wiLGVbZS5URU5TT1I9NF09XCJURU5TT1JcIixlW2UuR1JBUEg9NV09XCJHUkFQSFwiLGVbZS5GTE9BVFM9Nl09XCJGTE9BVFNcIixlW2UuSU5UUz03XT1cIklOVFNcIixlW2UuU1RSSU5HUz04XT1cIlNUUklOR1NcIixlW2UuVEVOU09SUz05XT1cIlRFTlNPUlNcIixlW2UuR1JBUEhTPTEwXT1cIkdSQVBIU1wiLGVbZS5TUEFSU0VfVEVOU09SPTExXT1cIlNQQVJTRV9URU5TT1JcIixlW2UuU1BBUlNFX1RFTlNPUlM9MTJdPVwiU1BBUlNFX1RFTlNPUlNcIn0odD1lLkF0dHJpYnV0ZVR5cGV8fChlLkF0dHJpYnV0ZVR5cGU9e30pKX0oKGk9by5leHBlcmltZW50YWx8fChvLmV4cGVyaW1lbnRhbD17fSkpLmZic3x8KGkuZmJzPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtsZXQgdDshZnVuY3Rpb24oZSl7ZVtlLlVOS05PV049MF09XCJVTktOT1dOXCIsZVtlLlZBTFVFPTFdPVwiVkFMVUVcIixlW2UuUEFSQU09Ml09XCJQQVJBTVwifSh0PWUuRGltZW5zaW9uVmFsdWVUeXBlfHwoZS5EaW1lbnNpb25WYWx1ZVR5cGU9e30pKX0oZS5mYnN8fChlLmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtsZXQgdDshZnVuY3Rpb24oZSl7ZVtlLlVOREVGSU5FRD0wXT1cIlVOREVGSU5FRFwiLGVbZS5GTE9BVD0xXT1cIkZMT0FUXCIsZVtlLlVJTlQ4PTJdPVwiVUlOVDhcIixlW2UuSU5UOD0zXT1cIklOVDhcIixlW2UuVUlOVDE2PTRdPVwiVUlOVDE2XCIsZVtlLklOVDE2PTVdPVwiSU5UMTZcIixlW2UuSU5UMzI9Nl09XCJJTlQzMlwiLGVbZS5JTlQ2ND03XT1cIklOVDY0XCIsZVtlLlNUUklORz04XT1cIlNUUklOR1wiLGVbZS5CT09MPTldPVwiQk9PTFwiLGVbZS5GTE9BVDE2PTEwXT1cIkZMT0FUMTZcIixlW2UuRE9VQkxFPTExXT1cIkRPVUJMRVwiLGVbZS5VSU5UMzI9MTJdPVwiVUlOVDMyXCIsZVtlLlVJTlQ2ND0xM109XCJVSU5UNjRcIixlW2UuQ09NUExFWDY0PTE0XT1cIkNPTVBMRVg2NFwiLGVbZS5DT01QTEVYMTI4PTE1XT1cIkNPTVBMRVgxMjhcIixlW2UuQkZMT0FUMTY9MTZdPVwiQkZMT0FUMTZcIn0odD1lLlRlbnNvckRhdGFUeXBlfHwoZS5UZW5zb3JEYXRhVHlwZT17fSkpfShlLmZic3x8KGUuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2xldCB0OyFmdW5jdGlvbihlKXtlW2UuUHJpbWl0aXZlPTBdPVwiUHJpbWl0aXZlXCIsZVtlLkZ1c2VkPTFdPVwiRnVzZWRcIn0odD1lLk5vZGVUeXBlfHwoZS5Ob2RlVHlwZT17fSkpfShlLmZic3x8KGUuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2xldCB0OyFmdW5jdGlvbihlKXtlW2UuTk9ORT0wXT1cIk5PTkVcIixlW2UudGVuc29yX3R5cGU9MV09XCJ0ZW5zb3JfdHlwZVwiLGVbZS5zZXF1ZW5jZV90eXBlPTJdPVwic2VxdWVuY2VfdHlwZVwiLGVbZS5tYXBfdHlwZT0zXT1cIm1hcF90eXBlXCJ9KHQ9ZS5UeXBlSW5mb1ZhbHVlfHwoZS5UeXBlSW5mb1ZhbHVlPXt9KSl9KGUuZmJzfHwoZS5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNTaGFwZShlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTaGFwZShlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9ZGltKHQsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gcj8obnx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb24pLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KnQpLHRoaXMuYmIpOm51bGx9ZGltTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfXN0YXRpYyBzdGFydFNoYXBlKGUpe2Uuc3RhcnRPYmplY3QoMSl9c3RhdGljIGFkZERpbShlLHQpe2UuYWRkRmllbGRPZmZzZXQoMCx0LDApfXN0YXRpYyBjcmVhdGVEaW1WZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0RGltVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGVuZFNoYXBlKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVTaGFwZShlLHQpe3JldHVybiBuLnN0YXJ0U2hhcGUoZSksbi5hZGREaW0oZSx0KSxuLmVuZFNoYXBlKGUpfX10LlNoYXBlPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNEaW1lbnNpb24oZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzRGltZW5zaW9uKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX12YWx1ZSh0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBuPyh0fHxuZXcgZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9ZGVub3RhdGlvbihlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfXN0YXRpYyBzdGFydERpbWVuc2lvbihlKXtlLnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGRWYWx1ZShlLHQpe2UuYWRkRmllbGRPZmZzZXQoMCx0LDApfXN0YXRpYyBhZGREZW5vdGF0aW9uKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxLHQsMCl9c3RhdGljIGVuZERpbWVuc2lvbihlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlRGltZW5zaW9uKGUsdCxyKXtyZXR1cm4gbi5zdGFydERpbWVuc2lvbihlKSxuLmFkZFZhbHVlKGUsdCksbi5hZGREZW5vdGF0aW9uKGUsciksbi5lbmREaW1lbnNpb24oZSl9fXQuRGltZW5zaW9uPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNEaW1lbnNpb25WYWx1ZShlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNEaW1lbnNpb25WYWx1ZShlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9ZGltVHlwZSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50OCh0aGlzLmJiX3Bvcyt0KTplLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWVUeXBlLlVOS05PV059ZGltVmFsdWUoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmJfcG9zK2UpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWRpbVBhcmFtKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9c3RhdGljIHN0YXJ0RGltZW5zaW9uVmFsdWUoZSl7ZS5zdGFydE9iamVjdCgzKX1zdGF0aWMgYWRkRGltVHlwZSh0LG4pe3QuYWRkRmllbGRJbnQ4KDAsbixlLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWVUeXBlLlVOS05PV04pfXN0YXRpYyBhZGREaW1WYWx1ZShlLHQpe2UuYWRkRmllbGRJbnQ2NCgxLHQsZS5jcmVhdGVMb25nKDAsMCkpfXN0YXRpYyBhZGREaW1QYXJhbShlLHQpe2UuYWRkRmllbGRPZmZzZXQoMix0LDApfXN0YXRpYyBlbmREaW1lbnNpb25WYWx1ZShlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlRGltZW5zaW9uVmFsdWUoZSx0LHIsbyl7cmV0dXJuIG4uc3RhcnREaW1lbnNpb25WYWx1ZShlKSxuLmFkZERpbVR5cGUoZSx0KSxuLmFkZERpbVZhbHVlKGUsciksbi5hZGREaW1QYXJhbShlLG8pLG4uZW5kRGltZW5zaW9uVmFsdWUoZSl9fXQuRGltZW5zaW9uVmFsdWU9bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc1RlbnNvclR5cGVBbmRTaGFwZShlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNUZW5zb3JUeXBlQW5kU2hhcGUoZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfWVsZW1UeXBlKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcyt0KTplLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEfXNoYXBlKHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KHR8fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuU2hhcGUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRUZW5zb3JUeXBlQW5kU2hhcGUoZSl7ZS5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkRWxlbVR5cGUodCxuKXt0LmFkZEZpZWxkSW50MzIoMCxuLGUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpfXN0YXRpYyBhZGRTaGFwZShlLHQpe2UuYWRkRmllbGRPZmZzZXQoMSx0LDApfXN0YXRpYyBlbmRUZW5zb3JUeXBlQW5kU2hhcGUoZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZVRlbnNvclR5cGVBbmRTaGFwZShlLHQscil7cmV0dXJuIG4uc3RhcnRUZW5zb3JUeXBlQW5kU2hhcGUoZSksbi5hZGRFbGVtVHlwZShlLHQpLG4uYWRkU2hhcGUoZSxyKSxuLmVuZFRlbnNvclR5cGVBbmRTaGFwZShlKX19dC5UZW5zb3JUeXBlQW5kU2hhcGU9bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc01hcFR5cGUoZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTWFwVHlwZShlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9a2V5VHlwZSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrdCk6ZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRH12YWx1ZVR5cGUodCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gbj8odHx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbykuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfXN0YXRpYyBzdGFydE1hcFR5cGUoZSl7ZS5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkS2V5VHlwZSh0LG4pe3QuYWRkRmllbGRJbnQzMigwLG4sZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRCl9c3RhdGljIGFkZFZhbHVlVHlwZShlLHQpe2UuYWRkRmllbGRPZmZzZXQoMSx0LDApfXN0YXRpYyBlbmRNYXBUeXBlKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVNYXBUeXBlKGUsdCxyKXtyZXR1cm4gbi5zdGFydE1hcFR5cGUoZSksbi5hZGRLZXlUeXBlKGUsdCksbi5hZGRWYWx1ZVR5cGUoZSxyKSxuLmVuZE1hcFR5cGUoZSl9fXQuTWFwVHlwZT1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzU2VxdWVuY2VUeXBlKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1NlcXVlbmNlVHlwZShlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9ZWxlbVR5cGUodCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gbj8odHx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbykuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfXN0YXRpYyBzdGFydFNlcXVlbmNlVHlwZShlKXtlLnN0YXJ0T2JqZWN0KDEpfXN0YXRpYyBhZGRFbGVtVHlwZShlLHQpe2UuYWRkRmllbGRPZmZzZXQoMCx0LDApfXN0YXRpYyBlbmRTZXF1ZW5jZVR5cGUoZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZVNlcXVlbmNlVHlwZShlLHQpe3JldHVybiBuLnN0YXJ0U2VxdWVuY2VUeXBlKGUpLG4uYWRkRWxlbVR5cGUoZSx0KSxuLmVuZFNlcXVlbmNlVHlwZShlKX19dC5TZXF1ZW5jZVR5cGU9bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpeyhlLmZic3x8KGUuZmJzPXt9KSkuRWRnZUVuZD1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfW5vZGVJbmRleCgpe3JldHVybiB0aGlzLmJiLnJlYWRVaW50MzIodGhpcy5iYl9wb3MpfXNyY0FyZ0luZGV4KCl7cmV0dXJuIHRoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zKzQpfWRzdEFyZ0luZGV4KCl7cmV0dXJuIHRoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zKzgpfXN0YXRpYyBjcmVhdGVFZGdlRW5kKGUsdCxuLHIpe3JldHVybiBlLnByZXAoNCwxMiksZS53cml0ZUludDMyKHIpLGUud3JpdGVJbnQzMihuKSxlLndyaXRlSW50MzIodCksZS5vZmZzZXQoKX19fShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc05vZGVFZGdlKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc05vZGVFZGdlKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1ub2RlSW5kZXgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIucmVhZFVpbnQzMih0aGlzLmJiX3BvcytlKTowfWlucHV0RWRnZXModCxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiByPyhufHxuZXcgZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQpLl9faW5pdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzEyKnQsdGhpcy5iYik6bnVsbH1pbnB1dEVkZ2VzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfW91dHB1dEVkZ2VzKHQsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gcj8obnx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kKS5fX2luaXQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSsxMip0LHRoaXMuYmIpOm51bGx9b3V0cHV0RWRnZXNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9c3RhdGljIHN0YXJ0Tm9kZUVkZ2UoZSl7ZS5zdGFydE9iamVjdCgzKX1zdGF0aWMgYWRkTm9kZUluZGV4KGUsdCl7ZS5hZGRGaWVsZEludDMyKDAsdCwwKX1zdGF0aWMgYWRkSW5wdXRFZGdlcyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMSx0LDApfXN0YXRpYyBzdGFydElucHV0RWRnZXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDEyLHQsNCl9c3RhdGljIGFkZE91dHB1dEVkZ2VzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgyLHQsMCl9c3RhdGljIHN0YXJ0T3V0cHV0RWRnZXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDEyLHQsNCl9c3RhdGljIGVuZE5vZGVFZGdlKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVOb2RlRWRnZShlLHQscixvKXtyZXR1cm4gbi5zdGFydE5vZGVFZGdlKGUpLG4uYWRkTm9kZUluZGV4KGUsdCksbi5hZGRJbnB1dEVkZ2VzKGUsciksbi5hZGRPdXRwdXRFZGdlcyhlLG8pLG4uZW5kTm9kZUVkZ2UoZSl9fXQuTm9kZUVkZ2U9bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc05vZGUoZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTm9kZShlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9bmFtZShlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfWRvY1N0cmluZyhlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfWRvbWFpbihlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfXNpbmNlVmVyc2lvbigpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiBlP3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK2UpOjB9aW5kZXgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50MzIodGhpcy5iYl9wb3MrZSk6MH1vcFR5cGUoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9dHlwZSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTYpO3JldHVybiB0P3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK3QpOmUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZS5QcmltaXRpdmV9ZXhlY3V0aW9uUHJvdmlkZXJUeXBlKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTgpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfWlucHV0cyhlLHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjApO3JldHVybiBuP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytuKSs0KmUsdCk6bnVsbH1pbnB1dHNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfW91dHB1dHMoZSx0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIyKTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCplLHQpOm51bGx9b3V0cHV0c0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjIpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9YXR0cmlidXRlcyh0LG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjQpO3JldHVybiByPyhufHxuZXcgZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZSkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqdCksdGhpcy5iYik6bnVsbH1hdHRyaWJ1dGVzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1pbnB1dEFyZ0NvdW50cyhlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI2KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpKzQqZSk6MH1pbnB1dEFyZ0NvdW50c0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjYpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9aW5wdXRBcmdDb3VudHNBcnJheSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjYpO3JldHVybiBlP25ldyBJbnQzMkFycmF5KHRoaXMuYmIuYnl0ZXMoKS5idWZmZXIsdGhpcy5iYi5ieXRlcygpLmJ5dGVPZmZzZXQrdGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSx0aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKSk6bnVsbH1pbXBsaWNpdElucHV0cyhlLHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjgpO3JldHVybiBuP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytuKSs0KmUsdCk6bnVsbH1pbXBsaWNpdElucHV0c0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjgpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9c3RhdGljIHN0YXJ0Tm9kZShlKXtlLnN0YXJ0T2JqZWN0KDEzKX1zdGF0aWMgYWRkTmFtZShlLHQpe2UuYWRkRmllbGRPZmZzZXQoMCx0LDApfXN0YXRpYyBhZGREb2NTdHJpbmcoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEsdCwwKX1zdGF0aWMgYWRkRG9tYWluKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgyLHQsMCl9c3RhdGljIGFkZFNpbmNlVmVyc2lvbihlLHQpe2UuYWRkRmllbGRJbnQzMigzLHQsMCl9c3RhdGljIGFkZEluZGV4KGUsdCl7ZS5hZGRGaWVsZEludDMyKDQsdCwwKX1zdGF0aWMgYWRkT3BUeXBlKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg1LHQsMCl9c3RhdGljIGFkZFR5cGUodCxuKXt0LmFkZEZpZWxkSW50MzIoNixuLGUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZS5QcmltaXRpdmUpfXN0YXRpYyBhZGRFeGVjdXRpb25Qcm92aWRlclR5cGUoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDcsdCwwKX1zdGF0aWMgYWRkSW5wdXRzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg4LHQsMCl9c3RhdGljIGNyZWF0ZUlucHV0c1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRJbnB1dHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgYWRkT3V0cHV0cyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoOSx0LDApfXN0YXRpYyBjcmVhdGVPdXRwdXRzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE91dHB1dHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgYWRkQXR0cmlidXRlcyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMTAsdCwwKX1zdGF0aWMgY3JlYXRlQXR0cmlidXRlc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRBdHRyaWJ1dGVzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGFkZElucHV0QXJnQ291bnRzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxMSx0LDApfXN0YXRpYyBjcmVhdGVJbnB1dEFyZ0NvdW50c1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZEludDMyKHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydElucHV0QXJnQ291bnRzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGFkZEltcGxpY2l0SW5wdXRzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxMix0LDApfXN0YXRpYyBjcmVhdGVJbXBsaWNpdElucHV0c1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRJbXBsaWNpdElucHV0c1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBlbmROb2RlKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVOb2RlKGUsdCxyLG8saSxhLHMsdSxsLGMscCxkLGYsaCl7cmV0dXJuIG4uc3RhcnROb2RlKGUpLG4uYWRkTmFtZShlLHQpLG4uYWRkRG9jU3RyaW5nKGUsciksbi5hZGREb21haW4oZSxvKSxuLmFkZFNpbmNlVmVyc2lvbihlLGkpLG4uYWRkSW5kZXgoZSxhKSxuLmFkZE9wVHlwZShlLHMpLG4uYWRkVHlwZShlLHUpLG4uYWRkRXhlY3V0aW9uUHJvdmlkZXJUeXBlKGUsbCksbi5hZGRJbnB1dHMoZSxjKSxuLmFkZE91dHB1dHMoZSxwKSxuLmFkZEF0dHJpYnV0ZXMoZSxkKSxuLmFkZElucHV0QXJnQ291bnRzKGUsZiksbi5hZGRJbXBsaWNpdElucHV0cyhlLGgpLG4uZW5kTm9kZShlKX19dC5Ob2RlPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNWYWx1ZUluZm8oZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVmFsdWVJbmZvKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1uYW1lKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9ZG9jU3RyaW5nKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9dHlwZSh0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBuPyh0fHxuZXcgZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0VmFsdWVJbmZvKGUpe2Uuc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZE5hbWUoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDAsdCwwKX1zdGF0aWMgYWRkRG9jU3RyaW5nKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxLHQsMCl9c3RhdGljIGFkZFR5cGUoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDIsdCwwKX1zdGF0aWMgZW5kVmFsdWVJbmZvKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVWYWx1ZUluZm8oZSx0LHIsbyl7cmV0dXJuIG4uc3RhcnRWYWx1ZUluZm8oZSksbi5hZGROYW1lKGUsdCksbi5hZGREb2NTdHJpbmcoZSxyKSxuLmFkZFR5cGUoZSxvKSxuLmVuZFZhbHVlSW5mbyhlKX19dC5WYWx1ZUluZm89bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc1R5cGVJbmZvKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1R5cGVJbmZvKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1kZW5vdGF0aW9uKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9dmFsdWVUeXBlKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRVaW50OCh0aGlzLmJiX3Bvcyt0KTplLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm9WYWx1ZS5OT05FfXZhbHVlKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3VuaW9uKGUsdGhpcy5iYl9wb3MrdCk6bnVsbH1zdGF0aWMgc3RhcnRUeXBlSW5mbyhlKXtlLnN0YXJ0T2JqZWN0KDMpfXN0YXRpYyBhZGREZW5vdGF0aW9uKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgwLHQsMCl9c3RhdGljIGFkZFZhbHVlVHlwZSh0LG4pe3QuYWRkRmllbGRJbnQ4KDEsbixlLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm9WYWx1ZS5OT05FKX1zdGF0aWMgYWRkVmFsdWUoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDIsdCwwKX1zdGF0aWMgZW5kVHlwZUluZm8oZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZVR5cGVJbmZvKGUsdCxyLG8pe3JldHVybiBuLnN0YXJ0VHlwZUluZm8oZSksbi5hZGREZW5vdGF0aW9uKGUsdCksbi5hZGRWYWx1ZVR5cGUoZSxyKSxuLmFkZFZhbHVlKGUsbyksbi5lbmRUeXBlSW5mbyhlKX19dC5UeXBlSW5mbz1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIHR7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzT3BlcmF0b3JTZXRJZChlLG4pe3JldHVybihufHxuZXcgdCkuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNPcGVyYXRvclNldElkKGUsbil7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwobnx8bmV3IHQpLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1kb21haW4oZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH12ZXJzaW9uKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcytlKTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1zdGF0aWMgc3RhcnRPcGVyYXRvclNldElkKGUpe2Uuc3RhcnRPYmplY3QoMil9c3RhdGljIGFkZERvbWFpbihlLHQpe2UuYWRkRmllbGRPZmZzZXQoMCx0LDApfXN0YXRpYyBhZGRWZXJzaW9uKGUsdCl7ZS5hZGRGaWVsZEludDY0KDEsdCxlLmNyZWF0ZUxvbmcoMCwwKSl9c3RhdGljIGVuZE9wZXJhdG9yU2V0SWQoZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZU9wZXJhdG9yU2V0SWQoZSxuLHIpe3JldHVybiB0LnN0YXJ0T3BlcmF0b3JTZXRJZChlKSx0LmFkZERvbWFpbihlLG4pLHQuYWRkVmVyc2lvbihlLHIpLHQuZW5kT3BlcmF0b3JTZXRJZChlKX19ZS5PcGVyYXRvclNldElkPXR9KGUuZmJzfHwoZS5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNUZW5zb3IoZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVGVuc29yKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1uYW1lKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9ZG9jU3RyaW5nKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9ZGltcyhlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiB0P3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrdCkrOCplKTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kaW1zTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfWRhdGFUeXBlKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMCk7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrdCk6ZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRH1yYXdEYXRhKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiB0P3RoaXMuYmIucmVhZFVpbnQ4KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrdCkrZSk6MH1yYXdEYXRhTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1yYXdEYXRhQXJyYXkoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gZT9uZXcgVWludDhBcnJheSh0aGlzLmJiLmJ5dGVzKCkuYnVmZmVyLHRoaXMuYmIuYnl0ZXMoKS5ieXRlT2Zmc2V0K3RoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrZSksdGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSkpOm51bGx9c3RyaW5nRGF0YShlLHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiBuP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytuKSs0KmUsdCk6bnVsbH1zdHJpbmdEYXRhTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1zdGF0aWMgc3RhcnRUZW5zb3IoZSl7ZS5zdGFydE9iamVjdCg2KX1zdGF0aWMgYWRkTmFtZShlLHQpe2UuYWRkRmllbGRPZmZzZXQoMCx0LDApfXN0YXRpYyBhZGREb2NTdHJpbmcoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEsdCwwKX1zdGF0aWMgYWRkRGltcyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMix0LDApfXN0YXRpYyBjcmVhdGVEaW1zVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig4LHQubGVuZ3RoLDgpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkSW50NjQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0RGltc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoOCx0LDgpfXN0YXRpYyBhZGREYXRhVHlwZSh0LG4pe3QuYWRkRmllbGRJbnQzMigzLG4sZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRCl9c3RhdGljIGFkZFJhd0RhdGEoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDQsdCwwKX1zdGF0aWMgY3JlYXRlUmF3RGF0YVZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoMSx0Lmxlbmd0aCwxKTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZEludDgodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0UmF3RGF0YVZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoMSx0LDEpfXN0YXRpYyBhZGRTdHJpbmdEYXRhKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg1LHQsMCl9c3RhdGljIGNyZWF0ZVN0cmluZ0RhdGFWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0U3RyaW5nRGF0YVZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBlbmRUZW5zb3IoZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZVRlbnNvcihlLHQscixvLGksYSxzKXtyZXR1cm4gbi5zdGFydFRlbnNvcihlKSxuLmFkZE5hbWUoZSx0KSxuLmFkZERvY1N0cmluZyhlLHIpLG4uYWRkRGltcyhlLG8pLG4uYWRkRGF0YVR5cGUoZSxpKSxuLmFkZFJhd0RhdGEoZSxhKSxuLmFkZFN0cmluZ0RhdGEoZSxzKSxuLmVuZFRlbnNvcihlKX19dC5UZW5zb3I9bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc1NwYXJzZVRlbnNvcihlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTcGFyc2VUZW5zb3IoZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXZhbHVlcyh0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBuPyh0fHxuZXcgZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcikuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfWluZGljZXModCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gbj8odHx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1kaW1zKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3Bvcyt0KSs4KmUpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWRpbXNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9c3RhdGljIHN0YXJ0U3BhcnNlVGVuc29yKGUpe2Uuc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZFZhbHVlcyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMCx0LDApfXN0YXRpYyBhZGRJbmRpY2VzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxLHQsMCl9c3RhdGljIGFkZERpbXMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDIsdCwwKX1zdGF0aWMgY3JlYXRlRGltc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoOCx0Lmxlbmd0aCw4KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZEludDY0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydERpbXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDgsdCw4KX1zdGF0aWMgZW5kU3BhcnNlVGVuc29yKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVTcGFyc2VUZW5zb3IoZSx0LHIsbyl7cmV0dXJuIG4uc3RhcnRTcGFyc2VUZW5zb3IoZSksbi5hZGRWYWx1ZXMoZSx0KSxuLmFkZEluZGljZXMoZSxyKSxuLmFkZERpbXMoZSxvKSxuLmVuZFNwYXJzZVRlbnNvcihlKX19dC5TcGFyc2VUZW5zb3I9bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc0F0dHJpYnV0ZShlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNBdHRyaWJ1dGUoZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfW5hbWUoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH1kb2NTdHJpbmcoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH10eXBlKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcyt0KTplLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlVHlwZS5VTkRFRklORUR9Zigpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiBlP3RoaXMuYmIucmVhZEZsb2F0MzIodGhpcy5iYl9wb3MrZSk6MH1pKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MrZSk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9cyhlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH10KHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTYpO3JldHVybiBuPyh0fHxuZXcgZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcikuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfWcodCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIG4/KHR8fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1mbG9hdHMoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkRmxvYXQzMih0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpKzQqZSk6MH1mbG9hdHNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfWZsb2F0c0FycmF5KCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIGU/bmV3IEZsb2F0MzJBcnJheSh0aGlzLmJiLmJ5dGVzKCkuYnVmZmVyLHRoaXMuYmIuYnl0ZXMoKS5ieXRlT2Zmc2V0K3RoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrZSksdGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSkpOm51bGx9aW50cyhlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIyKTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpKzgqZSk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9aW50c0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjIpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9c3RyaW5ncyhlLHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjQpO3JldHVybiBuP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytuKSs0KmUsdCk6bnVsbH1zdHJpbmdzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH10ZW5zb3JzKHQsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIHI/KG58fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCp0KSx0aGlzLmJiKTpudWxsfXRlbnNvcnNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI2KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfWdyYXBocyh0LG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjgpO3JldHVybiByPyhufHxuZXcgZS5leHBlcmltZW50YWwuZmJzLkdyYXBoKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCp0KSx0aGlzLmJiKTpudWxsfWdyYXBoc0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjgpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9c3RhdGljIHN0YXJ0QXR0cmlidXRlKGUpe2Uuc3RhcnRPYmplY3QoMTMpfXN0YXRpYyBhZGROYW1lKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgwLHQsMCl9c3RhdGljIGFkZERvY1N0cmluZyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMSx0LDApfXN0YXRpYyBhZGRUeXBlKHQsbil7dC5hZGRGaWVsZEludDMyKDIsbixlLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlVHlwZS5VTkRFRklORUQpfXN0YXRpYyBhZGRGKGUsdCl7ZS5hZGRGaWVsZEZsb2F0MzIoMyx0LDApfXN0YXRpYyBhZGRJKGUsdCl7ZS5hZGRGaWVsZEludDY0KDQsdCxlLmNyZWF0ZUxvbmcoMCwwKSl9c3RhdGljIGFkZFMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDUsdCwwKX1zdGF0aWMgYWRkVChlLHQpe2UuYWRkRmllbGRPZmZzZXQoNix0LDApfXN0YXRpYyBhZGRHKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg3LHQsMCl9c3RhdGljIGFkZEZsb2F0cyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoOCx0LDApfXN0YXRpYyBjcmVhdGVGbG9hdHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRGbG9hdDMyKHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEZsb2F0c1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBhZGRJbnRzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg5LHQsMCl9c3RhdGljIGNyZWF0ZUludHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDgsdC5sZW5ndGgsOCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRJbnQ2NCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRJbnRzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig4LHQsOCl9c3RhdGljIGFkZFN0cmluZ3MoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEwLHQsMCl9c3RhdGljIGNyZWF0ZVN0cmluZ3NWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0U3RyaW5nc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBhZGRUZW5zb3JzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxMSx0LDApfXN0YXRpYyBjcmVhdGVUZW5zb3JzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFRlbnNvcnNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgYWRkR3JhcGhzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxMix0LDApfXN0YXRpYyBjcmVhdGVHcmFwaHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0R3JhcGhzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGVuZEF0dHJpYnV0ZShlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlQXR0cmlidXRlKGUsdCxyLG8saSxhLHMsdSxsLGMscCxkLGYsaCl7cmV0dXJuIG4uc3RhcnRBdHRyaWJ1dGUoZSksbi5hZGROYW1lKGUsdCksbi5hZGREb2NTdHJpbmcoZSxyKSxuLmFkZFR5cGUoZSxvKSxuLmFkZEYoZSxpKSxuLmFkZEkoZSxhKSxuLmFkZFMoZSxzKSxuLmFkZFQoZSx1KSxuLmFkZEcoZSxsKSxuLmFkZEZsb2F0cyhlLGMpLG4uYWRkSW50cyhlLHApLG4uYWRkU3RyaW5ncyhlLGQpLG4uYWRkVGVuc29ycyhlLGYpLG4uYWRkR3JhcGhzKGUsaCksbi5lbmRBdHRyaWJ1dGUoZSl9fXQuQXR0cmlidXRlPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNHcmFwaChlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNHcmFwaChlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9aW5pdGlhbGl6ZXJzKHQsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gcj8obnx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KnQpLHRoaXMuYmIpOm51bGx9aW5pdGlhbGl6ZXJzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfW5vZGVBcmdzKHQsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gcj8obnx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5WYWx1ZUluZm8pLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KnQpLHRoaXMuYmIpOm51bGx9bm9kZUFyZ3NMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9bm9kZXModCxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiByPyhufHxuZXcgZS5leHBlcmltZW50YWwuZmJzLk5vZGUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KnQpLHRoaXMuYmIpOm51bGx9bm9kZXNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9bWF4Tm9kZUluZGV4KCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMCk7cmV0dXJuIGU/dGhpcy5iYi5yZWFkVWludDMyKHRoaXMuYmJfcG9zK2UpOjB9bm9kZUVkZ2VzKHQsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIHI/KG58fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuTm9kZUVkZ2UpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KnQpLHRoaXMuYmIpOm51bGx9bm9kZUVkZ2VzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1pbnB1dHMoZSx0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCplLHQpOm51bGx9aW5wdXRzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1vdXRwdXRzKGUsdCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIG4/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK24pKzQqZSx0KTpudWxsfW91dHB1dHNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE2KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfXNwYXJzZUluaXRpYWxpemVycyh0LG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTgpO3JldHVybiByPyhufHxuZXcgZS5leHBlcmltZW50YWwuZmJzLlNwYXJzZVRlbnNvcikuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqdCksdGhpcy5iYik6bnVsbH1zcGFyc2VJbml0aWFsaXplcnNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE4KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfXN0YXRpYyBzdGFydEdyYXBoKGUpe2Uuc3RhcnRPYmplY3QoOCl9c3RhdGljIGFkZEluaXRpYWxpemVycyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMCx0LDApfXN0YXRpYyBjcmVhdGVJbml0aWFsaXplcnNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW5pdGlhbGl6ZXJzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGFkZE5vZGVBcmdzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxLHQsMCl9c3RhdGljIGNyZWF0ZU5vZGVBcmdzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE5vZGVBcmdzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGFkZE5vZGVzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgyLHQsMCl9c3RhdGljIGNyZWF0ZU5vZGVzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE5vZGVzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGFkZE1heE5vZGVJbmRleChlLHQpe2UuYWRkRmllbGRJbnQzMigzLHQsMCl9c3RhdGljIGFkZE5vZGVFZGdlcyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoNCx0LDApfXN0YXRpYyBjcmVhdGVOb2RlRWRnZXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0Tm9kZUVkZ2VzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGFkZElucHV0cyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoNSx0LDApfXN0YXRpYyBjcmVhdGVJbnB1dHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW5wdXRzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGFkZE91dHB1dHMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDYsdCwwKX1zdGF0aWMgY3JlYXRlT3V0cHV0c1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRPdXRwdXRzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGFkZFNwYXJzZUluaXRpYWxpemVycyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoNyx0LDApfXN0YXRpYyBjcmVhdGVTcGFyc2VJbml0aWFsaXplcnNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0U3BhcnNlSW5pdGlhbGl6ZXJzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGVuZEdyYXBoKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVHcmFwaChlLHQscixvLGksYSxzLHUsbCl7cmV0dXJuIG4uc3RhcnRHcmFwaChlKSxuLmFkZEluaXRpYWxpemVycyhlLHQpLG4uYWRkTm9kZUFyZ3MoZSxyKSxuLmFkZE5vZGVzKGUsbyksbi5hZGRNYXhOb2RlSW5kZXgoZSxpKSxuLmFkZE5vZGVFZGdlcyhlLGEpLG4uYWRkSW5wdXRzKGUscyksbi5hZGRPdXRwdXRzKGUsdSksbi5hZGRTcGFyc2VJbml0aWFsaXplcnMoZSxsKSxuLmVuZEdyYXBoKGUpfX10LkdyYXBoPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNNb2RlbChlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNNb2RlbChlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9aXJWZXJzaW9uKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcytlKTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1vcHNldEltcG9ydCh0LG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHI/KG58fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuT3BlcmF0b3JTZXRJZCkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqdCksdGhpcy5iYik6bnVsbH1vcHNldEltcG9ydExlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1wcm9kdWNlck5hbWUoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH1wcm9kdWNlclZlcnNpb24oZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9ZG9tYWluKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfW1vZGVsVmVyc2lvbigpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmJfcG9zK2UpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWRvY1N0cmluZyhlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE2KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH1ncmFwaCh0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE4KTtyZXR1cm4gbj8odHx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfWdyYXBoRG9jU3RyaW5nKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjApO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfXN0YXRpYyBzdGFydE1vZGVsKGUpe2Uuc3RhcnRPYmplY3QoOSl9c3RhdGljIGFkZElyVmVyc2lvbihlLHQpe2UuYWRkRmllbGRJbnQ2NCgwLHQsZS5jcmVhdGVMb25nKDAsMCkpfXN0YXRpYyBhZGRPcHNldEltcG9ydChlLHQpe2UuYWRkRmllbGRPZmZzZXQoMSx0LDApfXN0YXRpYyBjcmVhdGVPcHNldEltcG9ydFZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRPcHNldEltcG9ydFZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBhZGRQcm9kdWNlck5hbWUoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDIsdCwwKX1zdGF0aWMgYWRkUHJvZHVjZXJWZXJzaW9uKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgzLHQsMCl9c3RhdGljIGFkZERvbWFpbihlLHQpe2UuYWRkRmllbGRPZmZzZXQoNCx0LDApfXN0YXRpYyBhZGRNb2RlbFZlcnNpb24oZSx0KXtlLmFkZEZpZWxkSW50NjQoNSx0LGUuY3JlYXRlTG9uZygwLDApKX1zdGF0aWMgYWRkRG9jU3RyaW5nKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg2LHQsMCl9c3RhdGljIGFkZEdyYXBoKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg3LHQsMCl9c3RhdGljIGFkZEdyYXBoRG9jU3RyaW5nKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg4LHQsMCl9c3RhdGljIGVuZE1vZGVsKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVNb2RlbChlLHQscixvLGksYSxzLHUsbCxjKXtyZXR1cm4gbi5zdGFydE1vZGVsKGUpLG4uYWRkSXJWZXJzaW9uKGUsdCksbi5hZGRPcHNldEltcG9ydChlLHIpLG4uYWRkUHJvZHVjZXJOYW1lKGUsbyksbi5hZGRQcm9kdWNlclZlcnNpb24oZSxpKSxuLmFkZERvbWFpbihlLGEpLG4uYWRkTW9kZWxWZXJzaW9uKGUscyksbi5hZGREb2NTdHJpbmcoZSx1KSxuLmFkZEdyYXBoKGUsbCksbi5hZGRHcmFwaERvY1N0cmluZyhlLGMpLG4uZW5kTW9kZWwoZSl9fXQuTW9kZWw9bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtjbGFzcyB0e2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc0tlcm5lbENyZWF0ZUluZm9zKGUsbil7cmV0dXJuKG58fG5ldyB0KS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0tlcm5lbENyZWF0ZUluZm9zKGUsbil7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwobnx8bmV3IHQpLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1ub2RlSW5kaWNlcyhlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB0P3RoaXMuYmIucmVhZFVpbnQzMih0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpKzQqZSk6MH1ub2RlSW5kaWNlc0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1ub2RlSW5kaWNlc0FycmF5KCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gZT9uZXcgVWludDMyQXJyYXkodGhpcy5iYi5ieXRlcygpLmJ1ZmZlcix0aGlzLmJiLmJ5dGVzKCkuYnl0ZU9mZnNldCt0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2UpLHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpKTpudWxsfWtlcm5lbERlZkhhc2hlcyhlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiB0P3RoaXMuYmIucmVhZFVpbnQ2NCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpKzgqZSk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9a2VybmVsRGVmSGFzaGVzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfXN0YXRpYyBzdGFydEtlcm5lbENyZWF0ZUluZm9zKGUpe2Uuc3RhcnRPYmplY3QoMil9c3RhdGljIGFkZE5vZGVJbmRpY2VzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgwLHQsMCl9c3RhdGljIGNyZWF0ZU5vZGVJbmRpY2VzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkSW50MzIodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0Tm9kZUluZGljZXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgYWRkS2VybmVsRGVmSGFzaGVzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxLHQsMCl9c3RhdGljIGNyZWF0ZUtlcm5lbERlZkhhc2hlc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoOCx0Lmxlbmd0aCw4KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZEludDY0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEtlcm5lbERlZkhhc2hlc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoOCx0LDgpfXN0YXRpYyBlbmRLZXJuZWxDcmVhdGVJbmZvcyhlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlS2VybmVsQ3JlYXRlSW5mb3MoZSxuLHIpe3JldHVybiB0LnN0YXJ0S2VybmVsQ3JlYXRlSW5mb3MoZSksdC5hZGROb2RlSW5kaWNlcyhlLG4pLHQuYWRkS2VybmVsRGVmSGFzaGVzKGUsciksdC5lbmRLZXJuZWxDcmVhdGVJbmZvcyhlKX19ZS5LZXJuZWxDcmVhdGVJbmZvcz10fShlLmZic3x8KGUuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzU3ViR3JhcGhTZXNzaW9uU3RhdGUoZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU3ViR3JhcGhTZXNzaW9uU3RhdGUoZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfWdyYXBoSWQoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH1zZXNzaW9uU3RhdGUodCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gbj8odHx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRTdWJHcmFwaFNlc3Npb25TdGF0ZShlKXtlLnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGRHcmFwaElkKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgwLHQsMCl9c3RhdGljIGFkZFNlc3Npb25TdGF0ZShlLHQpe2UuYWRkRmllbGRPZmZzZXQoMSx0LDApfXN0YXRpYyBlbmRTdWJHcmFwaFNlc3Npb25TdGF0ZShlKXtsZXQgdD1lLmVuZE9iamVjdCgpO3JldHVybiBlLnJlcXVpcmVkRmllbGQodCw0KSx0fXN0YXRpYyBjcmVhdGVTdWJHcmFwaFNlc3Npb25TdGF0ZShlLHQscil7cmV0dXJuIG4uc3RhcnRTdWJHcmFwaFNlc3Npb25TdGF0ZShlKSxuLmFkZEdyYXBoSWQoZSx0KSxuLmFkZFNlc3Npb25TdGF0ZShlLHIpLG4uZW5kU3ViR3JhcGhTZXNzaW9uU3RhdGUoZSl9fXQuU3ViR3JhcGhTZXNzaW9uU3RhdGU9bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc1Nlc3Npb25TdGF0ZShlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTZXNzaW9uU3RhdGUoZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfWtlcm5lbHModCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gbj8odHx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5LZXJuZWxDcmVhdGVJbmZvcykuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfXN1YkdyYXBoU2Vzc2lvblN0YXRlcyh0LG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHI/KG58fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuU3ViR3JhcGhTZXNzaW9uU3RhdGUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KnQpLHRoaXMuYmIpOm51bGx9c3ViR3JhcGhTZXNzaW9uU3RhdGVzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfXN0YXRpYyBzdGFydFNlc3Npb25TdGF0ZShlKXtlLnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGRLZXJuZWxzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgwLHQsMCl9c3RhdGljIGFkZFN1YkdyYXBoU2Vzc2lvblN0YXRlcyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMSx0LDApfXN0YXRpYyBjcmVhdGVTdWJHcmFwaFNlc3Npb25TdGF0ZXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGVzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGVuZFNlc3Npb25TdGF0ZShlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlU2Vzc2lvblN0YXRlKGUsdCxyKXtyZXR1cm4gbi5zdGFydFNlc3Npb25TdGF0ZShlKSxuLmFkZEtlcm5lbHMoZSx0KSxuLmFkZFN1YkdyYXBoU2Vzc2lvblN0YXRlcyhlLHIpLG4uZW5kU2Vzc2lvblN0YXRlKGUpfX10LlNlc3Npb25TdGF0ZT1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzSW5mZXJlbmNlU2Vzc2lvbihlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNJbmZlcmVuY2VTZXNzaW9uKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgYnVmZmVySGFzSWRlbnRpZmllcihlKXtyZXR1cm4gZS5fX2hhc19pZGVudGlmaWVyKFwiT1JUTVwiKX1vcnRWZXJzaW9uKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9bW9kZWwodCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gbj8odHx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5Nb2RlbCkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfXNlc3Npb25TdGF0ZSh0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBuPyh0fHxuZXcgZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZSkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfXN0YXRpYyBzdGFydEluZmVyZW5jZVNlc3Npb24oZSl7ZS5zdGFydE9iamVjdCgzKX1zdGF0aWMgYWRkT3J0VmVyc2lvbihlLHQpe2UuYWRkRmllbGRPZmZzZXQoMCx0LDApfXN0YXRpYyBhZGRNb2RlbChlLHQpe2UuYWRkRmllbGRPZmZzZXQoMSx0LDApfXN0YXRpYyBhZGRTZXNzaW9uU3RhdGUoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDIsdCwwKX1zdGF0aWMgZW5kSW5mZXJlbmNlU2Vzc2lvbihlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgZmluaXNoSW5mZXJlbmNlU2Vzc2lvbkJ1ZmZlcihlLHQpe2UuZmluaXNoKHQsXCJPUlRNXCIpfXN0YXRpYyBmaW5pc2hTaXplUHJlZml4ZWRJbmZlcmVuY2VTZXNzaW9uQnVmZmVyKGUsdCl7ZS5maW5pc2godCxcIk9SVE1cIiwhMCl9c3RhdGljIGNyZWF0ZUluZmVyZW5jZVNlc3Npb24oZSx0LHIsbyl7cmV0dXJuIG4uc3RhcnRJbmZlcmVuY2VTZXNzaW9uKGUpLG4uYWRkT3J0VmVyc2lvbihlLHQpLG4uYWRkTW9kZWwoZSxyKSxuLmFkZFNlc3Npb25TdGF0ZShlLG8pLG4uZW5kSW5mZXJlbmNlU2Vzc2lvbihlKX19dC5JbmZlcmVuY2VTZXNzaW9uPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpfSwxNzIzOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk9ubnhqc1Nlc3Npb25IYW5kbGVyPXZvaWQgMDtjb25zdCByPW4oODQ1Myksbz1uKDkyNDApO3QuT25ueGpzU2Vzc2lvbkhhbmRsZXI9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5zZXNzaW9uPWUsdGhpcy5pbnB1dE5hbWVzPXRoaXMuc2Vzc2lvbi5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXM9dGhpcy5zZXNzaW9uLm91dHB1dE5hbWVzfWFzeW5jIGRpc3Bvc2UoKXt9YXN5bmMgcnVuKGUsdCxuKXtjb25zdCBpPW5ldyBNYXA7Zm9yKGNvbnN0IHQgaW4gZSlpZihPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpKXtjb25zdCBuPWVbdF07aS5zZXQodCxuZXcgby5UZW5zb3Iobi5kaW1zLG4udHlwZSx2b2lkIDAsdm9pZCAwLG4uZGF0YSkpfWNvbnN0IGE9YXdhaXQgdGhpcy5zZXNzaW9uLnJ1bihpKSxzPXt9O3JldHVybiBhLmZvckVhY2goKChlLHQpPT57c1t0XT1uZXcgci5UZW5zb3IoZS50eXBlLGUuZGF0YSxlLmRpbXMpfSkpLHN9c3RhcnRQcm9maWxpbmcoKXt0aGlzLnNlc3Npb24uc3RhcnRQcm9maWxpbmcoKX1lbmRQcm9maWxpbmcoKXt0aGlzLnNlc3Npb24uZW5kUHJvZmlsaW5nKCl9fX0sNjAyNzooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5TZXNzaW9uPXZvaWQgMDtjb25zdCByPW4oNzA2Nyksbz1uKDEyOTYpLGk9bigxOTc1KSxhPW4oNjQ5Nikscz1uKDEzMTUpLHU9bigxNzQ1KTt0LlNlc3Npb249Y2xhc3N7Y29uc3RydWN0b3IoZT17fSl7dGhpcy5faW5pdGlhbGl6ZWQ9ITEsdGhpcy5iYWNrZW5kSGludD1lLmJhY2tlbmRIaW50LHRoaXMucHJvZmlsZXI9cy5Qcm9maWxlci5jcmVhdGUoZS5wcm9maWxlciksdGhpcy5jb250ZXh0PXtwcm9maWxlcjp0aGlzLnByb2ZpbGVyLGdyYXBoSW5wdXRUeXBlczpbXSxncmFwaElucHV0RGltczpbXX19Z2V0IGlucHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0SW5wdXROYW1lcygpfWdldCBvdXRwdXROYW1lcygpe3JldHVybiB0aGlzLl9tb2RlbC5ncmFwaC5nZXRPdXRwdXROYW1lcygpfXN0YXJ0UHJvZmlsaW5nKCl7dGhpcy5wcm9maWxlci5zdGFydCgpfWVuZFByb2ZpbGluZygpe3RoaXMucHJvZmlsZXIuc3RvcCgpfWFzeW5jIGxvYWRNb2RlbChlLHQsbil7YXdhaXQgdGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIlNlc3Npb24ubG9hZE1vZGVsXCIsKGFzeW5jKCk9Pntjb25zdCBhPWF3YWl0KDAsaS5yZXNvbHZlQmFja2VuZCkodGhpcy5iYWNrZW5kSGludCk7aWYodGhpcy5zZXNzaW9uSGFuZGxlcj1hLmNyZWF0ZVNlc3Npb25IYW5kbGVyKHRoaXMuY29udGV4dCksdGhpcy5fbW9kZWw9bmV3IHUuTW9kZWwsXCJzdHJpbmdcIj09dHlwZW9mIGUpe2NvbnN0IHQ9ZS5lbmRzV2l0aChcIi5vcnRcIik7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGZldGNoKXtjb25zdCBuPWF3YWl0KDAsby5wcm9taXNpZnkpKHIucmVhZEZpbGUpKGUpO3RoaXMuaW5pdGlhbGl6ZShuLHQpfWVsc2V7Y29uc3Qgbj1hd2FpdCBmZXRjaChlKSxyPWF3YWl0IG4uYXJyYXlCdWZmZXIoKTt0aGlzLmluaXRpYWxpemUobmV3IFVpbnQ4QXJyYXkociksdCl9fWVsc2UgaWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpKXRoaXMuaW5pdGlhbGl6ZShlKTtlbHNle2NvbnN0IHI9bmV3IFVpbnQ4QXJyYXkoZSx0fHwwLG58fGUuYnl0ZUxlbmd0aCk7dGhpcy5pbml0aWFsaXplKHIpfX0pKX1pbml0aWFsaXplKGUsdCl7aWYodGhpcy5faW5pdGlhbGl6ZWQpdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBpbml0aWFsaXplZFwiKTt0aGlzLnByb2ZpbGVyLmV2ZW50KFwic2Vzc2lvblwiLFwiU2Vzc2lvbi5pbml0aWFsaXplXCIsKCgpPT57Y29uc3Qgbj10aGlzLnNlc3Npb25IYW5kbGVyLnRyYW5zZm9ybUdyYXBoP3RoaXMuc2Vzc2lvbkhhbmRsZXI6dm9pZCAwO3RoaXMuX21vZGVsLmxvYWQoZSxuLHQpLHRoaXMuc2Vzc2lvbkhhbmRsZXIub25HcmFwaEluaXRpYWxpemVkJiZ0aGlzLnNlc3Npb25IYW5kbGVyLm9uR3JhcGhJbml0aWFsaXplZCh0aGlzLl9tb2RlbC5ncmFwaCksdGhpcy5pbml0aWFsaXplT3BzKHRoaXMuX21vZGVsLmdyYXBoKSx0aGlzLl9leGVjdXRpb25QbGFuPW5ldyBhLkV4ZWN1dGlvblBsYW4odGhpcy5fbW9kZWwuZ3JhcGgsdGhpcy5fb3BzLHRoaXMucHJvZmlsZXIpfSkpLHRoaXMuX2luaXRpYWxpemVkPSEwfWFzeW5jIHJ1bihlKXtpZighdGhpcy5faW5pdGlhbGl6ZWQpdGhyb3cgbmV3IEVycm9yKFwic2Vzc2lvbiBub3QgaW5pdGlhbGl6ZWQgeWV0XCIpO3JldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KFwic2Vzc2lvblwiLFwiU2Vzc2lvbi5ydW5cIiwoYXN5bmMoKT0+e2NvbnN0IHQ9dGhpcy5ub3JtYWxpemVBbmRWYWxpZGF0ZUlucHV0cyhlKSxuPWF3YWl0IHRoaXMuX2V4ZWN1dGlvblBsYW4uZXhlY3V0ZSh0aGlzLnNlc3Npb25IYW5kbGVyLHQpO3JldHVybiB0aGlzLmNyZWF0ZU91dHB1dChuKX0pKX1ub3JtYWxpemVBbmRWYWxpZGF0ZUlucHV0cyhlKXtjb25zdCB0PXRoaXMuX21vZGVsLmdyYXBoLmdldElucHV0TmFtZXMoKTtpZihBcnJheS5pc0FycmF5KGUpKXtpZihlLmxlbmd0aCE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW5jb3JyZWN0IGlucHV0IGFycmF5IGxlbmd0aDogZXhwZWN0ZWQgJHt0Lmxlbmd0aH0gYnV0IGdvdCAke2UubGVuZ3RofWApfWVsc2V7aWYoZS5zaXplIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbmNvcnJlY3QgaW5wdXQgbWFwIHNpemU6IGV4cGVjdGVkICR7dC5sZW5ndGh9IGJ1dCBnb3QgJHtlLnNpemV9YCk7Y29uc3Qgbj1uZXcgQXJyYXkoZS5zaXplKTtsZXQgcj0wO2ZvcihsZXQgbz0wO288dC5sZW5ndGg7KytvKXtjb25zdCBpPWUuZ2V0KHRbb10pO2lmKCFpKXRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCB0ZW5zb3IgZm9yOiAnJHtuYW1lfSdgKTtuW3IrK109aX1lPW59aWYodGhpcy5jb250ZXh0LmdyYXBoSW5wdXRUeXBlcyYmMCE9PXRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMubGVuZ3RoJiZ0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dERpbXMmJjAhPT10aGlzLmNvbnRleHQuZ3JhcGhJbnB1dERpbXMubGVuZ3RoKXRoaXMudmFsaWRhdGVJbnB1dFRlbnNvckRpbXModGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zLGUsITEpO2Vsc2V7Y29uc3QgdD10aGlzLl9tb2RlbC5ncmFwaC5nZXRJbnB1dEluZGljZXMoKSxuPXRoaXMuX21vZGVsLmdyYXBoLmdldFZhbHVlcygpLHI9bmV3IEFycmF5KHQubGVuZ3RoKTtmb3IobGV0IG89MDtvPHQubGVuZ3RoOysrbyl7Y29uc3QgaT1uW3Rbb11dO3Jbb109aS50eXBlLnNoYXBlLmRpbXMsdGhpcy5jb250ZXh0LmdyYXBoSW5wdXRUeXBlcy5wdXNoKGkudHlwZS50ZW5zb3JUeXBlKSx0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dERpbXMucHVzaChlW29dLmRpbXMpfXRoaXMudmFsaWRhdGVJbnB1dFRlbnNvckRpbXMocixlLCEwKX1yZXR1cm4gdGhpcy52YWxpZGF0ZUlucHV0VGVuc29yVHlwZXModGhpcy5jb250ZXh0LmdyYXBoSW5wdXRUeXBlcyxlKSxlfXZhbGlkYXRlSW5wdXRUZW5zb3JUeXBlcyhlLHQpe2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKXtjb25zdCByPWVbbl0sbz10W25dLnR5cGU7aWYociE9PW8pdGhyb3cgbmV3IEVycm9yKGBpbnB1dCB0ZW5zb3JbJHtufV0gY2hlY2sgZmFpbGVkOiBleHBlY3RlZCB0eXBlICcke3J9JyBidXQgZ290ICR7b31gKX19dmFsaWRhdGVJbnB1dFRlbnNvckRpbXMoZSx0LG4pe2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7cisrKXtjb25zdCBvPWVbcl0saT10W3JdLmRpbXM7aWYoIXRoaXMuY29tcGFyZVRlbnNvckRpbXMobyxpLG4pKXRocm93IG5ldyBFcnJvcihgaW5wdXQgdGVuc29yWyR7cn1dIGNoZWNrIGZhaWxlZDogZXhwZWN0ZWQgc2hhcGUgJ1ske28uam9pbihcIixcIil9XScgYnV0IGdvdCBbJHtpLmpvaW4oXCIsXCIpfV1gKX19Y29tcGFyZVRlbnNvckRpbXMoZSx0LG4pe2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3IpaWYoZVtyXSE9PXRbcl0mJighbnx8MCE9PWVbcl0pKXJldHVybiExO3JldHVybiEwfWNyZWF0ZU91dHB1dChlKXtjb25zdCB0PXRoaXMuX21vZGVsLmdyYXBoLmdldE91dHB1dE5hbWVzKCk7aWYoZS5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBudW1iZXIgb2Ygb3V0cHV0cyBkbyBub3QgbWF0Y2ggbnVtYmVyIG9mIGdlbmVyYXRlZCBvdXRwdXRzXCIpO2NvbnN0IG49bmV3IE1hcDtmb3IobGV0IHI9MDtyPHQubGVuZ3RoOysrciluLnNldCh0W3JdLGVbcl0pO3JldHVybiBufWluaXRpYWxpemVPcHMoZSl7Y29uc3QgdD1lLmdldE5vZGVzKCk7dGhpcy5fb3BzPW5ldyBBcnJheSh0Lmxlbmd0aCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspdGhpcy5fb3BzW25dPXRoaXMuc2Vzc2lvbkhhbmRsZXIucmVzb2x2ZSh0W25dLHRoaXMuX21vZGVsLm9wc2V0cyxlKX19fSw5MjQwOmZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlRlbnNvcj12b2lkIDA7Y29uc3Qgbz1uKDM0NDIpLGk9cihuKDM3MjApKSxhPW4oMTQ0Nikscz1uKDEyODcpLHU9big3MjczKTt2YXIgbD1zLm9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnM7Y2xhc3MgY3tnZXQgZGF0YSgpe2lmKHZvaWQgMD09PXRoaXMuY2FjaGUpe2NvbnN0IGU9dGhpcy5kYXRhUHJvdmlkZXIodGhpcy5kYXRhSWQpO2lmKGUubGVuZ3RoIT09dGhpcy5zaXplKXRocm93IG5ldyBFcnJvcihcIkxlbmd0aCBvZiBkYXRhIHByb3ZpZGVkIGJ5IHRoZSBEYXRhIFByb3ZpZGVyIGlzIGluY29uc2lzdGVudCB3aXRoIHRoZSBkaW1zIG9mIHRoaXMgVGVuc29yLlwiKTt0aGlzLmNhY2hlPWV9cmV0dXJuIHRoaXMuY2FjaGV9Z2V0IHN0cmluZ0RhdGEoKXtpZihcInN0cmluZ1wiIT09dGhpcy50eXBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJkYXRhIHR5cGUgaXMgbm90IHN0cmluZ1wiKTtyZXR1cm4gdGhpcy5kYXRhfWdldCBpbnRlZ2VyRGF0YSgpe3N3aXRjaCh0aGlzLnR5cGUpe2Nhc2VcInVpbnQ4XCI6Y2FzZVwiaW50OFwiOmNhc2VcInVpbnQxNlwiOmNhc2VcImludDE2XCI6Y2FzZVwiaW50MzJcIjpjYXNlXCJ1aW50MzJcIjpjYXNlXCJib29sXCI6cmV0dXJuIHRoaXMuZGF0YTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoXCJkYXRhIHR5cGUgaXMgbm90IGludGVnZXIgKHVpbnQ4LCBpbnQ4LCB1aW50MTYsIGludDE2LCBpbnQzMiwgdWludDMyLCBib29sKVwiKX19Z2V0IGZsb2F0RGF0YSgpe3N3aXRjaCh0aGlzLnR5cGUpe2Nhc2VcImZsb2F0MzJcIjpjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIHRoaXMuZGF0YTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoXCJkYXRhIHR5cGUgaXMgbm90IGZsb2F0IChmbG9hdDMyLCBmbG9hdDY0KVwiKX19Z2V0IG51bWJlckRhdGEoKXtpZihcInN0cmluZ1wiIT09dGhpcy50eXBlKXJldHVybiB0aGlzLmRhdGE7dGhyb3cgbmV3IFR5cGVFcnJvcihcInR5cGUgY2Fubm90IGJlIG5vbi1udW1iZXIgKHN0cmluZylcIil9Z2V0KGUpe3JldHVybiB0aGlzLmRhdGFbdS5TaGFwZVV0aWwuaW5kaWNlc1RvT2Zmc2V0KGUsdGhpcy5zdHJpZGVzKV19c2V0KGUsdCl7dGhpcy5kYXRhW3UuU2hhcGVVdGlsLmluZGljZXNUb09mZnNldChlLHRoaXMuc3RyaWRlcyldPXR9YXN5bmMgZ2V0RGF0YSgpe3JldHVybiB2b2lkIDA9PT10aGlzLmNhY2hlJiYodGhpcy5jYWNoZT1hd2FpdCB0aGlzLmFzeW5jRGF0YVByb3ZpZGVyKHRoaXMuZGF0YUlkKSksdGhpcy5jYWNoZX1nZXQgc3RyaWRlcygpe3JldHVybiB0aGlzLl9zdHJpZGVzfHwodGhpcy5fc3RyaWRlcz11LlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyh0aGlzLmRpbXMpKSx0aGlzLl9zdHJpZGVzfWNvbnN0cnVjdG9yKGUsdCxuLHIsaSxhPW8uR3VpZC5jcmVhdGUoKSl7dGhpcy5kaW1zPWUsdGhpcy50eXBlPXQsdGhpcy5kYXRhUHJvdmlkZXI9bix0aGlzLmFzeW5jRGF0YVByb3ZpZGVyPXIsdGhpcy5jYWNoZT1pLHRoaXMuZGF0YUlkPWEsdGhpcy5zaXplPXUuU2hhcGVVdGlsLnZhbGlkYXRlRGltc0FuZENhbGNTaXplKGUpO2NvbnN0IHM9dGhpcy5zaXplLGw9dm9pZCAwPT09biYmdm9pZCAwPT09ciYmdm9pZCAwPT09aTtpZih2b2lkIDAhPT1pJiZpLmxlbmd0aCE9PXMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnB1dCBkaW1zIGRvZXNuJ3QgbWF0Y2ggZGF0YSBsZW5ndGguXCIpO2lmKFwic3RyaW5nXCI9PT10KXtpZighKHZvaWQgMD09PWl8fEFycmF5LmlzQXJyYXkoaSkmJmkuZXZlcnkoKGU9Plwic3RyaW5nXCI9PXR5cGVvZiBlKSkpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWNoZSBzaG91bGQgYmUgYSBzdHJpbmcgYXJyYXlcIik7bCYmKHRoaXMuY2FjaGU9bmV3IEFycmF5KHMpKX1lbHNle2lmKHZvaWQgMCE9PWkpe2NvbnN0IGU9ZCh0KTtpZighKGkgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBjYWNoZSBzaG91bGQgYmUgdHlwZSAke2UubmFtZX1gKX1pZihsKXtjb25zdCBlPW5ldyBBcnJheUJ1ZmZlcihzKmZ1bmN0aW9uKGUpe3N3aXRjaChlKXtjYXNlXCJib29sXCI6Y2FzZVwiaW50OFwiOmNhc2VcInVpbnQ4XCI6cmV0dXJuIDE7Y2FzZVwiaW50MTZcIjpjYXNlXCJ1aW50MTZcIjpyZXR1cm4gMjtjYXNlXCJpbnQzMlwiOmNhc2VcInVpbnQzMlwiOmNhc2VcImZsb2F0MzJcIjpyZXR1cm4gNDtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIDg7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBjYWxjdWxhdGUgc2l6ZW9mKCkgb24gdHlwZSAke2V9YCl9fSh0KSk7dGhpcy5jYWNoZT1mdW5jdGlvbihlLHQpe3JldHVybiBuZXcoZCh0KSkoZSl9KGUsdCl9fX1zdGF0aWMgZnJvbVByb3RvKGUpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBjb25zdHJ1Y3QgVmFsdWUgZnJvbSBhbiBlbXB0eSB0ZW5zb3JcIik7Y29uc3QgdD11LlByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhlLmRhdGFUeXBlKSxuPXUuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tUHJvdG8oZS5kaW1zKSxyPW5ldyBjKG4sdCk7aWYoXCJzdHJpbmdcIj09PXQpZS5zdHJpbmdEYXRhLmZvckVhY2goKChlLHQpPT57ci5kYXRhW3RdPSgwLHUuZGVjb2RlVXRmOFN0cmluZykoZSl9KSk7ZWxzZSBpZihlLnJhd0RhdGEmJlwibnVtYmVyXCI9PXR5cGVvZiBlLnJhd0RhdGEuYnl0ZUxlbmd0aCYmZS5yYXdEYXRhLmJ5dGVMZW5ndGg+MCl7Y29uc3QgdD1yLmRhdGEsbj1uZXcgRGF0YVZpZXcoZS5yYXdEYXRhLmJ1ZmZlcixlLnJhd0RhdGEuYnl0ZU9mZnNldCxlLnJhd0RhdGEuYnl0ZUxlbmd0aCksbz1wKGUuZGF0YVR5cGUpLGk9ZS5yYXdEYXRhLmJ5dGVMZW5ndGgvbztpZihlLnJhd0RhdGEuYnl0ZUxlbmd0aCVvIT0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYnVmZmVyIGxlbmd0aFwiKTtpZih0Lmxlbmd0aCE9PWkpdGhyb3cgbmV3IEVycm9yKFwiYnVmZmVyIGxlbmd0aCBtaXNtYXRjaFwiKTtmb3IobGV0IHI9MDtyPGk7cisrKXtjb25zdCBpPWgobixlLmRhdGFUeXBlLHIqbyk7dFtyXT1pfX1lbHNle2xldCB0O3N3aXRjaChlLmRhdGFUeXBlKXtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDp0PWUuZmxvYXREYXRhO2JyZWFrO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2OmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6dD1lLmludDMyRGF0YTticmVhaztjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDp0PWUuaW50NjREYXRhO2JyZWFrO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTp0PWUuZG91YmxlRGF0YTticmVhaztjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0OnQ9ZS51aW50NjREYXRhO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwidW5zcGVjaWZpYyBlcnJvclwiKX1pZihudWxsPT10KXRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBwb3B1bGF0ZSBkYXRhIGZyb20gYSB0ZW5zb3Jwcm90byB2YWx1ZVwiKTtjb25zdCBuPXIuZGF0YTtpZihuLmxlbmd0aCE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImFycmF5IGxlbmd0aCBtaXNtYXRjaFwiKTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl7Y29uc3Qgbz10W3JdO2kuZGVmYXVsdC5pc0xvbmcobyk/bltyXT1mKG8sZS5kYXRhVHlwZSk6bltyXT1vfX1yZXR1cm4gcn1zdGF0aWMgZnJvbURhdGEoZSx0LG4pe3JldHVybiBuZXcgYyh0LG4sdm9pZCAwLHZvaWQgMCxlKX1zdGF0aWMgZnJvbU9ydFRlbnNvcihlKXtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgY29uc3RydWN0IFZhbHVlIGZyb20gYW4gZW1wdHkgdGVuc29yXCIpO2NvbnN0IHQ9dS5Qcm90b1V0aWwudGVuc29yRGltc0Zyb21PUlRGb3JtYXQoZSksbj11LlByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhlLmRhdGFUeXBlKCkpLHI9bmV3IGModCxuKTtpZihcInN0cmluZ1wiPT09bilmb3IobGV0IHQ9MDt0PGUuc3RyaW5nRGF0YUxlbmd0aCgpO3QrKylyLmRhdGFbdF09ZS5zdHJpbmdEYXRhKHQpO2Vsc2UgaWYoZS5yYXdEYXRhQXJyYXkoKSYmXCJudW1iZXJcIj09dHlwZW9mIGUucmF3RGF0YUxlbmd0aCgpJiZlLnJhd0RhdGFMZW5ndGgoKT4wKXtjb25zdCB0PXIuZGF0YSxuPW5ldyBEYXRhVmlldyhlLnJhd0RhdGFBcnJheSgpLmJ1ZmZlcixlLnJhd0RhdGFBcnJheSgpLmJ5dGVPZmZzZXQsZS5yYXdEYXRhTGVuZ3RoKCkpLG89cChlLmRhdGFUeXBlKCkpLGk9ZS5yYXdEYXRhTGVuZ3RoKCkvbztpZihlLnJhd0RhdGFMZW5ndGgoKSVvIT0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYnVmZmVyIGxlbmd0aFwiKTtpZih0Lmxlbmd0aCE9PWkpdGhyb3cgbmV3IEVycm9yKFwiYnVmZmVyIGxlbmd0aCBtaXNtYXRjaFwiKTtmb3IobGV0IHI9MDtyPGk7cisrKXtjb25zdCBpPWgobixlLmRhdGFUeXBlKCkscipvKTt0W3JdPWl9fXJldHVybiByfX1mdW5jdGlvbiBwKGUpe3N3aXRjaChlKXtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6cmV0dXJuIDE7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2OnJldHVybiAyO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUOmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjpyZXR1cm4gNDtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0OnJldHVybiA4O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgY2FsY3VsYXRlIHNpemVvZigpIG9uIHR5cGUgJHthLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVbZV19YCl9fWZ1bmN0aW9uIGQoZSl7c3dpdGNoKGUpe2Nhc2VcImJvb2xcIjpjYXNlXCJ1aW50OFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImludDhcIjpyZXR1cm4gSW50OEFycmF5O2Nhc2VcImludDE2XCI6cmV0dXJuIEludDE2QXJyYXk7Y2FzZVwidWludDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImludDMyXCI6cmV0dXJuIEludDMyQXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gRmxvYXQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwidW5zcGVjaWZpZWQgZXJyb3JcIil9fWZ1bmN0aW9uIGYoZSx0KXtpZih0PT09YS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0fHx0PT09bC5UZW5zb3JEYXRhVHlwZS5JTlQ2NCl7aWYoZS5ncmVhdGVyVGhhbk9yRXF1YWwoMjE0NzQ4MzY0OCl8fGUubGVzc1RoYW4oLTIxNDc0ODM2NDgpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnQ2NCBpcyBub3Qgc3VwcG9ydGVkXCIpfWVsc2V7aWYodCE9PWEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzImJnQhPT1sLlRlbnNvckRhdGFUeXBlLlVJTlQzMiYmdCE9PWEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQmJnQhPT1sLlRlbnNvckRhdGFUeXBlLlVJTlQ2NCl0aHJvdyBuZXcgVHlwZUVycm9yKGBub3QgYSBMT05HIHR5cGU6ICR7YS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3RdfWApO2lmKGUuZ3JlYXRlclRoYW5PckVxdWFsKDQyOTQ5NjcyOTYpfHxlLmxlc3NUaGFuKDApKXRocm93IG5ldyBUeXBlRXJyb3IoXCJ1aW50NjQgaXMgbm90IHN1cHBvcnRlZFwiKX1yZXR1cm4gZS50b051bWJlcigpfWZ1bmN0aW9uIGgoZSx0LG4pe3N3aXRjaCh0KXtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OnJldHVybiBlLmdldFVpbnQ4KG4pO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6cmV0dXJuIGUuZ2V0SW50OChuKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6cmV0dXJuIGUuZ2V0VWludDE2KG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2OnJldHVybiBlLmdldEludDE2KG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUOnJldHVybiBlLmdldEZsb2F0MzIobiwhMCk7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI6cmV0dXJuIGUuZ2V0SW50MzIobiwhMCk7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOnJldHVybiBlLmdldFVpbnQzMihuLCEwKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDpyZXR1cm4gZihpLmRlZmF1bHQuZnJvbUJpdHMoZS5nZXRVaW50MzIobiwhMCksZS5nZXRVaW50MzIobis0LCEwKSwhMSksdCk7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOnJldHVybiBlLmdldEZsb2F0NjQobiwhMCk7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0OnJldHVybiBmKGkuZGVmYXVsdC5mcm9tQml0cyhlLmdldFVpbnQzMihuLCEwKSxlLmdldFVpbnQzMihuKzQsITApLCEwKSx0KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlYWQgZnJvbSBEYXRhVmlldyBmb3IgdHlwZSAke2Eub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVt0XX1gKX19dC5UZW5zb3I9Y30sNzI3MzpmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWNvZGVVdGY4U3RyaW5nPXQuTUFYX0NMSVA9dC5NSU5fQ0xJUD10LlBvb2xDb252VXRpbD10LlJlZHVjZVV0aWw9dC5TcGxpdFV0aWw9dC5NYXRoVXRpbD10LlNoYXBlVXRpbD10LkxvbmdVdGlsPXQuUHJvdG9VdGlsPXQuR2VtbVV0aWw9dC5hcnJheUNvcHlIZWxwZXI9dC5Ccm9hZGNhc3RVdGlsPXQuTWF0TXVsVXRpbD10LkFycmF5VXRpbD10LmFzc2VydD10LmNoZWNrSW5wdXRzU2hhcGU9dm9pZCAwO2NvbnN0IG89big1Njg2KSxpPXIobigzNzIwKSksYT1uKDE0NDYpLHM9big5MjQwKTt0LmNoZWNrSW5wdXRzU2hhcGU9ZnVuY3Rpb24oZSwuLi50KXtpZighZXx8ZS5sZW5ndGghPT10Lmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKylpZighZVtuXS5kaW1zfHxlW25dLmRpbXMubGVuZ3RoIT09dFtuXSlyZXR1cm4hMTtyZXR1cm4hMH0sdC5hc3NlcnQ9ZnVuY3Rpb24oZSx0KXtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmdcIj09dHlwZW9mIHQ/dDp0KCkpfSx0LkFycmF5VXRpbD1jbGFzc3tzdGF0aWMgYXJyYXlzRXF1YWwoZSx0KXtpZihlLmxlbmd0aCE9PXQubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWlmKGVbbl0hPT10W25dKXJldHVybiExO3JldHVybiEwfX07Y2xhc3MgdXtzdGF0aWMgcHJlcHJvY2Vzc0lucHV0U2hhcGVzKGUsdCl7cmV0dXJuWzE9PT1lLmxlbmd0aD9bMSxlWzBdXTplLDE9PT10Lmxlbmd0aD9bdFswXSwxXTp0XX1zdGF0aWMgcG9zdHByb2Nlc3NPdXRwdXRTaGFwZShlLHQsbil7MT09PXQmJmUuc3BsaWNlKGUubGVuZ3RoLTIsMSksMT09PW4mJmUucG9wKCl9c3RhdGljIGNhbGNNYXRNdWxTaGFwZShlLHQpe3JldHVybiBlWzFdIT09dFswXT92b2lkIDA6W2VbMF0sdFsxXV19fXQuTWF0TXVsVXRpbD11O2NsYXNzIGx7c3RhdGljIGNhbGNTaGFwZShlLHQsbj0hMSl7Y29uc3Qgcj1lLmxlbmd0aCxvPXQubGVuZ3RoO2lmKDA9PT1yKXJldHVybiB0O2lmKDA9PT1vKXJldHVybiBlO2NvbnN0IGk9TWF0aC5tYXgoZS5sZW5ndGgsdC5sZW5ndGgpLGE9bmV3IEFycmF5KGkpO2lmKG4pe2lmKHI8Mnx8bzwyKXJldHVybjtjb25zdCBuPXUuY2FsY01hdE11bFNoYXBlKFtlW3ItMl0sZVtyLTFdXSxbdFtvLTJdLHRbby0xXV0pO2lmKHZvaWQgMD09PW4pcmV0dXJuO1thW2ktMl0sYVtpLTFdXT1ufWZvcihsZXQgcz1uPzM6MTtzPD1pO3MrKyl7Y29uc3Qgbj1yLXM8MD8xOmVbci1zXSx1PW8tczwwPzE6dFtvLXNdO2lmKG4hPT11JiZuPjEmJnU+MSlyZXR1cm47YVtpLXNdPU1hdGgubWF4KG4sdSl9cmV0dXJuIGF9c3RhdGljIGluZGV4KGUsdCl7Y29uc3Qgbj1uZXcgQXJyYXkodC5sZW5ndGgpO3JldHVybiBsLmZpbGxJbmRleChlLHQsbiksbn1zdGF0aWMgZmlsbEluZGV4KGUsdCxuKXtjb25zdCByPWUubGVuZ3RoLXQubGVuZ3RoO2ZvcihsZXQgbz0wO288dC5sZW5ndGg7bysrKW5bb109ZVtyK29dJXRbb119c3RhdGljIGNhbGMoZSx0LG4scixvKXtjb25zdCBpPWwuY2FsY1NoYXBlKGUuZGltcyx0LmRpbXMpO2lmKGkpe2lmKHImJiFkLmFyZUVxdWFsKGksZS5kaW1zKSlyZXR1cm47Y29uc3QgYT1kLnNpemUoaSksdT1yP2U6bmV3IHMuVGVuc29yKGksb3x8ZS50eXBlKTtpZigwPT09aS5sZW5ndGgpdS5zZXQoW10sbihlLmdldChbXSksdC5nZXQoW10pKSk7ZWxzZXtjb25zdCByPW5ldyBBcnJheShpLmxlbmd0aCksbz1uZXcgQXJyYXkoZS5kaW1zLmxlbmd0aCkscz1uZXcgQXJyYXkodC5kaW1zLmxlbmd0aCk7bGV0IGMscD0wLGQ9MCxmPSExLGg9ITE7MD09PWUuZGltcy5sZW5ndGgmJihwPWUuZ2V0KFtdKSxmPSEwKSwwPT09dC5kaW1zLmxlbmd0aCYmKGQ9dC5nZXQoW10pLGg9ITApO2ZvcihsZXQgZz0wO2c8YTtnKyspe2M9Zztmb3IobGV0IGU9aS5sZW5ndGgtMTtlPj0wO2UtLSlyW2VdPWMlaVtlXSxjPU1hdGguZmxvb3IoYy9pW2VdKTtmfHwobC5maWxsSW5kZXgocixlLmRpbXMsbykscD1lLmdldChvKSksaHx8KGwuZmlsbEluZGV4KHIsdC5kaW1zLHMpLGQ9dC5nZXQocykpLHUuc2V0KHIsbihwLGQpKX19cmV0dXJuIHV9fXN0YXRpYyBpc1ZhbGlkQnJvYWRjYXN0KGUsdCl7Y29uc3Qgbj1lLmxlbmd0aCxyPXQubGVuZ3RoO2lmKG4+cilyZXR1cm4hMTtmb3IobGV0IG89MTtvPD1uO28rKylpZigxIT09ZVtuLW9dJiZlW24tb10hPT10W3Itb10pcmV0dXJuITE7cmV0dXJuITB9c3RhdGljIGdldEJyb2FkY2FzdERpbXMoZSx0KXtjb25zdCBuPWUubGVuZ3RoLHI9W107Zm9yKGxldCBvPTA7bzxuO28rKyl7Y29uc3QgaT1uLTEtbyxhPWVbaV18fDE7KHRbdC5sZW5ndGgtMS1vXXx8MSk+MSYmMT09PWEmJnIudW5zaGlmdChpKX1yZXR1cm4gcn19dC5Ccm9hZGNhc3RVdGlsPWwsdC5hcnJheUNvcHlIZWxwZXI9ZnVuY3Rpb24oZSx0LG4scixvKXtpZihyPDB8fHI+PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZUluZGV4IG91dCBvZiBib3VuZHNcIik7aWYobjwwfHxuPj1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKHIrbz50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzXCIpO2lmKG4rbz5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0XCIpO2ZvcihsZXQgaT0wO2k8bztpKyspZVtuK2ldPXRbcitpXX0sdC5HZW1tVXRpbD1jbGFzc3tzdGF0aWMgZ2V0U2hhcGVPZkdlbW1SZXN1bHQoZSx0LG4scixvKXtpZigyIT09ZS5sZW5ndGh8fDIhPT1uLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzaGFwZSBuZWVkIHRvIGJlIG9mIHNpemUgMlwiKTtsZXQgaSxhLHM7dD8oaT1lWzFdLGE9ZVswXSk6KGk9ZVswXSxhPWVbMV0pO2xldCB1PS0xO2lmKHI/KHM9blswXSx1PTEpOihzPW5bMV0sdT0wKSxuW3VdIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJkaW1lbnNpb24gbWlzbWF0Y2hcIik7aWYoaTw9MHx8czw9MHx8YTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNoYXBlIHNwZWNpZmllZFwiKTtpZihvJiYhbC5pc1ZhbGlkQnJvYWRjYXN0KG8sW2ksc10pKXRocm93IG5ldyBFcnJvcihcImdlbW06IGludmFsaWQgYmlhcyBzaGFwZSBmb3IgYnJvYWRjYXN0XCIpO3JldHVybltpLHMsYV19fTtjbGFzcyBje3N0YXRpYyB0ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhlKXtzd2l0Y2goZSl7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpyZXR1cm5cImludDhcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpyZXR1cm5cInVpbnQ4XCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDpyZXR1cm5cImJvb2xcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpyZXR1cm5cImludDE2XCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OnJldHVyblwidWludDE2XCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjpyZXR1cm5cInVpbnQzMlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpyZXR1cm5cImZsb2F0NjRcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5TVFJJTkc6cmV0dXJuXCJzdHJpbmdcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDpyZXR1cm5cImludDMyXCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0OnJldHVyblwidWludDMyXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHthLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVbZV19YCl9fXN0YXRpYyB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bShlKXtzd2l0Y2goZSl7Y2FzZVwiaW50OFwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODtjYXNlXCJ1aW50OFwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg7Y2FzZVwiYm9vbFwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDtjYXNlXCJpbnQxNlwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY7Y2FzZVwidWludDE2XCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY7Y2FzZVwiaW50MzJcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyO2Nhc2VcInVpbnQzMlwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlNUUklORztjYXNlXCJpbnQ2NFwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ7Y2FzZVwidWludDY0XCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX1zdGF0aWMgdGVuc29yRGltc0Zyb21Qcm90byhlKXtyZXR1cm4gZS5tYXAoKGU9PmkuZGVmYXVsdC5pc0xvbmcoZSk/ZS50b051bWJlcigpOmUpKX1zdGF0aWMgdGVuc29yVmFsdWVUeXBlRnJvbVByb3RvKGUpe3JldHVybnt0ZW5zb3JUeXBlOmMudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8oZS5lbGVtVHlwZSksc2hhcGU6e2RpbXM6Yy50ZW5zb3JEaW1zRnJvbVByb3RvKGUuc2hhcGUuZGltLm1hcCgoZT0+ZS5kaW1WYWx1ZSkpKX19fXN0YXRpYyB0ZW5zb3JEaW1zRnJvbU9SVEZvcm1hdChlKXtjb25zdCB0PVtdO2ZvcihsZXQgbj0wO248ZS5kaW1zTGVuZ3RoKCk7bisrKXQucHVzaChwLmxvbmdUb051bWJlcihlLmRpbXMobikpKTtyZXR1cm4gdH1zdGF0aWMgdGVuc29yQXR0cmlidXRlc0Zyb21PUlRGb3JtYXQoZSl7Y29uc3QgdD1bXTtmb3IobGV0IG49MDtuPGUuYXR0cmlidXRlc0xlbmd0aCgpO24rKyl0LnB1c2goZS5hdHRyaWJ1dGVzKG4pKTtyZXR1cm4gdH19dC5Qcm90b1V0aWw9YztjbGFzcyBwe3N0YXRpYyBsb25nVG9OdW1iZXIoZSx0KXtyZXR1cm4gaS5kZWZhdWx0LmlzTG9uZyhlKT9lLnRvTnVtYmVyKCk6ZSBpbnN0YW5jZW9mIG8uZmxhdGJ1ZmZlcnMuTG9uZz9pLmRlZmF1bHQuZnJvbVZhbHVlKHtsb3c6ZS5sb3csaGlnaDplLmhpZ2gsdW5zaWduZWQ6bnVsbCE9dCYmdH0pLnRvTnVtYmVyKCk6ZX1zdGF0aWMgaXNMb25nKGUpe3JldHVybiBpLmRlZmF1bHQuaXNMb25nKGUpfHxlIGluc3RhbmNlb2Ygby5mbGF0YnVmZmVycy5Mb25nfX10LkxvbmdVdGlsPXA7Y2xhc3MgZHtzdGF0aWMgc2l6ZShlKXtyZXR1cm4gZC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGUsMCxlLmxlbmd0aCl9c3RhdGljIHNpemVGcm9tRGltZW5zaW9uKGUsdCl7aWYodDwwfHx0PmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHt0fSBmb3Igc2l6ZUZyb21EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke2UubGVuZ3RofSBkaW1lbnNpb25zLmApO3JldHVybiBkLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZSx0LGUubGVuZ3RoKX1zdGF0aWMgc2l6ZVRvRGltZW5zaW9uKGUsdCl7aWYodDwwfHx0PmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHt0fSBmb3Igc2l6ZVRvRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHtlLmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGUsMCx0KX1zdGF0aWMgZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShlLHQsbil7bGV0IHI9MTtmb3IobGV0IG89dDtvPG47bysrKXtpZihlW29dPD0wKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBnZXQgdmFsaWQgc2l6ZSBmcm9tIHNwZWNpZmllZCBkaW1lbnNpb24gcmFuZ2UuIE1vc3QgbGlrZWx5IHRoZSByYW5nZSBjb250YWlucyAwIG9yIG5lZ2F0aXZlIHZhbHVlcyBpbiB0aGVtLlwiKTtyKj1lW29dfXJldHVybiByfXN0YXRpYyBjb21wdXRlU3RyaWRlcyhlKXtjb25zdCB0PWUubGVuZ3RoO2lmKDA9PT10KXJldHVybltdO2lmKDE9PT10KXJldHVyblsxXTtjb25zdCBuPW5ldyBBcnJheSh0KTtuW3QtMV09MSxuW3QtMl09ZVt0LTFdO2ZvcihsZXQgcj10LTM7cj49MDstLXIpbltyXT1uW3IrMV0qZVtyKzFdO3JldHVybiBufXN0YXRpYyB0cmFuc3Bvc2UoZSl7cmV0dXJuIGUuc2xpY2UoKS5yZXZlcnNlKCl9c3RhdGljIGluZGljZXNUb09mZnNldChlLHQsbil7dm9pZCAwPT09biYmKG49ZS5sZW5ndGgpO2xldCByPTA7Zm9yKGxldCBvPTA7bzxuOysrbylyKz10W29dKmVbb107cmV0dXJuIHJ9c3RhdGljIG9mZnNldFRvSW5kaWNlcyhlLHQpe2NvbnN0IG49dC5sZW5ndGg7aWYoMD09PW4pcmV0dXJuW107aWYoMT09PW4pcmV0dXJuW2UqdFswXV07Y29uc3Qgcj1uZXcgQXJyYXkodC5sZW5ndGgpO2ZvcihsZXQgbj0wO248ci5sZW5ndGgtMTsrK24pcltuXT1NYXRoLmZsb29yKGUvdFtuXSksZS09cltuXSp0W25dO3JldHVybiByW3IubGVuZ3RoLTFdPWUscn1zdGF0aWMgbm9ybWFsaXplQXhpcyhlLHQpe2lmKGU8LXQmJmU+PXQpdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYXhpcyBmb3IgdGhpcyBvcGVyYXRpb24uXCIpO3JldHVybiBlPDA/ZSt0OmV9c3RhdGljIG5vcm1hbGl6ZUF4ZXMoZSx0KXtyZXR1cm4gZS5tYXAoKGU9PnRoaXMubm9ybWFsaXplQXhpcyhlLHQpKSl9c3RhdGljIGluY3JlbWVudEluZGV4KGUsdCxuKXtpZigwPT09dC5sZW5ndGh8fDA9PT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbmRleCBpbmNyZW1lbnRpbmcgdW5zdXBwb3J0ZWQgZm9yIHNjYWxhciBUZW5zb3JcIik7aWYodm9pZCAwPT09biluPXQubGVuZ3RoO2Vsc2UgaWYobjw9MHx8bj50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbmNvcnJlY3QgYXhpcyB0byBpbmNyZW1lbnQgb25cIik7Zm9yKGxldCByPW4tMTtyPj0wJiYoZVtyXSsrLCEoZVtyXTx0W3JdKSk7LS1yKWVbcl09MH1zdGF0aWMgY2FsY3VsYXRlUmVzaGFwZWREaW1zKGUsdCl7aWYoMD09PXQubGVuZ3RoKXtpZigwPT09ZS5sZW5ndGh8fDE9PT1kLnNpemUoZSkpcmV0dXJuW107dGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHJlc2hhcGUgdG8gYSBzY2FsYXIgVGVuc29yXCIpfWNvbnN0IG49dC5sZW5ndGgscj1uZXcgQXJyYXkobik7bGV0IG89LTEsaT0xO2ZvcihsZXQgYT0wO2E8bjthKyspe2lmKHRbYV08LTEpdGhyb3cgbmV3IEVycm9yKFwiYSBkaW1lbnNpb24gaW4gc2hhcGUgaGludHMgY2Fubm90IGJlIGxlc3MgdGhhbiAtMVwiKTtpZigtMT09PXRbYV0pe2lmKC0xIT09byl0aHJvdyBuZXcgRXJyb3IoXCJhdCBtb3N0IG9uZSBkaW1lbnNpb24gaW4gc2hhcGUgaGludHMgY2FuIGJlIC0xXCIpO289YX1lbHNle2lmKDA9PT10W2FdKXtpZihhPj1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgZGltZW5zaW9uIHdpdGggdmFsdWUgemVybyBleGNlZWRzIHRoZSBkaW1lbnNpb24gc2l6ZSBvZiB0aGUgaW5wdXQgdGVuc29yXCIpO3JbYV09ZVthXX1lbHNlIHJbYV09dFthXTtpKj1yW2FdfX1jb25zdCBhPWQuc2l6ZShlKTtpZigtMSE9PW8pe2lmKGElaSE9MCl0aHJvdyBuZXcgRXJyb3IoYHRoZSBpbnB1dCB0ZW5zb3IgY2Fubm90IGJlIHJlc2hhcGVkIHRvIHRoZSByZXF1ZXN0ZWQgc2hhcGUuIElucHV0IHNoYXBlOiBbJHtlfV0gT3V0cHV0IHNoYXBlOiBbJHt0fV1gKTtyW29dPWEvaX1lbHNlIGlmKGkhPT1hKXRocm93IG5ldyBFcnJvcihcInJlc2hhcGVkRGltcyBhbmQgb3JpZ2luYWxEaW1zIGRvbid0IGhhdmUgbWF0Y2hpbmcgc2l6ZXNcIik7cmV0dXJuIHJ9c3RhdGljIHNvcnRCYXNlZE9uUGVybShlLHQpe3JldHVybiB0P3QubWFwKCh0PT5lW3RdKSk6ZS5zbGljZSgpLnJldmVyc2UoKX1zdGF0aWMgcGFkU2hhcGUoZSx0KXtjb25zdCBuPWUubGVuZ3RoO3JldHVybiBlLm1hcCgoKGUscik9PmUrdFtyXSt0W3Irbl0pKX1zdGF0aWMgYXJlRXF1YWwoZSx0KXtyZXR1cm4gZS5sZW5ndGg9PT10Lmxlbmd0aCYmZS5ldmVyeSgoKGUsbik9PmU9PT10W25dKSl9c3RhdGljIHZhbGlkYXRlRGltc0FuZENhbGNTaXplKGUpe2lmKGUubGVuZ3RoPjYpdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9ubHkgcmFuayAwIHRvIDYgaXMgc3VwcG9ydGVkIGZvciB0ZW5zb3Igc2hhcGUuXCIpO2xldCB0PTE7Zm9yKGNvbnN0IG4gb2YgZSl7aWYoIU51bWJlci5pc0ludGVnZXIobikpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBzaGFwZTogJHtufSBpcyBub3QgYW4gaW50ZWdlcmApO2lmKG48MHx8bj4yMTQ3NDgzNjQ3KXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2hhcGU6IGxlbmd0aCAke259IGlzIG5vdCBhbGxvd2VkYCk7dCo9bn1yZXR1cm4gdH1zdGF0aWMgZmxhdHRlblNoYXBlKGUsdCl7dDwwJiYodCs9ZS5sZW5ndGgpO2NvbnN0IG49ZS5yZWR1Y2UoKChlLHQpPT5lKnQpLDEpLHI9ZS5zbGljZSh0KS5yZWR1Y2UoKChlLHQpPT5lKnQpLDEpO3JldHVybltuL3Iscl19c3RhdGljIHNxdWVlemVTaGFwZShlLHQpe2NvbnN0IG49bmV3IEFycmF5O3Q9ZC5ub3JtYWxpemVBeGVzKHQsZS5sZW5ndGgpO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXtjb25zdCBvPXQuaW5kZXhPZihyKT49MDtpZihvJiYxIT09ZVtyXSl0aHJvdyBuZXcgRXJyb3IoXCJzcXVlZXplIGFuIGF4aXMgb2Ygc2l6ZSBkaWZmZXJlbnQgdGhhbiAxXCIpOygwPT09dC5sZW5ndGgmJmVbcl0+MXx8dC5sZW5ndGg+MCYmIW8pJiZuLnB1c2goZVtyXSl9cmV0dXJuIG59c3RhdGljIHVuc3F1ZWV6ZVNoYXBlKGUsdCl7Y29uc3Qgbj1uZXcgQXJyYXkoZS5sZW5ndGgrdC5sZW5ndGgpO24uZmlsbCgwKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgcj1kLm5vcm1hbGl6ZUF4aXModFtlXSxuLmxlbmd0aCk7aWYocj49bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiJ2F4ZXMnIGhhcyBhbiBvdXQgb2YgcmFuZ2UgYXhpc1wiKTtpZigwIT09bltyXSl0aHJvdyBuZXcgRXJyb3IoXCInYXhlcycgaGFzIGEgZHVwbGljYXRlIGF4aXNcIik7bltyXT0xfWxldCByPTA7Zm9yKGxldCB0PTA7dDxuLmxlbmd0aDt0KyspMD09PW5bdF0mJihuW3RdPWVbcisrXSk7aWYociE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRoZSB1bnNxdWVlemVkIGRpbWVuc2lvbiBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWRcIik7cmV0dXJuIG59fXQuU2hhcGVVdGlsPWQsdC5NYXRoVXRpbD1jbGFzc3tzdGF0aWMgc3FyKGUsdCxuLHIsbyl7aWYocjwwfHxyPj10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MHx8bj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihyK28+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kc1wiKTtpZihuK28+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdFwiKTtmb3IobGV0IGk9MDtpPG87aSsrKWVbbitpXSs9TWF0aC5wb3codFtyK2ldLDIpfXN0YXRpYyBheHB5KGUsdCxuLHIsbyxpKXtpZihyPDB8fHI+PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZUluZGV4IG91dCBvZiBib3VuZHNcIik7aWYobjwwfHxuPj1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKHIrbz50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzXCIpO2lmKG4rbz5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0XCIpO2ZvcihsZXQgYT0wO2E8bzthKyspZVtuK2FdKz1pKnRbcithXX1zdGF0aWMgcG93eChlLHQsbixyLG8saSl7aWYocjwwfHxyPj10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MHx8bj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihyK28+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kc1wiKTtpZihuK28+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdFwiKTtmb3IobGV0IGE9MDthPG87YSsrKWVbbithXT1NYXRoLnBvdyh0W3IrYV0saSl9c3RhdGljIG11bChlLHQsbixyLG8pe2lmKHI8MHx8cj49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IG91dCBvZiBib3VuZHNcIik7aWYocitvPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHNcIik7aWYobitvPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHRcIik7Zm9yKGxldCBpPTA7aTxvO2krKyllW24raV09dFtyK2ldKmVbbitpXX19O2NsYXNzIGZ7c3RhdGljIHNwbGl0U2hhcGUoZSx0LG4scil7aWYoMD09PW4ubGVuZ3RoKXtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJuZWVkIHRvIGtub3cgbnVtYmVyIG9mIG91dHB1dHMgd2hlbiB0aGUgJ3NwbGl0JyBhdHRyaWJ1dGUgaXMgbm90IHNwZWNpZmllZFwiKTtmLmRldGVybWluZVNwbGl0KGVbdF0scixuKX1jb25zdCBvPVtdLGk9WzBdO2ZvcihsZXQgcj0wO3I8bi5sZW5ndGg7KytyKXswIT09ciYmaS5wdXNoKGlbci0xXStuW3ItMV0pO2NvbnN0IGE9ZS5zbGljZSgpO2FbdF09bltyXSxvLnB1c2goYSl9cmV0dXJuW28saV19c3RhdGljIGRldGVybWluZVNwbGl0KGUsdCxuKXtpZihlJXQhPTApdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHNwbGl0IHRlbnNvciB0byBlcXVhbCBzaXplZCBwYXJ0c1wiKTtmb3IobGV0IHI9MDtyPHQ7KytyKW4ucHVzaChlL3QpfX10LlNwbGl0VXRpbD1mO2NsYXNzIGh7c3RhdGljIGNhbGNSZWR1Y2UoZSx0LG4scixvKXtjb25zdCBpPWUuZGltcy5zbGljZSgwKTswPT09dC5sZW5ndGgmJmkuZm9yRWFjaCgoKGUsbik9PnQucHVzaChuKSkpO2NvbnN0IGE9aC5jYWxjUmVkdWNlU2hhcGUoaSx0LCEwKSx1PWQuc2l6ZShhKSxjPW5ldyBzLlRlbnNvcihhLGUudHlwZSkscD1kLmNvbXB1dGVTdHJpZGVzKGEpLGY9ZC5jb21wdXRlU3RyaWRlcyhpKSxnPW5ldyBBcnJheShpLmxlbmd0aCk7Zm9yKGxldCBuPTA7bjx1O24rKyl7Y29uc3QgYT1kLm9mZnNldFRvSW5kaWNlcyhuLHApO2wuZmlsbEluZGV4KGEsaSxnKSxjLnNldChhLGguY2FsY1JlZHVjZUJ5QXhpcyhlLm51bWJlckRhdGEsdCxpLDAsZC5pbmRpY2VzVG9PZmZzZXQoZyxmKSxyLG8pKX1yZXR1cm4gbj9jOm5ldyBzLlRlbnNvcihoLmNhbGNSZWR1Y2VTaGFwZShpLHQsbiksYy50eXBlLHZvaWQgMCx2b2lkIDAsYy5kYXRhLGMuZGF0YUlkKX1zdGF0aWMgY2FsY1JlZHVjZUJ5QXhpcyhlLHQsbixyLG8saSxhKXtsZXQgcz0wO2lmKHI+PXQubGVuZ3RoKXJldHVybiBpKGVbb10pO2NvbnN0IHU9dFtyXSxsPXU+PW4ubGVuZ3RoPzE6ZC5zaXplKG4uc2xpY2UodSsxKSk7Zm9yKGxldCBjPTA7YzxuW3VdO2MrKylzPTA9PT1jP2guY2FsY1JlZHVjZUJ5QXhpcyhlLHQsbixyKzEsbyxpLGEpOmEocyxoLmNhbGNSZWR1Y2VCeUF4aXMoZSx0LG4scisxLG8saSxhKSksbys9bDtyZXR1cm4gc31zdGF0aWMgY2FsY1JlZHVjZVNoYXBlKGUsdCxuKXtjb25zdCByPWUuc2xpY2UoKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylyW3RbZV1dPW4/MTowO3JldHVybiByLmZpbHRlcigoZT0+MCE9PWUpKX19dC5SZWR1Y2VVdGlsPWg7Y2xhc3MgZ3tzdGF0aWMgYWRqdXN0UG9vbEF0dHJpYnV0ZXMoZSx0LG4scixvLGkpe2lmKCFlJiZuLmxlbmd0aCE9PXQubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9uc1wiKTtpZihlKWZvcihsZXQgZT0wO2U8dC5sZW5ndGgtMjtlKyspZT49bi5sZW5ndGg/bi5wdXNoKHRbZSsyXSk6bltlXT10W2UrMl07Zm9yKGxldCBlPTA7ZTxuLmxlbmd0aDtlKyspaWYoZTxyLmxlbmd0aCl7aWYocltlXTwwKXRocm93IG5ldyBFcnJvcihcInN0cmlkZXMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugci5wdXNoKDEpO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGg7ZSsrKWlmKGU8by5sZW5ndGgpe2lmKG9bZV08MCl0aHJvdyBuZXcgRXJyb3IoXCJkaWxhdGlvbnMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugby5wdXNoKDEpO2ZvcihsZXQgZT0wO2U8MipuLmxlbmd0aDtlKyspaWYoZTxpLmxlbmd0aCl7aWYoaVtlXTwwKXRocm93IG5ldyBFcnJvcihcInBhZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBpLnB1c2goMCk7Zm9yKGxldCBlPTA7ZTxuLmxlbmd0aDtlKyspe2lmKG5bZV08PTApdGhyb3cgbmV3IEVycm9yKFwia2VybmVsIHNoYXBlcyBuZWVkIHRvIGJlIGdyZWF0ZXIgdGhhbiAwXCIpO2lmKGlbZV0+PW5bZV18fGlbZStuLmxlbmd0aF0+PW5bZV0pdGhyb3cgbmV3IEVycm9yKFwicGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbFwiKX19c3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChlLHQsbixyLG8saSl7aWYoaSl7aWYoby5sZW5ndGghPT0yKihlLmxlbmd0aC0yKSl0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2YgcGFkcyBzaG91bGQgYmUgdHdpY2UgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYodC5sZW5ndGghPT1lLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzdHJpZGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZihyLmxlbmd0aCE9PWUubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2ZvcihsZXQgYT0wO2E8ZS5sZW5ndGgtMjthKyspZy5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZShlW2ErMl0sdFthXSxuW2FdLHJbYV0sbyxhLGErZS5sZW5ndGgtMixpKX19c3RhdGljIGNvbXB1dGVQb29sT3V0cHV0U2hhcGUoZSx0LG4scixvLGksYSl7aWYodC5sZW5ndGg8PTApdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hhcGUgbXVzdCBiZSBvZiBzaXplIGdyZWF0ZXIgdGhhbiAwXCIpO2NvbnN0IHM9W3RbMF0sdFsxXV07cmV0dXJuIGcuY29tcHV0ZVNoYXBlSGVscGVyKGUsdCxzLG4scixvLGksYSksc31zdGF0aWMgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZShlLHQsbixyLG8saSxhKXtpZihlLmxlbmd0aDw9MHx8dC5sZW5ndGg8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgZGltcyBvciBpbnZhbGlkIGZpbHRlciB0ZW5zb3IgZGltc1wiKTtjb25zdCBzPVtlWzBdLHRbMF1dO3JldHVybiBnLmNvbXB1dGVTaGFwZUhlbHBlcighMSxlLHMsbixyLG8saSxhKSxzfXN0YXRpYyBjb21wdXRlU2hhcGVIZWxwZXIoZSx0LG4scixvLGksYSxzKXtpZihlKWZvcihsZXQgZT0wO2U8dC5sZW5ndGgtMjtlKyspbi5wdXNoKDEpO2Vsc2UgZm9yKGxldCBlPTA7ZTx0Lmxlbmd0aC0yO2UrKyluLnB1c2goZy5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0W2UrMl0scltlXSxvW2VdLGlbZV0sYSxlLGUrdC5sZW5ndGgtMixzKSl9c3RhdGljIGFkanVzdFBhZEFuZFJldHVyblNoYXBlKGUsdCxuLHIsbyxpLGEscyl7Y29uc3QgdT1uKihyLTEpKzE7aWYoIXN8fFwiTk9UU0VUXCI9PT1zKXJldHVybiBNYXRoLmZsb29yKChlK29baV0rb1thXS11KS90KzEpO3N3aXRjaChzKXtjYXNlXCJWQUxJRFwiOnJldHVybiBvW2ldPTAsb1thXT0wLE1hdGguZmxvb3IoKGUtdSkvdCsxKTtjYXNlXCJTQU1FX0xPV0VSXCI6Y2FzZVwiU0FNRV9VUFBFUlwiOmlmKDEhPT1uKXRocm93IG5ldyBFcnJvcihcIkRpbGF0aW9uIG5vdCBzdXBwb3J0ZWQgZm9yIFNBTUVfVVBQRVIgb3IgU0FNRV9MT1dFUlwiKTt7Y29uc3Qgbj0oKGUrdC0xKS90LTEpKnQrci1lO3JldHVybiBvW2ldPVwiU0FNRV9MT1dFUlwiPT09cz9NYXRoLmZsb29yKChuKzEpLzIpOk1hdGguZmxvb3Iobi8yKSxvW2FdPW4tb1tpXSxNYXRoLmZsb29yKChlK24tcikvdCsxKX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIEF1dG9QYWQgdHlwZVwiKX19fXQuUG9vbENvbnZVdGlsPWcsdC5NSU5fQ0xJUD0tMzQwMjgyMzQ2NjM4NTI4ODZlMjIsdC5NQVhfQ0xJUD0zNDAyODIzNDY2Mzg1Mjg4NmUyMix0LmRlY29kZVV0ZjhTdHJpbmc9ZnVuY3Rpb24oZSl7cmV0dXJuKG5ldyBUZXh0RGVjb2RlcikuZGVjb2RlKGUpfX0sMzgzODooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5XZWJHcHVCYWNrZW5kPXZvaWQgMDtjb25zdCByPW4oODQ1Myksbz1uKDQ5NTUpLGk9big3NzcxKSxhPW4oODUxMCkscz1uKDgzMDUpO3QuV2ViR3B1QmFja2VuZD1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuY3VycmVudEtlcm5lbElkPW51bGwsdGhpcy5jb21tYW5kRW5jb2Rlcj1udWxsLHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPW51bGwsdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI9MCx0aGlzLnByb2ZpbGluZ0VuYWJsZWQ9ITF9Z2V0IGN1cnJlbnRLZXJuZWxDdXN0b21EYXRhKCl7aWYobnVsbD09PXRoaXMuY3VycmVudEtlcm5lbElkKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRLZXJuZWxDdXN0b21EYXRhKCk6IGN1cnJlbnRLZXJuZWxJZCBpcyBudWxsLiAoc2hvdWxkIG5vdCBoYXBwZW4pXCIpO2xldCBlPXRoaXMua2VybmVsQ3VzdG9tRGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO3JldHVybiBlfHwoZT17fSx0aGlzLmtlcm5lbEN1c3RvbURhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkLGUpKSxlfWFzeW5jIGluaXRpYWxpemUoKXtpZighbmF2aWdhdG9yLmdwdSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHcHVCYWNrZW5kOiBXZWJHUFUgaXMgbm90IGF2YWlsYWJsZS5cIik7Y29uc3QgZT1hd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKCk7aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiV2ViR3B1QmFja2VuZDogRmFpbGVkIHRvIGdldCBHUFUgYWRhcHRlci5cIik7Y29uc3QgdD17cmVxdWlyZWRMaW1pdHM6e21heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZTplLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUsbWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb246ZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb24sbWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplOmUubGltaXRzLm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZX19O2UuZmVhdHVyZXMuaGFzKFwidGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXNcIikmJlwiZGVmYXVsdFwiPT09ci5lbnYud2ViZ3B1LnByb2ZpbGluZ01vZGUmJih0aGlzLnByb2ZpbGluZ0VuYWJsZWQ9ITAsdC5yZXF1aXJlZEZlYXR1cmVzPVtcInRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzXCJdKSx0aGlzLmRldmljZT1hd2FpdCBlLnJlcXVlc3REZXZpY2UodCksdGhpcy5ncHVEYXRhTWFuYWdlcj0oMCxpLmNyZWF0ZUdwdURhdGFNYW5hZ2VyKSh0aGlzKSx0aGlzLnByb2dyYW1NYW5hZ2VyPW5ldyBzLlByb2dyYW1NYW5hZ2VyKHRoaXMpLHRoaXMua2VybmVscz1uZXcgTWFwLHRoaXMua2VybmVsUGVyc2lzdGVudERhdGE9bmV3IE1hcCx0aGlzLmtlcm5lbEN1c3RvbURhdGE9bmV3IE1hcCx0aGlzLmRldmljZS5vbnVuY2FwdHVyZWRlcnJvcj1lPT57ZS5lcnJvciBpbnN0YW5jZW9mIEdQVVZhbGlkYXRpb25FcnJvciYmY29uc29sZS5lcnJvcihgQW4gdW5jYXVnaHQgV2ViR1BVIHZhbGlkYXRpb24gZXJyb3Igd2FzIHJhaXNlZDogJHtlLmVycm9yLm1lc3NhZ2V9YCl9LHRoaXMucHJvZmlsaW5nRW5hYmxlZCYmKHRoaXMucHJvZmlsaW5nUXVlcnlTZXQ9dGhpcy5kZXZpY2UuY3JlYXRlUXVlcnlTZXQoe3R5cGU6XCJ0aW1lc3RhbXBcIixjb3VudDoyfSkpfWRpc3Bvc2UoKXt9Z2V0Q29tbWFuZEVuY29kZXIoKXtyZXR1cm4gdGhpcy5jb21tYW5kRW5jb2Rlcnx8KHRoaXMuY29tbWFuZEVuY29kZXI9dGhpcy5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKSksdGhpcy5jb21tYW5kRW5jb2Rlcn1nZXRDb21wdXRlUGFzc0VuY29kZXIoKXtyZXR1cm4gdGhpcy5jb21wdXRlUGFzc0VuY29kZXJ8fCh0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj10aGlzLmdldENvbW1hbmRFbmNvZGVyKCkuYmVnaW5Db21wdXRlUGFzcygpKSx0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcn1lbmRDb21wdXRlUGFzcygpe3RoaXMuY29tcHV0ZVBhc3NFbmNvZGVyJiYodGhpcy5jb21wdXRlUGFzc0VuY29kZXIuZW5kKCksdGhpcy5jb21wdXRlUGFzc0VuY29kZXI9bnVsbCl9Zmx1c2goKXt0aGlzLmVuZENvbXB1dGVQYXNzKCksdGhpcy5kZXZpY2UucXVldWUuc3VibWl0KFt0aGlzLmdldENvbW1hbmRFbmNvZGVyKCkuZmluaXNoKCldKSx0aGlzLmdwdURhdGFNYW5hZ2VyLnJlZnJlc2hQZW5kaW5nQnVmZmVycygpLHRoaXMuY29tbWFuZEVuY29kZXI9bnVsbCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj0wfXJ1bihlLHQsbixyLGkpe2lmKHQubGVuZ3RoIT09ZS5pbnB1dFR5cGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYElucHV0IHNpemUgbXVzdCBiZSBlcXVhbCB0byAke2UuaW5wdXRUeXBlcy5sZW5ndGh9LmApO2NvbnN0IGE9W107Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDsrK2Upe2NvbnN0IG49dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQodFtlXS5kYXRhKTtpZighbil0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBpbnB1dDogJHt0W2VdLmRhdGF9YCk7YVtlXT1ufWNvbnN0IHM9KChlLHQsbik9Pntjb25zdCByPXQubWFwKChlPT5gJHtlLmpvaW4oXCIsXCIpfWApKS5qb2luKFwiX1wiKSxvPW4uam9pbihcIl9cIik7bGV0IGk9ZS5uYW1lO3JldHVybiBlLmNhY2hlSGludCYmKGkrPVwiW1wiK2UuY2FjaGVIaW50K1wiXVwiKSxpKz1cIjpcIityK1wiO1wiK28saX0pKGUsdC5tYXAoKGU9PmUuZGltcykpLGEubWFwKChlPT5lLnR5cGUpKSk7bGV0IHU9dGhpcy5wcm9ncmFtTWFuYWdlci5nZXRBcnRpZmFjdChzKTtjb25zdCBsPXU/dS5wcm9ncmFtSW5mbzpcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmdldD9lLmdldCgpOmUsYz0wPT09bi5sZW5ndGg/bC5vdXRwdXRzLm1hcCgoKGUsdCk9PnQpKTpuO2lmKGMubGVuZ3RoIT09bC5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYE91dHB1dCBzaXplICR7Yy5sZW5ndGh9IG11c3QgYmUgZXF1YWwgdG8gJHtsLm91dHB1dHMubGVuZ3RofS5gKTtjb25zdCBwPVtdLGQ9W107Zm9yKGxldCBlPTA7ZTxsLm91dHB1dHMubGVuZ3RoOysrZSl7aWYoIU51bWJlci5pc0ludGVnZXIoY1tlXSl8fGNbZV08LTJ8fGNbZV0+PWwub3V0cHV0cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG91dHB1dCBpbmRleDogJHtjW2VdfWApO2NvbnN0IHQ9LTE9PT1jW2VdLG49LTI9PT1jW2VdLG89dHx8bj9pKGwub3V0cHV0c1tlXS5kYXRhVHlwZSxsLm91dHB1dHNbZV0uZGltcyk6cihjW2VdLGwub3V0cHV0c1tlXS5kYXRhVHlwZSxsLm91dHB1dHNbZV0uZGltcyksYT10aGlzLmdwdURhdGFNYW5hZ2VyLmdldChvLmRhdGEpO2lmKCFhKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIG91dHB1dDogJHtvLmRhdGF9YCk7aWYodCYmdGhpcy50ZW1wb3JhcnlEYXRhLnB1c2goYSksbil7bGV0IGU9dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO2V8fChlPVtdLHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkLGUpKSxlLnB1c2goYSl9cC5wdXNoKG8pLGQucHVzaChhKX1jb25zdCBmPXRoaXMucHJvZ3JhbU1hbmFnZXIubm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUobC5kaXNwYXRjaEdyb3VwKHQpKTtyZXR1cm4gdXx8KHU9dGhpcy5wcm9ncmFtTWFuYWdlci5idWlsZChsLGYpLHRoaXMucHJvZ3JhbU1hbmFnZXIuc2V0QXJ0aWZhY3Qocyx1KSksKDAsby5MT0dfREVCVUcpKFwiaW5mb1wiLCgoKT0+YFtQcm9ncmFtTWFuYWdlcl0gcnVuIFwiJHtsLm5hbWV9XCIgKGtleT0ke3N9KSB3aXRoICR7ZlswXX14JHtmWzFdfXgke2ZbMl19YCkpLHRoaXMucHJvZ3JhbU1hbmFnZXIucnVuKHUsYSxkLGYpLHB9dXBsb2FkKGUsdCl7dGhpcy5ncHVEYXRhTWFuYWdlci51cGxvYWQoZSx0KX1tZW1jcHkoZSx0KXt0aGlzLmdwdURhdGFNYW5hZ2VyLm1lbWNweShlLHQpfWFzeW5jIGRvd25sb2FkKGUsdCl7Y29uc3Qgbj1hd2FpdCB0aGlzLmdwdURhdGFNYW5hZ2VyLmRvd25sb2FkKGUpO3QoKS5zZXQobmV3IFVpbnQ4QXJyYXkobikpfWFsbG9jKGUpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShlKS5pZH1mcmVlKGUpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoZSl9Y3JlYXRlS2VybmVsKGUsdCxuKXtjb25zdCByPWEuV0VCR1BVX09QX1JFU09MVkVfUlVMRVMuZ2V0KGUpO2lmKCFyKXRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBpbXBsZW1lbnRlZDogJHtlfWApO3RoaXMua2VybmVscy5zZXQodCxbZSxyWzBdLFtyWzFdLG5dXSl9cmVsZWFzZUtlcm5lbChlKXtjb25zdCB0PXRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KGUpO2lmKHQpe2Zvcihjb25zdCBlIG9mIHQpdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKGUuaWQpO3RoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZGVsZXRlKGUpfXRoaXMua2VybmVsQ3VzdG9tRGF0YS5kZWxldGUoZSksdGhpcy5rZXJuZWxzLmRlbGV0ZShlKX1jb21wdXRlS2VybmVsKGUsdCl7Y29uc3Qgbj10aGlzLmtlcm5lbHMuZ2V0KGUpO2lmKCFuKXRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBjcmVhdGVkOiAke2V9YCk7Y29uc3RbcixpLGFdPW47aWYobnVsbCE9PXRoaXMuY3VycmVudEtlcm5lbElkKXRocm93IG5ldyBFcnJvcihga2VybmVsIFwiJHtyfVwiIGlzIG5vdCBhbGxvd2VkIHRvIGJlIGNhbGxlZCByZWN1cnNpdmVseWApO3RoaXMuY3VycmVudEtlcm5lbElkPWUsYVswXSYmKGFbMV09YVswXShhWzFdKSxhWzBdPXZvaWQgMCksKDAsby5MT0dfREVCVUcpKFwiaW5mb1wiLCgoKT0+YFtXZWJHUFVdIFN0YXJ0IHRvIHJ1biBrZXJuZWwgXCIke3J9XCIuLi5gKSksdGhpcy50ZW1wb3JhcnlEYXRhPVtdO3RyeXtyZXR1cm4gaSh0LGFbMV0pLDB9Y2F0Y2goZSl7cmV0dXJuKDAsby5MT0dfREVCVUcpKFwid2FybmluZ1wiLGBbV2ViR1BVXSBLZXJuZWwgXCIke3J9XCIgZmFpbGVkLiBFcnJvcjogJHtlfWApLDF9ZmluYWxseXtmb3IoY29uc3QgZSBvZiB0aGlzLnRlbXBvcmFyeURhdGEpdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKGUuaWQpO3RoaXMudGVtcG9yYXJ5RGF0YT1bXSx0aGlzLmN1cnJlbnRLZXJuZWxJZD1udWxsfX19fSw3Njc1OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmluaXQ9dm9pZCAwO2NvbnN0IHI9big3OTE3KSxvPW4oMzgzOCksaT1uKDQ5NTUpLGE9big2OTUyKTtjbGFzcyBze2NvbnN0cnVjdG9yKGUsdCxuLHIpe3RoaXMubW9kdWxlPWUsdGhpcy5kYXRhVHlwZT10LHRoaXMuZGF0YT1uLHRoaXMuZGltcz1yfWdldEZsb2F0MzJBcnJheSgpe3JldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsYS5TaGFwZVV0aWwuc2l6ZSh0aGlzLmRpbXMpKX1yZXNoYXBlKGUpe2lmKGEuU2hhcGVVdGlsLnNpemUoZSkhPT1hLlNoYXBlVXRpbC5zaXplKHRoaXMuZGltcykpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBuZXcgc2hhcGVcIik7cmV0dXJuIG5ldyBzKHRoaXMubW9kdWxlLHRoaXMuZGF0YVR5cGUsdGhpcy5kYXRhLGUpfX1jbGFzcyB1e2dldCBjdXN0b21EYXRhKCl7cmV0dXJuIHRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsQ3VzdG9tRGF0YX1jb25zdHJ1Y3RvcihlLHQsbil7dGhpcy5tb2R1bGU9ZSx0aGlzLmJhY2tlbmQ9dDtjb25zdCByPWUuSEVBUFUzMjtsZXQgbz1uPj4yO3RoaXMub3BLZXJuZWxDb250ZXh0PXJbbysrXTtjb25zdCBpPXJbbysrXSxhPVtdO2ZvcihsZXQgdD0wO3Q8aTt0Kyspe2NvbnN0IHQ9cltvKytdLG49cltvKytdLGk9cltvKytdLHU9W107Zm9yKGxldCBlPTA7ZTxpO2UrKyl1LnB1c2gocltvKytdKTthLnB1c2gobmV3IHMoZSx0LG4sdSkpfXRoaXMuaW5wdXRzPWF9Y29tcHV0ZShlLHQpe3ZhciBuLG8saTtjb25zdCB1PW51bGwhPT0obz1udWxsPT09KG49bnVsbD09dD92b2lkIDA6dC5pbnB1dHMpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLm1hcCgoZT0+XCJudW1iZXJcIj09dHlwZW9mIGU/dGhpcy5pbnB1dHNbZV06ZSkpKSYmdm9pZCAwIT09bz9vOnRoaXMuaW5wdXRzLGw9bnVsbCE9PShpPW51bGw9PXQ/dm9pZCAwOnQub3V0cHV0cykmJnZvaWQgMCE9PWk/aTpbXTtyZXR1cm4gdGhpcy5iYWNrZW5kLnJ1bihlLHUsbCwoKGUsdCxuKT0+bmV3IHModGhpcy5tb2R1bGUsdCx0aGlzLm91dHB1dChlLG4pLG4pKSwoKGUsdCk9Pntjb25zdCBuPSgwLHIuZ2V0VGVuc29yRWxlbWVudFNpemUpKGUpO2lmKCFuKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCk7Y29uc3Qgbz1uKmEuU2hhcGVVdGlsLnNpemUodCk7cmV0dXJuIG5ldyBzKHRoaXMubW9kdWxlLGUsdGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShvKS5pZCx0KX0pKX1vdXRwdXQoZSx0KXtjb25zdCBuPXRoaXMubW9kdWxlLnN0YWNrU2F2ZSgpO3RyeXtjb25zdCBuPXRoaXMubW9kdWxlLnN0YWNrQWxsb2MoNCooMSt0Lmxlbmd0aCkpO2xldCByPW4+PjI7dGhpcy5tb2R1bGUuSEVBUFUzMltyKytdPXQubGVuZ3RoO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRoaXMubW9kdWxlLkhFQVBVMzJbcisrXT10W2VdO3JldHVybiB0aGlzLm1vZHVsZS5fSnNlcE91dHB1dCh0aGlzLm9wS2VybmVsQ29udGV4dCxlLG4pfWZpbmFsbHl7dGhpcy5tb2R1bGUuc3RhY2tSZXN0b3JlKG4pfX19dC5pbml0PWFzeW5jIGU9Pntjb25zdCB0PWUuanNlcEluaXQ7aWYodCYmbmF2aWdhdG9yLmdwdSl7Y29uc3Qgbj1uZXcgby5XZWJHcHVCYWNrZW5kO2F3YWl0IG4uaW5pdGlhbGl6ZSgpLHQoe2JhY2tlbmQ6bn0sKGU9Pm4uYWxsb2MoZSkpLChlPT5uLmZyZWUoZSkpLCgodCxyLG8sYT0hMSk9PntpZihhKSgwLGkuTE9HX0RFQlVHKShcInZlcmJvc2VcIiwoKCk9PmBbV2ViR1BVXSBqc2VwQ29weUdwdVRvR3B1OiBzcmM9JHt0fSwgZHN0PSR7cn0sIHNpemU9JHtvfWApKSxuLm1lbWNweSh0LHIpO2Vsc2V7KDAsaS5MT0dfREVCVUcpKFwidmVyYm9zZVwiLCgoKT0+YFtXZWJHUFVdIGpzZXBDb3B5Q3B1VG9HcHU6IGRhdGFPZmZzZXQ9JHt0fSwgZ3B1RGF0YUlkPSR7cn0sIHNpemU9JHtvfWApKTtjb25zdCBhPWUuSEVBUFU4LnN1YmFycmF5KHQsdCtvKTtuLnVwbG9hZChyLGEpfX0pLChhc3luYyh0LHIsbyk9PnsoMCxpLkxPR19ERUJVRykoXCJ2ZXJib3NlXCIsKCgpPT5gW1dlYkdQVV0ganNlcENvcHlHcHVUb0NwdTogZ3B1RGF0YUlkPSR7dH0sIGRhdGFPZmZzZXQ9JHtyfSwgc2l6ZT0ke299YCkpLGF3YWl0IG4uZG93bmxvYWQodCwoKCk9PmUuSEVBUFU4LnN1YmFycmF5KHIscitvKSkpfSksKChlLHQscik9Pm4uY3JlYXRlS2VybmVsKGUsdCxyKSksKGU9Pm4ucmVsZWFzZUtlcm5lbChlKSksKCh0LHIpPT57KDAsaS5MT0dfREVCVUcpKFwidmVyYm9zZVwiLCgoKT0+YFtXZWJHUFVdIGpzZXBSdW46IGtlcm5lbD0ke3R9LCBjb250ZXh0RGF0YU9mZnNldD0ke3J9YCkpO2NvbnN0IG89bmV3IHUoZSxuLHIpO3JldHVybiBuLmNvbXB1dGVLZXJuZWwodCxvKX0pKX19fSw0OTU1OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkxPR19ERUJVRz10LkxPRz12b2lkIDA7Y29uc3Qgcj1uKDg0NTMpLG89big3OTE3KSxpPVtcIlZcIixcIklcIixcIldcIixcIkVcIixcIkZcIl07dC5MT0c9KGUsdCk9Pntjb25zdCBuPSgwLG8ubG9nTGV2ZWxTdHJpbmdUb0VudW0pKGUpO3ZhciBhLHM7bj49KDAsby5sb2dMZXZlbFN0cmluZ1RvRW51bSkoci5lbnYubG9nTGV2ZWwpJiYoYT1uLHM9XCJmdW5jdGlvblwiPT10eXBlb2YgdD90KCk6dCxjb25zb2xlLmxvZyhgWyR7aVthXX0sJHsobmV3IERhdGUpLnRvSVNPU3RyaW5nKCl9XSR7c31gKSl9LHQuTE9HX0RFQlVHPSguLi5lKT0+e3IuZW52LmRlYnVnJiYoMCx0LkxPRykoLi4uZSl9fSw2OTUyOihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NQVhfQ0xJUD10Lk1JTl9DTElQPXQuR2VtbVV0aWw9dC5Qb29sQ29udlV0aWw9dC5TaGFwZVV0aWw9dC5Ccm9hZGNhc3RVdGlsPXQuTWF0TXVsVXRpbD12b2lkIDA7Y2xhc3MgbntzdGF0aWMgY2FsY01hdE11bFNoYXBlKGUsdCl7cmV0dXJuIGVbMV0hPT10WzBdP3ZvaWQgMDpbZVswXSx0WzFdXX19dC5NYXRNdWxVdGlsPW47Y2xhc3MgcntzdGF0aWMgY2FsY1NoYXBlKGUsdCxyPSExKXtjb25zdCBvPWUubGVuZ3RoLGk9dC5sZW5ndGg7aWYoMD09PW8pcmV0dXJuIHQ7aWYoMD09PWkpcmV0dXJuIGU7Y29uc3QgYT1NYXRoLm1heChlLmxlbmd0aCx0Lmxlbmd0aCkscz1uZXcgQXJyYXkoYSk7aWYocil7aWYobzwyfHxpPDIpcmV0dXJuO2NvbnN0IHI9bi5jYWxjTWF0TXVsU2hhcGUoW2Vbby0yXSxlW28tMV1dLFt0W2ktMl0sdFtpLTFdXSk7aWYodm9pZCAwPT09cilyZXR1cm47W3NbYS0yXSxzW2EtMV1dPXJ9Zm9yKGxldCBuPXI/MzoxO248PWE7bisrKXtjb25zdCByPW8tbjwwPzE6ZVtvLW5dLHU9aS1uPDA/MTp0W2ktbl07aWYociE9PXUmJnI+MSYmdT4xKXJldHVybjtzW2Etbl09TWF0aC5tYXgocix1KX1yZXR1cm4gc31zdGF0aWMgaXNWYWxpZEJyb2FkY2FzdChlLHQpe2NvbnN0IG49ZS5sZW5ndGgscj10Lmxlbmd0aDtpZihuPnIpcmV0dXJuITE7Zm9yKGxldCBvPTE7bzw9bjtvKyspaWYoMSE9PWVbbi1vXSYmZVtuLW9dIT09dFtyLW9dKXJldHVybiExO3JldHVybiEwfX10LkJyb2FkY2FzdFV0aWw9cjtjbGFzcyBve3N0YXRpYyBzaXplKGUpe3JldHVybiBvLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZSwwLGUubGVuZ3RoKX1zdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24oZSx0KXtpZih0PDB8fHQ+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke3R9IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7ZS5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIG8uZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShlLHQsZS5sZW5ndGgpfXN0YXRpYyBzaXplVG9EaW1lbnNpb24oZSx0KXtpZih0PDB8fHQ+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke3R9IGZvciBzaXplVG9EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke2UubGVuZ3RofSBkaW1lbnNpb25zLmApO3JldHVybiBvLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZSwwLHQpfXN0YXRpYyBnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGUsdCxuKXtsZXQgcj0xO2ZvcihsZXQgbz10O288bjtvKyspe2lmKGVbb108PTApdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGdldCB2YWxpZCBzaXplIGZyb20gc3BlY2lmaWVkIGRpbWVuc2lvbiByYW5nZS4gTW9zdCBsaWtlbHkgdGhlIHJhbmdlIGNvbnRhaW5zIDAgb3IgbmVnYXRpdmUgdmFsdWVzIGluIHRoZW0uXCIpO3IqPWVbb119cmV0dXJuIHJ9c3RhdGljIGNvbXB1dGVTdHJpZGVzKGUpe2NvbnN0IHQ9ZS5sZW5ndGg7aWYoMD09PXQpcmV0dXJuW107aWYoMT09PXQpcmV0dXJuWzFdO2NvbnN0IG49bmV3IEFycmF5KHQpO25bdC0xXT0xLG5bdC0yXT1lW3QtMV07Zm9yKGxldCByPXQtMztyPj0wOy0tciluW3JdPW5bcisxXSplW3IrMV07cmV0dXJuIG59c3RhdGljIG5vcm1hbGl6ZUF4aXMoZSx0KXtpZihlPC10JiZlPj10KXRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGF4aXMgZm9yIHRoaXMgb3BlcmF0aW9uLlwiKTtyZXR1cm4gZTwwP2UrdDplfXN0YXRpYyBub3JtYWxpemVBeGVzKGUsdCl7cmV0dXJuIGUubWFwKChuPT50aGlzLm5vcm1hbGl6ZUF4aXMobixudWxsIT10P3Q6ZS5sZW5ndGgpKSl9c3RhdGljIHNvcnRCYXNlZE9uUGVybShlLHQpe3JldHVybiB0P3QubWFwKCh0PT5lW3RdKSk6ZS5zbGljZSgpLnJldmVyc2UoKX1zdGF0aWMgcGFkU2hhcGUoZSx0KXtjb25zdCBuPWUubGVuZ3RoO3JldHVybiBlLm1hcCgoKGUscik9PmUrdFtyXSt0W3Irbl0pKX1zdGF0aWMgYXJlRXF1YWwoZSx0KXtyZXR1cm4gZS5sZW5ndGg9PT10Lmxlbmd0aCYmZS5ldmVyeSgoKGUsbik9PmU9PT10W25dKSl9fXQuU2hhcGVVdGlsPW87Y2xhc3MgaXtzdGF0aWMgYWRqdXN0UG9vbEF0dHJpYnV0ZXMoZSx0LG4scixvLGkpe2lmKCFlJiZuLmxlbmd0aCE9PXQubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9uc1wiKTtpZihlKWZvcihsZXQgZT0wO2U8dC5sZW5ndGgtMjtlKyspZT49bi5sZW5ndGg/bi5wdXNoKHRbZSsyXSk6bltlXT10W2UrMl07Zm9yKGxldCBlPTA7ZTxuLmxlbmd0aDtlKyspaWYoZTxyLmxlbmd0aCl7aWYocltlXTwwKXRocm93IG5ldyBFcnJvcihcInN0cmlkZXMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugci5wdXNoKDEpO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGg7ZSsrKWlmKGU8by5sZW5ndGgpe2lmKG9bZV08MCl0aHJvdyBuZXcgRXJyb3IoXCJkaWxhdGlvbnMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugby5wdXNoKDEpO2ZvcihsZXQgZT0wO2U8MipuLmxlbmd0aDtlKyspaWYoZTxpLmxlbmd0aCl7aWYoaVtlXTwwKXRocm93IG5ldyBFcnJvcihcInBhZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBpLnB1c2goMCk7Zm9yKGxldCBlPTA7ZTxuLmxlbmd0aDtlKyspe2lmKG5bZV08PTApdGhyb3cgbmV3IEVycm9yKFwia2VybmVsIHNoYXBlcyBuZWVkIHRvIGJlIGdyZWF0ZXIgdGhhbiAwXCIpO2lmKGlbZV0+PW5bZV18fGlbZStuLmxlbmd0aF0+PW5bZV0pdGhyb3cgbmV3IEVycm9yKFwicGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbFwiKX19c3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChlLHQsbixyLG8sYSxzKXtpZihzKXtpZihvLmxlbmd0aCE9PTIqKGUubGVuZ3RoLTIpKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBwYWRzIHNob3VsZCBiZSB0d2ljZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHN0cmlkZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKHIubGVuZ3RoIT09ZS5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Yga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7Zm9yKGxldCB1PTA7dTxlLmxlbmd0aC0yO3UrKylpLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKGVbdSsoYT8xOjIpXSx0W3VdLG5bdV0sclt1XSxvLHUsdStlLmxlbmd0aC0yLHMpfX1zdGF0aWMgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShlLHQsbixyLG8sYSxzKXtpZih0Lmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaGFwZSBtdXN0IGJlIG9mIHNpemUgZ3JlYXRlciB0aGFuIDBcIik7Y29uc3QgdT1bdFswXSx0WzFdXTtyZXR1cm4gaS5jb21wdXRlU2hhcGVIZWxwZXIoZSx0LHUsbixyLG8sYSxzKSx1fXN0YXRpYyBjb21wdXRlQ29udk91dHB1dFNoYXBlKGUsdCxuLHIsbyxhLHMpe2lmKGUubGVuZ3RoPD0wfHx0Lmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHRlbnNvciBkaW1zIG9yIGludmFsaWQgZmlsdGVyIHRlbnNvciBkaW1zXCIpO2NvbnN0IHU9W2VbMF0sdFswXV07cmV0dXJuIGkuY29tcHV0ZVNoYXBlSGVscGVyKCExLGUsdSxuLHIsbyxhLHMpLHV9c3RhdGljIGNvbXB1dGVTaGFwZUhlbHBlcihlLHQsbixyLG8sYSxzLHUpe2lmKGUpZm9yKGxldCBlPTA7ZTx0Lmxlbmd0aC0yO2UrKyluLnB1c2goMSk7ZWxzZSBmb3IobGV0IGU9MDtlPHQubGVuZ3RoLTI7ZSsrKW4ucHVzaChpLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKHRbZSsyXSxyW2VdLG9bZV0sYVtlXSxzLGUsZSt0Lmxlbmd0aC0yLHUpKX1zdGF0aWMgYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoZSx0LG4scixvLGksYSxzKXtjb25zdCB1PW4qKHItMSkrMTtpZighc3x8XCJOT1RTRVRcIj09PXMpcmV0dXJuIE1hdGguZmxvb3IoKGUrb1tpXStvW2FdLXUpL3QrMSk7c3dpdGNoKHMpe2Nhc2VcIlZBTElEXCI6cmV0dXJuIG9baV09MCxvW2FdPTAsTWF0aC5mbG9vcigoZS11KS90KzEpO2Nhc2VcIlNBTUVfTE9XRVJcIjpjYXNlXCJTQU1FX1VQUEVSXCI6aWYoMSE9PW4pdGhyb3cgbmV3IEVycm9yKFwiRGlsYXRpb24gbm90IHN1cHBvcnRlZCBmb3IgU0FNRV9VUFBFUiBvciBTQU1FX0xPV0VSXCIpO3tjb25zdCBuPSgoZSt0LTEpL3QtMSkqdCtyLWU7cmV0dXJuIG9baV09XCJTQU1FX0xPV0VSXCI9PT1zP01hdGguZmxvb3IoKG4rMSkvMik6TWF0aC5mbG9vcihuLzIpLG9bYV09bi1vW2ldLE1hdGguZmxvb3IoKGUrbi1yKS90KzEpfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlXCIpfX19dC5Qb29sQ29udlV0aWw9aSx0LkdlbW1VdGlsPWNsYXNze3N0YXRpYyBnZXRTaGFwZU9mR2VtbVJlc3VsdChlLHQsbixvLGkpe2lmKDIhPT1lLmxlbmd0aHx8MiE9PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNoYXBlIG5lZWQgdG8gYmUgb2Ygc2l6ZSAyXCIpO2xldCBhLHMsdTt0PyhhPWVbMV0scz1lWzBdKTooYT1lWzBdLHM9ZVsxXSk7bGV0IGw9LTE7aWYobz8odT1uWzBdLGw9MSk6KHU9blsxXSxsPTApLG5bbF0hPT1zKXRocm93IG5ldyBFcnJvcihcImRpbWVuc2lvbiBtaXNtYXRjaFwiKTtpZihhPD0wfHx1PD0wfHxzPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2hhcGUgc3BlY2lmaWVkXCIpO2lmKGkmJiFyLmlzVmFsaWRCcm9hZGNhc3QoaSxbYSx1XSkpdGhyb3cgbmV3IEVycm9yKFwiZ2VtbTogaW52YWxpZCBiaWFzIHNoYXBlIGZvciBicm9hZGNhc3RcIik7cmV0dXJuW2EsdSxzXX19LHQuTUlOX0NMSVA9LTM0MDI4MjM0NjYzODUyODg2ZTIyLHQuTUFYX0NMSVA9MzQwMjgyMzQ2NjM4NTI4ODZlMjJ9LDM4NzooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5PXZvaWQgMDtjbGFzcyBue2NvbnN0cnVjdG9yKGUpe09iamVjdC5hc3NpZ24odGhpcyxlKX1nZXQgY2FjaGVLZXkoKXtyZXR1cm4gdGhpcy5fY2FjaGVLZXl8fCh0aGlzLl9jYWNoZUtleT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKS5zb3J0KCkubWFwKChlPT5gJHt0aGlzW2VdfWApKS5qb2luKFwiO1wiKSksdGhpcy5fY2FjaGVLZXl9fXQuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5PWU9Pm5ldyBuKGUpfSw3NzcxOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNyZWF0ZUdwdURhdGFNYW5hZ2VyPXZvaWQgMDtjb25zdCByPW4oNDk1NSksbz1uKDExNjMpLGk9ZT0+MTYqTWF0aC5jZWlsKGUvMTYpO2xldCBhPTA7Y2xhc3Mgc3tjb25zdHJ1Y3RvcihlKXt0aGlzLmJhY2tlbmQ9ZSx0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwLHRoaXMuZG93bmxvYWRDYWNoZT1uZXcgTWFwLHRoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmc9W10sdGhpcy5idWZmZXJzUGVuZGluZz1bXX11cGxvYWQoZSx0KXtjb25zdCBuPXQuYnVmZmVyLG89dC5ieXRlT2Zmc2V0LGE9dC5ieXRlTGVuZ3RoLHM9aShhKSx1PXRoaXMuc3RvcmFnZUNhY2hlLmdldChlKTtpZighdSl0aHJvdyBuZXcgRXJyb3IoXCJncHUgZGF0YSBmb3IgdXBsb2FkaW5nIGRvZXMgbm90IGV4aXN0XCIpO2lmKHUub3JpZ2luYWxTaXplIT09YSl0aHJvdyBuZXcgRXJyb3IoYGluY29uc2lzdGVudCBkYXRhIHNpemUuIGdwdSBkYXRhIHNpemU9JHt1Lm9yaWdpbmFsU2l6ZX0sIGRhdGEgc2l6ZT0ke2F9YCk7Y29uc3QgbD10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7bWFwcGVkQXRDcmVhdGlvbjohMCxzaXplOnMsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuTUFQX1dSSVRFfEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfSksYz1sLmdldE1hcHBlZFJhbmdlKCk7bmV3IFVpbnQ4QXJyYXkoYykuc2V0KG5ldyBVaW50OEFycmF5KG4sbyxhKSksbC51bm1hcCgpO2NvbnN0IHA9dGhpcy5iYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCk7dGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCkscC5jb3B5QnVmZmVyVG9CdWZmZXIobCwwLHUuZ3B1RGF0YS5idWZmZXIsMCxzKSwoMCxyLkxPR19ERUJVRykoXCJ2ZXJib3NlXCIsKCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudXBsb2FkKGlkPSR7ZX0pYCkpLHRoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmcucHVzaChsKX1tZW1jcHkoZSx0KXtjb25zdCBuPXRoaXMuc3RvcmFnZUNhY2hlLmdldChlKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2UgZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdFwiKTtjb25zdCByPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJkZXN0aW5hdGlvbiBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0XCIpO2lmKG4ub3JpZ2luYWxTaXplIT09ci5vcmlnaW5hbFNpemUpdGhyb3cgbmV3IEVycm9yKFwiaW5jb25zaXN0ZW50IHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZ3B1IGRhdGEgc2l6ZVwiKTtjb25zdCBvPWkobi5vcmlnaW5hbFNpemUpO3RoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpLmNvcHlCdWZmZXJUb0J1ZmZlcihuLmdwdURhdGEuYnVmZmVyLDAsci5ncHVEYXRhLmJ1ZmZlciwwLG8pfWNyZWF0ZShlLHQ9R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRXxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ3xHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCl7Y29uc3Qgbj1pKGUpLHM9dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6bix1c2FnZTp0fSksdT17aWQ6YSsrLHR5cGU6by5HcHVEYXRhVHlwZS5kZWZhdWx0LGJ1ZmZlcjpzfTtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KHUuaWQse2dwdURhdGE6dSxvcmlnaW5hbFNpemU6ZX0pLCgwLHIuTE9HX0RFQlVHKShcInZlcmJvc2VcIiwoKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5jcmVhdGUoc2l6ZT0ke2V9KSA9PiBpZD0ke3UuaWR9YCkpLHV9Z2V0KGUpe3ZhciB0O3JldHVybiBudWxsPT09KHQ9dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KGUpKXx8dm9pZCAwPT09dD92b2lkIDA6dC5ncHVEYXRhfXJlbGVhc2UoZSl7Y29uc3QgdD10aGlzLnN0b3JhZ2VDYWNoZS5nZXQoZSk7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwicmVsZWFzaW5nIGRhdGEgZG9lcyBub3QgZXhpc3RcIik7cmV0dXJuKDAsci5MT0dfREVCVUcpKFwidmVyYm9zZVwiLCgoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoaWQ9JHtlfSksIGdwdURhdGFJZD0ke3QuZ3B1RGF0YS5pZH1gKSksdGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKGUpLHRoaXMuYnVmZmVyc1BlbmRpbmcucHVzaCh0LmdwdURhdGEuYnVmZmVyKSx0aGlzLmRvd25sb2FkQ2FjaGUuZ2V0KGUpJiZ0aGlzLmRvd25sb2FkQ2FjaGUuZGVsZXRlKGUpLHQub3JpZ2luYWxTaXplfWFzeW5jIGRvd25sb2FkKGUpe2NvbnN0IHQ9dGhpcy5kb3dubG9hZENhY2hlLmdldChlKTtpZih0KXJldHVybiB0LmRhdGE7Y29uc3Qgbj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiZGF0YSBkb2VzIG5vdCBleGlzdFwiKTtjb25zdCByPXRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO3RoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpO2NvbnN0IG89dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6bi5vcmlnaW5hbFNpemUsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUR9KTtyLmNvcHlCdWZmZXJUb0J1ZmZlcihuLmdwdURhdGEuYnVmZmVyLDAsbywwLG4ub3JpZ2luYWxTaXplKSx0aGlzLmJhY2tlbmQuZmx1c2goKTtjb25zdCBpPW5ldyBQcm9taXNlKChlPT57by5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpLnRoZW4oKCgpPT57Y29uc3QgdD1vLmdldE1hcHBlZFJhbmdlKCkuc2xpY2UoMCk7by5kZXN0cm95KCksZSh0KX0pKX0pKTtyZXR1cm4gdGhpcy5kb3dubG9hZENhY2hlLnNldChlLHtkYXRhOml9KSxpfXJlZnJlc2hQZW5kaW5nQnVmZmVycygpe2Zvcihjb25zdCBlIG9mIHRoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmcpZS5kZXN0cm95KCk7Zm9yKGNvbnN0IGUgb2YgdGhpcy5idWZmZXJzUGVuZGluZyllLmRlc3Ryb3koKX19dC5jcmVhdGVHcHVEYXRhTWFuYWdlcj0oLi4uZSk9Pm5ldyBzKC4uLmUpfSw4NTEwOmZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG4pO28mJiEoXCJnZXRcImluIG8/IXQuX19lc01vZHVsZTpvLndyaXRhYmxlfHxvLmNvbmZpZ3VyYWJsZSl8fChvPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsbyl9OmZ1bmN0aW9uKGUsdCxuLHIpe3ZvaWQgMD09PXImJihyPW4pLGVbcl09dFtuXX0pLG89dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pfTpmdW5jdGlvbihlLHQpe2UuZGVmYXVsdD10fSksaT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciBuIGluIGUpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxuKSYmcih0LGUsbik7cmV0dXJuIG8odCxlKSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LldFQkdQVV9PUF9SRVNPTFZFX1JVTEVTPXZvaWQgMDtjb25zdCBhPWkobig1MDQpKSxzPW4oOTc3MCksdT1uKDQyNzEpLGw9bigxNTIyKSxjPWkobig1MjYyKSkscD1uKDI2MjUpLGQ9aShuKDkzMDIpKTt0LldFQkdQVV9PUF9SRVNPTFZFX1JVTEVTPW5ldyBNYXAoW1tcIkFic1wiLFtkLmFic11dLFtcIkFjb3NcIixbZC5hY29zXV0sW1wiQWNvc2hcIixbZC5hY29zaF1dLFtcIkFkZFwiLFthLmFkZF1dLFtcIkFzaW5cIixbZC5hc2luXV0sW1wiQXNpbmhcIixbZC5hc2luaF1dLFtcIkF0YW5cIixbZC5hdGFuXV0sW1wiQXRhbmhcIixbZC5hdGFuaF1dLFtcIkF2ZXJhZ2VQb29sXCIsW2MuYXZlcmFnZVBvb2wsYy5wYXJzZUF2ZXJhZ2VQb29sQXR0cmlidXRlc11dLFtcIkNlaWxcIixbZC5jZWlsXV0sW1wiQ2xpcFYxMFwiLFtkLmNsaXBWMTBdXSxbXCJDbGlwXCIsW2QuY2xpcF1dLFtcIkNvbnZcIixbcy5jb252LHMucGFyc2VDb252QXR0cmlidXRlc11dLFtcIkNvc1wiLFtkLmNvc11dLFtcIkNvc2hcIixbZC5jb3NoXV0sW1wiRGl2XCIsW2EuZGl2XV0sW1wiRWx1XCIsW2QuZWx1LGQucGFyc2VBbHBoYUF0dHJpYnV0ZXNdXSxbXCJFcmZcIixbZC5lcmZdXSxbXCJFeHBcIixbZC5leHBdXSxbXCJGbG9vclwiLFtkLmZsb29yXV0sW1wiR2VtbVwiLFt1LmdlbW0sdS5wYXJzZUdlbW1BdHRyaWJ1dGVzXV0sW1wiR2xvYmFsQXZlcmFnZVBvb2xcIixbYy5nbG9iYWxBdmVyYWdlUG9vbCxjLnBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXV0sW1wiR2xvYmFsTWF4UG9vbFwiLFtjLmdsb2JhbE1heFBvb2wsYy5wYXJzZUdsb2JhbE1heFBvb2xBdHRyaWJ1dGVzXV0sW1wiTGVha3lSZWx1XCIsW2QubGVha3lSZWx1LGQucGFyc2VBbHBoYUF0dHJpYnV0ZXNdXSxbXCJNYXRNdWxcIixbbC5tYXRNdWxdXSxbXCJNYXhQb29sXCIsW2MubWF4UG9vbCxjLnBhcnNlTWF4UG9vbEF0dHJpYnV0ZXNdXSxbXCJNdWxcIixbYS5tdWxdXSxbXCJOZWdcIixbZC5uZWddXSxbXCJQb3dcIixbYS5wb3ddXSxbXCJSZWNpcHJvY2FsXCIsW2QucmVjaXByb2NhbF1dLFtcIlJlbHVcIixbZC5yZWx1XV0sW1wiU2lnbW9pZFwiLFtkLnNpZ21vaWRdXSxbXCJTaW5cIixbZC5zaW5dXSxbXCJTaW5oXCIsW2Quc2luaF1dLFtcIlNxcnRcIixbZC5zcXJ0XV0sW1wiU3ViXCIsW2Euc3ViXV0sW1wiVGFuXCIsW2QudGFuXV0sW1wiVGFuaFwiLFtkLnRhbmhdXSxbXCJUaHJlc2hvbGRlZFJlbHVcIixbZC50aHJlc2hvbGRlZFJlbHUsZC5wYXJzZUFscGhhQXR0cmlidXRlc11dLFtcIlRyYW5zcG9zZVwiLFtwLnRyYW5zcG9zZSxwLnBhcnNlVHJhbnNwb3NlQXR0cmlidXRlc11dXSl9LDE0Mjc6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmJpYXNBY3RpdmF0aW9uU25pcHBldD10LmFjdGl2YXRpb25GblNuaXBwZXQ9dC50eXBlU25pcHBldD12b2lkIDAsdC50eXBlU25pcHBldD1lPT57c3dpdGNoKGUpe2Nhc2UgMTpyZXR1cm5cImYzMlwiO2Nhc2UgMjpyZXR1cm5cInZlYzI8ZjMyPlwiO2Nhc2UgMzpyZXR1cm5cInZlYzM8ZjMyPlwiO2Nhc2UgNDpyZXR1cm5cInZlYzQ8ZjMyPlwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGAke2V9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApfX0sdC5hY3RpdmF0aW9uRm5TbmlwcGV0PShlLHQ9ITEsbj0hMSxyPTMpPT5cIlwiLHQuYmlhc0FjdGl2YXRpb25TbmlwcGV0PShlLHQpPT5gXFxuICAgICAgJHtlP1widmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpO1wiOlwiXCJ9XFxuICAgICAgJHt0P1widmFsdWUgPSBhY3RpdmF0aW9uKHZhbHVlLCBjb29yZHMpO1wiOlwiXCJ9XFxuICAgICAgYH0sOTQ1NjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5jcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mbz12b2lkIDA7Y29uc3Qgcj1uKDQ5NTUpLG89big2OTUyKSxpPW4oMTE2MyksYT1uKDE0MjcpLHM9big0MDg1KSx1PW4oMTU4KTt0LmNyZWF0ZUNvbnYyRE1hdE11bFByb2dyYW1JbmZvPShlLHQsbixsLGMscCxkLGYsaCk9Pntjb25zdCBnPVwiTkhXQ1wiPT09bi5mb3JtYXQsbT1nP2VbMF0uZGltc1szXTplWzBdLmRpbXNbMV0sYj1sWzBdLHk9Zz9sWzJdOmxbM10sdz1nP2xbMV06bFsyXSxfPWc/bFszXTpsWzFdLHY9KChtJTQ9PTB8fG0lMz09MCkmJmd8fHklND09MCYmIWcpJiZfJTQ9PTAseD1nP186eSp3LFQ9Zz95Knc6XyxTPXY/WzgsOCwxXTpbeDw9ND80OjE2LHg+NCYmVDw9ND80OjE2LDFdLE89dj9bNCw0LDFdOlt4PD00PzE6Mix4PjQmJlQ8PTQ/MToyLDFdLEE9W01hdGguY2VpbCh4L1NbMF0vT1swXSksTWF0aC5jZWlsKFQvU1sxXS9PWzFdKSxNYXRoLmNlaWwoYi9TWzJdL09bMV0pXTsoMCxyLkxPR19ERUJVRykoXCJ2ZXJib3NlXCIsKCgpPT5gW2NvbnYyZF9tbV93ZWJncHVdIGRpc3BhdGNoID0gJHtBfWApKTtjb25zdCBFPXY/ZyYmbSU0IT0wPzM6NDpPWzBdLEk9U1sxXSpPWzFdLCQ9U1swXSpPWzBdLFA9TWF0aC5tYXgoU1swXSpFLFNbMV0pLEQ9YyVJPT0wLGs9cCUkPT0wLEM9ZCVQPT0wLFI9dj9bRSw0LDRdOlsxLDEsMV0sTT1bYEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4geDogYXJyYXk8JHt2JiY0PT09RT9cInZlYzQ8ZjMyPlwiOlwiZjMyXCJ9PjtgLGBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHc6IGFycmF5PCR7dj9cInZlYzQ8ZjMyPlwiOlwiZjMyXCJ9PjtgXTtsZXQgTj1gXFxuICAgICAgZm4gc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggOiBpMzIsIHZhbHVlIDogJHt2P1widmVjNDxmMzI+XCI6XCJmMzJcIn0pIHtcXG4gICAgICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHt2P1widmVjNDxmMzI+XCI6XCJmMzJcIn0odmFsdWUpO1xcbiAgICAgIH1cXG4gICAgICBmbiBzZXRPdXRwdXRBdENvb3JkcyhkMCA6IGkzMiwgZDEgOiBpMzIsIGQyIDogaTMyLCBkMyA6IGkzMiwgdmFsdWUgOiAke3Y/XCJ2ZWM0PGYzMj5cIjpcImYzMlwifSkge1xcbiAgICAgICAgbGV0IGZsYXRJbmRleCA9IGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyh2ZWM0PGkzMj4oZDAsIGQxLCBkMiwgZDMpKTtcXG4gICAgICAgIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4ICR7dj9cIi8gNFwiOlwiXCJ9LCB2YWx1ZSk7XFxuICAgICAgfWA7cmV0dXJuIGYmJihNLnB1c2goYEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZD4gYmlhczogYXJyYXk8JHt2P1widmVjNDxmMzI+XCI6XCJmMzJcIn0+O2ApLE4rPWBcXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+ICR7dj9cInZlYzQ8ZjMyPlwiOlwiZjMyXCJ9IHtcXG4gICAgICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7Zz9cIndcIjpcInlcIn0ke3Y/XCIvIDRcIjpcIlwifV07XFxuICAgICAgICB9YCksT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXRzOlt7ZGltczpsLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6aS5HcHVEYXRhVHlwZS5kZWZhdWx0fV0sZGlzcGF0Y2hHcm91cDooKT0+KHt4OkFbMF0seTpBWzFdLHo6QVsyXX0pLGdldFNoYWRlclNvdXJjZTooKT0+YFxcbiAgICAgICAgJHtzLnV0aWxGdW5jdGlvbnN9XFxuICAgICAgICAvL3N0cnVjdCBVbmlmb3JtcyB7IHhTaGFwZSA6IHZlYzQ8aTMyPiwgd1NoYXBlIDogdmVjNDxpMzI+LCBvdXRTaGFwZSA6IHZlYzQ8aTMyPixcXG4gICAgICAgIC8vICBvdXRTaGFwZVN0cmlkZXM6IHZlYzM8aTMyPiwgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiwgcGFkIDogdmVjMjxpMzI+LCBzdHJpZGUgOiB2ZWMyPGkzMj4sXFxuICAgICAgICAvLyAgZGlsYXRpb24gOiB2ZWMyPGkzMj4sIGRpbUFPdXRlciA6IGkzMiwgZGltQk91dGVyIDogaTMyLCBkaW1Jbm5lciA6IGkzMiB9O1xcbiAgICAgICAgJHtNLmpvaW4oXCJcIil9XFxuICAgICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtNLmxlbmd0aH0pIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiByZXN1bHQ6IGFycmF5PCR7dj9cInZlYzQ8ZjMyPlwiOlwiZjMyXCJ9PjtcXG4gICAgICAgIC8vQGdyb3VwKDApIEBiaW5kaW5nKCR7TS5sZW5ndGgrMX0pIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7XFxuXFxuICAgICAgICBjb25zdCB4U2hhcGUgOiB2ZWM0PGkzMj4gPSB2ZWM0PGkzMj4oJHtlWzBdLmRpbXMuam9pbihcIixcIil9KTtcXG4gICAgICAgIGNvbnN0IHdTaGFwZSA6IHZlYzQ8aTMyPiA9IHZlYzQ8aTMyPigke2VbMV0uZGltcy5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgY29uc3Qgb3V0U2hhcGUgOiB2ZWM0PGkzMj4gPSB2ZWM0PGkzMj4oJHtsLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCBvdXRTaGFwZVN0cmlkZXMgOiB2ZWMzPGkzMj4gPSB2ZWMzPGkzMj4oJHtvLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhsKS5zbGljZSgwLDMpLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICBjb25zdCBmaWx0ZXJEaW1zIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7bi5rZXJuZWxTaGFwZVswXX0sICR7bi5rZXJuZWxTaGFwZVsxXX0pO1xcbiAgICAgICAgY29uc3QgcGFkIDogdmVjMjxpMzI+ID0gdmVjMjxpMzI+KCR7bi5wYWRzWzBdfSwgJHtuLnBhZHNbMV19KTtcXG4gICAgICAgIGNvbnN0IHN0cmlkZSA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPigke24uc3RyaWRlc1swXX0sICR7bi5zdHJpZGVzWzFdfSk7XFxuICAgICAgICBjb25zdCBkaWxhdGlvbiA6IHZlYzI8aTMyPiA9IHZlYzI8aTMyPigke24uZGlsYXRpb25zWzBdfSwgJHtuLmRpbGF0aW9uc1sxXX0pO1xcbiAgICAgICAgY29uc3QgZGltQU91dGVyIDogaTMyID0gJHtjfTtcXG4gICAgICAgIGNvbnN0IGRpbUJPdXRlciA6IGkzMiA9ICR7cH07XFxuICAgICAgICBjb25zdCBkaW1Jbm5lciA6IGkzMiA9ICR7ZH07XFxuICAgICAgICAke059XFxuICAgICAgICAkeygoZSx0LG4scixvPSExLGkscz0hMSx1PTQsbD00LGM9NCk9Pntjb25zdCBwPWU/XCJcXG4gICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Um93LCB4Q29sLCB4Q2gpO1xcbiAgICBcIjpcIlxcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhDaCwgeFJvdywgeENvbCk7XFxuICAgIFwiLGQ9ZT9cIlxcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxcbiAgICAgIGJhdGNoLFxcbiAgICAgIHJvdyAvIG91dFdpZHRoLFxcbiAgICAgIHJvdyAlIG91dFdpZHRoLFxcbiAgICAgIGNvbCk7XFxuICAgIFwiOlwiXFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXFxuICAgICAgYmF0Y2gsXFxuICAgICAgcm93LFxcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxcbiAgICAgIGNvbCAlIG91dFdpZHRoKTtcXG4gICAgXCIsZj1lP1wieFNoYXBlWzFdXCI6XCJ4U2hhcGVbMl1cIixoPWU/XCJ4U2hhcGVbMl1cIjpcInhTaGFwZVszXVwiLGc9ZT9cInJvd1wiOlwiY29sXCIsbT1lP1wiY29sXCI6XCJyb3dcIixiPWBcXG4gICAgbGV0IGluQ2hhbm5lbHMgPSB3U2hhcGVbMl07XFxuICAgIGxldCBvdXRXaWR0aCA9ICR7ZT9cIm91dFNoYXBlWzJdXCI6XCJvdXRTaGFwZVszXVwifTtcXG4gICAgbGV0IG91dFJvdyA9ICR7Z30gLyBvdXRXaWR0aDtcXG4gICAgbGV0IG91dENvbCA9ICR7Z30gJSBvdXRXaWR0aDtcXG5cXG4gICAgbGV0IFdSb3cgPSAke219IC8gKGZpbHRlckRpbXNbMV0gKiBpbkNoYW5uZWxzKTtcXG4gICAgbGV0IFdDb2wgPSAke219IC8gaW5DaGFubmVscyAlIGZpbHRlckRpbXNbMV07XFxuICAgIGxldCB4Um93ID0gb3V0Um93ICogc3RyaWRlWzBdICsgZGlsYXRpb25bMF0gKiBXUm93IC0gcGFkWzBdO1xcbiAgICBsZXQgeENvbCA9IG91dENvbCAqIHN0cmlkZVsxXSArIGRpbGF0aW9uWzFdICogV0NvbCAtIHBhZFsxXTtcXG4gICAgbGV0IHhDaCA9ICR7bX0gJSBpbkNoYW5uZWxzO1xcbiAgICB2YXIgcmVzRGF0YSA9ICR7KDAsYS50eXBlU25pcHBldCkodSl9KDAuMCk7XFxuICAgIC8vIFRoZSBib3VuZHMgY2hlY2tpbmcgaXMgYWx3YXlzIG5lZWRlZCBzaW5jZSB3ZSB1c2UgaXQgdG8gcGFkIHplcm8gZm9yXFxuICAgIC8vIHRoZSAnc2FtZScgcGFkZGluZyB0eXBlLlxcbiAgICBpZiAoeFJvdyA+PSAwICYmIHhSb3cgPCAke2Z9ICYmIHhDb2wgPj0gMCAmJiB4Q29sIDwgJHtofSkge1xcbiAgICAgICR7cH1cXG4gICAgICBsZXQgeEluZGV4ID0gZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHhTaGFwZSk7XFxuICAgICAgJHsoZT0+e3N3aXRjaChlKXtjYXNlIDE6cmV0dXJuXCJyZXNEYXRhID0geFt4SW5kZXhdO1wiO2Nhc2UgMzpyZXR1cm5cInJlc0RhdGEgPSB2ZWMzPGYzMj4oeFt4SW5kZXhdLCB4W3hJbmRleCArIDFdLCB4W3hJbmRleCArIDJdKTtcIjtjYXNlIDQ6cmV0dXJuXCJyZXNEYXRhID0geFt4SW5kZXggLyA0XTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke2V9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSkodSl9XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc0RhdGE7YCx5PWU/dCYmcj9gXFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7dX07XFxuICAgICR7Yn1gOmBcXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHt1fTtcXG4gICAgaWYgKHJvdyA8IGRpbUFPdXRlciAmJiBjb2wgPCBkaW1Jbm5lcikge1xcbiAgICAgICR7Yn1cXG4gICAgfVxcbiAgICByZXR1cm4gJHsoMCxhLnR5cGVTbmlwcGV0KSh1KX0oMC4wKTtgOnImJm4/YFxcbiAgICBsZXQgY29sID0gY29sSW4gKiAke3V9O1xcbiAgICAke2J9YDpgXFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7dX07XFxuICAgIGlmIChyb3cgPCBkaW1Jbm5lciAmJiBjb2wgPCBkaW1CT3V0ZXIpIHtcXG4gICAgICAke2J9XFxuICAgIH1cXG4gICAgcmV0dXJuICR7KDAsYS50eXBlU25pcHBldCkodSl9KDAuMCk7YCx3PWAkeyhlPT57c3dpdGNoKGUpe2Nhc2UgMTpyZXR1cm5cInJldHVybiB3W3JvdyAqIHdTaGFwZVszXSArIGNvbEluXTtcIjtjYXNlIDQ6cmV0dXJuXCJyZXR1cm4gd1tyb3cgKiB3U2hhcGVbM10gLyA0ICsgY29sSW5dO1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7ZX0gaXMgbm90IHN1cHBvcnRlZC5gKX19KShsKX1gLF89KDAsYS50eXBlU25pcHBldCkoYyksdj1lPygwLGEudHlwZVNuaXBwZXQpKHUpOigwLGEudHlwZVNuaXBwZXQpKGwpLHg9ZT8oMCxhLnR5cGVTbmlwcGV0KShsKTooMCxhLnR5cGVTbmlwcGV0KSh1KTtyZXR1cm5gXFxuICAgICR7KDAsYS5hY3RpdmF0aW9uRm5TbmlwcGV0KShpLHMsND09PWMsNCl9XFxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7dn0ge1xcbiAgICAgICR7ZT95Ond9XFxuICAgIH1cXG5cXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHt4fSB7XFxuICAgICAgJHtlP3c6eX1cXG4gICAgfVxcblxcbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyLCB2YWx1ZUluIDogJHtffSkge1xcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7Y307XFxuICAgICAgaWYgKHJvdyA8IGRpbUFPdXRlciAmJiBjb2wgPCBkaW1CT3V0ZXIpXFxuICAgICAge1xcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XFxuICAgICAgbGV0IG91dFdpZHRoID0gJHtlP1wib3V0U2hhcGVbMl1cIjpcIm91dFNoYXBlWzNdXCJ9O1xcbiAgICAgICR7ZH1cXG4gICAgICAkeygwLGEuYmlhc0FjdGl2YXRpb25TbmlwcGV0KShvLGkpfVxcbiAgICAgIHNldE91dHB1dEF0Q29vcmRzKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIGNvb3Jkc1szXSwgdmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfWB9KShnLEQsayxDLGYsdm9pZCAwLCExLFJbMF0sUlsxXSxSWzJdKX1cXG4gICAgICAgICAgICAke3Y/KDAsdS5tYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZSkoTyxTLCFnLFApOigwLHUubWFrZU1hdE11bFBhY2tlZFNvdXJjZSkoTyxTLCFnLFAsITEsdm9pZCAwLGgpfWB9KX19LDQwODU6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnV0aWxGdW5jdGlvbnM9dm9pZCAwLHQudXRpbEZ1bmN0aW9ucz1cIlxcbmZuIGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcyA6IHZlYzQ8aTMyPiwgc2hhcGUgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XFxuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxcbiAgICAgIHNoYXBlLnkgKiBzaGFwZS56ICogc2hhcGUudywgc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLncsIDEpKTtcXG59XFxuZm4gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gaTMyIHtcXG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXFxuICAgIG91dFNoYXBlU3RyaWRlcy54LCBvdXRTaGFwZVN0cmlkZXMueSwgb3V0U2hhcGVTdHJpZGVzLnosIDEpKTtcXG59XFxuXCJ9LDE1ODooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQubWFrZU1hdE11bFBhY2tlZFNvdXJjZT10Lm1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlPXZvaWQgMCx0Lm1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlPShlLHQsbj0hMSxyPTMyLG89ITEsaT0zMixhPSExKT0+e2NvbnN0IHM9dFsxXSplWzFdLHU9dFswXSplWzBdLGw9bj9zOnIsYz1uP3I6cyxwPWwvdFswXSxkPXIvdFsxXTtpZigoIW58fDQhPT1wfHw0IT09ZVsxXSkmJihufHwzIT09cCYmNCE9PXApfHxsJXRbMF0hPTB8fHIldFsxXSE9MHx8NCE9PWVbMF0pdGhyb3cgbmV3IEVycm9yKGBJZiB0cmFuc3Bvc2VBICR7bn0gaXMgdHJ1ZSwgaW5uZXJFbGVtZW50U2l6ZSAke3B9IGFuZCB3b3JrUGVyVGhyZWFkWzFdICR7ZVsxXX0gbXVzdCBiZSA0LlxcbiAgICAgIE90aGVyd2lzZSwgaW5uZXJFbGVtZW50U2l6ZSAke3B9IG11c3QgYmUgMyBvciA0LlxcbiAgdGlsZUFXaWR0aCAke2x9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3RbMF19LiB0aWxlSW5uZXIgJHtyfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdICR7dFsxXX0uIGNvbFBlclRocmVhZCAke2VbMF19IG11c3QgYmUgNC5gKTtyZXR1cm5gXFxudmFyPHdvcmtncm91cD4gbW1fQXN1YiA6IGFycmF5PGFycmF5PHZlYyR7cH08ZjMyPiwgJHtsL3B9PiwgJHtjfT47XFxudmFyPHdvcmtncm91cD4gbW1fQnN1YiA6IGFycmF5PGFycmF5PHZlYzQ8ZjMyPiwgJHt1L2VbMF19PiwgJHtyfT47XFxuXFxuY29uc3Qgcm93UGVyVGhyZWFkID0gJHtlWzFdfTtcXG5jb25zdCBjb2xQZXJUaHJlYWQgPSAke2VbMF19O1xcbmNvbnN0IGlubmVyRWxlbWVudFNpemUgPSAke3B9O1xcbmNvbnN0IHRpbGVJbm5lciA9ICR7cn07XFxuXFxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7dFswXX0sICR7dFsxXX0sICR7dFsyXX0pXFxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxcbiAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbElkIDogdmVjMzx1MzI+LFxcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xcbiAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XFxuICBsZXQgdGlsZVJvdyA9ICR7YT9cIjBcIjpcImxvY2FsUm93ICogcm93UGVyVGhyZWFkXCJ9O1xcbiAgbGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KTtcXG5cXG4gIGxldCBnbG9iYWxSb3cgPSAke2E/XCIwXCI6XCJpMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWRcIn07XFxuICBsZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpO1xcbiAgbGV0IGJhdGNoID0gJHtvP1wiMFwiOlwiaTMyKGdsb2JhbElkLnopXCJ9O1xcbiAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHtzfTtcXG5cXG4gIGxldCBudW1UaWxlcyA9ICR7bz9gJHtNYXRoLmNlaWwoaS9yKX1gOlwiKGRpbUlubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxXCJ9O1xcbiAgdmFyIGtTdGFydCA9ICR7bz9gaTMyKGdsb2JhbElkLnopICogJHtpfWA6XCIwXCJ9O1xcblxcbiAgdmFyIGFjYzogYXJyYXk8dmVjNDxmMzI+LCByb3dQZXJUaHJlYWQ+O1xcblxcbiAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXFxuICBsZXQgdGlsZVJvd0IgPSBsb2NhbFJvdyAqICR7ZH07XFxuICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bVRpbGVzOyB0ID0gdCArIDEpIHtcXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXFxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvdyArIGlubmVyUm93O1xcbiAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xcbiAgICAgICAgICAke2Y9bixmP1wiXFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcXG4gICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXFxuICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sKTtcXG4gICAgICAgIFwiOlwiXFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcXG4gICAgICAgICAgZ2xvYmFsUm93ICsgaW5uZXJSb3csXFxuICAgICAgICAgIGtTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCk7XFxuICAgICAgICBcIn1cXG4gICAgICB9XFxuXFxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxcbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke2R9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xcbiAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCwga1N0YXJ0ICsgaW5wdXRSb3csIGdsb2JhbENvbCk7XFxuICAgICAgfVxcbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXFxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXIgLyBpbm5lckVsZW1lbnRTaXplOyBrID0gayArIDEpIHtcXG4gICAgICAgICAgbGV0IEJDYWNoZWQwID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bdGlsZUNvbF07XFxuICAgICAgICAgIGxldCBCQ2FjaGVkMSA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVt0aWxlQ29sXTtcXG4gICAgICAgICAgbGV0IEJDYWNoZWQyID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW3RpbGVDb2xdO1xcbiAgICAgICAgICAkezM9PT1wP1wiXCI6XCJsZXQgQkNhY2hlZDMgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bdGlsZUNvbF07XCJ9XFxuXFxuICAgICAgICAgICR7KChlLHQpPT5lP2BcXG4gICAgICAgIGxldCBBQ2FjaGVkMCA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemVdW2xvY2FsUm93XTtcXG4gICAgICAgIGxldCBBQ2FjaGVkMSA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVtsb2NhbFJvd107XFxuICAgICAgICBsZXQgQUNhY2hlZDIgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bbG9jYWxSb3ddO1xcbiAgICAgICAgJHszPT09dD9cIlwiOlwibGV0IEFDYWNoZWQzID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDNdW2xvY2FsUm93XTtcIn1cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcXG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkMFtpXSArIGFjY1tpXTtcXG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkMVtpXSArIGFjY1tpXTtcXG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkMltpXSArIGFjY1tpXTtcXG4gICAgICAgICAgJHszPT09dD9cIlwiOlwiYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkM1tpXSArIGFjY1tpXTtcIn1cXG4gICAgICAgIH1gOmBcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcXG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpXVtrXTtcXG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkLnggKyBhY2NbaV07XFxuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZC55ICsgYWNjW2ldO1xcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQueiArIGFjY1tpXTtcXG4gICAgICAgICAgJHszPT09dD9cIlwiOlwiYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkLncgKyBhY2NbaV07XCJ9XFxuICAgICAgICB9YCkobixwKX1cXG4gICAgICB9XFxuXFxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xcbiAgfVxcblxcbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gICAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCwgYWNjW2lubmVyUm93XSk7XFxuICB9XFxufWA7dmFyIGZ9O2NvbnN0IG49ZT0+ZT9cIlxcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Q29sKTtcXG4gICAgICAgICAgICBcIjpcIlxcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dFJvdyxcXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Q29sKTtcXG4gICAgICAgICAgICBcIjt0Lm1ha2VNYXRNdWxQYWNrZWRTb3VyY2U9KGUsdCxyPSExLG89MzIsaT0hMSxhPTMyLHM9ITEpPT57Y29uc3QgdT1lWzFdKnRbMV0sbD1lWzBdKnRbMF0sYz1yP3U6byxwPXI/bzp1O2lmKHAldFsxXSE9MHx8YyV0WzBdIT0wfHxvJXRbMV0hPTApdGhyb3cgbmV3IEVycm9yKGB0aWxlQUhpZ2h0ICR7cH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7dFsxXX0sIHRpbGVBV2lkdGggJHtjfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzBdJHt0WzBdfSwgdGlsZUlubmVyICR7b30gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7dFsxXX1gKTtjb25zdCBkPXAvdFsxXSxmPWMvdFswXSxoPW8vdFsxXSxnPXM/YFxcbiAgICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcXG4gICAgbGV0IGxvY2FsQ29sID0gaTMyKGxvY2FsSWQueCk7XFxuICAgIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7dX07XFxuICAgIGxldCBnbG9iYWxDb2xTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC54KSAqICR7bH07XFxuXFxuICAgIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxcbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bVRpbGVzOyB0ID0gdCArIDEpIHtcXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXFxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke3B9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt0WzFdfSkge1xcbiAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke2N9OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt0WzBdfSkge1xcbiAgICAgICAgICAke24ocil9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7b307IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3RbMV19KSB7XFxuICAgICAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke2x9OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt0WzBdfSkge1xcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcXG4gICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcXG4gICAgICAgICAgICBnbG9iYWxDb2xTdGFydCArIGlucHV0Q29sKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcXG5cXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cXG4gICAgICB2YXIgQkNhY2hlZCA6IGFycmF5PGYzMiwgY29sUGVyVGhyZWFkPjtcXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XFxuICAgICAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xcbiAgICAgICAgICBCQ2FjaGVkW2lubmVyXSA9IG1tX0JzdWJba11bbG9jYWxDb2wgKyBpbm5lciAqICR7dFswXX1dO1xcbiAgICAgICAgfVxcbiAgICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSAke3I/YG1tX0FzdWJba11bbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX1dO2A6YG1tX0FzdWJbbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX1dW2tdO2B9XFxuICAgICAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XFxuICAgICAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArXFxuICAgICAgICAgICAgICAgIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuICAgIH1cXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gICAgICBsZXQgZ1JvdyA9IGdsb2JhbFJvd1N0YXJ0ICsgbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX07XFxuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcXG4gICAgICAgIGxldCBnQ29sID0gZ2xvYmFsQ29sU3RhcnQgKyBsb2NhbENvbCArIGlubmVyQ29sICogJHt0WzBdfTtcXG4gICAgICAgIG1tX3dyaXRlKGJhdGNoLCBnUm93LCBnQ29sLCBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGA6YFxcbmxldCB0aWxlUm93ID0gaTMyKGxvY2FsSWQueSkgKiByb3dQZXJUaHJlYWQ7XFxubGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KSAqIGNvbFBlclRocmVhZDtcXG5cXG5sZXQgZ2xvYmFsUm93ID0gaTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xcbmxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XFxubGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHt1fTtcXG5cXG5sZXQgdGlsZVJvd0EgPSBpMzIobG9jYWxJZC55KSAqICR7ZH07XFxubGV0IHRpbGVDb2xBID0gaTMyKGxvY2FsSWQueCkgKiAke2Z9O1xcbmxldCB0aWxlUm93QiA9IGkzMihsb2NhbElkLnkpICogJHtofTtcXG4vLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cXG5mb3IgKHZhciB0ID0gMDsgdCA8IG51bVRpbGVzOyB0ID0gdCArIDEpIHtcXG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke2R9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgJHtmfTsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcXG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QSArIGlubmVyUm93O1xcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2xBICsgaW5uZXJDb2w7XFxuICAgICAgJHtuKHIpfVxcbiAgICB9XFxuICB9XFxuXFxuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXFxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtofTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcXG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2wgKyBpbm5lckNvbDtcXG4gICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcXG4gICAgICAgIGtTdGFydCArIGlucHV0Um93LFxcbiAgICAgICAgZ2xvYmFsQ29sICsgaW5uZXJDb2wpO1xcbiAgICB9XFxuICB9XFxuICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XFxuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XFxuXFxuICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cXG4gIHZhciBCQ2FjaGVkIDogYXJyYXk8ZjMyLCBjb2xQZXJUaHJlYWQ+O1xcbiAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xcbiAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xcbiAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVt0aWxlQ29sICsgaW5uZXJdO1xcbiAgICB9XFxuXFxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XFxuICAgICAgJHsoZT0+ZT9cImxldCBBQ2FjaGVkID0gbW1fQXN1YltrXVt0aWxlUm93ICsgaW5uZXJSb3ddO1wiOlwibGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpbm5lclJvd11ba107XCIpKHIpfVxcbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XFxuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICsgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgd29ya2dyb3VwQmFycmllcigpO1xcbn1cXG5cXG5mb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xcbiAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcXG4gICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wgKyBpbm5lckNvbCxcXG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcXG4gIH1cXG59XFxuYDtyZXR1cm5gXFxuICB2YXI8d29ya2dyb3VwPiBtbV9Bc3ViIDogYXJyYXk8YXJyYXk8ZjMyLCAke2N9PiwgJHtwfT47XFxuICB2YXI8d29ya2dyb3VwPiBtbV9Cc3ViIDogYXJyYXk8YXJyYXk8ZjMyLCAke2x9PiwgJHtvfT47XFxuICBjb25zdCByb3dQZXJUaHJlYWQgPSAke2VbMV19O1xcbiAgY29uc3QgY29sUGVyVGhyZWFkID0gJHtlWzBdfTtcXG4gIGNvbnN0IHRpbGVJbm5lciA9ICR7b307XFxuXFxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7dFswXX0sICR7dFsxXX0sICR7dFsyXX0pXFxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxcbiAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbElkIDogdmVjMzx1MzI+LFxcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xcbiAgICBsZXQgYmF0Y2ggPSAke2k/XCIwXCI6XCJpMzIoZ2xvYmFsSWQueilcIn07XFxuICAgIGxldCBudW1UaWxlcyA9ICR7aT9gJHtNYXRoLmNlaWwoYS9vKX1gOlwiKGRpbUlubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxXCJ9O1xcbiAgICB2YXIga1N0YXJ0ID0gJHtpP2BpMzIoZ2xvYmFsSWQueikgKiAke2F9YDpcIjBcIn07XFxuXFxuICAgIHZhciBhY2MgOiBhcnJheTxhcnJheTxmMzIsIGNvbFBlclRocmVhZD4sIHJvd1BlclRocmVhZD47XFxuXFxuICAgIC8vIFdpdGhvdXQgdGhpcyBpbml0aWFsaXphdGlvbiBzdHJhbmdlIHZhbHVlcyBzaG93IHVwIGluIGFjYy5cXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcXG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSAwLjA7XFxuICAgICAgfVxcbiAgICB9XFxuICAgICR7Z31cXG4gIH1cXG5gfX0sNTA0OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnN1Yj10LnBvdz10Lm11bD10LmRpdj10LmFkZD12b2lkIDA7Y29uc3Qgcj1uKDY5NTIpLG89bigxMTYzKSxpPW4oMjA3NSksYT0oZSx0LG4sYSxzKT0+e2NvbnN0IHU9e25hbWU6dCxpbnB1dFR5cGVzOltvLkdwdURhdGFUeXBlLmRlZmF1bHQsby5HcHVEYXRhVHlwZS5kZWZhdWx0XSxjYWNoZUhpbnQ6c307cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Z2V0OigpPT4oKGUsdCxuLGEscyx1PXQuZGF0YVR5cGUpPT57dmFyIGwsYztjb25zdCBwPSFyLlNoYXBlVXRpbC5hcmVFcXVhbCh0LmRpbXMsbi5kaW1zKTtsZXQgZD10LmRpbXMsZj1yLlNoYXBlVXRpbC5zaXplKHQuZGltcyksaD0hMTtpZihwKXtjb25zdCBlPXIuQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUodC5kaW1zLG4uZGltcywhMSk7aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7ZD1lLGY9ci5TaGFwZVV0aWwuc2l6ZShkKTtsZXQgbz0xO2ZvcihsZXQgZT0wO2U8ZC5sZW5ndGg7ZSsrKXtjb25zdCByPW51bGwhPT0obD10LmRpbXNbdC5kaW1zLmxlbmd0aC1lXSkmJnZvaWQgMCE9PWw/bDoxO2lmKHIhPT0obnVsbCE9PShjPW4uZGltc1tuLmRpbXMubGVuZ3RoLWVdKSYmdm9pZCAwIT09Yz9jOjEpKWJyZWFrO28qPXJ9byU0PT0wJiYoaD0hMCl9ZWxzZSBoPSEwO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse2dldFNoYWRlclNvdXJjZTplPT4oKGUsdCxuLG8sYSxzLHUsbCxjPVwiZjMyXCIscD1cImYzMlwiLGQ9XCJmMzJcIik9Pntjb25zdCBmPXIuU2hhcGVVdGlsLnNpemUobyksaD1NYXRoLmNlaWwoZi80KTtsZXQgZyxtO1wic3RyaW5nXCI9PXR5cGVvZiB1P2c9bT0oZSx0KT0+YCR7dX0oKCR7ZX0pLCgke3R9KSlgOlwiZnVuY3Rpb25cIj09dHlwZW9mIHU/Zz1tPXU6KGc9dS5zY2FsYXIsbT11LnZlY3Rvcik7bGV0IGI9XCJcIjtjb25zdCB5PSgwLGkuY3JlYXRlSW5kaWNlc0hlbHBlcikoXCJvdXRwdXRcIixvKTtpZihzKXtjb25zdCBlPWU9Pntjb25zdCB0PXIuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGUpLG49W107Zm9yKGxldCByPWUubGVuZ3RoLTE7cj49MDtyLS0pe2NvbnN0IGk9MD09PW8ubGVuZ3RoP1wiMHVcIjoxPT09by5sZW5ndGg/XCIoKm91dHB1dEluZGljZXMpXCI6YCgqb3V0cHV0SW5kaWNlcylbJHtyK28ubGVuZ3RoLWUubGVuZ3RofV1gO24ucHVzaChgJHt0W3JdfXUgKiAoJHtpfSAlICR7ZVtyXX11KWApfXJldHVybiBuLmxlbmd0aD4wP24uam9pbihcIitcIik6XCIwdVwifTtiPWBcXG4gICR7eS5vMmlJbXBsfVxcblxcbiAgZm4gY2FsY09mZnNldEEob3V0cHV0SW5kaWNlczogcHRyPGZ1bmN0aW9uLCAke3kuaVR5cGV9PikgLT4gdTMyIHtcXG4gICAgcmV0dXJuICR7ZSh0KX07XFxuICB9XFxuXFxuICBmbiBjYWxjT2Zmc2V0QihvdXRwdXRJbmRpY2VzOiBwdHI8ZnVuY3Rpb24sICR7eS5pVHlwZX0+KSAtPiB1MzIge1xcbiAgICByZXR1cm4gJHtlKG4pfTtcXG4gIH1cXG4gIGB9bGV0IHc7aWYoYSl3PXM/YFxcbiAgICAgICR7eS5pbmRpY2VzVmFyaWFibGVEZWNsYXJhdGlvbihcIm91dHB1dEluZGljZXNcIil9XFxuICAgICAgJHt5Lm8yaUNhbGwoXCJnbG9iYWxfaWR4ICogNHVcIixcIm91dHB1dEluZGljZXNcIil9XFxuICAgICAgbGV0IG9mZnNldEEgPSBjYWxjT2Zmc2V0QSgmb3V0cHV0SW5kaWNlcyk7XFxuICAgICAgbGV0IG9mZnNldEIgPSBjYWxjT2Zmc2V0Qigmb3V0cHV0SW5kaWNlcyk7XFxuICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9ICR7bShcImFEYXRhW29mZnNldEEgLyA0dV1cIixcImJEYXRhW29mZnNldEIgLyA0dV1cIil9O2A6YG91dHB1dERhdGFbZ2xvYmFsX2lkeF0gPSAke20oXCJhRGF0YVtnbG9iYWxfaWR4XVwiLFwiYkRhdGFbZ2xvYmFsX2lkeF1cIil9O2A7ZWxzZXtpZighcyl0aHJvdyBuZXcgRXJyb3IoXCJubyBuZWNlc3NhcnkgdG8gdXNlIHNjYWxhciBpbXBsZW1lbnRhdGlvbiBmb3IgZWxlbWVudC13aXNlIGJpbmFyeSBvcCBpbXBsZW1lbnRhdGlvbi5cIik7Y29uc3QgZT1lPT57Y29uc3QgdD1gYURhdGFbaW5kZXhBJHtlfV1bY29tcG9uZW50QSR7ZX1dYCxuPWBiRGF0YVtpbmRleEIke2V9XVtjb21wb25lbnRCJHtlfV1gO3JldHVybmBcXG4gICAgICAke3kubzJpQ2FsbChgZ2xvYmFsX2lkeCAqIDR1ICsgJHtlfXVgLFwib3V0cHV0SW5kaWNlc1wiKX1cXG4gICAgICBsZXQgb2Zmc2V0QSR7ZX0gPSBjYWxjT2Zmc2V0QSgmb3V0cHV0SW5kaWNlcyk7XFxuICAgICAgbGV0IG9mZnNldEIke2V9ID0gY2FsY09mZnNldEIoJm91dHB1dEluZGljZXMpO1xcbiAgICAgIGxldCBpbmRleEEke2V9ID0gb2Zmc2V0QSR7ZX0gLyA0dTtcXG4gICAgICBsZXQgaW5kZXhCJHtlfSA9IG9mZnNldEIke2V9IC8gNHU7XFxuICAgICAgbGV0IGNvbXBvbmVudEEke2V9ID0gb2Zmc2V0QSR7ZX0gJSA0dTtcXG4gICAgICBsZXQgY29tcG9uZW50QiR7ZX0gPSBvZmZzZXRCJHtlfSAlIDR1O1xcbiAgICAgIG91dHB1dERhdGFbZ2xvYmFsX2lkeF1bJHtlfV0gPSAke2codCxuKX07YH07dz1gXFxuICAgICAgJHt5LmluZGljZXNWYXJpYWJsZURlY2xhcmF0aW9uKFwib3V0cHV0SW5kaWNlc1wiKX1cXG4gICAgICAke2UoMCl9XFxuICAgICAgJHtlKDEpfVxcbiAgICAgICR7ZSgyKX1cXG4gICAgICAke2UoMyl9YH1yZXR1cm5gXFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGFEYXRhIDogYXJyYXk8dmVjNDwke2N9Pj47XFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGJEYXRhIDogYXJyYXk8dmVjNDwke3B9Pj47XFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dERhdGEgOiBhcnJheTx2ZWM0PCR7ZH0+PjtcXG5cXG4gICR7bnVsbCE9bD9sOlwiXCJ9XFxuICAke2J9XFxuXFxuICAke2UubWFpblN0YXJ0KCl9XFxuICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGgpfVxcbiAgICAke3d9XFxuICB9YH0pKGUsdC5kaW1zLG4uZGltcyxkLGgscCxhLHMpLG91dHB1dHM6W3tkaW1zOmQsZGF0YVR5cGU6dSxncHVEYXRhVHlwZTpvLkdwdURhdGFUeXBlLmRlZmF1bHR9XSxkaXNwYXRjaEdyb3VwOigpPT4oe3g6TWF0aC5jZWlsKGYvNjQvKGg/NDoxKSl9KX0pfSkodSxlWzBdLGVbMV0sbixhKX0pfTt0LmFkZD1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHMsXCJBZGRcIiwoKGUsdCk9PmAke2V9KyR7dH1gKSkpfSx0LmRpdj1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHMsXCJEaXZcIiwoKGUsdCk9PmAke2V9LyR7dH1gKSkpfSx0Lm11bD1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHMsXCJNdWxcIiwoKGUsdCk9PmAke2V9KiR7dH1gKSkpfSx0LnBvdz1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHMsXCJQb3dcIix7c2NhbGFyOihlLHQpPT5gcG93X2YzMigke2V9LCR7dH0pYCx2ZWN0b3I6KGUsdCk9PmBwb3dfdmYzMigke2V9LCR7dH0pYH0sXCJcXG4gICAgZm4gcG93X2YzMihhIDogZjMyLCBiIDogZjMyKSAtPiBmMzIge1xcbiAgICAgIGlmIChiID09IDAuMCkge1xcbiAgICAgICAgcmV0dXJuIDEuMDtcXG4gICAgICB9IGVsc2UgaWYgKGEgPCAwLjAgJiYgYiAhPSBmbG9vcihiKSkge1xcbiAgICAgICAgcmV0dXJuIHBvdyhhLCBiKTsgLy8gTmFOXFxuICAgICAgfVxcbiAgICAgIHJldHVybiBzZWxlY3Qoc2lnbihhKSwgMS4wLCByb3VuZChhYnMoYikgJSAyLjApICE9IDEuMCkgKiBwb3coYWJzKGEpLCBiKTtcXG4gICAgfVxcbiAgICBmbiBwb3dfdmYzMihhIDogdmVjNDxmMzI+LCBiIDogdmVjNDxmMzI+KSAtPiB2ZWM0PGYzMj4ge1xcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCB2ZWN0b3JpemVkIHBvd1xcbiAgICAgIHJldHVybiB2ZWM0PGYzMj4ocG93X2YzMihhLngsIGIueCksIHBvd19mMzIoYS55LCBiLnkpLCBwb3dfZjMyKGEueiwgYi56KSwgcG93X2YzMihhLncsIGIudykpO1xcbiAgICB9XFxuICAgICAgXCIpKX0sdC5zdWI9ZT0+e2UuY29tcHV0ZShhKGUuaW5wdXRzLFwiU3ViXCIsKChlLHQpPT5gJHtlfS0ke3R9YCkpKX19LDIwNzU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlU2hhZGVySGVscGVyPXQuY3JlYXRlSW5kaWNlc0hlbHBlcj10LldPUktHUk9VUF9TSVpFPXZvaWQgMDtjb25zdCByPW4oNjk1Mik7dC5XT1JLR1JPVVBfU0laRT02NCx0LmNyZWF0ZUluZGljZXNIZWxwZXI9KGUsdCk9Pntjb25zdCBuPXQubGVuZ3RoPDI/XCJ1MzJcIjpgYXJyYXk8dTMyLCAke3QubGVuZ3RofT5gLG89ci5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXModCk7bGV0IGk9XCJcIjtmb3IobGV0IGU9MDtlPHQubGVuZ3RoLTE7ZSsrKWkrPWBcXG4gICAgbGV0IGRpbSR7ZX0gPSBjdXJyZW50IC8gJHtvW2VdfXU7XFxuICAgIGxldCByZXN0JHtlfSA9IGN1cnJlbnQgJSAke29bZV19dTtcXG4gICAgKCppbmRpY2VzKVske2V9XSA9IGRpbSR7ZX07XFxuICAgIGN1cnJlbnQgPSByZXN0JHtlfTtcXG4gICAgYDtpKz1gKCppbmRpY2VzKVske3QubGVuZ3RoLTF9XSA9IGN1cnJlbnQ7YDtjb25zdCBhPXQubGVuZ3RoPDI/XCJcIjpgXFxuICBmbiBpaF9vMmlfJHtlfShvZmZzZXQ6IHUzMiwgaW5kaWNlczogcHRyPGZ1bmN0aW9uLCAke259Pikge1xcbiAgICB2YXIgY3VycmVudCA9IG9mZnNldDtcXG4gICAgJHtpfVxcbiAgfWAscz1bXTtpZigwPT09dC5sZW5ndGgpcy5wdXNoKFwiMHVcIik7ZWxzZSBpZih0Lmxlbmd0aDwyKXMucHVzaChcIigqaW5kaWNlcylcIik7ZWxzZSBmb3IobGV0IGU9dC5sZW5ndGgtMTtlPj0wO2UtLSlzLnB1c2goYCR7b1tlXX11ICogKCgqaW5kaWNlcylbJHtlfV0pYCk7cmV0dXJue28yaUltcGw6YSxvMmlDYWxsOihuLHIpPT50Lmxlbmd0aDwyP2Ake3J9PSR7bn07YDpgaWhfbzJpXyR7ZX0oJHtufSwgJiR7cn0pO2AsaTJvSW1wbDp0Lmxlbmd0aDwyP1wiXCI6YFxcbiAgZm4gaWhfaTJvXyR7ZX0oaW5kaWNlczogcHRyPGZ1bmN0aW9uLCAke259PikgLT4gdTMyIHtcXG4gICAgcmV0dXJuICR7cy5qb2luKFwiK1wiKX07XFxuICB9YCxpMm9FeHByZXNzaW9uOihuLHIpPT50Lmxlbmd0aDwyP2AoJHtyP1wiKlwiOlwiXCJ9JHtufSlgOmBpaF9pMm9fJHtlfSgke3I/XCJcIjpcIiZcIn0ke259KWAsaW5kaWNlc1ZhcmlhYmxlRGVjbGFyYXRpb246KGUsdCk9PmB2YXIgJHtlfToke259JHt0P2A9JHtufSgke3Quam9pbihcIixcIil9KWA6XCJcIn07YCxpVHlwZTpufX07Y2xhc3Mgb3tjb25zdHJ1Y3RvcihlKXt0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwPWV9Z3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhlKXtyZXR1cm5gaWYgKGdsb2JhbF9pZHggPj0gJHtcIm51bWJlclwiPT10eXBlb2YgZT9gJHtlfXVgOmV9KSB7IHJldHVybjsgfWB9bWFpblN0YXJ0KGU9dC5XT1JLR1JPVVBfU0laRSl7Y29uc3Qgbj1cIm51bWJlclwiPT10eXBlb2YgZT9lOmVbMF0scj1cIm51bWJlclwiPT10eXBlb2YgZT8xOmVbMV0sbz1cIm51bWJlclwiPT10eXBlb2YgZT8xOmVbMl0saT0xPT09dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXSYmMT09PXRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl07cmV0dXJuYEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke259LCAke3J9LCAke299KVxcbiAgZm4gbWFpbigke2k/XCJAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+XCI6XCJAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBsb2NhbF9pbmRleCA6IHUzMixcXG4gICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj5cIn0pIHtcXG4gICAgJHtpP1wibGV0IGdsb2JhbF9pZHggPSBnbG9iYWxfaWQueDtcIjpgbGV0IGdsb2JhbF9pZHggPSAod29ya2dyb3VwX2lkLnogKiAke3RoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMF0qdGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXX11ICtcXG4gICAgICAgICAgd29ya2dyb3VwX2lkLnkgKiAke3RoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMF19dSArIHdvcmtncm91cF9pZC54KSAqICR7bipyKm99dSArIGxvY2FsX2luZGV4O2B9XFxuICBgfX10LmNyZWF0ZVNoYWRlckhlbHBlcj1lPT5uZXcgbyhlKX0sOTE5MjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5jcmVhdGVHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNjk1Miksbz1uKDExNjMpLGk9bigyMDc1KSxhPW4oOTc3MCkscz1uKDM5OTcpO3QuY3JlYXRlR3JvdXBlZENvbnZQcm9ncmFtSW5mb0xvYWRlcj0oZSx0LG4pPT57Y29uc3QgdT0obD1lLmxlbmd0aD4yLGM9dC5jYWNoZUtleSx7bmFtZTpcIkdyb3VwZWRDb252XCIsaW5wdXRUeXBlczpsP1tvLkdwdURhdGFUeXBlLmRlZmF1bHQsby5HcHVEYXRhVHlwZS5kZWZhdWx0LG8uR3B1RGF0YVR5cGUuZGVmYXVsdF06W28uR3B1RGF0YVR5cGUuZGVmYXVsdCxvLkdwdURhdGFUeXBlLmRlZmF1bHRdLGNhY2hlSGludDpjfSk7dmFyIGwsYztyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtnZXQ6KCk9PigoZSx0LG4sdSk9Pntjb25zdCBsPWUubGVuZ3RoPjIsYz1sP1widmFsdWUgKz0gYltvdXRwdXRfY2hhbm5lbF07XCI6XCJcIixwPWVbMF0uZGltcyxkPWVbMV0uZGltcyxmPWRbMF0vbi5ncm91cCxoPVwiZjMyXCIse2FjdGl2YXRpb25GdW5jdGlvbjpnLGFwcGx5QWN0aXZhdGlvbjptfT0oMCxzLmdldEFjdGljYXRpb25TbmlwcGV0KShuKSxiPVtgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiB4IDogYXJyYXk8JHtofT47YCxgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiB3IDogYXJyYXk8JHtofT47YF07bCYmYi5wdXNoKGBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWQ+IGIgOiBhcnJheTwke2h9PjtgKTtjb25zdCB5PVwiTkhXQ1wiPT09bi5mb3JtYXQsdz0oMCxhLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShwLGQsbi5kaWxhdGlvbnMsbi5wYWRzLG4uc3RyaWRlcyx5KSxfPXIuU2hhcGVVdGlsLnNpemUodyksdj0oMCxpLmNyZWF0ZUluZGljZXNIZWxwZXIpKFwib3V0cHV0XCIsdykseD0oMCxpLmNyZWF0ZUluZGljZXNIZWxwZXIpKFwieFwiLHApLFQ9KDAsaS5jcmVhdGVJbmRpY2VzSGVscGVyKShcIndcIixkKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXRzOlt7ZGltczp1P3Uodyk6dyxkYXRhVHlwZTplWzBdLmRhdGFUeXBlLGdwdURhdGFUeXBlOm8uR3B1RGF0YVR5cGUuZGVmYXVsdH1dLGdldFNoYWRlclNvdXJjZTplPT5gXFxuICBjb25zdCBzdHJpZGVzOiB2ZWMyPHUzMj4gPSB2ZWMyKCR7bi5zdHJpZGVzWzBdfXUsICR7bi5zdHJpZGVzWzFdfXUpO1xcbiAgY29uc3QgcGFkczogdmVjMjx1MzI+ID0gdmVjMigke24ucGFkc1swXX11LCAke24ucGFkc1sxXX11KTtcXG5cXG4gICR7Yi5qb2luKFwiXFxuXCIpfVxcbiAgQGdyb3VwKDApIEBiaW5kaW5nKCR7Yi5sZW5ndGh9KSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHtofT47XFxuXFxuICAke2d9XFxuICAke3YubzJpSW1wbH1cXG4gICR7eC5pMm9JbXBsfVxcbiAgJHtULmkyb0ltcGx9XFxuXFxuICAke2UubWFpblN0YXJ0KCl9XFxuICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKF8pfVxcblxcbiAgICAke3YuaW5kaWNlc1ZhcmlhYmxlRGVjbGFyYXRpb24oXCJvdXRwdXRJbmRpY2VzXCIpfVxcbiAgICAke3YubzJpQ2FsbChcImdsb2JhbF9pZHhcIixcIm91dHB1dEluZGljZXNcIil9XFxuICAgIGxldCBiYXRjaDogdTMyID0gb3V0cHV0SW5kaWNlc1swXTtcXG4gICAgbGV0IG91dHB1dF9jaGFubmVsOiB1MzIgPSBvdXRwdXRJbmRpY2VzWyR7eT8zOjF9XTtcXG4gICAgbGV0IHhSQ0Nvcm5lcjogdmVjMjx1MzI+ID0gdmVjMjx1MzI+KG91dHB1dEluZGljZXNbJHt5PzE6Mn1dLCBvdXRwdXRJbmRpY2VzWyR7eT8yOjN9XSkgKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgbGV0IGdyb3VwX2lkOiB1MzIgPSBvdXRwdXRfY2hhbm5lbCAvICR7Zn11O1xcblxcbiAgICB2YXIgdmFsdWU6ICR7aH0gPSAke2h9KDApO1xcbiAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8ICR7ZFsxXX11OyB3SW5DaGFubmVsKyspIHtcXG4gICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGdyb3VwX2lkICogJHtkWzFdfXUgKyB3SW5DaGFubmVsO1xcbiAgICAgIGZvciAodmFyIHdIZWlnaHQ6IHUzMiA9IDB1OyB3SGVpZ2h0IDwgJHtkWzJdfXU7IHdIZWlnaHQrKykge1xcbiAgICAgICAgbGV0IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiAke24uZGlsYXRpb25zWzBdfXU7XFxuXFxuICAgICAgICBpZiAoeEhlaWdodCA8IDB1IHx8IHhIZWlnaHQgPj0gJHtwW3k/MToyXX11KSB7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZm9yICh2YXIgd1dpZHRoOiB1MzIgPSAwdTsgd1dpZHRoIDwgJHtkWzNdfXU7IHdXaWR0aCsrKSB7XFxuICAgICAgICAgIGxldCB4V2lkdGggPSB4UkNDb3JuZXIueSArIHdXaWR0aCAqICR7bi5kaWxhdGlvbnNbMV19dTtcXG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSAke3BbeT8yOjNdfXUpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICAke3guaW5kaWNlc1ZhcmlhYmxlRGVjbGFyYXRpb24oXCJ4SW5kaWNlc1wiLHk/W1wiYmF0Y2hcIixcInhIZWlnaHRcIixcInhXaWR0aFwiLFwiaW5wdXRfY2hhbm5lbFwiXTpbXCJiYXRjaFwiLFwiaW5wdXRfY2hhbm5lbFwiLFwieEhlaWdodFwiLFwieFdpZHRoXCJdKX1cXG4gICAgICAgICAgbGV0IHhWYWwgPSB4WyR7eC5pMm9FeHByZXNzaW9uKFwieEluZGljZXNcIil9XTtcXG4gICAgICAgICAgJHtULmluZGljZXNWYXJpYWJsZURlY2xhcmF0aW9uKFwid0luZGljZXNcIixbXCJvdXRwdXRfY2hhbm5lbFwiLFwid0luQ2hhbm5lbFwiLFwid0hlaWdodFwiLFwid1dpZHRoXCJdKX1cXG4gICAgICAgICAgbGV0IHdWYWwgPSB3WyR7VC5pMm9FeHByZXNzaW9uKFwid0luZGljZXNcIil9XTtcXG4gICAgICAgICAgdmFsdWUgKz0geFZhbCp3VmFsO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICAke2N9XFxuICAgICR7bX1cXG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XFxuICB9YCxkaXNwYXRjaEdyb3VwOigpPT4oe3g6TWF0aC5jZWlsKF8vNjQpfSl9KX0pKGUsdSx0LG4pfSl9fSw5NzcwOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNvbnY9dC5wYXJzZUNvbnZBdHRyaWJ1dGVzPXQuY2FsY3VsYXRlT3V0cHV0U2hhcGU9dm9pZCAwO2NvbnN0IHI9big2OTUyKSxvPW4oMzg3KSxpPW4oOTE5MiksYT1uKDM4MjIpLHM9bigzOTk3KSx1PW4oMjYyNSk7dC5jYWxjdWxhdGVPdXRwdXRTaGFwZT0oZSx0LG4scixvLGkpPT57Y29uc3QgYT1lWzBdLHM9ZS5zbGljZShpPzE6MixpPzM6NCksdT1zLmxlbmd0aCxsPXRbMF0sYz10LnNsaWNlKDIpLm1hcCgoKGUsdCk9PmUrKGUtMSkqKG5bdF0tMSkpKSxwPXMubWFwKCgoZSx0KT0+ZStyW3RdK3JbdCt1XSkpLm1hcCgoKGUsdCk9Pk1hdGguZmxvb3IoKGUtY1t0XStvW3RdKS9vW3RdKSkpO3JldHVybiBwLnNwbGljZSgwLDAsYSkscC5zcGxpY2UoaT8zOjEsMCxsKSxwfTtjb25zdCBsPSgwLG8uY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7cGVybTpbMiwzLDEsMF19KSxjPShlLHQpPT57Y29uc3Qgbj1lLmtlcm5lbFNoYXBlLnNsaWNlKCk7Zm9yKGxldCBlPTI7ZTx0WzFdLmRpbXMubGVuZ3RoOysrZSkwPT09bltlLTJdJiYobltlLTJdPXRbMV0uZGltc1tlXSk7Y29uc3Qgbz1lLnBhZHMuc2xpY2UoKTtyLlBvb2xDb252VXRpbC5hZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodFswXS5kaW1zLGUuc3RyaWRlcyxlLmRpbGF0aW9ucyxuLG8sXCJOSFdDXCI9PT1lLmZvcm1hdCxlLmF1dG9QYWQpO2NvbnN0IGk9T2JqZWN0LmFzc2lnbih7fSxlKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihpLHtrZXJuZWxTaGFwZTpuLHBhZHM6byxjYWNoZUtleTplLmNhY2hlS2V5fSksaX07dC5wYXJzZUNvbnZBdHRyaWJ1dGVzPWU9Pntjb25zdCB0PSgwLHMucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKShlKSxuPWUuZm9ybWF0LHI9W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVtlLmF1dG9fcGFkXSxpPWUuZGlsYXRpb25zLGE9ZS5ncm91cCx1PWUua2VybmVsX3NoYXBlLGw9ZS5wYWRzLGM9ZS5zdHJpZGVzLHA9ZS53X2lzX2NvbnN0KCk7cmV0dXJuKDAsby5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKE9iamVjdC5hc3NpZ24oe2F1dG9QYWQ6cixmb3JtYXQ6bixkaWxhdGlvbnM6aSxncm91cDphLGtlcm5lbFNoYXBlOnUscGFkczpsLHN0cmlkZXM6Yyx3SXNDb25zdDpwfSx0KSl9LHQuY29udj0oZSxuKT0+eygoZSx0KT0+e2lmKCFlfHwyIT09ZS5sZW5ndGgmJjMhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoNCE9PWVbMF0uZGltcy5sZW5ndGgmJjMhPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBvbmx5IHN1cHBvcnQgY29udiAxRCBhbmQgMkRcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZmlsdGVyIGRvZXMgbm90IGhhdmUgc2FtZSBkaW1lbnNpb24gYXMgaW5wdXRcIik7aWYoZVswXS5kaW1zW1wiTkhXQ1wiPT09dC5mb3JtYXQ/ZVswXS5kaW1zLmxlbmd0aC0xOjFdIT09ZVsxXS5kaW1zWzFdKnQuZ3JvdXApdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtpZigzPT09ZS5sZW5ndGgmJigxIT09ZVsyXS5kaW1zLmxlbmd0aHx8ZVsxXS5kaW1zWzBdIT09ZVsyXS5kaW1zWzBdKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJpYXNcIik7Y29uc3Qgbj1lWzBdLmRpbXMubGVuZ3RoLTI7aWYodC5kaWxhdGlvbnMubGVuZ3RoIT09bil0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtufURgKTtpZih0LnN0cmlkZXMubGVuZ3RoIT09bil0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7bn1EYCk7aWYodC5wYWRzLmxlbmd0aCE9PTIqbil0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7MipufURgKTtpZigwIT09dC5rZXJuZWxTaGFwZS5sZW5ndGgmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKDEhPT1lWzBdLmRhdGFUeXBlfHwxIT09ZVsxXS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJDb252IGlucHV0KFgsVykgc2hvdWxkIGJlIGZsb2F0IHRlbnNvclwiKTtpZigzPT09ZS5sZW5ndGgmJjEhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIkNvbnYgaW5wdXQoYmlhcykgc2hvdWxkIGJlIGZsb2F0IHRlbnNvclwiKX0pKGUuaW5wdXRzLG4pLDM9PT1lLmlucHV0c1swXS5kaW1zLmxlbmd0aD8oKGUsdCk9Pntjb25zdCBuPVwiTkhXQ1wiPT09dC5mb3JtYXQscj1bZS5pbnB1dHNbMF0ucmVzaGFwZShuP1tlLmlucHV0c1swXS5kaW1zWzBdLDEsZS5pbnB1dHNbMF0uZGltc1sxXSxlLmlucHV0c1swXS5kaW1zWzJdXTpbZS5pbnB1dHNbMF0uZGltc1swXSxlLmlucHV0c1swXS5kaW1zWzFdLDEsZS5pbnB1dHNbMF0uZGltc1syXV0pLGUuaW5wdXRzWzFdLnJlc2hhcGUoW2UuaW5wdXRzWzFdLmRpbXNbMF0sZS5pbnB1dHNbMV0uZGltc1sxXSwxLGUuaW5wdXRzWzFdLmRpbXNbMl1dKV07Mz09PWUuaW5wdXRzLmxlbmd0aCYmci5wdXNoKGUuaW5wdXRzWzJdKTtjb25zdCBvPVswLHQucGFkc1swXSwwLHQucGFkc1sxXV0sYT1bMV0uY29uY2F0KHQuc3RyaWRlcykscz1bMV0uY29uY2F0KHQuZGlsYXRpb25zKSx1PVsxXS5jb25jYXQodC5rZXJuZWxTaGFwZSksbD1jKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7cGFkczpvLHN0cmlkZXM6YSxkaWxhdGlvbnM6cyxrZXJuZWxTaGFwZTp1fSkscik7ZS5jb21wdXRlKCgwLGkuY3JlYXRlR3JvdXBlZENvbnZQcm9ncmFtSW5mb0xvYWRlcikocixsLChlPT5uP1tlWzBdLGVbMl0sZVszXV06W10pKSl9KShlLG4pOigoZSxuLHIpPT57dmFyIG87Y29uc3Qgcz1jKHIsbikscD0zPT09bi5sZW5ndGgsZD1cIk5IV0NcIj09PXIuZm9ybWF0LGY9blswXS5kaW1zW2Q/MToyXSxoPW5bMF0uZGltc1tkPzI6M10sZz1uWzBdLmRpbXNbZD8zOjFdLG09blsxXS5kaW1zWzJdLGI9blsxXS5kaW1zWzNdLHk9KDAsdC5jYWxjdWxhdGVPdXRwdXRTaGFwZSkoblswXS5kaW1zLG5bMV0uZGltcyxyLmRpbGF0aW9ucyxzLnBhZHMsci5zdHJpZGVzLGQpLHc9eVtkPzE6Ml0sXz15W2Q/MjozXSx2PXlbZD8zOjFdO2lmKGQmJm09PT1mJiZiPT09aCYmXCJWQUxJRFwiPT09ci5hdXRvUGFkfHwxPT09bSYmMT09PWImJjE9PT1yLmRpbGF0aW9uc1swXSYmMT09PXIuZGlsYXRpb25zWzFdJiYxPT09ci5zdHJpZGVzWzBdJiYxPT09ci5zdHJpZGVzWzFdJiYoXCJTQU1FX1VQUEVSXCI9PT1yLmF1dG9QYWR8fFwiU0FNRV9MT1dFUlwiPT09ci5hdXRvUGFkfHxcIlZBTElEXCI9PT1yLmF1dG9QYWQpKXJldHVybiB2b2lkIGUuY29tcHV0ZSgoMCxpLmNyZWF0ZUdyb3VwZWRDb252UHJvZ3JhbUluZm9Mb2FkZXIpKG4scykpO2lmKCFkfHwxIT09ci5ncm91cClyZXR1cm4gdm9pZCBlLmNvbXB1dGUoKDAsaS5jcmVhdGVHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyKShuLHMpKTtjb25zdCB4PWQ/dypfOnYsVD1kP3Y6dypfLFM9bSpiKmcsTz1udWxsIT09KG89ZS5jdXN0b21EYXRhLndUKSYmdm9pZCAwIT09bz9vOmUuY29tcHV0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdS50cmFuc3Bvc2VQcm9ncmFtTWV0YWRhdGEpLHtjYWNoZUhpbnQ6bC5jYWNoZUtleSxnZXQ6KCk9PigwLHUuY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8pKG5bMV0sbC5wZXJtKX0pLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07ci53SXNDb25zdCYmIWUuY3VzdG9tRGF0YS53VCYmKGUuY3VzdG9tRGF0YS53VD1PKTtjb25zdCBBPVtuWzBdLE9dO3AmJihkfHwxIT09blsyXS5kaW1zLmxlbmd0aD9BLnB1c2goblsyXSk6QS5wdXNoKG5bMl0ucmVzaGFwZShbblsyXS5kaW1zWzBdLDEsMV0pKSksZS5jb21wdXRlKCgwLGEuY3JlYXRlQ29udjJETWF0TXVsUHJvZ3JhbUluZm9Mb2FkZXIpKEEscyx5LHgsVCxTLHAsITApLHtpbnB1dHM6QX0pfSkoZSxlLmlucHV0cyxuKX19LDM4MjI6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlQ29udjJETWF0TXVsUHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9bigxMTYzKSxvPW4oOTQ1Nik7dC5jcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mb0xvYWRlcj0oZSx0LG4saSxhLHMsdSxsKT0+e2NvbnN0IGM9KChlLHQpPT4oe25hbWU6XCJDb252MkRNYXRNdWxcIixpbnB1dFR5cGVzOmU/W3IuR3B1RGF0YVR5cGUuZGVmYXVsdCxyLkdwdURhdGFUeXBlLmRlZmF1bHQsci5HcHVEYXRhVHlwZS5kZWZhdWx0XTpbci5HcHVEYXRhVHlwZS5kZWZhdWx0LHIuR3B1RGF0YVR5cGUuZGVmYXVsdF0sY2FjaGVIaW50OnR9KSkodSx0LmNhY2hlS2V5KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGMpLHtnZXQ6KCk9PigwLG8uY3JlYXRlQ29udjJETWF0TXVsUHJvZ3JhbUluZm8pKGUsYyx0LG4saSxhLHMsdSxsKX0pfX0sMzk5NzooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXM9dC5nZXRBY3RpY2F0aW9uU25pcHBldD12b2lkIDA7Y29uc3Qgcj1uKDY5NTIpO3QuZ2V0QWN0aWNhdGlvblNuaXBwZXQ9ZT0+e3N3aXRjaChlLmFjdGl2YXRpb24pe2Nhc2VcIlJlbHVcIjpyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOlwiXCIsYXBwbHlBY3RpdmF0aW9uOlwidmFsdWUgPSBtYXgodmFsdWUsIDAuMCk7XCJ9O2Nhc2VcIlNpZ21vaWRcIjpyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOlwiXCIsYXBwbHlBY3RpdmF0aW9uOlwidmFsdWUgPSAoMS4wIC8gKDEuMCArIGV4cCgtdmFsdWUpKSk7XCJ9O2Nhc2VcIkNsaXBcIjpyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOmBjb25zdCBjbGlwX21pbl89ZjMyKCR7ZS5jbGlwTWlufSk7Y29uc3QgY2xpcF9tYXhfPWYzMigke2UuY2xpcE1heH0pO2AsYXBwbHlBY3RpdmF0aW9uOlwidmFsdWUgPSBjbGFtcCh2YWx1ZSwgY2xpcF9taW5fLCBjbGlwX21heF8pO1wifTtkZWZhdWx0OnJldHVybnthY3RpdmF0aW9uRnVuY3Rpb246XCJcIixhcHBseUFjdGl2YXRpb246XCJcIn19fSx0LnBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcz1lPT57Y29uc3QgdD0obnVsbD09ZT92b2lkIDA6ZS5hY3RpdmF0aW9uKXx8XCJcIjtpZihcIkNsaXBcIj09PXQpe2NvbnN0W24sb109KG51bGw9PWU/dm9pZCAwOmUuYWN0aXZhdGlvbl9wYXJhbXMpfHxbci5NSU5fQ0xJUCxyLk1BWF9DTElQXTtyZXR1cm57YWN0aXZhdGlvbjp0LGNsaXBNYXg6byxjbGlwTWluOm4sYWN0aXZhdGlvbkNhY2hlS2V5OmAke3R9OiR7bn0sJHtvfWB9fXJldHVybnthY3RpdmF0aW9uOnQsYWN0aXZhdGlvbkNhY2hlS2V5OnR9fX0sNDI3MTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZUdlbW1BdHRyaWJ1dGVzPXQuZ2VtbT12b2lkIDA7Y29uc3Qgcj1uKDY5NTIpLG89bigzODcpLGk9bigxMTYzKTt0LmdlbW09KGUsdCk9PnsoZT0+e2lmKCFlKXRocm93IG5ldyBFcnJvcihcIklucHV0IGlzIG1pc3NpbmdcIik7aWYoZS5sZW5ndGg8Mnx8ZS5sZW5ndGg+Myl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhaWQgaW5wdXQgbnVtYmVyLlwiKTtpZigzPT09ZS5sZW5ndGgmJmVbMl0uZGltcy5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHNoYXBlIG9mIENcIik7aWYoMSE9PWVbMF0uZGF0YVR5cGV8fDEhPT1lWzFdLmRhdGFUeXBlfHwzPT09ZS5sZW5ndGgmJjEhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoZVswXS5kYXRhVHlwZSE9PWVbMV0uZGF0YVR5cGV8fDM9PT1lLmxlbmd0aCYmZVswXS5kYXRhVHlwZSE9PWVbMl0uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZXMgYXJlIG1pc21hdGNoZWRcIil9KShlLmlucHV0cyksZS5jb21wdXRlKCgoZSx0KT0+e2NvbnN0IG49e25hbWU6XCJHZW1tXCIsaW5wdXRUeXBlczozPT09ZS5sZW5ndGg/W2kuR3B1RGF0YVR5cGUuZGVmYXVsdCxpLkdwdURhdGFUeXBlLmRlZmF1bHQsaS5HcHVEYXRhVHlwZS5kZWZhdWx0XTpbaS5HcHVEYXRhVHlwZS5kZWZhdWx0LGkuR3B1RGF0YVR5cGUuZGVmYXVsdF0sY2FjaGVIaW50OnQuY2FjaGVLZXl9O3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+KChlLHQsbik9Pntjb25zdCBvPXRbMF0uZGltcy5zbGljZSgpLGE9dFsxXS5kaW1zLnNsaWNlKCksW3MsdSxsXT1yLkdlbW1VdGlsLmdldFNoYXBlT2ZHZW1tUmVzdWx0KG8sbi50cmFuc0EsYSxuLnRyYW5zQiwzPT09dC5sZW5ndGg/dFsyXS5kaW1zOnZvaWQgMCksYz1bcyx1XTtpZighYyl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgZ2VtbSBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtjb25zdCBwPXIuU2hhcGVVdGlsLnNpemUoYyk7bGV0IGQ9XCJcIjtuLnRyYW5zQSYmbi50cmFuc0I/ZD1cInZhbHVlICs9IGFbayAqIE0gKyBtXSAqIGJbbiAqIEsgKyBrXTtcIjpuLnRyYW5zQSYmIW4udHJhbnNCP2Q9XCJ2YWx1ZSArPSBhW2sgKiBNICsgbV0gKiBiW2sgKiBOICsgbl07XCI6IW4udHJhbnNBJiZuLnRyYW5zQj9kPVwidmFsdWUgKz0gYVttICogSyArIGtdICogYltuICogSyArIGtdO1wiOm4udHJhbnNBfHxuLnRyYW5zQnx8KGQ9XCJ2YWx1ZSArPSBhW20gKiBLICsga10gKiBiW2sgKiBOICsgbl07XCIpO2NvbnN0IGY9XCJmMzJcIixoPTE9PT1uLmFscGhhP1wiXCI6XCJ2YWx1ZSAqPSBhbHBoYTtcIixnPTM9PT10Lmxlbmd0aD9gdmFsdWUgKz0gYmV0YSAqIGNbJHsoKGUsdCxuKT0+e2lmKDA9PT1uLmxlbmd0aClyZXR1cm5cIjB1XCI7Y29uc3Qgcj0xPT09bi5sZW5ndGgmJjEhPT1lfHwyPT09bi5sZW5ndGgmJm5bMF0hPT1lLG89bltuLmxlbmd0aC0xXSE9PXQ7bGV0IGk9XCIwdVwiO3JldHVybiByfHwoaSs9YCsgbSAqICR7bltuLmxlbmd0aC0xXX11YCksb3x8KGkrPVwiK25cIiksaX0pKHMsdSx0WzJdLmRpbXMpfV07YDpcIlwiLG09W2BAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGEgOiBhcnJheTwke2Z9PjtgLGBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGIgOiBhcnJheTwke2Z9PjtgXTtyZXR1cm4gMz09PXQubGVuZ3RoJiZtLnB1c2goYEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZD4gYyA6IGFycmF5PCR7Zn0+O2ApLE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0czpbe2RpbXM6YyxkYXRhVHlwZTp0WzBdLmRhdGFUeXBlLGdwdURhdGFUeXBlOmkuR3B1RGF0YVR5cGUuZGVmYXVsdH1dLGdldFNoYWRlclNvdXJjZTplPT5gXFxuICBjb25zdCBNOiB1MzIgPSAke3N9dTtcXG4gIGNvbnN0IE46IHUzMiA9ICR7dX11O1xcbiAgY29uc3QgSzogdTMyID0gJHtsfXU7XFxuICBjb25zdCBhbHBoYSA9ICR7Zn0oJHtuLmFscGhhfSk7XFxuICBjb25zdCBiZXRhID0gJHtmfSgke24uYmV0YX0pO1xcblxcbiAgJHttLmpvaW4oXCJcXG5cIil9XFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHt0Lmxlbmd0aH0pIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke2Z9PjtcXG5cXG4gICR7ZS5tYWluU3RhcnQoKX1cXG4gICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMocCl9XFxuXFxuICAgIGxldCBtID0gZ2xvYmFsX2lkLnggLyBOO1xcbiAgICBsZXQgbiA9IGdsb2JhbF9pZC54ICUgTjtcXG5cXG4gICAgdmFyIHZhbHVlID0gJHtmfSgwKTtcXG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGs8JHtsfXU7IGsrKykge1xcbiAgICAgICR7ZH1cXG4gICAgfVxcblxcbiAgICAke2h9XFxuICAgICR7Z31cXG4gICAgb3V0cHV0W2dsb2JhbF9pZC54XSA9IHZhbHVlO1xcblxcbiAgfWAsZGlzcGF0Y2hHcm91cDooKT0+KHt4Ok1hdGguY2VpbChwLzY0KX0pfSl9KShuLGUsdCl9KX0pKGUuaW5wdXRzLHQpKX0sdC5wYXJzZUdlbW1BdHRyaWJ1dGVzPWU9PigwLG8uY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KShlKX0sMTUyMjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5tYXRNdWw9dC5jcmVhdGVNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDY5NTIpLG89bigxMTYzKSxpPW4oMzk5Nyk7dC5jcmVhdGVNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcj0oZSx0KT0+e2NvbnN0IG49KGE9ZS5sZW5ndGg+MixzPXQuYWN0aXZhdGlvbkNhY2hlS2V5LHtuYW1lOlwiTWF0TXVsXCIsaW5wdXRUeXBlczphP1tvLkdwdURhdGFUeXBlLmRlZmF1bHQsby5HcHVEYXRhVHlwZS5kZWZhdWx0LG8uR3B1RGF0YVR5cGUuZGVmYXVsdF06W28uR3B1RGF0YVR5cGUuZGVmYXVsdCxvLkdwdURhdGFUeXBlLmRlZmF1bHRdLGNhY2hlSGludDpzfSk7dmFyIGEscztyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtnZXQ6KCk9PigoZSx0LG4pPT57Y29uc3QgYT10WzBdLmRpbXMscz10WzFdLmRpbXMsdT1yLkJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGEscywhMCk7aWYoIXUpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtjb25zdCBsPXIuU2hhcGVVdGlsLnNpemUodSksYz1cImYzMlwiLHthY3RpdmF0aW9uRnVuY3Rpb246cCxhcHBseUFjdGl2YXRpb246ZH09KDAsaS5nZXRBY3RpY2F0aW9uU25pcHBldCkobiksZj11W3UubGVuZ3RoLTJdLGg9YVthLmxlbmd0aC0xXSxnPXVbdS5sZW5ndGgtMV07cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0czpbe2RpbXM6dSxkYXRhVHlwZTp0WzBdLmRhdGFUeXBlLGdwdURhdGFUeXBlOm8uR3B1RGF0YVR5cGUuZGVmYXVsdH1dLGdldFNoYWRlclNvdXJjZTplPT5gXFxuICBjb25zdCBNOiB1MzIgPSAke2Z9dTtcXG4gIGNvbnN0IE46IHUzMiA9ICR7Z311O1xcbiAgY29uc3QgSzogdTMyID0gJHtofXU7XFxuXFxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMCkgdmFyPHN0b3JhZ2UsIHJlYWQ+IGEgOiBhcnJheTwke2N9PjtcXG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gYiA6IGFycmF5PCR7Y30+O1xcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke2N9PjtcXG5cXG4gICR7cH1cXG5cXG4gICR7ZS5tYWluU3RhcnQoKX1cXG4gICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMobCl9XFxuXFxuICAgIGxldCBzdGFjayA9IGdsb2JhbF9pZHggLyAoTSAqIE4pO1xcbiAgICBsZXQgbW4gPSBnbG9iYWxfaWR4ICUgKE0gKiBOKTtcXG4gICAgbGV0IG4gPSBnbG9iYWxfaWR4ICUgTjtcXG4gICAgbGV0IG0gPSBtbiAvIE47XFxuXFxuICAgIGxldCBvZmZzZXRBID0gc3RhY2sgKiAoTSAqIEspO1xcbiAgICBsZXQgb2Zmc2V0QiA9IHN0YWNrICogKEsgKiBOKTtcXG5cXG4gICAgdmFyIHZhbHVlID0gJHtjfSgwKTtcXG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGs8JHtofXU7IGsrKykge1xcbiAgICAgIHZhbHVlICs9IGFbb2Zmc2V0QSArIG0gKiBLICsga10gKiBiW29mZnNldEIgKyBrICogTiArIG5dO1xcbiAgICB9XFxuICAgICR7ZH1cXG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XFxuICB9YCxkaXNwYXRjaEdyb3VwOigpPT4oe3g6TWF0aC5jZWlsKGwvNjQpfSl9KX0pKG4sZSx0KX0pfSx0Lm1hdE11bD1lPT57KGU9PntpZighZXx8MiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk1hdE11bCByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zW2VbMF0uZGltcy5sZW5ndGgtMV0hPT1lWzFdLmRpbXNbZVsxXS5kaW1zLmxlbmd0aC0yXSl0aHJvdyBuZXcgRXJyb3IoXCJzaGFyZWQgZGltZW5zaW9uIGRvZXMgbm90IG1hdGNoLlwiKTtpZigxIT09ZVswXS5kYXRhVHlwZXx8MSE9PWVbMV0uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRzIHNob3VsZCBiZSBmbG9hdCB0eXBlXCIpfSkoZS5pbnB1dHMpLGUuY29tcHV0ZSgoMCx0LmNyZWF0ZU1hdG11bFByb2dyYW1JbmZvTG9hZGVyKShlLmlucHV0cyx7YWN0aXZhdGlvbjpcIlwiLGFjdGl2YXRpb25DYWNoZUtleTpcIlwifSkpfX0sNTI2MjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nbG9iYWxNYXhQb29sPXQucGFyc2VHbG9iYWxNYXhQb29sQXR0cmlidXRlcz10LnBhcnNlTWF4UG9vbEF0dHJpYnV0ZXM9dC5tYXhQb29sPXQuZ2xvYmFsQXZlcmFnZVBvb2w9dC5wYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlcz10LmF2ZXJhZ2VQb29sPXQucGFyc2VBdmVyYWdlUG9vbEF0dHJpYnV0ZXM9dm9pZCAwO2NvbnN0IHI9big2OTUyKSxvPW4oMzg3KSxpPW4oMTE2MyksYT1uKDIwNzUpLHM9ZT0+e2lmKCFlfHwxIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUG9vbCBvcHMgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoNCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUG9vbCBvcHMgc3VwcG9ydHMgMi1EIGlucHV0cyBvbmx5IGZvciBub3cuXCIpO2lmKDEhPT1lWzBdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9LHU9KGUsdCxuKT0+e2NvbnN0IG89XCJOSFdDXCI9PT10LmZvcm1hdCxpPW8/W2VbMF0uZGltc1swXSxlWzBdLmRpbXNbM10sZVswXS5kaW1zWzFdLGVbMF0uZGltc1syXV06ZVswXS5kaW1zLnNsaWNlKCksYT1PYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0LFwiZGlsYXRpb25zXCIpLHM9dC5rZXJuZWxTaGFwZS5zbGljZSgpLHU9dC5zdHJpZGVzLnNsaWNlKCksbD1hP3QuZGlsYXRpb25zLnNsaWNlKCk6W10sYz10LnBhZHMuc2xpY2UoKTtyLlBvb2xDb252VXRpbC5hZGp1c3RQb29sQXR0cmlidXRlcyhuLGkscyx1LGwsYyk7Y29uc3QgcD1yLlBvb2xDb252VXRpbC5jb21wdXRlUG9vbE91dHB1dFNoYXBlKG4saSx1LGwscyxjLHQuYXV0b1BhZCksZD1PYmplY3QuYXNzaWduKHt9LHQpO3JldHVybiBhP09iamVjdC5hc3NpZ24oZCx7a2VybmVsU2hhcGU6cyxzdHJpZGVzOnUscGFkczpjLGRpbGF0aW9uczpsLGNhY2hlS2V5OnQuY2FjaGVLZXl9KTpPYmplY3QuYXNzaWduKGQse2tlcm5lbFNoYXBlOnMsc3RyaWRlczp1LHBhZHM6YyxjYWNoZUtleTp0LmNhY2hlS2V5fSksW2Qsbz9bcFswXSxwWzJdLHBbM10scFsxXV06cF19LGw9KGUsdCxuLG8saSxzLHUsbCk9Pntjb25zdCBjPVwiTkhXQ1wiPT09by5mb3JtYXQscD10Lmxlbmd0aCxkPXIuU2hhcGVVdGlsLnNpemUobiksZj0oMCxhLmNyZWF0ZUluZGljZXNIZWxwZXIpKFwib3V0cHV0XCIsbiksaD0oMCxhLmNyZWF0ZUluZGljZXNIZWxwZXIpKFwieFwiLHQpO2lmKG8ua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtjb25zdCBuPW8ua2VybmVsU2hhcGVbby5rZXJuZWxTaGFwZS5sZW5ndGgtMV0scj1vLnN0cmlkZXNbby5zdHJpZGVzLmxlbmd0aC0xXSxhPW8ucGFkc1tvLnBhZHMubGVuZ3RoLzItMV0sZz1wLShjPzI6MSk7bGV0IG09XCJcIixiPVwiXCIseT1cIlwiO2lmKG09YStvLnBhZHNbby5wYWRzLmxlbmd0aC0xXSE9PTA/YFxcbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke259dTsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7Z31dID0gaW5kaWNlc1ske2d9XSAqICR7cn0gLSAke2F9ICsgaTtcXG4gICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzWyR7Z31dIDwgMCB8fCB4SW5kaWNlc1ske2d9XSA+PSAke3RbZ119KSB7XFxuICAgICAgICAgICAgICAgICAgcGFkKys7XFxuICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske2guaTJvRXhwcmVzc2lvbihcInhJbmRpY2VzXCIpfV07XFxuICAgICAgICAgICAgICAgICR7aX1cXG4gICAgICAgICAgICAgIH1gOmBcXG4gICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtufXU7IGkrKykge1xcbiAgICAgICAgICAgICAgICB4SW5kaWNlc1ske2d9XSA9IGluZGljZXNbJHtnfV0gKiAke3J9IC0gJHthfSArIGk7XFxuICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHtoLmkyb0V4cHJlc3Npb24oXCJ4SW5kaWNlc1wiKX1dO1xcbiAgICAgICAgICAgICAgICAke2l9XFxuICAgICAgICAgICAgICB9YCwyPT09by5rZXJuZWxTaGFwZS5sZW5ndGgpe2NvbnN0IGU9by5rZXJuZWxTaGFwZVtvLmtlcm5lbFNoYXBlLmxlbmd0aC0yXSxyPW8uc3RyaWRlc1tvLnN0cmlkZXMubGVuZ3RoLTJdLGk9by5wYWRzW28ucGFkcy5sZW5ndGgvMi0yXSxhPW8ucGFkc1tvLnBhZHMubGVuZ3RoLTJdLHM9cC0oYz8zOjIpLHU9dFtzXTtiPWkrYSE9PTA/YFxcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8ICR7ZX11OyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske3N9XSA9IGluZGljZXNbJHtzfV0gKiAke3J9IC0gJHtpfSArIGo7XFxuICAgICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzWyR7c31dIDwgMCB8fCB4SW5kaWNlc1ske3N9XSA+PSAke3V9KSB7XFxuICAgICAgICAgICAgICAgICAgICBwYWQrPSAke259O1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgYDpgXFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgJHtlfXU7IGorKykge1xcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7c31dID0gaW5kaWNlc1ske3N9XSAqICR7cn0gLSAke2l9ICsgajtcXG4gICAgICAgICAgICAgICAgYCx5PVwiXFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgXCJ9cmV0dXJuYFxcbiAgICAgICAgICAgIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4geCA6IGFycmF5PCR7dX0+O1xcbiAgICAgICAgICAgIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHt1fT47XFxuXFxuICAgICAgICAgICAgJHtmLm8yaUltcGx9XFxuICAgICAgICAgICAgJHtoLmkyb0ltcGx9XFxuXFxuICAgICAgICAgICAgJHtlLm1haW5TdGFydCgpfVxcbiAgICAgICAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoZCl9XFxuXFxuICAgICAgICAgICAgICAke2YuaW5kaWNlc1ZhcmlhYmxlRGVjbGFyYXRpb24oXCJpbmRpY2VzXCIpfVxcbiAgICAgICAgICAgICAgJHtmLm8yaUNhbGwoXCJnbG9iYWxfaWR4XCIsXCJpbmRpY2VzXCIpfVxcbiAgICAgICAgICAgICAgJHtmLmluZGljZXNWYXJpYWJsZURlY2xhcmF0aW9uKFwieEluZGljZXNcIil9XFxuICAgICAgICAgICAgICAke2YubzJpQ2FsbChcImdsb2JhbF9pZHhcIixcInhJbmRpY2VzXCIpfVxcblxcbiAgICAgICAgICAgICAgdmFyIHZhbHVlOiAke3V9ID0gJHt1fSgke2x9KTtcXG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xcbiAgICAgICAgICAgICAgJHtifVxcbiAgICAgICAgICAgICAgJHttfVxcbiAgICAgICAgICAgICAgJHt5fVxcbiAgICAgICAgICAgICAgJHtzfVxcblxcbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XFxuICAgICAgICAgICAgfWB9e2lmKGMpdGhyb3cgbmV3IEVycm9yKFwiUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuXCIpO2NvbnN0IG49ci5TaGFwZVV0aWwuc2l6ZShvLmtlcm5lbFNoYXBlKSxhPXIuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKG8ua2VybmVsU2hhcGUpLGc9YS5sZW5ndGgsbT1vLnBhZHMubGVuZ3RoO2xldCBiPVwiXCI7cmV0dXJuIGI9by5wYWRzLnJlZHVjZSgoKGUsdCk9PmUrdCkpP2BcXG4gICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzW2pdID49IGlucHV0RGltc1tqXSkge1xcbiAgICAgICAgICAgICAgICAgIHBhZCsrO1xcbiAgICAgICAgICAgICAgICAgIGlzUGFkID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgaWYgKCFpc1BhZCkge1xcbiAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7aC5pMm9FeHByZXNzaW9uKFwieEluZGljZXNcIil9XTtcXG4gICAgICAgICAgICAgICAgJHtpfVxcbiAgICAgICAgICAgICAgfWA6YFxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske2guaTJvRXhwcmVzc2lvbihcInhJbmRpY2VzXCIpfV07XFxuICAgICAgICAgICAgICAke2l9XFxuICAgICAgICAgICAgYCxgXFxuICAgICAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiB4IDogYXJyYXk8JHt1fT47XFxuICAgICAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke3V9PjtcXG5cXG4gICAgICAgICAgICAke2YubzJpSW1wbH1cXG4gICAgICAgICAgICAke2guaTJvSW1wbH1cXG5cXG4gICAgICAgICAgICBjb25zdCBwYWRzID0gYXJyYXk8dTMyLCAke219Pigke28ucGFkcy5tYXAoKGU9PmAke2V9dWApKS5qb2luKFwiLFwiKX0pO1xcbiAgICAgICAgICAgIGNvbnN0IGlucHV0RGltcyA9IGFycmF5PHUzMiwgJHtwfT4oJHt0Lm1hcCgoZT0+YCR7ZX11YCkpLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICAgICAgY29uc3Qga2VybmVsU3RyaWRlcyA9IGFycmF5PHUzMiwgJHtnfT4oJHthLm1hcCgoZT0+YCR7ZX11YCkpLmpvaW4oXCIsXCIpfSk7XFxuICAgICAgICAgICAgY29uc3Qgc3RyaWRlcyA9IGFycmF5PHUzMiwgJHtnfT4oJHtvLnN0cmlkZXMubWFwKChlPT5gJHtlfXVgKSkuam9pbihcIixcIil9KTtcXG5cXG4gICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XFxuICAgICAgICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhkKX1cXG5cXG4gICAgICAgICAgICAgICR7Zi5pbmRpY2VzVmFyaWFibGVEZWNsYXJhdGlvbihcImluZGljZXNcIil9XFxuICAgICAgICAgICAgICAke2YubzJpQ2FsbChcImdsb2JhbF9pZHhcIixcImluZGljZXNcIil9XFxuICAgICAgICAgICAgICAke2YuaW5kaWNlc1ZhcmlhYmxlRGVjbGFyYXRpb24oXCJ4SW5kaWNlc1wiKX1cXG4gICAgICAgICAgICAgICR7Zi5vMmlDYWxsKFwiZ2xvYmFsX2lkeFwiLFwieEluZGljZXNcIil9XFxuXFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0czogYXJyYXk8dTMyLCAke2d9PjtcXG5cXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7dX0oJHtsfSk7XFxuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcXG4gICAgICAgICAgICAgIHZhciBpc1BhZCA9IGZhbHNlO1xcblxcbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke259dTsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpO1xcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMHU7IGogPCAke2ctMX11OyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICBvZmZzZXRzW2pdID0gb2Zmc2V0IC8ga2VybmVsU3RyaWRlc1tqXTtcXG4gICAgICAgICAgICAgICAgICBvZmZzZXQgLT0gb2Zmc2V0c1tqXSAqIGtlcm5lbFN0cmlkZXNbal07XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgb2Zmc2V0c1ske2ctMX1dID0gb2Zmc2V0O1xcblxcbiAgICAgICAgICAgICAgICBpc1BhZCA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gJHtwLWd9dTsgaiA8ICR7cH11OyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1tqXSA9IGluZGljZXNbal0gKiBzdHJpZGVzW2ogLSAke3AtZ311XVxcbiAgICAgICAgICAgICAgICAgICAgKyBvZmZzZXRzW2ogLSAke3AtZ311XSAtIHBhZHNbaiAtIDJ1XTtcXG4gICAgICAgICAgICAgICAgICAke2J9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAke3N9XFxuXFxuICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcXG4gICAgICAgICAgICB9YH19LGM9ZT0+KHtmb3JtYXQ6ZS5mb3JtYXQsYXV0b1BhZDpbXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW2UuYXV0b19wYWRdLGNlaWxNb2RlOmUuY2VpbF9tb2RlLGtlcm5lbFNoYXBlOmUua2VybmVsX3NoYXBlLHN0cmlkZXM6ZS5zdHJpZGVzLHBhZHM6ZS5wYWRzfSkscD0oZSx0LG4sbyk9Pntjb25zdFthLHNdPXUoZSxvLG4pLGM9ci5TaGFwZVV0aWwuc2l6ZShhLmtlcm5lbFNoYXBlKSxwPVwiZjMyXCI7bGV0IGQ9XCJcIjtyZXR1cm4gYS5jb3VudEluY2x1ZGVQYWQ/ZCs9YHZhbHVlIC89ICR7cH0oJHtjfSk7YDpkKz1gdmFsdWUgLz0gJHtwfSgke2N9IC0gcGFkKTtgLE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7b3V0cHV0czpbe2RpbXM6cyxkYXRhVHlwZTplWzBdLmRhdGFUeXBlLGdwdURhdGFUeXBlOmkuR3B1RGF0YVR5cGUuZGVmYXVsdH1dLGdldFNoYWRlclNvdXJjZTp0PT5sKHQsZVswXS5kaW1zLHMsYSxcInZhbHVlICs9IHhfdmFsO1wiLGQscCxcIjAuMFwiKSxkaXNwYXRjaEdyb3VwOigpPT4oe3g6TWF0aC5jZWlsKHIuU2hhcGVVdGlsLnNpemUocykvNjQpfSl9KX07dC5wYXJzZUF2ZXJhZ2VQb29sQXR0cmlidXRlcz1lPT57Y29uc3QgdD0wIT09ZS5jb3VudF9pbmNsdWRlX3BhZCxuPWMoZSk7aWYoMCE9PW4uY2VpbE1vZGUpdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBBdmVyYWdlUG9vbFwiKTtyZXR1cm4oMCxvLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoT2JqZWN0LmFzc2lnbih7Y291bnRJbmNsdWRlUGFkOnR9LG4pKX0sdC5hdmVyYWdlUG9vbD0oZSx0KT0+e3MoZS5pbnB1dHMpO2NvbnN0IG49e25hbWU6XCJBdmVyYWdlUG9vbFwiLGlucHV0VHlwZXM6W2kuR3B1RGF0YVR5cGUuZGVmYXVsdF0sY2FjaGVIaW50OnQuY2FjaGVLZXl9O2UuY29tcHV0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+cChlLmlucHV0cyxuLCExLHQpfSkpfTtjb25zdCBkPXthdXRvUGFkOlwiXCIsY2VpbE1vZGU6MCxjb3VudEluY2x1ZGVQYWQ6ITEsa2VybmVsU2hhcGU6W10sc3RyaWRlczpbXSxwYWRzOltdLHN0b3JhZ2VPcmRlcjowLGRpbGF0aW9uczpbXSxjYWNoZUtleTpcIlwifTt0LnBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzPWU9Pntjb25zdCB0PWUuZm9ybWF0O3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe2Zvcm1hdDp0fSxkKSx7Y2FjaGVLZXk6dH0pfSx0Lmdsb2JhbEF2ZXJhZ2VQb29sPShlLHQpPT57cyhlLmlucHV0cyk7Y29uc3Qgbj17bmFtZTpcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsaW5wdXRUeXBlczpbaS5HcHVEYXRhVHlwZS5kZWZhdWx0XSxjYWNoZUhpbnQ6dC5jYWNoZUtleX07ZS5jb21wdXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7Z2V0OigpPT5wKGUuaW5wdXRzLG4sITAsdCl9KSl9O2NvbnN0IGY9KGUsdCxuLG8pPT57Y29uc3RbYSxzXT11KGUsbyxuKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXRzOlt7ZGltczpzLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6aS5HcHVEYXRhVHlwZS5kZWZhdWx0fV0sZ2V0U2hhZGVyU291cmNlOnQ9PmwodCxlWzBdLmRpbXMscyxhLFwiXFxuICAgICAgdmFsdWUgPSBtYXgoeF92YWwsIHZhbHVlKTtcXG4gICAgXCIsXCJcIixcImYzMlwiLFwiLTFlNVwiKSxkaXNwYXRjaEdyb3VwOigpPT4oe3g6TWF0aC5jZWlsKHIuU2hhcGVVdGlsLnNpemUocykvNjQpfSl9KX07dC5tYXhQb29sPShlLHQpPT57cyhlLmlucHV0cyk7Y29uc3Qgbj17bmFtZTpcIk1heFBvb2xcIixpbnB1dFR5cGVzOltpLkdwdURhdGFUeXBlLmRlZmF1bHRdLGNhY2hlSGludDp0LmNhY2hlS2V5fTtlLmNvbXB1dGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtnZXQ6KCk9PmYoZS5pbnB1dHMsbiwhMSx0KX0pKX0sdC5wYXJzZU1heFBvb2xBdHRyaWJ1dGVzPWU9Pntjb25zdCB0PWUuc3RvcmFnZV9vcmRlcixuPWUuZGlsYXRpb25zLHI9YyhlKTtpZigwIT09dCl0aHJvdyBuZXcgRXJyb3IoXCJjb2x1bW4gbWFqb3Igc3RvcmFnZSBvcmRlciBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtpZigwIT09ci5jZWlsTW9kZSl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7cmV0dXJuKDAsby5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKE9iamVjdC5hc3NpZ24oe3N0b3JhZ2VPcmRlcjp0LGRpbGF0aW9uczpufSxyKSl9LHQucGFyc2VHbG9iYWxNYXhQb29sQXR0cmlidXRlcz1lPT57Y29uc3QgdD1lLmZvcm1hdDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHtmb3JtYXQ6dH0sZCkse2NhY2hlS2V5OnR9KX0sdC5nbG9iYWxNYXhQb29sPShlLHQpPT57cyhlLmlucHV0cyk7Y29uc3Qgbj17bmFtZTpcIkdsb2JhbE1heFBvb2xcIixpbnB1dFR5cGVzOltpLkdwdURhdGFUeXBlLmRlZmF1bHRdLGNhY2hlSGludDp0LmNhY2hlS2V5fTtlLmNvbXB1dGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtnZXQ6KCk9PmYoZS5pbnB1dHMsbiwhMCx0KX0pKX19LDI2MjU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzPXQudHJhbnNwb3NlPXQuY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm89dC50cmFuc3Bvc2VQcm9ncmFtTWV0YWRhdGE9dm9pZCAwO2NvbnN0IHI9big2OTUyKSxvPW4oMzg3KSxpPW4oMTE2MyksYT1uKDIwNzUpO3QudHJhbnNwb3NlUHJvZ3JhbU1ldGFkYXRhPXtuYW1lOlwiVHJhbnNwb3NlXCIsaW5wdXRUeXBlczpbaS5HcHVEYXRhVHlwZS5kZWZhdWx0XX07Y29uc3Qgcz0oZSx0KT0+dCYmdC5sZW5ndGghPT1lLmxlbmd0aD9bLi4uZS5rZXlzKCldLnJldmVyc2UoKTp0O3QuY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm89KGUsbik9Pntjb25zdCBvPWUuZGltcyx1PXMobyxuKSxsPSgoZSx0KT0+ci5TaGFwZVV0aWwuc29ydEJhc2VkT25QZXJtKGUscyhlLHQpKSkobyx1KSxjPW8ubGVuZ3RoLHA9ci5TaGFwZVV0aWwuc2l6ZShsKSxkPSgwLGEuY3JlYXRlSW5kaWNlc0hlbHBlcikoXCJvdXRwdXRcIixsKSxmPSgwLGEuY3JlYXRlSW5kaWNlc0hlbHBlcikoXCJhXCIsbyk7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0LnRyYW5zcG9zZVByb2dyYW1NZXRhZGF0YSkse291dHB1dHM6W3tkaW1zOmwsZGF0YVR5cGU6ZS5kYXRhVHlwZSxncHVEYXRhVHlwZTppLkdwdURhdGFUeXBlLmRlZmF1bHR9XSxnZXRTaGFkZXJTb3VyY2U6ZT0+YFxcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBhIDogYXJyYXk8ZjMyPjtcXG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8ZjMyPjtcXG5cXG4gICR7KChlLHQpPT57Y29uc3Qgbj1bXTtuLnB1c2goYGZuIHBlcm0oYTogcHRyPGZ1bmN0aW9uLCBhcnJheTx1MzIsICR7dH0+PiwgaTogcHRyPGZ1bmN0aW9uLCBhcnJheTx1MzIsICR7dH0+Pikge2ApO2ZvcihsZXQgcj0wO3I8dDsrK3Ipbi5wdXNoKGBcXHQoKmEpWyR7ZVtyXX1dPSgqaSlbJHtyfV07YCk7cmV0dXJuIG4ucHVzaChcIlxcdH1cIiksbi5qb2luKFwiXFxuXCIpfSkodSxjKX1cXG4gICR7ZC5vMmlJbXBsfVxcbiAgJHtmLmkyb0ltcGx9XFxuXFxuICAke2UubWFpblN0YXJ0KCl9XFxuICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHApfVxcblxcbiAgICAke2QuaW5kaWNlc1ZhcmlhYmxlRGVjbGFyYXRpb24oXCJpbmRpY2VzXCIpfVxcbiAgICAke2QubzJpQ2FsbChcImdsb2JhbF9pZHhcIixcImluZGljZXNcIil9XFxuICAgICR7Zi5pbmRpY2VzVmFyaWFibGVEZWNsYXJhdGlvbihcImFJbmRpY2VzXCIpfVxcbiAgICBwZXJtKCZhSW5kaWNlcywgJmluZGljZXMpO1xcblxcbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBhWyR7Zi5pMm9FeHByZXNzaW9uKFwiYUluZGljZXNcIil9XTtcXG4gIH1gLGRpc3BhdGNoR3JvdXA6KCk9Pih7eDpNYXRoLmNlaWwocC82NCl9KX0pfSx0LnRyYW5zcG9zZT0oZSxuKT0+eyhlPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3Bvc2UgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoMSE9PWVbMF0uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGJlIGZsb2F0IHRlbnNvclwiKX0pKGUuaW5wdXRzKSxlLmNvbXB1dGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQudHJhbnNwb3NlUHJvZ3JhbU1ldGFkYXRhKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT4oMCx0LmNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKShlLmlucHV0c1swXSxuLnBlcm0pfSkpfSx0LnBhcnNlVHJhbnNwb3NlQXR0cmlidXRlcz1lPT4oMCxvLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe3Blcm06ZS5wZXJtfSl9LDkzMDI6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQudGhyZXNob2xkZWRSZWx1PXQudGFuaD10LnRhbj10LnNxcnQ9dC5zaW5oPXQuc2luPXQuc2lnbW9pZD10LnJlbHU9dC5yZWNpcHJvY2FsPXQubmVnPXQubGVha3lSZWx1PXQuZmxvb3I9dC5leHA9dC5lcmY9dC5lbHU9dC5wYXJzZUFscGhhQXR0cmlidXRlcz10LmNvc2g9dC5jb3M9dC5jZWlsPXQuY2xpcD10LmNsaXBWMTA9dC5hdGFuaD10LmF0YW49dC5hc2luaD10LmFzaW49dC5hY29zaD10LmFjb3M9dC5hYnM9dm9pZCAwO2NvbnN0IHI9big2OTUyKSxvPW4oMzg3KSxpPW4oMTE2MyksYT0oZSx0LG4sbyxhKT0+e2NvbnN0IHM9e25hbWU6dCxpbnB1dFR5cGVzOltpLkdwdURhdGFUeXBlLmRlZmF1bHRdLGNhY2hlSGludDphfTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtnZXQ6KCk9PigoZSx0LG4sbyk9Pk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7Z2V0U2hhZGVyU291cmNlOmU9PigoZSx0LG4scik9Pntjb25zdCBvPU1hdGguY2VpbCh0LzQpO2xldCBpPVwiXCI7cmV0dXJuIGk9XCJzdHJpbmdcIj09dHlwZW9mIG4/YCR7bn0oYSlgOm4oXCJhXCIpLGBcXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gaW5wdXREYXRhIDogYXJyYXk8dmVjNDxmMzI+PjtcXG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0RGF0YSA6IGFycmF5PHZlYzQ8ZjMyPj47XFxuXFxuICAke251bGwhPXI/cjpcIlwifVxcblxcbiAgJHtlLm1haW5TdGFydCgpfVxcbiAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhvKX1cXG5cXG4gICAgbGV0IGEgPSBpbnB1dERhdGFbZ2xvYmFsX2lkeF07XFxuICAgIG91dHB1dERhdGFbZ2xvYmFsX2lkeF0gPSAke2l9O1xcbiAgfWB9KShlLHIuU2hhcGVVdGlsLnNpemUodC5kaW1zKSxuLG8pLG91dHB1dHM6W3tkaW1zOnQuZGltcyxkYXRhVHlwZTp0LmRhdGFUeXBlLGdwdURhdGFUeXBlOmkuR3B1RGF0YVR5cGUuZGVmYXVsdH1dLGRpc3BhdGNoR3JvdXA6ZT0+KHt4Ok1hdGguY2VpbChyLlNoYXBlVXRpbC5zaXplKGVbMF0uZGltcykvNjQvNCl9KX0pKShzLGUsbixvKX0pfTt0LmFicz1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJBYnNcIixcImFic1wiKSl9LHQuYWNvcz1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJBY29zXCIsXCJhY29zXCIpKX0sdC5hY29zaD1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJBY29zaFwiLFwiYWNvc2hcIikpfSx0LmFzaW49ZT0+e2UuY29tcHV0ZShhKGUuaW5wdXRzWzBdLFwiQXNpblwiLFwiYXNpblwiKSl9LHQuYXNpbmg9ZT0+e2UuY29tcHV0ZShhKGUuaW5wdXRzWzBdLFwiQXNpbmhcIixcImFzaW5oXCIpKX0sdC5hdGFuPWU9PntlLmNvbXB1dGUoYShlLmlucHV0c1swXSxcIkF0YW5cIixcImF0YW5cIikpfSx0LmF0YW5oPWU9PntlLmNvbXB1dGUoYShlLmlucHV0c1swXSxcIkF0YW5oXCIsXCJhdGFuaFwiKSl9LHQuY2xpcFYxMD0oZSx0KT0+e2UuY29tcHV0ZShhKGUuaW5wdXRzWzBdLFwiQ2xpcFwiLChlPT5gY2xhbXAoJHtlfSwgY2xpcF9taW5fLCBjbGlwX21heF8pYCksYFxcbiAgICBjb25zdCBjbGlwX21pbl86IHZlYzQ8ZjMyPiA9IHZlYzQoZjMyKCR7dC5taW59KSk7XFxuICAgIGNvbnN0IGNsaXBfbWF4XzogdmVjNDxmMzI+ID0gdmVjNChmMzIoJHt0Lm1heH0pKTtcXG5gLHQuY2FjaGVLZXkpLHtpbnB1dHM6WzBdfSl9LHQuY2xpcD1lPT57Y29uc3Qgbj0oZT0+e2NvbnN0IHQ9ZS5sZW5ndGg+PTI/ZVsxXS5nZXRGbG9hdDMyQXJyYXkoKVswXTpyLk1JTl9DTElQLG49ZS5sZW5ndGg+PTM/ZVsyXS5nZXRGbG9hdDMyQXJyYXkoKVswXTpyLk1BWF9DTElQO3JldHVybigwLG8uY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7bWluOnQsbWF4Om59KX0pKGUuaW5wdXRzKTsoMCx0LmNsaXBWMTApKGUsbil9LHQuY2VpbD1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJDZWlsXCIsXCJjZWlsXCIpKX0sdC5jb3M9ZT0+e2UuY29tcHV0ZShhKGUuaW5wdXRzWzBdLFwiQ29zXCIsXCJjb3NcIikpfSx0LmNvc2g9ZT0+e2UuY29tcHV0ZShhKGUuaW5wdXRzWzBdLFwiQ29zaFwiLFwiY29zaFwiKSl9LHQucGFyc2VBbHBoYUF0dHJpYnV0ZXM9ZT0+KDAsby5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKGUpLHQuZWx1PShlLHQpPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJFbHVcIiwoZT0+YGVsdV92ZjMyKCR7ZX0pYCksYFxcbiAgY29uc3QgZWx1X2FscGhhXzogZjMyID0gZjMyKCR7dC5hbHBoYX0pO1xcblxcbiAgZm4gZWx1X2YzMihhOiBmMzIpIC0+IGYzMiB7XFxuICByZXR1cm4gc2VsZWN0KChleHAoYSkgLSAxLjApICogZWx1X2FscGhhXywgYSwgYSA+PSAwLjApO1xcbiAgfVxcblxcbiAgZm4gZWx1X3ZmMzIodjogdmVjNDxmMzI+KSAtPiB2ZWM0PGYzMj4ge1xcbiAgcmV0dXJuIHZlYzQoZWx1X2YzMih2LngpLCBlbHVfZjMyKHYueSksIGVsdV9mMzIodi56KSwgZWx1X2YzMih2LncpKTtcXG4gIH1gLHQuY2FjaGVLZXkpKX0sdC5lcmY9ZT0+e2UuY29tcHV0ZShhKGUuaW5wdXRzWzBdLFwiRXJmXCIsKGU9PmBlcmZfdmYzMigke2V9KWApLFwiXFxuICBjb25zdCByMDogZjMyID0gMC4zMjc1OTExO1xcbiAgY29uc3QgcjE6IGYzMiA9IDAuMjU0ODI5NTkyO1xcbiAgY29uc3QgcjI6IGYzMiA9IC0wLjI4NDQ5NjczNjtcXG4gIGNvbnN0IHIzOiBmMzIgPSAxLjQyMTQxMzc0MTtcXG4gIGNvbnN0IHI0OiBmMzIgPSAtMS40NTMxNTIwMjc7XFxuICBjb25zdCByNTogZjMyID0gMS4wNjE0MDU0Mjk7XFxuXFxuICBmbiBlcmZfdmYzMih2OiB2ZWM0PGYzMj4pIC0+IHZlYzQ8ZjMyPiB7XFxuICAgIGxldCBhYnN2ID0gYWJzKHYpO1xcbiAgICBsZXQgeCA9IDEuMCAvICgxLjAgKyByMCAqIGFic3YpO1xcbiAgICByZXR1cm4gc2lnbih2KSAqICgxLjAgLSAoKCgocjUgKiB4ICsgcjQpICogeCArIHIzKSAqIHggKyByMikgKiB4ICsgcjEpICogeCAqIGV4cCgtYWJzdiAqIGFic3YpKTtcXG4gIH1cIikpfSx0LmV4cD1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJFeHBcIixcImV4cFwiKSl9LHQuZmxvb3I9ZT0+e2UuY29tcHV0ZShhKGUuaW5wdXRzWzBdLFwiRmxvb3JcIixcImZsb29yXCIpKX0sdC5sZWFreVJlbHU9KGUsdCk9PntlLmNvbXB1dGUoYShlLmlucHV0c1swXSxcIkxlYWt5UmVsdVwiLChlPT5gc2VsZWN0KGxlYWt5X3JlbHVfYWxwaGFfICogJHtlfSwgJHtlfSwgJHtlfSA+PSB2ZWM0PGYzMj4oMC4wKSlgKSxgY29uc3QgbGVha3lfcmVsdV9hbHBoYV86IGYzMiA9IGYzMigke3QuYWxwaGF9KTtgLHQuY2FjaGVLZXkpKX0sdC5uZWc9ZT0+e2UuY29tcHV0ZShhKGUuaW5wdXRzWzBdLFwiTmVnXCIsKGU9PmAtJHtlfWApKSl9LHQucmVjaXByb2NhbD1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJSZWNpcHJvY2FsXCIsKGU9PmAxLjAvJHtlfWApKSl9LHQucmVsdT1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJSZWx1XCIsKGU9PmBzZWxlY3QodmVjNDxmMzI+KDAuMCksICR7ZX0sICR7ZX0gPiB2ZWM0PGYzMj4oMC4wKSlgKSkpfSx0LnNpZ21vaWQ9ZT0+e2UuY29tcHV0ZShhKGUuaW5wdXRzWzBdLFwiU2lnbW9pZFwiLChlPT5gKDEuMCAvICgxLjAgKyBleHAoLSR7ZX0pKSlgKSkpfSx0LnNpbj1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJTaW5cIixcInNpblwiKSl9LHQuc2luaD1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJTaW5oXCIsXCJzaW5oXCIpKX0sdC5zcXJ0PWU9PntlLmNvbXB1dGUoYShlLmlucHV0c1swXSxcIlNxcnRcIixcInNxcnRcIikpfSx0LnRhbj1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJUYW5cIixcInRhblwiKSl9LHQudGFuaD1lPT57ZS5jb21wdXRlKGEoZS5pbnB1dHNbMF0sXCJUYW5oXCIsXCJ0YW5oXCIpKX0sdC50aHJlc2hvbGRlZFJlbHU9KGUsdCk9PihlLmNvbXB1dGUoYShlLmlucHV0c1swXSxcIlRocmVzaG9sZGVkUmVsdVwiLChlPT5gc2VsZWN0KHZlYzQ8ZjMyPigwLjApLCAke2V9LCAke2V9ID4gdGhyZXNob2xkZWRfcmVsdV9hbHBoYV8pYCksYGNvbnN0IHRocmVzaG9sZGVkX3JlbHVfYWxwaGFfOiB2ZWM0PGYzMj4gPSB2ZWM0PGYzMj4oJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSksMCl9LDgzMDU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuUHJvZ3JhbU1hbmFnZXI9dm9pZCAwO2NvbnN0IHI9big0OTU1KSxvPW4oMjA3NSk7dC5Qcm9ncmFtTWFuYWdlcj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLmJhY2tlbmQ9ZSx0aGlzLnJlcG89bmV3IE1hcCx0aGlzLmF0dHJpYnV0ZXNCb3VuZD0hMX1nZXRBcnRpZmFjdChlKXtyZXR1cm4gdGhpcy5yZXBvLmdldChlKX1zZXRBcnRpZmFjdChlLHQpe3RoaXMucmVwby5zZXQoZSx0KX1ydW4oZSx0LG4scil7Y29uc3Qgbz10aGlzLmJhY2tlbmQuZGV2aWNlLGk9dGhpcy5iYWNrZW5kLmdldENvbXB1dGVQYXNzRW5jb2RlcigpO3RoaXMuYmFja2VuZC5wcm9maWxpbmdFbmFibGVkJiZpLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wcm9maWxpbmdRdWVyeVNldCwwKSxpLnNldFBpcGVsaW5lKGUuY29tcHV0ZVBpcGVsaW5lKTtjb25zdCBhPVtdO2Zvcihjb25zdCBlIG9mIHQpYS5wdXNoKHtiaW5kaW5nOmEubGVuZ3RoLHJlc291cmNlOntidWZmZXI6ZS5idWZmZXJ9fSk7Zm9yKGNvbnN0IGUgb2YgbilhLnB1c2goe2JpbmRpbmc6YS5sZW5ndGgscmVzb3VyY2U6e2J1ZmZlcjplLmJ1ZmZlcn19KTtjb25zdCBzPW8uY3JlYXRlQmluZEdyb3VwKHtsYXlvdXQ6ZS5jb21wdXRlUGlwZWxpbmUuZ2V0QmluZEdyb3VwTGF5b3V0KDApLGVudHJpZXM6YX0pO2lmKGkuc2V0QmluZEdyb3VwKDAscyksaS5kaXNwYXRjaFdvcmtncm91cHMoLi4uciksdGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcisrLHRoaXMuYmFja2VuZC5wcm9maWxpbmdFbmFibGVkKXtpLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wcm9maWxpbmdRdWVyeVNldCwxKTtjb25zdCBlPXRoaXMuYmFja2VuZC5ncHVEYXRhTWFuYWdlci5jcmVhdGUoMTYsR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN8R1BVQnVmZmVyVXNhZ2UuUVVFUllfUkVTT0xWRSksdD10aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKDE2LEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUKTt0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSx0aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKS5yZXNvbHZlUXVlcnlTZXQodGhpcy5iYWNrZW5kLnByb2ZpbGluZ1F1ZXJ5U2V0LDAsMixlLmJ1ZmZlciwwKSx0aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKS5jb3B5QnVmZmVyVG9CdWZmZXIoZS5idWZmZXIsMCx0LmJ1ZmZlciwwLDE2KSx0aGlzLmJhY2tlbmQuZmx1c2goKTtjb25zdCBuPXRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsSWQscj10aGlzLmJhY2tlbmQua2VybmVscy5nZXQobilbMF07dC5idWZmZXIubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKS50aGVuKCgoKT0+e2NvbnN0IG89bmV3IEJpZ1VpbnQ2NEFycmF5KHQuYnVmZmVyLmdldE1hcHBlZFJhbmdlKCkpLGk9b1swXSxhPW9bMV07dC5idWZmZXIudW5tYXAoKSx2b2lkIDA9PT10aGlzLmJhY2tlbmQucHJvZmlsaW5nVGltZUJhc2UmJih0aGlzLmJhY2tlbmQucHJvZmlsaW5nVGltZUJhc2U9aSk7Y29uc3Qgcz1OdW1iZXIoaS10aGlzLmJhY2tlbmQucHJvZmlsaW5nVGltZUJhc2UpLHU9TnVtYmVyKGEtdGhpcy5iYWNrZW5kLnByb2ZpbGluZ1RpbWVCYXNlKTtpZighTnVtYmVyLmlzU2FmZUludGVnZXIocyl8fCFOdW1iZXIuaXNTYWZlSW50ZWdlcih1KSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImluY29ycmVjdCB0aW1lc3RhbXAgcmFuZ2VcIik7dGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoZS5pZCksdGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UodC5pZCksY29uc29sZS5sb2coYFtwcm9maWxpbmddIGtlcm5lbCBcIiR7bn18JHtyfVwiIGV4ZWN1dGlvbiB0aW1lOiAke3Utc30gbnNgKX0pKX10aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj0xNiYmdGhpcy5iYWNrZW5kLmZsdXNoKCl9ZGlzcG9zZSgpe31idWlsZChlLHQpe2NvbnN0IG49dGhpcy5iYWNrZW5kLmRldmljZSxpPWUuZ2V0U2hhZGVyU291cmNlKCgwLG8uY3JlYXRlU2hhZGVySGVscGVyKSh0KSksYT1uLmNyZWF0ZVNoYWRlck1vZHVsZSh7Y29kZTppfSk7cmV0dXJuKDAsci5MT0dfREVCVUcpKFwidmVyYm9zZVwiLCgoKT0+YFtXZWJHUFVdIHNoYWRlciBjb2RlOiAke2l9YCkpLHtwcm9ncmFtSW5mbzplLGNvbXB1dGVQaXBlbGluZTpuLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7Y29tcHV0ZTp7bW9kdWxlOmEsZW50cnlQb2ludDpcIm1haW5cIn0sbGF5b3V0OlwiYXV0b1wifSl9fW5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKGUpe2NvbnN0IHQ9XCJudW1iZXJcIj09dHlwZW9mIGU/ZTplLngsbj1cIm51bWJlclwiPT10eXBlb2YgZT8xOmUueXx8MSxyPVwibnVtYmVyXCI9PXR5cGVvZiBlPzE6ZS56fHwxLG89dGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb247aWYodDw9byYmbjw9byYmcjw9bylyZXR1cm5bdCxuLHJdO2NvbnN0IGk9dCpuKnI7bGV0IGE9TWF0aC5jZWlsKE1hdGguc3FydChpKSk7aWYoYT5vKXtpZihhPU1hdGguY2VpbChNYXRoLmNicnQoaSkpLGE+byl0aHJvdyBuZXcgRXJyb3IoXCJUb3RhbCBkaXNwYXRjaCBzaXplIGV4Y2VlZHMgV2ViR1BVIG1heGltdW0uXCIpO3JldHVyblthLGEsYV19cmV0dXJuW2EsYSwxXX19fSwxMTYzOihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIG47T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5HcHVEYXRhVHlwZT12b2lkIDAsKG49dC5HcHVEYXRhVHlwZXx8KHQuR3B1RGF0YVR5cGU9e30pKVtuLmRlZmF1bHQ9MF09XCJkZWZhdWx0XCIsbltuLnVwbG9hZD0xXT1cInVwbG9hZFwiLG5bbi5wcm9maWxlPTJdPVwicHJvZmlsZVwifSwzODk5OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5pdGVyYXRlRXh0cmFPcHRpb25zPXZvaWQgMCx0Lml0ZXJhdGVFeHRyYU9wdGlvbnM9KGUsbixyLG8pPT57aWYoXCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lKXtpZihyLmhhcyhlKSl0aHJvdyBuZXcgRXJyb3IoXCJDaXJjdWxhciByZWZlcmVuY2UgaW4gb3B0aW9uc1wiKTtyLmFkZChlKX1PYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKCgoW2UsaV0pPT57Y29uc3QgYT1uP24rZTplO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBpKSgwLHQuaXRlcmF0ZUV4dHJhT3B0aW9ucykoaSxhK1wiLlwiLHIsbyk7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgaXx8XCJudW1iZXJcIj09dHlwZW9mIGkpbyhhLGkudG9TdHJpbmcoKSk7ZWxzZXtpZihcImJvb2xlYW5cIiE9dHlwZW9mIGkpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiBcIit0eXBlb2YgaSk7byhhLGk/XCIxXCI6XCIwXCIpfX0pKX19LDk1NDQ6ZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciByLG89dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCxuLHIpe3ZvaWQgMD09PXImJihyPW4pO3ZhciBvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxuKTtvJiYhKFwiZ2V0XCJpbiBvPyF0Ll9fZXNNb2R1bGU6by53cml0YWJsZXx8by5jb25maWd1cmFibGUpfHwobz17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtuXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLG8pfTpmdW5jdGlvbihlLHQsbixyKXt2b2lkIDA9PT1yJiYocj1uKSxlW3JdPXRbbl19KSxpPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOnR9KX06ZnVuY3Rpb24oZSx0KXtlLmRlZmF1bHQ9dH0pLGE9dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgbiBpbiBlKVwiZGVmYXVsdFwiIT09biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbikmJm8odCxlLG4pO3JldHVybiBpKHQsZSksdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5lbmRQcm9maWxpbmc9dC5ydW49dC5yZWxlYXNlU2Vzc2lvbj10LmNyZWF0ZVNlc3Npb249dC5jcmVhdGVTZXNzaW9uRmluYWxpemU9dC5jcmVhdGVTZXNzaW9uQWxsb2NhdGU9dC5pbml0T3J0PXQuaW5pdFdhc209dm9pZCAwO2NvbnN0IHM9big4NDUzKSx1PW4oNzY3NSksbD1hKG4oMTI1OSkpLGM9bigyNjMpLHA9KCk9PiEhcy5lbnYud2FzbS5wcm94eSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50O2xldCBkLGYsaCxnPSExLG09ITEsYj0hMTtjb25zdCB5PVtdLHc9W10sXz1bXSx2PVtdLHg9W10sVD1bXSxTPSgpPT57aWYoZ3x8IW18fGJ8fCFkKXRocm93IG5ldyBFcnJvcihcIndvcmtlciBub3QgcmVhZHlcIil9LE89ZT0+e3N3aXRjaChlLmRhdGEudHlwZSl7Y2FzZVwiaW5pdC13YXNtXCI6Zz0hMSxlLmRhdGEuZXJyPyhiPSEwLGZbMV0oZS5kYXRhLmVycikpOihtPSEwLGZbMF0oKSk7YnJlYWs7Y2FzZVwiaW5pdC1vcnRcIjplLmRhdGEuZXJyP2hbMV0oZS5kYXRhLmVycik6aFswXSgpO2JyZWFrO2Nhc2VcImNyZWF0ZV9hbGxvY2F0ZVwiOmUuZGF0YS5lcnI/eS5zaGlmdCgpWzFdKGUuZGF0YS5lcnIpOnkuc2hpZnQoKVswXShlLmRhdGEub3V0KTticmVhaztjYXNlXCJjcmVhdGVfZmluYWxpemVcIjplLmRhdGEuZXJyP3cuc2hpZnQoKVsxXShlLmRhdGEuZXJyKTp3LnNoaWZ0KClbMF0oZS5kYXRhLm91dCk7YnJlYWs7Y2FzZVwiY3JlYXRlXCI6ZS5kYXRhLmVycj9fLnNoaWZ0KClbMV0oZS5kYXRhLmVycik6Xy5zaGlmdCgpWzBdKGUuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcInJlbGVhc2VcIjplLmRhdGEuZXJyP3Yuc2hpZnQoKVsxXShlLmRhdGEuZXJyKTp2LnNoaWZ0KClbMF0oKTticmVhaztjYXNlXCJydW5cIjplLmRhdGEuZXJyP3guc2hpZnQoKVsxXShlLmRhdGEuZXJyKTp4LnNoaWZ0KClbMF0oZS5kYXRhLm91dCk7YnJlYWs7Y2FzZVwiZW5kLXByb2ZpbGluZ1wiOmUuZGF0YS5lcnI/VC5zaGlmdCgpWzFdKGUuZGF0YS5lcnIpOlQuc2hpZnQoKVswXSgpfX0sQT1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQ/bnVsbD09PShyPW51bGw9PT1kb2N1bWVudHx8dm9pZCAwPT09ZG9jdW1lbnQ/dm9pZCAwOmRvY3VtZW50LmN1cnJlbnRTY3JpcHQpfHx2b2lkIDA9PT1yP3ZvaWQgMDpyLnNyYzp2b2lkIDA7dC5pbml0V2FzbT1hc3luYygpPT57aWYocCgpKXtpZihtKXJldHVybjtpZihnKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0V2FzbSgpJyBkZXRlY3RlZC5cIik7aWYoYil0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0V2FzbSgpJyBmYWlsZWQuXCIpO3JldHVybiBnPSEwLHZvaWQgMD09PXMuZW52Lndhc20ud2FzbVBhdGhzJiZBJiYwIT09QS5pbmRleE9mKFwiYmxvYjpcIikmJihzLmVudi53YXNtLndhc21QYXRocz1BLnN1YnN0cigwLCtBLmxhc3RJbmRleE9mKFwiL1wiKSsxKSksbmV3IFByb21pc2UoKChlLHQpPT57bnVsbD09ZHx8ZC50ZXJtaW5hdGUoKSxkPW4oODA1MCkuWigpLGQub25tZXNzYWdlPU8sZj1bZSx0XTtjb25zdCByPXt0eXBlOlwiaW5pdC13YXNtXCIsaW46cy5lbnYud2FzbX07ZC5wb3N0TWVzc2FnZShyKX0pKX1yZXR1cm4oMCxjLmluaXRpYWxpemVXZWJBc3NlbWJseSkocy5lbnYud2FzbSl9LHQuaW5pdE9ydD1hc3luYyhlLHQpPT57aWYocCgpKXJldHVybiBTKCksbmV3IFByb21pc2UoKChuLHIpPT57aD1bbixyXTtjb25zdCBvPXt0eXBlOlwiaW5pdC1vcnRcIixpbjp7bnVtVGhyZWFkczplLGxvZ2dpbmdMZXZlbDp0fX07ZC5wb3N0TWVzc2FnZShvKX0pKTtsLmluaXRPcnQoZSx0KSxhd2FpdCgwLHUuaW5pdCkoKDAsYy5nZXRJbnN0YW5jZSkoKSl9LHQuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPWFzeW5jIGU9PnAoKT8oUygpLG5ldyBQcm9taXNlKCgodCxuKT0+e3kucHVzaChbdCxuXSk7Y29uc3Qgcj17dHlwZTpcImNyZWF0ZV9hbGxvY2F0ZVwiLGluOnttb2RlbDplfX07ZC5wb3N0TWVzc2FnZShyLFtlLmJ1ZmZlcl0pfSkpKTpsLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZShlKSx0LmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT1hc3luYyhlLHQpPT5wKCk/KFMoKSxuZXcgUHJvbWlzZSgoKG4scik9Pnt3LnB1c2goW24scl0pO2NvbnN0IG89e3R5cGU6XCJjcmVhdGVfZmluYWxpemVcIixpbjp7bW9kZWxkYXRhOmUsb3B0aW9uczp0fX07ZC5wb3N0TWVzc2FnZShvKX0pKSk6bC5jcmVhdGVTZXNzaW9uRmluYWxpemUoZSx0KSx0LmNyZWF0ZVNlc3Npb249YXN5bmMoZSx0KT0+cCgpPyhTKCksbmV3IFByb21pc2UoKChuLHIpPT57Xy5wdXNoKFtuLHJdKTtjb25zdCBvPXt0eXBlOlwiY3JlYXRlXCIsaW46e21vZGVsOmUsb3B0aW9uczp0fX07ZC5wb3N0TWVzc2FnZShvLFtlLmJ1ZmZlcl0pfSkpKTpsLmNyZWF0ZVNlc3Npb24oZSx0KSx0LnJlbGVhc2VTZXNzaW9uPWFzeW5jIGU9PntpZihwKCkpcmV0dXJuIFMoKSxuZXcgUHJvbWlzZSgoKHQsbik9Pnt2LnB1c2goW3Qsbl0pO2NvbnN0IHI9e3R5cGU6XCJyZWxlYXNlXCIsaW46ZX07ZC5wb3N0TWVzc2FnZShyKX0pKTtsLnJlbGVhc2VTZXNzaW9uKGUpfSx0LnJ1bj1hc3luYyhlLHQsbixyLG8pPT5wKCk/KFMoKSxuZXcgUHJvbWlzZSgoKGksYSk9Pnt4LnB1c2goW2ksYV0pO2NvbnN0IHM9e3R5cGU6XCJydW5cIixpbjp7c2Vzc2lvbklkOmUsaW5wdXRJbmRpY2VzOnQsaW5wdXRzOm4sb3V0cHV0SW5kaWNlczpyLG9wdGlvbnM6b319O2QucG9zdE1lc3NhZ2UocyxsLmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzKG4pKX0pKSk6bC5ydW4oZSx0LG4scixvKSx0LmVuZFByb2ZpbGluZz1hc3luYyBlPT57aWYocCgpKXJldHVybiBTKCksbmV3IFByb21pc2UoKCh0LG4pPT57VC5wdXNoKFt0LG5dKTtjb25zdCByPXt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGluOmV9O2QucG9zdE1lc3NhZ2Uocil9KSk7bC5lbmRQcm9maWxpbmcoZSl9fSw3OTE4OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnNldFJ1bk9wdGlvbnM9dm9pZCAwO2NvbnN0IHI9bigzODk5KSxvPW4oOTQ0NCksaT1uKDI2Myk7dC5zZXRSdW5PcHRpb25zPWU9Pntjb25zdCB0PSgwLGkuZ2V0SW5zdGFuY2UpKCk7bGV0IG49MDtjb25zdCBhPVtdLHM9ZXx8e307dHJ5e2lmKHZvaWQgMD09PShudWxsPT1lP3ZvaWQgMDplLmxvZ1NldmVyaXR5TGV2ZWwpKXMubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYoXCJudW1iZXJcIiE9dHlwZW9mIGUubG9nU2V2ZXJpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dTZXZlcml0eUxldmVsKXx8ZS5sb2dTZXZlcml0eUxldmVsPDB8fGUubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dTZXZlcml0eUxldmVsfWApO2lmKHZvaWQgMD09PShudWxsPT1lP3ZvaWQgMDplLmxvZ1ZlcmJvc2l0eUxldmVsKSlzLmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgZS5sb2dWZXJib3NpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1ZlcmJvc2l0eUxldmVsfWApO3ZvaWQgMD09PShudWxsPT1lP3ZvaWQgMDplLnRlcm1pbmF0ZSkmJihzLnRlcm1pbmF0ZT0hMSk7bGV0IGk9MDtpZih2b2lkIDAhPT0obnVsbD09ZT92b2lkIDA6ZS50YWcpJiYoaT0oMCxvLmFsbG9jV2FzbVN0cmluZykoZS50YWcsYSkpLG49dC5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhzLmxvZ1NldmVyaXR5TGV2ZWwscy5sb2dWZXJib3NpdHlMZXZlbCwhIXMudGVybWluYXRlLGkpLDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9uc1wiKTtyZXR1cm4gdm9pZCAwIT09KG51bGw9PWU/dm9pZCAwOmUuZXh0cmEpJiYoMCxyLml0ZXJhdGVFeHRyYU9wdGlvbnMpKGUuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoKGUscik9Pntjb25zdCBpPSgwLG8uYWxsb2NXYXNtU3RyaW5nKShlLGEpLHM9KDAsby5hbGxvY1dhc21TdHJpbmcpKHIsYSk7aWYoMCE9PXQuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KG4saSxzKSl0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7ZX0gLSAke3J9YCl9KSksW24sYV19Y2F0Y2goZSl7dGhyb3cgMCE9PW4mJnQuX09ydFJlbGVhc2VSdW5PcHRpb25zKG4pLGEuZm9yRWFjaCh0Ll9mcmVlKSxlfX19LDY2NDA6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyPXZvaWQgMDtjb25zdCByPW4oMjgwNiksbz1uKDg0NTMpLGk9bigyODUwKSxhPW4oOTU0NCkscz1uKDc5MTcpO2xldCB1O3QuT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyPWNsYXNze2FzeW5jIGNyZWF0ZVNlc3Npb25BbGxvY2F0ZShlKXtjb25zdCB0PWF3YWl0IGZldGNoKGUpLG49YXdhaXQgdC5hcnJheUJ1ZmZlcigpO3JldHVybigwLGEuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKShuZXcgVWludDhBcnJheShuKSl9YXN5bmMgbG9hZE1vZGVsKGUsdCl7aWYodXx8KGF3YWl0KDAsYS5pbml0T3J0KShvLmVudi53YXNtLm51bVRocmVhZHMsKDAscy5sb2dMZXZlbFN0cmluZ1RvRW51bSkoby5lbnYubG9nTGV2ZWwpKSx1PSEwKSxcInN0cmluZ1wiPT10eXBlb2YgZSlpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZmV0Y2gpe2NvbnN0IG49YXdhaXQoMCxpLnByb21pc2lmeSkoci5yZWFkRmlsZSkoZSk7W3RoaXMuc2Vzc2lvbklkLHRoaXMuaW5wdXROYW1lcyx0aGlzLm91dHB1dE5hbWVzXT1hd2FpdCgwLGEuY3JlYXRlU2Vzc2lvbikobix0KX1lbHNle2NvbnN0IG49YXdhaXQgdGhpcy5jcmVhdGVTZXNzaW9uQWxsb2NhdGUoZSk7W3RoaXMuc2Vzc2lvbklkLHRoaXMuaW5wdXROYW1lcyx0aGlzLm91dHB1dE5hbWVzXT1hd2FpdCgwLGEuY3JlYXRlU2Vzc2lvbkZpbmFsaXplKShuLHQpfWVsc2VbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0KDAsYS5jcmVhdGVTZXNzaW9uKShlLHQpfWFzeW5jIGRpc3Bvc2UoKXtyZXR1cm4oMCxhLnJlbGVhc2VTZXNzaW9uKSh0aGlzLnNlc3Npb25JZCl9YXN5bmMgcnVuKGUsdCxuKXtjb25zdCByPVtdLGk9W107T2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoZT0+e2NvbnN0IHQ9ZVswXSxuPWVbMV0sbz10aGlzLmlucHV0TmFtZXMuaW5kZXhPZih0KTtpZigtMT09PW8pdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlucHV0ICcke3R9J2ApO3IucHVzaChuKSxpLnB1c2gobyl9KSk7Y29uc3Qgcz1bXTtPYmplY3QuZW50cmllcyh0KS5mb3JFYWNoKChlPT57Y29uc3QgdD1lWzBdLG49dGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKHQpO2lmKC0xPT09bil0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3V0cHV0ICcke3R9J2ApO3MucHVzaChuKX0pKTtjb25zdCB1PWF3YWl0KDAsYS5ydW4pKHRoaXMuc2Vzc2lvbklkLGksci5tYXAoKGU9PltlLnR5cGUsZS5kaW1zLGUuZGF0YV0pKSxzLG4pLGw9e307Zm9yKGxldCBlPTA7ZTx1Lmxlbmd0aDtlKyspbFt0aGlzLm91dHB1dE5hbWVzW3NbZV1dXT1uZXcgby5UZW5zb3IodVtlXVswXSx1W2VdWzJdLHVbZV1bMV0pO3JldHVybiBsfXN0YXJ0UHJvZmlsaW5nKCl7fWVuZFByb2ZpbGluZygpeygwLGEuZW5kUHJvZmlsaW5nKSh0aGlzLnNlc3Npb25JZCl9fX0sNzYyMjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5zZXRTZXNzaW9uT3B0aW9ucz12b2lkIDA7Y29uc3Qgcj1uKDM4OTkpLG89big5NDQ0KSxpPW4oMjYzKTt0LnNldFNlc3Npb25PcHRpb25zPWU9Pnt2YXIgdCxuLGEscztjb25zdCB1PSgwLGkuZ2V0SW5zdGFuY2UpKCk7bGV0IGw9MDtjb25zdCBjPVtdLHA9ZXx8e307KGU9PntlLmV4dHJhfHwoZS5leHRyYT17fSksZS5leHRyYS5zZXNzaW9ufHwoZS5leHRyYS5zZXNzaW9uPXt9KTtjb25zdCB0PWUuZXh0cmEuc2Vzc2lvbjt0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fCh0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpLGUuZXhlY3V0aW9uUHJvdmlkZXJzJiZlLmV4ZWN1dGlvblByb3ZpZGVycy5zb21lKChlPT5cIndlYmdwdVwiPT09KFwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZS5uYW1lKSkpJiYoZS5lbmFibGVNZW1QYXR0ZXJuPSExKX0pKHApO3RyeXtjb25zdCBlPShlPT57c3dpdGNoKGUpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2V9YCl9fSkobnVsbCE9PSh0PXAuZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCkmJnZvaWQgMCE9PXQ/dDpcImFsbFwiKSxkPShlPT57c3dpdGNoKGUpe2Nhc2VcInNlcXVlbnRpYWxcIjpyZXR1cm4gMDtjYXNlXCJwYXJhbGxlbFwiOnJldHVybiAxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtlfWApfX0pKG51bGwhPT0obj1wLmV4ZWN1dGlvbk1vZGUpJiZ2b2lkIDAhPT1uP246XCJzZXF1ZW50aWFsXCIpLGY9XCJzdHJpbmdcIj09dHlwZW9mIHAubG9nSWQ/KDAsby5hbGxvY1dhc21TdHJpbmcpKHAubG9nSWQsYyk6MCxoPW51bGwhPT0oYT1wLmxvZ1NldmVyaXR5TGV2ZWwpJiZ2b2lkIDAhPT1hP2E6MjtpZighTnVtYmVyLmlzSW50ZWdlcihoKXx8aDwwfHxoPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtofWApO2NvbnN0IGc9bnVsbCE9PShzPXAubG9nVmVyYm9zaXR5TGV2ZWwpJiZ2b2lkIDAhPT1zP3M6MDtpZighTnVtYmVyLmlzSW50ZWdlcihnKXx8ZzwwfHxnPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtnfWApO2NvbnN0IG09XCJzdHJpbmdcIj09dHlwZW9mIHAub3B0aW1pemVkTW9kZWxGaWxlUGF0aD8oMCxvLmFsbG9jV2FzbVN0cmluZykocC5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoLGMpOjA7aWYobD11Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhlLCEhcC5lbmFibGVDcHVNZW1BcmVuYSwhIXAuZW5hYmxlTWVtUGF0dGVybixkLCEhcC5lbmFibGVQcm9maWxpbmcsMCxmLGgsZyxtKSwwPT09bCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zXCIpO3JldHVybiBwLmV4ZWN1dGlvblByb3ZpZGVycyYmKChlLHQsbik9Pntmb3IoY29uc3QgciBvZiB0KXtsZXQgdD1cInN0cmluZ1wiPT10eXBlb2Ygcj9yOnIubmFtZTtzd2l0Y2godCl7Y2FzZVwieG5ucGFja1wiOnQ9XCJYTk5QQUNLXCI7YnJlYWs7Y2FzZVwid2ViZ3B1XCI6dD1cIkpTXCI7YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIEVQOiAke3R9YCl9Y29uc3QgYT0oMCxvLmFsbG9jV2FzbVN0cmluZykodCxuKTtpZigwIT09KDAsaS5nZXRJbnN0YW5jZSkoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoZSxhKSl0aHJvdyBuZXcgRXJyb3IoYENhbid0IGFwcGVuZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7dH1gKX19KShsLHAuZXhlY3V0aW9uUHJvdmlkZXJzLGMpLHZvaWQgMCE9PXAuZXh0cmEmJigwLHIuaXRlcmF0ZUV4dHJhT3B0aW9ucykocC5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LCgoZSx0KT0+e2NvbnN0IG49KDAsby5hbGxvY1dhc21TdHJpbmcpKGUsYykscj0oMCxvLmFsbG9jV2FzbVN0cmluZykodCxjKTtpZigwIT09dS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGwsbixyKSl0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke2V9IC0gJHt0fWApfSkpLFtsLGNdfWNhdGNoKGUpe3Rocm93IDAhPT1sJiZ1Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMobCksYy5mb3JFYWNoKHUuX2ZyZWUpLGV9fX0sOTQ0NDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5hbGxvY1dhc21TdHJpbmc9dm9pZCAwO2NvbnN0IHI9bigyNjMpO3QuYWxsb2NXYXNtU3RyaW5nPShlLHQpPT57Y29uc3Qgbj0oMCxyLmdldEluc3RhbmNlKSgpLG89bi5sZW5ndGhCeXRlc1VURjgoZSkrMSxpPW4uX21hbGxvYyhvKTtyZXR1cm4gbi5zdHJpbmdUb1VURjgoZSxpLG8pLHQucHVzaChpKSxpfX0sNzkxNzooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQubG9nTGV2ZWxTdHJpbmdUb0VudW09dC50ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3I9dC5nZXRUZW5zb3JFbGVtZW50U2l6ZT10LnRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nPXQudGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW09dm9pZCAwLHQudGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW09ZT0+e3N3aXRjaChlKXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDE7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiAxMTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gODtjYXNlXCJpbnQ2NFwiOnJldHVybiA3O2Nhc2VcInVpbnQ2NFwiOnJldHVybiAxMztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSx0LnRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nPWU9Pntzd2l0Y2goZSl7Y2FzZSAzOnJldHVyblwiaW50OFwiO2Nhc2UgMjpyZXR1cm5cInVpbnQ4XCI7Y2FzZSA5OnJldHVyblwiYm9vbFwiO2Nhc2UgNTpyZXR1cm5cImludDE2XCI7Y2FzZSA0OnJldHVyblwidWludDE2XCI7Y2FzZSA2OnJldHVyblwiaW50MzJcIjtjYXNlIDEyOnJldHVyblwidWludDMyXCI7Y2FzZSAxOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgMTE6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSA4OnJldHVyblwic3RyaW5nXCI7Y2FzZSA3OnJldHVyblwiaW50NjRcIjtjYXNlIDEzOnJldHVyblwidWludDY0XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0sdC5nZXRUZW5zb3JFbGVtZW50U2l6ZT1lPT5bdm9pZCAwLDQsMSwxLDIsMiw0LDgsdm9pZCAwLDEsMiw4LDQsOCx2b2lkIDAsdm9pZCAwLHZvaWQgMF1bZV0sdC50ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3I9ZT0+e3N3aXRjaChlKXtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJ1aW50OFwiOmNhc2VcImJvb2xcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJpbnQ4XCI6cmV0dXJuIEludDhBcnJheTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gSW50MTZBcnJheTtjYXNlXCJpbnQzMlwiOnJldHVybiBJbnQzMkFycmF5O2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gRmxvYXQ2NEFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJpbnQ2NFwiOnJldHVybiBCaWdJbnQ2NEFycmF5O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBCaWdVaW50NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZTogJHtlfWApfX0sdC5sb2dMZXZlbFN0cmluZ1RvRW51bT1lPT57c3dpdGNoKGUpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm4gMDtjYXNlXCJpbmZvXCI6cmV0dXJuIDE7Y2FzZVwid2FybmluZ1wiOnJldHVybiAyO2Nhc2VcImVycm9yXCI6cmV0dXJuIDM7Y2FzZVwiZmF0YWxcIjpyZXR1cm4gNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApfX19LDEyNTk6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnM9dC5lbmRQcm9maWxpbmc9dC5ydW49dC5yZWxlYXNlU2Vzc2lvbj10LmNyZWF0ZVNlc3Npb249dC5jcmVhdGVTZXNzaW9uRmluYWxpemU9dC5jcmVhdGVTZXNzaW9uQWxsb2NhdGU9dC5pbml0T3J0PXZvaWQgMDtjb25zdCByPW4oNzkxOCksbz1uKDc2MjIpLGk9big5NDQ0KSxhPW4oNzkxNykscz1uKDI2Myk7dC5pbml0T3J0PShlLHQpPT57Y29uc3Qgbj0oMCxzLmdldEluc3RhbmNlKSgpLl9PcnRJbml0KGUsdCk7aWYoMCE9PW4pdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBpbml0aWFsaXplIG9ubnhydW50aW1lLiBlcnJvciBjb2RlID0gJHtufWApfTtjb25zdCB1PW5ldyBNYXA7dC5jcmVhdGVTZXNzaW9uQWxsb2NhdGU9ZT0+e2NvbnN0IHQ9KDAscy5nZXRJbnN0YW5jZSkoKSxuPXQuX21hbGxvYyhlLmJ5dGVMZW5ndGgpO3JldHVybiB0LkhFQVBVOC5zZXQoZSxuKSxbbixlLmJ5dGVMZW5ndGhdfSx0LmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT0oZSx0KT0+e2NvbnN0IG49KDAscy5nZXRJbnN0YW5jZSkoKTtsZXQgcj0wLGk9MCxhPVtdO3RyeXtpZihbaSxhXT0oMCxvLnNldFNlc3Npb25PcHRpb25zKSh0KSxyPW4uX09ydENyZWF0ZVNlc3Npb24oZVswXSxlWzFdLGkpLDA9PT1yKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBhIHNlc3Npb25cIil9ZmluYWxseXtuLl9mcmVlKGVbMF0pLDAhPT1pJiZuLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMoaSksYS5mb3JFYWNoKG4uX2ZyZWUpfWNvbnN0IGw9bi5fT3J0R2V0SW5wdXRDb3VudChyKSxjPW4uX09ydEdldE91dHB1dENvdW50KHIpLHA9W10sZD1bXSxmPVtdLGg9W107Zm9yKGxldCBlPTA7ZTxsO2UrKyl7Y29uc3QgdD1uLl9PcnRHZXRJbnB1dE5hbWUocixlKTtpZigwPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBnZXQgYW4gaW5wdXQgbmFtZVwiKTtkLnB1c2godCkscC5wdXNoKG4uVVRGOFRvU3RyaW5nKHQpKX1mb3IobGV0IGU9MDtlPGM7ZSsrKXtjb25zdCB0PW4uX09ydEdldE91dHB1dE5hbWUocixlKTtpZigwPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBnZXQgYW4gb3V0cHV0IG5hbWVcIik7aC5wdXNoKHQpLGYucHVzaChuLlVURjhUb1N0cmluZyh0KSl9cmV0dXJuIHUuc2V0KHIsW3IsZCxoXSksW3IscCxmXX0sdC5jcmVhdGVTZXNzaW9uPShlLG4pPT57Y29uc3Qgcj0oMCx0LmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSkoZSk7cmV0dXJuKDAsdC5jcmVhdGVTZXNzaW9uRmluYWxpemUpKHIsbil9LHQucmVsZWFzZVNlc3Npb249ZT0+e2NvbnN0IHQ9KDAscy5nZXRJbnN0YW5jZSkoKSxuPXUuZ2V0KGUpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtjb25zdCByPW5bMF0sbz1uWzFdLGk9blsyXTtvLmZvckVhY2godC5fT3J0RnJlZSksaS5mb3JFYWNoKHQuX09ydEZyZWUpLHQuX09ydFJlbGVhc2VTZXNzaW9uKHIpLHUuZGVsZXRlKGUpfSx0LnJ1bj1hc3luYyhlLHQsbixvLGwpPT57Y29uc3QgYz0oMCxzLmdldEluc3RhbmNlKSgpLHA9dS5nZXQoZSk7aWYoIXApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2NvbnN0IGQ9cFswXSxmPXBbMV0saD1wWzJdLGc9dC5sZW5ndGgsbT1vLmxlbmd0aDtsZXQgYj0wLHk9W107Y29uc3Qgdz1bXSxfPVtdO3RyeXtbYix5XT0oMCxyLnNldFJ1bk9wdGlvbnMpKGwpO2ZvcihsZXQgZT0wO2U8ZztlKyspe2NvbnN0IHQ9bltlXVswXSxyPW5bZV1bMV0sbz1uW2VdWzJdO2xldCBzLHU7aWYoQXJyYXkuaXNBcnJheShvKSl7dT00Km8ubGVuZ3RoLHM9Yy5fbWFsbG9jKHUpLF8ucHVzaChzKTtsZXQgZT1zLzQ7Zm9yKGxldCB0PTA7dDxvLmxlbmd0aDt0Kyspe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBvW3RdKXRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7dH0gaXMgbm90IGEgc3RyaW5nYCk7Yy5IRUFQVTMyW2UrK109KDAsaS5hbGxvY1dhc21TdHJpbmcpKG9bdF0sXyl9fWVsc2UgdT1vLmJ5dGVMZW5ndGgscz1jLl9tYWxsb2ModSksXy5wdXNoKHMpLGMuSEVBUFU4LnNldChuZXcgVWludDhBcnJheShvLmJ1ZmZlcixvLmJ5dGVPZmZzZXQsdSkscyk7Y29uc3QgbD1jLnN0YWNrU2F2ZSgpLHA9Yy5zdGFja0FsbG9jKDQqci5sZW5ndGgpO3RyeXtsZXQgZT1wLzQ7ci5mb3JFYWNoKCh0PT5jLkhFQVAzMltlKytdPXQpKTtjb25zdCBuPWMuX09ydENyZWF0ZVRlbnNvcigoMCxhLnRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKSh0KSxzLHUscCxyLmxlbmd0aCk7aWYoMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY3JlYXRlIGEgdGVuc29yXCIpO3cucHVzaChuKX1maW5hbGx5e2Muc3RhY2tSZXN0b3JlKGwpfX1jb25zdCBlPWMuc3RhY2tTYXZlKCkscz1jLnN0YWNrQWxsb2MoNCpnKSx1PWMuc3RhY2tBbGxvYyg0KmcpLHA9Yy5zdGFja0FsbG9jKDQqbSksdj1jLnN0YWNrQWxsb2MoNCptKTt0cnl7bGV0IGU9cy80LG49dS80LHI9cC80LGk9di80O2ZvcihsZXQgcj0wO3I8ZztyKyspYy5IRUFQVTMyW2UrK109d1tyXSxjLkhFQVBVMzJbbisrXT1mW3Rbcl1dO2ZvcihsZXQgZT0wO2U8bTtlKyspYy5IRUFQVTMyW3IrK109MCxjLkhFQVBVMzJbaSsrXT1oW29bZV1dO2xldCBsPWMuX09ydFJ1bihkLHUscyxnLHYsbSxwLGIpO2NvbnN0IHk9Yy5qc2VwUnVuUHJvbWlzZTt5JiZ2b2lkIDAhPT15LnRoZW4mJihsPWF3YWl0IHkpO2NvbnN0IF89W107aWYoMD09PWwpZm9yKGxldCBlPTA7ZTxtO2UrKyl7Y29uc3QgdD1jLkhFQVBVMzJbcC80K2VdLG49Yy5zdGFja1NhdmUoKSxyPWMuc3RhY2tBbGxvYygxNik7bGV0IG8saT0wO3RyeXtpZihsPWMuX09ydEdldFRlbnNvckRhdGEodCxyLHIrNCxyKzgscisxMiksMCE9PWwpdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhLiBlcnJvciBjb2RlID0gJHtsfWApO2xldCBlPXIvNDtjb25zdCBuPWMuSEVBUFUzMltlKytdO2k9Yy5IRUFQVTMyW2UrK107Y29uc3Qgcz1jLkhFQVBVMzJbZSsrXSx1PWMuSEVBUFUzMltlKytdLHA9W107Zm9yKGxldCBlPTA7ZTx1O2UrKylwLnB1c2goYy5IRUFQVTMyW3MvNCtlXSk7Yy5fT3J0RnJlZShzKTtjb25zdCBkPTA9PT1wLmxlbmd0aD8xOnAucmVkdWNlKCgoZSx0KT0+ZSp0KSk7aWYobz0oMCxhLnRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKShuKSxcInN0cmluZ1wiPT09byl7Y29uc3QgZT1bXTtsZXQgdD1pLzQ7Zm9yKGxldCBuPTA7bjxkO24rKyl7Y29uc3Qgcj1jLkhFQVBVMzJbdCsrXSxvPW49PT1kLTE/dm9pZCAwOmMuSEVBUFUzMlt0XS1yO2UucHVzaChjLlVURjhUb1N0cmluZyhyLG8pKX1fLnB1c2goW28scCxlXSl9ZWxzZXtjb25zdCBlPW5ldygoMCxhLnRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3RvcikobykpKGQpO25ldyBVaW50OEFycmF5KGUuYnVmZmVyLGUuYnl0ZU9mZnNldCxlLmJ5dGVMZW5ndGgpLnNldChjLkhFQVBVOC5zdWJhcnJheShpLGkrZS5ieXRlTGVuZ3RoKSksXy5wdXNoKFtvLHAsZV0pfX1maW5hbGx5e2Muc3RhY2tSZXN0b3JlKG4pLFwic3RyaW5nXCI9PT1vJiZpJiZjLl9mcmVlKGkpLGMuX09ydFJlbGVhc2VUZW5zb3IodCl9fWlmKDA9PT1sKXJldHVybiBfO3Rocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGNhbGwgT3J0UnVuKCkuIGVycm9yIGNvZGUgPSAke2x9LmApfWZpbmFsbHl7Yy5zdGFja1Jlc3RvcmUoZSl9fWZpbmFsbHl7dy5mb3JFYWNoKGMuX09ydFJlbGVhc2VUZW5zb3IpLF8uZm9yRWFjaChjLl9mcmVlKSxjLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyhiKSx5LmZvckVhY2goYy5fZnJlZSl9fSx0LmVuZFByb2ZpbGluZz1lPT57Y29uc3QgdD0oMCxzLmdldEluc3RhbmNlKSgpLG49dS5nZXQoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2NvbnN0IHI9blswXSxvPXQuX09ydEVuZFByb2ZpbGluZyhyKTtpZigwPT09byl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBnZXQgYW4gcHJvZmlsZSBmaWxlIG5hbWVcIik7dC5fT3J0RnJlZShvKX0sdC5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycz1lPT57Y29uc3QgdD1bXTtmb3IoY29uc3QgbiBvZiBlKXtjb25zdCBlPW5bMl07IUFycmF5LmlzQXJyYXkoZSkmJmUuYnVmZmVyJiZ0LnB1c2goZS5idWZmZXIpfXJldHVybiB0fX0sMjYzOmZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG4pO28mJiEoXCJnZXRcImluIG8/IXQuX19lc01vZHVsZTpvLndyaXRhYmxlfHxvLmNvbmZpZ3VyYWJsZSl8fChvPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsbyl9OmZ1bmN0aW9uKGUsdCxuLHIpe3ZvaWQgMD09PXImJihyPW4pLGVbcl09dFtuXX0pLG89dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pfTpmdW5jdGlvbihlLHQpe2UuZGVmYXVsdD10fSksaT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciBuIGluIGUpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxuKSYmcih0LGUsbik7cmV0dXJuIG8odCxlKSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRpc3Bvc2U9dC5nZXRJbnN0YW5jZT10LmluaXRpYWxpemVXZWJBc3NlbWJseT12b2lkIDA7Y29uc3QgYT1pKG4oNjQ0OSkpLHM9big5MzIpLHU9bigzNDc0KTtsZXQgbCxjPSExLHA9ITEsZD0hMTt0LmluaXRpYWxpemVXZWJBc3NlbWJseT1hc3luYyBlPT57aWYoYylyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7aWYocCl0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGRldGVjdGVkLlwiKTtpZihkKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBmYWlsZWQuXCIpO3A9ITA7Y29uc3QgdD1lLmluaXRUaW1lb3V0LHI9ZS5udW1UaHJlYWRzLG89ZS5zaW1kLGk9cj4xJiYoKCk9Pnt0cnl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyJiYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIE1lc3NhZ2VDaGFubmVsJiYobmV3IE1lc3NhZ2VDaGFubmVsKS5wb3J0MS5wb3N0TWVzc2FnZShuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMSkpLFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCw1LDQsMSwzLDEsMSwxMCwxMSwxLDksMCw2NSwwLDI1NCwxNiwyLDAsMjYsMTFdKSkpfWNhdGNoKGUpe3JldHVybiExfX0pKCksZj1vJiYoKCk9Pnt0cnl7cmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCwxMCwzMCwxLDI4LDAsNjUsMCwyNTMsMTUsMjUzLDEyLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMjUzLDE4NiwxLDI2LDExXSkpfWNhdGNoKGUpe3JldHVybiExfX0pKCksaD1lLndhc21QYXRocyxnPVwic3RyaW5nXCI9PXR5cGVvZiBoP2g6dm9pZCAwLG09KChlLHQpPT50P2U/XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21cIjpcIm9ydC13YXNtLXRocmVhZGVkLndhc21cIjplP1wib3J0LXdhc20tc2ltZC53YXNtXCI6XCJvcnQtd2FzbS53YXNtXCIpKGYsaSksYj1cIm9iamVjdFwiPT10eXBlb2YgaD9oW21dOnZvaWQgMDtsZXQgeT0hMTtjb25zdCB3PVtdO2lmKHQ+MCYmdy5wdXNoKG5ldyBQcm9taXNlKChlPT57c2V0VGltZW91dCgoKCk9Pnt5PSEwLGUoKX0pLHQpfSkpKSx3LnB1c2gobmV3IFByb21pc2UoKChlLHQpPT57Y29uc3Qgcj1pP3U6cyxvPXtsb2NhdGVGaWxlOihlLHQpPT5pJiZlLmVuZHNXaXRoKFwiLndvcmtlci5qc1wiKSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEJsb2I/VVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbbig0MTU0KV0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pKTplLmVuZHNXaXRoKFwiLndhc21cIik/Ynx8KG51bGwhPWc/Zzp0KSttOnQrZX07aWYoaSlpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgQmxvYilvLm1haW5TY3JpcHRVcmxPckJsb2I9YS5qb2luKFwiL1wiLFwib3J0LXdhc20tdGhyZWFkZWQuanNcIik7ZWxzZXtjb25zdCBlPWB2YXIgb3J0V2FzbVRocmVhZGVkPShmdW5jdGlvbigpe3ZhciBfc2NyaXB0RGlyO3JldHVybiAke3IudG9TdHJpbmcoKX19KSgpO2A7by5tYWluU2NyaXB0VXJsT3JCbG9iPW5ldyBCbG9iKFtlXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSl9cihvKS50aGVuKCh0PT57cD0hMSxjPSEwLGw9dCxlKCl9KSwoZT0+e3A9ITEsZD0hMCx0KGUpfSkpfSkpKSxhd2FpdCBQcm9taXNlLnJhY2UodykseSl0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHt0fW1zYCl9LHQuZ2V0SW5zdGFuY2U9KCk9PntpZihjJiZsKXJldHVybiBsO3Rocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuXCIpfSx0LmRpc3Bvc2U9KCk9Pnt2YXIgZTshY3x8cHx8ZHx8KHA9ITAsbnVsbD09PShlPWwuUFRocmVhZCl8fHZvaWQgMD09PWV8fGUudGVybWluYXRlQWxsVGhyZWFkcygpLGw9dm9pZCAwLHA9ITEsYz0hMSxkPSEwKX19LDgwNTA6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO24uZCh0LHtaOigpPT5pfSk7dmFyIHI9big2NjE0KSxvPW4ubihyKTtmdW5jdGlvbiBpKCl7cmV0dXJuIG8oKSgnLyohXFxuKiBPTk5YIFJ1bnRpbWUgV2ViIHYxLjE1LjFcXG4qIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxcbiovXFxuKCgpPT57dmFyIGU9ezg5OTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuaXRlcmF0ZUV4dHJhT3B0aW9ucz12b2lkIDAsdC5pdGVyYXRlRXh0cmFPcHRpb25zPShlLG4scixhKT0+e2lmKFwib2JqZWN0XCI9PXR5cGVvZiBlJiZudWxsIT09ZSl7aWYoci5oYXMoZSkpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnNcIik7ci5hZGQoZSl9T2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoKFtlLG9dKT0+e2NvbnN0IGk9bj9uK2U6ZTtpZihcIm9iamVjdFwiPT10eXBlb2YgbykoMCx0Lml0ZXJhdGVFeHRyYU9wdGlvbnMpKG8saStcIi5cIixyLGEpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIG98fFwibnVtYmVyXCI9PXR5cGVvZiBvKWEoaSxvLnRvU3RyaW5nKCkpO2Vsc2V7aWYoXCJib29sZWFuXCIhPXR5cGVvZiBvKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiBcIit0eXBlb2Ygbyk7YShpLG8/XCIxXCI6XCIwXCIpfX0pKX19LDkxODooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5zZXRSdW5PcHRpb25zPXZvaWQgMDtjb25zdCByPW4oODk5KSxhPW4oNDQ0KSxvPW4oMjYzKTt0LnNldFJ1bk9wdGlvbnM9ZT0+e2NvbnN0IHQ9KDAsby5nZXRJbnN0YW5jZSkoKTtsZXQgbj0wO2NvbnN0IGk9W10scz1lfHx7fTt0cnl7aWYodm9pZCAwPT09KG51bGw9PWU/dm9pZCAwOmUubG9nU2V2ZXJpdHlMZXZlbCkpcy5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgZS5sb2dTZXZlcml0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1NldmVyaXR5TGV2ZWwpfHxlLmxvZ1NldmVyaXR5TGV2ZWw8MHx8ZS5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYodm9pZCAwPT09KG51bGw9PWU/dm9pZCAwOmUubG9nVmVyYm9zaXR5TGV2ZWwpKXMubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKFwibnVtYmVyXCIhPXR5cGVvZiBlLmxvZ1ZlcmJvc2l0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nVmVyYm9zaXR5TGV2ZWx9YCk7dm9pZCAwPT09KG51bGw9PWU/dm9pZCAwOmUudGVybWluYXRlKSYmKHMudGVybWluYXRlPSExKTtsZXQgbz0wO2lmKHZvaWQgMCE9PShudWxsPT1lP3ZvaWQgMDplLnRhZykmJihvPSgwLGEuYWxsb2NXYXNtU3RyaW5nKShlLnRhZyxpKSksbj10Ll9PcnRDcmVhdGVSdW5PcHRpb25zKHMubG9nU2V2ZXJpdHlMZXZlbCxzLmxvZ1ZlcmJvc2l0eUxldmVsLCEhcy50ZXJtaW5hdGUsbyksMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBjcmVhdGUgcnVuIG9wdGlvbnNcIik7cmV0dXJuIHZvaWQgMCE9PShudWxsPT1lP3ZvaWQgMDplLmV4dHJhKSYmKDAsci5pdGVyYXRlRXh0cmFPcHRpb25zKShlLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKChlLHIpPT57Y29uc3Qgbz0oMCxhLmFsbG9jV2FzbVN0cmluZykoZSxpKSxzPSgwLGEuYWxsb2NXYXNtU3RyaW5nKShyLGkpO2lmKDAhPT10Ll9PcnRBZGRSdW5Db25maWdFbnRyeShuLG8scykpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7ZX0gLSAke3J9YCl9KSksW24saV19Y2F0Y2goZSl7dGhyb3cgMCE9PW4mJnQuX09ydFJlbGVhc2VSdW5PcHRpb25zKG4pLGkuZm9yRWFjaCh0Ll9mcmVlKSxlfX19LDYyMjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5zZXRTZXNzaW9uT3B0aW9ucz12b2lkIDA7Y29uc3Qgcj1uKDg5OSksYT1uKDQ0NCksbz1uKDI2Myk7dC5zZXRTZXNzaW9uT3B0aW9ucz1lPT57dmFyIHQsbixpLHM7Y29uc3QgdT0oMCxvLmdldEluc3RhbmNlKSgpO2xldCBjPTA7Y29uc3QgbD1bXSxmPWV8fHt9OyhlPT57ZS5leHRyYXx8KGUuZXh0cmE9e30pLGUuZXh0cmEuc2Vzc2lvbnx8KGUuZXh0cmEuc2Vzc2lvbj17fSk7Y29uc3QgdD1lLmV4dHJhLnNlc3Npb247dC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5fHwodC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5PVwiMVwiKSxlLmV4ZWN1dGlvblByb3ZpZGVycyYmZS5leGVjdXRpb25Qcm92aWRlcnMuc29tZSgoZT0+XCJ3ZWJncHVcIj09PShcInN0cmluZ1wiPT10eXBlb2YgZT9lOmUubmFtZSkpKSYmKGUuZW5hYmxlTWVtUGF0dGVybj0hMSl9KShmKTt0cnl7Y29uc3QgZT0oZT0+e3N3aXRjaChlKXtjYXNlXCJkaXNhYmxlZFwiOnJldHVybiAwO2Nhc2VcImJhc2ljXCI6cmV0dXJuIDE7Y2FzZVwiZXh0ZW5kZWRcIjpyZXR1cm4gMjtjYXNlXCJhbGxcIjpyZXR1cm4gOTk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGdyYXBoIG9wdGltaXphdGlvbiBsZXZlbDogJHtlfWApfX0pKG51bGwhPT0odD1mLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwpJiZ2b2lkIDAhPT10P3Q6XCJhbGxcIikscD0oZT0+e3N3aXRjaChlKXtjYXNlXCJzZXF1ZW50aWFsXCI6cmV0dXJuIDA7Y2FzZVwicGFyYWxsZWxcIjpyZXR1cm4gMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7ZX1gKX19KShudWxsIT09KG49Zi5leGVjdXRpb25Nb2RlKSYmdm9pZCAwIT09bj9uOlwic2VxdWVudGlhbFwiKSxkPVwic3RyaW5nXCI9PXR5cGVvZiBmLmxvZ0lkPygwLGEuYWxsb2NXYXNtU3RyaW5nKShmLmxvZ0lkLGwpOjAsbT1udWxsIT09KGk9Zi5sb2dTZXZlcml0eUxldmVsKSYmdm9pZCAwIT09aT9pOjI7aWYoIU51bWJlci5pc0ludGVnZXIobSl8fG08MHx8bT40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7bX1gKTtjb25zdCBnPW51bGwhPT0ocz1mLmxvZ1ZlcmJvc2l0eUxldmVsKSYmdm9pZCAwIT09cz9zOjA7aWYoIU51bWJlci5pc0ludGVnZXIoZyl8fGc8MHx8Zz40KXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7Z31gKTtjb25zdCBoPVwic3RyaW5nXCI9PXR5cGVvZiBmLm9wdGltaXplZE1vZGVsRmlsZVBhdGg/KDAsYS5hbGxvY1dhc21TdHJpbmcpKGYub3B0aW1pemVkTW9kZWxGaWxlUGF0aCxsKTowO2lmKGM9dS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnMoZSwhIWYuZW5hYmxlQ3B1TWVtQXJlbmEsISFmLmVuYWJsZU1lbVBhdHRlcm4scCwhIWYuZW5hYmxlUHJvZmlsaW5nLDAsZCxtLGcsaCksMD09PWMpdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zXCIpO3JldHVybiBmLmV4ZWN1dGlvblByb3ZpZGVycyYmKChlLHQsbik9Pntmb3IoY29uc3QgciBvZiB0KXtsZXQgdD1cInN0cmluZ1wiPT10eXBlb2Ygcj9yOnIubmFtZTtzd2l0Y2godCl7Y2FzZVwieG5ucGFja1wiOnQ9XCJYTk5QQUNLXCI7YnJlYWs7Y2FzZVwid2ViZ3B1XCI6dD1cIkpTXCI7YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIEVQOiAke3R9YCl9Y29uc3QgaT0oMCxhLmFsbG9jV2FzbVN0cmluZykodCxuKTtpZigwIT09KDAsby5nZXRJbnN0YW5jZSkoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoZSxpKSl0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHt0fWApfX0pKGMsZi5leGVjdXRpb25Qcm92aWRlcnMsbCksdm9pZCAwIT09Zi5leHRyYSYmKDAsci5pdGVyYXRlRXh0cmFPcHRpb25zKShmLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKChlLHQpPT57Y29uc3Qgbj0oMCxhLmFsbG9jV2FzbVN0cmluZykoZSxsKSxyPSgwLGEuYWxsb2NXYXNtU3RyaW5nKSh0LGwpO2lmKDAhPT11Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoYyxuLHIpKXRocm93IG5ldyBFcnJvcihgQ2FuXFwndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJHtlfSAtICR7dH1gKX0pKSxbYyxsXX1jYXRjaChlKXt0aHJvdyAwIT09YyYmdS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKGMpLGwuZm9yRWFjaCh1Ll9mcmVlKSxlfX19LDQ0NDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5hbGxvY1dhc21TdHJpbmc9dm9pZCAwO2NvbnN0IHI9bigyNjMpO3QuYWxsb2NXYXNtU3RyaW5nPShlLHQpPT57Y29uc3Qgbj0oMCxyLmdldEluc3RhbmNlKSgpLGE9bi5sZW5ndGhCeXRlc1VURjgoZSkrMSxvPW4uX21hbGxvYyhhKTtyZXR1cm4gbi5zdHJpbmdUb1VURjgoZSxvLGEpLHQucHVzaChvKSxvfX0sOTE3OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5sb2dMZXZlbFN0cmluZ1RvRW51bT10LnRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcj10LmdldFRlbnNvckVsZW1lbnRTaXplPXQudGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmc9dC50ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bT12b2lkIDAsdC50ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bT1lPT57c3dpdGNoKGUpe2Nhc2VcImludDhcIjpyZXR1cm4gMztjYXNlXCJ1aW50OFwiOnJldHVybiAyO2Nhc2VcImJvb2xcIjpyZXR1cm4gOTtjYXNlXCJpbnQxNlwiOnJldHVybiA1O2Nhc2VcInVpbnQxNlwiOnJldHVybiA0O2Nhc2VcImludDMyXCI6cmV0dXJuIDY7Y2FzZVwidWludDMyXCI6cmV0dXJuIDEyO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gMTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIDExO2Nhc2VcInN0cmluZ1wiOnJldHVybiA4O2Nhc2VcImludDY0XCI6cmV0dXJuIDc7Y2FzZVwidWludDY0XCI6cmV0dXJuIDEzO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LHQudGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmc9ZT0+e3N3aXRjaChlKXtjYXNlIDM6cmV0dXJuXCJpbnQ4XCI7Y2FzZSAyOnJldHVyblwidWludDhcIjtjYXNlIDk6cmV0dXJuXCJib29sXCI7Y2FzZSA1OnJldHVyblwiaW50MTZcIjtjYXNlIDQ6cmV0dXJuXCJ1aW50MTZcIjtjYXNlIDY6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgMTI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIDE6cmV0dXJuXCJmbG9hdDMyXCI7Y2FzZSAxMTpyZXR1cm5cImZsb2F0NjRcIjtjYXNlIDg6cmV0dXJuXCJzdHJpbmdcIjtjYXNlIDc6cmV0dXJuXCJpbnQ2NFwiO2Nhc2UgMTM6cmV0dXJuXCJ1aW50NjRcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSx0LmdldFRlbnNvckVsZW1lbnRTaXplPWU9Plt2b2lkIDAsNCwxLDEsMiwyLDQsOCx2b2lkIDAsMSwyLDgsNCw4LHZvaWQgMCx2b2lkIDAsdm9pZCAwXVtlXSx0LnRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcj1lPT57c3dpdGNoKGUpe2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6Y2FzZVwiYm9vbFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImludDhcIjpyZXR1cm4gSW50OEFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcImludDMyXCI6cmV0dXJuIEludDMyQXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke2V9YCl9fSx0LmxvZ0xldmVsU3RyaW5nVG9FbnVtPWU9Pntzd2l0Y2goZSl7Y2FzZVwidmVyYm9zZVwiOnJldHVybiAwO2Nhc2VcImluZm9cIjpyZXR1cm4gMTtjYXNlXCJ3YXJuaW5nXCI6cmV0dXJuIDI7Y2FzZVwiZXJyb3JcIjpyZXR1cm4gMztjYXNlXCJmYXRhbFwiOnJldHVybiA0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2V9YCl9fX0sMjU5OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzPXQuZW5kUHJvZmlsaW5nPXQucnVuPXQucmVsZWFzZVNlc3Npb249dC5jcmVhdGVTZXNzaW9uPXQuY3JlYXRlU2Vzc2lvbkZpbmFsaXplPXQuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPXQuaW5pdE9ydD12b2lkIDA7Y29uc3Qgcj1uKDkxOCksYT1uKDYyMiksbz1uKDQ0NCksaT1uKDkxNykscz1uKDI2Myk7dC5pbml0T3J0PShlLHQpPT57Y29uc3Qgbj0oMCxzLmdldEluc3RhbmNlKSgpLl9PcnRJbml0KGUsdCk7aWYoMCE9PW4pdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuIGVycm9yIGNvZGUgPSAke259YCl9O2NvbnN0IHU9bmV3IE1hcDt0LmNyZWF0ZVNlc3Npb25BbGxvY2F0ZT1lPT57Y29uc3QgdD0oMCxzLmdldEluc3RhbmNlKSgpLG49dC5fbWFsbG9jKGUuYnl0ZUxlbmd0aCk7cmV0dXJuIHQuSEVBUFU4LnNldChlLG4pLFtuLGUuYnl0ZUxlbmd0aF19LHQuY3JlYXRlU2Vzc2lvbkZpbmFsaXplPShlLHQpPT57Y29uc3Qgbj0oMCxzLmdldEluc3RhbmNlKSgpO2xldCByPTAsbz0wLGk9W107dHJ5e2lmKFtvLGldPSgwLGEuc2V0U2Vzc2lvbk9wdGlvbnMpKHQpLHI9bi5fT3J0Q3JlYXRlU2Vzc2lvbihlWzBdLGVbMV0sbyksMD09PXIpdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBjcmVhdGUgYSBzZXNzaW9uXCIpfWZpbmFsbHl7bi5fZnJlZShlWzBdKSwwIT09byYmbi5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKG8pLGkuZm9yRWFjaChuLl9mcmVlKX1jb25zdCBjPW4uX09ydEdldElucHV0Q291bnQociksbD1uLl9PcnRHZXRPdXRwdXRDb3VudChyKSxmPVtdLHA9W10sZD1bXSxtPVtdO2ZvcihsZXQgZT0wO2U8YztlKyspe2NvbnN0IHQ9bi5fT3J0R2V0SW5wdXROYW1lKHIsZSk7aWYoMD09PXQpdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBnZXQgYW4gaW5wdXQgbmFtZVwiKTtwLnB1c2godCksZi5wdXNoKG4uVVRGOFRvU3RyaW5nKHQpKX1mb3IobGV0IGU9MDtlPGw7ZSsrKXtjb25zdCB0PW4uX09ydEdldE91dHB1dE5hbWUocixlKTtpZigwPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGdldCBhbiBvdXRwdXQgbmFtZVwiKTttLnB1c2godCksZC5wdXNoKG4uVVRGOFRvU3RyaW5nKHQpKX1yZXR1cm4gdS5zZXQocixbcixwLG1dKSxbcixmLGRdfSx0LmNyZWF0ZVNlc3Npb249KGUsbik9Pntjb25zdCByPSgwLHQuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKShlKTtyZXR1cm4oMCx0LmNyZWF0ZVNlc3Npb25GaW5hbGl6ZSkocixuKX0sdC5yZWxlYXNlU2Vzc2lvbj1lPT57Y29uc3QgdD0oMCxzLmdldEluc3RhbmNlKSgpLG49dS5nZXQoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2NvbnN0IHI9blswXSxhPW5bMV0sbz1uWzJdO2EuZm9yRWFjaCh0Ll9PcnRGcmVlKSxvLmZvckVhY2godC5fT3J0RnJlZSksdC5fT3J0UmVsZWFzZVNlc3Npb24ociksdS5kZWxldGUoZSl9LHQucnVuPWFzeW5jKGUsdCxuLGEsYyk9Pntjb25zdCBsPSgwLHMuZ2V0SW5zdGFuY2UpKCksZj11LmdldChlKTtpZighZil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7Y29uc3QgcD1mWzBdLGQ9ZlsxXSxtPWZbMl0sZz10Lmxlbmd0aCxoPWEubGVuZ3RoO2xldCB5PTAsdj1bXTtjb25zdCBiPVtdLHc9W107dHJ5e1t5LHZdPSgwLHIuc2V0UnVuT3B0aW9ucykoYyk7Zm9yKGxldCBlPTA7ZTxnO2UrKyl7Y29uc3QgdD1uW2VdWzBdLHI9bltlXVsxXSxhPW5bZV1bMl07bGV0IHMsdTtpZihBcnJheS5pc0FycmF5KGEpKXt1PTQqYS5sZW5ndGgscz1sLl9tYWxsb2ModSksdy5wdXNoKHMpO2xldCBlPXMvNDtmb3IobGV0IHQ9MDt0PGEubGVuZ3RoO3QrKyl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGFbdF0pdGhyb3cgbmV3IFR5cGVFcnJvcihgdGVuc29yIGRhdGEgYXQgaW5kZXggJHt0fSBpcyBub3QgYSBzdHJpbmdgKTtsLkhFQVBVMzJbZSsrXT0oMCxvLmFsbG9jV2FzbVN0cmluZykoYVt0XSx3KX19ZWxzZSB1PWEuYnl0ZUxlbmd0aCxzPWwuX21hbGxvYyh1KSx3LnB1c2gocyksbC5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLGEuYnl0ZU9mZnNldCx1KSxzKTtjb25zdCBjPWwuc3RhY2tTYXZlKCksZj1sLnN0YWNrQWxsb2MoNCpyLmxlbmd0aCk7dHJ5e2xldCBlPWYvNDtyLmZvckVhY2goKHQ9PmwuSEVBUDMyW2UrK109dCkpO2NvbnN0IG49bC5fT3J0Q3JlYXRlVGVuc29yKCgwLGkudGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0pKHQpLHMsdSxmLHIubGVuZ3RoKTtpZigwPT09bil0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGNyZWF0ZSBhIHRlbnNvclwiKTtiLnB1c2gobil9ZmluYWxseXtsLnN0YWNrUmVzdG9yZShjKX19Y29uc3QgZT1sLnN0YWNrU2F2ZSgpLHM9bC5zdGFja0FsbG9jKDQqZyksdT1sLnN0YWNrQWxsb2MoNCpnKSxmPWwuc3RhY2tBbGxvYyg0KmgpLF89bC5zdGFja0FsbG9jKDQqaCk7dHJ5e2xldCBlPXMvNCxuPXUvNCxyPWYvNCxvPV8vNDtmb3IobGV0IHI9MDtyPGc7cisrKWwuSEVBUFUzMltlKytdPWJbcl0sbC5IRUFQVTMyW24rK109ZFt0W3JdXTtmb3IobGV0IGU9MDtlPGg7ZSsrKWwuSEVBUFUzMltyKytdPTAsbC5IRUFQVTMyW28rK109bVthW2VdXTtsZXQgYz1sLl9PcnRSdW4ocCx1LHMsZyxfLGgsZix5KTtjb25zdCB2PWwuanNlcFJ1blByb21pc2U7diYmdm9pZCAwIT09di50aGVuJiYoYz1hd2FpdCB2KTtjb25zdCB3PVtdO2lmKDA9PT1jKWZvcihsZXQgZT0wO2U8aDtlKyspe2NvbnN0IHQ9bC5IRUFQVTMyW2YvNCtlXSxuPWwuc3RhY2tTYXZlKCkscj1sLnN0YWNrQWxsb2MoMTYpO2xldCBhLG89MDt0cnl7aWYoYz1sLl9PcnRHZXRUZW5zb3JEYXRhKHQscixyKzQscis4LHIrMTIpLDAhPT1jKXRocm93IG5ldyBFcnJvcihgQ2FuXFwndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhLiBlcnJvciBjb2RlID0gJHtjfWApO2xldCBlPXIvNDtjb25zdCBuPWwuSEVBUFUzMltlKytdO289bC5IRUFQVTMyW2UrK107Y29uc3Qgcz1sLkhFQVBVMzJbZSsrXSx1PWwuSEVBUFUzMltlKytdLGY9W107Zm9yKGxldCBlPTA7ZTx1O2UrKylmLnB1c2gobC5IRUFQVTMyW3MvNCtlXSk7bC5fT3J0RnJlZShzKTtjb25zdCBwPTA9PT1mLmxlbmd0aD8xOmYucmVkdWNlKCgoZSx0KT0+ZSp0KSk7aWYoYT0oMCxpLnRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKShuKSxcInN0cmluZ1wiPT09YSl7Y29uc3QgZT1bXTtsZXQgdD1vLzQ7Zm9yKGxldCBuPTA7bjxwO24rKyl7Y29uc3Qgcj1sLkhFQVBVMzJbdCsrXSxhPW49PT1wLTE/dm9pZCAwOmwuSEVBUFUzMlt0XS1yO2UucHVzaChsLlVURjhUb1N0cmluZyhyLGEpKX13LnB1c2goW2EsZixlXSl9ZWxzZXtjb25zdCBlPW5ldygoMCxpLnRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3RvcikoYSkpKHApO25ldyBVaW50OEFycmF5KGUuYnVmZmVyLGUuYnl0ZU9mZnNldCxlLmJ5dGVMZW5ndGgpLnNldChsLkhFQVBVOC5zdWJhcnJheShvLG8rZS5ieXRlTGVuZ3RoKSksdy5wdXNoKFthLGYsZV0pfX1maW5hbGx5e2wuc3RhY2tSZXN0b3JlKG4pLFwic3RyaW5nXCI9PT1hJiZvJiZsLl9mcmVlKG8pLGwuX09ydFJlbGVhc2VUZW5zb3IodCl9fWlmKDA9PT1jKXJldHVybiB3O3Rocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGNhbGwgT3J0UnVuKCkuIGVycm9yIGNvZGUgPSAke2N9LmApfWZpbmFsbHl7bC5zdGFja1Jlc3RvcmUoZSl9fWZpbmFsbHl7Yi5mb3JFYWNoKGwuX09ydFJlbGVhc2VUZW5zb3IpLHcuZm9yRWFjaChsLl9mcmVlKSxsLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyh5KSx2LmZvckVhY2gobC5fZnJlZSl9fSx0LmVuZFByb2ZpbGluZz1lPT57Y29uc3QgdD0oMCxzLmdldEluc3RhbmNlKSgpLG49dS5nZXQoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2NvbnN0IHI9blswXSxhPXQuX09ydEVuZFByb2ZpbGluZyhyKTtpZigwPT09YSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGdldCBhbiBwcm9maWxlIGZpbGUgbmFtZVwiKTt0Ll9PcnRGcmVlKGEpfSx0LmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzPWU9Pntjb25zdCB0PVtdO2Zvcihjb25zdCBuIG9mIGUpe2NvbnN0IGU9blsyXTshQXJyYXkuaXNBcnJheShlKSYmZS5idWZmZXImJnQucHVzaChlLmJ1ZmZlcil9cmV0dXJuIHR9fSwyNjM6ZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQsbixyKXt2b2lkIDA9PT1yJiYocj1uKTt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbik7YSYmIShcImdldFwiaW4gYT8hdC5fX2VzTW9kdWxlOmEud3JpdGFibGV8fGEuY29uZmlndXJhYmxlKXx8KGE9e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbbl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixhKX06ZnVuY3Rpb24oZSx0LG4scil7dm9pZCAwPT09ciYmKHI9biksZVtyXT10W25dfSksYT10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSl9OmZ1bmN0aW9uKGUsdCl7ZS5kZWZhdWx0PXR9KSxvPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIG4gaW4gZSlcImRlZmF1bHRcIiE9PW4mJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pJiZyKHQsZSxuKTtyZXR1cm4gYSh0LGUpLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGlzcG9zZT10LmdldEluc3RhbmNlPXQuaW5pdGlhbGl6ZVdlYkFzc2VtYmx5PXZvaWQgMDtjb25zdCBpPW8obig0NDkpKSxzPW4oOTMyKSx1PW4oNDc0KTtsZXQgYyxsPSExLGY9ITEscD0hMTt0LmluaXRpYWxpemVXZWJBc3NlbWJseT1hc3luYyBlPT57aWYobClyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7aWYoZil0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byBcXCdpbml0aWFsaXplV2ViQXNzZW1ibHkoKVxcJyBkZXRlY3RlZC5cIik7aWYocCl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvIFxcJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpXFwnIGZhaWxlZC5cIik7Zj0hMDtjb25zdCB0PWUuaW5pdFRpbWVvdXQscj1lLm51bVRocmVhZHMsYT1lLnNpbWQsbz1yPjEmJigoKT0+e3RyeXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXImJihcInVuZGVmaW5lZFwiIT10eXBlb2YgTWVzc2FnZUNoYW5uZWwmJihuZXcgTWVzc2FnZUNoYW5uZWwpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSksV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDUsNCwxLDMsMSwxLDEwLDExLDEsOSwwLDY1LDAsMjU0LDE2LDIsMCwyNiwxMV0pKSl9Y2F0Y2goZSl7cmV0dXJuITF9fSkoKSxkPWEmJigoKT0+e3RyeXtyZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDMwLDEsMjgsMCw2NSwwLDI1MywxNSwyNTMsMTIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyNTMsMTg2LDEsMjYsMTFdKSl9Y2F0Y2goZSl7cmV0dXJuITF9fSkoKSxtPWUud2FzbVBhdGhzLGc9XCJzdHJpbmdcIj09dHlwZW9mIG0/bTp2b2lkIDAsaD0oKGUsdCk9PnQ/ZT9cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbVwiOlwib3J0LXdhc20tdGhyZWFkZWQud2FzbVwiOmU/XCJvcnQtd2FzbS1zaW1kLndhc21cIjpcIm9ydC13YXNtLndhc21cIikoZCxvKSx5PVwib2JqZWN0XCI9PXR5cGVvZiBtP21baF06dm9pZCAwO2xldCB2PSExO2NvbnN0IGI9W107aWYodD4wJiZiLnB1c2gobmV3IFByb21pc2UoKGU9PntzZXRUaW1lb3V0KCgoKT0+e3Y9ITAsZSgpfSksdCl9KSkpLGIucHVzaChuZXcgUHJvbWlzZSgoKGUsdCk9Pntjb25zdCByPW8/dTpzLGE9e2xvY2F0ZUZpbGU6KGUsdCk9Pm8mJmUuZW5kc1dpdGgoXCIud29ya2VyLmpzXCIpJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgQmxvYj9VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtuKDE1NCldLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSk6ZS5lbmRzV2l0aChcIi53YXNtXCIpP3l8fChudWxsIT1nP2c6dCkraDp0K2V9O2lmKG8paWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIEJsb2IpYS5tYWluU2NyaXB0VXJsT3JCbG9iPWkuam9pbihcIi9cIixcIm9ydC13YXNtLXRocmVhZGVkLmpzXCIpO2Vsc2V7Y29uc3QgZT1gdmFyIG9ydFdhc21UaHJlYWRlZD0oZnVuY3Rpb24oKXt2YXIgX3NjcmlwdERpcjtyZXR1cm4gJHtyLnRvU3RyaW5nKCl9fSkoKTtgO2EubWFpblNjcmlwdFVybE9yQmxvYj1uZXcgQmxvYihbZV0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pfXIoYSkudGhlbigodD0+e2Y9ITEsbD0hMCxjPXQsZSgpfSksKGU9PntmPSExLHA9ITAsdChlKX0pKX0pKSksYXdhaXQgUHJvbWlzZS5yYWNlKGIpLHYpdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7dH1tc2ApfSx0LmdldEluc3RhbmNlPSgpPT57aWYobCYmYylyZXR1cm4gYzt0aHJvdyBuZXcgRXJyb3IoXCJXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LlwiKX0sdC5kaXNwb3NlPSgpPT57dmFyIGU7IWx8fGZ8fHB8fChmPSEwLG51bGw9PT0oZT1jLlBUaHJlYWQpfHx2b2lkIDA9PT1lfHxlLnRlcm1pbmF0ZUFsbFRocmVhZHMoKSxjPXZvaWQgMCxmPSExLGw9ITEscD0hMCl9fSw0NzQ6KGUsdCxuKT0+e3ZhciBfc2NyaXB0RGlyLHI9KF9zY3JpcHREaXI9KF9zY3JpcHREaXI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMCl8fFwiL2luZGV4LmpzXCIsZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBQLmJ1ZmZlciE9RCYmRyhQLmJ1ZmZlciksRn1mdW5jdGlvbiByKCl7cmV0dXJuIFAuYnVmZmVyIT1EJiZHKFAuYnVmZmVyKSxVfWZ1bmN0aW9uIGEoKXtyZXR1cm4gUC5idWZmZXIhPUQmJkcoUC5idWZmZXIpLEl9ZnVuY3Rpb24gbygpe3JldHVybiBQLmJ1ZmZlciE9RCYmRyhQLmJ1ZmZlciksV31mdW5jdGlvbiBpKCl7cmV0dXJuIFAuYnVmZmVyIT1EJiZHKFAuYnVmZmVyKSxqfXZhciBzLHUsYztlPWV8fHt9LHN8fChzPXZvaWQgMCE9PWU/ZTp7fSkscy5yZWFkeT1uZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSx0KXt1PWUsYz10fSkpO3ZhciBsLGYscCxkLG0sZyxoPU9iamVjdC5hc3NpZ24oe30scykseT1cIi4vdGhpcy5wcm9ncmFtXCIsdj0oZSx0KT0+e3Rocm93IHR9LGI9XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyx3PVwiZnVuY3Rpb25cIj09dHlwZW9mIGltcG9ydFNjcmlwdHMsXz1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUsTz1zLkVOVklST05NRU5UX0lTX1BUSFJFQUR8fCExLFM9XCJcIjtmdW5jdGlvbiBUKGUpe3JldHVybiBzLmxvY2F0ZUZpbGU/cy5sb2NhdGVGaWxlKGUsUyk6UytlfWlmKF8pe2xldCB0O1M9dz9uKDkwOCkuZGlybmFtZShTKStcIi9cIjpcIi8vXCIsZz0oKT0+e218fChkPW4oMzg0KSxtPW4oOTA4KSl9LGw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZygpLGU9bS5ub3JtYWxpemUoZSksZC5yZWFkRmlsZVN5bmMoZSx0P3ZvaWQgMDpcInV0ZjhcIil9LHA9ZT0+KChlPWwoZSwhMCkpLmJ1ZmZlcnx8KGU9bmV3IFVpbnQ4QXJyYXkoZSkpLGUpLGY9KGUsdCxuKT0+e2coKSxlPW0ubm9ybWFsaXplKGUpLGQucmVhZEZpbGUoZSwoZnVuY3Rpb24oZSxyKXtlP24oZSk6dChyLmJ1ZmZlcil9KSl9LDE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKHk9cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFxcXFxcL2csXCIvXCIpKSxwcm9jZXNzLmFyZ3Yuc2xpY2UoMikscHJvY2Vzcy5vbihcInVuY2F1Z2h0RXhjZXB0aW9uXCIsKGZ1bmN0aW9uKGUpe2lmKCEoZSBpbnN0YW5jZW9mIGllKSl0aHJvdyBlfSkpLHByb2Nlc3Mub24oXCJ1bmhhbmRsZWRSZWplY3Rpb25cIiwoZnVuY3Rpb24oZSl7dGhyb3cgZX0pKSx2PShlLHQpPT57aWYoQyl0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPWUsdDt0IGluc3RhbmNlb2YgaWV8fHgoXCJleGl0aW5nIGR1ZSB0byBleGNlcHRpb246IFwiK3QpLHByb2Nlc3MuZXhpdChlKX0scy5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifTt0cnl7dD1uKDkyNSl9Y2F0Y2goZSl7dGhyb3cgY29uc29sZS5lcnJvcihcXCdUaGUgXCJ3b3JrZXJfdGhyZWFkc1wiIG1vZHVsZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgbm9kZS5qcyBidWlsZCAtIHBlcmhhcHMgYSBuZXdlciB2ZXJzaW9uIGlzIG5lZWRlZD9cXCcpLGV9bi5nLldvcmtlcj10Lldvcmtlcn1lbHNlKGJ8fHcpJiYodz9TPXNlbGYubG9jYXRpb24uaHJlZjpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihTPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxfc2NyaXB0RGlyJiYoUz1fc2NyaXB0RGlyKSxTPTAhPT1TLmluZGV4T2YoXCJibG9iOlwiKT9TLnN1YnN0cigwLFMucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIixffHwobD1lPT57dmFyIHQ9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB0Lm9wZW4oXCJHRVRcIixlLCExKSx0LnNlbmQobnVsbCksdC5yZXNwb25zZVRleHR9LHcmJihwPWU9Pnt2YXIgdD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHQub3BlbihcIkdFVFwiLGUsITEpLHQucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIix0LnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkodC5yZXNwb25zZSl9KSxmPShlLHQsbik9Pnt2YXIgcj1uZXcgWE1MSHR0cFJlcXVlc3Q7ci5vcGVuKFwiR0VUXCIsZSwhMCksci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLHIub25sb2FkPSgpPT57MjAwPT1yLnN0YXR1c3x8MD09ci5zdGF0dXMmJnIucmVzcG9uc2U/dChyLnJlc3BvbnNlKTpuKCl9LHIub25lcnJvcj1uLHIuc2VuZChudWxsKX0pKTtfJiZcInVuZGVmaW5lZFwiPT10eXBlb2YgcGVyZm9ybWFuY2UmJihuLmcucGVyZm9ybWFuY2U9big5NTMpLnBlcmZvcm1hbmNlKTt2YXIgQT1jb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLEU9Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XyYmKGcoKSxBPWU9PmQud3JpdGVTeW5jKDEsZStcIlxcXFxuXCIpLEU9ZT0+ZC53cml0ZVN5bmMoMixlK1wiXFxcXG5cIikpO3ZhciBNLFI9cy5wcmludHx8QSx4PXMucHJpbnRFcnJ8fEU7T2JqZWN0LmFzc2lnbihzLGgpLGg9bnVsbCxzLnRoaXNQcm9ncmFtJiYoeT1zLnRoaXNQcm9ncmFtKSxzLnF1aXQmJih2PXMucXVpdCkscy53YXNtQmluYXJ5JiYoTT1zLndhc21CaW5hcnkpO3ZhciBDPXMubm9FeGl0UnVudGltZXx8ITA7XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZuZShcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIFAsayxELEYsVSxJLFcsaixIPSExLEw9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwO2Z1bmN0aW9uIFkoZSx0LG4pe3ZhciByPSh0Pj4+PTApK247Zm9yKG49dDtlW25dJiYhKG4+PXIpOykrK247aWYoMTY8bi10JiZlLmJ1ZmZlciYmTClyZXR1cm4gTC5kZWNvZGUoZS5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcj9lLnNsaWNlKHQsbik6ZS5zdWJhcnJheSh0LG4pKTtmb3Iocj1cIlwiO3Q8bjspe3ZhciBhPWVbdCsrXTtpZigxMjgmYSl7dmFyIG89NjMmZVt0KytdO2lmKDE5Mj09KDIyNCZhKSlyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzMSZhKTw8NnxvKTtlbHNle3ZhciBpPTYzJmVbdCsrXTs2NTUzNj4oYT0yMjQ9PSgyNDAmYSk/KDE1JmEpPDwxMnxvPDw2fGk6KDcmYSk8PDE4fG88PDEyfGk8PDZ8NjMmZVt0KytdKT9yKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpOihhLT02NTUzNixyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGE+PjEwLDU2MzIwfDEwMjMmYSkpfX1lbHNlIHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoYSl9cmV0dXJuIHJ9ZnVuY3Rpb24geihlLHQpe3JldHVybihlPj4+PTApP1kocigpLGUsdCk6XCJcIn1mdW5jdGlvbiBCKGUsdCxuLHIpe2lmKCEoMDxyKSlyZXR1cm4gMDt2YXIgYT1uPj4+PTA7cj1uK3ItMTtmb3IodmFyIG89MDtvPGUubGVuZ3RoOysrbyl7dmFyIGk9ZS5jaGFyQ29kZUF0KG8pO2lmKDU1Mjk2PD1pJiY1NzM0Mz49aSYmKGk9NjU1MzYrKCgxMDIzJmkpPDwxMCl8MTAyMyZlLmNoYXJDb2RlQXQoKytvKSksMTI3Pj1pKXtpZihuPj1yKWJyZWFrO3RbbisrPj4+MF09aX1lbHNle2lmKDIwNDc+PWkpe2lmKG4rMT49cilicmVhazt0W24rKz4+PjBdPTE5MnxpPj42fWVsc2V7aWYoNjU1MzU+PWkpe2lmKG4rMj49cilicmVhazt0W24rKz4+PjBdPTIyNHxpPj4xMn1lbHNle2lmKG4rMz49cilicmVhazt0W24rKz4+PjBdPTI0MHxpPj4xOCx0W24rKz4+PjBdPTEyOHxpPj4xMiY2M310W24rKz4+PjBdPTEyOHxpPj42JjYzfXRbbisrPj4+MF09MTI4fDYzJml9fXJldHVybiB0W24+Pj4wXT0wLG4tYX1mdW5jdGlvbiBOKGUpe2Zvcih2YXIgdD0wLG49MDtuPGUubGVuZ3RoOysrbil7dmFyIHI9ZS5jaGFyQ29kZUF0KG4pOzEyNz49cj90Kys6MjA0Nz49cj90Kz0yOjU1Mjk2PD1yJiY1NzM0Mz49cj8odCs9NCwrK24pOnQrPTN9cmV0dXJuIHR9ZnVuY3Rpb24gRyhlKXtEPWUscy5IRUFQOD1GPW5ldyBJbnQ4QXJyYXkoZSkscy5IRUFQMTY9bmV3IEludDE2QXJyYXkoZSkscy5IRUFQMzI9ST1uZXcgSW50MzJBcnJheShlKSxzLkhFQVBVOD1VPW5ldyBVaW50OEFycmF5KGUpLHMuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkoZSkscy5IRUFQVTMyPVc9bmV3IFVpbnQzMkFycmF5KGUpLHMuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KGUpLHMuSEVBUEY2ND1qPW5ldyBGbG9hdDY0QXJyYXkoZSl9TyYmKEQ9cy5idWZmZXIpO3ZhciBxPXMuSU5JVElBTF9NRU1PUll8fDE2Nzc3MjE2O2lmKE8pUD1zLndhc21NZW1vcnksRD1zLmJ1ZmZlcjtlbHNlIGlmKHMud2FzbU1lbW9yeSlQPXMud2FzbU1lbW9yeTtlbHNlIGlmKCEoKFA9bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpxLzY1NTM2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSkpLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSl0aHJvdyB4KFwicmVxdWVzdGVkIGEgc2hhcmVkIFdlYkFzc2VtYmx5Lk1lbW9yeSBidXQgdGhlIHJldHVybmVkIGJ1ZmZlciBpcyBub3QgYSBTaGFyZWRBcnJheUJ1ZmZlciwgaW5kaWNhdGluZyB0aGF0IHdoaWxlIHRoZSBicm93c2VyIGhhcyBTaGFyZWRBcnJheUJ1ZmZlciBpdCBkb2VzIG5vdCBoYXZlIFdlYkFzc2VtYmx5IHRocmVhZHMgc3VwcG9ydCAtIHlvdSBtYXkgbmVlZCB0byBzZXQgYSBmbGFnXCIpLF8mJmNvbnNvbGUubG9nKFwiKG9uIG5vZGUgeW91IG1heSBuZWVkOiAtLWV4cGVyaW1lbnRhbC13YXNtLXRocmVhZHMgLS1leHBlcmltZW50YWwtd2FzbS1idWxrLW1lbW9yeSBhbmQgYWxzbyB1c2UgYSByZWNlbnQgdmVyc2lvbilcIiksRXJyb3IoXCJiYWQgbWVtb3J5XCIpO1AmJihEPVAuYnVmZmVyKSxxPUQuYnl0ZUxlbmd0aCxHKEQpO3ZhciAkLFY9W10sSj1bXSxRPVtdO2Z1bmN0aW9uIFgoKXt2YXIgZT1zLnByZVJ1bi5zaGlmdCgpO1YudW5zaGlmdChlKX12YXIgSyxaPTAsZWU9bnVsbCx0ZT1udWxsO2Z1bmN0aW9uIG5lKGUpe3Rocm93IE8/cG9zdE1lc3NhZ2Uoe2NtZDpcIm9uQWJvcnRcIixhcmc6ZX0pOnMub25BYm9ydCYmcy5vbkFib3J0KGUpLHgoZT1cIkFib3J0ZWQoXCIrZStcIilcIiksSD0hMCxlPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoZStcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksYyhlKSxlfWZ1bmN0aW9uIHJlKCl7cmV0dXJuIEsuc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIil9ZnVuY3Rpb24gYWUoKXt2YXIgZT1LO3RyeXtpZihlPT1LJiZNKXJldHVybiBuZXcgVWludDhBcnJheShNKTtpZihwKXJldHVybiBwKGUpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWNhdGNoKGUpe25lKGUpfX1LPVwib3J0LXdhc20tdGhyZWFkZWQud2FzbVwiLHJlKCl8fChLPVQoSykpO3ZhciBvZT17fTtmdW5jdGlvbiBpZShlKXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPVwiUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdChcIitlK1wiKVwiLHRoaXMuc3RhdHVzPWV9ZnVuY3Rpb24gc2UoZSl7KGU9ZmUuTGFbZV0pfHxuZSgpLGZlLlhhKGUpfWZ1bmN0aW9uIHVlKGUpe3ZhciB0PWZlLmxiKCk7aWYoIXQpcmV0dXJuIDY7ZmUuUmEucHVzaCh0KSxmZS5MYVtlLkthXT10LHQuS2E9ZS5LYTt2YXIgbj17Y21kOlwicnVuXCIsc3RhcnRfcm91dGluZTplLnBiLGFyZzplLmliLHB0aHJlYWRfcHRyOmUuS2F9O3JldHVybiB0LlFhPSgpPT57bi50aW1lPXBlcmZvcm1hbmNlLm5vdygpLHQucG9zdE1lc3NhZ2UobixlLnZiKX0sdC5sb2FkZWQmJih0LlFhKCksZGVsZXRlIHQuUWEpLDB9ZnVuY3Rpb24gY2UoZSl7aWYoTylyZXR1cm4gSGUoMSwxLGUpO0N8fChmZS5xYigpLHMub25FeGl0JiZzLm9uRXhpdChlKSxIPSEwKSx2KGUsbmV3IGllKGUpKX1mdW5jdGlvbiBsZShlLHQpe2lmKCF0JiZPKXRocm93IGRlKGUpLFwidW53aW5kXCI7Y2UoZSl9dmFyIGZlPXtPYTpbXSxSYTpbXSwkYTpbXSxMYTp7fSxVYTpmdW5jdGlvbigpe08mJmZlLm1iKCl9LHhiOmZ1bmN0aW9uKCl7fSxtYjpmdW5jdGlvbigpe2ZlLnJlY2VpdmVPYmplY3RUcmFuc2Zlcj1mZS5vYixmZS50aHJlYWRJbml0VExTPWZlLlphLGZlLnNldEV4aXRTdGF0dXM9ZmUuWWEsQz0hMX0sWWE6ZnVuY3Rpb24oKXt9LHFiOmZ1bmN0aW9uKCl7Zm9yKHZhciBlIG9mIE9iamVjdC52YWx1ZXMoZmUuTGEpKWZlLlhhKGUpO2ZvcihlIG9mIGZlLk9hKWUudGVybWluYXRlKCk7ZmUuT2E9W119LFhhOmZ1bmN0aW9uKGUpe3ZhciB0PWUuS2E7ZGVsZXRlIGZlLkxhW3RdLGZlLk9hLnB1c2goZSksZmUuUmEuc3BsaWNlKGZlLlJhLmluZGV4T2YoZSksMSksZS5LYT0wLGN0KHQpfSxvYjpmdW5jdGlvbigpe30sWmE6ZnVuY3Rpb24oKXtmZS4kYS5mb3JFYWNoKChlPT5lKCkpKX0sbmI6ZnVuY3Rpb24oZSx0KXtlLm9ubWVzc2FnZT1uPT57dmFyIHI9KG49bi5kYXRhKS5jbWQ7aWYoZS5LYSYmKGZlLmtiPWUuS2EpLG4udGFyZ2V0VGhyZWFkJiZuLnRhcmdldFRocmVhZCE9cnQoKSl7dmFyIGE9ZmUuTGFbbi55Yl07YT9hLnBvc3RNZXNzYWdlKG4sbi50cmFuc2Zlckxpc3QpOngoXFwnSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIlxcJytyK1xcJ1wiIHRvIHRhcmdldCBwdGhyZWFkIFxcJytuLnRhcmdldFRocmVhZCtcIiwgYnV0IHRoYXQgdGhyZWFkIG5vIGxvbmdlciBleGlzdHMhXCIpfWVsc2VcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCI9PT1yP0RlKG4ucXVldWUpOlwic3Bhd25UaHJlYWRcIj09PXI/dWUobik6XCJjbGVhbnVwVGhyZWFkXCI9PT1yP3NlKG4udGhyZWFkKTpcImtpbGxUaHJlYWRcIj09PXI/KG49bi50aHJlYWQscj1mZS5MYVtuXSxkZWxldGUgZmUuTGFbbl0sci50ZXJtaW5hdGUoKSxjdChuKSxmZS5SYS5zcGxpY2UoZmUuUmEuaW5kZXhPZihyKSwxKSxyLkthPTApOlwiY2FuY2VsVGhyZWFkXCI9PT1yP2ZlLkxhW24udGhyZWFkXS5wb3N0TWVzc2FnZSh7Y21kOlwiY2FuY2VsXCJ9KTpcImxvYWRlZFwiPT09cj8oZS5sb2FkZWQ9ITAsdCYmdChlKSxlLlFhJiYoZS5RYSgpLGRlbGV0ZSBlLlFhKSk6XCJwcmludFwiPT09cj9SKFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJwcmludEVyclwiPT09cj94KFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJhbGVydFwiPT09cj9hbGVydChcIlRocmVhZCBcIituLnRocmVhZElkK1wiOiBcIituLnRleHQpOlwic2V0aW1tZWRpYXRlXCI9PT1uLnRhcmdldD9lLnBvc3RNZXNzYWdlKG4pOlwib25BYm9ydFwiPT09cj9zLm9uQWJvcnQmJnMub25BYm9ydChuLmFyZyk6ciYmeChcIndvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCBcIityKTtmZS5rYj12b2lkIDB9LGUub25lcnJvcj1lPT57dGhyb3cgeChcIndvcmtlciBzZW50IGFuIGVycm9yISBcIitlLmZpbGVuYW1lK1wiOlwiK2UubGluZW5vK1wiOiBcIitlLm1lc3NhZ2UpLGV9LF8mJihlLm9uKFwibWVzc2FnZVwiLChmdW5jdGlvbih0KXtlLm9ubWVzc2FnZSh7ZGF0YTp0fSl9KSksZS5vbihcImVycm9yXCIsKGZ1bmN0aW9uKHQpe2Uub25lcnJvcih0KX0pKSxlLm9uKFwiZGV0YWNoZWRFeGl0XCIsKGZ1bmN0aW9uKCl7fSkpKSxlLnBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkXCIsdXJsT3JCbG9iOnMubWFpblNjcmlwdFVybE9yQmxvYnx8X3NjcmlwdERpcix3YXNtTWVtb3J5OlAsd2FzbU1vZHVsZTprfSl9LGhiOmZ1bmN0aW9uKCl7dmFyIGU9VChcIm9ydC13YXNtLXRocmVhZGVkLndvcmtlci5qc1wiKTtmZS5PYS5wdXNoKG5ldyBXb3JrZXIoZSkpfSxsYjpmdW5jdGlvbigpe3JldHVybiAwPT1mZS5PYS5sZW5ndGgmJihmZS5oYigpLGZlLm5iKGZlLk9hWzBdKSksZmUuT2EucG9wKCl9fTtmdW5jdGlvbiBwZShlKXtmb3IoOzA8ZS5sZW5ndGg7KWUuc2hpZnQoKShzKX1mdW5jdGlvbiBkZShlKXtpZihPKXJldHVybiBIZSgyLDAsZSk7dHJ5e2xlKGUpfWNhdGNoKGUpe2UgaW5zdGFuY2VvZiBpZXx8XCJ1bndpbmRcIj09ZXx8digxLGUpfX1zLlBUaHJlYWQ9ZmUscy5lc3RhYmxpc2hTdGFja1NwYWNlPWZ1bmN0aW9uKCl7dmFyIGU9cnQoKSx0PWEoKVtlKzQ0Pj4yPj4+MF07ZT1hKClbZSs0OD4+Mj4+PjBdLGZ0KHQsdC1lKSxkdCh0KX07dmFyIG1lLGdlLGhlPVtdO2Z1bmN0aW9uIHllKGUpe3RoaXMuUGE9ZS0yNCx0aGlzLmdiPWZ1bmN0aW9uKGUpe28oKVt0aGlzLlBhKzQ+PjI+Pj4wXT1lfSx0aGlzLmNiPWZ1bmN0aW9uKGUpe28oKVt0aGlzLlBhKzg+PjI+Pj4wXT1lfSx0aGlzLmViPWZ1bmN0aW9uKCl7YSgpW3RoaXMuUGE+PjI+Pj4wXT0wfSx0aGlzLmJiPWZ1bmN0aW9uKCl7dCgpW3RoaXMuUGErMTI+PjA+Pj4wXT0wfSx0aGlzLmZiPWZ1bmN0aW9uKCl7dCgpW3RoaXMuUGErMTM+PjA+Pj4wXT0wfSx0aGlzLlVhPWZ1bmN0aW9uKGUsdCl7dGhpcy5hYigpLHRoaXMuZ2IoZSksdGhpcy5jYih0KSx0aGlzLmViKCksdGhpcy5iYigpLHRoaXMuZmIoKX0sdGhpcy5hYj1mdW5jdGlvbigpe28oKVt0aGlzLlBhKzE2Pj4yPj4+MF09MH19ZnVuY3Rpb24gdmUoZSx0LG4scil7cmV0dXJuIE8/SGUoMywxLGUsdCxuLHIpOmJlKGUsdCxuLHIpfWZ1bmN0aW9uIGJlKGUsdCxuLHIpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcilyZXR1cm4geChcIkN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBTaGFyZWRBcnJheUJ1ZmZlciwgcHRocmVhZHMgYXJlIG5vdCBhdmFpbGFibGUhXCIpLDY7dmFyIGE9W107cmV0dXJuIE8mJjA9PT1hLmxlbmd0aD92ZShlLHQsbixyKTooZT17cGI6bixLYTplLGliOnIsdmI6YX0sTz8oZS53Yj1cInNwYXduVGhyZWFkXCIscG9zdE1lc3NhZ2UoZSxhKSwwKTp1ZShlKSl9ZnVuY3Rpb24gd2UoZSx0LG4pe3JldHVybiBPP0hlKDQsMSxlLHQsbik6MH1mdW5jdGlvbiBfZShlLHQpe2lmKE8pcmV0dXJuIEhlKDUsMSxlLHQpfWZ1bmN0aW9uIE9lKGUsdCl7aWYoTylyZXR1cm4gSGUoNiwxLGUsdCl9ZnVuY3Rpb24gU2UoZSx0LG4pe2lmKE8pcmV0dXJuIEhlKDcsMSxlLHQsbil9ZnVuY3Rpb24gVGUoZSx0LG4pe3JldHVybiBPP0hlKDgsMSxlLHQsbik6MH1mdW5jdGlvbiBBZShlLHQpe2lmKE8pcmV0dXJuIEhlKDksMSxlLHQpfWZ1bmN0aW9uIEVlKGUsdCxuKXtpZihPKXJldHVybiBIZSgxMCwxLGUsdCxuKX1mdW5jdGlvbiBNZShlLHQsbixyKXtpZihPKXJldHVybiBIZSgxMSwxLGUsdCxuLHIpfWZ1bmN0aW9uIFJlKGUsdCxuLHIpe2lmKE8pcmV0dXJuIEhlKDEyLDEsZSx0LG4scil9ZnVuY3Rpb24geGUoZSx0LG4scil7aWYoTylyZXR1cm4gSGUoMTMsMSxlLHQsbixyKX1mdW5jdGlvbiBDZShlKXtpZihPKXJldHVybiBIZSgxNCwxLGUpfWZ1bmN0aW9uIFBlKGUsdCl7aWYoTylyZXR1cm4gSGUoMTUsMSxlLHQpfWZ1bmN0aW9uIGtlKGUsdCxuKXtpZihPKXJldHVybiBIZSgxNiwxLGUsdCxuKX1mdW5jdGlvbiBEZShlKXtBdG9taWNzLnN0b3JlKGEoKSxlPj4yLDEpLHJ0KCkmJnV0KGUpLEF0b21pY3MuY29tcGFyZUV4Y2hhbmdlKGEoKSxlPj4yLDEsMCl9ZnVuY3Rpb24gRmUoZSl7cmV0dXJuIG8oKVtlPj4+Ml0rNDI5NDk2NzI5NiphKClbZSs0Pj4+Ml19ZnVuY3Rpb24gVWUoZSx0LG4scixhLG8pe3JldHVybiBPP0hlKDE3LDEsZSx0LG4scixhLG8pOi01Mn1mdW5jdGlvbiBJZShlLHQsbixyLGEsbyl7aWYoTylyZXR1cm4gSGUoMTgsMSxlLHQsbixyLGEsbyl9ZnVuY3Rpb24gV2UoZSl7dmFyIG49TihlKSsxLHI9YXQobik7cmV0dXJuIHImJkIoZSx0KCkscixuKSxyfWZ1bmN0aW9uIGplKGUsdCxuKXtmdW5jdGlvbiByKGUpe3JldHVybihlPWUudG9UaW1lU3RyaW5nKCkubWF0Y2goL1xcXFwoKFtBLVphLXogXSspXFxcXCkkLykpP2VbMV06XCJHTVRcIn1pZihPKXJldHVybiBIZSgxOSwxLGUsdCxuKTt2YXIgaT0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCkscz1uZXcgRGF0ZShpLDAsMSksdT1uZXcgRGF0ZShpLDYsMSk7aT1zLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGM9dS5nZXRUaW1lem9uZU9mZnNldCgpLGw9TWF0aC5tYXgoaSxjKTthKClbZT4+Mj4+PjBdPTYwKmwsYSgpW3Q+PjI+Pj4wXT1OdW1iZXIoaSE9YyksZT1yKHMpLHQ9cih1KSxlPVdlKGUpLHQ9V2UodCksYzxpPyhvKClbbj4+Mj4+PjBdPWUsbygpW24rND4+Mj4+PjBdPXQpOihvKClbbj4+Mj4+PjBdPXQsbygpW24rND4+Mj4+PjBdPWUpfWZ1bmN0aW9uIEhlKGUsdCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aC0yLHI9YXJndW1lbnRzO3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD1wdCgpO3JldHVybiBlPWUoKSxkdCh0KSxlfSgoKCk9Pntmb3IodmFyIGE9bXQoOCpuKSxvPWE+PjMscz0wO3M8bjtzKyspe3ZhciB1PXJbMitzXTtpKClbbytzPj4+MF09dX1yZXR1cm4gc3QoZSxuLGEsdCl9KSl9cy5pbnZva2VFbnRyeVBvaW50PWZ1bmN0aW9uKGUsdCl7dmFyIG49aGVbZV07bnx8KGU+PWhlLmxlbmd0aCYmKGhlLmxlbmd0aD1lKzEpLGhlW2VdPW49JC5nZXQoZSkpLGU9bih0KSxDP2ZlLllhKGUpOmx0KGUpfSxzLmV4ZWN1dGVOb3RpZmllZFByb3h5aW5nUXVldWU9RGUsZ2U9Xz8oKT0+e3ZhciBlPXByb2Nlc3MuaHJ0aW1lKCk7cmV0dXJuIDFlMyplWzBdK2VbMV0vMWU2fTpPPygpPT5wZXJmb3JtYW5jZS5ub3coKS1zLl9fcGVyZm9ybWFuY2Vfbm93X2Nsb2NrX2RyaWZ0OigpPT5wZXJmb3JtYW5jZS5ub3coKTt2YXIgTGUsWWU9W10semU9e307ZnVuY3Rpb24gQmUoKXtpZighTGUpe3ZhciBlLHQ9e1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KFwib2JqZWN0XCI9PXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86eXx8XCIuL3RoaXMucHJvZ3JhbVwifTtmb3IoZSBpbiB6ZSl2b2lkIDA9PT16ZVtlXT9kZWxldGUgdFtlXTp0W2VdPXplW2VdO3ZhciBuPVtdO2ZvcihlIGluIHQpbi5wdXNoKGUrXCI9XCIrdFtlXSk7TGU9bn1yZXR1cm4gTGV9ZnVuY3Rpb24gTmUoZSxuKXtpZihPKXJldHVybiBIZSgyMCwxLGUsbik7dmFyIHI9MDtyZXR1cm4gQmUoKS5mb3JFYWNoKChmdW5jdGlvbihhLGkpe3ZhciBzPW4rcjtmb3IoaT1vKClbZSs0Kmk+PjI+Pj4wXT1zLHM9MDtzPGEubGVuZ3RoOysrcyl0KClbaSsrPj4wPj4+MF09YS5jaGFyQ29kZUF0KHMpO3QoKVtpPj4wPj4+MF09MCxyKz1hLmxlbmd0aCsxfSkpLDB9ZnVuY3Rpb24gR2UoZSx0KXtpZihPKXJldHVybiBIZSgyMSwxLGUsdCk7dmFyIG49QmUoKTtvKClbZT4+Mj4+PjBdPW4ubGVuZ3RoO3ZhciByPTA7cmV0dXJuIG4uZm9yRWFjaCgoZnVuY3Rpb24oZSl7cis9ZS5sZW5ndGgrMX0pKSxvKClbdD4+Mj4+PjBdPXIsMH1mdW5jdGlvbiBxZShlKXtyZXR1cm4gTz9IZSgyMiwxLGUpOjUyfWZ1bmN0aW9uICRlKGUsdCxuLHIpe3JldHVybiBPP0hlKDIzLDEsZSx0LG4scik6NTJ9ZnVuY3Rpb24gVmUoZSx0LG4scixhKXtyZXR1cm4gTz9IZSgyNCwxLGUsdCxuLHIsYSk6NzB9dmFyIEplPVtudWxsLFtdLFtdXTtmdW5jdGlvbiBRZShlLHQsbixhKXtpZihPKXJldHVybiBIZSgyNSwxLGUsdCxuLGEpO2Zvcih2YXIgaT0wLHM9MDtzPG47cysrKXt2YXIgdT1vKClbdD4+Mj4+PjBdLGM9bygpW3QrND4+Mj4+PjBdO3QrPTg7Zm9yKHZhciBsPTA7bDxjO2wrKyl7dmFyIGY9cigpW3UrbD4+PjBdLHA9SmVbZV07MD09PWZ8fDEwPT09Zj8oKDE9PT1lP1I6eCkoWShwLDApKSxwLmxlbmd0aD0wKTpwLnB1c2goZil9aSs9Y31yZXR1cm4gbygpW2E+PjI+Pj4wXT1pLDB9ZnVuY3Rpb24gWGUoZSl7cmV0dXJuIDA9PWUlNCYmKDAhPWUlMTAwfHwwPT1lJTQwMCl9dmFyIEtlPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sWmU9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBldChlLG4scixvKXtmdW5jdGlvbiBpKGUsdCxuKXtmb3IoZT1cIm51bWJlclwiPT10eXBlb2YgZT9lLnRvU3RyaW5nKCk6ZXx8XCJcIjtlLmxlbmd0aDx0OyllPW5bMF0rZTtyZXR1cm4gZX1mdW5jdGlvbiBzKGUsdCl7cmV0dXJuIGkoZSx0LFwiMFwiKX1mdW5jdGlvbiB1KGUsdCl7ZnVuY3Rpb24gbihlKXtyZXR1cm4gMD5lPy0xOjA8ZT8xOjB9dmFyIHI7cmV0dXJuIDA9PT0ocj1uKGUuZ2V0RnVsbFllYXIoKS10LmdldEZ1bGxZZWFyKCkpKSYmMD09PShyPW4oZS5nZXRNb250aCgpLXQuZ2V0TW9udGgoKSkpJiYocj1uKGUuZ2V0RGF0ZSgpLXQuZ2V0RGF0ZSgpKSkscn1mdW5jdGlvbiBjKGUpe3N3aXRjaChlLmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIGU7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIGwoZSl7dmFyIHQ9ZS5NYTtmb3IoZT1uZXcgRGF0ZShuZXcgRGF0ZShlLk5hKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8dDspe3ZhciBuPWUuZ2V0TW9udGgoKSxyPShYZShlLmdldEZ1bGxZZWFyKCkpP0tlOlplKVtuXTtpZighKHQ+ci1lLmdldERhdGUoKSkpe2Uuc2V0RGF0ZShlLmdldERhdGUoKSt0KTticmVha310LT1yLWUuZ2V0RGF0ZSgpKzEsZS5zZXREYXRlKDEpLDExPm4/ZS5zZXRNb250aChuKzEpOihlLnNldE1vbnRoKDApLGUuc2V0RnVsbFllYXIoZS5nZXRGdWxsWWVhcigpKzEpKX1yZXR1cm4gbj1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCkrMSwwLDQpLHQ9YyhuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCw0KSksbj1jKG4pLDA+PXUodCxlKT8wPj11KG4sZSk/ZS5nZXRGdWxsWWVhcigpKzE6ZS5nZXRGdWxsWWVhcigpOmUuZ2V0RnVsbFllYXIoKS0xfXZhciBmPWEoKVtvKzQwPj4yPj4+MF07Zm9yKHZhciBwIGluIG89e3RiOmEoKVtvPj4yPj4+MF0sc2I6YSgpW28rND4+Mj4+PjBdLFNhOmEoKVtvKzg+PjI+Pj4wXSxWYTphKClbbysxMj4+Mj4+PjBdLFRhOmEoKVtvKzE2Pj4yPj4+MF0sTmE6YSgpW28rMjA+PjI+Pj4wXSxKYTphKClbbysyND4+Mj4+PjBdLE1hOmEoKVtvKzI4Pj4yPj4+MF0semI6YSgpW28rMzI+PjI+Pj4wXSxyYjphKClbbyszNj4+Mj4+PjBdLHViOmY/eihmKTpcIlwifSxyPXoociksZj17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9KXI9ci5yZXBsYWNlKG5ldyBSZWdFeHAocCxcImdcIiksZltwXSk7dmFyIGQ9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxtPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtmb3IocCBpbiBmPXtcIiVhXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGRbZS5KYV0uc3Vic3RyaW5nKDAsMyl9LFwiJUFcIjpmdW5jdGlvbihlKXtyZXR1cm4gZFtlLkphXX0sXCIlYlwiOmZ1bmN0aW9uKGUpe3JldHVybiBtW2UuVGFdLnN1YnN0cmluZygwLDMpfSxcIiVCXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIG1bZS5UYV19LFwiJUNcIjpmdW5jdGlvbihlKXtyZXR1cm4gcygoZS5OYSsxOTAwKS8xMDB8MCwyKX0sXCIlZFwiOmZ1bmN0aW9uKGUpe3JldHVybiBzKGUuVmEsMil9LFwiJWVcIjpmdW5jdGlvbihlKXtyZXR1cm4gaShlLlZhLDIsXCIgXCIpfSxcIiVnXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGwoZSkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJUdcIjpmdW5jdGlvbihlKXtyZXR1cm4gbChlKX0sXCIlSFwiOmZ1bmN0aW9uKGUpe3JldHVybiBzKGUuU2EsMil9LFwiJUlcIjpmdW5jdGlvbihlKXtyZXR1cm4gMD09KGU9ZS5TYSk/ZT0xMjoxMjxlJiYoZS09MTIpLHMoZSwyKX0sXCIlalwiOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wLG49MDtuPD1lLlRhLTE7dCs9KFhlKGUuTmErMTkwMCk/S2U6WmUpW24rK10pO3JldHVybiBzKGUuVmErdCwzKX0sXCIlbVwiOmZ1bmN0aW9uKGUpe3JldHVybiBzKGUuVGErMSwyKX0sXCIlTVwiOmZ1bmN0aW9uKGUpe3JldHVybiBzKGUuc2IsMil9LFwiJW5cIjpmdW5jdGlvbigpe3JldHVyblwiXFxcXG5cIn0sXCIlcFwiOmZ1bmN0aW9uKGUpe3JldHVybiAwPD1lLlNhJiYxMj5lLlNhP1wiQU1cIjpcIlBNXCJ9LFwiJVNcIjpmdW5jdGlvbihlKXtyZXR1cm4gcyhlLnRiLDIpfSxcIiV0XCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcXFx0XCJ9LFwiJXVcIjpmdW5jdGlvbihlKXtyZXR1cm4gZS5KYXx8N30sXCIlVVwiOmZ1bmN0aW9uKGUpe3JldHVybiBzKE1hdGguZmxvb3IoKGUuTWErNy1lLkphKS83KSwyKX0sXCIlVlwiOmZ1bmN0aW9uKGUpe3ZhciB0PU1hdGguZmxvb3IoKGUuTWErNy0oZS5KYSs2KSU3KS83KTtpZigyPj0oZS5KYSszNzEtZS5NYS0yKSU3JiZ0KyssdCk1Mz09dCYmKDQ9PShuPShlLkphKzM3MS1lLk1hKSU3KXx8Mz09biYmWGUoZS5OYSl8fCh0PTEpKTtlbHNle3Q9NTI7dmFyIG49KGUuSmErNy1lLk1hLTEpJTc7KDQ9PW58fDU9PW4mJlhlKGUuTmElNDAwLTEpKSYmdCsrfXJldHVybiBzKHQsMil9LFwiJXdcIjpmdW5jdGlvbihlKXtyZXR1cm4gZS5KYX0sXCIlV1wiOmZ1bmN0aW9uKGUpe3JldHVybiBzKE1hdGguZmxvb3IoKGUuTWErNy0oZS5KYSs2KSU3KS83KSwyKX0sXCIleVwiOmZ1bmN0aW9uKGUpe3JldHVybihlLk5hKzE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVZXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuTmErMTkwMH0sXCIlelwiOmZ1bmN0aW9uKGUpe3ZhciB0PTA8PShlPWUucmIpO3JldHVybiBlPU1hdGguYWJzKGUpLzYwLCh0P1wiK1wiOlwiLVwiKStTdHJpbmcoXCIwMDAwXCIrKGUvNjAqMTAwK2UlNjApKS5zbGljZSgtNCl9LFwiJVpcIjpmdW5jdGlvbihlKXtyZXR1cm4gZS51Yn0sXCIlJVwiOmZ1bmN0aW9uKCl7cmV0dXJuXCIlXCJ9fSxyPXIucmVwbGFjZSgvJSUvZyxcIlxcXFwwXFxcXDBcIiksZilyLmluY2x1ZGVzKHApJiYocj1yLnJlcGxhY2UobmV3IFJlZ0V4cChwLFwiZ1wiKSxmW3BdKG8pKSk7cmV0dXJuIHA9ZnVuY3Rpb24oZSl7dmFyIHQ9QXJyYXkoTihlKSsxKTtyZXR1cm4gQihlLHQsMCx0Lmxlbmd0aCksdH0ocj1yLnJlcGxhY2UoL1xcXFwwXFxcXDAvZyxcIiVcIikpLHAubGVuZ3RoPm4/MDooZnVuY3Rpb24oZSxuKXt0KCkuc2V0KGUsbj4+PjApfShwLGUpLHAubGVuZ3RoLTEpfWZlLlVhKCk7dmFyIHR0PVtudWxsLGNlLGRlLHZlLHdlLF9lLE9lLFNlLFRlLEFlLEVlLE1lLFJlLHhlLENlLFBlLGtlLFVlLEllLGplLE5lLEdlLHFlLCRlLFZlLFFlXSxudD17YjpmdW5jdGlvbihlKXtyZXR1cm4gYXQoZSsyNCkrMjR9LGM6ZnVuY3Rpb24oZSx0LG4pe3Rocm93IG5ldyB5ZShlKS5VYSh0LG4pLGV9LEw6ZnVuY3Rpb24oZSl7b3QoZSwhdywxLCFiKSxmZS5aYSgpfSxsOmZ1bmN0aW9uKGUpe08/cG9zdE1lc3NhZ2Uoe2NtZDpcImNsZWFudXBUaHJlYWRcIix0aHJlYWQ6ZX0pOnNlKGUpfSxEOmJlLGk6d2UsUjpfZSx6Ok9lLEI6U2UsVDpUZSxQOkFlLEk6RWUsTzpNZSxwOlJlLEE6eGUseDpDZSxROlBlLHk6a2UscjpmdW5jdGlvbigpe30sajpmdW5jdGlvbigpe25lKFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LHM6ZnVuY3Rpb24oKXtuZShcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxxOmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9LEU6ZnVuY3Rpb24oKXtyZXR1cm4gMjA5NzE1Mn0sVjpmdW5jdGlvbigpe3JldHVybiEwfSxGOmZ1bmN0aW9uKGUsdCxuLHIpe2lmKGU9PXQpc2V0VGltZW91dCgoKCk9PkRlKHIpKSk7ZWxzZSBpZihPKXBvc3RNZXNzYWdlKHt0YXJnZXRUaHJlYWQ6ZSxjbWQ6XCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiLHF1ZXVlOnJ9KTtlbHNle2lmKCEoZT1mZS5MYVtlXSkpcmV0dXJuO2UucG9zdE1lc3NhZ2Uoe2NtZDpcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCIscXVldWU6cn0pfXJldHVybiAxfSxLOmZ1bmN0aW9uKCl7cmV0dXJuLTF9LFc6ZnVuY3Rpb24oZSx0KXtlPW5ldyBEYXRlKDFlMypGZShlKSksYSgpW3Q+PjI+Pj4wXT1lLmdldFVUQ1NlY29uZHMoKSxhKClbdCs0Pj4yPj4+MF09ZS5nZXRVVENNaW51dGVzKCksYSgpW3QrOD4+Mj4+PjBdPWUuZ2V0VVRDSG91cnMoKSxhKClbdCsxMj4+Mj4+PjBdPWUuZ2V0VVRDRGF0ZSgpLGEoKVt0KzE2Pj4yPj4+MF09ZS5nZXRVVENNb250aCgpLGEoKVt0KzIwPj4yPj4+MF09ZS5nZXRVVENGdWxsWWVhcigpLTE5MDAsYSgpW3QrMjQ+PjI+Pj4wXT1lLmdldFVUQ0RheSgpLGU9KGUuZ2V0VGltZSgpLURhdGUuVVRDKGUuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDAsYSgpW3QrMjg+PjI+Pj4wXT1lfSxYOmZ1bmN0aW9uKGUsdCl7ZT1uZXcgRGF0ZSgxZTMqRmUoZSkpLGEoKVt0Pj4yPj4+MF09ZS5nZXRTZWNvbmRzKCksYSgpW3QrND4+Mj4+PjBdPWUuZ2V0TWludXRlcygpLGEoKVt0Kzg+PjI+Pj4wXT1lLmdldEhvdXJzKCksYSgpW3QrMTI+PjI+Pj4wXT1lLmdldERhdGUoKSxhKClbdCsxNj4+Mj4+PjBdPWUuZ2V0TW9udGgoKSxhKClbdCsyMD4+Mj4+PjBdPWUuZ2V0RnVsbFllYXIoKS0xOTAwLGEoKVt0KzI0Pj4yPj4+MF09ZS5nZXREYXkoKTt2YXIgbj1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwxKSxyPShlLmdldFRpbWUoKS1uLmdldFRpbWUoKSkvODY0ZTV8MDthKClbdCsyOD4+Mj4+PjBdPXIsYSgpW3QrMzY+PjI+Pj4wXT0tNjAqZS5nZXRUaW1lem9uZU9mZnNldCgpLHI9bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxlPTB8KHIhPShuPW4uZ2V0VGltZXpvbmVPZmZzZXQoKSkmJmUuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4obixyKSksYSgpW3QrMzI+PjI+Pj4wXT1lfSxZOmZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBEYXRlKGEoKVtlKzIwPj4yPj4+MF0rMTkwMCxhKClbZSsxNj4+Mj4+PjBdLGEoKVtlKzEyPj4yPj4+MF0sYSgpW2UrOD4+Mj4+PjBdLGEoKVtlKzQ+PjI+Pj4wXSxhKClbZT4+Mj4+PjBdLDApLG49YSgpW2UrMzI+PjI+Pj4wXSxyPXQuZ2V0VGltZXpvbmVPZmZzZXQoKSxvPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDEpLGk9bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxzPW8uZ2V0VGltZXpvbmVPZmZzZXQoKSx1PU1hdGgubWluKHMsaSk7cmV0dXJuIDA+bj9hKClbZSszMj4+Mj4+PjBdPU51bWJlcihpIT1zJiZ1PT1yKTowPG4hPSh1PT1yKSYmKGk9TWF0aC5tYXgocyxpKSx0LnNldFRpbWUodC5nZXRUaW1lKCkrNmU0KigoMDxuP3U6aSktcikpKSxhKClbZSsyND4+Mj4+PjBdPXQuZ2V0RGF5KCksbj0odC5nZXRUaW1lKCktby5nZXRUaW1lKCkpLzg2NGU1fDAsYSgpW2UrMjg+PjI+Pj4wXT1uLGEoKVtlPj4yPj4+MF09dC5nZXRTZWNvbmRzKCksYSgpW2UrND4+Mj4+PjBdPXQuZ2V0TWludXRlcygpLGEoKVtlKzg+PjI+Pj4wXT10LmdldEhvdXJzKCksYSgpW2UrMTI+PjI+Pj4wXT10LmdldERhdGUoKSxhKClbZSsxNj4+Mj4+PjBdPXQuZ2V0TW9udGgoKSx0LmdldFRpbWUoKS8xZTN8MH0sRzpVZSxIOkllLFo6ZnVuY3Rpb24gZSh0LG4scil7ZS5qYnx8KGUuamI9ITAsamUodCxuLHIpKX0sZDpmdW5jdGlvbigpe25lKFwiXCIpfSxtOmZ1bmN0aW9uKCl7aWYoIV8mJiF3KXt2YXIgZT1cIkJsb2NraW5nIG9uIHRoZSBtYWluIHRocmVhZCBpcyB2ZXJ5IGRhbmdlcm91cywgc2VlIGh0dHBzOi8vZW1zY3JpcHRlbi5vcmcvZG9jcy9wb3J0aW5nL3B0aHJlYWRzLmh0bWwjYmxvY2tpbmctb24tdGhlLW1haW4tYnJvd3Nlci10aHJlYWRcIjttZXx8KG1lPXt9KSxtZVtlXXx8KG1lW2VdPTEsXyYmKGU9XCJ3YXJuaW5nOiBcIitlKSx4KGUpKX19LHc6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sZjpnZSxTOmZ1bmN0aW9uKGUsdCxuKXtyKCkuY29weVdpdGhpbihlPj4+MCx0Pj4+MCx0K24+Pj4wKX0sZzpmdW5jdGlvbigpe3JldHVybiBfP24oOTkzKS5jcHVzKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5fSxKOmZ1bmN0aW9uKGUsdCxuKXtZZS5sZW5ndGg9dCxuPj49Mztmb3IodmFyIHI9MDtyPHQ7cisrKVllW3JdPWkoKVtuK3I+Pj4wXTtyZXR1cm4oMD5lP29lWy1lLTFdOnR0W2VdKS5hcHBseShudWxsLFllKX0sdjpmdW5jdGlvbihlKXt2YXIgdD1yKCkubGVuZ3RoO2lmKChlPj4+PTApPD10fHw0Mjk0OTAxNzYwPGUpcmV0dXJuITE7Zm9yKHZhciBuPTE7ND49bjtuKj0yKXt2YXIgYT10KigxKy4yL24pO2E9TWF0aC5taW4oYSxlKzEwMDY2MzI5Nik7dmFyIG89TWF0aDthPU1hdGgubWF4KGUsYSksbz1vLm1pbi5jYWxsKG8sNDI5NDkwMTc2MCxhKyg2NTUzNi1hJTY1NTM2KSU2NTUzNik7ZTp7dHJ5e1AuZ3JvdyhvLUQuYnl0ZUxlbmd0aCs2NTUzNT4+PjE2KSxHKFAuYnVmZmVyKTt2YXIgaT0xO2JyZWFrIGV9Y2F0Y2goZSl7fWk9dm9pZCAwfWlmKGkpcmV0dXJuITB9cmV0dXJuITF9LFU6ZnVuY3Rpb24oKXt0aHJvd1widW53aW5kXCJ9LE06TmUsTjpHZSxrOmxlLGg6cWUsbzokZSx0OlZlLG46UWUsdTpmdW5jdGlvbiBlKHIsYSl7ZS5XYXx8KGUuV2E9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgZT1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+KGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoZSksZVswXSl9aWYoXyl0cnl7dmFyIHQ9big3NjApO3JldHVybigpPT50LnJhbmRvbUJ5dGVzKDEpWzBdfWNhdGNoKGUpe31yZXR1cm4oKT0+bmUoXCJyYW5kb21EZXZpY2VcIil9KCkpO2Zvcih2YXIgbz0wO288YTtvKyspdCgpW3Irbz4+MD4+PjBdPWUuV2EoKTtyZXR1cm4gMH0sYTpQfHxzLndhc21NZW1vcnksQzpldCxlOmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBldChlLHQsbixyKX19OyFmdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtzLmFzbT1lLmV4cG9ydHMsZmUuJGEucHVzaChzLmFzbS53YSksJD1zLmFzbS56YSxKLnVuc2hpZnQocy5hc20uXyksaz10LE98fChaLS0scy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZzLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoWiksMD09WiYmKG51bGwhPT1lZSYmKGNsZWFySW50ZXJ2YWwoZWUpLGVlPW51bGwpLHRlJiYoZT10ZSx0ZT1udWxsLGUoKSkpKX1mdW5jdGlvbiB0KHQpe2UodC5pbnN0YW5jZSx0Lm1vZHVsZSl9ZnVuY3Rpb24gbihlKXtyZXR1cm4gZnVuY3Rpb24oKXtpZighTSYmKGJ8fHcpKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBmZXRjaCYmIUsuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpcmV0dXJuIGZldGNoKEsse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKGUpe2lmKCFlLm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0IFxcJ1wiK0srXCJcXCdcIjtyZXR1cm4gZS5hcnJheUJ1ZmZlcigpfSkpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBhZSgpfSkpO2lmKGYpcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihlLHQpe2YoSywoZnVuY3Rpb24odCl7ZShuZXcgVWludDhBcnJheSh0KSl9KSx0KX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gYWUoKX0pKX0oKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoZSxyKX0pKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gZX0pKS50aGVuKGUsKGZ1bmN0aW9uKGUpe3goXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIitlKSxuZShlKX0pKX12YXIgcj17YTpudH07aWYoT3x8KForKyxzLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJnMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhaKSkscy5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBzLmluc3RhbnRpYXRlV2FzbShyLGUpfWNhdGNoKGUpe3JldHVybiB4KFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrZSksITF9KE18fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxyZSgpfHxLLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpfHxffHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBmZXRjaD9uKHQpOmZldGNoKEsse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhlLHIpLnRoZW4odCwoZnVuY3Rpb24oZSl7cmV0dXJuIHgoXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIrZSkseChcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLG4odCl9KSl9KSkpLmNhdGNoKGMpfSgpLHMuX19fd2FzbV9jYWxsX2N0b3JzPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19fd2FzbV9jYWxsX2N0b3JzPXMuYXNtLl8pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0SW5pdD1mdW5jdGlvbigpe3JldHVybihzLl9PcnRJbml0PXMuYXNtLiQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9cy5hc20uYWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9cy5hc20uYmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1zLmFzbS5jYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPXMuYXNtLmRhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydENyZWF0ZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0Q3JlYXRlU2Vzc2lvbj1zLmFzbS5lYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRSZWxlYXNlU2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybihzLl9PcnRSZWxlYXNlU2Vzc2lvbj1zLmFzbS5mYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRHZXRJbnB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEdldElucHV0Q291bnQ9cy5hc20uZ2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0T3V0cHV0Q291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0R2V0T3V0cHV0Q291bnQ9cy5hc20uaGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0SW5wdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEdldElucHV0TmFtZT1zLmFzbS5pYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRHZXRPdXRwdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEdldE91dHB1dE5hbWU9cy5hc20uamEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0RnJlZT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRGcmVlPXMuYXNtLmthKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydENyZWF0ZVRlbnNvcj1mdW5jdGlvbigpe3JldHVybihzLl9PcnRDcmVhdGVUZW5zb3I9cy5hc20ubGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0VGVuc29yRGF0YT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRUZW5zb3JEYXRhPXMuYXNtLm1hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydFJlbGVhc2VUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0UmVsZWFzZVRlbnNvcj1zLmFzbS5uYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRDcmVhdGVSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydENyZWF0ZVJ1bk9wdGlvbnM9cy5hc20ub2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0QWRkUnVuQ29uZmlnRW50cnk9cy5hc20ucGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9cy5hc20ucWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0UnVuPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJ1bj1zLmFzbS5yYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRFbmRQcm9maWxpbmc9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0RW5kUHJvZmlsaW5nPXMuYXNtLnNhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBydD1zLl9wdGhyZWFkX3NlbGY9ZnVuY3Rpb24oKXtyZXR1cm4ocnQ9cy5fcHRocmVhZF9zZWxmPXMuYXNtLnRhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGF0PXMuX21hbGxvYz1mdW5jdGlvbigpe3JldHVybihhdD1zLl9tYWxsb2M9cy5hc20udWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07cy5fZnJlZT1mdW5jdGlvbigpe3JldHVybihzLl9mcmVlPXMuYXNtLnZhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX19lbXNjcmlwdGVuX3Rsc19pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19lbXNjcmlwdGVuX3Rsc19pbml0PXMuYXNtLndhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBvdD1zLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD1mdW5jdGlvbigpe3JldHVybihvdD1zLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD1zLmFzbS54YSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtzLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZD1mdW5jdGlvbigpe3JldHVybihzLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZD1zLmFzbS55YSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgaXQsc3Q9cy5fZW1zY3JpcHRlbl9ydW5faW5fbWFpbl9ydW50aW1lX3RocmVhZF9qcz1mdW5jdGlvbigpe3JldHVybihzdD1zLl9lbXNjcmlwdGVuX3J1bl9pbl9tYWluX3J1bnRpbWVfdGhyZWFkX2pzPXMuYXNtLkFhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHV0PXMuX19lbXNjcmlwdGVuX3Byb3h5X2V4ZWN1dGVfdGFza19xdWV1ZT1mdW5jdGlvbigpe3JldHVybih1dD1zLl9fZW1zY3JpcHRlbl9wcm94eV9leGVjdXRlX3Rhc2tfcXVldWU9cy5hc20uQmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sY3Q9cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2ZyZWVfZGF0YT1mdW5jdGlvbigpe3JldHVybihjdD1zLl9fZW1zY3JpcHRlbl90aHJlYWRfZnJlZV9kYXRhPXMuYXNtLkNhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGx0PXMuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0PWZ1bmN0aW9uKCl7cmV0dXJuKGx0PXMuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0PXMuYXNtLkRhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGZ0PXMuX2Vtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0cz1mdW5jdGlvbigpe3JldHVybihmdD1zLl9lbXNjcmlwdGVuX3N0YWNrX3NldF9saW1pdHM9cy5hc20uRWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scHQ9cy5zdGFja1NhdmU9ZnVuY3Rpb24oKXtyZXR1cm4ocHQ9cy5zdGFja1NhdmU9cy5hc20uRmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZHQ9cy5zdGFja1Jlc3RvcmU9ZnVuY3Rpb24oKXtyZXR1cm4oZHQ9cy5zdGFja1Jlc3RvcmU9cy5hc20uR2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbXQ9cy5zdGFja0FsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKG10PXMuc3RhY2tBbGxvYz1zLmFzbS5IYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiBndCgpe2Z1bmN0aW9uIGUoKXtpZighaXQmJihpdD0hMCxzLmNhbGxlZFJ1bj0hMCwhSCkmJihPfHxwZShKKSx1KHMpLHMub25SdW50aW1lSW5pdGlhbGl6ZWQmJnMub25SdW50aW1lSW5pdGlhbGl6ZWQoKSwhTykpe2lmKHMucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2Ygcy5wb3N0UnVuJiYocy5wb3N0UnVuPVtzLnBvc3RSdW5dKTtzLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIGU9cy5wb3N0UnVuLnNoaWZ0KCk7US51bnNoaWZ0KGUpfXBlKFEpfX1pZighKDA8WikpaWYoTyl1KHMpLE98fHBlKEopLHBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkZWRcIn0pO2Vsc2V7aWYocy5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHMucHJlUnVuJiYocy5wcmVSdW49W3MucHJlUnVuXSk7cy5wcmVSdW4ubGVuZ3RoOylYKCk7cGUoViksMDxafHwocy5zZXRTdGF0dXM/KHMuc2V0U3RhdHVzKFwiUnVubmluZy4uLlwiKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7cy5zZXRTdGF0dXMoXCJcIil9KSwxKSxlKCl9KSwxKSk6ZSgpKX19aWYocy5fX19jeGFfaXNfcG9pbnRlcl90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1zLmFzbS5JYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLlVURjhUb1N0cmluZz16LHMuc3RyaW5nVG9VVEY4PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gQihlLHIoKSx0LG4pfSxzLmxlbmd0aEJ5dGVzVVRGOD1OLHMua2VlcFJ1bnRpbWVBbGl2ZT1mdW5jdGlvbigpe3JldHVybiBDfSxzLndhc21NZW1vcnk9UCxzLnN0YWNrU2F2ZT1wdCxzLnN0YWNrUmVzdG9yZT1kdCxzLnN0YWNrQWxsb2M9bXQscy5FeGl0U3RhdHVzPWllLHMuUFRocmVhZD1mZSx0ZT1mdW5jdGlvbiBlKCl7aXR8fGd0KCksaXR8fCh0ZT1lKX0scy5wcmVJbml0KWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBzLnByZUluaXQmJihzLnByZUluaXQ9W3MucHJlSW5pdF0pOzA8cy5wcmVJbml0Lmxlbmd0aDspcy5wcmVJbml0LnBvcCgpKCk7cmV0dXJuIGd0KCksZS5yZWFkeX0pO2UuZXhwb3J0cz1yfSw5MzI6KGUsdCxuKT0+e3ZhciBfc2NyaXB0RGlyLHI9KF9zY3JpcHREaXI9KF9zY3JpcHREaXI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMCl8fFwiL2luZGV4LmpzXCIsZnVuY3Rpb24oZSl7dmFyIHQscixhO2U9ZXx8e30sdHx8KHQ9dm9pZCAwIT09ZT9lOnt9KSx0LnJlYWR5PW5ldyBQcm9taXNlKChmdW5jdGlvbihlLHQpe3I9ZSxhPXR9KSk7dmFyIG8saSxzLHUsYyxsLGY9T2JqZWN0LmFzc2lnbih7fSx0KSxwPVwiLi90aGlzLnByb2dyYW1cIixkPShlLHQpPT57dGhyb3cgdH0sbT1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93LGc9XCJmdW5jdGlvblwiPT10eXBlb2YgaW1wb3J0U2NyaXB0cyxoPVwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzJiZcIm9iamVjdFwiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyYmXCJzdHJpbmdcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSx5PVwiXCI7aD8oeT1nP24oOTA4KS5kaXJuYW1lKHkpK1wiL1wiOlwiLy9cIixsPSgpPT57Y3x8KHU9bigzODQpLGM9big5MDgpKX0sbz1mdW5jdGlvbihlLHQpe3JldHVybiBsKCksZT1jLm5vcm1hbGl6ZShlKSx1LnJlYWRGaWxlU3luYyhlLHQ/dm9pZCAwOlwidXRmOFwiKX0scz1lPT4oKGU9byhlLCEwKSkuYnVmZmVyfHwoZT1uZXcgVWludDhBcnJheShlKSksZSksaT0oZSx0LG4pPT57bCgpLGU9Yy5ub3JtYWxpemUoZSksdS5yZWFkRmlsZShlLChmdW5jdGlvbihlLHIpe2U/bihlKTp0KHIuYnVmZmVyKX0pKX0sMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYocD1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXFxcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSxwcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIiwoZnVuY3Rpb24oZSl7aWYoIShlIGluc3RhbmNlb2YgJCkpdGhyb3cgZX0pKSxwcm9jZXNzLm9uKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsKGZ1bmN0aW9uKGUpe3Rocm93IGV9KSksZD0oZSx0KT0+e2lmKF8pdGhyb3cgcHJvY2Vzcy5leGl0Q29kZT1lLHQ7dCBpbnN0YW5jZW9mICR8fHcoXCJleGl0aW5nIGR1ZSB0byBleGNlcHRpb246IFwiK3QpLHByb2Nlc3MuZXhpdChlKX0sdC5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifSk6KG18fGcpJiYoZz95PXNlbGYubG9jYXRpb24uaHJlZjpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJih5PWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxfc2NyaXB0RGlyJiYoeT1fc2NyaXB0RGlyKSx5PTAhPT15LmluZGV4T2YoXCJibG9iOlwiKT95LnN1YnN0cigwLHkucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIixvPWU9Pnt2YXIgdD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHQub3BlbihcIkdFVFwiLGUsITEpLHQuc2VuZChudWxsKSx0LnJlc3BvbnNlVGV4dH0sZyYmKHM9ZT0+e3ZhciB0PW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gdC5vcGVuKFwiR0VUXCIsZSwhMSksdC5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLHQuc2VuZChudWxsKSxuZXcgVWludDhBcnJheSh0LnJlc3BvbnNlKX0pLGk9KGUsdCxuKT0+e3ZhciByPW5ldyBYTUxIdHRwUmVxdWVzdDtyLm9wZW4oXCJHRVRcIixlLCEwKSxyLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsci5vbmxvYWQ9KCk9PnsyMDA9PXIuc3RhdHVzfHwwPT1yLnN0YXR1cyYmci5yZXNwb25zZT90KHIucmVzcG9uc2UpOm4oKX0sci5vbmVycm9yPW4sci5zZW5kKG51bGwpfSk7dmFyIHYsYj10LnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLHc9dC5wcmludEVycnx8Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbih0LGYpLGY9bnVsbCx0LnRoaXNQcm9ncmFtJiYocD10LnRoaXNQcm9ncmFtKSx0LnF1aXQmJihkPXQucXVpdCksdC53YXNtQmluYXJ5JiYodj10Lndhc21CaW5hcnkpO3ZhciBfPXQubm9FeGl0UnVudGltZXx8ITA7XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZCKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgTyxTLFQsQSxFLE0sUj0hMSx4PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMDtmdW5jdGlvbiBDKGUsdCxuKXt2YXIgcj0odD4+Pj0wKStuO2ZvcihuPXQ7ZVtuXSYmIShuPj1yKTspKytuO2lmKDE2PG4tdCYmZS5idWZmZXImJngpcmV0dXJuIHguZGVjb2RlKGUuc3ViYXJyYXkodCxuKSk7Zm9yKHI9XCJcIjt0PG47KXt2YXIgYT1lW3QrK107aWYoMTI4JmEpe3ZhciBvPTYzJmVbdCsrXTtpZigxOTI9PSgyMjQmYSkpcis9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmYSk8PDZ8byk7ZWxzZXt2YXIgaT02MyZlW3QrK107NjU1MzY+KGE9MjI0PT0oMjQwJmEpPygxNSZhKTw8MTJ8bzw8NnxpOig3JmEpPDwxOHxvPDwxMnxpPDw2fDYzJmVbdCsrXSk/cis9U3RyaW5nLmZyb21DaGFyQ29kZShhKTooYS09NjU1MzYscis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxhPj4xMCw1NjMyMHwxMDIzJmEpKX19ZWxzZSByKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpfXJldHVybiByfWZ1bmN0aW9uIFAoZSx0KXtyZXR1cm4oZT4+Pj0wKT9DKEEsZSx0KTpcIlwifWZ1bmN0aW9uIGsoZSx0LG4scil7aWYoISgwPHIpKXJldHVybiAwO3ZhciBhPW4+Pj49MDtyPW4rci0xO2Zvcih2YXIgbz0wO288ZS5sZW5ndGg7KytvKXt2YXIgaT1lLmNoYXJDb2RlQXQobyk7aWYoNTUyOTY8PWkmJjU3MzQzPj1pJiYoaT02NTUzNisoKDEwMjMmaSk8PDEwKXwxMDIzJmUuY2hhckNvZGVBdCgrK28pKSwxMjc+PWkpe2lmKG4+PXIpYnJlYWs7dFtuKys+Pj4wXT1pfWVsc2V7aWYoMjA0Nz49aSl7aWYobisxPj1yKWJyZWFrO3RbbisrPj4+MF09MTkyfGk+PjZ9ZWxzZXtpZig2NTUzNT49aSl7aWYobisyPj1yKWJyZWFrO3RbbisrPj4+MF09MjI0fGk+PjEyfWVsc2V7aWYobiszPj1yKWJyZWFrO3RbbisrPj4+MF09MjQwfGk+PjE4LHRbbisrPj4+MF09MTI4fGk+PjEyJjYzfXRbbisrPj4+MF09MTI4fGk+PjYmNjN9dFtuKys+Pj4wXT0xMjh8NjMmaX19cmV0dXJuIHRbbj4+PjBdPTAsbi1hfWZ1bmN0aW9uIEQoZSl7Zm9yKHZhciB0PTAsbj0wO248ZS5sZW5ndGg7KytuKXt2YXIgcj1lLmNoYXJDb2RlQXQobik7MTI3Pj1yP3QrKzoyMDQ3Pj1yP3QrPTI6NTUyOTY8PXImJjU3MzQzPj1yPyh0Kz00LCsrbik6dCs9M31yZXR1cm4gdH1mdW5jdGlvbiBGKCl7dmFyIGU9Ty5idWZmZXI7Uz1lLHQuSEVBUDg9VD1uZXcgSW50OEFycmF5KGUpLHQuSEVBUDE2PW5ldyBJbnQxNkFycmF5KGUpLHQuSEVBUDMyPUU9bmV3IEludDMyQXJyYXkoZSksdC5IRUFQVTg9QT1uZXcgVWludDhBcnJheShlKSx0LkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KGUpLHQuSEVBUFUzMj1NPW5ldyBVaW50MzJBcnJheShlKSx0LkhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheShlKSx0LkhFQVBGNjQ9bmV3IEZsb2F0NjRBcnJheShlKX12YXIgVT1bXSxJPVtdLFc9W107ZnVuY3Rpb24gaigpe3ZhciBlPXQucHJlUnVuLnNoaWZ0KCk7VS51bnNoaWZ0KGUpfXZhciBILEw9MCxZPW51bGwsej1udWxsO2Z1bmN0aW9uIEIoZSl7dGhyb3cgdC5vbkFib3J0JiZ0Lm9uQWJvcnQoZSksdyhlPVwiQWJvcnRlZChcIitlK1wiKVwiKSxSPSEwLGU9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihlK1wiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiKSxhKGUpLGV9ZnVuY3Rpb24gTigpe3JldHVybiBILnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpfWlmKEg9XCJvcnQtd2FzbS53YXNtXCIsIU4oKSl7dmFyIEc9SDtIPXQubG9jYXRlRmlsZT90LmxvY2F0ZUZpbGUoRyx5KTp5K0d9ZnVuY3Rpb24gcSgpe3ZhciBlPUg7dHJ5e2lmKGU9PUgmJnYpcmV0dXJuIG5ldyBVaW50OEFycmF5KHYpO2lmKHMpcmV0dXJuIHMoZSk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9Y2F0Y2goZSl7QihlKX19ZnVuY3Rpb24gJChlKXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPVwiUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdChcIitlK1wiKVwiLHRoaXMuc3RhdHVzPWV9ZnVuY3Rpb24gVihlKXtmb3IoOzA8ZS5sZW5ndGg7KWUuc2hpZnQoKSh0KX1mdW5jdGlvbiBKKGUpe3RoaXMuc2E9ZS0yNCx0aGlzLklhPWZ1bmN0aW9uKGUpe01bdGhpcy5zYSs0Pj4yPj4+MF09ZX0sdGhpcy5CYT1mdW5jdGlvbihlKXtNW3RoaXMuc2ErOD4+Mj4+PjBdPWV9LHRoaXMuR2E9ZnVuY3Rpb24oKXtFW3RoaXMuc2E+PjI+Pj4wXT0wfSx0aGlzLkFhPWZ1bmN0aW9uKCl7VFt0aGlzLnNhKzEyPj4wPj4+MF09MH0sdGhpcy5IYT1mdW5jdGlvbigpe1RbdGhpcy5zYSsxMz4+MD4+PjBdPTB9LHRoaXMueWE9ZnVuY3Rpb24oZSx0KXt0aGlzLnphKCksdGhpcy5JYShlKSx0aGlzLkJhKHQpLHRoaXMuR2EoKSx0aGlzLkFhKCksdGhpcy5IYSgpfSx0aGlzLnphPWZ1bmN0aW9uKCl7TVt0aGlzLnNhKzE2Pj4yPj4+MF09MH19ZnVuY3Rpb24gUShlKXt2YXIgdD1EKGUpKzEsbj1pZSh0KTtyZXR1cm4gbiYmayhlLFQsbix0KSxufXZhciBYPXt9O2Z1bmN0aW9uIEsoKXtpZighWil7dmFyIGUsdD17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzooXCJvYmplY3RcIj09dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzpwfHxcIi4vdGhpcy5wcm9ncmFtXCJ9O2ZvcihlIGluIFgpdm9pZCAwPT09WFtlXT9kZWxldGUgdFtlXTp0W2VdPVhbZV07dmFyIG49W107Zm9yKGUgaW4gdCluLnB1c2goZStcIj1cIit0W2VdKTtaPW59cmV0dXJuIFp9dmFyIFosZWU9W251bGwsW10sW11dO2Z1bmN0aW9uIHRlKGUpe3JldHVybiAwPT1lJTQmJigwIT1lJTEwMHx8MD09ZSU0MDApfXZhciBuZT1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLHJlPVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24gYWUoZSx0LG4scil7ZnVuY3Rpb24gYShlLHQsbil7Zm9yKGU9XCJudW1iZXJcIj09dHlwZW9mIGU/ZS50b1N0cmluZygpOmV8fFwiXCI7ZS5sZW5ndGg8dDspZT1uWzBdK2U7cmV0dXJuIGV9ZnVuY3Rpb24gbyhlLHQpe3JldHVybiBhKGUsdCxcIjBcIil9ZnVuY3Rpb24gaShlLHQpe2Z1bmN0aW9uIG4oZSl7cmV0dXJuIDA+ZT8tMTowPGU/MTowfXZhciByO3JldHVybiAwPT09KHI9bihlLmdldEZ1bGxZZWFyKCktdC5nZXRGdWxsWWVhcigpKSkmJjA9PT0ocj1uKGUuZ2V0TW9udGgoKS10LmdldE1vbnRoKCkpKSYmKHI9bihlLmdldERhdGUoKS10LmdldERhdGUoKSkpLHJ9ZnVuY3Rpb24gcyhlKXtzd2l0Y2goZS5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiBlO2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiB1KGUpe3ZhciB0PWUucWE7Zm9yKGU9bmV3IERhdGUobmV3IERhdGUoZS5yYSsxOTAwLDAsMSkuZ2V0VGltZSgpKTswPHQ7KXt2YXIgbj1lLmdldE1vbnRoKCkscj0odGUoZS5nZXRGdWxsWWVhcigpKT9uZTpyZSlbbl07aWYoISh0PnItZS5nZXREYXRlKCkpKXtlLnNldERhdGUoZS5nZXREYXRlKCkrdCk7YnJlYWt9dC09ci1lLmdldERhdGUoKSsxLGUuc2V0RGF0ZSgxKSwxMT5uP2Uuc2V0TW9udGgobisxKTooZS5zZXRNb250aCgwKSxlLnNldEZ1bGxZZWFyKGUuZ2V0RnVsbFllYXIoKSsxKSl9cmV0dXJuIG49bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpKzEsMCw0KSx0PXMobmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsNCkpLG49cyhuKSwwPj1pKHQsZSk/MD49aShuLGUpP2UuZ2V0RnVsbFllYXIoKSsxOmUuZ2V0RnVsbFllYXIoKTplLmdldEZ1bGxZZWFyKCktMX12YXIgYz1FW3IrNDA+PjI+Pj4wXTtmb3IodmFyIGwgaW4gcj17RWE6RVtyPj4yPj4+MF0sRGE6RVtyKzQ+PjI+Pj4wXSx0YTpFW3IrOD4+Mj4+PjBdLHZhOkVbcisxMj4+Mj4+PjBdLHVhOkVbcisxNj4+Mj4+PjBdLHJhOkVbcisyMD4+Mj4+PjBdLGxhOkVbcisyND4+Mj4+PjBdLHFhOkVbcisyOD4+Mj4+PjBdLEphOkVbciszMj4+Mj4+PjBdLENhOkVbciszNj4+Mj4+PjBdLEZhOmM/UChjKTpcIlwifSxuPVAobiksYz17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9KW49bi5yZXBsYWNlKG5ldyBSZWdFeHAobCxcImdcIiksY1tsXSk7dmFyIGY9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxwPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtmb3IobCBpbiBjPXtcIiVhXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGZbZS5sYV0uc3Vic3RyaW5nKDAsMyl9LFwiJUFcIjpmdW5jdGlvbihlKXtyZXR1cm4gZltlLmxhXX0sXCIlYlwiOmZ1bmN0aW9uKGUpe3JldHVybiBwW2UudWFdLnN1YnN0cmluZygwLDMpfSxcIiVCXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHBbZS51YV19LFwiJUNcIjpmdW5jdGlvbihlKXtyZXR1cm4gbygoZS5yYSsxOTAwKS8xMDB8MCwyKX0sXCIlZFwiOmZ1bmN0aW9uKGUpe3JldHVybiBvKGUudmEsMil9LFwiJWVcIjpmdW5jdGlvbihlKXtyZXR1cm4gYShlLnZhLDIsXCIgXCIpfSxcIiVnXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHUoZSkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJUdcIjpmdW5jdGlvbihlKXtyZXR1cm4gdShlKX0sXCIlSFwiOmZ1bmN0aW9uKGUpe3JldHVybiBvKGUudGEsMil9LFwiJUlcIjpmdW5jdGlvbihlKXtyZXR1cm4gMD09KGU9ZS50YSk/ZT0xMjoxMjxlJiYoZS09MTIpLG8oZSwyKX0sXCIlalwiOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wLG49MDtuPD1lLnVhLTE7dCs9KHRlKGUucmErMTkwMCk/bmU6cmUpW24rK10pO3JldHVybiBvKGUudmErdCwzKX0sXCIlbVwiOmZ1bmN0aW9uKGUpe3JldHVybiBvKGUudWErMSwyKX0sXCIlTVwiOmZ1bmN0aW9uKGUpe3JldHVybiBvKGUuRGEsMil9LFwiJW5cIjpmdW5jdGlvbigpe3JldHVyblwiXFxcXG5cIn0sXCIlcFwiOmZ1bmN0aW9uKGUpe3JldHVybiAwPD1lLnRhJiYxMj5lLnRhP1wiQU1cIjpcIlBNXCJ9LFwiJVNcIjpmdW5jdGlvbihlKXtyZXR1cm4gbyhlLkVhLDIpfSxcIiV0XCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcXFx0XCJ9LFwiJXVcIjpmdW5jdGlvbihlKXtyZXR1cm4gZS5sYXx8N30sXCIlVVwiOmZ1bmN0aW9uKGUpe3JldHVybiBvKE1hdGguZmxvb3IoKGUucWErNy1lLmxhKS83KSwyKX0sXCIlVlwiOmZ1bmN0aW9uKGUpe3ZhciB0PU1hdGguZmxvb3IoKGUucWErNy0oZS5sYSs2KSU3KS83KTtpZigyPj0oZS5sYSszNzEtZS5xYS0yKSU3JiZ0KyssdCk1Mz09dCYmKDQ9PShuPShlLmxhKzM3MS1lLnFhKSU3KXx8Mz09biYmdGUoZS5yYSl8fCh0PTEpKTtlbHNle3Q9NTI7dmFyIG49KGUubGErNy1lLnFhLTEpJTc7KDQ9PW58fDU9PW4mJnRlKGUucmElNDAwLTEpKSYmdCsrfXJldHVybiBvKHQsMil9LFwiJXdcIjpmdW5jdGlvbihlKXtyZXR1cm4gZS5sYX0sXCIlV1wiOmZ1bmN0aW9uKGUpe3JldHVybiBvKE1hdGguZmxvb3IoKGUucWErNy0oZS5sYSs2KSU3KS83KSwyKX0sXCIleVwiOmZ1bmN0aW9uKGUpe3JldHVybihlLnJhKzE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVZXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmErMTkwMH0sXCIlelwiOmZ1bmN0aW9uKGUpe3ZhciB0PTA8PShlPWUuQ2EpO3JldHVybiBlPU1hdGguYWJzKGUpLzYwLCh0P1wiK1wiOlwiLVwiKStTdHJpbmcoXCIwMDAwXCIrKGUvNjAqMTAwK2UlNjApKS5zbGljZSgtNCl9LFwiJVpcIjpmdW5jdGlvbihlKXtyZXR1cm4gZS5GYX0sXCIlJVwiOmZ1bmN0aW9uKCl7cmV0dXJuXCIlXCJ9fSxuPW4ucmVwbGFjZSgvJSUvZyxcIlxcXFwwXFxcXDBcIiksYyluLmluY2x1ZGVzKGwpJiYobj1uLnJlcGxhY2UobmV3IFJlZ0V4cChsLFwiZ1wiKSxjW2xdKHIpKSk7cmV0dXJuIGw9ZnVuY3Rpb24oZSl7dmFyIHQ9QXJyYXkoRChlKSsxKTtyZXR1cm4gayhlLHQsMCx0Lmxlbmd0aCksdH0obj1uLnJlcGxhY2UoL1xcXFwwXFxcXDAvZyxcIiVcIikpLGwubGVuZ3RoPnQ/MDooVC5zZXQobCxlPj4+MCksbC5sZW5ndGgtMSl9dmFyIG9lPXthOmZ1bmN0aW9uKGUpe3JldHVybiBpZShlKzI0KSsyNH0sYjpmdW5jdGlvbihlLHQsbil7dGhyb3cgbmV3IEooZSkueWEodCxuKSxlfSxnOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LEk6ZnVuY3Rpb24oKXt9LHc6ZnVuY3Rpb24oKXt9LHk6ZnVuY3Rpb24oKXt9LEs6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sRzpmdW5jdGlvbigpe30sQzpmdW5jdGlvbigpe30sRjpmdW5jdGlvbigpe30sazpmdW5jdGlvbigpe30seDpmdW5jdGlvbigpe30sdTpmdW5jdGlvbigpe30sSDpmdW5jdGlvbigpe30sdjpmdW5jdGlvbigpe30sbjpmdW5jdGlvbigpe30scDpmdW5jdGlvbigpe0IoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0sbzpmdW5jdGlvbigpe0IoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0sbDpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfSxMOmZ1bmN0aW9uKCl7cmV0dXJuITB9LE06ZnVuY3Rpb24oZSx0KXtlPW5ldyBEYXRlKDFlMyooTVtlPj4+Ml0rNDI5NDk2NzI5NipFW2UrND4+PjJdKSksRVt0Pj4yPj4+MF09ZS5nZXRVVENTZWNvbmRzKCksRVt0KzQ+PjI+Pj4wXT1lLmdldFVUQ01pbnV0ZXMoKSxFW3QrOD4+Mj4+PjBdPWUuZ2V0VVRDSG91cnMoKSxFW3QrMTI+PjI+Pj4wXT1lLmdldFVUQ0RhdGUoKSxFW3QrMTY+PjI+Pj4wXT1lLmdldFVUQ01vbnRoKCksRVt0KzIwPj4yPj4+MF09ZS5nZXRVVENGdWxsWWVhcigpLTE5MDAsRVt0KzI0Pj4yPj4+MF09ZS5nZXRVVENEYXkoKSxFW3QrMjg+PjI+Pj4wXT0oZS5nZXRUaW1lKCktRGF0ZS5VVEMoZS5nZXRVVENGdWxsWWVhcigpLDAsMSwwLDAsMCwwKSkvODY0ZTV8MH0sTjpmdW5jdGlvbihlLHQpe2U9bmV3IERhdGUoMWUzKihNW2U+Pj4yXSs0Mjk0OTY3Mjk2KkVbZSs0Pj4+Ml0pKSxFW3Q+PjI+Pj4wXT1lLmdldFNlY29uZHMoKSxFW3QrND4+Mj4+PjBdPWUuZ2V0TWludXRlcygpLEVbdCs4Pj4yPj4+MF09ZS5nZXRIb3VycygpLEVbdCsxMj4+Mj4+PjBdPWUuZ2V0RGF0ZSgpLEVbdCsxNj4+Mj4+PjBdPWUuZ2V0TW9udGgoKSxFW3QrMjA+PjI+Pj4wXT1lLmdldEZ1bGxZZWFyKCktMTkwMCxFW3QrMjQ+PjI+Pj4wXT1lLmdldERheSgpO3ZhciBuPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDEpO0VbdCsyOD4+Mj4+PjBdPShlLmdldFRpbWUoKS1uLmdldFRpbWUoKSkvODY0ZTV8MCxFW3QrMzY+PjI+Pj4wXT0tNjAqZS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciByPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7bj1uLmdldFRpbWV6b25lT2Zmc2V0KCksRVt0KzMyPj4yPj4+MF09MHwociE9biYmZS5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbihuLHIpKX0sTzpmdW5jdGlvbihlKXt2YXIgdD1uZXcgRGF0ZShFW2UrMjA+PjI+Pj4wXSsxOTAwLEVbZSsxNj4+Mj4+PjBdLEVbZSsxMj4+Mj4+PjBdLEVbZSs4Pj4yPj4+MF0sRVtlKzQ+PjI+Pj4wXSxFW2U+PjI+Pj4wXSwwKSxuPUVbZSszMj4+Mj4+PjBdLHI9dC5nZXRUaW1lem9uZU9mZnNldCgpLGE9bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSksbz1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLGk9YS5nZXRUaW1lem9uZU9mZnNldCgpLHM9TWF0aC5taW4oaSxvKTtyZXR1cm4gMD5uP0VbZSszMj4+Mj4+PjBdPU51bWJlcihvIT1pJiZzPT1yKTowPG4hPShzPT1yKSYmKG89TWF0aC5tYXgoaSxvKSx0LnNldFRpbWUodC5nZXRUaW1lKCkrNmU0KigoMDxuP3M6byktcikpKSxFW2UrMjQ+PjI+Pj4wXT10LmdldERheSgpLEVbZSsyOD4+Mj4+PjBdPSh0LmdldFRpbWUoKS1hLmdldFRpbWUoKSkvODY0ZTV8MCxFW2U+PjI+Pj4wXT10LmdldFNlY29uZHMoKSxFW2UrND4+Mj4+PjBdPXQuZ2V0TWludXRlcygpLEVbZSs4Pj4yPj4+MF09dC5nZXRIb3VycygpLEVbZSsxMj4+Mj4+PjBdPXQuZ2V0RGF0ZSgpLEVbZSsxNj4+Mj4+PjBdPXQuZ2V0TW9udGgoKSx0LmdldFRpbWUoKS8xZTN8MH0sejpmdW5jdGlvbigpe3JldHVybi01Mn0sQjpmdW5jdGlvbigpe30sbTpmdW5jdGlvbiBlKHQsbixyKXtlLnhhfHwoZS54YT0hMCxmdW5jdGlvbihlLHQsbil7ZnVuY3Rpb24gcihlKXtyZXR1cm4oZT1lLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXFxcKChbQS1aYS16IF0rKVxcXFwpJC8pKT9lWzFdOlwiR01UXCJ9dmFyIGE9KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpLG89bmV3IERhdGUoYSwwLDEpLGk9bmV3IERhdGUoYSw2LDEpO2E9by5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBzPWkuZ2V0VGltZXpvbmVPZmZzZXQoKTtFW2U+PjI+Pj4wXT02MCpNYXRoLm1heChhLHMpLEVbdD4+Mj4+PjBdPU51bWJlcihhIT1zKSxlPXIobyksdD1yKGkpLGU9UShlKSx0PVEodCksczxhPyhNW24+PjI+Pj4wXT1lLE1bbis0Pj4yPj4+MF09dCk6KE1bbj4+Mj4+PjBdPXQsTVtuKzQ+PjI+Pj4wXT1lKX0odCxuLHIpKX0sZDpmdW5jdGlvbigpe0IoXCJcIil9LHQ6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0saDpoPygpPT57dmFyIGU9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gMWUzKmVbMF0rZVsxXS8xZTZ9OigpPT5wZXJmb3JtYW5jZS5ub3coKSxKOmZ1bmN0aW9uKGUsdCxuKXtBLmNvcHlXaXRoaW4oZT4+PjAsdD4+PjAsdCtuPj4+MCl9LGY6ZnVuY3Rpb24oZSl7dmFyIHQ9QS5sZW5ndGg7aWYoNDI5NDkwMTc2MDwoZT4+Pj0wKSlyZXR1cm4hMTtmb3IodmFyIG49MTs0Pj1uO24qPTIpe3ZhciByPXQqKDErLjIvbik7cj1NYXRoLm1pbihyLGUrMTAwNjYzMjk2KTt2YXIgYT1NYXRoO3I9TWF0aC5tYXgoZSxyKSxhPWEubWluLmNhbGwoYSw0Mjk0OTAxNzYwLHIrKDY1NTM2LXIlNjU1MzYpJTY1NTM2KTtlOnt0cnl7Ty5ncm93KGEtUy5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTYpLEYoKTt2YXIgbz0xO2JyZWFrIGV9Y2F0Y2goZSl7fW89dm9pZCAwfWlmKG8pcmV0dXJuITB9cmV0dXJuITF9LEQ6ZnVuY3Rpb24oZSx0KXt2YXIgbj0wO3JldHVybiBLKCkuZm9yRWFjaCgoZnVuY3Rpb24ocixhKXt2YXIgbz10K247Zm9yKGE9TVtlKzQqYT4+Mj4+PjBdPW8sbz0wO288ci5sZW5ndGg7KytvKVRbYSsrPj4wPj4+MF09ci5jaGFyQ29kZUF0KG8pO1RbYT4+MD4+PjBdPTAsbis9ci5sZW5ndGgrMX0pKSwwfSxFOmZ1bmN0aW9uKGUsdCl7dmFyIG49SygpO01bZT4+Mj4+PjBdPW4ubGVuZ3RoO3ZhciByPTA7cmV0dXJuIG4uZm9yRWFjaCgoZnVuY3Rpb24oZSl7cis9ZS5sZW5ndGgrMX0pKSxNW3Q+PjI+Pj4wXT1yLDB9LHI6ZnVuY3Rpb24oZSl7X3x8KHQub25FeGl0JiZ0Lm9uRXhpdChlKSxSPSEwKSxkKGUsbmV3ICQoZSkpfSxlOmZ1bmN0aW9uKCl7cmV0dXJuIDUyfSxqOmZ1bmN0aW9uKCl7cmV0dXJuIDUyfSxxOmZ1bmN0aW9uKCl7cmV0dXJuIDcwfSxpOmZ1bmN0aW9uKGUsdCxuLHIpe2Zvcih2YXIgYT0wLG89MDtvPG47bysrKXt2YXIgaT1NW3Q+PjI+Pj4wXSxzPU1bdCs0Pj4yPj4+MF07dCs9ODtmb3IodmFyIHU9MDt1PHM7dSsrKXt2YXIgYz1BW2krdT4+PjBdLGw9ZWVbZV07MD09PWN8fDEwPT09Yz8oKDE9PT1lP2I6dykoQyhsLDApKSxsLmxlbmd0aD0wKTpsLnB1c2goYyl9YSs9c31yZXR1cm4gTVtyPj4yPj4+MF09YSwwfSxzOmZ1bmN0aW9uIGUodCxyKXtlLndhfHwoZS53YT1mdW5jdGlvbigpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBjcnlwdG8mJlwiZnVuY3Rpb25cIj09dHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpe3ZhciBlPW5ldyBVaW50OEFycmF5KDEpO3JldHVybigpPT4oY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhlKSxlWzBdKX1pZihoKXRyeXt2YXIgdD1uKDc2MCk7cmV0dXJuKCk9PnQucmFuZG9tQnl0ZXMoMSlbMF19Y2F0Y2goZSl7fXJldHVybigpPT5CKFwicmFuZG9tRGV2aWNlXCIpfSgpKTtmb3IodmFyIGE9MDthPHI7YSsrKVRbdCthPj4wPj4+MF09ZS53YSgpO3JldHVybiAwfSxBOmFlLGM6ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIGFlKGUsdCxuLHIpfX07IWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0LmFzbT1lLmV4cG9ydHMsTz10LmFzbS5QLEYoKSxJLnVuc2hpZnQodC5hc20uUSksTC0tLHQubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmdC5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKEwpLDA9PUwmJihudWxsIT09WSYmKGNsZWFySW50ZXJ2YWwoWSksWT1udWxsKSx6JiYoZT16LHo9bnVsbCxlKCkpKX1mdW5jdGlvbiBuKHQpe2UodC5pbnN0YW5jZSl9ZnVuY3Rpb24gcihlKXtyZXR1cm4gZnVuY3Rpb24oKXtpZighdiYmKG18fGcpKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBmZXRjaCYmIUguc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpcmV0dXJuIGZldGNoKEgse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKGUpe2lmKCFlLm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0IFxcJ1wiK0grXCJcXCdcIjtyZXR1cm4gZS5hcnJheUJ1ZmZlcigpfSkpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBxKCl9KSk7aWYoaSlyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsdCl7aShILChmdW5jdGlvbih0KXtlKG5ldyBVaW50OEFycmF5KHQpKX0pLHQpfSkpfXJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKChmdW5jdGlvbigpe3JldHVybiBxKCl9KSl9KCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGUsbyl9KSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIGV9KSkudGhlbihlLChmdW5jdGlvbihlKXt3KFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrZSksQihlKX0pKX12YXIgbz17YTpvZX07aWYoTCsrLHQubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmdC5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKEwpLHQuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gdC5pbnN0YW50aWF0ZVdhc20obyxlKX1jYXRjaChlKXtyZXR1cm4gdyhcIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6IFwiK2UpLCExfSh2fHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ3x8TigpfHxILnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpfHxofHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBmZXRjaD9yKG4pOmZldGNoKEgse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhlLG8pLnRoZW4obiwoZnVuY3Rpb24oZSl7cmV0dXJuIHcoXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIrZSksdyhcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLHIobil9KSl9KSkpLmNhdGNoKGEpfSgpLHQuX19fd2FzbV9jYWxsX2N0b3JzPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX19fd2FzbV9jYWxsX2N0b3JzPXQuYXNtLlEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0SW5pdD1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRJbml0PXQuYXNtLlIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9dC5hc20uUykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj10LmFzbS5UKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9dC5hc20uVSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPXQuYXNtLlYpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0Q3JlYXRlU2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRDcmVhdGVTZXNzaW9uPXQuYXNtLlcpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0UmVsZWFzZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0UmVsZWFzZVNlc3Npb249dC5hc20uWCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRHZXRJbnB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEdldElucHV0Q291bnQ9dC5hc20uWSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRHZXRPdXRwdXRDb3VudD1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRHZXRPdXRwdXRDb3VudD10LmFzbS5aKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEdldElucHV0TmFtZT1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRHZXRJbnB1dE5hbWU9dC5hc20uXykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRHZXRPdXRwdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEdldE91dHB1dE5hbWU9dC5hc20uJCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRGcmVlPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEZyZWU9dC5hc20uYWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0Q3JlYXRlVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydENyZWF0ZVRlbnNvcj10LmFzbS5iYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRHZXRUZW5zb3JEYXRhPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEdldFRlbnNvckRhdGE9dC5hc20uY2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0UmVsZWFzZVRlbnNvcj1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRSZWxlYXNlVGVuc29yPXQuYXNtLmRhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydENyZWF0ZVJ1bk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0Q3JlYXRlUnVuT3B0aW9ucz10LmFzbS5lYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRBZGRSdW5Db25maWdFbnRyeT1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRBZGRSdW5Db25maWdFbnRyeT10LmFzbS5mYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRSZWxlYXNlUnVuT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRSZWxlYXNlUnVuT3B0aW9ucz10LmFzbS5nYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRSdW49ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0UnVuPXQuYXNtLmhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEVuZFByb2ZpbGluZz1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRFbmRQcm9maWxpbmc9dC5hc20uaWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIGllPXQuX21hbGxvYz1mdW5jdGlvbigpe3JldHVybihpZT10Ll9tYWxsb2M9dC5hc20uamEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dC5fZnJlZT1mdW5jdGlvbigpe3JldHVybih0Ll9mcmVlPXQuYXNtLmthKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBzZSx1ZT10LnN0YWNrU2F2ZT1mdW5jdGlvbigpe3JldHVybih1ZT10LnN0YWNrU2F2ZT10LmFzbS5tYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxjZT10LnN0YWNrUmVzdG9yZT1mdW5jdGlvbigpe3JldHVybihjZT10LnN0YWNrUmVzdG9yZT10LmFzbS5uYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxsZT10LnN0YWNrQWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4obGU9dC5zdGFja0FsbG9jPXQuYXNtLm9hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIGZlKCl7ZnVuY3Rpb24gZSgpe2lmKCFzZSYmKHNlPSEwLHQuY2FsbGVkUnVuPSEwLCFSKSl7aWYoVihJKSxyKHQpLHQub25SdW50aW1lSW5pdGlhbGl6ZWQmJnQub25SdW50aW1lSW5pdGlhbGl6ZWQoKSx0LnBvc3RSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQucG9zdFJ1biYmKHQucG9zdFJ1bj1bdC5wb3N0UnVuXSk7dC5wb3N0UnVuLmxlbmd0aDspe3ZhciBlPXQucG9zdFJ1bi5zaGlmdCgpO1cudW5zaGlmdChlKX1WKFcpfX1pZighKDA8TCkpe2lmKHQucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnByZVJ1biYmKHQucHJlUnVuPVt0LnByZVJ1bl0pO3QucHJlUnVuLmxlbmd0aDspaigpO1YoVSksMDxMfHwodC5zZXRTdGF0dXM/KHQuc2V0U3RhdHVzKFwiUnVubmluZy4uLlwiKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7dC5zZXRTdGF0dXMoXCJcIil9KSwxKSxlKCl9KSwxKSk6ZSgpKX19aWYodC5fX19jeGFfaXNfcG9pbnRlcl90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT10LmFzbS5wYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0LlVURjhUb1N0cmluZz1QLHQuc3RyaW5nVG9VVEY4PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gayhlLEEsdCxuKX0sdC5sZW5ndGhCeXRlc1VURjg9RCx0LnN0YWNrU2F2ZT11ZSx0LnN0YWNrUmVzdG9yZT1jZSx0LnN0YWNrQWxsb2M9bGUsej1mdW5jdGlvbiBlKCl7c2V8fGZlKCksc2V8fCh6PWUpfSx0LnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQucHJlSW5pdCYmKHQucHJlSW5pdD1bdC5wcmVJbml0XSk7MDx0LnByZUluaXQubGVuZ3RoOyl0LnByZUluaXQucG9wKCkoKTtyZXR1cm4gZmUoKSxlLnJlYWR5fSk7ZS5leHBvcnRzPXJ9LDE1NDplPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPVxcJ1widXNlIHN0cmljdFwiO3ZhciBlPXt9LHQ9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO2lmKHQpe3ZhciByPXJlcXVpcmUoXCJ3b3JrZXJfdGhyZWFkc1wiKSxhPXIucGFyZW50UG9ydDthLm9uKFwibWVzc2FnZVwiLChlPT5vbm1lc3NhZ2Uoe2RhdGE6ZX0pKSk7dmFyIG89cmVxdWlyZShcImZzXCIpO09iamVjdC5hc3NpZ24oZ2xvYmFsLHtzZWxmOmdsb2JhbCxyZXF1aXJlOnJlcXVpcmUsTW9kdWxlOmUsbG9jYXRpb246e2hyZWY6X19maWxlbmFtZX0sV29ya2VyOnIuV29ya2VyLGltcG9ydFNjcmlwdHM6ZnVuY3Rpb24oZSl7KDAsZXZhbCkoby5yZWFkRmlsZVN5bmMoZSxcInV0ZjhcIikpfSxwb3N0TWVzc2FnZTpmdW5jdGlvbihlKXthLnBvc3RNZXNzYWdlKGUpfSxwZXJmb3JtYW5jZTpnbG9iYWwucGVyZm9ybWFuY2V8fHtub3c6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX19fSl9dmFyIHM9ITEsbj1bXSxpPWZ1bmN0aW9uKCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTt0P28ud3JpdGVTeW5jKDIsZStcIlxcXFxcXFxcblwiKTpjb25zb2xlLmVycm9yKGUpfTtzZWxmLmFsZXJ0PWZ1bmN0aW9uKCl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtwb3N0TWVzc2FnZSh7Y21kOlwiYWxlcnRcIix0ZXh0OnQsdGhyZWFkSWQ6ZS5fcHRocmVhZF9zZWxmKCl9KX0sZS5pbnN0YW50aWF0ZVdhc209KHQscik9Pnt2YXIgYT1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UoZS53YXNtTW9kdWxlLHQpO3JldHVybiByKGEpLGUud2FzbU1vZHVsZT1udWxsLGEuZXhwb3J0c30sc2VsZi5vbnVuaGFuZGxlZHJlamVjdGlvbj1lPT57dGhyb3cgZS5yZWFzb24/P2V9LHNlbGYub25tZXNzYWdlPXQ9Pnt0cnl7aWYoXCJsb2FkXCI9PT10LmRhdGEuY21kKXtpZihlLndhc21Nb2R1bGU9dC5kYXRhLndhc21Nb2R1bGUsZS53YXNtTWVtb3J5PXQuZGF0YS53YXNtTWVtb3J5LGUuYnVmZmVyPWUud2FzbU1lbW9yeS5idWZmZXIsZS5FTlZJUk9OTUVOVF9JU19QVEhSRUFEPSEwLFwic3RyaW5nXCI9PXR5cGVvZiB0LmRhdGEudXJsT3JCbG9iKWltcG9ydFNjcmlwdHModC5kYXRhLnVybE9yQmxvYik7ZWxzZXt2YXIgcj1VUkwuY3JlYXRlT2JqZWN0VVJMKHQuZGF0YS51cmxPckJsb2IpO2ltcG9ydFNjcmlwdHMociksVVJMLnJldm9rZU9iamVjdFVSTChyKX1vcnRXYXNtVGhyZWFkZWQoZSkudGhlbigoZnVuY3Rpb24odCl7ZT10fSkpfWVsc2UgaWYoXCJydW5cIj09PXQuZGF0YS5jbWQpe2UuX19wZXJmb3JtYW5jZV9ub3dfY2xvY2tfZHJpZnQ9cGVyZm9ybWFuY2Uubm93KCktdC5kYXRhLnRpbWUsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQodC5kYXRhLnB0aHJlYWRfcHRyLDAsMCwxKSxlLmVzdGFibGlzaFN0YWNrU3BhY2UoKSxlLlBUaHJlYWQucmVjZWl2ZU9iamVjdFRyYW5zZmVyKHQuZGF0YSksZS5QVGhyZWFkLnRocmVhZEluaXRUTFMoKSxzfHwobi5mb3JFYWNoKCh0PT57ZS5leGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlKHQpfSkpLG49W10scz0hMCk7dHJ5e2UuaW52b2tlRW50cnlQb2ludCh0LmRhdGEuc3RhcnRfcm91dGluZSx0LmRhdGEuYXJnKX1jYXRjaCh0KXtpZihcInVud2luZFwiIT10KXtpZighKHQgaW5zdGFuY2VvZiBlLkV4aXRTdGF0dXMpKXRocm93IHQ7ZS5rZWVwUnVudGltZUFsaXZlKCl8fGUuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0KHQuc3RhdHVzKX19fWVsc2VcImNhbmNlbFwiPT09dC5kYXRhLmNtZD9lLl9wdGhyZWFkX3NlbGYoKSYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQoLTEpOlwic2V0aW1tZWRpYXRlXCI9PT10LmRhdGEudGFyZ2V0fHwoXCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiPT09dC5kYXRhLmNtZD9zP2UuZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZSh0LmRhdGEucXVldWUpOm4ucHVzaCh0LmRhdGEucXVldWUpOihpKFwid29ya2VyLmpzIHJlY2VpdmVkIHVua25vd24gY29tbWFuZCBcIit0LmRhdGEuY21kKSxpKHQuZGF0YSkpKX1jYXRjaCh0KXt0aHJvdyBpKFwid29ya2VyLmpzIG9ubWVzc2FnZSgpIGNhcHR1cmVkIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbjogXCIrdCksdCYmdC5zdGFjayYmaSh0LnN0YWNrKSxlLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZCYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQoKSx0fX07XFxcXG5cXCd9LDc2MDooKT0+e30sMzg0OigpPT57fSw5OTM6KCk9Pnt9LDkwODooKT0+e30sOTUzOigpPT57fSw5MjU6KCk9Pnt9LDQ0OTooKT0+e319LHQ9e307ZnVuY3Rpb24gbihyKXt2YXIgYT10W3JdO2lmKHZvaWQgMCE9PWEpcmV0dXJuIGEuZXhwb3J0czt2YXIgbz10W3JdPXtleHBvcnRzOnt9fTtyZXR1cm4gZVtyXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyxuKSxvLmV4cG9ydHN9bi5nPWZ1bmN0aW9uKCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbFRoaXMpcmV0dXJuIGdsb2JhbFRoaXM7dHJ5e3JldHVybiB0aGlzfHxuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfWNhdGNoKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cpcmV0dXJuIHdpbmRvd319KCksKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgZT1uKDI1OSksdD1uKDI2Myk7c2VsZi5vbm1lc3NhZ2U9bj0+e3N3aXRjaChuLmRhdGEudHlwZSl7Y2FzZVwiaW5pdC13YXNtXCI6KDAsdC5pbml0aWFsaXplV2ViQXNzZW1ibHkpKG4uZGF0YS5pbikudGhlbigoKCk9PnBvc3RNZXNzYWdlKHt0eXBlOlwiaW5pdC13YXNtXCJ9KSksKGU9PnBvc3RNZXNzYWdlKHt0eXBlOlwiaW5pdC13YXNtXCIsZXJyOmV9KSkpO2JyZWFrO2Nhc2VcImluaXQtb3J0XCI6dHJ5e2NvbnN0e251bVRocmVhZHM6dCxsb2dnaW5nTGV2ZWw6cn09bi5kYXRhLmluOygwLGUuaW5pdE9ydCkodCxyKSxwb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtb3J0XCJ9KX1jYXRjaChlKXtwb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtb3J0XCIsZXJyOmV9KX1icmVhaztjYXNlXCJjcmVhdGVfYWxsb2NhdGVcIjp0cnl7Y29uc3R7bW9kZWw6dH09bi5kYXRhLmluLHI9KDAsZS5jcmVhdGVTZXNzaW9uQWxsb2NhdGUpKHQpO3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlX2FsbG9jYXRlXCIsb3V0OnJ9KX1jYXRjaChlKXtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZV9hbGxvY2F0ZVwiLGVycjplfSl9YnJlYWs7Y2FzZVwiY3JlYXRlX2ZpbmFsaXplXCI6dHJ5e2NvbnN0e21vZGVsZGF0YTp0LG9wdGlvbnM6cn09bi5kYXRhLmluLGE9KDAsZS5jcmVhdGVTZXNzaW9uRmluYWxpemUpKHQscik7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVfZmluYWxpemVcIixvdXQ6YX0pfWNhdGNoKGUpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlX2ZpbmFsaXplXCIsZXJyOmV9KX1icmVhaztjYXNlXCJjcmVhdGVcIjp0cnl7Y29uc3R7bW9kZWw6dCxvcHRpb25zOnJ9PW4uZGF0YS5pbixhPSgwLGUuY3JlYXRlU2Vzc2lvbikodCxyKTtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZVwiLG91dDphfSl9Y2F0Y2goZSl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVcIixlcnI6ZX0pfWJyZWFrO2Nhc2VcInJlbGVhc2VcIjp0cnl7Y29uc3QgdD1uLmRhdGEuaW47KDAsZS5yZWxlYXNlU2Vzc2lvbikodCkscG9zdE1lc3NhZ2Uoe3R5cGU6XCJyZWxlYXNlXCJ9KX1jYXRjaChlKXtwb3N0TWVzc2FnZSh7dHlwZTpcInJlbGVhc2VcIixlcnI6ZX0pfWJyZWFrO2Nhc2VcInJ1blwiOnRyeXtjb25zdHtzZXNzaW9uSWQ6dCxpbnB1dEluZGljZXM6cixpbnB1dHM6YSxvdXRwdXRJbmRpY2VzOm8sb3B0aW9uczppfT1uLmRhdGEuaW47KDAsZS5ydW4pKHQscixhLG8saSkudGhlbigodD0+e3Bvc3RNZXNzYWdlKHt0eXBlOlwicnVuXCIsb3V0OnR9LCgwLGUuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMpKHQpKX0pLChlPT57cG9zdE1lc3NhZ2Uoe3R5cGU6XCJydW5cIixlcnI6ZX0pfSkpfWNhdGNoKGUpe3Bvc3RNZXNzYWdlKHt0eXBlOlwicnVuXCIsZXJyOmV9KX1icmVhaztjYXNlXCJlbmQtcHJvZmlsaW5nXCI6dHJ5e2NvbnN0IHQ9bi5kYXRhLmluOygwLGUuZW5kUHJvZmlsaW5nKSh0KSxwb3N0TWVzc2FnZSh7dHlwZTpcImVuZC1wcm9maWxpbmdcIn0pfWNhdGNoKGUpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGVycjplfSl9fX19KSgpfSkoKTtcXG4nLFwiV29ya2VyXCIsdm9pZCAwLHZvaWQgMCl9fSw2NjE0OmU9PntcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LG4scil7dmFyIG89c2VsZnx8d2luZG93O3RyeXt0cnl7dmFyIGk7dHJ5e2k9bmV3IG8uQmxvYihbZV0pfWNhdGNoKHQpeyhpPW5ldyhvLkJsb2JCdWlsZGVyfHxvLldlYktpdEJsb2JCdWlsZGVyfHxvLk1vekJsb2JCdWlsZGVyfHxvLk1TQmxvYkJ1aWxkZXIpKS5hcHBlbmQoZSksaT1pLmdldEJsb2IoKX12YXIgYT1vLlVSTHx8by53ZWJraXRVUkwscz1hLmNyZWF0ZU9iamVjdFVSTChpKSx1PW5ldyBvW3RdKHMsbik7cmV0dXJuIGEucmV2b2tlT2JqZWN0VVJMKHMpLHV9Y2F0Y2gocil7cmV0dXJuIG5ldyBvW3RdKFwiZGF0YTphcHBsaWNhdGlvbi9qYXZhc2NyaXB0LFwiLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQoZSkpLG4pfX1jYXRjaChlKXtpZighcil0aHJvdyBFcnJvcihcIklubGluZSB3b3JrZXIgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gbmV3IG9bdF0ocixuKX19fSwzNDc0OihlLHQsbik9Pnt2YXIgX3NjcmlwdERpcixyPShfc2NyaXB0RGlyPShfc2NyaXB0RGlyPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDApfHxcIi9pbmRleC5qc1wiLGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gRC5idWZmZXIhPUMmJkgoRC5idWZmZXIpLFJ9ZnVuY3Rpb24gcigpe3JldHVybiBELmJ1ZmZlciE9QyYmSChELmJ1ZmZlciksTX1mdW5jdGlvbiBvKCl7cmV0dXJuIEQuYnVmZmVyIT1DJiZIKEQuYnVmZmVyKSxOfWZ1bmN0aW9uIGkoKXtyZXR1cm4gRC5idWZmZXIhPUMmJkgoRC5idWZmZXIpLEZ9ZnVuY3Rpb24gYSgpe3JldHVybiBELmJ1ZmZlciE9QyYmSChELmJ1ZmZlciksTH12YXIgcyx1LGw7ZT1lfHx7fSxzfHwocz12b2lkIDAhPT1lP2U6e30pLHMucmVhZHk9bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsdCl7dT1lLGw9dH0pKTt2YXIgYyxwLGQsZixoLGcsbT1PYmplY3QuYXNzaWduKHt9LHMpLGI9XCIuL3RoaXMucHJvZ3JhbVwiLHk9KGUsdCk9Pnt0aHJvdyB0fSx3PVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3csXz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpbXBvcnRTY3JpcHRzLHY9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLHg9cy5FTlZJUk9OTUVOVF9JU19QVEhSRUFEfHwhMSxUPVwiXCI7ZnVuY3Rpb24gUyhlKXtyZXR1cm4gcy5sb2NhdGVGaWxlP3MubG9jYXRlRmlsZShlLFQpOlQrZX1pZih2KXtsZXQgdDtUPV8/big5MDgpLmRpcm5hbWUoVCkrXCIvXCI6XCIvL1wiLGc9KCk9PntofHwoZj1uKDEzODQpLGg9big5MDgpKX0sYz1mdW5jdGlvbihlLHQpe3JldHVybiBnKCksZT1oLm5vcm1hbGl6ZShlKSxmLnJlYWRGaWxlU3luYyhlLHQ/dm9pZCAwOlwidXRmOFwiKX0sZD1lPT4oKGU9YyhlLCEwKSkuYnVmZmVyfHwoZT1uZXcgVWludDhBcnJheShlKSksZSkscD0oZSx0LG4pPT57ZygpLGU9aC5ub3JtYWxpemUoZSksZi5yZWFkRmlsZShlLChmdW5jdGlvbihlLHIpe2U/bihlKTp0KHIuYnVmZmVyKX0pKX0sMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYoYj1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLChmdW5jdGlvbihlKXtpZighKGUgaW5zdGFuY2VvZiBhZSkpdGhyb3cgZX0pKSxwcm9jZXNzLm9uKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsKGZ1bmN0aW9uKGUpe3Rocm93IGV9KSkseT0oZSx0KT0+e2lmKFApdGhyb3cgcHJvY2Vzcy5leGl0Q29kZT1lLHQ7dCBpbnN0YW5jZW9mIGFlfHwkKFwiZXhpdGluZyBkdWUgdG8gZXhjZXB0aW9uOiBcIit0KSxwcm9jZXNzLmV4aXQoZSl9LHMuaW5zcGVjdD1mdW5jdGlvbigpe3JldHVyblwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn07dHJ5e3Q9big5OTI1KX1jYXRjaChlKXt0aHJvdyBjb25zb2xlLmVycm9yKCdUaGUgXCJ3b3JrZXJfdGhyZWFkc1wiIG1vZHVsZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgbm9kZS5qcyBidWlsZCAtIHBlcmhhcHMgYSBuZXdlciB2ZXJzaW9uIGlzIG5lZWRlZD8nKSxlfW4uZy5Xb3JrZXI9dC5Xb3JrZXJ9ZWxzZSh3fHxfKSYmKF8/VD1zZWxmLmxvY2F0aW9uLmhyZWY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoVD1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksX3NjcmlwdERpciYmKFQ9X3NjcmlwdERpciksVD0wIT09VC5pbmRleE9mKFwiYmxvYjpcIik/VC5zdWJzdHIoMCxULnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOlwiXCIsdnx8KGM9ZT0+e3ZhciB0PW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gdC5vcGVuKFwiR0VUXCIsZSwhMSksdC5zZW5kKG51bGwpLHQucmVzcG9uc2VUZXh0fSxfJiYoZD1lPT57dmFyIHQ9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB0Lm9wZW4oXCJHRVRcIixlLCExKSx0LnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsdC5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KHQucmVzcG9uc2UpfSkscD0oZSx0LG4pPT57dmFyIHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3Iub3BlbihcIkdFVFwiLGUsITApLHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixyLm9ubG9hZD0oKT0+ezIwMD09ci5zdGF0dXN8fDA9PXIuc3RhdHVzJiZyLnJlc3BvbnNlP3Qoci5yZXNwb25zZSk6bigpfSxyLm9uZXJyb3I9bixyLnNlbmQobnVsbCl9KSk7diYmXCJ1bmRlZmluZWRcIj09dHlwZW9mIHBlcmZvcm1hbmNlJiYobi5nLnBlcmZvcm1hbmNlPW4oNjk1MykucGVyZm9ybWFuY2UpO3ZhciBPPWNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksQT1jb25zb2xlLndhcm4uYmluZChjb25zb2xlKTt2JiYoZygpLE89ZT0+Zi53cml0ZVN5bmMoMSxlK1wiXFxuXCIpLEE9ZT0+Zi53cml0ZVN5bmMoMixlK1wiXFxuXCIpKTt2YXIgRSxJPXMucHJpbnR8fE8sJD1zLnByaW50RXJyfHxBO09iamVjdC5hc3NpZ24ocyxtKSxtPW51bGwscy50aGlzUHJvZ3JhbSYmKGI9cy50aGlzUHJvZ3JhbSkscy5xdWl0JiYoeT1zLnF1aXQpLHMud2FzbUJpbmFyeSYmKEU9cy53YXNtQmluYXJ5KTt2YXIgUD1zLm5vRXhpdFJ1bnRpbWV8fCEwO1wib2JqZWN0XCIhPXR5cGVvZiBXZWJBc3NlbWJseSYmbmUoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciBELGssQyxSLE0sTixGLEwsaj0hMSxVPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMDtmdW5jdGlvbiBCKGUsdCxuKXt2YXIgcj0odD4+Pj0wKStuO2ZvcihuPXQ7ZVtuXSYmIShuPj1yKTspKytuO2lmKDE2PG4tdCYmZS5idWZmZXImJlUpcmV0dXJuIFUuZGVjb2RlKGUuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXI/ZS5zbGljZSh0LG4pOmUuc3ViYXJyYXkodCxuKSk7Zm9yKHI9XCJcIjt0PG47KXt2YXIgbz1lW3QrK107aWYoMTI4Jm8pe3ZhciBpPTYzJmVbdCsrXTtpZigxOTI9PSgyMjQmbykpcis9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmbyk8PDZ8aSk7ZWxzZXt2YXIgYT02MyZlW3QrK107NjU1MzY+KG89MjI0PT0oMjQwJm8pPygxNSZvKTw8MTJ8aTw8NnxhOig3Jm8pPDwxOHxpPDwxMnxhPDw2fDYzJmVbdCsrXSk/cis9U3RyaW5nLmZyb21DaGFyQ29kZShvKTooby09NjU1MzYscis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxvPj4xMCw1NjMyMHwxMDIzJm8pKX19ZWxzZSByKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pfXJldHVybiByfWZ1bmN0aW9uIEcoZSx0KXtyZXR1cm4oZT4+Pj0wKT9CKHIoKSxlLHQpOlwiXCJ9ZnVuY3Rpb24gVihlLHQsbixyKXtpZighKDA8cikpcmV0dXJuIDA7dmFyIG89bj4+Pj0wO3I9bityLTE7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDsrK2kpe3ZhciBhPWUuY2hhckNvZGVBdChpKTtpZig1NTI5Njw9YSYmNTczNDM+PWEmJihhPTY1NTM2KygoMTAyMyZhKTw8MTApfDEwMjMmZS5jaGFyQ29kZUF0KCsraSkpLDEyNz49YSl7aWYobj49cilicmVhazt0W24rKz4+PjBdPWF9ZWxzZXtpZigyMDQ3Pj1hKXtpZihuKzE+PXIpYnJlYWs7dFtuKys+Pj4wXT0xOTJ8YT4+Nn1lbHNle2lmKDY1NTM1Pj1hKXtpZihuKzI+PXIpYnJlYWs7dFtuKys+Pj4wXT0yMjR8YT4+MTJ9ZWxzZXtpZihuKzM+PXIpYnJlYWs7dFtuKys+Pj4wXT0yNDB8YT4+MTgsdFtuKys+Pj4wXT0xMjh8YT4+MTImNjN9dFtuKys+Pj4wXT0xMjh8YT4+NiY2M310W24rKz4+PjBdPTEyOHw2MyZhfX1yZXR1cm4gdFtuPj4+MF09MCxuLW99ZnVuY3Rpb24geihlKXtmb3IodmFyIHQ9MCxuPTA7bjxlLmxlbmd0aDsrK24pe3ZhciByPWUuY2hhckNvZGVBdChuKTsxMjc+PXI/dCsrOjIwNDc+PXI/dCs9Mjo1NTI5Njw9ciYmNTczNDM+PXI/KHQrPTQsKytuKTp0Kz0zfXJldHVybiB0fWZ1bmN0aW9uIEgoZSl7Qz1lLHMuSEVBUDg9Uj1uZXcgSW50OEFycmF5KGUpLHMuSEVBUDE2PW5ldyBJbnQxNkFycmF5KGUpLHMuSEVBUDMyPU49bmV3IEludDMyQXJyYXkoZSkscy5IRUFQVTg9TT1uZXcgVWludDhBcnJheShlKSxzLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KGUpLHMuSEVBUFUzMj1GPW5ldyBVaW50MzJBcnJheShlKSxzLkhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheShlKSxzLkhFQVBGNjQ9TD1uZXcgRmxvYXQ2NEFycmF5KGUpfXgmJihDPXMuYnVmZmVyKTt2YXIgVz1zLklOSVRJQUxfTUVNT1JZfHwxNjc3NzIxNjtpZih4KUQ9cy53YXNtTWVtb3J5LEM9cy5idWZmZXI7ZWxzZSBpZihzLndhc21NZW1vcnkpRD1zLndhc21NZW1vcnk7ZWxzZSBpZighKChEPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6Vy82NTUzNixtYXhpbXVtOjY1NTM2LHNoYXJlZDohMH0pKS5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikpdGhyb3cgJChcInJlcXVlc3RlZCBhIHNoYXJlZCBXZWJBc3NlbWJseS5NZW1vcnkgYnV0IHRoZSByZXR1cm5lZCBidWZmZXIgaXMgbm90IGEgU2hhcmVkQXJyYXlCdWZmZXIsIGluZGljYXRpbmcgdGhhdCB3aGlsZSB0aGUgYnJvd3NlciBoYXMgU2hhcmVkQXJyYXlCdWZmZXIgaXQgZG9lcyBub3QgaGF2ZSBXZWJBc3NlbWJseSB0aHJlYWRzIHN1cHBvcnQgLSB5b3UgbWF5IG5lZWQgdG8gc2V0IGEgZmxhZ1wiKSx2JiZjb25zb2xlLmxvZyhcIihvbiBub2RlIHlvdSBtYXkgbmVlZDogLS1leHBlcmltZW50YWwtd2FzbS10aHJlYWRzIC0tZXhwZXJpbWVudGFsLXdhc20tYnVsay1tZW1vcnkgYW5kIGFsc28gdXNlIGEgcmVjZW50IHZlcnNpb24pXCIpLEVycm9yKFwiYmFkIG1lbW9yeVwiKTtEJiYoQz1ELmJ1ZmZlciksVz1DLmJ5dGVMZW5ndGgsSChDKTt2YXIgcSxLPVtdLFg9W10sWT1bXTtmdW5jdGlvbiBKKCl7dmFyIGU9cy5wcmVSdW4uc2hpZnQoKTtLLnVuc2hpZnQoZSl9dmFyIFosUT0wLGVlPW51bGwsdGU9bnVsbDtmdW5jdGlvbiBuZShlKXt0aHJvdyB4P3Bvc3RNZXNzYWdlKHtjbWQ6XCJvbkFib3J0XCIsYXJnOmV9KTpzLm9uQWJvcnQmJnMub25BYm9ydChlKSwkKGU9XCJBYm9ydGVkKFwiK2UrXCIpXCIpLGo9ITAsZT1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKGUrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLGwoZSksZX1mdW5jdGlvbiByZSgpe3JldHVybiBaLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpfWZ1bmN0aW9uIG9lKCl7dmFyIGU9Wjt0cnl7aWYoZT09WiYmRSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoRSk7aWYoZClyZXR1cm4gZChlKTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1jYXRjaChlKXtuZShlKX19Wj1cIm9ydC13YXNtLXRocmVhZGVkLndhc21cIixyZSgpfHwoWj1TKFopKTt2YXIgaWU9e307ZnVuY3Rpb24gYWUoZSl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiLHRoaXMubWVzc2FnZT1cIlByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoXCIrZStcIilcIix0aGlzLnN0YXR1cz1lfWZ1bmN0aW9uIHNlKGUpeyhlPXBlLkxhW2VdKXx8bmUoKSxwZS5YYShlKX1mdW5jdGlvbiB1ZShlKXt2YXIgdD1wZS5sYigpO2lmKCF0KXJldHVybiA2O3BlLlJhLnB1c2godCkscGUuTGFbZS5LYV09dCx0LkthPWUuS2E7dmFyIG49e2NtZDpcInJ1blwiLHN0YXJ0X3JvdXRpbmU6ZS5wYixhcmc6ZS5pYixwdGhyZWFkX3B0cjplLkthfTtyZXR1cm4gdC5RYT0oKT0+e24udGltZT1wZXJmb3JtYW5jZS5ub3coKSx0LnBvc3RNZXNzYWdlKG4sZS52Yil9LHQubG9hZGVkJiYodC5RYSgpLGRlbGV0ZSB0LlFhKSwwfWZ1bmN0aW9uIGxlKGUpe2lmKHgpcmV0dXJuIGplKDEsMSxlKTtQfHwocGUucWIoKSxzLm9uRXhpdCYmcy5vbkV4aXQoZSksaj0hMCkseShlLG5ldyBhZShlKSl9ZnVuY3Rpb24gY2UoZSx0KXtpZighdCYmeCl0aHJvdyBmZShlKSxcInVud2luZFwiO2xlKGUpfXZhciBwZT17T2E6W10sUmE6W10sJGE6W10sTGE6e30sVWE6ZnVuY3Rpb24oKXt4JiZwZS5tYigpfSx4YjpmdW5jdGlvbigpe30sbWI6ZnVuY3Rpb24oKXtwZS5yZWNlaXZlT2JqZWN0VHJhbnNmZXI9cGUub2IscGUudGhyZWFkSW5pdFRMUz1wZS5aYSxwZS5zZXRFeGl0U3RhdHVzPXBlLllhLFA9ITF9LFlhOmZ1bmN0aW9uKCl7fSxxYjpmdW5jdGlvbigpe2Zvcih2YXIgZSBvZiBPYmplY3QudmFsdWVzKHBlLkxhKSlwZS5YYShlKTtmb3IoZSBvZiBwZS5PYSllLnRlcm1pbmF0ZSgpO3BlLk9hPVtdfSxYYTpmdW5jdGlvbihlKXt2YXIgdD1lLkthO2RlbGV0ZSBwZS5MYVt0XSxwZS5PYS5wdXNoKGUpLHBlLlJhLnNwbGljZShwZS5SYS5pbmRleE9mKGUpLDEpLGUuS2E9MCxsdCh0KX0sb2I6ZnVuY3Rpb24oKXt9LFphOmZ1bmN0aW9uKCl7cGUuJGEuZm9yRWFjaCgoZT0+ZSgpKSl9LG5iOmZ1bmN0aW9uKGUsdCl7ZS5vbm1lc3NhZ2U9bj0+e3ZhciByPShuPW4uZGF0YSkuY21kO2lmKGUuS2EmJihwZS5rYj1lLkthKSxuLnRhcmdldFRocmVhZCYmbi50YXJnZXRUaHJlYWQhPXJ0KCkpe3ZhciBvPXBlLkxhW24ueWJdO28/by5wb3N0TWVzc2FnZShuLG4udHJhbnNmZXJMaXN0KTokKCdJbnRlcm5hbCBlcnJvciEgV29ya2VyIHNlbnQgYSBtZXNzYWdlIFwiJytyKydcIiB0byB0YXJnZXQgcHRocmVhZCAnK24udGFyZ2V0VGhyZWFkK1wiLCBidXQgdGhhdCB0aHJlYWQgbm8gbG9uZ2VyIGV4aXN0cyFcIil9ZWxzZVwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIj09PXI/Q2Uobi5xdWV1ZSk6XCJzcGF3blRocmVhZFwiPT09cj91ZShuKTpcImNsZWFudXBUaHJlYWRcIj09PXI/c2Uobi50aHJlYWQpOlwia2lsbFRocmVhZFwiPT09cj8obj1uLnRocmVhZCxyPXBlLkxhW25dLGRlbGV0ZSBwZS5MYVtuXSxyLnRlcm1pbmF0ZSgpLGx0KG4pLHBlLlJhLnNwbGljZShwZS5SYS5pbmRleE9mKHIpLDEpLHIuS2E9MCk6XCJjYW5jZWxUaHJlYWRcIj09PXI/cGUuTGFbbi50aHJlYWRdLnBvc3RNZXNzYWdlKHtjbWQ6XCJjYW5jZWxcIn0pOlwibG9hZGVkXCI9PT1yPyhlLmxvYWRlZD0hMCx0JiZ0KGUpLGUuUWEmJihlLlFhKCksZGVsZXRlIGUuUWEpKTpcInByaW50XCI9PT1yP0koXCJUaHJlYWQgXCIrbi50aHJlYWRJZCtcIjogXCIrbi50ZXh0KTpcInByaW50RXJyXCI9PT1yPyQoXCJUaHJlYWQgXCIrbi50aHJlYWRJZCtcIjogXCIrbi50ZXh0KTpcImFsZXJ0XCI9PT1yP2FsZXJ0KFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJzZXRpbW1lZGlhdGVcIj09PW4udGFyZ2V0P2UucG9zdE1lc3NhZ2Uobik6XCJvbkFib3J0XCI9PT1yP3Mub25BYm9ydCYmcy5vbkFib3J0KG4uYXJnKTpyJiYkKFwid29ya2VyIHNlbnQgYW4gdW5rbm93biBjb21tYW5kIFwiK3IpO3BlLmtiPXZvaWQgMH0sZS5vbmVycm9yPWU9Pnt0aHJvdyAkKFwid29ya2VyIHNlbnQgYW4gZXJyb3IhIFwiK2UuZmlsZW5hbWUrXCI6XCIrZS5saW5lbm8rXCI6IFwiK2UubWVzc2FnZSksZX0sdiYmKGUub24oXCJtZXNzYWdlXCIsKGZ1bmN0aW9uKHQpe2Uub25tZXNzYWdlKHtkYXRhOnR9KX0pKSxlLm9uKFwiZXJyb3JcIiwoZnVuY3Rpb24odCl7ZS5vbmVycm9yKHQpfSkpLGUub24oXCJkZXRhY2hlZEV4aXRcIiwoZnVuY3Rpb24oKXt9KSkpLGUucG9zdE1lc3NhZ2Uoe2NtZDpcImxvYWRcIix1cmxPckJsb2I6cy5tYWluU2NyaXB0VXJsT3JCbG9ifHxfc2NyaXB0RGlyLHdhc21NZW1vcnk6RCx3YXNtTW9kdWxlOmt9KX0saGI6ZnVuY3Rpb24oKXt2YXIgZT1TKFwib3J0LXdhc20tdGhyZWFkZWQud29ya2VyLmpzXCIpO3BlLk9hLnB1c2gobmV3IFdvcmtlcihlKSl9LGxiOmZ1bmN0aW9uKCl7cmV0dXJuIDA9PXBlLk9hLmxlbmd0aCYmKHBlLmhiKCkscGUubmIocGUuT2FbMF0pKSxwZS5PYS5wb3AoKX19O2Z1bmN0aW9uIGRlKGUpe2Zvcig7MDxlLmxlbmd0aDspZS5zaGlmdCgpKHMpfWZ1bmN0aW9uIGZlKGUpe2lmKHgpcmV0dXJuIGplKDIsMCxlKTt0cnl7Y2UoZSl9Y2F0Y2goZSl7ZSBpbnN0YW5jZW9mIGFlfHxcInVud2luZFwiPT1lfHx5KDEsZSl9fXMuUFRocmVhZD1wZSxzLmVzdGFibGlzaFN0YWNrU3BhY2U9ZnVuY3Rpb24oKXt2YXIgZT1ydCgpLHQ9bygpW2UrNDQ+PjI+Pj4wXTtlPW8oKVtlKzQ4Pj4yPj4+MF0scHQodCx0LWUpLGZ0KHQpfTt2YXIgaGUsZ2UsbWU9W107ZnVuY3Rpb24gYmUoZSl7dGhpcy5QYT1lLTI0LHRoaXMuZ2I9ZnVuY3Rpb24oZSl7aSgpW3RoaXMuUGErND4+Mj4+PjBdPWV9LHRoaXMuY2I9ZnVuY3Rpb24oZSl7aSgpW3RoaXMuUGErOD4+Mj4+PjBdPWV9LHRoaXMuZWI9ZnVuY3Rpb24oKXtvKClbdGhpcy5QYT4+Mj4+PjBdPTB9LHRoaXMuYmI9ZnVuY3Rpb24oKXt0KClbdGhpcy5QYSsxMj4+MD4+PjBdPTB9LHRoaXMuZmI9ZnVuY3Rpb24oKXt0KClbdGhpcy5QYSsxMz4+MD4+PjBdPTB9LHRoaXMuVWE9ZnVuY3Rpb24oZSx0KXt0aGlzLmFiKCksdGhpcy5nYihlKSx0aGlzLmNiKHQpLHRoaXMuZWIoKSx0aGlzLmJiKCksdGhpcy5mYigpfSx0aGlzLmFiPWZ1bmN0aW9uKCl7aSgpW3RoaXMuUGErMTY+PjI+Pj4wXT0wfX1mdW5jdGlvbiB5ZShlLHQsbixyKXtyZXR1cm4geD9qZSgzLDEsZSx0LG4scik6d2UoZSx0LG4scil9ZnVuY3Rpb24gd2UoZSx0LG4scil7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyKXJldHVybiAkKFwiQ3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFNoYXJlZEFycmF5QnVmZmVyLCBwdGhyZWFkcyBhcmUgbm90IGF2YWlsYWJsZSFcIiksNjt2YXIgbz1bXTtyZXR1cm4geCYmMD09PW8ubGVuZ3RoP3llKGUsdCxuLHIpOihlPXtwYjpuLEthOmUsaWI6cix2YjpvfSx4PyhlLndiPVwic3Bhd25UaHJlYWRcIixwb3N0TWVzc2FnZShlLG8pLDApOnVlKGUpKX1mdW5jdGlvbiBfZShlLHQsbil7cmV0dXJuIHg/amUoNCwxLGUsdCxuKTowfWZ1bmN0aW9uIHZlKGUsdCl7aWYoeClyZXR1cm4gamUoNSwxLGUsdCl9ZnVuY3Rpb24geGUoZSx0KXtpZih4KXJldHVybiBqZSg2LDEsZSx0KX1mdW5jdGlvbiBUZShlLHQsbil7aWYoeClyZXR1cm4gamUoNywxLGUsdCxuKX1mdW5jdGlvbiBTZShlLHQsbil7cmV0dXJuIHg/amUoOCwxLGUsdCxuKTowfWZ1bmN0aW9uIE9lKGUsdCl7aWYoeClyZXR1cm4gamUoOSwxLGUsdCl9ZnVuY3Rpb24gQWUoZSx0LG4pe2lmKHgpcmV0dXJuIGplKDEwLDEsZSx0LG4pfWZ1bmN0aW9uIEVlKGUsdCxuLHIpe2lmKHgpcmV0dXJuIGplKDExLDEsZSx0LG4scil9ZnVuY3Rpb24gSWUoZSx0LG4scil7aWYoeClyZXR1cm4gamUoMTIsMSxlLHQsbixyKX1mdW5jdGlvbiAkZShlLHQsbixyKXtpZih4KXJldHVybiBqZSgxMywxLGUsdCxuLHIpfWZ1bmN0aW9uIFBlKGUpe2lmKHgpcmV0dXJuIGplKDE0LDEsZSl9ZnVuY3Rpb24gRGUoZSx0KXtpZih4KXJldHVybiBqZSgxNSwxLGUsdCl9ZnVuY3Rpb24ga2UoZSx0LG4pe2lmKHgpcmV0dXJuIGplKDE2LDEsZSx0LG4pfWZ1bmN0aW9uIENlKGUpe0F0b21pY3Muc3RvcmUobygpLGU+PjIsMSkscnQoKSYmdXQoZSksQXRvbWljcy5jb21wYXJlRXhjaGFuZ2UobygpLGU+PjIsMSwwKX1mdW5jdGlvbiBSZShlKXtyZXR1cm4gaSgpW2U+Pj4yXSs0Mjk0OTY3Mjk2Km8oKVtlKzQ+Pj4yXX1mdW5jdGlvbiBNZShlLHQsbixyLG8saSl7cmV0dXJuIHg/amUoMTcsMSxlLHQsbixyLG8saSk6LTUyfWZ1bmN0aW9uIE5lKGUsdCxuLHIsbyxpKXtpZih4KXJldHVybiBqZSgxOCwxLGUsdCxuLHIsbyxpKX1mdW5jdGlvbiBGZShlKXt2YXIgbj16KGUpKzEscj1vdChuKTtyZXR1cm4gciYmVihlLHQoKSxyLG4pLHJ9ZnVuY3Rpb24gTGUoZSx0LG4pe2Z1bmN0aW9uIHIoZSl7cmV0dXJuKGU9ZS50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFwoKFtBLVphLXogXSspXFwpJC8pKT9lWzFdOlwiR01UXCJ9aWYoeClyZXR1cm4gamUoMTksMSxlLHQsbik7dmFyIGE9KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpLHM9bmV3IERhdGUoYSwwLDEpLHU9bmV3IERhdGUoYSw2LDEpO2E9cy5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBsPXUuZ2V0VGltZXpvbmVPZmZzZXQoKSxjPU1hdGgubWF4KGEsbCk7bygpW2U+PjI+Pj4wXT02MCpjLG8oKVt0Pj4yPj4+MF09TnVtYmVyKGEhPWwpLGU9cihzKSx0PXIodSksZT1GZShlKSx0PUZlKHQpLGw8YT8oaSgpW24+PjI+Pj4wXT1lLGkoKVtuKzQ+PjI+Pj4wXT10KTooaSgpW24+PjI+Pj4wXT10LGkoKVtuKzQ+PjI+Pj4wXT1lKX1mdW5jdGlvbiBqZShlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGgtMixyPWFyZ3VtZW50cztyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9ZHQoKTtyZXR1cm4gZT1lKCksZnQodCksZX0oKCgpPT57Zm9yKHZhciBvPWh0KDgqbiksaT1vPj4zLHM9MDtzPG47cysrKXt2YXIgdT1yWzIrc107YSgpW2krcz4+PjBdPXV9cmV0dXJuIHN0KGUsbixvLHQpfSkpfXMuaW52b2tlRW50cnlQb2ludD1mdW5jdGlvbihlLHQpe3ZhciBuPW1lW2VdO258fChlPj1tZS5sZW5ndGgmJihtZS5sZW5ndGg9ZSsxKSxtZVtlXT1uPXEuZ2V0KGUpKSxlPW4odCksUD9wZS5ZYShlKTpjdChlKX0scy5leGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlPUNlLGdlPXY/KCk9Pnt2YXIgZT1wcm9jZXNzLmhydGltZSgpO3JldHVybiAxZTMqZVswXStlWzFdLzFlNn06eD8oKT0+cGVyZm9ybWFuY2Uubm93KCktcy5fX3BlcmZvcm1hbmNlX25vd19jbG9ja19kcmlmdDooKT0+cGVyZm9ybWFuY2Uubm93KCk7dmFyIFVlLEJlPVtdLEdlPXt9O2Z1bmN0aW9uIFZlKCl7aWYoIVVlKXt2YXIgZSx0PXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOihcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOmJ8fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKGUgaW4gR2Updm9pZCAwPT09R2VbZV0/ZGVsZXRlIHRbZV06dFtlXT1HZVtlXTt2YXIgbj1bXTtmb3IoZSBpbiB0KW4ucHVzaChlK1wiPVwiK3RbZV0pO1VlPW59cmV0dXJuIFVlfWZ1bmN0aW9uIHplKGUsbil7aWYoeClyZXR1cm4gamUoMjAsMSxlLG4pO3ZhciByPTA7cmV0dXJuIFZlKCkuZm9yRWFjaCgoZnVuY3Rpb24obyxhKXt2YXIgcz1uK3I7Zm9yKGE9aSgpW2UrNCphPj4yPj4+MF09cyxzPTA7czxvLmxlbmd0aDsrK3MpdCgpW2ErKz4+MD4+PjBdPW8uY2hhckNvZGVBdChzKTt0KClbYT4+MD4+PjBdPTAscis9by5sZW5ndGgrMX0pKSwwfWZ1bmN0aW9uIEhlKGUsdCl7aWYoeClyZXR1cm4gamUoMjEsMSxlLHQpO3ZhciBuPVZlKCk7aSgpW2U+PjI+Pj4wXT1uLmxlbmd0aDt2YXIgcj0wO3JldHVybiBuLmZvckVhY2goKGZ1bmN0aW9uKGUpe3IrPWUubGVuZ3RoKzF9KSksaSgpW3Q+PjI+Pj4wXT1yLDB9ZnVuY3Rpb24gV2UoZSl7cmV0dXJuIHg/amUoMjIsMSxlKTo1Mn1mdW5jdGlvbiBxZShlLHQsbixyKXtyZXR1cm4geD9qZSgyMywxLGUsdCxuLHIpOjUyfWZ1bmN0aW9uIEtlKGUsdCxuLHIsbyl7cmV0dXJuIHg/amUoMjQsMSxlLHQsbixyLG8pOjcwfXZhciBYZT1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gWWUoZSx0LG4sbyl7aWYoeClyZXR1cm4gamUoMjUsMSxlLHQsbixvKTtmb3IodmFyIGE9MCxzPTA7czxuO3MrKyl7dmFyIHU9aSgpW3Q+PjI+Pj4wXSxsPWkoKVt0KzQ+PjI+Pj4wXTt0Kz04O2Zvcih2YXIgYz0wO2M8bDtjKyspe3ZhciBwPXIoKVt1K2M+Pj4wXSxkPVhlW2VdOzA9PT1wfHwxMD09PXA/KCgxPT09ZT9JOiQpKEIoZCwwKSksZC5sZW5ndGg9MCk6ZC5wdXNoKHApfWErPWx9cmV0dXJuIGkoKVtvPj4yPj4+MF09YSwwfWZ1bmN0aW9uIEplKGUpe3JldHVybiAwPT1lJTQmJigwIT1lJTEwMHx8MD09ZSU0MDApfXZhciBaZT1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLFFlPVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24gZXQoZSxuLHIsaSl7ZnVuY3Rpb24gYShlLHQsbil7Zm9yKGU9XCJudW1iZXJcIj09dHlwZW9mIGU/ZS50b1N0cmluZygpOmV8fFwiXCI7ZS5sZW5ndGg8dDspZT1uWzBdK2U7cmV0dXJuIGV9ZnVuY3Rpb24gcyhlLHQpe3JldHVybiBhKGUsdCxcIjBcIil9ZnVuY3Rpb24gdShlLHQpe2Z1bmN0aW9uIG4oZSl7cmV0dXJuIDA+ZT8tMTowPGU/MTowfXZhciByO3JldHVybiAwPT09KHI9bihlLmdldEZ1bGxZZWFyKCktdC5nZXRGdWxsWWVhcigpKSkmJjA9PT0ocj1uKGUuZ2V0TW9udGgoKS10LmdldE1vbnRoKCkpKSYmKHI9bihlLmdldERhdGUoKS10LmdldERhdGUoKSkpLHJ9ZnVuY3Rpb24gbChlKXtzd2l0Y2goZS5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiBlO2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBjKGUpe3ZhciB0PWUuTWE7Zm9yKGU9bmV3IERhdGUobmV3IERhdGUoZS5OYSsxOTAwLDAsMSkuZ2V0VGltZSgpKTswPHQ7KXt2YXIgbj1lLmdldE1vbnRoKCkscj0oSmUoZS5nZXRGdWxsWWVhcigpKT9aZTpRZSlbbl07aWYoISh0PnItZS5nZXREYXRlKCkpKXtlLnNldERhdGUoZS5nZXREYXRlKCkrdCk7YnJlYWt9dC09ci1lLmdldERhdGUoKSsxLGUuc2V0RGF0ZSgxKSwxMT5uP2Uuc2V0TW9udGgobisxKTooZS5zZXRNb250aCgwKSxlLnNldEZ1bGxZZWFyKGUuZ2V0RnVsbFllYXIoKSsxKSl9cmV0dXJuIG49bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpKzEsMCw0KSx0PWwobmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsNCkpLG49bChuKSwwPj11KHQsZSk/MD49dShuLGUpP2UuZ2V0RnVsbFllYXIoKSsxOmUuZ2V0RnVsbFllYXIoKTplLmdldEZ1bGxZZWFyKCktMX12YXIgcD1vKClbaSs0MD4+Mj4+PjBdO2Zvcih2YXIgZCBpbiBpPXt0YjpvKClbaT4+Mj4+PjBdLHNiOm8oKVtpKzQ+PjI+Pj4wXSxTYTpvKClbaSs4Pj4yPj4+MF0sVmE6bygpW2krMTI+PjI+Pj4wXSxUYTpvKClbaSsxNj4+Mj4+PjBdLE5hOm8oKVtpKzIwPj4yPj4+MF0sSmE6bygpW2krMjQ+PjI+Pj4wXSxNYTpvKClbaSsyOD4+Mj4+PjBdLHpiOm8oKVtpKzMyPj4yPj4+MF0scmI6bygpW2krMzY+PjI+Pj4wXSx1YjpwP0cocCk6XCJcIn0scj1HKHIpLHA9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifSlyPXIucmVwbGFjZShuZXcgUmVnRXhwKGQsXCJnXCIpLHBbZF0pO3ZhciBmPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksaD1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7Zm9yKGQgaW4gcD17XCIlYVwiOmZ1bmN0aW9uKGUpe3JldHVybiBmW2UuSmFdLnN1YnN0cmluZygwLDMpfSxcIiVBXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGZbZS5KYV19LFwiJWJcIjpmdW5jdGlvbihlKXtyZXR1cm4gaFtlLlRhXS5zdWJzdHJpbmcoMCwzKX0sXCIlQlwiOmZ1bmN0aW9uKGUpe3JldHVybiBoW2UuVGFdfSxcIiVDXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHMoKGUuTmErMTkwMCkvMTAwfDAsMil9LFwiJWRcIjpmdW5jdGlvbihlKXtyZXR1cm4gcyhlLlZhLDIpfSxcIiVlXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGEoZS5WYSwyLFwiIFwiKX0sXCIlZ1wiOmZ1bmN0aW9uKGUpe3JldHVybiBjKGUpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVHXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGMoZSl9LFwiJUhcIjpmdW5jdGlvbihlKXtyZXR1cm4gcyhlLlNhLDIpfSxcIiVJXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIDA9PShlPWUuU2EpP2U9MTI6MTI8ZSYmKGUtPTEyKSxzKGUsMil9LFwiJWpcIjpmdW5jdGlvbihlKXtmb3IodmFyIHQ9MCxuPTA7bjw9ZS5UYS0xO3QrPShKZShlLk5hKzE5MDApP1plOlFlKVtuKytdKTtyZXR1cm4gcyhlLlZhK3QsMyl9LFwiJW1cIjpmdW5jdGlvbihlKXtyZXR1cm4gcyhlLlRhKzEsMil9LFwiJU1cIjpmdW5jdGlvbihlKXtyZXR1cm4gcyhlLnNiLDIpfSxcIiVuXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcblwifSxcIiVwXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIDA8PWUuU2EmJjEyPmUuU2E/XCJBTVwiOlwiUE1cIn0sXCIlU1wiOmZ1bmN0aW9uKGUpe3JldHVybiBzKGUudGIsMil9LFwiJXRcIjpmdW5jdGlvbigpe3JldHVyblwiXFx0XCJ9LFwiJXVcIjpmdW5jdGlvbihlKXtyZXR1cm4gZS5KYXx8N30sXCIlVVwiOmZ1bmN0aW9uKGUpe3JldHVybiBzKE1hdGguZmxvb3IoKGUuTWErNy1lLkphKS83KSwyKX0sXCIlVlwiOmZ1bmN0aW9uKGUpe3ZhciB0PU1hdGguZmxvb3IoKGUuTWErNy0oZS5KYSs2KSU3KS83KTtpZigyPj0oZS5KYSszNzEtZS5NYS0yKSU3JiZ0KyssdCk1Mz09dCYmKDQ9PShuPShlLkphKzM3MS1lLk1hKSU3KXx8Mz09biYmSmUoZS5OYSl8fCh0PTEpKTtlbHNle3Q9NTI7dmFyIG49KGUuSmErNy1lLk1hLTEpJTc7KDQ9PW58fDU9PW4mJkplKGUuTmElNDAwLTEpKSYmdCsrfXJldHVybiBzKHQsMil9LFwiJXdcIjpmdW5jdGlvbihlKXtyZXR1cm4gZS5KYX0sXCIlV1wiOmZ1bmN0aW9uKGUpe3JldHVybiBzKE1hdGguZmxvb3IoKGUuTWErNy0oZS5KYSs2KSU3KS83KSwyKX0sXCIleVwiOmZ1bmN0aW9uKGUpe3JldHVybihlLk5hKzE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVZXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuTmErMTkwMH0sXCIlelwiOmZ1bmN0aW9uKGUpe3ZhciB0PTA8PShlPWUucmIpO3JldHVybiBlPU1hdGguYWJzKGUpLzYwLCh0P1wiK1wiOlwiLVwiKStTdHJpbmcoXCIwMDAwXCIrKGUvNjAqMTAwK2UlNjApKS5zbGljZSgtNCl9LFwiJVpcIjpmdW5jdGlvbihlKXtyZXR1cm4gZS51Yn0sXCIlJVwiOmZ1bmN0aW9uKCl7cmV0dXJuXCIlXCJ9fSxyPXIucmVwbGFjZSgvJSUvZyxcIlxcMFxcMFwiKSxwKXIuaW5jbHVkZXMoZCkmJihyPXIucmVwbGFjZShuZXcgUmVnRXhwKGQsXCJnXCIpLHBbZF0oaSkpKTtyZXR1cm4gZD1mdW5jdGlvbihlKXt2YXIgdD1BcnJheSh6KGUpKzEpO3JldHVybiBWKGUsdCwwLHQubGVuZ3RoKSx0fShyPXIucmVwbGFjZSgvXFwwXFwwL2csXCIlXCIpKSxkLmxlbmd0aD5uPzA6KGZ1bmN0aW9uKGUsbil7dCgpLnNldChlLG4+Pj4wKX0oZCxlKSxkLmxlbmd0aC0xKX1wZS5VYSgpO3ZhciB0dD1bbnVsbCxsZSxmZSx5ZSxfZSx2ZSx4ZSxUZSxTZSxPZSxBZSxFZSxJZSwkZSxQZSxEZSxrZSxNZSxOZSxMZSx6ZSxIZSxXZSxxZSxLZSxZZV0sbnQ9e2I6ZnVuY3Rpb24oZSl7cmV0dXJuIG90KGUrMjQpKzI0fSxjOmZ1bmN0aW9uKGUsdCxuKXt0aHJvdyBuZXcgYmUoZSkuVWEodCxuKSxlfSxMOmZ1bmN0aW9uKGUpe2l0KGUsIV8sMSwhdykscGUuWmEoKX0sbDpmdW5jdGlvbihlKXt4P3Bvc3RNZXNzYWdlKHtjbWQ6XCJjbGVhbnVwVGhyZWFkXCIsdGhyZWFkOmV9KTpzZShlKX0sRDp3ZSxpOl9lLFI6dmUsejp4ZSxCOlRlLFQ6U2UsUDpPZSxJOkFlLE86RWUscDpJZSxBOiRlLHg6UGUsUTpEZSx5OmtlLHI6ZnVuY3Rpb24oKXt9LGo6ZnVuY3Rpb24oKXtuZShcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxzOmZ1bmN0aW9uKCl7bmUoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0scTpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfSxFOmZ1bmN0aW9uKCl7cmV0dXJuIDIwOTcxNTJ9LFY6ZnVuY3Rpb24oKXtyZXR1cm4hMH0sRjpmdW5jdGlvbihlLHQsbixyKXtpZihlPT10KXNldFRpbWVvdXQoKCgpPT5DZShyKSkpO2Vsc2UgaWYoeClwb3N0TWVzc2FnZSh7dGFyZ2V0VGhyZWFkOmUsY21kOlwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIixxdWV1ZTpyfSk7ZWxzZXtpZighKGU9cGUuTGFbZV0pKXJldHVybjtlLnBvc3RNZXNzYWdlKHtjbWQ6XCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiLHF1ZXVlOnJ9KX1yZXR1cm4gMX0sSzpmdW5jdGlvbigpe3JldHVybi0xfSxXOmZ1bmN0aW9uKGUsdCl7ZT1uZXcgRGF0ZSgxZTMqUmUoZSkpLG8oKVt0Pj4yPj4+MF09ZS5nZXRVVENTZWNvbmRzKCksbygpW3QrND4+Mj4+PjBdPWUuZ2V0VVRDTWludXRlcygpLG8oKVt0Kzg+PjI+Pj4wXT1lLmdldFVUQ0hvdXJzKCksbygpW3QrMTI+PjI+Pj4wXT1lLmdldFVUQ0RhdGUoKSxvKClbdCsxNj4+Mj4+PjBdPWUuZ2V0VVRDTW9udGgoKSxvKClbdCsyMD4+Mj4+PjBdPWUuZ2V0VVRDRnVsbFllYXIoKS0xOTAwLG8oKVt0KzI0Pj4yPj4+MF09ZS5nZXRVVENEYXkoKSxlPShlLmdldFRpbWUoKS1EYXRlLlVUQyhlLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwLG8oKVt0KzI4Pj4yPj4+MF09ZX0sWDpmdW5jdGlvbihlLHQpe2U9bmV3IERhdGUoMWUzKlJlKGUpKSxvKClbdD4+Mj4+PjBdPWUuZ2V0U2Vjb25kcygpLG8oKVt0KzQ+PjI+Pj4wXT1lLmdldE1pbnV0ZXMoKSxvKClbdCs4Pj4yPj4+MF09ZS5nZXRIb3VycygpLG8oKVt0KzEyPj4yPj4+MF09ZS5nZXREYXRlKCksbygpW3QrMTY+PjI+Pj4wXT1lLmdldE1vbnRoKCksbygpW3QrMjA+PjI+Pj4wXT1lLmdldEZ1bGxZZWFyKCktMTkwMCxvKClbdCsyND4+Mj4+PjBdPWUuZ2V0RGF5KCk7dmFyIG49bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMSkscj0oZS5nZXRUaW1lKCktbi5nZXRUaW1lKCkpLzg2NGU1fDA7bygpW3QrMjg+PjI+Pj4wXT1yLG8oKVt0KzM2Pj4yPj4+MF09LTYwKmUuZ2V0VGltZXpvbmVPZmZzZXQoKSxyPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksZT0wfChyIT0obj1uLmdldFRpbWV6b25lT2Zmc2V0KCkpJiZlLmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKG4scikpLG8oKVt0KzMyPj4yPj4+MF09ZX0sWTpmdW5jdGlvbihlKXt2YXIgdD1uZXcgRGF0ZShvKClbZSsyMD4+Mj4+PjBdKzE5MDAsbygpW2UrMTY+PjI+Pj4wXSxvKClbZSsxMj4+Mj4+PjBdLG8oKVtlKzg+PjI+Pj4wXSxvKClbZSs0Pj4yPj4+MF0sbygpW2U+PjI+Pj4wXSwwKSxuPW8oKVtlKzMyPj4yPj4+MF0scj10LmdldFRpbWV6b25lT2Zmc2V0KCksaT1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwxKSxhPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCkscz1pLmdldFRpbWV6b25lT2Zmc2V0KCksdT1NYXRoLm1pbihzLGEpO3JldHVybiAwPm4/bygpW2UrMzI+PjI+Pj4wXT1OdW1iZXIoYSE9cyYmdT09cik6MDxuIT0odT09cikmJihhPU1hdGgubWF4KHMsYSksdC5zZXRUaW1lKHQuZ2V0VGltZSgpKzZlNCooKDA8bj91OmEpLXIpKSksbygpW2UrMjQ+PjI+Pj4wXT10LmdldERheSgpLG49KHQuZ2V0VGltZSgpLWkuZ2V0VGltZSgpKS84NjRlNXwwLG8oKVtlKzI4Pj4yPj4+MF09bixvKClbZT4+Mj4+PjBdPXQuZ2V0U2Vjb25kcygpLG8oKVtlKzQ+PjI+Pj4wXT10LmdldE1pbnV0ZXMoKSxvKClbZSs4Pj4yPj4+MF09dC5nZXRIb3VycygpLG8oKVtlKzEyPj4yPj4+MF09dC5nZXREYXRlKCksbygpW2UrMTY+PjI+Pj4wXT10LmdldE1vbnRoKCksdC5nZXRUaW1lKCkvMWUzfDB9LEc6TWUsSDpOZSxaOmZ1bmN0aW9uIGUodCxuLHIpe2UuamJ8fChlLmpiPSEwLExlKHQsbixyKSl9LGQ6ZnVuY3Rpb24oKXtuZShcIlwiKX0sbTpmdW5jdGlvbigpe2lmKCF2JiYhXyl7dmFyIGU9XCJCbG9ja2luZyBvbiB0aGUgbWFpbiB0aHJlYWQgaXMgdmVyeSBkYW5nZXJvdXMsIHNlZSBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvcG9ydGluZy9wdGhyZWFkcy5odG1sI2Jsb2NraW5nLW9uLXRoZS1tYWluLWJyb3dzZXItdGhyZWFkXCI7aGV8fChoZT17fSksaGVbZV18fChoZVtlXT0xLHYmJihlPVwid2FybmluZzogXCIrZSksJChlKSl9fSx3OmZ1bmN0aW9uKCl7cmV0dXJuIDQyOTQ5MDE3NjB9LGY6Z2UsUzpmdW5jdGlvbihlLHQsbil7cigpLmNvcHlXaXRoaW4oZT4+PjAsdD4+PjAsdCtuPj4+MCl9LGc6ZnVuY3Rpb24oKXtyZXR1cm4gdj9uKDM5OTMpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3l9LEo6ZnVuY3Rpb24oZSx0LG4pe0JlLmxlbmd0aD10LG4+Pj0zO2Zvcih2YXIgcj0wO3I8dDtyKyspQmVbcl09YSgpW24rcj4+PjBdO3JldHVybigwPmU/aWVbLWUtMV06dHRbZV0pLmFwcGx5KG51bGwsQmUpfSx2OmZ1bmN0aW9uKGUpe3ZhciB0PXIoKS5sZW5ndGg7aWYoKGU+Pj49MCk8PXR8fDQyOTQ5MDE3NjA8ZSlyZXR1cm4hMTtmb3IodmFyIG49MTs0Pj1uO24qPTIpe3ZhciBvPXQqKDErLjIvbik7bz1NYXRoLm1pbihvLGUrMTAwNjYzMjk2KTt2YXIgaT1NYXRoO289TWF0aC5tYXgoZSxvKSxpPWkubWluLmNhbGwoaSw0Mjk0OTAxNzYwLG8rKDY1NTM2LW8lNjU1MzYpJTY1NTM2KTtlOnt0cnl7RC5ncm93KGktQy5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTYpLEgoRC5idWZmZXIpO3ZhciBhPTE7YnJlYWsgZX1jYXRjaChlKXt9YT12b2lkIDB9aWYoYSlyZXR1cm4hMH1yZXR1cm4hMX0sVTpmdW5jdGlvbigpe3Rocm93XCJ1bndpbmRcIn0sTTp6ZSxOOkhlLGs6Y2UsaDpXZSxvOnFlLHQ6S2UsbjpZZSx1OmZ1bmN0aW9uIGUocixvKXtlLldhfHwoZS5XYT1mdW5jdGlvbigpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBjcnlwdG8mJlwiZnVuY3Rpb25cIj09dHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpe3ZhciBlPW5ldyBVaW50OEFycmF5KDEpO3JldHVybigpPT4oY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhlKSxlWzBdKX1pZih2KXRyeXt2YXIgdD1uKDc2MCk7cmV0dXJuKCk9PnQucmFuZG9tQnl0ZXMoMSlbMF19Y2F0Y2goZSl7fXJldHVybigpPT5uZShcInJhbmRvbURldmljZVwiKX0oKSk7Zm9yKHZhciBpPTA7aTxvO2krKyl0KClbcitpPj4wPj4+MF09ZS5XYSgpO3JldHVybiAwfSxhOkR8fHMud2FzbU1lbW9yeSxDOmV0LGU6ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIGV0KGUsdCxuLHIpfX07IWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3MuYXNtPWUuZXhwb3J0cyxwZS4kYS5wdXNoKHMuYXNtLndhKSxxPXMuYXNtLnphLFgudW5zaGlmdChzLmFzbS5fKSxrPXQseHx8KFEtLSxzLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJnMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhRKSwwPT1RJiYobnVsbCE9PWVlJiYoY2xlYXJJbnRlcnZhbChlZSksZWU9bnVsbCksdGUmJihlPXRlLHRlPW51bGwsZSgpKSkpfWZ1bmN0aW9uIHQodCl7ZSh0Lmluc3RhbmNlLHQubW9kdWxlKX1mdW5jdGlvbiBuKGUpe3JldHVybiBmdW5jdGlvbigpe2lmKCFFJiYod3x8Xykpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGZldGNoJiYhWi5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSlyZXR1cm4gZmV0Y2goWix7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24oZSl7aWYoIWUub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiK1orXCInXCI7cmV0dXJuIGUuYXJyYXlCdWZmZXIoKX0pKS5jYXRjaCgoZnVuY3Rpb24oKXtyZXR1cm4gb2UoKX0pKTtpZihwKXJldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSx0KXtwKFosKGZ1bmN0aW9uKHQpe2UobmV3IFVpbnQ4QXJyYXkodCkpfSksdCl9KSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIG9lKCl9KSl9KCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGUscil9KSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIGV9KSkudGhlbihlLChmdW5jdGlvbihlKXskKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrZSksbmUoZSl9KSl9dmFyIHI9e2E6bnR9O2lmKHh8fChRKysscy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZzLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoUSkpLHMuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gcy5pbnN0YW50aWF0ZVdhc20ocixlKX1jYXRjaChlKXtyZXR1cm4gJChcIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6IFwiK2UpLCExfShFfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ3x8cmUoKXx8Wi5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8dnx8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/bih0KTpmZXRjaChaLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoZSxyKS50aGVuKHQsKGZ1bmN0aW9uKGUpe3JldHVybiAkKFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK2UpLCQoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxuKHQpfSkpfSkpKS5jYXRjaChsKX0oKSxzLl9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybihzLl9fX3dhc21fY2FsbF9jdG9ycz1zLmFzbS5fKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEluaXQ9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0SW5pdD1zLmFzbS4kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPXMuYXNtLmFhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPXMuYXNtLmJhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9cy5hc20uY2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1zLmFzbS5kYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRDcmVhdGVTZXNzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydENyZWF0ZVNlc3Npb249cy5hc20uZWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0UmVsZWFzZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0UmVsZWFzZVNlc3Npb249cy5hc20uZmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0SW5wdXRDb3VudD1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRJbnB1dENvdW50PXMuYXNtLmdhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldE91dHB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEdldE91dHB1dENvdW50PXMuYXNtLmhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldElucHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRJbnB1dE5hbWU9cy5hc20uaWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0T3V0cHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRPdXRwdXROYW1lPXMuYXNtLmphKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0RnJlZT1zLmFzbS5rYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRDcmVhdGVUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0Q3JlYXRlVGVuc29yPXMuYXNtLmxhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldFRlbnNvckRhdGE9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0R2V0VGVuc29yRGF0YT1zLmFzbS5tYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRSZWxlYXNlVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VUZW5zb3I9cy5hc20ubmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybihzLl9PcnRDcmVhdGVSdW5PcHRpb25zPXMuYXNtLm9hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PXMuYXNtLnBhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydFJlbGVhc2VSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VSdW5PcHRpb25zPXMuYXNtLnFhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydFJ1bj1mdW5jdGlvbigpe3JldHVybihzLl9PcnRSdW49cy5hc20ucmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0RW5kUHJvZmlsaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEVuZFByb2ZpbGluZz1zLmFzbS5zYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgcnQ9cy5fcHRocmVhZF9zZWxmPWZ1bmN0aW9uKCl7cmV0dXJuKHJ0PXMuX3B0aHJlYWRfc2VsZj1zLmFzbS50YSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxvdD1zLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4ob3Q9cy5fbWFsbG9jPXMuYXNtLnVhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3MuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fZnJlZT1zLmFzbS52YSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9fZW1zY3JpcHRlbl90bHNfaW5pdD1mdW5jdGlvbigpe3JldHVybihzLl9fZW1zY3JpcHRlbl90bHNfaW5pdD1zLmFzbS53YSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgaXQ9cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4oaXQ9cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQ9cy5hc20ueGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9cy5hc20ueWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIGF0LHN0PXMuX2Vtc2NyaXB0ZW5fcnVuX2luX21haW5fcnVudGltZV90aHJlYWRfanM9ZnVuY3Rpb24oKXtyZXR1cm4oc3Q9cy5fZW1zY3JpcHRlbl9ydW5faW5fbWFpbl9ydW50aW1lX3RocmVhZF9qcz1zLmFzbS5BYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1dD1zLl9fZW1zY3JpcHRlbl9wcm94eV9leGVjdXRlX3Rhc2tfcXVldWU9ZnVuY3Rpb24oKXtyZXR1cm4odXQ9cy5fX2Vtc2NyaXB0ZW5fcHJveHlfZXhlY3V0ZV90YXNrX3F1ZXVlPXMuYXNtLkJhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGx0PXMuX19lbXNjcmlwdGVuX3RocmVhZF9mcmVlX2RhdGE9ZnVuY3Rpb24oKXtyZXR1cm4obHQ9cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2ZyZWVfZGF0YT1zLmFzbS5DYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxjdD1zLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD1mdW5jdGlvbigpe3JldHVybihjdD1zLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD1zLmFzbS5EYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxwdD1zLl9lbXNjcmlwdGVuX3N0YWNrX3NldF9saW1pdHM9ZnVuY3Rpb24oKXtyZXR1cm4ocHQ9cy5fZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzPXMuYXNtLkVhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGR0PXMuc3RhY2tTYXZlPWZ1bmN0aW9uKCl7cmV0dXJuKGR0PXMuc3RhY2tTYXZlPXMuYXNtLkZhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGZ0PXMuc3RhY2tSZXN0b3JlPWZ1bmN0aW9uKCl7cmV0dXJuKGZ0PXMuc3RhY2tSZXN0b3JlPXMuYXNtLkdhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGh0PXMuc3RhY2tBbGxvYz1mdW5jdGlvbigpe3JldHVybihodD1zLnN0YWNrQWxsb2M9cy5hc20uSGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07ZnVuY3Rpb24gZ3QoKXtmdW5jdGlvbiBlKCl7aWYoIWF0JiYoYXQ9ITAscy5jYWxsZWRSdW49ITAsIWopJiYoeHx8ZGUoWCksdShzKSxzLm9uUnVudGltZUluaXRpYWxpemVkJiZzLm9uUnVudGltZUluaXRpYWxpemVkKCksIXgpKXtpZihzLnBvc3RSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHMucG9zdFJ1biYmKHMucG9zdFJ1bj1bcy5wb3N0UnVuXSk7cy5wb3N0UnVuLmxlbmd0aDspe3ZhciBlPXMucG9zdFJ1bi5zaGlmdCgpO1kudW5zaGlmdChlKX1kZShZKX19aWYoISgwPFEpKWlmKHgpdShzKSx4fHxkZShYKSxwb3N0TWVzc2FnZSh7Y21kOlwibG9hZGVkXCJ9KTtlbHNle2lmKHMucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBzLnByZVJ1biYmKHMucHJlUnVuPVtzLnByZVJ1bl0pO3MucHJlUnVuLmxlbmd0aDspSigpO2RlKEspLDA8UXx8KHMuc2V0U3RhdHVzPyhzLnNldFN0YXR1cyhcIlJ1bm5pbmcuLi5cIiksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KChmdW5jdGlvbigpe3Muc2V0U3RhdHVzKFwiXCIpfSksMSksZSgpfSksMSkpOmUoKSl9fWlmKHMuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1mdW5jdGlvbigpe3JldHVybihzLl9fX2N4YV9pc19wb2ludGVyX3R5cGU9cy5hc20uSWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5VVEY4VG9TdHJpbmc9RyxzLnN0cmluZ1RvVVRGOD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIFYoZSxyKCksdCxuKX0scy5sZW5ndGhCeXRlc1VURjg9eixzLmtlZXBSdW50aW1lQWxpdmU9ZnVuY3Rpb24oKXtyZXR1cm4gUH0scy53YXNtTWVtb3J5PUQscy5zdGFja1NhdmU9ZHQscy5zdGFja1Jlc3RvcmU9ZnQscy5zdGFja0FsbG9jPWh0LHMuRXhpdFN0YXR1cz1hZSxzLlBUaHJlYWQ9cGUsdGU9ZnVuY3Rpb24gZSgpe2F0fHxndCgpLGF0fHwodGU9ZSl9LHMucHJlSW5pdClmb3IoXCJmdW5jdGlvblwiPT10eXBlb2Ygcy5wcmVJbml0JiYocy5wcmVJbml0PVtzLnByZUluaXRdKTswPHMucHJlSW5pdC5sZW5ndGg7KXMucHJlSW5pdC5wb3AoKSgpO3JldHVybiBndCgpLGUucmVhZHl9KTtlLmV4cG9ydHM9cn0sOTMyOihlLHQsbik9Pnt2YXIgX3NjcmlwdERpcixyPShfc2NyaXB0RGlyPShfc2NyaXB0RGlyPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDApfHxcIi9pbmRleC5qc1wiLGZ1bmN0aW9uKGUpe3ZhciB0LHIsbztlPWV8fHt9LHR8fCh0PXZvaWQgMCE9PWU/ZTp7fSksdC5yZWFkeT1uZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSx0KXtyPWUsbz10fSkpO3ZhciBpLGEscyx1LGwsYyxwPU9iamVjdC5hc3NpZ24oe30sdCksZD1cIi4vdGhpcy5wcm9ncmFtXCIsZj0oZSx0KT0+e3Rocm93IHR9LGg9XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyxnPVwiZnVuY3Rpb25cIj09dHlwZW9mIGltcG9ydFNjcmlwdHMsbT1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUsYj1cIlwiO20/KGI9Zz9uKDkwOCkuZGlybmFtZShiKStcIi9cIjpcIi8vXCIsYz0oKT0+e2x8fCh1PW4oMTM4NCksbD1uKDkwOCkpfSxpPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGMoKSxlPWwubm9ybWFsaXplKGUpLHUucmVhZEZpbGVTeW5jKGUsdD92b2lkIDA6XCJ1dGY4XCIpfSxzPWU9PigoZT1pKGUsITApKS5idWZmZXJ8fChlPW5ldyBVaW50OEFycmF5KGUpKSxlKSxhPShlLHQsbik9PntjKCksZT1sLm5vcm1hbGl6ZShlKSx1LnJlYWRGaWxlKGUsKGZ1bmN0aW9uKGUscil7ZT9uKGUpOnQoci5idWZmZXIpfSkpfSwxPHByb2Nlc3MuYXJndi5sZW5ndGgmJihkPXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpKSxwcm9jZXNzLmFyZ3Yuc2xpY2UoMikscHJvY2Vzcy5vbihcInVuY2F1Z2h0RXhjZXB0aW9uXCIsKGZ1bmN0aW9uKGUpe2lmKCEoZSBpbnN0YW5jZW9mIHEpKXRocm93IGV9KSkscHJvY2Vzcy5vbihcInVuaGFuZGxlZFJlamVjdGlvblwiLChmdW5jdGlvbihlKXt0aHJvdyBlfSkpLGY9KGUsdCk9PntpZih2KXRocm93IHByb2Nlc3MuZXhpdENvZGU9ZSx0O3QgaW5zdGFuY2VvZiBxfHxfKFwiZXhpdGluZyBkdWUgdG8gZXhjZXB0aW9uOiBcIit0KSxwcm9jZXNzLmV4aXQoZSl9LHQuaW5zcGVjdD1mdW5jdGlvbigpe3JldHVyblwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn0pOihofHxnKSYmKGc/Yj1zZWxmLmxvY2F0aW9uLmhyZWY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoYj1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksX3NjcmlwdERpciYmKGI9X3NjcmlwdERpciksYj0wIT09Yi5pbmRleE9mKFwiYmxvYjpcIik/Yi5zdWJzdHIoMCxiLnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOlwiXCIsaT1lPT57dmFyIHQ9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB0Lm9wZW4oXCJHRVRcIixlLCExKSx0LnNlbmQobnVsbCksdC5yZXNwb25zZVRleHR9LGcmJihzPWU9Pnt2YXIgdD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHQub3BlbihcIkdFVFwiLGUsITEpLHQucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIix0LnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkodC5yZXNwb25zZSl9KSxhPShlLHQsbik9Pnt2YXIgcj1uZXcgWE1MSHR0cFJlcXVlc3Q7ci5vcGVuKFwiR0VUXCIsZSwhMCksci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLHIub25sb2FkPSgpPT57MjAwPT1yLnN0YXR1c3x8MD09ci5zdGF0dXMmJnIucmVzcG9uc2U/dChyLnJlc3BvbnNlKTpuKCl9LHIub25lcnJvcj1uLHIuc2VuZChudWxsKX0pO3ZhciB5LHc9dC5wcmludHx8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxfPXQucHJpbnRFcnJ8fGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO09iamVjdC5hc3NpZ24odCxwKSxwPW51bGwsdC50aGlzUHJvZ3JhbSYmKGQ9dC50aGlzUHJvZ3JhbSksdC5xdWl0JiYoZj10LnF1aXQpLHQud2FzbUJpbmFyeSYmKHk9dC53YXNtQmluYXJ5KTt2YXIgdj10Lm5vRXhpdFJ1bnRpbWV8fCEwO1wib2JqZWN0XCIhPXR5cGVvZiBXZWJBc3NlbWJseSYmVihcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIHgsVCxTLE8sQSxFLEk9ITEsJD1cInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDA7ZnVuY3Rpb24gUChlLHQsbil7dmFyIHI9KHQ+Pj49MCkrbjtmb3Iobj10O2Vbbl0mJiEobj49cik7KSsrbjtpZigxNjxuLXQmJmUuYnVmZmVyJiYkKXJldHVybiAkLmRlY29kZShlLnN1YmFycmF5KHQsbikpO2ZvcihyPVwiXCI7dDxuOyl7dmFyIG89ZVt0KytdO2lmKDEyOCZvKXt2YXIgaT02MyZlW3QrK107aWYoMTkyPT0oMjI0Jm8pKXIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMxJm8pPDw2fGkpO2Vsc2V7dmFyIGE9NjMmZVt0KytdOzY1NTM2PihvPTIyND09KDI0MCZvKT8oMTUmbyk8PDEyfGk8PDZ8YTooNyZvKTw8MTh8aTw8MTJ8YTw8Nnw2MyZlW3QrK10pP3IrPVN0cmluZy5mcm9tQ2hhckNvZGUobyk6KG8tPTY1NTM2LHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8bz4+MTAsNTYzMjB8MTAyMyZvKSl9fWVsc2Ugcis9U3RyaW5nLmZyb21DaGFyQ29kZShvKX1yZXR1cm4gcn1mdW5jdGlvbiBEKGUsdCl7cmV0dXJuKGU+Pj49MCk/UChPLGUsdCk6XCJcIn1mdW5jdGlvbiBrKGUsdCxuLHIpe2lmKCEoMDxyKSlyZXR1cm4gMDt2YXIgbz1uPj4+PTA7cj1uK3ItMTtmb3IodmFyIGk9MDtpPGUubGVuZ3RoOysraSl7dmFyIGE9ZS5jaGFyQ29kZUF0KGkpO2lmKDU1Mjk2PD1hJiY1NzM0Mz49YSYmKGE9NjU1MzYrKCgxMDIzJmEpPDwxMCl8MTAyMyZlLmNoYXJDb2RlQXQoKytpKSksMTI3Pj1hKXtpZihuPj1yKWJyZWFrO3RbbisrPj4+MF09YX1lbHNle2lmKDIwNDc+PWEpe2lmKG4rMT49cilicmVhazt0W24rKz4+PjBdPTE5MnxhPj42fWVsc2V7aWYoNjU1MzU+PWEpe2lmKG4rMj49cilicmVhazt0W24rKz4+PjBdPTIyNHxhPj4xMn1lbHNle2lmKG4rMz49cilicmVhazt0W24rKz4+PjBdPTI0MHxhPj4xOCx0W24rKz4+PjBdPTEyOHxhPj4xMiY2M310W24rKz4+PjBdPTEyOHxhPj42JjYzfXRbbisrPj4+MF09MTI4fDYzJmF9fXJldHVybiB0W24+Pj4wXT0wLG4tb31mdW5jdGlvbiBDKGUpe2Zvcih2YXIgdD0wLG49MDtuPGUubGVuZ3RoOysrbil7dmFyIHI9ZS5jaGFyQ29kZUF0KG4pOzEyNz49cj90Kys6MjA0Nz49cj90Kz0yOjU1Mjk2PD1yJiY1NzM0Mz49cj8odCs9NCwrK24pOnQrPTN9cmV0dXJuIHR9ZnVuY3Rpb24gUigpe3ZhciBlPXguYnVmZmVyO1Q9ZSx0LkhFQVA4PVM9bmV3IEludDhBcnJheShlKSx0LkhFQVAxNj1uZXcgSW50MTZBcnJheShlKSx0LkhFQVAzMj1BPW5ldyBJbnQzMkFycmF5KGUpLHQuSEVBUFU4PU89bmV3IFVpbnQ4QXJyYXkoZSksdC5IRUFQVTE2PW5ldyBVaW50MTZBcnJheShlKSx0LkhFQVBVMzI9RT1uZXcgVWludDMyQXJyYXkoZSksdC5IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkoZSksdC5IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkoZSl9dmFyIE09W10sTj1bXSxGPVtdO2Z1bmN0aW9uIEwoKXt2YXIgZT10LnByZVJ1bi5zaGlmdCgpO00udW5zaGlmdChlKX12YXIgaixVPTAsQj1udWxsLEc9bnVsbDtmdW5jdGlvbiBWKGUpe3Rocm93IHQub25BYm9ydCYmdC5vbkFib3J0KGUpLF8oZT1cIkFib3J0ZWQoXCIrZStcIilcIiksST0hMCxlPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoZStcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksbyhlKSxlfWZ1bmN0aW9uIHooKXtyZXR1cm4gai5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKX1pZihqPVwib3J0LXdhc20ud2FzbVwiLCF6KCkpe3ZhciBIPWo7aj10LmxvY2F0ZUZpbGU/dC5sb2NhdGVGaWxlKEgsYik6YitIfWZ1bmN0aW9uIFcoKXt2YXIgZT1qO3RyeXtpZihlPT1qJiZ5KXJldHVybiBuZXcgVWludDhBcnJheSh5KTtpZihzKXJldHVybiBzKGUpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWNhdGNoKGUpe1YoZSl9fWZ1bmN0aW9uIHEoZSl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiLHRoaXMubWVzc2FnZT1cIlByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoXCIrZStcIilcIix0aGlzLnN0YXR1cz1lfWZ1bmN0aW9uIEsoZSl7Zm9yKDswPGUubGVuZ3RoOyllLnNoaWZ0KCkodCl9ZnVuY3Rpb24gWChlKXt0aGlzLnNhPWUtMjQsdGhpcy5JYT1mdW5jdGlvbihlKXtFW3RoaXMuc2ErND4+Mj4+PjBdPWV9LHRoaXMuQmE9ZnVuY3Rpb24oZSl7RVt0aGlzLnNhKzg+PjI+Pj4wXT1lfSx0aGlzLkdhPWZ1bmN0aW9uKCl7QVt0aGlzLnNhPj4yPj4+MF09MH0sdGhpcy5BYT1mdW5jdGlvbigpe1NbdGhpcy5zYSsxMj4+MD4+PjBdPTB9LHRoaXMuSGE9ZnVuY3Rpb24oKXtTW3RoaXMuc2ErMTM+PjA+Pj4wXT0wfSx0aGlzLnlhPWZ1bmN0aW9uKGUsdCl7dGhpcy56YSgpLHRoaXMuSWEoZSksdGhpcy5CYSh0KSx0aGlzLkdhKCksdGhpcy5BYSgpLHRoaXMuSGEoKX0sdGhpcy56YT1mdW5jdGlvbigpe0VbdGhpcy5zYSsxNj4+Mj4+PjBdPTB9fWZ1bmN0aW9uIFkoZSl7dmFyIHQ9QyhlKSsxLG49YWUodCk7cmV0dXJuIG4mJmsoZSxTLG4sdCksbn12YXIgSj17fTtmdW5jdGlvbiBaKCl7aWYoIVEpe3ZhciBlLHQ9e1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KFwib2JqZWN0XCI9PXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86ZHx8XCIuL3RoaXMucHJvZ3JhbVwifTtmb3IoZSBpbiBKKXZvaWQgMD09PUpbZV0/ZGVsZXRlIHRbZV06dFtlXT1KW2VdO3ZhciBuPVtdO2ZvcihlIGluIHQpbi5wdXNoKGUrXCI9XCIrdFtlXSk7UT1ufXJldHVybiBRfXZhciBRLGVlPVtudWxsLFtdLFtdXTtmdW5jdGlvbiB0ZShlKXtyZXR1cm4gMD09ZSU0JiYoMCE9ZSUxMDB8fDA9PWUlNDAwKX12YXIgbmU9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxyZT1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIG9lKGUsdCxuLHIpe2Z1bmN0aW9uIG8oZSx0LG4pe2ZvcihlPVwibnVtYmVyXCI9PXR5cGVvZiBlP2UudG9TdHJpbmcoKTplfHxcIlwiO2UubGVuZ3RoPHQ7KWU9blswXStlO3JldHVybiBlfWZ1bmN0aW9uIGkoZSx0KXtyZXR1cm4gbyhlLHQsXCIwXCIpfWZ1bmN0aW9uIGEoZSx0KXtmdW5jdGlvbiBuKGUpe3JldHVybiAwPmU/LTE6MDxlPzE6MH12YXIgcjtyZXR1cm4gMD09PShyPW4oZS5nZXRGdWxsWWVhcigpLXQuZ2V0RnVsbFllYXIoKSkpJiYwPT09KHI9bihlLmdldE1vbnRoKCktdC5nZXRNb250aCgpKSkmJihyPW4oZS5nZXREYXRlKCktdC5nZXREYXRlKCkpKSxyfWZ1bmN0aW9uIHMoZSl7c3dpdGNoKGUuZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gZTtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gdShlKXt2YXIgdD1lLnFhO2ZvcihlPW5ldyBEYXRlKG5ldyBEYXRlKGUucmErMTkwMCwwLDEpLmdldFRpbWUoKSk7MDx0Oyl7dmFyIG49ZS5nZXRNb250aCgpLHI9KHRlKGUuZ2V0RnVsbFllYXIoKSk/bmU6cmUpW25dO2lmKCEodD5yLWUuZ2V0RGF0ZSgpKSl7ZS5zZXREYXRlKGUuZ2V0RGF0ZSgpK3QpO2JyZWFrfXQtPXItZS5nZXREYXRlKCkrMSxlLnNldERhdGUoMSksMTE+bj9lLnNldE1vbnRoKG4rMSk6KGUuc2V0TW9udGgoMCksZS5zZXRGdWxsWWVhcihlLmdldEZ1bGxZZWFyKCkrMSkpfXJldHVybiBuPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSsxLDAsNCksdD1zKG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDQpKSxuPXMobiksMD49YSh0LGUpPzA+PWEobixlKT9lLmdldEZ1bGxZZWFyKCkrMTplLmdldEZ1bGxZZWFyKCk6ZS5nZXRGdWxsWWVhcigpLTF9dmFyIGw9QVtyKzQwPj4yPj4+MF07Zm9yKHZhciBjIGluIHI9e0VhOkFbcj4+Mj4+PjBdLERhOkFbcis0Pj4yPj4+MF0sdGE6QVtyKzg+PjI+Pj4wXSx2YTpBW3IrMTI+PjI+Pj4wXSx1YTpBW3IrMTY+PjI+Pj4wXSxyYTpBW3IrMjA+PjI+Pj4wXSxsYTpBW3IrMjQ+PjI+Pj4wXSxxYTpBW3IrMjg+PjI+Pj4wXSxKYTpBW3IrMzI+PjI+Pj4wXSxDYTpBW3IrMzY+PjI+Pj4wXSxGYTpsP0QobCk6XCJcIn0sbj1EKG4pLGw9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifSluPW4ucmVwbGFjZShuZXcgUmVnRXhwKGMsXCJnXCIpLGxbY10pO3ZhciBwPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksZD1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7Zm9yKGMgaW4gbD17XCIlYVwiOmZ1bmN0aW9uKGUpe3JldHVybiBwW2UubGFdLnN1YnN0cmluZygwLDMpfSxcIiVBXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHBbZS5sYV19LFwiJWJcIjpmdW5jdGlvbihlKXtyZXR1cm4gZFtlLnVhXS5zdWJzdHJpbmcoMCwzKX0sXCIlQlwiOmZ1bmN0aW9uKGUpe3JldHVybiBkW2UudWFdfSxcIiVDXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGkoKGUucmErMTkwMCkvMTAwfDAsMil9LFwiJWRcIjpmdW5jdGlvbihlKXtyZXR1cm4gaShlLnZhLDIpfSxcIiVlXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIG8oZS52YSwyLFwiIFwiKX0sXCIlZ1wiOmZ1bmN0aW9uKGUpe3JldHVybiB1KGUpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVHXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIHUoZSl9LFwiJUhcIjpmdW5jdGlvbihlKXtyZXR1cm4gaShlLnRhLDIpfSxcIiVJXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIDA9PShlPWUudGEpP2U9MTI6MTI8ZSYmKGUtPTEyKSxpKGUsMil9LFwiJWpcIjpmdW5jdGlvbihlKXtmb3IodmFyIHQ9MCxuPTA7bjw9ZS51YS0xO3QrPSh0ZShlLnJhKzE5MDApP25lOnJlKVtuKytdKTtyZXR1cm4gaShlLnZhK3QsMyl9LFwiJW1cIjpmdW5jdGlvbihlKXtyZXR1cm4gaShlLnVhKzEsMil9LFwiJU1cIjpmdW5jdGlvbihlKXtyZXR1cm4gaShlLkRhLDIpfSxcIiVuXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcblwifSxcIiVwXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIDA8PWUudGEmJjEyPmUudGE/XCJBTVwiOlwiUE1cIn0sXCIlU1wiOmZ1bmN0aW9uKGUpe3JldHVybiBpKGUuRWEsMil9LFwiJXRcIjpmdW5jdGlvbigpe3JldHVyblwiXFx0XCJ9LFwiJXVcIjpmdW5jdGlvbihlKXtyZXR1cm4gZS5sYXx8N30sXCIlVVwiOmZ1bmN0aW9uKGUpe3JldHVybiBpKE1hdGguZmxvb3IoKGUucWErNy1lLmxhKS83KSwyKX0sXCIlVlwiOmZ1bmN0aW9uKGUpe3ZhciB0PU1hdGguZmxvb3IoKGUucWErNy0oZS5sYSs2KSU3KS83KTtpZigyPj0oZS5sYSszNzEtZS5xYS0yKSU3JiZ0KyssdCk1Mz09dCYmKDQ9PShuPShlLmxhKzM3MS1lLnFhKSU3KXx8Mz09biYmdGUoZS5yYSl8fCh0PTEpKTtlbHNle3Q9NTI7dmFyIG49KGUubGErNy1lLnFhLTEpJTc7KDQ9PW58fDU9PW4mJnRlKGUucmElNDAwLTEpKSYmdCsrfXJldHVybiBpKHQsMil9LFwiJXdcIjpmdW5jdGlvbihlKXtyZXR1cm4gZS5sYX0sXCIlV1wiOmZ1bmN0aW9uKGUpe3JldHVybiBpKE1hdGguZmxvb3IoKGUucWErNy0oZS5sYSs2KSU3KS83KSwyKX0sXCIleVwiOmZ1bmN0aW9uKGUpe3JldHVybihlLnJhKzE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVZXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmErMTkwMH0sXCIlelwiOmZ1bmN0aW9uKGUpe3ZhciB0PTA8PShlPWUuQ2EpO3JldHVybiBlPU1hdGguYWJzKGUpLzYwLCh0P1wiK1wiOlwiLVwiKStTdHJpbmcoXCIwMDAwXCIrKGUvNjAqMTAwK2UlNjApKS5zbGljZSgtNCl9LFwiJVpcIjpmdW5jdGlvbihlKXtyZXR1cm4gZS5GYX0sXCIlJVwiOmZ1bmN0aW9uKCl7cmV0dXJuXCIlXCJ9fSxuPW4ucmVwbGFjZSgvJSUvZyxcIlxcMFxcMFwiKSxsKW4uaW5jbHVkZXMoYykmJihuPW4ucmVwbGFjZShuZXcgUmVnRXhwKGMsXCJnXCIpLGxbY10ocikpKTtyZXR1cm4gYz1mdW5jdGlvbihlKXt2YXIgdD1BcnJheShDKGUpKzEpO3JldHVybiBrKGUsdCwwLHQubGVuZ3RoKSx0fShuPW4ucmVwbGFjZSgvXFwwXFwwL2csXCIlXCIpKSxjLmxlbmd0aD50PzA6KFMuc2V0KGMsZT4+PjApLGMubGVuZ3RoLTEpfXZhciBpZT17YTpmdW5jdGlvbihlKXtyZXR1cm4gYWUoZSsyNCkrMjR9LGI6ZnVuY3Rpb24oZSx0LG4pe3Rocm93IG5ldyBYKGUpLnlhKHQsbiksZX0sZzpmdW5jdGlvbigpe3JldHVybiAwfSxJOmZ1bmN0aW9uKCl7fSx3OmZ1bmN0aW9uKCl7fSx5OmZ1bmN0aW9uKCl7fSxLOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LEc6ZnVuY3Rpb24oKXt9LEM6ZnVuY3Rpb24oKXt9LEY6ZnVuY3Rpb24oKXt9LGs6ZnVuY3Rpb24oKXt9LHg6ZnVuY3Rpb24oKXt9LHU6ZnVuY3Rpb24oKXt9LEg6ZnVuY3Rpb24oKXt9LHY6ZnVuY3Rpb24oKXt9LG46ZnVuY3Rpb24oKXt9LHA6ZnVuY3Rpb24oKXtWKFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LG86ZnVuY3Rpb24oKXtWKFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LGw6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX0sTDpmdW5jdGlvbigpe3JldHVybiEwfSxNOmZ1bmN0aW9uKGUsdCl7ZT1uZXcgRGF0ZSgxZTMqKEVbZT4+PjJdKzQyOTQ5NjcyOTYqQVtlKzQ+Pj4yXSkpLEFbdD4+Mj4+PjBdPWUuZ2V0VVRDU2Vjb25kcygpLEFbdCs0Pj4yPj4+MF09ZS5nZXRVVENNaW51dGVzKCksQVt0Kzg+PjI+Pj4wXT1lLmdldFVUQ0hvdXJzKCksQVt0KzEyPj4yPj4+MF09ZS5nZXRVVENEYXRlKCksQVt0KzE2Pj4yPj4+MF09ZS5nZXRVVENNb250aCgpLEFbdCsyMD4+Mj4+PjBdPWUuZ2V0VVRDRnVsbFllYXIoKS0xOTAwLEFbdCsyND4+Mj4+PjBdPWUuZ2V0VVRDRGF5KCksQVt0KzI4Pj4yPj4+MF09KGUuZ2V0VGltZSgpLURhdGUuVVRDKGUuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDB9LE46ZnVuY3Rpb24oZSx0KXtlPW5ldyBEYXRlKDFlMyooRVtlPj4+Ml0rNDI5NDk2NzI5NipBW2UrND4+PjJdKSksQVt0Pj4yPj4+MF09ZS5nZXRTZWNvbmRzKCksQVt0KzQ+PjI+Pj4wXT1lLmdldE1pbnV0ZXMoKSxBW3QrOD4+Mj4+PjBdPWUuZ2V0SG91cnMoKSxBW3QrMTI+PjI+Pj4wXT1lLmdldERhdGUoKSxBW3QrMTY+PjI+Pj4wXT1lLmdldE1vbnRoKCksQVt0KzIwPj4yPj4+MF09ZS5nZXRGdWxsWWVhcigpLTE5MDAsQVt0KzI0Pj4yPj4+MF09ZS5nZXREYXkoKTt2YXIgbj1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwxKTtBW3QrMjg+PjI+Pj4wXT0oZS5nZXRUaW1lKCktbi5nZXRUaW1lKCkpLzg2NGU1fDAsQVt0KzM2Pj4yPj4+MF09LTYwKmUuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgcj1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO249bi5nZXRUaW1lem9uZU9mZnNldCgpLEFbdCszMj4+Mj4+PjBdPTB8KHIhPW4mJmUuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4obixyKSl9LE86ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IERhdGUoQVtlKzIwPj4yPj4+MF0rMTkwMCxBW2UrMTY+PjI+Pj4wXSxBW2UrMTI+PjI+Pj4wXSxBW2UrOD4+Mj4+PjBdLEFbZSs0Pj4yPj4+MF0sQVtlPj4yPj4+MF0sMCksbj1BW2UrMzI+PjI+Pj4wXSxyPXQuZ2V0VGltZXpvbmVPZmZzZXQoKSxvPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDEpLGk9bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxhPW8uZ2V0VGltZXpvbmVPZmZzZXQoKSxzPU1hdGgubWluKGEsaSk7cmV0dXJuIDA+bj9BW2UrMzI+PjI+Pj4wXT1OdW1iZXIoaSE9YSYmcz09cik6MDxuIT0ocz09cikmJihpPU1hdGgubWF4KGEsaSksdC5zZXRUaW1lKHQuZ2V0VGltZSgpKzZlNCooKDA8bj9zOmkpLXIpKSksQVtlKzI0Pj4yPj4+MF09dC5nZXREYXkoKSxBW2UrMjg+PjI+Pj4wXT0odC5nZXRUaW1lKCktby5nZXRUaW1lKCkpLzg2NGU1fDAsQVtlPj4yPj4+MF09dC5nZXRTZWNvbmRzKCksQVtlKzQ+PjI+Pj4wXT10LmdldE1pbnV0ZXMoKSxBW2UrOD4+Mj4+PjBdPXQuZ2V0SG91cnMoKSxBW2UrMTI+PjI+Pj4wXT10LmdldERhdGUoKSxBW2UrMTY+PjI+Pj4wXT10LmdldE1vbnRoKCksdC5nZXRUaW1lKCkvMWUzfDB9LHo6ZnVuY3Rpb24oKXtyZXR1cm4tNTJ9LEI6ZnVuY3Rpb24oKXt9LG06ZnVuY3Rpb24gZSh0LG4scil7ZS54YXx8KGUueGE9ITAsZnVuY3Rpb24oZSx0LG4pe2Z1bmN0aW9uIHIoZSl7cmV0dXJuKGU9ZS50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFwoKFtBLVphLXogXSspXFwpJC8pKT9lWzFdOlwiR01UXCJ9dmFyIG89KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpLGk9bmV3IERhdGUobywwLDEpLGE9bmV3IERhdGUobyw2LDEpO289aS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBzPWEuZ2V0VGltZXpvbmVPZmZzZXQoKTtBW2U+PjI+Pj4wXT02MCpNYXRoLm1heChvLHMpLEFbdD4+Mj4+PjBdPU51bWJlcihvIT1zKSxlPXIoaSksdD1yKGEpLGU9WShlKSx0PVkodCksczxvPyhFW24+PjI+Pj4wXT1lLEVbbis0Pj4yPj4+MF09dCk6KEVbbj4+Mj4+PjBdPXQsRVtuKzQ+PjI+Pj4wXT1lKX0odCxuLHIpKX0sZDpmdW5jdGlvbigpe1YoXCJcIil9LHQ6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0saDptPygpPT57dmFyIGU9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gMWUzKmVbMF0rZVsxXS8xZTZ9OigpPT5wZXJmb3JtYW5jZS5ub3coKSxKOmZ1bmN0aW9uKGUsdCxuKXtPLmNvcHlXaXRoaW4oZT4+PjAsdD4+PjAsdCtuPj4+MCl9LGY6ZnVuY3Rpb24oZSl7dmFyIHQ9Ty5sZW5ndGg7aWYoNDI5NDkwMTc2MDwoZT4+Pj0wKSlyZXR1cm4hMTtmb3IodmFyIG49MTs0Pj1uO24qPTIpe3ZhciByPXQqKDErLjIvbik7cj1NYXRoLm1pbihyLGUrMTAwNjYzMjk2KTt2YXIgbz1NYXRoO3I9TWF0aC5tYXgoZSxyKSxvPW8ubWluLmNhbGwobyw0Mjk0OTAxNzYwLHIrKDY1NTM2LXIlNjU1MzYpJTY1NTM2KTtlOnt0cnl7eC5ncm93KG8tVC5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTYpLFIoKTt2YXIgaT0xO2JyZWFrIGV9Y2F0Y2goZSl7fWk9dm9pZCAwfWlmKGkpcmV0dXJuITB9cmV0dXJuITF9LEQ6ZnVuY3Rpb24oZSx0KXt2YXIgbj0wO3JldHVybiBaKCkuZm9yRWFjaCgoZnVuY3Rpb24ocixvKXt2YXIgaT10K247Zm9yKG89RVtlKzQqbz4+Mj4+PjBdPWksaT0wO2k8ci5sZW5ndGg7KytpKVNbbysrPj4wPj4+MF09ci5jaGFyQ29kZUF0KGkpO1Nbbz4+MD4+PjBdPTAsbis9ci5sZW5ndGgrMX0pKSwwfSxFOmZ1bmN0aW9uKGUsdCl7dmFyIG49WigpO0VbZT4+Mj4+PjBdPW4ubGVuZ3RoO3ZhciByPTA7cmV0dXJuIG4uZm9yRWFjaCgoZnVuY3Rpb24oZSl7cis9ZS5sZW5ndGgrMX0pKSxFW3Q+PjI+Pj4wXT1yLDB9LHI6ZnVuY3Rpb24oZSl7dnx8KHQub25FeGl0JiZ0Lm9uRXhpdChlKSxJPSEwKSxmKGUsbmV3IHEoZSkpfSxlOmZ1bmN0aW9uKCl7cmV0dXJuIDUyfSxqOmZ1bmN0aW9uKCl7cmV0dXJuIDUyfSxxOmZ1bmN0aW9uKCl7cmV0dXJuIDcwfSxpOmZ1bmN0aW9uKGUsdCxuLHIpe2Zvcih2YXIgbz0wLGk9MDtpPG47aSsrKXt2YXIgYT1FW3Q+PjI+Pj4wXSxzPUVbdCs0Pj4yPj4+MF07dCs9ODtmb3IodmFyIHU9MDt1PHM7dSsrKXt2YXIgbD1PW2ErdT4+PjBdLGM9ZWVbZV07MD09PWx8fDEwPT09bD8oKDE9PT1lP3c6XykoUChjLDApKSxjLmxlbmd0aD0wKTpjLnB1c2gobCl9bys9c31yZXR1cm4gRVtyPj4yPj4+MF09bywwfSxzOmZ1bmN0aW9uIGUodCxyKXtlLndhfHwoZS53YT1mdW5jdGlvbigpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBjcnlwdG8mJlwiZnVuY3Rpb25cIj09dHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpe3ZhciBlPW5ldyBVaW50OEFycmF5KDEpO3JldHVybigpPT4oY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhlKSxlWzBdKX1pZihtKXRyeXt2YXIgdD1uKDc2MCk7cmV0dXJuKCk9PnQucmFuZG9tQnl0ZXMoMSlbMF19Y2F0Y2goZSl7fXJldHVybigpPT5WKFwicmFuZG9tRGV2aWNlXCIpfSgpKTtmb3IodmFyIG89MDtvPHI7bysrKVNbdCtvPj4wPj4+MF09ZS53YSgpO3JldHVybiAwfSxBOm9lLGM6ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIG9lKGUsdCxuLHIpfX07IWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0LmFzbT1lLmV4cG9ydHMseD10LmFzbS5QLFIoKSxOLnVuc2hpZnQodC5hc20uUSksVS0tLHQubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmdC5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKFUpLDA9PVUmJihudWxsIT09QiYmKGNsZWFySW50ZXJ2YWwoQiksQj1udWxsKSxHJiYoZT1HLEc9bnVsbCxlKCkpKX1mdW5jdGlvbiBuKHQpe2UodC5pbnN0YW5jZSl9ZnVuY3Rpb24gcihlKXtyZXR1cm4gZnVuY3Rpb24oKXtpZigheSYmKGh8fGcpKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBmZXRjaCYmIWouc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpcmV0dXJuIGZldGNoKGose2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKGUpe2lmKCFlLm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIitqK1wiJ1wiO3JldHVybiBlLmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIFcoKX0pKTtpZihhKXJldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSx0KXthKGosKGZ1bmN0aW9uKHQpe2UobmV3IFVpbnQ4QXJyYXkodCkpfSksdCl9KSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIFcoKX0pKX0oKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoZSxpKX0pKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gZX0pKS50aGVuKGUsKGZ1bmN0aW9uKGUpe18oXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIitlKSxWKGUpfSkpfXZhciBpPXthOmllfTtpZihVKyssdC5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZ0Lm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoVSksdC5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiB0Lmluc3RhbnRpYXRlV2FzbShpLGUpfWNhdGNoKGUpe3JldHVybiBfKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrZSksITF9KHl8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHx6KCl8fGouc3RhcnRzV2l0aChcImZpbGU6Ly9cIil8fG18fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGZldGNoP3Iobik6ZmV0Y2goaix7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKGUsaSkudGhlbihuLChmdW5jdGlvbihlKXtyZXR1cm4gXyhcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIitlKSxfKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIikscihuKX0pKX0pKSkuY2F0Y2gobyl9KCksdC5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4odC5fX193YXNtX2NhbGxfY3RvcnM9dC5hc20uUSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRJbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEluaXQ9dC5hc20uUikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz10LmFzbS5TKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPXQuYXNtLlQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT10LmFzbS5VKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9dC5hc20uVikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRDcmVhdGVTZXNzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydENyZWF0ZVNlc3Npb249dC5hc20uVykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRSZWxlYXNlU2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRSZWxlYXNlU2Vzc2lvbj10LmFzbS5YKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEdldElucHV0Q291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0R2V0SW5wdXRDb3VudD10LmFzbS5ZKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEdldE91dHB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEdldE91dHB1dENvdW50PXQuYXNtLlopLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0R2V0SW5wdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEdldElucHV0TmFtZT10LmFzbS5fKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEdldE91dHB1dE5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0R2V0T3V0cHV0TmFtZT10LmFzbS4kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0RnJlZT10LmFzbS5hYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRDcmVhdGVUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0Q3JlYXRlVGVuc29yPXQuYXNtLmJhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEdldFRlbnNvckRhdGE9ZnVuY3Rpb24oKXtyZXR1cm4odC5fT3J0R2V0VGVuc29yRGF0YT10LmFzbS5jYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Ll9PcnRSZWxlYXNlVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydFJlbGVhc2VUZW5zb3I9dC5hc20uZGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRDcmVhdGVSdW5PcHRpb25zPXQuYXNtLmVhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PXQuYXNtLmZhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydFJlbGVhc2VSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydFJlbGVhc2VSdW5PcHRpb25zPXQuYXNtLmdhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuX09ydFJ1bj1mdW5jdGlvbigpe3JldHVybih0Ll9PcnRSdW49dC5hc20uaGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdC5fT3J0RW5kUHJvZmlsaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX09ydEVuZFByb2ZpbGluZz10LmFzbS5pYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgYWU9dC5fbWFsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKGFlPXQuX21hbGxvYz10LmFzbS5qYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt0Ll9mcmVlPWZ1bmN0aW9uKCl7cmV0dXJuKHQuX2ZyZWU9dC5hc20ua2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIHNlLHVlPXQuc3RhY2tTYXZlPWZ1bmN0aW9uKCl7cmV0dXJuKHVlPXQuc3RhY2tTYXZlPXQuYXNtLm1hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGxlPXQuc3RhY2tSZXN0b3JlPWZ1bmN0aW9uKCl7cmV0dXJuKGxlPXQuc3RhY2tSZXN0b3JlPXQuYXNtLm5hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGNlPXQuc3RhY2tBbGxvYz1mdW5jdGlvbigpe3JldHVybihjZT10LnN0YWNrQWxsb2M9dC5hc20ub2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07ZnVuY3Rpb24gcGUoKXtmdW5jdGlvbiBlKCl7aWYoIXNlJiYoc2U9ITAsdC5jYWxsZWRSdW49ITAsIUkpKXtpZihLKE4pLHIodCksdC5vblJ1bnRpbWVJbml0aWFsaXplZCYmdC5vblJ1bnRpbWVJbml0aWFsaXplZCgpLHQucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgdC5wb3N0UnVuJiYodC5wb3N0UnVuPVt0LnBvc3RSdW5dKTt0LnBvc3RSdW4ubGVuZ3RoOyl7dmFyIGU9dC5wb3N0UnVuLnNoaWZ0KCk7Ri51bnNoaWZ0KGUpfUsoRil9fWlmKCEoMDxVKSl7aWYodC5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQucHJlUnVuJiYodC5wcmVSdW49W3QucHJlUnVuXSk7dC5wcmVSdW4ubGVuZ3RoOylMKCk7SyhNKSwwPFV8fCh0LnNldFN0YXR1cz8odC5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXt0LnNldFN0YXR1cyhcIlwiKX0pLDEpLGUoKX0pLDEpKTplKCkpfX1pZih0Ll9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4odC5fX19jeGFfaXNfcG9pbnRlcl90eXBlPXQuYXNtLnBhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHQuVVRGOFRvU3RyaW5nPUQsdC5zdHJpbmdUb1VURjg9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBrKGUsTyx0LG4pfSx0Lmxlbmd0aEJ5dGVzVVRGOD1DLHQuc3RhY2tTYXZlPXVlLHQuc3RhY2tSZXN0b3JlPWxlLHQuc3RhY2tBbGxvYz1jZSxHPWZ1bmN0aW9uIGUoKXtzZXx8cGUoKSxzZXx8KEc9ZSl9LHQucHJlSW5pdClmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgdC5wcmVJbml0JiYodC5wcmVJbml0PVt0LnByZUluaXRdKTswPHQucHJlSW5pdC5sZW5ndGg7KXQucHJlSW5pdC5wb3AoKSgpO3JldHVybiBwZSgpLGUucmVhZHl9KTtlLmV4cG9ydHM9cn0sNDUzNzplPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpLHI9MCxvPTIsaT0hMDtvPGFyZ3VtZW50cy5sZW5ndGg7KW5bcisrXT1hcmd1bWVudHNbbysrXTtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKG8sYSl7bltyXT1mdW5jdGlvbihlKXtpZihpKWlmKGk9ITEsZSlhKGUpO2Vsc2V7Zm9yKHZhciB0PW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpLG49MDtuPHQubGVuZ3RoOyl0W24rK109YXJndW1lbnRzW25dO28uYXBwbHkobnVsbCx0KX19O3RyeXtlLmFwcGx5KHR8fG51bGwsbil9Y2F0Y2goZSl7aSYmKGk9ITEsYShlKSl9fSkpfX0sNzQxOTooZSx0KT0+e1widXNlIHN0cmljdFwiO3ZhciBuPXQ7bi5sZW5ndGg9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5sZW5ndGg7aWYoIXQpcmV0dXJuIDA7Zm9yKHZhciBuPTA7LS10JTQ+MSYmXCI9XCI9PT1lLmNoYXJBdCh0KTspKytuO3JldHVybiBNYXRoLmNlaWwoMyplLmxlbmd0aCkvNC1ufTtmb3IodmFyIHI9bmV3IEFycmF5KDY0KSxvPW5ldyBBcnJheSgxMjMpLGk9MDtpPDY0OylvW3JbaV09aTwyNj9pKzY1Omk8NTI/aSs3MTppPDYyP2ktNDppLTU5fDQzXT1pKys7bi5lbmNvZGU9ZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgbyxpPW51bGwsYT1bXSxzPTAsdT0wO3Q8bjspe3ZhciBsPWVbdCsrXTtzd2l0Y2godSl7Y2FzZSAwOmFbcysrXT1yW2w+PjJdLG89KDMmbCk8PDQsdT0xO2JyZWFrO2Nhc2UgMTphW3MrK109cltvfGw+PjRdLG89KDE1JmwpPDwyLHU9MjticmVhaztjYXNlIDI6YVtzKytdPXJbb3xsPj42XSxhW3MrK109cls2MyZsXSx1PTB9cz44MTkxJiYoKGl8fChpPVtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxhKSkscz0wKX1yZXR1cm4gdSYmKGFbcysrXT1yW29dLGFbcysrXT02MSwxPT09dSYmKGFbcysrXT02MSkpLGk/KHMmJmkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxhLnNsaWNlKDAscykpKSxpLmpvaW4oXCJcIikpOlN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGEuc2xpY2UoMCxzKSl9O3ZhciBhPVwiaW52YWxpZCBlbmNvZGluZ1wiO24uZGVjb2RlPWZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIHIsaT1uLHM9MCx1PTA7dTxlLmxlbmd0aDspe3ZhciBsPWUuY2hhckNvZGVBdCh1KyspO2lmKDYxPT09bCYmcz4xKWJyZWFrO2lmKHZvaWQgMD09PShsPW9bbF0pKXRocm93IEVycm9yKGEpO3N3aXRjaChzKXtjYXNlIDA6cj1sLHM9MTticmVhaztjYXNlIDE6dFtuKytdPXI8PDJ8KDQ4JmwpPj40LHI9bCxzPTI7YnJlYWs7Y2FzZSAyOnRbbisrXT0oMTUmcik8PDR8KDYwJmwpPj4yLHI9bCxzPTM7YnJlYWs7Y2FzZSAzOnRbbisrXT0oMyZyKTw8NnxsLHM9MH19aWYoMT09PXMpdGhyb3cgRXJyb3IoYSk7cmV0dXJuIG4taX0sbi50ZXN0PWZ1bmN0aW9uKGUpe3JldHVybi9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KGUpfX0sOTIxMTplPT57XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gdCgpe3RoaXMuX2xpc3RlbmVycz17fX1lLmV4cG9ydHM9dCx0LnByb3RvdHlwZS5vbj1mdW5jdGlvbihlLHQsbil7cmV0dXJuKHRoaXMuX2xpc3RlbmVyc1tlXXx8KHRoaXMuX2xpc3RlbmVyc1tlXT1bXSkpLnB1c2goe2ZuOnQsY3R4Om58fHRoaXN9KSx0aGlzfSx0LnByb3RvdHlwZS5vZmY9ZnVuY3Rpb24oZSx0KXtpZih2b2lkIDA9PT1lKXRoaXMuX2xpc3RlbmVycz17fTtlbHNlIGlmKHZvaWQgMD09PXQpdGhpcy5fbGlzdGVuZXJzW2VdPVtdO2Vsc2UgZm9yKHZhciBuPXRoaXMuX2xpc3RlbmVyc1tlXSxyPTA7cjxuLmxlbmd0aDspbltyXS5mbj09PXQ/bi5zcGxpY2UociwxKTorK3I7cmV0dXJuIHRoaXN9LHQucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5fbGlzdGVuZXJzW2VdO2lmKHQpe2Zvcih2YXIgbj1bXSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoOyluLnB1c2goYXJndW1lbnRzW3IrK10pO2ZvcihyPTA7cjx0Lmxlbmd0aDspdFtyXS5mbi5hcHBseSh0W3IrK10uY3R4LG4pfXJldHVybiB0aGlzfX0sOTQ1OmU9PntcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KGUpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBGbG9hdDMyQXJyYXk/ZnVuY3Rpb24oKXt2YXIgdD1uZXcgRmxvYXQzMkFycmF5KFstMF0pLG49bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIpLHI9MTI4PT09blszXTtmdW5jdGlvbiBvKGUscixvKXt0WzBdPWUscltvXT1uWzBdLHJbbysxXT1uWzFdLHJbbysyXT1uWzJdLHJbbyszXT1uWzNdfWZ1bmN0aW9uIGkoZSxyLG8pe3RbMF09ZSxyW29dPW5bM10scltvKzFdPW5bMl0scltvKzJdPW5bMV0scltvKzNdPW5bMF19ZnVuY3Rpb24gYShlLHIpe3JldHVybiBuWzBdPWVbcl0sblsxXT1lW3IrMV0sblsyXT1lW3IrMl0sblszXT1lW3IrM10sdFswXX1mdW5jdGlvbiBzKGUscil7cmV0dXJuIG5bM109ZVtyXSxuWzJdPWVbcisxXSxuWzFdPWVbcisyXSxuWzBdPWVbciszXSx0WzBdfWUud3JpdGVGbG9hdExFPXI/bzppLGUud3JpdGVGbG9hdEJFPXI/aTpvLGUucmVhZEZsb2F0TEU9cj9hOnMsZS5yZWFkRmxvYXRCRT1yP3M6YX0oKTpmdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSx0LG4scil7dmFyIG89dDwwPzE6MDtpZihvJiYodD0tdCksMD09PXQpZSgxL3Q+MD8wOjIxNDc0ODM2NDgsbixyKTtlbHNlIGlmKGlzTmFOKHQpKWUoMjE0MzI4OTM0NCxuLHIpO2Vsc2UgaWYodD4zNDAyODIzNDY2Mzg1Mjg4NmUyMillKChvPDwzMXwyMTM5MDk1MDQwKT4+PjAsbixyKTtlbHNlIGlmKHQ8MTE3NTQ5NDM1MDgyMjI4NzVlLTU0KWUoKG88PDMxfE1hdGgucm91bmQodC8xNDAxMjk4NDY0MzI0ODE3ZS02MCkpPj4+MCxuLHIpO2Vsc2V7dmFyIGk9TWF0aC5mbG9vcihNYXRoLmxvZyh0KS9NYXRoLkxOMik7ZSgobzw8MzF8aSsxMjc8PDIzfDgzODg2MDcmTWF0aC5yb3VuZCh0Kk1hdGgucG93KDIsLWkpKjgzODg2MDgpKT4+PjAsbixyKX19ZnVuY3Rpb24gYShlLHQsbil7dmFyIHI9ZSh0LG4pLG89Mioocj4+MzEpKzEsaT1yPj4+MjMmMjU1LGE9ODM4ODYwNyZyO3JldHVybiAyNTU9PT1pP2E/TmFOOm8qKDEvMCk6MD09PWk/MTQwMTI5ODQ2NDMyNDgxN2UtNjAqbyphOm8qTWF0aC5wb3coMixpLTE1MCkqKGErODM4ODYwOCl9ZS53cml0ZUZsb2F0TEU9dC5iaW5kKG51bGwsbiksZS53cml0ZUZsb2F0QkU9dC5iaW5kKG51bGwsciksZS5yZWFkRmxvYXRMRT1hLmJpbmQobnVsbCxvKSxlLnJlYWRGbG9hdEJFPWEuYmluZChudWxsLGkpfSgpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBGbG9hdDY0QXJyYXk/ZnVuY3Rpb24oKXt2YXIgdD1uZXcgRmxvYXQ2NEFycmF5KFstMF0pLG49bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIpLHI9MTI4PT09bls3XTtmdW5jdGlvbiBvKGUscixvKXt0WzBdPWUscltvXT1uWzBdLHJbbysxXT1uWzFdLHJbbysyXT1uWzJdLHJbbyszXT1uWzNdLHJbbys0XT1uWzRdLHJbbys1XT1uWzVdLHJbbys2XT1uWzZdLHJbbys3XT1uWzddfWZ1bmN0aW9uIGkoZSxyLG8pe3RbMF09ZSxyW29dPW5bN10scltvKzFdPW5bNl0scltvKzJdPW5bNV0scltvKzNdPW5bNF0scltvKzRdPW5bM10scltvKzVdPW5bMl0scltvKzZdPW5bMV0scltvKzddPW5bMF19ZnVuY3Rpb24gYShlLHIpe3JldHVybiBuWzBdPWVbcl0sblsxXT1lW3IrMV0sblsyXT1lW3IrMl0sblszXT1lW3IrM10sbls0XT1lW3IrNF0sbls1XT1lW3IrNV0sbls2XT1lW3IrNl0sbls3XT1lW3IrN10sdFswXX1mdW5jdGlvbiBzKGUscil7cmV0dXJuIG5bN109ZVtyXSxuWzZdPWVbcisxXSxuWzVdPWVbcisyXSxuWzRdPWVbciszXSxuWzNdPWVbcis0XSxuWzJdPWVbcis1XSxuWzFdPWVbcis2XSxuWzBdPWVbcis3XSx0WzBdfWUud3JpdGVEb3VibGVMRT1yP286aSxlLndyaXRlRG91YmxlQkU9cj9pOm8sZS5yZWFkRG91YmxlTEU9cj9hOnMsZS5yZWFkRG91YmxlQkU9cj9zOmF9KCk6ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsdCxuLHIsbyxpKXt2YXIgYT1yPDA/MTowO2lmKGEmJihyPS1yKSwwPT09cillKDAsbyxpK3QpLGUoMS9yPjA/MDoyMTQ3NDgzNjQ4LG8saStuKTtlbHNlIGlmKGlzTmFOKHIpKWUoMCxvLGkrdCksZSgyMTQ2OTU5MzYwLG8saStuKTtlbHNlIGlmKHI+MTc5NzY5MzEzNDg2MjMxNTdlMjkyKWUoMCxvLGkrdCksZSgoYTw8MzF8MjE0NjQzNTA3Mik+Pj4wLG8saStuKTtlbHNle3ZhciBzO2lmKHI8MjIyNTA3Mzg1ODUwNzIwMTRlLTMyNCllKChzPXIvNWUtMzI0KT4+PjAsbyxpK3QpLGUoKGE8PDMxfHMvNDI5NDk2NzI5Nik+Pj4wLG8saStuKTtlbHNle3ZhciB1PU1hdGguZmxvb3IoTWF0aC5sb2cocikvTWF0aC5MTjIpOzEwMjQ9PT11JiYodT0xMDIzKSxlKDQ1MDM1OTk2MjczNzA0OTYqKHM9cipNYXRoLnBvdygyLC11KSk+Pj4wLG8saSt0KSxlKChhPDwzMXx1KzEwMjM8PDIwfDEwNDg1NzYqcyYxMDQ4NTc1KT4+PjAsbyxpK24pfX19ZnVuY3Rpb24gYShlLHQsbixyLG8pe3ZhciBpPWUocixvK3QpLGE9ZShyLG8rbikscz0yKihhPj4zMSkrMSx1PWE+Pj4yMCYyMDQ3LGw9NDI5NDk2NzI5NiooMTA0ODU3NSZhKStpO3JldHVybiAyMDQ3PT09dT9sP05hTjpzKigxLzApOjA9PT11PzVlLTMyNCpzKmw6cypNYXRoLnBvdygyLHUtMTA3NSkqKGwrNDUwMzU5OTYyNzM3MDQ5Nil9ZS53cml0ZURvdWJsZUxFPXQuYmluZChudWxsLG4sMCw0KSxlLndyaXRlRG91YmxlQkU9dC5iaW5kKG51bGwsciw0LDApLGUucmVhZERvdWJsZUxFPWEuYmluZChudWxsLG8sMCw0KSxlLnJlYWREb3VibGVCRT1hLmJpbmQobnVsbCxpLDQsMCl9KCksZX1mdW5jdGlvbiBuKGUsdCxuKXt0W25dPTI1NSZlLHRbbisxXT1lPj4+OCYyNTUsdFtuKzJdPWU+Pj4xNiYyNTUsdFtuKzNdPWU+Pj4yNH1mdW5jdGlvbiByKGUsdCxuKXt0W25dPWU+Pj4yNCx0W24rMV09ZT4+PjE2JjI1NSx0W24rMl09ZT4+PjgmMjU1LHRbbiszXT0yNTUmZX1mdW5jdGlvbiBvKGUsdCl7cmV0dXJuKGVbdF18ZVt0KzFdPDw4fGVbdCsyXTw8MTZ8ZVt0KzNdPDwyNCk+Pj4wfWZ1bmN0aW9uIGkoZSx0KXtyZXR1cm4oZVt0XTw8MjR8ZVt0KzFdPDwxNnxlW3QrMl08PDh8ZVt0KzNdKT4+PjB9ZS5leHBvcnRzPXQodCl9LDcxOTk6bW9kdWxlPT57XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaW5xdWlyZShtb2R1bGVOYW1lKXt0cnl7dmFyIG1vZD1ldmFsKFwicXVpcmVcIi5yZXBsYWNlKC9eLyxcInJlXCIpKShtb2R1bGVOYW1lKTtpZihtb2QmJihtb2QubGVuZ3RofHxPYmplY3Qua2V5cyhtb2QpLmxlbmd0aCkpcmV0dXJuIG1vZH1jYXRjaChlKXt9cmV0dXJuIG51bGx9bW9kdWxlLmV4cG9ydHM9aW5xdWlyZX0sNjY2MjplPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1ufHw4MTkyLG89cj4+PjEsaT1udWxsLGE9cjtyZXR1cm4gZnVuY3Rpb24obil7aWYobjwxfHxuPm8pcmV0dXJuIGUobik7YStuPnImJihpPWUociksYT0wKTt2YXIgcz10LmNhbGwoaSxhLGErPW4pO3JldHVybiA3JmEmJihhPTErKDd8YSkpLHN9fX0sNDk5NzooZSx0KT0+e1widXNlIHN0cmljdFwiO3ZhciBuPXQ7bi5sZW5ndGg9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsbj0wLHI9MDtyPGUubGVuZ3RoOysrcikobj1lLmNoYXJDb2RlQXQocikpPDEyOD90Kz0xOm48MjA0OD90Kz0yOjU1Mjk2PT0oNjQ1MTImbikmJjU2MzIwPT0oNjQ1MTImZS5jaGFyQ29kZUF0KHIrMSkpPygrK3IsdCs9NCk6dCs9MztyZXR1cm4gdH0sbi5yZWFkPWZ1bmN0aW9uKGUsdCxuKXtpZihuLXQ8MSlyZXR1cm5cIlwiO2Zvcih2YXIgcixvPW51bGwsaT1bXSxhPTA7dDxuOykocj1lW3QrK10pPDEyOD9pW2ErK109cjpyPjE5MSYmcjwyMjQ/aVthKytdPSgzMSZyKTw8Nnw2MyZlW3QrK106cj4yMzkmJnI8MzY1PyhyPSgoNyZyKTw8MTh8KDYzJmVbdCsrXSk8PDEyfCg2MyZlW3QrK10pPDw2fDYzJmVbdCsrXSktNjU1MzYsaVthKytdPTU1Mjk2KyhyPj4xMCksaVthKytdPTU2MzIwKygxMDIzJnIpKTppW2ErK109KDE1JnIpPDwxMnwoNjMmZVt0KytdKTw8Nnw2MyZlW3QrK10sYT44MTkxJiYoKG98fChvPVtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxpKSksYT0wKTtyZXR1cm4gbz8oYSYmby5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGkuc2xpY2UoMCxhKSkpLG8uam9pbihcIlwiKSk6U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsaS5zbGljZSgwLGEpKX0sbi53cml0ZT1mdW5jdGlvbihlLHQsbil7Zm9yKHZhciByLG8saT1uLGE9MDthPGUubGVuZ3RoOysrYSkocj1lLmNoYXJDb2RlQXQoYSkpPDEyOD90W24rK109cjpyPDIwNDg/KHRbbisrXT1yPj42fDE5Mix0W24rK109NjMmcnwxMjgpOjU1Mjk2PT0oNjQ1MTImcikmJjU2MzIwPT0oNjQ1MTImKG89ZS5jaGFyQ29kZUF0KGErMSkpKT8ocj02NTUzNisoKDEwMjMmcik8PDEwKSsoMTAyMyZvKSwrK2EsdFtuKytdPXI+PjE4fDI0MCx0W24rK109cj4+MTImNjN8MTI4LHRbbisrXT1yPj42JjYzfDEyOCx0W24rK109NjMmcnwxMjgpOih0W24rK109cj4+MTJ8MjI0LHRbbisrXT1yPj42JjYzfDEyOCx0W24rK109NjMmcnwxMjgpO3JldHVybiBuLWl9fSwzNDQyOihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwO3ZhciBuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtpZighdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudDsgYHZhbHVlYCBoYXMgbm8gdmFsdWUuXCIpO3RoaXMudmFsdWU9ZS5FTVBUWSx0JiZlLmlzR3VpZCh0KSYmKHRoaXMudmFsdWU9dCl9cmV0dXJuIGUuaXNHdWlkPWZ1bmN0aW9uKHQpe3ZhciBuPXQudG9TdHJpbmcoKTtyZXR1cm4gdCYmKHQgaW5zdGFuY2VvZiBlfHxlLnZhbGlkYXRvci50ZXN0KG4pKX0sZS5jcmVhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGUoW2UuZ2VuKDIpLGUuZ2VuKDEpLGUuZ2VuKDEpLGUuZ2VuKDEpLGUuZ2VuKDMpXS5qb2luKFwiLVwiKSl9LGUuY3JlYXRlRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGUoXCJlbXB0eWd1aWRcIil9LGUucGFyc2U9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpfSxlLnJhdz1mdW5jdGlvbigpe3JldHVybltlLmdlbigyKSxlLmdlbigxKSxlLmdlbigxKSxlLmdlbigxKSxlLmdlbigzKV0uam9pbihcIi1cIil9LGUuZ2VuPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1cIlwiLG49MDtuPGU7bisrKXQrPSg2NTUzNiooMStNYXRoLnJhbmRvbSgpKXwwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO3JldHVybiB0fSxlLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24odCl7cmV0dXJuIGUuaXNHdWlkKHQpJiZ0aGlzLnZhbHVlPT09dC50b1N0cmluZygpfSxlLnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWU9PT1lLkVNUFRZfSxlLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlfSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm57dmFsdWU6dGhpcy52YWx1ZX19LGUudmFsaWRhdG9yPW5ldyBSZWdFeHAoXCJeW2EtejAtOV17OH0tW2EtejAtOV17NH0tW2EtejAtOV17NH0tW2EtejAtOV17NH0tW2EtejAtOV17MTJ9JFwiLFwiaVwiKSxlLkVNUFRZPVwiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwXCIsZX0oKTt0Lkd1aWQ9bn0sMzcyMDplPT57ZS5leHBvcnRzPW47dmFyIHQ9bnVsbDt0cnl7dD1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSwxMywyLDk2LDAsMSwxMjcsOTYsNCwxMjcsMTI3LDEyNywxMjcsMSwxMjcsMyw3LDYsMCwxLDEsMSwxLDEsNiw2LDEsMTI3LDEsNjUsMCwxMSw3LDUwLDYsMywxMDksMTE3LDEwOCwwLDEsNSwxMDAsMTA1LDExOCw5NSwxMTUsMCwyLDUsMTAwLDEwNSwxMTgsOTUsMTE3LDAsMyw1LDExNCwxMDEsMTA5LDk1LDExNSwwLDQsNSwxMTQsMTAxLDEwOSw5NSwxMTcsMCw1LDgsMTAzLDEwMSwxMTYsOTUsMTA0LDEwNSwxMDMsMTA0LDAsMCwxMCwxOTEsMSw2LDQsMCwzNSwwLDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEyNiwzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMSwzNiwxLDEsMTI2LDMyLDAsMTczLDMyLDEsMTczLDY2LDMyLDEzNCwxMzIsMzIsMiwxNzMsMzIsMywxNzMsNjYsMzIsMTM0LDEzMiwxMjcsMzQsNCw2NiwzMiwxMzUsMTY3LDM2LDAsMzIsNCwxNjcsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTI4LDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEyOSwzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMSwzNiwxLDEsMTI2LDMyLDAsMTczLDMyLDEsMTczLDY2LDMyLDEzNCwxMzIsMzIsMiwxNzMsMzIsMywxNzMsNjYsMzIsMTM0LDEzMiwxMzAsMzQsNCw2NiwzMiwxMzUsMTY3LDM2LDAsMzIsNCwxNjcsMTFdKSkse30pLmV4cG9ydHN9Y2F0Y2goZSl7fWZ1bmN0aW9uIG4oZSx0LG4pe3RoaXMubG93PTB8ZSx0aGlzLmhpZ2g9MHx0LHRoaXMudW5zaWduZWQ9ISFufWZ1bmN0aW9uIHIoZSl7cmV0dXJuITA9PT0oZSYmZS5fX2lzTG9uZ19fKX1uLnByb3RvdHlwZS5fX2lzTG9uZ19fLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLnByb3RvdHlwZSxcIl9faXNMb25nX19cIix7dmFsdWU6ITB9KSxuLmlzTG9uZz1yO3ZhciBvPXt9LGk9e307ZnVuY3Rpb24gYShlLHQpe3ZhciBuLHIsYTtyZXR1cm4gdD8oYT0wPD0oZT4+Pj0wKSYmZTwyNTYpJiYocj1pW2VdKT9yOihuPXUoZSwoMHxlKTwwPy0xOjAsITApLGEmJihpW2VdPW4pLG4pOihhPS0xMjg8PShlfD0wKSYmZTwxMjgpJiYocj1vW2VdKT9yOihuPXUoZSxlPDA/LTE6MCwhMSksYSYmKG9bZV09biksbil9ZnVuY3Rpb24gcyhlLHQpe2lmKGlzTmFOKGUpKXJldHVybiB0P2I6bTtpZih0KXtpZihlPDApcmV0dXJuIGI7aWYoZT49ZilyZXR1cm4geH1lbHNle2lmKGU8PS1oKXJldHVybiBUO2lmKGUrMT49aClyZXR1cm4gdn1yZXR1cm4gZTwwP3MoLWUsdCkubmVnKCk6dShlJWR8MCxlL2R8MCx0KX1mdW5jdGlvbiB1KGUsdCxyKXtyZXR1cm4gbmV3IG4oZSx0LHIpfW4uZnJvbUludD1hLG4uZnJvbU51bWJlcj1zLG4uZnJvbUJpdHM9dTt2YXIgbD1NYXRoLnBvdztmdW5jdGlvbiBjKGUsdCxuKXtpZigwPT09ZS5sZW5ndGgpdGhyb3cgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7aWYoXCJOYU5cIj09PWV8fFwiSW5maW5pdHlcIj09PWV8fFwiK0luZmluaXR5XCI9PT1lfHxcIi1JbmZpbml0eVwiPT09ZSlyZXR1cm4gbTtpZihcIm51bWJlclwiPT10eXBlb2YgdD8obj10LHQ9ITEpOnQ9ISF0LChuPW58fDEwKTwyfHwzNjxuKXRocm93IFJhbmdlRXJyb3IoXCJyYWRpeFwiKTt2YXIgcjtpZigocj1lLmluZGV4T2YoXCItXCIpKT4wKXRocm93IEVycm9yKFwiaW50ZXJpb3IgaHlwaGVuXCIpO2lmKDA9PT1yKXJldHVybiBjKGUuc3Vic3RyaW5nKDEpLHQsbikubmVnKCk7Zm9yKHZhciBvPXMobChuLDgpKSxpPW0sYT0wO2E8ZS5sZW5ndGg7YSs9OCl7dmFyIHU9TWF0aC5taW4oOCxlLmxlbmd0aC1hKSxwPXBhcnNlSW50KGUuc3Vic3RyaW5nKGEsYSt1KSxuKTtpZih1PDgpe3ZhciBkPXMobChuLHUpKTtpPWkubXVsKGQpLmFkZChzKHApKX1lbHNlIGk9KGk9aS5tdWwobykpLmFkZChzKHApKX1yZXR1cm4gaS51bnNpZ25lZD10LGl9ZnVuY3Rpb24gcChlLHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBlP3MoZSx0KTpcInN0cmluZ1wiPT10eXBlb2YgZT9jKGUsdCk6dShlLmxvdyxlLmhpZ2gsXCJib29sZWFuXCI9PXR5cGVvZiB0P3Q6ZS51bnNpZ25lZCl9bi5mcm9tU3RyaW5nPWMsbi5mcm9tVmFsdWU9cDt2YXIgZD00Mjk0OTY3Mjk2LGY9ZCpkLGg9Zi8yLGc9YSgxPDwyNCksbT1hKDApO24uWkVSTz1tO3ZhciBiPWEoMCwhMCk7bi5VWkVSTz1iO3ZhciB5PWEoMSk7bi5PTkU9eTt2YXIgdz1hKDEsITApO24uVU9ORT13O3ZhciBfPWEoLTEpO24uTkVHX09ORT1fO3ZhciB2PXUoLTEsMjE0NzQ4MzY0NywhMSk7bi5NQVhfVkFMVUU9djt2YXIgeD11KC0xLC0xLCEwKTtuLk1BWF9VTlNJR05FRF9WQUxVRT14O3ZhciBUPXUoMCwtMjE0NzQ4MzY0OCwhMSk7bi5NSU5fVkFMVUU9VDt2YXIgUz1uLnByb3RvdHlwZTtTLnRvSW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5zaWduZWQ/dGhpcy5sb3c+Pj4wOnRoaXMubG93fSxTLnRvTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5zaWduZWQ/KHRoaXMuaGlnaD4+PjApKmQrKHRoaXMubG93Pj4+MCk6dGhpcy5oaWdoKmQrKHRoaXMubG93Pj4+MCl9LFMudG9TdHJpbmc9ZnVuY3Rpb24oZSl7aWYoKGU9ZXx8MTApPDJ8fDM2PGUpdGhyb3cgUmFuZ2VFcnJvcihcInJhZGl4XCIpO2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuXCIwXCI7aWYodGhpcy5pc05lZ2F0aXZlKCkpe2lmKHRoaXMuZXEoVCkpe3ZhciB0PXMoZSksbj10aGlzLmRpdih0KSxyPW4ubXVsKHQpLnN1Yih0aGlzKTtyZXR1cm4gbi50b1N0cmluZyhlKStyLnRvSW50KCkudG9TdHJpbmcoZSl9cmV0dXJuXCItXCIrdGhpcy5uZWcoKS50b1N0cmluZyhlKX1mb3IodmFyIG89cyhsKGUsNiksdGhpcy51bnNpZ25lZCksaT10aGlzLGE9XCJcIjs7KXt2YXIgdT1pLmRpdihvKSxjPShpLnN1Yih1Lm11bChvKSkudG9JbnQoKT4+PjApLnRvU3RyaW5nKGUpO2lmKChpPXUpLmlzWmVybygpKXJldHVybiBjK2E7Zm9yKDtjLmxlbmd0aDw2OyljPVwiMFwiK2M7YT1cIlwiK2MrYX19LFMuZ2V0SGlnaEJpdHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oaWdofSxTLmdldEhpZ2hCaXRzVW5zaWduZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oaWdoPj4+MH0sUy5nZXRMb3dCaXRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubG93fSxTLmdldExvd0JpdHNVbnNpZ25lZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxvdz4+PjB9LFMuZ2V0TnVtQml0c0Ficz1mdW5jdGlvbigpe2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiB0aGlzLmVxKFQpPzY0OnRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO2Zvcih2YXIgZT0wIT10aGlzLmhpZ2g/dGhpcy5oaWdoOnRoaXMubG93LHQ9MzE7dD4wJiYwPT0oZSYxPDx0KTt0LS0pO3JldHVybiAwIT10aGlzLmhpZ2g/dCszMzp0KzF9LFMuaXNaZXJvPWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmhpZ2gmJjA9PT10aGlzLmxvd30sUy5lcXo9Uy5pc1plcm8sUy5pc05lZ2F0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMudW5zaWduZWQmJnRoaXMuaGlnaDwwfSxTLmlzUG9zaXRpdmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZHx8dGhpcy5oaWdoPj0wfSxTLmlzT2RkPWZ1bmN0aW9uKCl7cmV0dXJuIDE9PSgxJnRoaXMubG93KX0sUy5pc0V2ZW49ZnVuY3Rpb24oKXtyZXR1cm4gMD09KDEmdGhpcy5sb3cpfSxTLmVxdWFscz1mdW5jdGlvbihlKXtyZXR1cm4gcihlKXx8KGU9cChlKSksKHRoaXMudW5zaWduZWQ9PT1lLnVuc2lnbmVkfHx0aGlzLmhpZ2g+Pj4zMSE9MXx8ZS5oaWdoPj4+MzEhPTEpJiZ0aGlzLmhpZ2g9PT1lLmhpZ2gmJnRoaXMubG93PT09ZS5sb3d9LFMuZXE9Uy5lcXVhbHMsUy5ub3RFcXVhbHM9ZnVuY3Rpb24oZSl7cmV0dXJuIXRoaXMuZXEoZSl9LFMubmVxPVMubm90RXF1YWxzLFMubmU9Uy5ub3RFcXVhbHMsUy5sZXNzVGhhbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jb21wKGUpPDB9LFMubHQ9Uy5sZXNzVGhhbixTLmxlc3NUaGFuT3JFcXVhbD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jb21wKGUpPD0wfSxTLmx0ZT1TLmxlc3NUaGFuT3JFcXVhbCxTLmxlPVMubGVzc1RoYW5PckVxdWFsLFMuZ3JlYXRlclRoYW49ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY29tcChlKT4wfSxTLmd0PVMuZ3JlYXRlclRoYW4sUy5ncmVhdGVyVGhhbk9yRXF1YWw9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY29tcChlKT49MH0sUy5ndGU9Uy5ncmVhdGVyVGhhbk9yRXF1YWwsUy5nZT1TLmdyZWF0ZXJUaGFuT3JFcXVhbCxTLmNvbXBhcmU9ZnVuY3Rpb24oZSl7aWYocihlKXx8KGU9cChlKSksdGhpcy5lcShlKSlyZXR1cm4gMDt2YXIgdD10aGlzLmlzTmVnYXRpdmUoKSxuPWUuaXNOZWdhdGl2ZSgpO3JldHVybiB0JiYhbj8tMTohdCYmbj8xOnRoaXMudW5zaWduZWQ/ZS5oaWdoPj4+MD50aGlzLmhpZ2g+Pj4wfHxlLmhpZ2g9PT10aGlzLmhpZ2gmJmUubG93Pj4+MD50aGlzLmxvdz4+PjA/LTE6MTp0aGlzLnN1YihlKS5pc05lZ2F0aXZlKCk/LTE6MX0sUy5jb21wPVMuY29tcGFyZSxTLm5lZ2F0ZT1mdW5jdGlvbigpe3JldHVybiF0aGlzLnVuc2lnbmVkJiZ0aGlzLmVxKFQpP1Q6dGhpcy5ub3QoKS5hZGQoeSl9LFMubmVnPVMubmVnYXRlLFMuYWRkPWZ1bmN0aW9uKGUpe3IoZSl8fChlPXAoZSkpO3ZhciB0PXRoaXMuaGlnaD4+PjE2LG49NjU1MzUmdGhpcy5oaWdoLG89dGhpcy5sb3c+Pj4xNixpPTY1NTM1JnRoaXMubG93LGE9ZS5oaWdoPj4+MTYscz02NTUzNSZlLmhpZ2gsbD1lLmxvdz4+PjE2LGM9MCxkPTAsZj0wLGg9MDtyZXR1cm4gZis9KGgrPWkrKDY1NTM1JmUubG93KSk+Pj4xNixkKz0oZis9bytsKT4+PjE2LGMrPShkKz1uK3MpPj4+MTYsYys9dCthLHUoKGYmPTY1NTM1KTw8MTZ8KGgmPTY1NTM1KSwoYyY9NjU1MzUpPDwxNnwoZCY9NjU1MzUpLHRoaXMudW5zaWduZWQpfSxTLnN1YnRyYWN0PWZ1bmN0aW9uKGUpe3JldHVybiByKGUpfHwoZT1wKGUpKSx0aGlzLmFkZChlLm5lZygpKX0sUy5zdWI9Uy5zdWJ0cmFjdCxTLm11bHRpcGx5PWZ1bmN0aW9uKGUpe2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIG07aWYocihlKXx8KGU9cChlKSksdClyZXR1cm4gdSh0Lm11bCh0aGlzLmxvdyx0aGlzLmhpZ2gsZS5sb3csZS5oaWdoKSx0LmdldF9oaWdoKCksdGhpcy51bnNpZ25lZCk7aWYoZS5pc1plcm8oKSlyZXR1cm4gbTtpZih0aGlzLmVxKFQpKXJldHVybiBlLmlzT2RkKCk/VDptO2lmKGUuZXEoVCkpcmV0dXJuIHRoaXMuaXNPZGQoKT9UOm07aWYodGhpcy5pc05lZ2F0aXZlKCkpcmV0dXJuIGUuaXNOZWdhdGl2ZSgpP3RoaXMubmVnKCkubXVsKGUubmVnKCkpOnRoaXMubmVnKCkubXVsKGUpLm5lZygpO2lmKGUuaXNOZWdhdGl2ZSgpKXJldHVybiB0aGlzLm11bChlLm5lZygpKS5uZWcoKTtpZih0aGlzLmx0KGcpJiZlLmx0KGcpKXJldHVybiBzKHRoaXMudG9OdW1iZXIoKSplLnRvTnVtYmVyKCksdGhpcy51bnNpZ25lZCk7dmFyIG49dGhpcy5oaWdoPj4+MTYsbz02NTUzNSZ0aGlzLmhpZ2gsaT10aGlzLmxvdz4+PjE2LGE9NjU1MzUmdGhpcy5sb3csbD1lLmhpZ2g+Pj4xNixjPTY1NTM1JmUuaGlnaCxkPWUubG93Pj4+MTYsZj02NTUzNSZlLmxvdyxoPTAsYj0wLHk9MCx3PTA7cmV0dXJuIHkrPSh3Kz1hKmYpPj4+MTYsYis9KHkrPWkqZik+Pj4xNix5Jj02NTUzNSxiKz0oeSs9YSpkKT4+PjE2LGgrPShiKz1vKmYpPj4+MTYsYiY9NjU1MzUsaCs9KGIrPWkqZCk+Pj4xNixiJj02NTUzNSxoKz0oYis9YSpjKT4+PjE2LGgrPW4qZitvKmQraSpjK2EqbCx1KCh5Jj02NTUzNSk8PDE2fCh3Jj02NTUzNSksKGgmPTY1NTM1KTw8MTZ8KGImPTY1NTM1KSx0aGlzLnVuc2lnbmVkKX0sUy5tdWw9Uy5tdWx0aXBseSxTLmRpdmlkZT1mdW5jdGlvbihlKXtpZihyKGUpfHwoZT1wKGUpKSxlLmlzWmVybygpKXRocm93IEVycm9yKFwiZGl2aXNpb24gYnkgemVyb1wiKTt2YXIgbixvLGk7aWYodClyZXR1cm4gdGhpcy51bnNpZ25lZHx8LTIxNDc0ODM2NDghPT10aGlzLmhpZ2h8fC0xIT09ZS5sb3d8fC0xIT09ZS5oaWdoP3UoKHRoaXMudW5zaWduZWQ/dC5kaXZfdTp0LmRpdl9zKSh0aGlzLmxvdyx0aGlzLmhpZ2gsZS5sb3csZS5oaWdoKSx0LmdldF9oaWdoKCksdGhpcy51bnNpZ25lZCk6dGhpcztpZih0aGlzLmlzWmVybygpKXJldHVybiB0aGlzLnVuc2lnbmVkP2I6bTtpZih0aGlzLnVuc2lnbmVkKXtpZihlLnVuc2lnbmVkfHwoZT1lLnRvVW5zaWduZWQoKSksZS5ndCh0aGlzKSlyZXR1cm4gYjtpZihlLmd0KHRoaXMuc2hydSgxKSkpcmV0dXJuIHc7aT1ifWVsc2V7aWYodGhpcy5lcShUKSlyZXR1cm4gZS5lcSh5KXx8ZS5lcShfKT9UOmUuZXEoVCk/eToobj10aGlzLnNocigxKS5kaXYoZSkuc2hsKDEpKS5lcShtKT9lLmlzTmVnYXRpdmUoKT95Ol86KG89dGhpcy5zdWIoZS5tdWwobikpLGk9bi5hZGQoby5kaXYoZSkpKTtpZihlLmVxKFQpKXJldHVybiB0aGlzLnVuc2lnbmVkP2I6bTtpZih0aGlzLmlzTmVnYXRpdmUoKSlyZXR1cm4gZS5pc05lZ2F0aXZlKCk/dGhpcy5uZWcoKS5kaXYoZS5uZWcoKSk6dGhpcy5uZWcoKS5kaXYoZSkubmVnKCk7aWYoZS5pc05lZ2F0aXZlKCkpcmV0dXJuIHRoaXMuZGl2KGUubmVnKCkpLm5lZygpO2k9bX1mb3Iobz10aGlzO28uZ3RlKGUpOyl7bj1NYXRoLm1heCgxLE1hdGguZmxvb3Ioby50b051bWJlcigpL2UudG9OdW1iZXIoKSkpO2Zvcih2YXIgYT1NYXRoLmNlaWwoTWF0aC5sb2cobikvTWF0aC5MTjIpLGM9YTw9NDg/MTpsKDIsYS00OCksZD1zKG4pLGY9ZC5tdWwoZSk7Zi5pc05lZ2F0aXZlKCl8fGYuZ3Qobyk7KWY9KGQ9cyhuLT1jLHRoaXMudW5zaWduZWQpKS5tdWwoZSk7ZC5pc1plcm8oKSYmKGQ9eSksaT1pLmFkZChkKSxvPW8uc3ViKGYpfXJldHVybiBpfSxTLmRpdj1TLmRpdmlkZSxTLm1vZHVsbz1mdW5jdGlvbihlKXtyZXR1cm4gcihlKXx8KGU9cChlKSksdD91KCh0aGlzLnVuc2lnbmVkP3QucmVtX3U6dC5yZW1fcykodGhpcy5sb3csdGhpcy5oaWdoLGUubG93LGUuaGlnaCksdC5nZXRfaGlnaCgpLHRoaXMudW5zaWduZWQpOnRoaXMuc3ViKHRoaXMuZGl2KGUpLm11bChlKSl9LFMubW9kPVMubW9kdWxvLFMucmVtPVMubW9kdWxvLFMubm90PWZ1bmN0aW9uKCl7cmV0dXJuIHUofnRoaXMubG93LH50aGlzLmhpZ2gsdGhpcy51bnNpZ25lZCl9LFMuYW5kPWZ1bmN0aW9uKGUpe3JldHVybiByKGUpfHwoZT1wKGUpKSx1KHRoaXMubG93JmUubG93LHRoaXMuaGlnaCZlLmhpZ2gsdGhpcy51bnNpZ25lZCl9LFMub3I9ZnVuY3Rpb24oZSl7cmV0dXJuIHIoZSl8fChlPXAoZSkpLHUodGhpcy5sb3d8ZS5sb3csdGhpcy5oaWdofGUuaGlnaCx0aGlzLnVuc2lnbmVkKX0sUy54b3I9ZnVuY3Rpb24oZSl7cmV0dXJuIHIoZSl8fChlPXAoZSkpLHUodGhpcy5sb3deZS5sb3csdGhpcy5oaWdoXmUuaGlnaCx0aGlzLnVuc2lnbmVkKX0sUy5zaGlmdExlZnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHIoZSkmJihlPWUudG9JbnQoKSksMD09KGUmPTYzKT90aGlzOmU8MzI/dSh0aGlzLmxvdzw8ZSx0aGlzLmhpZ2g8PGV8dGhpcy5sb3c+Pj4zMi1lLHRoaXMudW5zaWduZWQpOnUoMCx0aGlzLmxvdzw8ZS0zMix0aGlzLnVuc2lnbmVkKX0sUy5zaGw9Uy5zaGlmdExlZnQsUy5zaGlmdFJpZ2h0PWZ1bmN0aW9uKGUpe3JldHVybiByKGUpJiYoZT1lLnRvSW50KCkpLDA9PShlJj02Myk/dGhpczplPDMyP3UodGhpcy5sb3c+Pj5lfHRoaXMuaGlnaDw8MzItZSx0aGlzLmhpZ2g+PmUsdGhpcy51bnNpZ25lZCk6dSh0aGlzLmhpZ2g+PmUtMzIsdGhpcy5oaWdoPj0wPzA6LTEsdGhpcy51bnNpZ25lZCl9LFMuc2hyPVMuc2hpZnRSaWdodCxTLnNoaWZ0UmlnaHRVbnNpZ25lZD1mdW5jdGlvbihlKXtpZihyKGUpJiYoZT1lLnRvSW50KCkpLDA9PShlJj02MykpcmV0dXJuIHRoaXM7dmFyIHQ9dGhpcy5oaWdoO3JldHVybiBlPDMyP3UodGhpcy5sb3c+Pj5lfHQ8PDMyLWUsdD4+PmUsdGhpcy51bnNpZ25lZCk6dSgzMj09PWU/dDp0Pj4+ZS0zMiwwLHRoaXMudW5zaWduZWQpfSxTLnNocnU9Uy5zaGlmdFJpZ2h0VW5zaWduZWQsUy5zaHJfdT1TLnNoaWZ0UmlnaHRVbnNpZ25lZCxTLnRvU2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5zaWduZWQ/dSh0aGlzLmxvdyx0aGlzLmhpZ2gsITEpOnRoaXN9LFMudG9VbnNpZ25lZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkP3RoaXM6dSh0aGlzLmxvdyx0aGlzLmhpZ2gsITApfSxTLnRvQnl0ZXM9ZnVuY3Rpb24oZSl7cmV0dXJuIGU/dGhpcy50b0J5dGVzTEUoKTp0aGlzLnRvQnl0ZXNCRSgpfSxTLnRvQnl0ZXNMRT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuaGlnaCx0PXRoaXMubG93O3JldHVyblsyNTUmdCx0Pj4+OCYyNTUsdD4+PjE2JjI1NSx0Pj4+MjQsMjU1JmUsZT4+PjgmMjU1LGU+Pj4xNiYyNTUsZT4+PjI0XX0sUy50b0J5dGVzQkU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmhpZ2gsdD10aGlzLmxvdztyZXR1cm5bZT4+PjI0LGU+Pj4xNiYyNTUsZT4+PjgmMjU1LDI1NSZlLHQ+Pj4yNCx0Pj4+MTYmMjU1LHQ+Pj44JjI1NSwyNTUmdF19LG4uZnJvbUJ5dGVzPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gcj9uLmZyb21CeXRlc0xFKGUsdCk6bi5mcm9tQnl0ZXNCRShlLHQpfSxuLmZyb21CeXRlc0xFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBuKGVbMF18ZVsxXTw8OHxlWzJdPDwxNnxlWzNdPDwyNCxlWzRdfGVbNV08PDh8ZVs2XTw8MTZ8ZVs3XTw8MjQsdCl9LG4uZnJvbUJ5dGVzQkU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IG4oZVs0XTw8MjR8ZVs1XTw8MTZ8ZVs2XTw8OHxlWzddLGVbMF08PDI0fGVbMV08PDE2fGVbMl08PDh8ZVszXSx0KX19LDE0NDY6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO3ZhciByLG8saSxhPW4oMjEwMCkscz1hLlJlYWRlcix1PWEuV3JpdGVyLGw9YS51dGlsLGM9YS5yb290cy5kZWZhdWx0fHwoYS5yb290cy5kZWZhdWx0PXt9KTtjLm9ubng9KChpPXt9KS5WZXJzaW9uPShyPXt9LChvPU9iamVjdC5jcmVhdGUocikpW3JbMF09XCJfU1RBUlRfVkVSU0lPTlwiXT0wLG9bclsxXT1cIklSX1ZFUlNJT05fMjAxN18xMF8xMFwiXT0xLG9bclsyXT1cIklSX1ZFUlNJT05fMjAxN18xMF8zMFwiXT0yLG9bclszXT1cIklSX1ZFUlNJT05fMjAxN18xMV8zXCJdPTMsb1tyWzRdPVwiSVJfVkVSU0lPTl8yMDE5XzFfMjJcIl09NCxvW3JbNV09XCJJUl9WRVJTSU9OXCJdPTUsbyksaS5BdHRyaWJ1dGVQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYodGhpcy5mbG9hdHM9W10sdGhpcy5pbnRzPVtdLHRoaXMuc3RyaW5ncz1bXSx0aGlzLnRlbnNvcnM9W10sdGhpcy5ncmFwaHM9W10sZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXJldHVybiBlLnByb3RvdHlwZS5uYW1lPVwiXCIsZS5wcm90b3R5cGUucmVmQXR0ck5hbWU9XCJcIixlLnByb3RvdHlwZS5kb2NTdHJpbmc9XCJcIixlLnByb3RvdHlwZS50eXBlPTAsZS5wcm90b3R5cGUuZj0wLGUucHJvdG90eXBlLmk9bC5Mb25nP2wuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsZS5wcm90b3R5cGUucz1sLm5ld0J1ZmZlcihbXSksZS5wcm90b3R5cGUudD1udWxsLGUucHJvdG90eXBlLmc9bnVsbCxlLnByb3RvdHlwZS5mbG9hdHM9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLmludHM9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLnN0cmluZ3M9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLnRlbnNvcnM9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLmdyYXBocz1sLmVtcHR5QXJyYXksZS5jcmVhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpfSxlLmVuY29kZT1mdW5jdGlvbihlLHQpe2lmKHR8fCh0PXUuY3JlYXRlKCkpLG51bGwhPWUubmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJnQudWludDMyKDEwKS5zdHJpbmcoZS5uYW1lKSxudWxsIT1lLmYmJmUuaGFzT3duUHJvcGVydHkoXCJmXCIpJiZ0LnVpbnQzMigyMSkuZmxvYXQoZS5mKSxudWxsIT1lLmkmJmUuaGFzT3duUHJvcGVydHkoXCJpXCIpJiZ0LnVpbnQzMigyNCkuaW50NjQoZS5pKSxudWxsIT1lLnMmJmUuaGFzT3duUHJvcGVydHkoXCJzXCIpJiZ0LnVpbnQzMigzNCkuYnl0ZXMoZS5zKSxudWxsIT1lLnQmJmUuaGFzT3duUHJvcGVydHkoXCJ0XCIpJiZjLm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKGUudCx0LnVpbnQzMig0MikuZm9yaygpKS5sZGVsaW0oKSxudWxsIT1lLmcmJmUuaGFzT3duUHJvcGVydHkoXCJnXCIpJiZjLm9ubnguR3JhcGhQcm90by5lbmNvZGUoZS5nLHQudWludDMyKDUwKS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPWUuZmxvYXRzJiZlLmZsb2F0cy5sZW5ndGgpe3QudWludDMyKDU4KS5mb3JrKCk7Zm9yKHZhciBuPTA7bjxlLmZsb2F0cy5sZW5ndGg7KytuKXQuZmxvYXQoZS5mbG9hdHNbbl0pO3QubGRlbGltKCl9aWYobnVsbCE9ZS5pbnRzJiZlLmludHMubGVuZ3RoKXtmb3IodC51aW50MzIoNjYpLmZvcmsoKSxuPTA7bjxlLmludHMubGVuZ3RoOysrbil0LmludDY0KGUuaW50c1tuXSk7dC5sZGVsaW0oKX1pZihudWxsIT1lLnN0cmluZ3MmJmUuc3RyaW5ncy5sZW5ndGgpZm9yKG49MDtuPGUuc3RyaW5ncy5sZW5ndGg7KytuKXQudWludDMyKDc0KS5ieXRlcyhlLnN0cmluZ3Nbbl0pO2lmKG51bGwhPWUudGVuc29ycyYmZS50ZW5zb3JzLmxlbmd0aClmb3Iobj0wO248ZS50ZW5zb3JzLmxlbmd0aDsrK24pYy5vbm54LlRlbnNvclByb3RvLmVuY29kZShlLnRlbnNvcnNbbl0sdC51aW50MzIoODIpLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9ZS5ncmFwaHMmJmUuZ3JhcGhzLmxlbmd0aClmb3Iobj0wO248ZS5ncmFwaHMubGVuZ3RoOysrbiljLm9ubnguR3JhcGhQcm90by5lbmNvZGUoZS5ncmFwaHNbbl0sdC51aW50MzIoOTApLmZvcmsoKSkubGRlbGltKCk7cmV0dXJuIG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiZ0LnVpbnQzMigxMDYpLnN0cmluZyhlLmRvY1N0cmluZyksbnVsbCE9ZS50eXBlJiZlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSYmdC51aW50MzIoMTYwKS5pbnQzMihlLnR5cGUpLG51bGwhPWUucmVmQXR0ck5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJyZWZBdHRyTmFtZVwiKSYmdC51aW50MzIoMTcwKS5zdHJpbmcoZS5yZWZBdHRyTmFtZSksdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2Ygc3x8KGU9cy5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54LkF0dHJpYnV0ZVByb3RvO2UucG9zPG47KXt2YXIgbz1lLnVpbnQzMigpO3N3aXRjaChvPj4+Myl7Y2FzZSAxOnIubmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMjE6ci5yZWZBdHRyTmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMTM6ci5kb2NTdHJpbmc9ZS5zdHJpbmcoKTticmVhaztjYXNlIDIwOnIudHlwZT1lLmludDMyKCk7YnJlYWs7Y2FzZSAyOnIuZj1lLmZsb2F0KCk7YnJlYWs7Y2FzZSAzOnIuaT1lLmludDY0KCk7YnJlYWs7Y2FzZSA0OnIucz1lLmJ5dGVzKCk7YnJlYWs7Y2FzZSA1OnIudD1jLm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7Y2FzZSA2OnIuZz1jLm9ubnguR3JhcGhQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDc6aWYoci5mbG9hdHMmJnIuZmxvYXRzLmxlbmd0aHx8KHIuZmxvYXRzPVtdKSwyPT0oNyZvKSlmb3IodmFyIGk9ZS51aW50MzIoKStlLnBvcztlLnBvczxpOylyLmZsb2F0cy5wdXNoKGUuZmxvYXQoKSk7ZWxzZSByLmZsb2F0cy5wdXNoKGUuZmxvYXQoKSk7YnJlYWs7Y2FzZSA4OmlmKHIuaW50cyYmci5pbnRzLmxlbmd0aHx8KHIuaW50cz1bXSksMj09KDcmbykpZm9yKGk9ZS51aW50MzIoKStlLnBvcztlLnBvczxpOylyLmludHMucHVzaChlLmludDY0KCkpO2Vsc2Ugci5pbnRzLnB1c2goZS5pbnQ2NCgpKTticmVhaztjYXNlIDk6ci5zdHJpbmdzJiZyLnN0cmluZ3MubGVuZ3RofHwoci5zdHJpbmdzPVtdKSxyLnN0cmluZ3MucHVzaChlLmJ5dGVzKCkpO2JyZWFrO2Nhc2UgMTA6ci50ZW5zb3JzJiZyLnRlbnNvcnMubGVuZ3RofHwoci50ZW5zb3JzPVtdKSxyLnRlbnNvcnMucHVzaChjLm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMTE6ci5ncmFwaHMmJnIuZ3JhcGhzLmxlbmd0aHx8KHIuZ3JhcGhzPVtdKSxyLmdyYXBocy5wdXNoKGMub25ueC5HcmFwaFByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZvKX19cmV0dXJuIHJ9LGUuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2Ygc3x8KGU9bmV3IHMoZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LGUudmVyaWZ5PWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZSlyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPWUubmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFsLmlzU3RyaW5nKGUubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLnJlZkF0dHJOYW1lJiZlLmhhc093blByb3BlcnR5KFwicmVmQXR0ck5hbWVcIikmJiFsLmlzU3RyaW5nKGUucmVmQXR0ck5hbWUpKXJldHVyblwicmVmQXR0ck5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhbC5pc1N0cmluZyhlLmRvY1N0cmluZykpcmV0dXJuXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPWUudHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpc3dpdGNoKGUudHlwZSl7ZGVmYXVsdDpyZXR1cm5cInR5cGU6IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtjYXNlIDA6Y2FzZSAxOmNhc2UgMjpjYXNlIDM6Y2FzZSA0OmNhc2UgNTpjYXNlIDY6Y2FzZSA3OmNhc2UgODpjYXNlIDk6Y2FzZSAxMDp9aWYobnVsbCE9ZS5mJiZlLmhhc093blByb3BlcnR5KFwiZlwiKSYmXCJudW1iZXJcIiE9dHlwZW9mIGUuZilyZXR1cm5cImY6IG51bWJlciBleHBlY3RlZFwiO2lmKG51bGwhPWUuaSYmZS5oYXNPd25Qcm9wZXJ0eShcImlcIikmJiEobC5pc0ludGVnZXIoZS5pKXx8ZS5pJiZsLmlzSW50ZWdlcihlLmkubG93KSYmbC5pc0ludGVnZXIoZS5pLmhpZ2gpKSlyZXR1cm5cImk6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO2lmKG51bGwhPWUucyYmZS5oYXNPd25Qcm9wZXJ0eShcInNcIikmJiEoZS5zJiZcIm51bWJlclwiPT10eXBlb2YgZS5zLmxlbmd0aHx8bC5pc1N0cmluZyhlLnMpKSlyZXR1cm5cInM6IGJ1ZmZlciBleHBlY3RlZFwiO2lmKG51bGwhPWUudCYmZS5oYXNPd25Qcm9wZXJ0eShcInRcIikmJihuPWMub25ueC5UZW5zb3JQcm90by52ZXJpZnkoZS50KSkpcmV0dXJuXCJ0LlwiK247aWYobnVsbCE9ZS5nJiZlLmhhc093blByb3BlcnR5KFwiZ1wiKSYmKG49Yy5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KGUuZykpKXJldHVyblwiZy5cIituO2lmKG51bGwhPWUuZmxvYXRzJiZlLmhhc093blByb3BlcnR5KFwiZmxvYXRzXCIpKXtpZighQXJyYXkuaXNBcnJheShlLmZsb2F0cykpcmV0dXJuXCJmbG9hdHM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciB0PTA7dDxlLmZsb2F0cy5sZW5ndGg7Kyt0KWlmKFwibnVtYmVyXCIhPXR5cGVvZiBlLmZsb2F0c1t0XSlyZXR1cm5cImZsb2F0czogbnVtYmVyW10gZXhwZWN0ZWRcIn1pZihudWxsIT1lLmludHMmJmUuaGFzT3duUHJvcGVydHkoXCJpbnRzXCIpKXtpZighQXJyYXkuaXNBcnJheShlLmludHMpKXJldHVyblwiaW50czogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5pbnRzLmxlbmd0aDsrK3QpaWYoIShsLmlzSW50ZWdlcihlLmludHNbdF0pfHxlLmludHNbdF0mJmwuaXNJbnRlZ2VyKGUuaW50c1t0XS5sb3cpJiZsLmlzSW50ZWdlcihlLmludHNbdF0uaGlnaCkpKXJldHVyblwiaW50czogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWRcIn1pZihudWxsIT1lLnN0cmluZ3MmJmUuaGFzT3duUHJvcGVydHkoXCJzdHJpbmdzXCIpKXtpZighQXJyYXkuaXNBcnJheShlLnN0cmluZ3MpKXJldHVyblwic3RyaW5nczogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5zdHJpbmdzLmxlbmd0aDsrK3QpaWYoIShlLnN0cmluZ3NbdF0mJlwibnVtYmVyXCI9PXR5cGVvZiBlLnN0cmluZ3NbdF0ubGVuZ3RofHxsLmlzU3RyaW5nKGUuc3RyaW5nc1t0XSkpKXJldHVyblwic3RyaW5nczogYnVmZmVyW10gZXhwZWN0ZWRcIn1pZihudWxsIT1lLnRlbnNvcnMmJmUuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JzXCIpKXtpZighQXJyYXkuaXNBcnJheShlLnRlbnNvcnMpKXJldHVyblwidGVuc29yczogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS50ZW5zb3JzLmxlbmd0aDsrK3QpaWYobj1jLm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KGUudGVuc29yc1t0XSkpcmV0dXJuXCJ0ZW5zb3JzLlwiK259aWYobnVsbCE9ZS5ncmFwaHMmJmUuaGFzT3duUHJvcGVydHkoXCJncmFwaHNcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuZ3JhcGhzKSlyZXR1cm5cImdyYXBoczogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5ncmFwaHMubGVuZ3RoOysrdCl7dmFyIG47aWYobj1jLm9ubnguR3JhcGhQcm90by52ZXJpZnkoZS5ncmFwaHNbdF0pKXJldHVyblwiZ3JhcGhzLlwiK259fXJldHVybiBudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5BdHRyaWJ1dGVQcm90bylyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54LkF0dHJpYnV0ZVByb3RvO3N3aXRjaChudWxsIT1lLm5hbWUmJih0Lm5hbWU9U3RyaW5nKGUubmFtZSkpLG51bGwhPWUucmVmQXR0ck5hbWUmJih0LnJlZkF0dHJOYW1lPVN0cmluZyhlLnJlZkF0dHJOYW1lKSksbnVsbCE9ZS5kb2NTdHJpbmcmJih0LmRvY1N0cmluZz1TdHJpbmcoZS5kb2NTdHJpbmcpKSxlLnR5cGUpe2Nhc2VcIlVOREVGSU5FRFwiOmNhc2UgMDp0LnR5cGU9MDticmVhaztjYXNlXCJGTE9BVFwiOmNhc2UgMTp0LnR5cGU9MTticmVhaztjYXNlXCJJTlRcIjpjYXNlIDI6dC50eXBlPTI7YnJlYWs7Y2FzZVwiU1RSSU5HXCI6Y2FzZSAzOnQudHlwZT0zO2JyZWFrO2Nhc2VcIlRFTlNPUlwiOmNhc2UgNDp0LnR5cGU9NDticmVhaztjYXNlXCJHUkFQSFwiOmNhc2UgNTp0LnR5cGU9NTticmVhaztjYXNlXCJGTE9BVFNcIjpjYXNlIDY6dC50eXBlPTY7YnJlYWs7Y2FzZVwiSU5UU1wiOmNhc2UgNzp0LnR5cGU9NzticmVhaztjYXNlXCJTVFJJTkdTXCI6Y2FzZSA4OnQudHlwZT04O2JyZWFrO2Nhc2VcIlRFTlNPUlNcIjpjYXNlIDk6dC50eXBlPTk7YnJlYWs7Y2FzZVwiR1JBUEhTXCI6Y2FzZSAxMDp0LnR5cGU9MTB9aWYobnVsbCE9ZS5mJiYodC5mPU51bWJlcihlLmYpKSxudWxsIT1lLmkmJihsLkxvbmc/KHQuaT1sLkxvbmcuZnJvbVZhbHVlKGUuaSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLmk/dC5pPXBhcnNlSW50KGUuaSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUuaT90Lmk9ZS5pOlwib2JqZWN0XCI9PXR5cGVvZiBlLmkmJih0Lmk9bmV3IGwuTG9uZ0JpdHMoZS5pLmxvdz4+PjAsZS5pLmhpZ2g+Pj4wKS50b051bWJlcigpKSksbnVsbCE9ZS5zJiYoXCJzdHJpbmdcIj09dHlwZW9mIGUucz9sLmJhc2U2NC5kZWNvZGUoZS5zLHQucz1sLm5ld0J1ZmZlcihsLmJhc2U2NC5sZW5ndGgoZS5zKSksMCk6ZS5zLmxlbmd0aCYmKHQucz1lLnMpKSxudWxsIT1lLnQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLnQpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udDogb2JqZWN0IGV4cGVjdGVkXCIpO3QudD1jLm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChlLnQpfWlmKG51bGwhPWUuZyl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuZyl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5nOiBvYmplY3QgZXhwZWN0ZWRcIik7dC5nPWMub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3QoZS5nKX1pZihlLmZsb2F0cyl7aWYoIUFycmF5LmlzQXJyYXkoZS5mbG9hdHMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmZsb2F0czogYXJyYXkgZXhwZWN0ZWRcIik7dC5mbG9hdHM9W107Zm9yKHZhciBuPTA7bjxlLmZsb2F0cy5sZW5ndGg7KytuKXQuZmxvYXRzW25dPU51bWJlcihlLmZsb2F0c1tuXSl9aWYoZS5pbnRzKXtpZighQXJyYXkuaXNBcnJheShlLmludHMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmludHM6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LmludHM9W10sbj0wO248ZS5pbnRzLmxlbmd0aDsrK24pbC5Mb25nPyh0LmludHNbbl09bC5Mb25nLmZyb21WYWx1ZShlLmludHNbbl0pKS51bnNpZ25lZD0hMTpcInN0cmluZ1wiPT10eXBlb2YgZS5pbnRzW25dP3QuaW50c1tuXT1wYXJzZUludChlLmludHNbbl0sMTApOlwibnVtYmVyXCI9PXR5cGVvZiBlLmludHNbbl0/dC5pbnRzW25dPWUuaW50c1tuXTpcIm9iamVjdFwiPT10eXBlb2YgZS5pbnRzW25dJiYodC5pbnRzW25dPW5ldyBsLkxvbmdCaXRzKGUuaW50c1tuXS5sb3c+Pj4wLGUuaW50c1tuXS5oaWdoPj4+MCkudG9OdW1iZXIoKSl9aWYoZS5zdHJpbmdzKXtpZighQXJyYXkuaXNBcnJheShlLnN0cmluZ3MpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnN0cmluZ3M6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LnN0cmluZ3M9W10sbj0wO248ZS5zdHJpbmdzLmxlbmd0aDsrK24pXCJzdHJpbmdcIj09dHlwZW9mIGUuc3RyaW5nc1tuXT9sLmJhc2U2NC5kZWNvZGUoZS5zdHJpbmdzW25dLHQuc3RyaW5nc1tuXT1sLm5ld0J1ZmZlcihsLmJhc2U2NC5sZW5ndGgoZS5zdHJpbmdzW25dKSksMCk6ZS5zdHJpbmdzW25dLmxlbmd0aCYmKHQuc3RyaW5nc1tuXT1lLnN0cmluZ3Nbbl0pfWlmKGUudGVuc29ycyl7aWYoIUFycmF5LmlzQXJyYXkoZS50ZW5zb3JzKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by50ZW5zb3JzOiBhcnJheSBleHBlY3RlZFwiKTtmb3IodC50ZW5zb3JzPVtdLG49MDtuPGUudGVuc29ycy5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS50ZW5zb3JzW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnRlbnNvcnM6IG9iamVjdCBleHBlY3RlZFwiKTt0LnRlbnNvcnNbbl09Yy5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3QoZS50ZW5zb3JzW25dKX19aWYoZS5ncmFwaHMpe2lmKCFBcnJheS5pc0FycmF5KGUuZ3JhcGhzKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5ncmFwaHM6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LmdyYXBocz1bXSxuPTA7bjxlLmdyYXBocy5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5ncmFwaHNbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uZ3JhcGhzOiBvYmplY3QgZXhwZWN0ZWRcIik7dC5ncmFwaHNbbl09Yy5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdChlLmdyYXBoc1tuXSl9fXJldHVybiB0fSxlLnRvT2JqZWN0PWZ1bmN0aW9uKGUsdCl7dHx8KHQ9e30pO3ZhciBuPXt9O2lmKCh0LmFycmF5c3x8dC5kZWZhdWx0cykmJihuLmZsb2F0cz1bXSxuLmludHM9W10sbi5zdHJpbmdzPVtdLG4udGVuc29ycz1bXSxuLmdyYXBocz1bXSksdC5kZWZhdWx0cyl7aWYobi5uYW1lPVwiXCIsbi5mPTAsbC5Mb25nKXt2YXIgcj1uZXcgbC5Mb25nKDAsMCwhMSk7bi5pPXQubG9uZ3M9PT1TdHJpbmc/ci50b1N0cmluZygpOnQubG9uZ3M9PT1OdW1iZXI/ci50b051bWJlcigpOnJ9ZWxzZSBuLmk9dC5sb25ncz09PVN0cmluZz9cIjBcIjowO3QuYnl0ZXM9PT1TdHJpbmc/bi5zPVwiXCI6KG4ucz1bXSx0LmJ5dGVzIT09QXJyYXkmJihuLnM9bC5uZXdCdWZmZXIobi5zKSkpLG4udD1udWxsLG4uZz1udWxsLG4uZG9jU3RyaW5nPVwiXCIsbi50eXBlPXQuZW51bXM9PT1TdHJpbmc/XCJVTkRFRklORURcIjowLG4ucmVmQXR0ck5hbWU9XCJcIn1pZihudWxsIT1lLm5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYobi5uYW1lPWUubmFtZSksbnVsbCE9ZS5mJiZlLmhhc093blByb3BlcnR5KFwiZlwiKSYmKG4uZj10Lmpzb24mJiFpc0Zpbml0ZShlLmYpP1N0cmluZyhlLmYpOmUuZiksbnVsbCE9ZS5pJiZlLmhhc093blByb3BlcnR5KFwiaVwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiBlLmk/bi5pPXQubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKGUuaSk6ZS5pOm4uaT10LmxvbmdzPT09U3RyaW5nP2wuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlLmkpOnQubG9uZ3M9PT1OdW1iZXI/bmV3IGwuTG9uZ0JpdHMoZS5pLmxvdz4+PjAsZS5pLmhpZ2g+Pj4wKS50b051bWJlcigpOmUuaSksbnVsbCE9ZS5zJiZlLmhhc093blByb3BlcnR5KFwic1wiKSYmKG4ucz10LmJ5dGVzPT09U3RyaW5nP2wuYmFzZTY0LmVuY29kZShlLnMsMCxlLnMubGVuZ3RoKTp0LmJ5dGVzPT09QXJyYXk/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZS5zKTplLnMpLG51bGwhPWUudCYmZS5oYXNPd25Qcm9wZXJ0eShcInRcIikmJihuLnQ9Yy5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KGUudCx0KSksbnVsbCE9ZS5nJiZlLmhhc093blByb3BlcnR5KFwiZ1wiKSYmKG4uZz1jLm9ubnguR3JhcGhQcm90by50b09iamVjdChlLmcsdCkpLGUuZmxvYXRzJiZlLmZsb2F0cy5sZW5ndGgpe24uZmxvYXRzPVtdO2Zvcih2YXIgbz0wO288ZS5mbG9hdHMubGVuZ3RoOysrbyluLmZsb2F0c1tvXT10Lmpzb24mJiFpc0Zpbml0ZShlLmZsb2F0c1tvXSk/U3RyaW5nKGUuZmxvYXRzW29dKTplLmZsb2F0c1tvXX1pZihlLmludHMmJmUuaW50cy5sZW5ndGgpZm9yKG4uaW50cz1bXSxvPTA7bzxlLmludHMubGVuZ3RoOysrbylcIm51bWJlclwiPT10eXBlb2YgZS5pbnRzW29dP24uaW50c1tvXT10LmxvbmdzPT09U3RyaW5nP1N0cmluZyhlLmludHNbb10pOmUuaW50c1tvXTpuLmludHNbb109dC5sb25ncz09PVN0cmluZz9sLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZS5pbnRzW29dKTp0LmxvbmdzPT09TnVtYmVyP25ldyBsLkxvbmdCaXRzKGUuaW50c1tvXS5sb3c+Pj4wLGUuaW50c1tvXS5oaWdoPj4+MCkudG9OdW1iZXIoKTplLmludHNbb107aWYoZS5zdHJpbmdzJiZlLnN0cmluZ3MubGVuZ3RoKWZvcihuLnN0cmluZ3M9W10sbz0wO288ZS5zdHJpbmdzLmxlbmd0aDsrK28pbi5zdHJpbmdzW29dPXQuYnl0ZXM9PT1TdHJpbmc/bC5iYXNlNjQuZW5jb2RlKGUuc3RyaW5nc1tvXSwwLGUuc3RyaW5nc1tvXS5sZW5ndGgpOnQuYnl0ZXM9PT1BcnJheT9BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLnN0cmluZ3Nbb10pOmUuc3RyaW5nc1tvXTtpZihlLnRlbnNvcnMmJmUudGVuc29ycy5sZW5ndGgpZm9yKG4udGVuc29ycz1bXSxvPTA7bzxlLnRlbnNvcnMubGVuZ3RoOysrbyluLnRlbnNvcnNbb109Yy5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KGUudGVuc29yc1tvXSx0KTtpZihlLmdyYXBocyYmZS5ncmFwaHMubGVuZ3RoKWZvcihuLmdyYXBocz1bXSxvPTA7bzxlLmdyYXBocy5sZW5ndGg7KytvKW4uZ3JhcGhzW29dPWMub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KGUuZ3JhcGhzW29dLHQpO3JldHVybiBudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmKG4uZG9jU3RyaW5nPWUuZG9jU3RyaW5nKSxudWxsIT1lLnR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpJiYobi50eXBlPXQuZW51bXM9PT1TdHJpbmc/Yy5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGVbZS50eXBlXTplLnR5cGUpLG51bGwhPWUucmVmQXR0ck5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJyZWZBdHRyTmFtZVwiKSYmKG4ucmVmQXR0ck5hbWU9ZS5yZWZBdHRyTmFtZSksbn0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LGUuQXR0cmlidXRlVHlwZT1mdW5jdGlvbigpe3ZhciBlPXt9LHQ9T2JqZWN0LmNyZWF0ZShlKTtyZXR1cm4gdFtlWzBdPVwiVU5ERUZJTkVEXCJdPTAsdFtlWzFdPVwiRkxPQVRcIl09MSx0W2VbMl09XCJJTlRcIl09Mix0W2VbM109XCJTVFJJTkdcIl09Myx0W2VbNF09XCJURU5TT1JcIl09NCx0W2VbNV09XCJHUkFQSFwiXT01LHRbZVs2XT1cIkZMT0FUU1wiXT02LHRbZVs3XT1cIklOVFNcIl09Nyx0W2VbOF09XCJTVFJJTkdTXCJdPTgsdFtlWzldPVwiVEVOU09SU1wiXT05LHRbZVsxMF09XCJHUkFQSFNcIl09MTAsdH0oKSxlfSgpLGkuVmFsdWVJbmZvUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLG49MDtuPHQubGVuZ3RoOysrbiludWxsIT1lW3Rbbl1dJiYodGhpc1t0W25dXT1lW3Rbbl1dKX1yZXR1cm4gZS5wcm90b3R5cGUubmFtZT1cIlwiLGUucHJvdG90eXBlLnR5cGU9bnVsbCxlLnByb3RvdHlwZS5kb2NTdHJpbmc9XCJcIixlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fCh0PXUuY3JlYXRlKCkpLG51bGwhPWUubmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJnQudWludDMyKDEwKS5zdHJpbmcoZS5uYW1lKSxudWxsIT1lLnR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpJiZjLm9ubnguVHlwZVByb3RvLmVuY29kZShlLnR5cGUsdC51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCksbnVsbCE9ZS5kb2NTdHJpbmcmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJnQudWludDMyKDI2KS5zdHJpbmcoZS5kb2NTdHJpbmcpLHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIHN8fChlPXMuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5WYWx1ZUluZm9Qcm90bztlLnBvczxuOyl7dmFyIG89ZS51aW50MzIoKTtzd2l0Y2gobz4+PjMpe2Nhc2UgMTpyLm5hbWU9ZS5zdHJpbmcoKTticmVhaztjYXNlIDI6ci50eXBlPWMub25ueC5UeXBlUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7Y2FzZSAzOnIuZG9jU3RyaW5nPWUuc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbyl9fXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHN8fChlPW5ldyBzKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWUpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT1lLm5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYhbC5pc1N0cmluZyhlLm5hbWUpKXJldHVyblwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS50eXBlJiZlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSl7dmFyIHQ9Yy5vbm54LlR5cGVQcm90by52ZXJpZnkoZS50eXBlKTtpZih0KXJldHVyblwidHlwZS5cIit0fXJldHVybiBudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmIWwuaXNTdHJpbmcoZS5kb2NTdHJpbmcpP1wiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5WYWx1ZUluZm9Qcm90bylyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54LlZhbHVlSW5mb1Byb3RvO2lmKG51bGwhPWUubmFtZSYmKHQubmFtZT1TdHJpbmcoZS5uYW1lKSksbnVsbCE9ZS50eXBlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS50eXBlKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlZhbHVlSW5mb1Byb3RvLnR5cGU6IG9iamVjdCBleHBlY3RlZFwiKTt0LnR5cGU9Yy5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KGUudHlwZSl9cmV0dXJuIG51bGwhPWUuZG9jU3RyaW5nJiYodC5kb2NTdHJpbmc9U3RyaW5nKGUuZG9jU3RyaW5nKSksdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtyZXR1cm4gdC5kZWZhdWx0cyYmKG4ubmFtZT1cIlwiLG4udHlwZT1udWxsLG4uZG9jU3RyaW5nPVwiXCIpLG51bGwhPWUubmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJihuLm5hbWU9ZS5uYW1lKSxudWxsIT1lLnR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpJiYobi50eXBlPWMub25ueC5UeXBlUHJvdG8udG9PYmplY3QoZS50eXBlLHQpKSxudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmKG4uZG9jU3RyaW5nPWUuZG9jU3RyaW5nKSxufSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sZX0oKSxpLk5vZGVQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYodGhpcy5pbnB1dD1bXSx0aGlzLm91dHB1dD1bXSx0aGlzLmF0dHJpYnV0ZT1bXSxlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxuPTA7bjx0Lmxlbmd0aDsrK24pbnVsbCE9ZVt0W25dXSYmKHRoaXNbdFtuXV09ZVt0W25dXSl9cmV0dXJuIGUucHJvdG90eXBlLmlucHV0PWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5vdXRwdXQ9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLm5hbWU9XCJcIixlLnByb3RvdHlwZS5vcFR5cGU9XCJcIixlLnByb3RvdHlwZS5kb21haW49XCJcIixlLnByb3RvdHlwZS5hdHRyaWJ1dGU9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtpZih0fHwodD11LmNyZWF0ZSgpKSxudWxsIT1lLmlucHV0JiZlLmlucHV0Lmxlbmd0aClmb3IodmFyIG49MDtuPGUuaW5wdXQubGVuZ3RoOysrbil0LnVpbnQzMigxMCkuc3RyaW5nKGUuaW5wdXRbbl0pO2lmKG51bGwhPWUub3V0cHV0JiZlLm91dHB1dC5sZW5ndGgpZm9yKG49MDtuPGUub3V0cHV0Lmxlbmd0aDsrK24pdC51aW50MzIoMTgpLnN0cmluZyhlLm91dHB1dFtuXSk7aWYobnVsbCE9ZS5uYW1lJiZlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmdC51aW50MzIoMjYpLnN0cmluZyhlLm5hbWUpLG51bGwhPWUub3BUeXBlJiZlLmhhc093blByb3BlcnR5KFwib3BUeXBlXCIpJiZ0LnVpbnQzMigzNCkuc3RyaW5nKGUub3BUeXBlKSxudWxsIT1lLmF0dHJpYnV0ZSYmZS5hdHRyaWJ1dGUubGVuZ3RoKWZvcihuPTA7bjxlLmF0dHJpYnV0ZS5sZW5ndGg7KytuKWMub25ueC5BdHRyaWJ1dGVQcm90by5lbmNvZGUoZS5hdHRyaWJ1dGVbbl0sdC51aW50MzIoNDIpLmZvcmsoKSkubGRlbGltKCk7cmV0dXJuIG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiZ0LnVpbnQzMig1MCkuc3RyaW5nKGUuZG9jU3RyaW5nKSxudWxsIT1lLmRvbWFpbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmdC51aW50MzIoNTgpLnN0cmluZyhlLmRvbWFpbiksdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2Ygc3x8KGU9cy5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54Lk5vZGVQcm90bztlLnBvczxuOyl7dmFyIG89ZS51aW50MzIoKTtzd2l0Y2gobz4+PjMpe2Nhc2UgMTpyLmlucHV0JiZyLmlucHV0Lmxlbmd0aHx8KHIuaW5wdXQ9W10pLHIuaW5wdXQucHVzaChlLnN0cmluZygpKTticmVhaztjYXNlIDI6ci5vdXRwdXQmJnIub3V0cHV0Lmxlbmd0aHx8KHIub3V0cHV0PVtdKSxyLm91dHB1dC5wdXNoKGUuc3RyaW5nKCkpO2JyZWFrO2Nhc2UgMzpyLm5hbWU9ZS5zdHJpbmcoKTticmVhaztjYXNlIDQ6ci5vcFR5cGU9ZS5zdHJpbmcoKTticmVhaztjYXNlIDc6ci5kb21haW49ZS5zdHJpbmcoKTticmVhaztjYXNlIDU6ci5hdHRyaWJ1dGUmJnIuYXR0cmlidXRlLmxlbmd0aHx8KHIuYXR0cmlidXRlPVtdKSxyLmF0dHJpYnV0ZS5wdXNoKGMub25ueC5BdHRyaWJ1dGVQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSA2OnIuZG9jU3RyaW5nPWUuc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbyl9fXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHN8fChlPW5ldyBzKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWUpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmlucHV0JiZlLmhhc093blByb3BlcnR5KFwiaW5wdXRcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuaW5wdXQpKXJldHVyblwiaW5wdXQ6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciB0PTA7dDxlLmlucHV0Lmxlbmd0aDsrK3QpaWYoIWwuaXNTdHJpbmcoZS5pbnB1dFt0XSkpcmV0dXJuXCJpbnB1dDogc3RyaW5nW10gZXhwZWN0ZWRcIn1pZihudWxsIT1lLm91dHB1dCYmZS5oYXNPd25Qcm9wZXJ0eShcIm91dHB1dFwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5vdXRwdXQpKXJldHVyblwib3V0cHV0OiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLm91dHB1dC5sZW5ndGg7Kyt0KWlmKCFsLmlzU3RyaW5nKGUub3V0cHV0W3RdKSlyZXR1cm5cIm91dHB1dDogc3RyaW5nW10gZXhwZWN0ZWRcIn1pZihudWxsIT1lLm5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYhbC5pc1N0cmluZyhlLm5hbWUpKXJldHVyblwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5vcFR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJvcFR5cGVcIikmJiFsLmlzU3RyaW5nKGUub3BUeXBlKSlyZXR1cm5cIm9wVHlwZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5kb21haW4mJmUuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJiFsLmlzU3RyaW5nKGUuZG9tYWluKSlyZXR1cm5cImRvbWFpbjogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5hdHRyaWJ1dGUmJmUuaGFzT3duUHJvcGVydHkoXCJhdHRyaWJ1dGVcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuYXR0cmlidXRlKSlyZXR1cm5cImF0dHJpYnV0ZTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5hdHRyaWJ1dGUubGVuZ3RoOysrdCl7dmFyIG49Yy5vbm54LkF0dHJpYnV0ZVByb3RvLnZlcmlmeShlLmF0dHJpYnV0ZVt0XSk7aWYobilyZXR1cm5cImF0dHJpYnV0ZS5cIitufX1yZXR1cm4gbnVsbCE9ZS5kb2NTdHJpbmcmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJiFsLmlzU3RyaW5nKGUuZG9jU3RyaW5nKT9cImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI6bnVsbH0sZS5mcm9tT2JqZWN0PWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBjLm9ubnguTm9kZVByb3RvKXJldHVybiBlO3ZhciB0PW5ldyBjLm9ubnguTm9kZVByb3RvO2lmKGUuaW5wdXQpe2lmKCFBcnJheS5pc0FycmF5KGUuaW5wdXQpKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk5vZGVQcm90by5pbnB1dDogYXJyYXkgZXhwZWN0ZWRcIik7dC5pbnB1dD1bXTtmb3IodmFyIG49MDtuPGUuaW5wdXQubGVuZ3RoOysrbil0LmlucHV0W25dPVN0cmluZyhlLmlucHV0W25dKX1pZihlLm91dHB1dCl7aWYoIUFycmF5LmlzQXJyYXkoZS5vdXRwdXQpKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk5vZGVQcm90by5vdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0Lm91dHB1dD1bXSxuPTA7bjxlLm91dHB1dC5sZW5ndGg7KytuKXQub3V0cHV0W25dPVN0cmluZyhlLm91dHB1dFtuXSl9aWYobnVsbCE9ZS5uYW1lJiYodC5uYW1lPVN0cmluZyhlLm5hbWUpKSxudWxsIT1lLm9wVHlwZSYmKHQub3BUeXBlPVN0cmluZyhlLm9wVHlwZSkpLG51bGwhPWUuZG9tYWluJiYodC5kb21haW49U3RyaW5nKGUuZG9tYWluKSksZS5hdHRyaWJ1dGUpe2lmKCFBcnJheS5pc0FycmF5KGUuYXR0cmlidXRlKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Ob2RlUHJvdG8uYXR0cmlidXRlOiBhcnJheSBleHBlY3RlZFwiKTtmb3IodC5hdHRyaWJ1dGU9W10sbj0wO248ZS5hdHRyaWJ1dGUubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuYXR0cmlidXRlW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk5vZGVQcm90by5hdHRyaWJ1dGU6IG9iamVjdCBleHBlY3RlZFwiKTt0LmF0dHJpYnV0ZVtuXT1jLm9ubnguQXR0cmlidXRlUHJvdG8uZnJvbU9iamVjdChlLmF0dHJpYnV0ZVtuXSl9fXJldHVybiBudWxsIT1lLmRvY1N0cmluZyYmKHQuZG9jU3RyaW5nPVN0cmluZyhlLmRvY1N0cmluZykpLHR9LGUudG9PYmplY3Q9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSk7dmFyIG49e307aWYoKHQuYXJyYXlzfHx0LmRlZmF1bHRzKSYmKG4uaW5wdXQ9W10sbi5vdXRwdXQ9W10sbi5hdHRyaWJ1dGU9W10pLHQuZGVmYXVsdHMmJihuLm5hbWU9XCJcIixuLm9wVHlwZT1cIlwiLG4uZG9jU3RyaW5nPVwiXCIsbi5kb21haW49XCJcIiksZS5pbnB1dCYmZS5pbnB1dC5sZW5ndGgpe24uaW5wdXQ9W107Zm9yKHZhciByPTA7cjxlLmlucHV0Lmxlbmd0aDsrK3Ipbi5pbnB1dFtyXT1lLmlucHV0W3JdfWlmKGUub3V0cHV0JiZlLm91dHB1dC5sZW5ndGgpZm9yKG4ub3V0cHV0PVtdLHI9MDtyPGUub3V0cHV0Lmxlbmd0aDsrK3Ipbi5vdXRwdXRbcl09ZS5vdXRwdXRbcl07aWYobnVsbCE9ZS5uYW1lJiZlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmKG4ubmFtZT1lLm5hbWUpLG51bGwhPWUub3BUeXBlJiZlLmhhc093blByb3BlcnR5KFwib3BUeXBlXCIpJiYobi5vcFR5cGU9ZS5vcFR5cGUpLGUuYXR0cmlidXRlJiZlLmF0dHJpYnV0ZS5sZW5ndGgpZm9yKG4uYXR0cmlidXRlPVtdLHI9MDtyPGUuYXR0cmlidXRlLmxlbmd0aDsrK3Ipbi5hdHRyaWJ1dGVbcl09Yy5vbm54LkF0dHJpYnV0ZVByb3RvLnRvT2JqZWN0KGUuYXR0cmlidXRlW3JdLHQpO3JldHVybiBudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmKG4uZG9jU3RyaW5nPWUuZG9jU3RyaW5nKSxudWxsIT1lLmRvbWFpbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmKG4uZG9tYWluPWUuZG9tYWluKSxufSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sZX0oKSxpLk1vZGVsUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKHRoaXMub3BzZXRJbXBvcnQ9W10sdGhpcy5tZXRhZGF0YVByb3BzPVtdLGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLG49MDtuPHQubGVuZ3RoOysrbiludWxsIT1lW3Rbbl1dJiYodGhpc1t0W25dXT1lW3Rbbl1dKX1yZXR1cm4gZS5wcm90b3R5cGUuaXJWZXJzaW9uPWwuTG9uZz9sLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLGUucHJvdG90eXBlLm9wc2V0SW1wb3J0PWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5wcm9kdWNlck5hbWU9XCJcIixlLnByb3RvdHlwZS5wcm9kdWNlclZlcnNpb249XCJcIixlLnByb3RvdHlwZS5kb21haW49XCJcIixlLnByb3RvdHlwZS5tb2RlbFZlcnNpb249bC5Mb25nP2wuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsZS5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsZS5wcm90b3R5cGUuZ3JhcGg9bnVsbCxlLnByb3RvdHlwZS5tZXRhZGF0YVByb3BzPWwuZW1wdHlBcnJheSxlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7aWYodHx8KHQ9dS5jcmVhdGUoKSksbnVsbCE9ZS5pclZlcnNpb24mJmUuaGFzT3duUHJvcGVydHkoXCJpclZlcnNpb25cIikmJnQudWludDMyKDgpLmludDY0KGUuaXJWZXJzaW9uKSxudWxsIT1lLnByb2R1Y2VyTmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyTmFtZVwiKSYmdC51aW50MzIoMTgpLnN0cmluZyhlLnByb2R1Y2VyTmFtZSksbnVsbCE9ZS5wcm9kdWNlclZlcnNpb24mJmUuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlclZlcnNpb25cIikmJnQudWludDMyKDI2KS5zdHJpbmcoZS5wcm9kdWNlclZlcnNpb24pLG51bGwhPWUuZG9tYWluJiZlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiZ0LnVpbnQzMigzNCkuc3RyaW5nKGUuZG9tYWluKSxudWxsIT1lLm1vZGVsVmVyc2lvbiYmZS5oYXNPd25Qcm9wZXJ0eShcIm1vZGVsVmVyc2lvblwiKSYmdC51aW50MzIoNDApLmludDY0KGUubW9kZWxWZXJzaW9uKSxudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmdC51aW50MzIoNTApLnN0cmluZyhlLmRvY1N0cmluZyksbnVsbCE9ZS5ncmFwaCYmZS5oYXNPd25Qcm9wZXJ0eShcImdyYXBoXCIpJiZjLm9ubnguR3JhcGhQcm90by5lbmNvZGUoZS5ncmFwaCx0LnVpbnQzMig1OCkuZm9yaygpKS5sZGVsaW0oKSxudWxsIT1lLm9wc2V0SW1wb3J0JiZlLm9wc2V0SW1wb3J0Lmxlbmd0aClmb3IodmFyIG49MDtuPGUub3BzZXRJbXBvcnQubGVuZ3RoOysrbiljLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmVuY29kZShlLm9wc2V0SW1wb3J0W25dLHQudWludDMyKDY2KS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPWUubWV0YWRhdGFQcm9wcyYmZS5tZXRhZGF0YVByb3BzLmxlbmd0aClmb3Iobj0wO248ZS5tZXRhZGF0YVByb3BzLmxlbmd0aDsrK24pYy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlKGUubWV0YWRhdGFQcm9wc1tuXSx0LnVpbnQzMigxMTQpLmZvcmsoKSkubGRlbGltKCk7cmV0dXJuIHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIHN8fChlPXMuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5Nb2RlbFByb3RvO2UucG9zPG47KXt2YXIgbz1lLnVpbnQzMigpO3N3aXRjaChvPj4+Myl7Y2FzZSAxOnIuaXJWZXJzaW9uPWUuaW50NjQoKTticmVhaztjYXNlIDg6ci5vcHNldEltcG9ydCYmci5vcHNldEltcG9ydC5sZW5ndGh8fChyLm9wc2V0SW1wb3J0PVtdKSxyLm9wc2V0SW1wb3J0LnB1c2goYy5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAyOnIucHJvZHVjZXJOYW1lPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSAzOnIucHJvZHVjZXJWZXJzaW9uPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSA0OnIuZG9tYWluPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSA1OnIubW9kZWxWZXJzaW9uPWUuaW50NjQoKTticmVhaztjYXNlIDY6ci5kb2NTdHJpbmc9ZS5zdHJpbmcoKTticmVhaztjYXNlIDc6ci5ncmFwaD1jLm9ubnguR3JhcGhQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDE0OnIubWV0YWRhdGFQcm9wcyYmci5tZXRhZGF0YVByb3BzLmxlbmd0aHx8KHIubWV0YWRhdGFQcm9wcz1bXSksci5tZXRhZGF0YVByb3BzLnB1c2goYy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm8pfX1yZXR1cm4gcn0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBzfHwoZT1uZXcgcyhlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5pclZlcnNpb24mJmUuaGFzT3duUHJvcGVydHkoXCJpclZlcnNpb25cIikmJiEobC5pc0ludGVnZXIoZS5pclZlcnNpb24pfHxlLmlyVmVyc2lvbiYmbC5pc0ludGVnZXIoZS5pclZlcnNpb24ubG93KSYmbC5pc0ludGVnZXIoZS5pclZlcnNpb24uaGlnaCkpKXJldHVyblwiaXJWZXJzaW9uOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLm9wc2V0SW1wb3J0JiZlLmhhc093blByb3BlcnR5KFwib3BzZXRJbXBvcnRcIikpe2lmKCFBcnJheS5pc0FycmF5KGUub3BzZXRJbXBvcnQpKXJldHVyblwib3BzZXRJbXBvcnQ6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciB0PTA7dDxlLm9wc2V0SW1wb3J0Lmxlbmd0aDsrK3QpaWYobj1jLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLnZlcmlmeShlLm9wc2V0SW1wb3J0W3RdKSlyZXR1cm5cIm9wc2V0SW1wb3J0LlwiK259aWYobnVsbCE9ZS5wcm9kdWNlck5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlck5hbWVcIikmJiFsLmlzU3RyaW5nKGUucHJvZHVjZXJOYW1lKSlyZXR1cm5cInByb2R1Y2VyTmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5wcm9kdWNlclZlcnNpb24mJmUuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlclZlcnNpb25cIikmJiFsLmlzU3RyaW5nKGUucHJvZHVjZXJWZXJzaW9uKSlyZXR1cm5cInByb2R1Y2VyVmVyc2lvbjogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5kb21haW4mJmUuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJiFsLmlzU3RyaW5nKGUuZG9tYWluKSlyZXR1cm5cImRvbWFpbjogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5tb2RlbFZlcnNpb24mJmUuaGFzT3duUHJvcGVydHkoXCJtb2RlbFZlcnNpb25cIikmJiEobC5pc0ludGVnZXIoZS5tb2RlbFZlcnNpb24pfHxlLm1vZGVsVmVyc2lvbiYmbC5pc0ludGVnZXIoZS5tb2RlbFZlcnNpb24ubG93KSYmbC5pc0ludGVnZXIoZS5tb2RlbFZlcnNpb24uaGlnaCkpKXJldHVyblwibW9kZWxWZXJzaW9uOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmIWwuaXNTdHJpbmcoZS5kb2NTdHJpbmcpKXJldHVyblwiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmdyYXBoJiZlLmhhc093blByb3BlcnR5KFwiZ3JhcGhcIikmJihuPWMub25ueC5HcmFwaFByb3RvLnZlcmlmeShlLmdyYXBoKSkpcmV0dXJuXCJncmFwaC5cIituO2lmKG51bGwhPWUubWV0YWRhdGFQcm9wcyYmZS5oYXNPd25Qcm9wZXJ0eShcIm1ldGFkYXRhUHJvcHNcIikpe2lmKCFBcnJheS5pc0FycmF5KGUubWV0YWRhdGFQcm9wcykpcmV0dXJuXCJtZXRhZGF0YVByb3BzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLm1ldGFkYXRhUHJvcHMubGVuZ3RoOysrdCl7dmFyIG47aWYobj1jLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by52ZXJpZnkoZS5tZXRhZGF0YVByb3BzW3RdKSlyZXR1cm5cIm1ldGFkYXRhUHJvcHMuXCIrbn19cmV0dXJuIG51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54Lk1vZGVsUHJvdG8pcmV0dXJuIGU7dmFyIHQ9bmV3IGMub25ueC5Nb2RlbFByb3RvO2lmKG51bGwhPWUuaXJWZXJzaW9uJiYobC5Mb25nPyh0LmlyVmVyc2lvbj1sLkxvbmcuZnJvbVZhbHVlKGUuaXJWZXJzaW9uKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIGUuaXJWZXJzaW9uP3QuaXJWZXJzaW9uPXBhcnNlSW50KGUuaXJWZXJzaW9uLDEwKTpcIm51bWJlclwiPT10eXBlb2YgZS5pclZlcnNpb24/dC5pclZlcnNpb249ZS5pclZlcnNpb246XCJvYmplY3RcIj09dHlwZW9mIGUuaXJWZXJzaW9uJiYodC5pclZlcnNpb249bmV3IGwuTG9uZ0JpdHMoZS5pclZlcnNpb24ubG93Pj4+MCxlLmlyVmVyc2lvbi5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLGUub3BzZXRJbXBvcnQpe2lmKCFBcnJheS5pc0FycmF5KGUub3BzZXRJbXBvcnQpKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8ub3BzZXRJbXBvcnQ6IGFycmF5IGV4cGVjdGVkXCIpO3Qub3BzZXRJbXBvcnQ9W107Zm9yKHZhciBuPTA7bjxlLm9wc2V0SW1wb3J0Lmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLm9wc2V0SW1wb3J0W25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8ub3BzZXRJbXBvcnQ6IG9iamVjdCBleHBlY3RlZFwiKTt0Lm9wc2V0SW1wb3J0W25dPWMub25ueC5PcGVyYXRvclNldElkUHJvdG8uZnJvbU9iamVjdChlLm9wc2V0SW1wb3J0W25dKX19aWYobnVsbCE9ZS5wcm9kdWNlck5hbWUmJih0LnByb2R1Y2VyTmFtZT1TdHJpbmcoZS5wcm9kdWNlck5hbWUpKSxudWxsIT1lLnByb2R1Y2VyVmVyc2lvbiYmKHQucHJvZHVjZXJWZXJzaW9uPVN0cmluZyhlLnByb2R1Y2VyVmVyc2lvbikpLG51bGwhPWUuZG9tYWluJiYodC5kb21haW49U3RyaW5nKGUuZG9tYWluKSksbnVsbCE9ZS5tb2RlbFZlcnNpb24mJihsLkxvbmc/KHQubW9kZWxWZXJzaW9uPWwuTG9uZy5mcm9tVmFsdWUoZS5tb2RlbFZlcnNpb24pKS51bnNpZ25lZD0hMTpcInN0cmluZ1wiPT10eXBlb2YgZS5tb2RlbFZlcnNpb24/dC5tb2RlbFZlcnNpb249cGFyc2VJbnQoZS5tb2RlbFZlcnNpb24sMTApOlwibnVtYmVyXCI9PXR5cGVvZiBlLm1vZGVsVmVyc2lvbj90Lm1vZGVsVmVyc2lvbj1lLm1vZGVsVmVyc2lvbjpcIm9iamVjdFwiPT10eXBlb2YgZS5tb2RlbFZlcnNpb24mJih0Lm1vZGVsVmVyc2lvbj1uZXcgbC5Mb25nQml0cyhlLm1vZGVsVmVyc2lvbi5sb3c+Pj4wLGUubW9kZWxWZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpKSksbnVsbCE9ZS5kb2NTdHJpbmcmJih0LmRvY1N0cmluZz1TdHJpbmcoZS5kb2NTdHJpbmcpKSxudWxsIT1lLmdyYXBoKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5ncmFwaCl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLmdyYXBoOiBvYmplY3QgZXhwZWN0ZWRcIik7dC5ncmFwaD1jLm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KGUuZ3JhcGgpfWlmKGUubWV0YWRhdGFQcm9wcyl7aWYoIUFycmF5LmlzQXJyYXkoZS5tZXRhZGF0YVByb3BzKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLm1ldGFkYXRhUHJvcHM6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0Lm1ldGFkYXRhUHJvcHM9W10sbj0wO248ZS5tZXRhZGF0YVByb3BzLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLm1ldGFkYXRhUHJvcHNbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5tZXRhZGF0YVByb3BzOiBvYmplY3QgZXhwZWN0ZWRcIik7dC5tZXRhZGF0YVByb3BzW25dPWMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3QoZS5tZXRhZGF0YVByb3BzW25dKX19cmV0dXJuIHR9LGUudG9PYmplY3Q9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSk7dmFyIG49e307aWYoKHQuYXJyYXlzfHx0LmRlZmF1bHRzKSYmKG4ub3BzZXRJbXBvcnQ9W10sbi5tZXRhZGF0YVByb3BzPVtdKSx0LmRlZmF1bHRzKXtpZihsLkxvbmcpe3ZhciByPW5ldyBsLkxvbmcoMCwwLCExKTtuLmlyVmVyc2lvbj10LmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTp0LmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyfWVsc2Ugbi5pclZlcnNpb249dC5sb25ncz09PVN0cmluZz9cIjBcIjowO24ucHJvZHVjZXJOYW1lPVwiXCIsbi5wcm9kdWNlclZlcnNpb249XCJcIixuLmRvbWFpbj1cIlwiLGwuTG9uZz8ocj1uZXcgbC5Mb25nKDAsMCwhMSksbi5tb2RlbFZlcnNpb249dC5sb25ncz09PVN0cmluZz9yLnRvU3RyaW5nKCk6dC5sb25ncz09PU51bWJlcj9yLnRvTnVtYmVyKCk6cik6bi5tb2RlbFZlcnNpb249dC5sb25ncz09PVN0cmluZz9cIjBcIjowLG4uZG9jU3RyaW5nPVwiXCIsbi5ncmFwaD1udWxsfWlmKG51bGwhPWUuaXJWZXJzaW9uJiZlLmhhc093blByb3BlcnR5KFwiaXJWZXJzaW9uXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIGUuaXJWZXJzaW9uP24uaXJWZXJzaW9uPXQubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKGUuaXJWZXJzaW9uKTplLmlyVmVyc2lvbjpuLmlyVmVyc2lvbj10LmxvbmdzPT09U3RyaW5nP2wuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlLmlyVmVyc2lvbik6dC5sb25ncz09PU51bWJlcj9uZXcgbC5Mb25nQml0cyhlLmlyVmVyc2lvbi5sb3c+Pj4wLGUuaXJWZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpOmUuaXJWZXJzaW9uKSxudWxsIT1lLnByb2R1Y2VyTmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyTmFtZVwiKSYmKG4ucHJvZHVjZXJOYW1lPWUucHJvZHVjZXJOYW1lKSxudWxsIT1lLnByb2R1Y2VyVmVyc2lvbiYmZS5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyVmVyc2lvblwiKSYmKG4ucHJvZHVjZXJWZXJzaW9uPWUucHJvZHVjZXJWZXJzaW9uKSxudWxsIT1lLmRvbWFpbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmKG4uZG9tYWluPWUuZG9tYWluKSxudWxsIT1lLm1vZGVsVmVyc2lvbiYmZS5oYXNPd25Qcm9wZXJ0eShcIm1vZGVsVmVyc2lvblwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiBlLm1vZGVsVmVyc2lvbj9uLm1vZGVsVmVyc2lvbj10LmxvbmdzPT09U3RyaW5nP1N0cmluZyhlLm1vZGVsVmVyc2lvbik6ZS5tb2RlbFZlcnNpb246bi5tb2RlbFZlcnNpb249dC5sb25ncz09PVN0cmluZz9sLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZS5tb2RlbFZlcnNpb24pOnQubG9uZ3M9PT1OdW1iZXI/bmV3IGwuTG9uZ0JpdHMoZS5tb2RlbFZlcnNpb24ubG93Pj4+MCxlLm1vZGVsVmVyc2lvbi5oaWdoPj4+MCkudG9OdW1iZXIoKTplLm1vZGVsVmVyc2lvbiksbnVsbCE9ZS5kb2NTdHJpbmcmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz1lLmRvY1N0cmluZyksbnVsbCE9ZS5ncmFwaCYmZS5oYXNPd25Qcm9wZXJ0eShcImdyYXBoXCIpJiYobi5ncmFwaD1jLm9ubnguR3JhcGhQcm90by50b09iamVjdChlLmdyYXBoLHQpKSxlLm9wc2V0SW1wb3J0JiZlLm9wc2V0SW1wb3J0Lmxlbmd0aCl7bi5vcHNldEltcG9ydD1bXTtmb3IodmFyIG89MDtvPGUub3BzZXRJbXBvcnQubGVuZ3RoOysrbyluLm9wc2V0SW1wb3J0W29dPWMub25ueC5PcGVyYXRvclNldElkUHJvdG8udG9PYmplY3QoZS5vcHNldEltcG9ydFtvXSx0KX1pZihlLm1ldGFkYXRhUHJvcHMmJmUubWV0YWRhdGFQcm9wcy5sZW5ndGgpZm9yKG4ubWV0YWRhdGFQcm9wcz1bXSxvPTA7bzxlLm1ldGFkYXRhUHJvcHMubGVuZ3RoOysrbyluLm1ldGFkYXRhUHJvcHNbb109Yy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QoZS5tZXRhZGF0YVByb3BzW29dLHQpO3JldHVybiBufSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sZX0oKSxpLlN0cmluZ1N0cmluZ0VudHJ5UHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLG49MDtuPHQubGVuZ3RoOysrbiludWxsIT1lW3Rbbl1dJiYodGhpc1t0W25dXT1lW3Rbbl1dKX1yZXR1cm4gZS5wcm90b3R5cGUua2V5PVwiXCIsZS5wcm90b3R5cGUudmFsdWU9XCJcIixlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fCh0PXUuY3JlYXRlKCkpLG51bGwhPWUua2V5JiZlLmhhc093blByb3BlcnR5KFwia2V5XCIpJiZ0LnVpbnQzMigxMCkuc3RyaW5nKGUua2V5KSxudWxsIT1lLnZhbHVlJiZlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikmJnQudWludDMyKDE4KS5zdHJpbmcoZS52YWx1ZSksdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2Ygc3x8KGU9cy5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG87ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci5rZXk9ZS5zdHJpbmcoKTticmVhaztjYXNlIDI6ci52YWx1ZT1lLnN0cmluZygpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm8pfX1yZXR1cm4gcn0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBzfHwoZT1uZXcgcyhlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24oZSl7cmV0dXJuXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lP1wib2JqZWN0IGV4cGVjdGVkXCI6bnVsbCE9ZS5rZXkmJmUuaGFzT3duUHJvcGVydHkoXCJrZXlcIikmJiFsLmlzU3RyaW5nKGUua2V5KT9cImtleTogc3RyaW5nIGV4cGVjdGVkXCI6bnVsbCE9ZS52YWx1ZSYmZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpJiYhbC5pc1N0cmluZyhlLnZhbHVlKT9cInZhbHVlOiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvKXJldHVybiBlO3ZhciB0PW5ldyBjLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90bztyZXR1cm4gbnVsbCE9ZS5rZXkmJih0LmtleT1TdHJpbmcoZS5rZXkpKSxudWxsIT1lLnZhbHVlJiYodC52YWx1ZT1TdHJpbmcoZS52YWx1ZSkpLHR9LGUudG9PYmplY3Q9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSk7dmFyIG49e307cmV0dXJuIHQuZGVmYXVsdHMmJihuLmtleT1cIlwiLG4udmFsdWU9XCJcIiksbnVsbCE9ZS5rZXkmJmUuaGFzT3duUHJvcGVydHkoXCJrZXlcIikmJihuLmtleT1lLmtleSksbnVsbCE9ZS52YWx1ZSYmZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpJiYobi52YWx1ZT1lLnZhbHVlKSxufSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sZX0oKSxpLlRlbnNvckFubm90YXRpb249ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKHRoaXMucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1bXSxlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxuPTA7bjx0Lmxlbmd0aDsrK24pbnVsbCE9ZVt0W25dXSYmKHRoaXNbdFtuXV09ZVt0W25dXSl9cmV0dXJuIGUucHJvdG90eXBlLnRlbnNvck5hbWU9XCJcIixlLnByb3RvdHlwZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPWwuZW1wdHlBcnJheSxlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7aWYodHx8KHQ9dS5jcmVhdGUoKSksbnVsbCE9ZS50ZW5zb3JOYW1lJiZlLmhhc093blByb3BlcnR5KFwidGVuc29yTmFtZVwiKSYmdC51aW50MzIoMTApLnN0cmluZyhlLnRlbnNvck5hbWUpLG51bGwhPWUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aClmb3IodmFyIG49MDtuPGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7KytuKWMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZShlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbbl0sdC51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7cmV0dXJuIHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIHN8fChlPXMuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5UZW5zb3JBbm5vdGF0aW9uO2UucG9zPG47KXt2YXIgbz1lLnVpbnQzMigpO3N3aXRjaChvPj4+Myl7Y2FzZSAxOnIudGVuc29yTmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMjpyLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMmJnIucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGh8fChyLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9W10pLHIucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5wdXNoKGMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZvKX19cmV0dXJuIHJ9LGUuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2Ygc3x8KGU9bmV3IHMoZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LGUudmVyaWZ5PWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZSlyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPWUudGVuc29yTmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcInRlbnNvck5hbWVcIikmJiFsLmlzU3RyaW5nKGUudGVuc29yTmFtZSkpcmV0dXJuXCJ0ZW5zb3JOYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMmJmUuaGFzT3duUHJvcGVydHkoXCJxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzXCIpKXtpZighQXJyYXkuaXNBcnJheShlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMpKXJldHVyblwicXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lczogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHQ9MDt0PGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7Kyt0KXt2YXIgbj1jLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by52ZXJpZnkoZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW3RdKTtpZihuKXJldHVyblwicXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5cIitufX1yZXR1cm4gbnVsbH0sZS5mcm9tT2JqZWN0PWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBjLm9ubnguVGVuc29yQW5ub3RhdGlvbilyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54LlRlbnNvckFubm90YXRpb247aWYobnVsbCE9ZS50ZW5zb3JOYW1lJiYodC50ZW5zb3JOYW1lPVN0cmluZyhlLnRlbnNvck5hbWUpKSxlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMpe2lmKCFBcnJheS5pc0FycmF5KGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yQW5ub3RhdGlvbi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzOiBhcnJheSBleHBlY3RlZFwiKTt0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9W107Zm9yKHZhciBuPTA7bjxlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JBbm5vdGF0aW9uLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM6IG9iamVjdCBleHBlY3RlZFwiKTt0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbbl09Yy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdChlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbbl0pfX1yZXR1cm4gdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtpZigodC5hcnJheXN8fHQuZGVmYXVsdHMpJiYobi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPVtdKSx0LmRlZmF1bHRzJiYobi50ZW5zb3JOYW1lPVwiXCIpLG51bGwhPWUudGVuc29yTmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcInRlbnNvck5hbWVcIikmJihuLnRlbnNvck5hbWU9ZS50ZW5zb3JOYW1lKSxlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMmJmUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGgpe24ucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1bXTtmb3IodmFyIHI9MDtyPGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7KytyKW4ucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tyXT1jLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdChlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbcl0sdCl9cmV0dXJuIG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSxlfSgpLGkuR3JhcGhQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYodGhpcy5ub2RlPVtdLHRoaXMuaW5pdGlhbGl6ZXI9W10sdGhpcy5pbnB1dD1bXSx0aGlzLm91dHB1dD1bXSx0aGlzLnZhbHVlSW5mbz1bXSx0aGlzLnF1YW50aXphdGlvbkFubm90YXRpb249W10sZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXJldHVybiBlLnByb3RvdHlwZS5ub2RlPWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5uYW1lPVwiXCIsZS5wcm90b3R5cGUuaW5pdGlhbGl6ZXI9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLGUucHJvdG90eXBlLmlucHV0PWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5vdXRwdXQ9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLnZhbHVlSW5mbz1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbj1sLmVtcHR5QXJyYXksZS5jcmVhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpfSxlLmVuY29kZT1mdW5jdGlvbihlLHQpe2lmKHR8fCh0PXUuY3JlYXRlKCkpLG51bGwhPWUubm9kZSYmZS5ub2RlLmxlbmd0aClmb3IodmFyIG49MDtuPGUubm9kZS5sZW5ndGg7KytuKWMub25ueC5Ob2RlUHJvdG8uZW5jb2RlKGUubm9kZVtuXSx0LnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT1lLm5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiZ0LnVpbnQzMigxOCkuc3RyaW5nKGUubmFtZSksbnVsbCE9ZS5pbml0aWFsaXplciYmZS5pbml0aWFsaXplci5sZW5ndGgpZm9yKG49MDtuPGUuaW5pdGlhbGl6ZXIubGVuZ3RoOysrbiljLm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKGUuaW5pdGlhbGl6ZXJbbl0sdC51aW50MzIoNDIpLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9ZS5kb2NTdHJpbmcmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJnQudWludDMyKDgyKS5zdHJpbmcoZS5kb2NTdHJpbmcpLG51bGwhPWUuaW5wdXQmJmUuaW5wdXQubGVuZ3RoKWZvcihuPTA7bjxlLmlucHV0Lmxlbmd0aDsrK24pYy5vbm54LlZhbHVlSW5mb1Byb3RvLmVuY29kZShlLmlucHV0W25dLHQudWludDMyKDkwKS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPWUub3V0cHV0JiZlLm91dHB1dC5sZW5ndGgpZm9yKG49MDtuPGUub3V0cHV0Lmxlbmd0aDsrK24pYy5vbm54LlZhbHVlSW5mb1Byb3RvLmVuY29kZShlLm91dHB1dFtuXSx0LnVpbnQzMig5OCkuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT1lLnZhbHVlSW5mbyYmZS52YWx1ZUluZm8ubGVuZ3RoKWZvcihuPTA7bjxlLnZhbHVlSW5mby5sZW5ndGg7KytuKWMub25ueC5WYWx1ZUluZm9Qcm90by5lbmNvZGUoZS52YWx1ZUluZm9bbl0sdC51aW50MzIoMTA2KS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPWUucXVhbnRpemF0aW9uQW5ub3RhdGlvbiYmZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aClmb3Iobj0wO248ZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsrK24pYy5vbm54LlRlbnNvckFubm90YXRpb24uZW5jb2RlKGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbltuXSx0LnVpbnQzMigxMTQpLmZvcmsoKSkubGRlbGltKCk7cmV0dXJuIHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIHN8fChlPXMuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5HcmFwaFByb3RvO2UucG9zPG47KXt2YXIgbz1lLnVpbnQzMigpO3N3aXRjaChvPj4+Myl7Y2FzZSAxOnIubm9kZSYmci5ub2RlLmxlbmd0aHx8KHIubm9kZT1bXSksci5ub2RlLnB1c2goYy5vbm54Lk5vZGVQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAyOnIubmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgNTpyLmluaXRpYWxpemVyJiZyLmluaXRpYWxpemVyLmxlbmd0aHx8KHIuaW5pdGlhbGl6ZXI9W10pLHIuaW5pdGlhbGl6ZXIucHVzaChjLm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMTA6ci5kb2NTdHJpbmc9ZS5zdHJpbmcoKTticmVhaztjYXNlIDExOnIuaW5wdXQmJnIuaW5wdXQubGVuZ3RofHwoci5pbnB1dD1bXSksci5pbnB1dC5wdXNoKGMub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxMjpyLm91dHB1dCYmci5vdXRwdXQubGVuZ3RofHwoci5vdXRwdXQ9W10pLHIub3V0cHV0LnB1c2goYy5vbm54LlZhbHVlSW5mb1Byb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVhaztjYXNlIDEzOnIudmFsdWVJbmZvJiZyLnZhbHVlSW5mby5sZW5ndGh8fChyLnZhbHVlSW5mbz1bXSksci52YWx1ZUluZm8ucHVzaChjLm9ubnguVmFsdWVJbmZvUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMTQ6ci5xdWFudGl6YXRpb25Bbm5vdGF0aW9uJiZyLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RofHwoci5xdWFudGl6YXRpb25Bbm5vdGF0aW9uPVtdKSxyLnF1YW50aXphdGlvbkFubm90YXRpb24ucHVzaChjLm9ubnguVGVuc29yQW5ub3RhdGlvbi5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbyl9fXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHN8fChlPW5ldyBzKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWUpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT1lLm5vZGUmJmUuaGFzT3duUHJvcGVydHkoXCJub2RlXCIpKXtpZighQXJyYXkuaXNBcnJheShlLm5vZGUpKXJldHVyblwibm9kZTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHQ9MDt0PGUubm9kZS5sZW5ndGg7Kyt0KWlmKG49Yy5vbm54Lk5vZGVQcm90by52ZXJpZnkoZS5ub2RlW3RdKSlyZXR1cm5cIm5vZGUuXCIrbn1pZihudWxsIT1lLm5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYhbC5pc1N0cmluZyhlLm5hbWUpKXJldHVyblwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5pbml0aWFsaXplciYmZS5oYXNPd25Qcm9wZXJ0eShcImluaXRpYWxpemVyXCIpKXtpZighQXJyYXkuaXNBcnJheShlLmluaXRpYWxpemVyKSlyZXR1cm5cImluaXRpYWxpemVyOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLmluaXRpYWxpemVyLmxlbmd0aDsrK3QpaWYobj1jLm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KGUuaW5pdGlhbGl6ZXJbdF0pKXJldHVyblwiaW5pdGlhbGl6ZXIuXCIrbn1pZihudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmIWwuaXNTdHJpbmcoZS5kb2NTdHJpbmcpKXJldHVyblwiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmlucHV0JiZlLmhhc093blByb3BlcnR5KFwiaW5wdXRcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuaW5wdXQpKXJldHVyblwiaW5wdXQ6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHQ9MDt0PGUuaW5wdXQubGVuZ3RoOysrdClpZihuPWMub25ueC5WYWx1ZUluZm9Qcm90by52ZXJpZnkoZS5pbnB1dFt0XSkpcmV0dXJuXCJpbnB1dC5cIitufWlmKG51bGwhPWUub3V0cHV0JiZlLmhhc093blByb3BlcnR5KFwib3V0cHV0XCIpKXtpZighQXJyYXkuaXNBcnJheShlLm91dHB1dCkpcmV0dXJuXCJvdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHQ9MDt0PGUub3V0cHV0Lmxlbmd0aDsrK3QpaWYobj1jLm9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5KGUub3V0cHV0W3RdKSlyZXR1cm5cIm91dHB1dC5cIitufWlmKG51bGwhPWUudmFsdWVJbmZvJiZlLmhhc093blByb3BlcnR5KFwidmFsdWVJbmZvXCIpKXtpZighQXJyYXkuaXNBcnJheShlLnZhbHVlSW5mbykpcmV0dXJuXCJ2YWx1ZUluZm86IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHQ9MDt0PGUudmFsdWVJbmZvLmxlbmd0aDsrK3QpaWYobj1jLm9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5KGUudmFsdWVJbmZvW3RdKSlyZXR1cm5cInZhbHVlSW5mby5cIitufWlmKG51bGwhPWUucXVhbnRpemF0aW9uQW5ub3RhdGlvbiYmZS5oYXNPd25Qcm9wZXJ0eShcInF1YW50aXphdGlvbkFubm90YXRpb25cIikpe2lmKCFBcnJheS5pc0FycmF5KGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbikpcmV0dXJuXCJxdWFudGl6YXRpb25Bbm5vdGF0aW9uOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOysrdCl7dmFyIG47aWYobj1jLm9ubnguVGVuc29yQW5ub3RhdGlvbi52ZXJpZnkoZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW3RdKSlyZXR1cm5cInF1YW50aXphdGlvbkFubm90YXRpb24uXCIrbn19cmV0dXJuIG51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54LkdyYXBoUHJvdG8pcmV0dXJuIGU7dmFyIHQ9bmV3IGMub25ueC5HcmFwaFByb3RvO2lmKGUubm9kZSl7aWYoIUFycmF5LmlzQXJyYXkoZS5ub2RlKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm5vZGU6IGFycmF5IGV4cGVjdGVkXCIpO3Qubm9kZT1bXTtmb3IodmFyIG49MDtuPGUubm9kZS5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5ub2RlW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ubm9kZTogb2JqZWN0IGV4cGVjdGVkXCIpO3Qubm9kZVtuXT1jLm9ubnguTm9kZVByb3RvLmZyb21PYmplY3QoZS5ub2RlW25dKX19aWYobnVsbCE9ZS5uYW1lJiYodC5uYW1lPVN0cmluZyhlLm5hbWUpKSxlLmluaXRpYWxpemVyKXtpZighQXJyYXkuaXNBcnJheShlLmluaXRpYWxpemVyKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLmluaXRpYWxpemVyOiBhcnJheSBleHBlY3RlZFwiKTtmb3IodC5pbml0aWFsaXplcj1bXSxuPTA7bjxlLmluaXRpYWxpemVyLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLmluaXRpYWxpemVyW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5pdGlhbGl6ZXI6IG9iamVjdCBleHBlY3RlZFwiKTt0LmluaXRpYWxpemVyW25dPWMub25ueC5UZW5zb3JQcm90by5mcm9tT2JqZWN0KGUuaW5pdGlhbGl6ZXJbbl0pfX1pZihudWxsIT1lLmRvY1N0cmluZyYmKHQuZG9jU3RyaW5nPVN0cmluZyhlLmRvY1N0cmluZykpLGUuaW5wdXQpe2lmKCFBcnJheS5pc0FycmF5KGUuaW5wdXQpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5wdXQ6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LmlucHV0PVtdLG49MDtuPGUuaW5wdXQubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuaW5wdXRbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbnB1dDogb2JqZWN0IGV4cGVjdGVkXCIpO3QuaW5wdXRbbl09Yy5vbm54LlZhbHVlSW5mb1Byb3RvLmZyb21PYmplY3QoZS5pbnB1dFtuXSl9fWlmKGUub3V0cHV0KXtpZighQXJyYXkuaXNBcnJheShlLm91dHB1dCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5vdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0Lm91dHB1dD1bXSxuPTA7bjxlLm91dHB1dC5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5vdXRwdXRbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5vdXRwdXQ6IG9iamVjdCBleHBlY3RlZFwiKTt0Lm91dHB1dFtuXT1jLm9ubnguVmFsdWVJbmZvUHJvdG8uZnJvbU9iamVjdChlLm91dHB1dFtuXSl9fWlmKGUudmFsdWVJbmZvKXtpZighQXJyYXkuaXNBcnJheShlLnZhbHVlSW5mbykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by52YWx1ZUluZm86IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LnZhbHVlSW5mbz1bXSxuPTA7bjxlLnZhbHVlSW5mby5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS52YWx1ZUluZm9bbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by52YWx1ZUluZm86IG9iamVjdCBleHBlY3RlZFwiKTt0LnZhbHVlSW5mb1tuXT1jLm9ubnguVmFsdWVJbmZvUHJvdG8uZnJvbU9iamVjdChlLnZhbHVlSW5mb1tuXSl9fWlmKGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbil7aWYoIUFycmF5LmlzQXJyYXkoZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnF1YW50aXphdGlvbkFubm90YXRpb246IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LnF1YW50aXphdGlvbkFubm90YXRpb249W10sbj0wO248ZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLnF1YW50aXphdGlvbkFubm90YXRpb25bbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5xdWFudGl6YXRpb25Bbm5vdGF0aW9uOiBvYmplY3QgZXhwZWN0ZWRcIik7dC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW25dPWMub25ueC5UZW5zb3JBbm5vdGF0aW9uLmZyb21PYmplY3QoZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW25dKX19cmV0dXJuIHR9LGUudG9PYmplY3Q9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSk7dmFyIG49e307aWYoKHQuYXJyYXlzfHx0LmRlZmF1bHRzKSYmKG4ubm9kZT1bXSxuLmluaXRpYWxpemVyPVtdLG4uaW5wdXQ9W10sbi5vdXRwdXQ9W10sbi52YWx1ZUluZm89W10sbi5xdWFudGl6YXRpb25Bbm5vdGF0aW9uPVtdKSx0LmRlZmF1bHRzJiYobi5uYW1lPVwiXCIsbi5kb2NTdHJpbmc9XCJcIiksZS5ub2RlJiZlLm5vZGUubGVuZ3RoKXtuLm5vZGU9W107Zm9yKHZhciByPTA7cjxlLm5vZGUubGVuZ3RoOysrciluLm5vZGVbcl09Yy5vbm54Lk5vZGVQcm90by50b09iamVjdChlLm5vZGVbcl0sdCl9aWYobnVsbCE9ZS5uYW1lJiZlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmKG4ubmFtZT1lLm5hbWUpLGUuaW5pdGlhbGl6ZXImJmUuaW5pdGlhbGl6ZXIubGVuZ3RoKWZvcihuLmluaXRpYWxpemVyPVtdLHI9MDtyPGUuaW5pdGlhbGl6ZXIubGVuZ3RoOysrciluLmluaXRpYWxpemVyW3JdPWMub25ueC5UZW5zb3JQcm90by50b09iamVjdChlLmluaXRpYWxpemVyW3JdLHQpO2lmKG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9ZS5kb2NTdHJpbmcpLGUuaW5wdXQmJmUuaW5wdXQubGVuZ3RoKWZvcihuLmlucHV0PVtdLHI9MDtyPGUuaW5wdXQubGVuZ3RoOysrciluLmlucHV0W3JdPWMub25ueC5WYWx1ZUluZm9Qcm90by50b09iamVjdChlLmlucHV0W3JdLHQpO2lmKGUub3V0cHV0JiZlLm91dHB1dC5sZW5ndGgpZm9yKG4ub3V0cHV0PVtdLHI9MDtyPGUub3V0cHV0Lmxlbmd0aDsrK3Ipbi5vdXRwdXRbcl09Yy5vbm54LlZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0KGUub3V0cHV0W3JdLHQpO2lmKGUudmFsdWVJbmZvJiZlLnZhbHVlSW5mby5sZW5ndGgpZm9yKG4udmFsdWVJbmZvPVtdLHI9MDtyPGUudmFsdWVJbmZvLmxlbmd0aDsrK3Ipbi52YWx1ZUluZm9bcl09Yy5vbm54LlZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0KGUudmFsdWVJbmZvW3JdLHQpO2lmKGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbiYmZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aClmb3Iobi5xdWFudGl6YXRpb25Bbm5vdGF0aW9uPVtdLHI9MDtyPGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGg7KytyKW4ucXVhbnRpemF0aW9uQW5ub3RhdGlvbltyXT1jLm9ubnguVGVuc29yQW5ub3RhdGlvbi50b09iamVjdChlLnF1YW50aXphdGlvbkFubm90YXRpb25bcl0sdCk7cmV0dXJuIG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSxlfSgpLGkuVGVuc29yUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKHRoaXMuZGltcz1bXSx0aGlzLmZsb2F0RGF0YT1bXSx0aGlzLmludDMyRGF0YT1bXSx0aGlzLnN0cmluZ0RhdGE9W10sdGhpcy5pbnQ2NERhdGE9W10sdGhpcy5leHRlcm5hbERhdGE9W10sdGhpcy5kb3VibGVEYXRhPVtdLHRoaXMudWludDY0RGF0YT1bXSxlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxuPTA7bjx0Lmxlbmd0aDsrK24pbnVsbCE9ZVt0W25dXSYmKHRoaXNbdFtuXV09ZVt0W25dXSl9cmV0dXJuIGUucHJvdG90eXBlLmRpbXM9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLmRhdGFUeXBlPTAsZS5wcm90b3R5cGUuc2VnbWVudD1udWxsLGUucHJvdG90eXBlLmZsb2F0RGF0YT1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuaW50MzJEYXRhPWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5zdHJpbmdEYXRhPWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5pbnQ2NERhdGE9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLm5hbWU9XCJcIixlLnByb3RvdHlwZS5kb2NTdHJpbmc9XCJcIixlLnByb3RvdHlwZS5yYXdEYXRhPWwubmV3QnVmZmVyKFtdKSxlLnByb3RvdHlwZS5leHRlcm5hbERhdGE9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLmRhdGFMb2NhdGlvbj0wLGUucHJvdG90eXBlLmRvdWJsZURhdGE9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLnVpbnQ2NERhdGE9bC5lbXB0eUFycmF5LGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtpZih0fHwodD11LmNyZWF0ZSgpKSxudWxsIT1lLmRpbXMmJmUuZGltcy5sZW5ndGgpe3QudWludDMyKDEwKS5mb3JrKCk7Zm9yKHZhciBuPTA7bjxlLmRpbXMubGVuZ3RoOysrbil0LmludDY0KGUuZGltc1tuXSk7dC5sZGVsaW0oKX1pZihudWxsIT1lLmRhdGFUeXBlJiZlLmhhc093blByb3BlcnR5KFwiZGF0YVR5cGVcIikmJnQudWludDMyKDE2KS5pbnQzMihlLmRhdGFUeXBlKSxudWxsIT1lLnNlZ21lbnQmJmUuaGFzT3duUHJvcGVydHkoXCJzZWdtZW50XCIpJiZjLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC5lbmNvZGUoZS5zZWdtZW50LHQudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPWUuZmxvYXREYXRhJiZlLmZsb2F0RGF0YS5sZW5ndGgpe2Zvcih0LnVpbnQzMigzNCkuZm9yaygpLG49MDtuPGUuZmxvYXREYXRhLmxlbmd0aDsrK24pdC5mbG9hdChlLmZsb2F0RGF0YVtuXSk7dC5sZGVsaW0oKX1pZihudWxsIT1lLmludDMyRGF0YSYmZS5pbnQzMkRhdGEubGVuZ3RoKXtmb3IodC51aW50MzIoNDIpLmZvcmsoKSxuPTA7bjxlLmludDMyRGF0YS5sZW5ndGg7KytuKXQuaW50MzIoZS5pbnQzMkRhdGFbbl0pO3QubGRlbGltKCl9aWYobnVsbCE9ZS5zdHJpbmdEYXRhJiZlLnN0cmluZ0RhdGEubGVuZ3RoKWZvcihuPTA7bjxlLnN0cmluZ0RhdGEubGVuZ3RoOysrbil0LnVpbnQzMig1MCkuYnl0ZXMoZS5zdHJpbmdEYXRhW25dKTtpZihudWxsIT1lLmludDY0RGF0YSYmZS5pbnQ2NERhdGEubGVuZ3RoKXtmb3IodC51aW50MzIoNTgpLmZvcmsoKSxuPTA7bjxlLmludDY0RGF0YS5sZW5ndGg7KytuKXQuaW50NjQoZS5pbnQ2NERhdGFbbl0pO3QubGRlbGltKCl9aWYobnVsbCE9ZS5uYW1lJiZlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmdC51aW50MzIoNjYpLnN0cmluZyhlLm5hbWUpLG51bGwhPWUucmF3RGF0YSYmZS5oYXNPd25Qcm9wZXJ0eShcInJhd0RhdGFcIikmJnQudWludDMyKDc0KS5ieXRlcyhlLnJhd0RhdGEpLG51bGwhPWUuZG91YmxlRGF0YSYmZS5kb3VibGVEYXRhLmxlbmd0aCl7Zm9yKHQudWludDMyKDgyKS5mb3JrKCksbj0wO248ZS5kb3VibGVEYXRhLmxlbmd0aDsrK24pdC5kb3VibGUoZS5kb3VibGVEYXRhW25dKTt0LmxkZWxpbSgpfWlmKG51bGwhPWUudWludDY0RGF0YSYmZS51aW50NjREYXRhLmxlbmd0aCl7Zm9yKHQudWludDMyKDkwKS5mb3JrKCksbj0wO248ZS51aW50NjREYXRhLmxlbmd0aDsrK24pdC51aW50NjQoZS51aW50NjREYXRhW25dKTt0LmxkZWxpbSgpfWlmKG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiZ0LnVpbnQzMig5OCkuc3RyaW5nKGUuZG9jU3RyaW5nKSxudWxsIT1lLmV4dGVybmFsRGF0YSYmZS5leHRlcm5hbERhdGEubGVuZ3RoKWZvcihuPTA7bjxlLmV4dGVybmFsRGF0YS5sZW5ndGg7KytuKWMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZShlLmV4dGVybmFsRGF0YVtuXSx0LnVpbnQzMigxMDYpLmZvcmsoKSkubGRlbGltKCk7cmV0dXJuIG51bGwhPWUuZGF0YUxvY2F0aW9uJiZlLmhhc093blByb3BlcnR5KFwiZGF0YUxvY2F0aW9uXCIpJiZ0LnVpbnQzMigxMTIpLmludDMyKGUuZGF0YUxvY2F0aW9uKSx0fSxlLmVuY29kZURlbGltaXRlZD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVuY29kZShlLHQpLmxkZWxpbSgpfSxlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiBzfHwoZT1zLmNyZWF0ZShlKSk7Zm9yKHZhciBuPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyBjLm9ubnguVGVuc29yUHJvdG87ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6aWYoci5kaW1zJiZyLmRpbXMubGVuZ3RofHwoci5kaW1zPVtdKSwyPT0oNyZvKSlmb3IodmFyIGk9ZS51aW50MzIoKStlLnBvcztlLnBvczxpOylyLmRpbXMucHVzaChlLmludDY0KCkpO2Vsc2Ugci5kaW1zLnB1c2goZS5pbnQ2NCgpKTticmVhaztjYXNlIDI6ci5kYXRhVHlwZT1lLmludDMyKCk7YnJlYWs7Y2FzZSAzOnIuc2VnbWVudD1jLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDQ6aWYoci5mbG9hdERhdGEmJnIuZmxvYXREYXRhLmxlbmd0aHx8KHIuZmxvYXREYXRhPVtdKSwyPT0oNyZvKSlmb3IoaT1lLnVpbnQzMigpK2UucG9zO2UucG9zPGk7KXIuZmxvYXREYXRhLnB1c2goZS5mbG9hdCgpKTtlbHNlIHIuZmxvYXREYXRhLnB1c2goZS5mbG9hdCgpKTticmVhaztjYXNlIDU6aWYoci5pbnQzMkRhdGEmJnIuaW50MzJEYXRhLmxlbmd0aHx8KHIuaW50MzJEYXRhPVtdKSwyPT0oNyZvKSlmb3IoaT1lLnVpbnQzMigpK2UucG9zO2UucG9zPGk7KXIuaW50MzJEYXRhLnB1c2goZS5pbnQzMigpKTtlbHNlIHIuaW50MzJEYXRhLnB1c2goZS5pbnQzMigpKTticmVhaztjYXNlIDY6ci5zdHJpbmdEYXRhJiZyLnN0cmluZ0RhdGEubGVuZ3RofHwoci5zdHJpbmdEYXRhPVtdKSxyLnN0cmluZ0RhdGEucHVzaChlLmJ5dGVzKCkpO2JyZWFrO2Nhc2UgNzppZihyLmludDY0RGF0YSYmci5pbnQ2NERhdGEubGVuZ3RofHwoci5pbnQ2NERhdGE9W10pLDI9PSg3Jm8pKWZvcihpPWUudWludDMyKCkrZS5wb3M7ZS5wb3M8aTspci5pbnQ2NERhdGEucHVzaChlLmludDY0KCkpO2Vsc2Ugci5pbnQ2NERhdGEucHVzaChlLmludDY0KCkpO2JyZWFrO2Nhc2UgODpyLm5hbWU9ZS5zdHJpbmcoKTticmVhaztjYXNlIDEyOnIuZG9jU3RyaW5nPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSA5OnIucmF3RGF0YT1lLmJ5dGVzKCk7YnJlYWs7Y2FzZSAxMzpyLmV4dGVybmFsRGF0YSYmci5leHRlcm5hbERhdGEubGVuZ3RofHwoci5leHRlcm5hbERhdGE9W10pLHIuZXh0ZXJuYWxEYXRhLnB1c2goYy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMTQ6ci5kYXRhTG9jYXRpb249ZS5pbnQzMigpO2JyZWFrO2Nhc2UgMTA6aWYoci5kb3VibGVEYXRhJiZyLmRvdWJsZURhdGEubGVuZ3RofHwoci5kb3VibGVEYXRhPVtdKSwyPT0oNyZvKSlmb3IoaT1lLnVpbnQzMigpK2UucG9zO2UucG9zPGk7KXIuZG91YmxlRGF0YS5wdXNoKGUuZG91YmxlKCkpO2Vsc2Ugci5kb3VibGVEYXRhLnB1c2goZS5kb3VibGUoKSk7YnJlYWs7Y2FzZSAxMTppZihyLnVpbnQ2NERhdGEmJnIudWludDY0RGF0YS5sZW5ndGh8fChyLnVpbnQ2NERhdGE9W10pLDI9PSg3Jm8pKWZvcihpPWUudWludDMyKCkrZS5wb3M7ZS5wb3M8aTspci51aW50NjREYXRhLnB1c2goZS51aW50NjQoKSk7ZWxzZSByLnVpbnQ2NERhdGEucHVzaChlLnVpbnQ2NCgpKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZvKX19cmV0dXJuIHJ9LGUuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2Ygc3x8KGU9bmV3IHMoZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LGUudmVyaWZ5PWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZSlyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPWUuZGltcyYmZS5oYXNPd25Qcm9wZXJ0eShcImRpbXNcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuZGltcykpcmV0dXJuXCJkaW1zOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgdD0wO3Q8ZS5kaW1zLmxlbmd0aDsrK3QpaWYoIShsLmlzSW50ZWdlcihlLmRpbXNbdF0pfHxlLmRpbXNbdF0mJmwuaXNJbnRlZ2VyKGUuZGltc1t0XS5sb3cpJiZsLmlzSW50ZWdlcihlLmRpbXNbdF0uaGlnaCkpKXJldHVyblwiZGltczogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWRcIn1pZihudWxsIT1lLmRhdGFUeXBlJiZlLmhhc093blByb3BlcnR5KFwiZGF0YVR5cGVcIikmJiFsLmlzSW50ZWdlcihlLmRhdGFUeXBlKSlyZXR1cm5cImRhdGFUeXBlOiBpbnRlZ2VyIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5zZWdtZW50JiZlLmhhc093blByb3BlcnR5KFwic2VnbWVudFwiKSYmKG49Yy5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQudmVyaWZ5KGUuc2VnbWVudCkpKXJldHVyblwic2VnbWVudC5cIituO2lmKG51bGwhPWUuZmxvYXREYXRhJiZlLmhhc093blByb3BlcnR5KFwiZmxvYXREYXRhXCIpKXtpZighQXJyYXkuaXNBcnJheShlLmZsb2F0RGF0YSkpcmV0dXJuXCJmbG9hdERhdGE6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHQ9MDt0PGUuZmxvYXREYXRhLmxlbmd0aDsrK3QpaWYoXCJudW1iZXJcIiE9dHlwZW9mIGUuZmxvYXREYXRhW3RdKXJldHVyblwiZmxvYXREYXRhOiBudW1iZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPWUuaW50MzJEYXRhJiZlLmhhc093blByb3BlcnR5KFwiaW50MzJEYXRhXCIpKXtpZighQXJyYXkuaXNBcnJheShlLmludDMyRGF0YSkpcmV0dXJuXCJpbnQzMkRhdGE6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHQ9MDt0PGUuaW50MzJEYXRhLmxlbmd0aDsrK3QpaWYoIWwuaXNJbnRlZ2VyKGUuaW50MzJEYXRhW3RdKSlyZXR1cm5cImludDMyRGF0YTogaW50ZWdlcltdIGV4cGVjdGVkXCJ9aWYobnVsbCE9ZS5zdHJpbmdEYXRhJiZlLmhhc093blByb3BlcnR5KFwic3RyaW5nRGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5zdHJpbmdEYXRhKSlyZXR1cm5cInN0cmluZ0RhdGE6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHQ9MDt0PGUuc3RyaW5nRGF0YS5sZW5ndGg7Kyt0KWlmKCEoZS5zdHJpbmdEYXRhW3RdJiZcIm51bWJlclwiPT10eXBlb2YgZS5zdHJpbmdEYXRhW3RdLmxlbmd0aHx8bC5pc1N0cmluZyhlLnN0cmluZ0RhdGFbdF0pKSlyZXR1cm5cInN0cmluZ0RhdGE6IGJ1ZmZlcltdIGV4cGVjdGVkXCJ9aWYobnVsbCE9ZS5pbnQ2NERhdGEmJmUuaGFzT3duUHJvcGVydHkoXCJpbnQ2NERhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuaW50NjREYXRhKSlyZXR1cm5cImludDY0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5pbnQ2NERhdGEubGVuZ3RoOysrdClpZighKGwuaXNJbnRlZ2VyKGUuaW50NjREYXRhW3RdKXx8ZS5pbnQ2NERhdGFbdF0mJmwuaXNJbnRlZ2VyKGUuaW50NjREYXRhW3RdLmxvdykmJmwuaXNJbnRlZ2VyKGUuaW50NjREYXRhW3RdLmhpZ2gpKSlyZXR1cm5cImludDY0RGF0YTogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWRcIn1pZihudWxsIT1lLm5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYhbC5pc1N0cmluZyhlLm5hbWUpKXJldHVyblwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5kb2NTdHJpbmcmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJiFsLmlzU3RyaW5nKGUuZG9jU3RyaW5nKSlyZXR1cm5cImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5yYXdEYXRhJiZlLmhhc093blByb3BlcnR5KFwicmF3RGF0YVwiKSYmIShlLnJhd0RhdGEmJlwibnVtYmVyXCI9PXR5cGVvZiBlLnJhd0RhdGEubGVuZ3RofHxsLmlzU3RyaW5nKGUucmF3RGF0YSkpKXJldHVyblwicmF3RGF0YTogYnVmZmVyIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5leHRlcm5hbERhdGEmJmUuaGFzT3duUHJvcGVydHkoXCJleHRlcm5hbERhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuZXh0ZXJuYWxEYXRhKSlyZXR1cm5cImV4dGVybmFsRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5leHRlcm5hbERhdGEubGVuZ3RoOysrdCl7dmFyIG47aWYobj1jLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by52ZXJpZnkoZS5leHRlcm5hbERhdGFbdF0pKXJldHVyblwiZXh0ZXJuYWxEYXRhLlwiK259fWlmKG51bGwhPWUuZGF0YUxvY2F0aW9uJiZlLmhhc093blByb3BlcnR5KFwiZGF0YUxvY2F0aW9uXCIpKXN3aXRjaChlLmRhdGFMb2NhdGlvbil7ZGVmYXVsdDpyZXR1cm5cImRhdGFMb2NhdGlvbjogZW51bSB2YWx1ZSBleHBlY3RlZFwiO2Nhc2UgMDpjYXNlIDE6fWlmKG51bGwhPWUuZG91YmxlRGF0YSYmZS5oYXNPd25Qcm9wZXJ0eShcImRvdWJsZURhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuZG91YmxlRGF0YSkpcmV0dXJuXCJkb3VibGVEYXRhOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLmRvdWJsZURhdGEubGVuZ3RoOysrdClpZihcIm51bWJlclwiIT10eXBlb2YgZS5kb3VibGVEYXRhW3RdKXJldHVyblwiZG91YmxlRGF0YTogbnVtYmVyW10gZXhwZWN0ZWRcIn1pZihudWxsIT1lLnVpbnQ2NERhdGEmJmUuaGFzT3duUHJvcGVydHkoXCJ1aW50NjREYXRhXCIpKXtpZighQXJyYXkuaXNBcnJheShlLnVpbnQ2NERhdGEpKXJldHVyblwidWludDY0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS51aW50NjREYXRhLmxlbmd0aDsrK3QpaWYoIShsLmlzSW50ZWdlcihlLnVpbnQ2NERhdGFbdF0pfHxlLnVpbnQ2NERhdGFbdF0mJmwuaXNJbnRlZ2VyKGUudWludDY0RGF0YVt0XS5sb3cpJiZsLmlzSW50ZWdlcihlLnVpbnQ2NERhdGFbdF0uaGlnaCkpKXJldHVyblwidWludDY0RGF0YTogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWRcIn1yZXR1cm4gbnVsbH0sZS5mcm9tT2JqZWN0PWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBjLm9ubnguVGVuc29yUHJvdG8pcmV0dXJuIGU7dmFyIHQ9bmV3IGMub25ueC5UZW5zb3JQcm90bztpZihlLmRpbXMpe2lmKCFBcnJheS5pc0FycmF5KGUuZGltcykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZGltczogYXJyYXkgZXhwZWN0ZWRcIik7dC5kaW1zPVtdO2Zvcih2YXIgbj0wO248ZS5kaW1zLmxlbmd0aDsrK24pbC5Mb25nPyh0LmRpbXNbbl09bC5Mb25nLmZyb21WYWx1ZShlLmRpbXNbbl0pKS51bnNpZ25lZD0hMTpcInN0cmluZ1wiPT10eXBlb2YgZS5kaW1zW25dP3QuZGltc1tuXT1wYXJzZUludChlLmRpbXNbbl0sMTApOlwibnVtYmVyXCI9PXR5cGVvZiBlLmRpbXNbbl0/dC5kaW1zW25dPWUuZGltc1tuXTpcIm9iamVjdFwiPT10eXBlb2YgZS5kaW1zW25dJiYodC5kaW1zW25dPW5ldyBsLkxvbmdCaXRzKGUuZGltc1tuXS5sb3c+Pj4wLGUuZGltc1tuXS5oaWdoPj4+MCkudG9OdW1iZXIoKSl9aWYobnVsbCE9ZS5kYXRhVHlwZSYmKHQuZGF0YVR5cGU9MHxlLmRhdGFUeXBlKSxudWxsIT1lLnNlZ21lbnQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLnNlZ21lbnQpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uc2VnbWVudDogb2JqZWN0IGV4cGVjdGVkXCIpO3Quc2VnbWVudD1jLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC5mcm9tT2JqZWN0KGUuc2VnbWVudCl9aWYoZS5mbG9hdERhdGEpe2lmKCFBcnJheS5pc0FycmF5KGUuZmxvYXREYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5mbG9hdERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LmZsb2F0RGF0YT1bXSxuPTA7bjxlLmZsb2F0RGF0YS5sZW5ndGg7KytuKXQuZmxvYXREYXRhW25dPU51bWJlcihlLmZsb2F0RGF0YVtuXSl9aWYoZS5pbnQzMkRhdGEpe2lmKCFBcnJheS5pc0FycmF5KGUuaW50MzJEYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5pbnQzMkRhdGE6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LmludDMyRGF0YT1bXSxuPTA7bjxlLmludDMyRGF0YS5sZW5ndGg7KytuKXQuaW50MzJEYXRhW25dPTB8ZS5pbnQzMkRhdGFbbl19aWYoZS5zdHJpbmdEYXRhKXtpZighQXJyYXkuaXNBcnJheShlLnN0cmluZ0RhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLnN0cmluZ0RhdGE6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LnN0cmluZ0RhdGE9W10sbj0wO248ZS5zdHJpbmdEYXRhLmxlbmd0aDsrK24pXCJzdHJpbmdcIj09dHlwZW9mIGUuc3RyaW5nRGF0YVtuXT9sLmJhc2U2NC5kZWNvZGUoZS5zdHJpbmdEYXRhW25dLHQuc3RyaW5nRGF0YVtuXT1sLm5ld0J1ZmZlcihsLmJhc2U2NC5sZW5ndGgoZS5zdHJpbmdEYXRhW25dKSksMCk6ZS5zdHJpbmdEYXRhW25dLmxlbmd0aCYmKHQuc3RyaW5nRGF0YVtuXT1lLnN0cmluZ0RhdGFbbl0pfWlmKGUuaW50NjREYXRhKXtpZighQXJyYXkuaXNBcnJheShlLmludDY0RGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uaW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IodC5pbnQ2NERhdGE9W10sbj0wO248ZS5pbnQ2NERhdGEubGVuZ3RoOysrbilsLkxvbmc/KHQuaW50NjREYXRhW25dPWwuTG9uZy5mcm9tVmFsdWUoZS5pbnQ2NERhdGFbbl0pKS51bnNpZ25lZD0hMTpcInN0cmluZ1wiPT10eXBlb2YgZS5pbnQ2NERhdGFbbl0/dC5pbnQ2NERhdGFbbl09cGFyc2VJbnQoZS5pbnQ2NERhdGFbbl0sMTApOlwibnVtYmVyXCI9PXR5cGVvZiBlLmludDY0RGF0YVtuXT90LmludDY0RGF0YVtuXT1lLmludDY0RGF0YVtuXTpcIm9iamVjdFwiPT10eXBlb2YgZS5pbnQ2NERhdGFbbl0mJih0LmludDY0RGF0YVtuXT1uZXcgbC5Mb25nQml0cyhlLmludDY0RGF0YVtuXS5sb3c+Pj4wLGUuaW50NjREYXRhW25dLmhpZ2g+Pj4wKS50b051bWJlcigpKX1pZihudWxsIT1lLm5hbWUmJih0Lm5hbWU9U3RyaW5nKGUubmFtZSkpLG51bGwhPWUuZG9jU3RyaW5nJiYodC5kb2NTdHJpbmc9U3RyaW5nKGUuZG9jU3RyaW5nKSksbnVsbCE9ZS5yYXdEYXRhJiYoXCJzdHJpbmdcIj09dHlwZW9mIGUucmF3RGF0YT9sLmJhc2U2NC5kZWNvZGUoZS5yYXdEYXRhLHQucmF3RGF0YT1sLm5ld0J1ZmZlcihsLmJhc2U2NC5sZW5ndGgoZS5yYXdEYXRhKSksMCk6ZS5yYXdEYXRhLmxlbmd0aCYmKHQucmF3RGF0YT1lLnJhd0RhdGEpKSxlLmV4dGVybmFsRGF0YSl7aWYoIUFycmF5LmlzQXJyYXkoZS5leHRlcm5hbERhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmV4dGVybmFsRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuZXh0ZXJuYWxEYXRhPVtdLG49MDtuPGUuZXh0ZXJuYWxEYXRhLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLmV4dGVybmFsRGF0YVtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5leHRlcm5hbERhdGE6IG9iamVjdCBleHBlY3RlZFwiKTt0LmV4dGVybmFsRGF0YVtuXT1jLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KGUuZXh0ZXJuYWxEYXRhW25dKX19c3dpdGNoKGUuZGF0YUxvY2F0aW9uKXtjYXNlXCJERUZBVUxUXCI6Y2FzZSAwOnQuZGF0YUxvY2F0aW9uPTA7YnJlYWs7Y2FzZVwiRVhURVJOQUxcIjpjYXNlIDE6dC5kYXRhTG9jYXRpb249MX1pZihlLmRvdWJsZURhdGEpe2lmKCFBcnJheS5pc0FycmF5KGUuZG91YmxlRGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZG91YmxlRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuZG91YmxlRGF0YT1bXSxuPTA7bjxlLmRvdWJsZURhdGEubGVuZ3RoOysrbil0LmRvdWJsZURhdGFbbl09TnVtYmVyKGUuZG91YmxlRGF0YVtuXSl9aWYoZS51aW50NjREYXRhKXtpZighQXJyYXkuaXNBcnJheShlLnVpbnQ2NERhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLnVpbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LnVpbnQ2NERhdGE9W10sbj0wO248ZS51aW50NjREYXRhLmxlbmd0aDsrK24pbC5Mb25nPyh0LnVpbnQ2NERhdGFbbl09bC5Mb25nLmZyb21WYWx1ZShlLnVpbnQ2NERhdGFbbl0pKS51bnNpZ25lZD0hMDpcInN0cmluZ1wiPT10eXBlb2YgZS51aW50NjREYXRhW25dP3QudWludDY0RGF0YVtuXT1wYXJzZUludChlLnVpbnQ2NERhdGFbbl0sMTApOlwibnVtYmVyXCI9PXR5cGVvZiBlLnVpbnQ2NERhdGFbbl0/dC51aW50NjREYXRhW25dPWUudWludDY0RGF0YVtuXTpcIm9iamVjdFwiPT10eXBlb2YgZS51aW50NjREYXRhW25dJiYodC51aW50NjREYXRhW25dPW5ldyBsLkxvbmdCaXRzKGUudWludDY0RGF0YVtuXS5sb3c+Pj4wLGUudWludDY0RGF0YVtuXS5oaWdoPj4+MCkudG9OdW1iZXIoITApKX1yZXR1cm4gdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtpZigodC5hcnJheXN8fHQuZGVmYXVsdHMpJiYobi5kaW1zPVtdLG4uZmxvYXREYXRhPVtdLG4uaW50MzJEYXRhPVtdLG4uc3RyaW5nRGF0YT1bXSxuLmludDY0RGF0YT1bXSxuLmRvdWJsZURhdGE9W10sbi51aW50NjREYXRhPVtdLG4uZXh0ZXJuYWxEYXRhPVtdKSx0LmRlZmF1bHRzJiYobi5kYXRhVHlwZT0wLG4uc2VnbWVudD1udWxsLG4ubmFtZT1cIlwiLHQuYnl0ZXM9PT1TdHJpbmc/bi5yYXdEYXRhPVwiXCI6KG4ucmF3RGF0YT1bXSx0LmJ5dGVzIT09QXJyYXkmJihuLnJhd0RhdGE9bC5uZXdCdWZmZXIobi5yYXdEYXRhKSkpLG4uZG9jU3RyaW5nPVwiXCIsbi5kYXRhTG9jYXRpb249dC5lbnVtcz09PVN0cmluZz9cIkRFRkFVTFRcIjowKSxlLmRpbXMmJmUuZGltcy5sZW5ndGgpe24uZGltcz1bXTtmb3IodmFyIHI9MDtyPGUuZGltcy5sZW5ndGg7KytyKVwibnVtYmVyXCI9PXR5cGVvZiBlLmRpbXNbcl0/bi5kaW1zW3JdPXQubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKGUuZGltc1tyXSk6ZS5kaW1zW3JdOm4uZGltc1tyXT10LmxvbmdzPT09U3RyaW5nP2wuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlLmRpbXNbcl0pOnQubG9uZ3M9PT1OdW1iZXI/bmV3IGwuTG9uZ0JpdHMoZS5kaW1zW3JdLmxvdz4+PjAsZS5kaW1zW3JdLmhpZ2g+Pj4wKS50b051bWJlcigpOmUuZGltc1tyXX1pZihudWxsIT1lLmRhdGFUeXBlJiZlLmhhc093blByb3BlcnR5KFwiZGF0YVR5cGVcIikmJihuLmRhdGFUeXBlPWUuZGF0YVR5cGUpLG51bGwhPWUuc2VnbWVudCYmZS5oYXNPd25Qcm9wZXJ0eShcInNlZ21lbnRcIikmJihuLnNlZ21lbnQ9Yy5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQudG9PYmplY3QoZS5zZWdtZW50LHQpKSxlLmZsb2F0RGF0YSYmZS5mbG9hdERhdGEubGVuZ3RoKWZvcihuLmZsb2F0RGF0YT1bXSxyPTA7cjxlLmZsb2F0RGF0YS5sZW5ndGg7KytyKW4uZmxvYXREYXRhW3JdPXQuanNvbiYmIWlzRmluaXRlKGUuZmxvYXREYXRhW3JdKT9TdHJpbmcoZS5mbG9hdERhdGFbcl0pOmUuZmxvYXREYXRhW3JdO2lmKGUuaW50MzJEYXRhJiZlLmludDMyRGF0YS5sZW5ndGgpZm9yKG4uaW50MzJEYXRhPVtdLHI9MDtyPGUuaW50MzJEYXRhLmxlbmd0aDsrK3Ipbi5pbnQzMkRhdGFbcl09ZS5pbnQzMkRhdGFbcl07aWYoZS5zdHJpbmdEYXRhJiZlLnN0cmluZ0RhdGEubGVuZ3RoKWZvcihuLnN0cmluZ0RhdGE9W10scj0wO3I8ZS5zdHJpbmdEYXRhLmxlbmd0aDsrK3Ipbi5zdHJpbmdEYXRhW3JdPXQuYnl0ZXM9PT1TdHJpbmc/bC5iYXNlNjQuZW5jb2RlKGUuc3RyaW5nRGF0YVtyXSwwLGUuc3RyaW5nRGF0YVtyXS5sZW5ndGgpOnQuYnl0ZXM9PT1BcnJheT9BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLnN0cmluZ0RhdGFbcl0pOmUuc3RyaW5nRGF0YVtyXTtpZihlLmludDY0RGF0YSYmZS5pbnQ2NERhdGEubGVuZ3RoKWZvcihuLmludDY0RGF0YT1bXSxyPTA7cjxlLmludDY0RGF0YS5sZW5ndGg7KytyKVwibnVtYmVyXCI9PXR5cGVvZiBlLmludDY0RGF0YVtyXT9uLmludDY0RGF0YVtyXT10LmxvbmdzPT09U3RyaW5nP1N0cmluZyhlLmludDY0RGF0YVtyXSk6ZS5pbnQ2NERhdGFbcl06bi5pbnQ2NERhdGFbcl09dC5sb25ncz09PVN0cmluZz9sLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZS5pbnQ2NERhdGFbcl0pOnQubG9uZ3M9PT1OdW1iZXI/bmV3IGwuTG9uZ0JpdHMoZS5pbnQ2NERhdGFbcl0ubG93Pj4+MCxlLmludDY0RGF0YVtyXS5oaWdoPj4+MCkudG9OdW1iZXIoKTplLmludDY0RGF0YVtyXTtpZihudWxsIT1lLm5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYobi5uYW1lPWUubmFtZSksbnVsbCE9ZS5yYXdEYXRhJiZlLmhhc093blByb3BlcnR5KFwicmF3RGF0YVwiKSYmKG4ucmF3RGF0YT10LmJ5dGVzPT09U3RyaW5nP2wuYmFzZTY0LmVuY29kZShlLnJhd0RhdGEsMCxlLnJhd0RhdGEubGVuZ3RoKTp0LmJ5dGVzPT09QXJyYXk/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZS5yYXdEYXRhKTplLnJhd0RhdGEpLGUuZG91YmxlRGF0YSYmZS5kb3VibGVEYXRhLmxlbmd0aClmb3Iobi5kb3VibGVEYXRhPVtdLHI9MDtyPGUuZG91YmxlRGF0YS5sZW5ndGg7KytyKW4uZG91YmxlRGF0YVtyXT10Lmpzb24mJiFpc0Zpbml0ZShlLmRvdWJsZURhdGFbcl0pP1N0cmluZyhlLmRvdWJsZURhdGFbcl0pOmUuZG91YmxlRGF0YVtyXTtpZihlLnVpbnQ2NERhdGEmJmUudWludDY0RGF0YS5sZW5ndGgpZm9yKG4udWludDY0RGF0YT1bXSxyPTA7cjxlLnVpbnQ2NERhdGEubGVuZ3RoOysrcilcIm51bWJlclwiPT10eXBlb2YgZS51aW50NjREYXRhW3JdP24udWludDY0RGF0YVtyXT10LmxvbmdzPT09U3RyaW5nP1N0cmluZyhlLnVpbnQ2NERhdGFbcl0pOmUudWludDY0RGF0YVtyXTpuLnVpbnQ2NERhdGFbcl09dC5sb25ncz09PVN0cmluZz9sLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZS51aW50NjREYXRhW3JdKTp0LmxvbmdzPT09TnVtYmVyP25ldyBsLkxvbmdCaXRzKGUudWludDY0RGF0YVtyXS5sb3c+Pj4wLGUudWludDY0RGF0YVtyXS5oaWdoPj4+MCkudG9OdW1iZXIoITApOmUudWludDY0RGF0YVtyXTtpZihudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmKG4uZG9jU3RyaW5nPWUuZG9jU3RyaW5nKSxlLmV4dGVybmFsRGF0YSYmZS5leHRlcm5hbERhdGEubGVuZ3RoKWZvcihuLmV4dGVybmFsRGF0YT1bXSxyPTA7cjxlLmV4dGVybmFsRGF0YS5sZW5ndGg7KytyKW4uZXh0ZXJuYWxEYXRhW3JdPWMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KGUuZXh0ZXJuYWxEYXRhW3JdLHQpO3JldHVybiBudWxsIT1lLmRhdGFMb2NhdGlvbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFMb2NhdGlvblwiKSYmKG4uZGF0YUxvY2F0aW9uPXQuZW51bXM9PT1TdHJpbmc/Yy5vbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvbltlLmRhdGFMb2NhdGlvbl06ZS5kYXRhTG9jYXRpb24pLG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSxlLkRhdGFUeXBlPWZ1bmN0aW9uKCl7dmFyIGU9e30sdD1PYmplY3QuY3JlYXRlKGUpO3JldHVybiB0W2VbMF09XCJVTkRFRklORURcIl09MCx0W2VbMV09XCJGTE9BVFwiXT0xLHRbZVsyXT1cIlVJTlQ4XCJdPTIsdFtlWzNdPVwiSU5UOFwiXT0zLHRbZVs0XT1cIlVJTlQxNlwiXT00LHRbZVs1XT1cIklOVDE2XCJdPTUsdFtlWzZdPVwiSU5UMzJcIl09Nix0W2VbN109XCJJTlQ2NFwiXT03LHRbZVs4XT1cIlNUUklOR1wiXT04LHRbZVs5XT1cIkJPT0xcIl09OSx0W2VbMTBdPVwiRkxPQVQxNlwiXT0xMCx0W2VbMTFdPVwiRE9VQkxFXCJdPTExLHRbZVsxMl09XCJVSU5UMzJcIl09MTIsdFtlWzEzXT1cIlVJTlQ2NFwiXT0xMyx0W2VbMTRdPVwiQ09NUExFWDY0XCJdPTE0LHRbZVsxNV09XCJDT01QTEVYMTI4XCJdPTE1LHRbZVsxNl09XCJCRkxPQVQxNlwiXT0xNix0fSgpLGUuU2VnbWVudD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYoZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXJldHVybiBlLnByb3RvdHlwZS5iZWdpbj1sLkxvbmc/bC5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCxlLnByb3RvdHlwZS5lbmQ9bC5Mb25nP2wuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsZS5jcmVhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpfSxlLmVuY29kZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHwodD11LmNyZWF0ZSgpKSxudWxsIT1lLmJlZ2luJiZlLmhhc093blByb3BlcnR5KFwiYmVnaW5cIikmJnQudWludDMyKDgpLmludDY0KGUuYmVnaW4pLG51bGwhPWUuZW5kJiZlLmhhc093blByb3BlcnR5KFwiZW5kXCIpJiZ0LnVpbnQzMigxNikuaW50NjQoZS5lbmQpLHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIHN8fChlPXMuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5UZW5zb3JQcm90by5TZWdtZW50O2UucG9zPG47KXt2YXIgbz1lLnVpbnQzMigpO3N3aXRjaChvPj4+Myl7Y2FzZSAxOnIuYmVnaW49ZS5pbnQ2NCgpO2JyZWFrO2Nhc2UgMjpyLmVuZD1lLmludDY0KCk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbyl9fXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHN8fChlPW5ldyBzKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtyZXR1cm5cIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWU/XCJvYmplY3QgZXhwZWN0ZWRcIjpudWxsIT1lLmJlZ2luJiZlLmhhc093blByb3BlcnR5KFwiYmVnaW5cIikmJiEobC5pc0ludGVnZXIoZS5iZWdpbil8fGUuYmVnaW4mJmwuaXNJbnRlZ2VyKGUuYmVnaW4ubG93KSYmbC5pc0ludGVnZXIoZS5iZWdpbi5oaWdoKSk/XCJiZWdpbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI6bnVsbCE9ZS5lbmQmJmUuaGFzT3duUHJvcGVydHkoXCJlbmRcIikmJiEobC5pc0ludGVnZXIoZS5lbmQpfHxlLmVuZCYmbC5pc0ludGVnZXIoZS5lbmQubG93KSYmbC5pc0ludGVnZXIoZS5lbmQuaGlnaCkpP1wiZW5kOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjpudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5UZW5zb3JQcm90by5TZWdtZW50KXJldHVybiBlO3ZhciB0PW5ldyBjLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudDtyZXR1cm4gbnVsbCE9ZS5iZWdpbiYmKGwuTG9uZz8odC5iZWdpbj1sLkxvbmcuZnJvbVZhbHVlKGUuYmVnaW4pKS51bnNpZ25lZD0hMTpcInN0cmluZ1wiPT10eXBlb2YgZS5iZWdpbj90LmJlZ2luPXBhcnNlSW50KGUuYmVnaW4sMTApOlwibnVtYmVyXCI9PXR5cGVvZiBlLmJlZ2luP3QuYmVnaW49ZS5iZWdpbjpcIm9iamVjdFwiPT10eXBlb2YgZS5iZWdpbiYmKHQuYmVnaW49bmV3IGwuTG9uZ0JpdHMoZS5iZWdpbi5sb3c+Pj4wLGUuYmVnaW4uaGlnaD4+PjApLnRvTnVtYmVyKCkpKSxudWxsIT1lLmVuZCYmKGwuTG9uZz8odC5lbmQ9bC5Mb25nLmZyb21WYWx1ZShlLmVuZCkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLmVuZD90LmVuZD1wYXJzZUludChlLmVuZCwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUuZW5kP3QuZW5kPWUuZW5kOlwib2JqZWN0XCI9PXR5cGVvZiBlLmVuZCYmKHQuZW5kPW5ldyBsLkxvbmdCaXRzKGUuZW5kLmxvdz4+PjAsZS5lbmQuaGlnaD4+PjApLnRvTnVtYmVyKCkpKSx0fSxlLnRvT2JqZWN0PWZ1bmN0aW9uKGUsdCl7dHx8KHQ9e30pO3ZhciBuPXt9O2lmKHQuZGVmYXVsdHMpe2lmKGwuTG9uZyl7dmFyIHI9bmV3IGwuTG9uZygwLDAsITEpO24uYmVnaW49dC5sb25ncz09PVN0cmluZz9yLnRvU3RyaW5nKCk6dC5sb25ncz09PU51bWJlcj9yLnRvTnVtYmVyKCk6cn1lbHNlIG4uYmVnaW49dC5sb25ncz09PVN0cmluZz9cIjBcIjowO2wuTG9uZz8ocj1uZXcgbC5Mb25nKDAsMCwhMSksbi5lbmQ9dC5sb25ncz09PVN0cmluZz9yLnRvU3RyaW5nKCk6dC5sb25ncz09PU51bWJlcj9yLnRvTnVtYmVyKCk6cik6bi5lbmQ9dC5sb25ncz09PVN0cmluZz9cIjBcIjowfXJldHVybiBudWxsIT1lLmJlZ2luJiZlLmhhc093blByb3BlcnR5KFwiYmVnaW5cIikmJihcIm51bWJlclwiPT10eXBlb2YgZS5iZWdpbj9uLmJlZ2luPXQubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKGUuYmVnaW4pOmUuYmVnaW46bi5iZWdpbj10LmxvbmdzPT09U3RyaW5nP2wuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlLmJlZ2luKTp0LmxvbmdzPT09TnVtYmVyP25ldyBsLkxvbmdCaXRzKGUuYmVnaW4ubG93Pj4+MCxlLmJlZ2luLmhpZ2g+Pj4wKS50b051bWJlcigpOmUuYmVnaW4pLG51bGwhPWUuZW5kJiZlLmhhc093blByb3BlcnR5KFwiZW5kXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIGUuZW5kP24uZW5kPXQubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKGUuZW5kKTplLmVuZDpuLmVuZD10LmxvbmdzPT09U3RyaW5nP2wuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlLmVuZCk6dC5sb25ncz09PU51bWJlcj9uZXcgbC5Mb25nQml0cyhlLmVuZC5sb3c+Pj4wLGUuZW5kLmhpZ2g+Pj4wKS50b051bWJlcigpOmUuZW5kKSxufSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sZX0oKSxlLkRhdGFMb2NhdGlvbj1mdW5jdGlvbigpe3ZhciBlPXt9LHQ9T2JqZWN0LmNyZWF0ZShlKTtyZXR1cm4gdFtlWzBdPVwiREVGQVVMVFwiXT0wLHRbZVsxXT1cIkVYVEVSTkFMXCJdPTEsdH0oKSxlfSgpLGkuVGVuc29yU2hhcGVQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYodGhpcy5kaW09W10sZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXJldHVybiBlLnByb3RvdHlwZS5kaW09bC5lbXB0eUFycmF5LGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtpZih0fHwodD11LmNyZWF0ZSgpKSxudWxsIT1lLmRpbSYmZS5kaW0ubGVuZ3RoKWZvcih2YXIgbj0wO248ZS5kaW0ubGVuZ3RoOysrbiljLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24uZW5jb2RlKGUuZGltW25dLHQudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiB0fSxlLmVuY29kZURlbGltaXRlZD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVuY29kZShlLHQpLmxkZWxpbSgpfSxlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiBzfHwoZT1zLmNyZWF0ZShlKSk7Zm9yKHZhciBuPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyBjLm9ubnguVGVuc29yU2hhcGVQcm90bztlLnBvczxuOyl7dmFyIG89ZS51aW50MzIoKTtvPj4+Mz09MT8oci5kaW0mJnIuZGltLmxlbmd0aHx8KHIuZGltPVtdKSxyLmRpbS5wdXNoKGMub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi5kZWNvZGUoZSxlLnVpbnQzMigpKSkpOmUuc2tpcFR5cGUoNyZvKX1yZXR1cm4gcn0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBzfHwoZT1uZXcgcyhlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5kaW0mJmUuaGFzT3duUHJvcGVydHkoXCJkaW1cIikpe2lmKCFBcnJheS5pc0FycmF5KGUuZGltKSlyZXR1cm5cImRpbTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHQ9MDt0PGUuZGltLmxlbmd0aDsrK3Qpe3ZhciBuPWMub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi52ZXJpZnkoZS5kaW1bdF0pO2lmKG4pcmV0dXJuXCJkaW0uXCIrbn19cmV0dXJuIG51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54LlRlbnNvclNoYXBlUHJvdG8pcmV0dXJuIGU7dmFyIHQ9bmV3IGMub25ueC5UZW5zb3JTaGFwZVByb3RvO2lmKGUuZGltKXtpZighQXJyYXkuaXNBcnJheShlLmRpbSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yU2hhcGVQcm90by5kaW06IGFycmF5IGV4cGVjdGVkXCIpO3QuZGltPVtdO2Zvcih2YXIgbj0wO248ZS5kaW0ubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuZGltW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclNoYXBlUHJvdG8uZGltOiBvYmplY3QgZXhwZWN0ZWRcIik7dC5kaW1bbl09Yy5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLmZyb21PYmplY3QoZS5kaW1bbl0pfX1yZXR1cm4gdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtpZigodC5hcnJheXN8fHQuZGVmYXVsdHMpJiYobi5kaW09W10pLGUuZGltJiZlLmRpbS5sZW5ndGgpe24uZGltPVtdO2Zvcih2YXIgcj0wO3I8ZS5kaW0ubGVuZ3RoOysrciluLmRpbVtyXT1jLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24udG9PYmplY3QoZS5kaW1bcl0sdCl9cmV0dXJuIG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSxlLkRpbWVuc2lvbj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYoZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXZhciB0O3JldHVybiBlLnByb3RvdHlwZS5kaW1WYWx1ZT1sLkxvbmc/bC5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCxlLnByb3RvdHlwZS5kaW1QYXJhbT1cIlwiLGUucHJvdG90eXBlLmRlbm90YXRpb249XCJcIixPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJ2YWx1ZVwiLHtnZXQ6bC5vbmVPZkdldHRlcih0PVtcImRpbVZhbHVlXCIsXCJkaW1QYXJhbVwiXSksc2V0Omwub25lT2ZTZXR0ZXIodCl9KSxlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fCh0PXUuY3JlYXRlKCkpLG51bGwhPWUuZGltVmFsdWUmJmUuaGFzT3duUHJvcGVydHkoXCJkaW1WYWx1ZVwiKSYmdC51aW50MzIoOCkuaW50NjQoZS5kaW1WYWx1ZSksbnVsbCE9ZS5kaW1QYXJhbSYmZS5oYXNPd25Qcm9wZXJ0eShcImRpbVBhcmFtXCIpJiZ0LnVpbnQzMigxOCkuc3RyaW5nKGUuZGltUGFyYW0pLG51bGwhPWUuZGVub3RhdGlvbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikmJnQudWludDMyKDI2KS5zdHJpbmcoZS5kZW5vdGF0aW9uKSx0fSxlLmVuY29kZURlbGltaXRlZD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVuY29kZShlLHQpLmxkZWxpbSgpfSxlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiBzfHwoZT1zLmNyZWF0ZShlKSk7Zm9yKHZhciBuPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyBjLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb247ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci5kaW1WYWx1ZT1lLmludDY0KCk7YnJlYWs7Y2FzZSAyOnIuZGltUGFyYW09ZS5zdHJpbmcoKTticmVhaztjYXNlIDM6ci5kZW5vdGF0aW9uPWUuc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbyl9fXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHN8fChlPW5ldyBzKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWUpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjt2YXIgdD17fTtpZihudWxsIT1lLmRpbVZhbHVlJiZlLmhhc093blByb3BlcnR5KFwiZGltVmFsdWVcIikmJih0LnZhbHVlPTEsIShsLmlzSW50ZWdlcihlLmRpbVZhbHVlKXx8ZS5kaW1WYWx1ZSYmbC5pc0ludGVnZXIoZS5kaW1WYWx1ZS5sb3cpJiZsLmlzSW50ZWdlcihlLmRpbVZhbHVlLmhpZ2gpKSkpcmV0dXJuXCJkaW1WYWx1ZTogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5kaW1QYXJhbSYmZS5oYXNPd25Qcm9wZXJ0eShcImRpbVBhcmFtXCIpKXtpZigxPT09dC52YWx1ZSlyZXR1cm5cInZhbHVlOiBtdWx0aXBsZSB2YWx1ZXNcIjtpZih0LnZhbHVlPTEsIWwuaXNTdHJpbmcoZS5kaW1QYXJhbSkpcmV0dXJuXCJkaW1QYXJhbTogc3RyaW5nIGV4cGVjdGVkXCJ9cmV0dXJuIG51bGwhPWUuZGVub3RhdGlvbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikmJiFsLmlzU3RyaW5nKGUuZGVub3RhdGlvbik/XCJkZW5vdGF0aW9uOiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbilyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uO3JldHVybiBudWxsIT1lLmRpbVZhbHVlJiYobC5Mb25nPyh0LmRpbVZhbHVlPWwuTG9uZy5mcm9tVmFsdWUoZS5kaW1WYWx1ZSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLmRpbVZhbHVlP3QuZGltVmFsdWU9cGFyc2VJbnQoZS5kaW1WYWx1ZSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUuZGltVmFsdWU/dC5kaW1WYWx1ZT1lLmRpbVZhbHVlOlwib2JqZWN0XCI9PXR5cGVvZiBlLmRpbVZhbHVlJiYodC5kaW1WYWx1ZT1uZXcgbC5Mb25nQml0cyhlLmRpbVZhbHVlLmxvdz4+PjAsZS5kaW1WYWx1ZS5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLG51bGwhPWUuZGltUGFyYW0mJih0LmRpbVBhcmFtPVN0cmluZyhlLmRpbVBhcmFtKSksbnVsbCE9ZS5kZW5vdGF0aW9uJiYodC5kZW5vdGF0aW9uPVN0cmluZyhlLmRlbm90YXRpb24pKSx0fSxlLnRvT2JqZWN0PWZ1bmN0aW9uKGUsdCl7dHx8KHQ9e30pO3ZhciBuPXt9O3JldHVybiB0LmRlZmF1bHRzJiYobi5kZW5vdGF0aW9uPVwiXCIpLG51bGwhPWUuZGltVmFsdWUmJmUuaGFzT3duUHJvcGVydHkoXCJkaW1WYWx1ZVwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiBlLmRpbVZhbHVlP24uZGltVmFsdWU9dC5sb25ncz09PVN0cmluZz9TdHJpbmcoZS5kaW1WYWx1ZSk6ZS5kaW1WYWx1ZTpuLmRpbVZhbHVlPXQubG9uZ3M9PT1TdHJpbmc/bC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUuZGltVmFsdWUpOnQubG9uZ3M9PT1OdW1iZXI/bmV3IGwuTG9uZ0JpdHMoZS5kaW1WYWx1ZS5sb3c+Pj4wLGUuZGltVmFsdWUuaGlnaD4+PjApLnRvTnVtYmVyKCk6ZS5kaW1WYWx1ZSx0Lm9uZW9mcyYmKG4udmFsdWU9XCJkaW1WYWx1ZVwiKSksbnVsbCE9ZS5kaW1QYXJhbSYmZS5oYXNPd25Qcm9wZXJ0eShcImRpbVBhcmFtXCIpJiYobi5kaW1QYXJhbT1lLmRpbVBhcmFtLHQub25lb2ZzJiYobi52YWx1ZT1cImRpbVBhcmFtXCIpKSxudWxsIT1lLmRlbm90YXRpb24mJmUuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpJiYobi5kZW5vdGF0aW9uPWUuZGVub3RhdGlvbiksbn0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LGV9KCksZX0oKSxpLlR5cGVQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYoZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXZhciB0O3JldHVybiBlLnByb3RvdHlwZS50ZW5zb3JUeXBlPW51bGwsZS5wcm90b3R5cGUuZGVub3RhdGlvbj1cIlwiLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcInZhbHVlXCIse2dldDpsLm9uZU9mR2V0dGVyKHQ9W1widGVuc29yVHlwZVwiXSksc2V0Omwub25lT2ZTZXR0ZXIodCl9KSxlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fCh0PXUuY3JlYXRlKCkpLG51bGwhPWUudGVuc29yVHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcInRlbnNvclR5cGVcIikmJmMub25ueC5UeXBlUHJvdG8uVGVuc29yLmVuY29kZShlLnRlbnNvclR5cGUsdC51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCksbnVsbCE9ZS5kZW5vdGF0aW9uJiZlLmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmdC51aW50MzIoNTApLnN0cmluZyhlLmRlbm90YXRpb24pLHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIHN8fChlPXMuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5UeXBlUHJvdG87ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci50ZW5zb3JUeXBlPWMub25ueC5UeXBlUHJvdG8uVGVuc29yLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2Nhc2UgNjpyLmRlbm90YXRpb249ZS5zdHJpbmcoKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZvKX19cmV0dXJuIHJ9LGUuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2Ygc3x8KGU9bmV3IHMoZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LGUudmVyaWZ5PWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZSlyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPWUudGVuc29yVHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcInRlbnNvclR5cGVcIikpe3ZhciB0PWMub25ueC5UeXBlUHJvdG8uVGVuc29yLnZlcmlmeShlLnRlbnNvclR5cGUpO2lmKHQpcmV0dXJuXCJ0ZW5zb3JUeXBlLlwiK3R9cmV0dXJuIG51bGwhPWUuZGVub3RhdGlvbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikmJiFsLmlzU3RyaW5nKGUuZGVub3RhdGlvbik/XCJkZW5vdGF0aW9uOiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5UeXBlUHJvdG8pcmV0dXJuIGU7dmFyIHQ9bmV3IGMub25ueC5UeXBlUHJvdG87aWYobnVsbCE9ZS50ZW5zb3JUeXBlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS50ZW5zb3JUeXBlKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by50ZW5zb3JUeXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7dC50ZW5zb3JUeXBlPWMub25ueC5UeXBlUHJvdG8uVGVuc29yLmZyb21PYmplY3QoZS50ZW5zb3JUeXBlKX1yZXR1cm4gbnVsbCE9ZS5kZW5vdGF0aW9uJiYodC5kZW5vdGF0aW9uPVN0cmluZyhlLmRlbm90YXRpb24pKSx0fSxlLnRvT2JqZWN0PWZ1bmN0aW9uKGUsdCl7dHx8KHQ9e30pO3ZhciBuPXt9O3JldHVybiB0LmRlZmF1bHRzJiYobi5kZW5vdGF0aW9uPVwiXCIpLG51bGwhPWUudGVuc29yVHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcInRlbnNvclR5cGVcIikmJihuLnRlbnNvclR5cGU9Yy5vbm54LlR5cGVQcm90by5UZW5zb3IudG9PYmplY3QoZS50ZW5zb3JUeXBlLHQpLHQub25lb2ZzJiYobi52YWx1ZT1cInRlbnNvclR5cGVcIikpLG51bGwhPWUuZGVub3RhdGlvbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikmJihuLmRlbm90YXRpb249ZS5kZW5vdGF0aW9uKSxufSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sZS5UZW5zb3I9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLG49MDtuPHQubGVuZ3RoOysrbiludWxsIT1lW3Rbbl1dJiYodGhpc1t0W25dXT1lW3Rbbl1dKX1yZXR1cm4gZS5wcm90b3R5cGUuZWxlbVR5cGU9MCxlLnByb3RvdHlwZS5zaGFwZT1udWxsLGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8KHQ9dS5jcmVhdGUoKSksbnVsbCE9ZS5lbGVtVHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpJiZ0LnVpbnQzMig4KS5pbnQzMihlLmVsZW1UeXBlKSxudWxsIT1lLnNoYXBlJiZlLmhhc093blByb3BlcnR5KFwic2hhcGVcIikmJmMub25ueC5UZW5zb3JTaGFwZVByb3RvLmVuY29kZShlLnNoYXBlLHQudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpLHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIHN8fChlPXMuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5UeXBlUHJvdG8uVGVuc29yO2UucG9zPG47KXt2YXIgbz1lLnVpbnQzMigpO3N3aXRjaChvPj4+Myl7Y2FzZSAxOnIuZWxlbVR5cGU9ZS5pbnQzMigpO2JyZWFrO2Nhc2UgMjpyLnNoYXBlPWMub25ueC5UZW5zb3JTaGFwZVByb3RvLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm8pfX1yZXR1cm4gcn0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBzfHwoZT1uZXcgcyhlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5lbGVtVHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpJiYhbC5pc0ludGVnZXIoZS5lbGVtVHlwZSkpcmV0dXJuXCJlbGVtVHlwZTogaW50ZWdlciBleHBlY3RlZFwiO2lmKG51bGwhPWUuc2hhcGUmJmUuaGFzT3duUHJvcGVydHkoXCJzaGFwZVwiKSl7dmFyIHQ9Yy5vbm54LlRlbnNvclNoYXBlUHJvdG8udmVyaWZ5KGUuc2hhcGUpO2lmKHQpcmV0dXJuXCJzaGFwZS5cIit0fXJldHVybiBudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5UeXBlUHJvdG8uVGVuc29yKXJldHVybiBlO3ZhciB0PW5ldyBjLm9ubnguVHlwZVByb3RvLlRlbnNvcjtpZihudWxsIT1lLmVsZW1UeXBlJiYodC5lbGVtVHlwZT0wfGUuZWxlbVR5cGUpLG51bGwhPWUuc2hhcGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLnNoYXBlKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by5UZW5zb3Iuc2hhcGU6IG9iamVjdCBleHBlY3RlZFwiKTt0LnNoYXBlPWMub25ueC5UZW5zb3JTaGFwZVByb3RvLmZyb21PYmplY3QoZS5zaGFwZSl9cmV0dXJuIHR9LGUudG9PYmplY3Q9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSk7dmFyIG49e307cmV0dXJuIHQuZGVmYXVsdHMmJihuLmVsZW1UeXBlPTAsbi5zaGFwZT1udWxsKSxudWxsIT1lLmVsZW1UeXBlJiZlLmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikmJihuLmVsZW1UeXBlPWUuZWxlbVR5cGUpLG51bGwhPWUuc2hhcGUmJmUuaGFzT3duUHJvcGVydHkoXCJzaGFwZVwiKSYmKG4uc2hhcGU9Yy5vbm54LlRlbnNvclNoYXBlUHJvdG8udG9PYmplY3QoZS5zaGFwZSx0KSksbn0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LGV9KCksZX0oKSxpLk9wZXJhdG9yU2V0SWRQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYoZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXJldHVybiBlLnByb3RvdHlwZS5kb21haW49XCJcIixlLnByb3RvdHlwZS52ZXJzaW9uPWwuTG9uZz9sLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8KHQ9dS5jcmVhdGUoKSksbnVsbCE9ZS5kb21haW4mJmUuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJnQudWludDMyKDEwKS5zdHJpbmcoZS5kb21haW4pLG51bGwhPWUudmVyc2lvbiYmZS5oYXNPd25Qcm9wZXJ0eShcInZlcnNpb25cIikmJnQudWludDMyKDE2KS5pbnQ2NChlLnZlcnNpb24pLHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIHN8fChlPXMuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5PcGVyYXRvclNldElkUHJvdG87ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci5kb21haW49ZS5zdHJpbmcoKTticmVhaztjYXNlIDI6ci52ZXJzaW9uPWUuaW50NjQoKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZvKX19cmV0dXJuIHJ9LGUuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2Ygc3x8KGU9bmV3IHMoZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LGUudmVyaWZ5PWZ1bmN0aW9uKGUpe3JldHVyblwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZT9cIm9iamVjdCBleHBlY3RlZFwiOm51bGwhPWUuZG9tYWluJiZlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYhbC5pc1N0cmluZyhlLmRvbWFpbik/XCJkb21haW46IHN0cmluZyBleHBlY3RlZFwiOm51bGwhPWUudmVyc2lvbiYmZS5oYXNPd25Qcm9wZXJ0eShcInZlcnNpb25cIikmJiEobC5pc0ludGVnZXIoZS52ZXJzaW9uKXx8ZS52ZXJzaW9uJiZsLmlzSW50ZWdlcihlLnZlcnNpb24ubG93KSYmbC5pc0ludGVnZXIoZS52ZXJzaW9uLmhpZ2gpKT9cInZlcnNpb246IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiOm51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54Lk9wZXJhdG9yU2V0SWRQcm90bylyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54Lk9wZXJhdG9yU2V0SWRQcm90bztyZXR1cm4gbnVsbCE9ZS5kb21haW4mJih0LmRvbWFpbj1TdHJpbmcoZS5kb21haW4pKSxudWxsIT1lLnZlcnNpb24mJihsLkxvbmc/KHQudmVyc2lvbj1sLkxvbmcuZnJvbVZhbHVlKGUudmVyc2lvbikpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLnZlcnNpb24/dC52ZXJzaW9uPXBhcnNlSW50KGUudmVyc2lvbiwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUudmVyc2lvbj90LnZlcnNpb249ZS52ZXJzaW9uOlwib2JqZWN0XCI9PXR5cGVvZiBlLnZlcnNpb24mJih0LnZlcnNpb249bmV3IGwuTG9uZ0JpdHMoZS52ZXJzaW9uLmxvdz4+PjAsZS52ZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpKSksdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtpZih0LmRlZmF1bHRzKWlmKG4uZG9tYWluPVwiXCIsbC5Mb25nKXt2YXIgcj1uZXcgbC5Mb25nKDAsMCwhMSk7bi52ZXJzaW9uPXQubG9uZ3M9PT1TdHJpbmc/ci50b1N0cmluZygpOnQubG9uZ3M9PT1OdW1iZXI/ci50b051bWJlcigpOnJ9ZWxzZSBuLnZlcnNpb249dC5sb25ncz09PVN0cmluZz9cIjBcIjowO3JldHVybiBudWxsIT1lLmRvbWFpbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmKG4uZG9tYWluPWUuZG9tYWluKSxudWxsIT1lLnZlcnNpb24mJmUuaGFzT3duUHJvcGVydHkoXCJ2ZXJzaW9uXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIGUudmVyc2lvbj9uLnZlcnNpb249dC5sb25ncz09PVN0cmluZz9TdHJpbmcoZS52ZXJzaW9uKTplLnZlcnNpb246bi52ZXJzaW9uPXQubG9uZ3M9PT1TdHJpbmc/bC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUudmVyc2lvbik6dC5sb25ncz09PU51bWJlcj9uZXcgbC5Mb25nQml0cyhlLnZlcnNpb24ubG93Pj4+MCxlLnZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCk6ZS52ZXJzaW9uKSxufSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sZX0oKSxpKSxlLmV4cG9ydHM9Y30sMjEwMDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPW4oOTQ4Mil9LDk0ODI6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO3ZhciByPXQ7ZnVuY3Rpb24gbygpe3IudXRpbC5fY29uZmlndXJlKCksci5Xcml0ZXIuX2NvbmZpZ3VyZShyLkJ1ZmZlcldyaXRlciksci5SZWFkZXIuX2NvbmZpZ3VyZShyLkJ1ZmZlclJlYWRlcil9ci5idWlsZD1cIm1pbmltYWxcIixyLldyaXRlcj1uKDExNzMpLHIuQnVmZmVyV3JpdGVyPW4oMzE1NSksci5SZWFkZXI9bigxNDA4KSxyLkJ1ZmZlclJlYWRlcj1uKDU5Myksci51dGlsPW4oOTY5Myksci5ycGM9big1OTk0KSxyLnJvb3RzPW4oNTA1NCksci5jb25maWd1cmU9byxvKCl9LDE0MDg6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz11O3ZhciByLG89big5NjkzKSxpPW8uTG9uZ0JpdHMsYT1vLnV0Zjg7ZnVuY3Rpb24gcyhlLHQpe3JldHVybiBSYW5nZUVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlOiBcIitlLnBvcytcIiArIFwiKyh0fHwxKStcIiA+IFwiK2UubGVuKX1mdW5jdGlvbiB1KGUpe3RoaXMuYnVmPWUsdGhpcy5wb3M9MCx0aGlzLmxlbj1lLmxlbmd0aH12YXIgbCxjPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBVaW50OEFycmF5P2Z1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBVaW50OEFycmF5fHxBcnJheS5pc0FycmF5KGUpKXJldHVybiBuZXcgdShlKTt0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpfTpmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBuZXcgdShlKTt0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpfSxwPWZ1bmN0aW9uKCl7cmV0dXJuIG8uQnVmZmVyP2Z1bmN0aW9uKGUpe3JldHVybih1LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gby5CdWZmZXIuaXNCdWZmZXIoZSk/bmV3IHIoZSk6YyhlKX0pKGUpfTpjfTtmdW5jdGlvbiBkKCl7dmFyIGU9bmV3IGkoMCwwKSx0PTA7aWYoISh0aGlzLmxlbi10aGlzLnBvcz40KSl7Zm9yKDt0PDM7Kyt0KXtpZih0aGlzLnBvcz49dGhpcy5sZW4pdGhyb3cgcyh0aGlzKTtpZihlLmxvPShlLmxvfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8Nyp0KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBlfXJldHVybiBlLmxvPShlLmxvfCgxMjcmdGhpcy5idWZbdGhpcy5wb3MrK10pPDw3KnQpPj4+MCxlfWZvcig7dDw0OysrdClpZihlLmxvPShlLmxvfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8Nyp0KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBlO2lmKGUubG89KGUubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDwyOCk+Pj4wLGUuaGk9KGUuaGl8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPj40KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBlO2lmKHQ9MCx0aGlzLmxlbi10aGlzLnBvcz40KXtmb3IoO3Q8NTsrK3QpaWYoZS5oaT0oZS5oaXwoMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDcqdCszKT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBlfWVsc2UgZm9yKDt0PDU7Kyt0KXtpZih0aGlzLnBvcz49dGhpcy5sZW4pdGhyb3cgcyh0aGlzKTtpZihlLmhpPShlLmhpfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8Nyp0KzMpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGV9dGhyb3cgRXJyb3IoXCJpbnZhbGlkIHZhcmludCBlbmNvZGluZ1wiKX1mdW5jdGlvbiBmKGUsdCl7cmV0dXJuKGVbdC00XXxlW3QtM108PDh8ZVt0LTJdPDwxNnxlW3QtMV08PDI0KT4+PjB9ZnVuY3Rpb24gaCgpe2lmKHRoaXMucG9zKzg+dGhpcy5sZW4pdGhyb3cgcyh0aGlzLDgpO3JldHVybiBuZXcgaShmKHRoaXMuYnVmLHRoaXMucG9zKz00KSxmKHRoaXMuYnVmLHRoaXMucG9zKz00KSl9dS5jcmVhdGU9cCgpLHUucHJvdG90eXBlLl9zbGljZT1vLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheXx8by5BcnJheS5wcm90b3R5cGUuc2xpY2UsdS5wcm90b3R5cGUudWludDMyPShsPTQyOTQ5NjcyOTUsZnVuY3Rpb24oKXtpZihsPSgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBsO2lmKGw9KGx8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBsO2lmKGw9KGx8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDwxNCk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gbDtpZihsPShsfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8MjEpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGw7aWYobD0obHwoMTUmdGhpcy5idWZbdGhpcy5wb3NdKTw8MjgpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGw7aWYoKHRoaXMucG9zKz01KT50aGlzLmxlbil0aHJvdyB0aGlzLnBvcz10aGlzLmxlbixzKHRoaXMsMTApO3JldHVybiBsfSksdS5wcm90b3R5cGUuaW50MzI9ZnVuY3Rpb24oKXtyZXR1cm4gMHx0aGlzLnVpbnQzMigpfSx1LnByb3RvdHlwZS5zaW50MzI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnVpbnQzMigpO3JldHVybiBlPj4+MV4tKDEmZSl8MH0sdS5wcm90b3R5cGUuYm9vbD1mdW5jdGlvbigpe3JldHVybiAwIT09dGhpcy51aW50MzIoKX0sdS5wcm90b3R5cGUuZml4ZWQzMj1mdW5jdGlvbigpe2lmKHRoaXMucG9zKzQ+dGhpcy5sZW4pdGhyb3cgcyh0aGlzLDQpO3JldHVybiBmKHRoaXMuYnVmLHRoaXMucG9zKz00KX0sdS5wcm90b3R5cGUuc2ZpeGVkMzI9ZnVuY3Rpb24oKXtpZih0aGlzLnBvcys0PnRoaXMubGVuKXRocm93IHModGhpcyw0KTtyZXR1cm4gMHxmKHRoaXMuYnVmLHRoaXMucG9zKz00KX0sdS5wcm90b3R5cGUuZmxvYXQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBvcys0PnRoaXMubGVuKXRocm93IHModGhpcyw0KTt2YXIgZT1vLmZsb2F0LnJlYWRGbG9hdExFKHRoaXMuYnVmLHRoaXMucG9zKTtyZXR1cm4gdGhpcy5wb3MrPTQsZX0sdS5wcm90b3R5cGUuZG91YmxlPWZ1bmN0aW9uKCl7aWYodGhpcy5wb3MrOD50aGlzLmxlbil0aHJvdyBzKHRoaXMsNCk7dmFyIGU9by5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsdGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9OCxlfSx1LnByb3RvdHlwZS5ieXRlcz1mdW5jdGlvbigpe3ZhciBlPXRoaXMudWludDMyKCksdD10aGlzLnBvcyxuPXRoaXMucG9zK2U7aWYobj50aGlzLmxlbil0aHJvdyBzKHRoaXMsZSk7cmV0dXJuIHRoaXMucG9zKz1lLEFycmF5LmlzQXJyYXkodGhpcy5idWYpP3RoaXMuYnVmLnNsaWNlKHQsbik6dD09PW4/bmV3IHRoaXMuYnVmLmNvbnN0cnVjdG9yKDApOnRoaXMuX3NsaWNlLmNhbGwodGhpcy5idWYsdCxuKX0sdS5wcm90b3R5cGUuc3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5ieXRlcygpO3JldHVybiBhLnJlYWQoZSwwLGUubGVuZ3RoKX0sdS5wcm90b3R5cGUuc2tpcD1mdW5jdGlvbihlKXtpZihcIm51bWJlclwiPT10eXBlb2YgZSl7aWYodGhpcy5wb3MrZT50aGlzLmxlbil0aHJvdyBzKHRoaXMsZSk7dGhpcy5wb3MrPWV9ZWxzZSBkb3tpZih0aGlzLnBvcz49dGhpcy5sZW4pdGhyb3cgcyh0aGlzKX13aGlsZSgxMjgmdGhpcy5idWZbdGhpcy5wb3MrK10pO3JldHVybiB0aGlzfSx1LnByb3RvdHlwZS5za2lwVHlwZT1mdW5jdGlvbihlKXtzd2l0Y2goZSl7Y2FzZSAwOnRoaXMuc2tpcCgpO2JyZWFrO2Nhc2UgMTp0aGlzLnNraXAoOCk7YnJlYWs7Y2FzZSAyOnRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTticmVhaztjYXNlIDM6Zm9yKDs0IT0oZT03JnRoaXMudWludDMyKCkpOyl0aGlzLnNraXBUeXBlKGUpO2JyZWFrO2Nhc2UgNTp0aGlzLnNraXAoNCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcImludmFsaWQgd2lyZSB0eXBlIFwiK2UrXCIgYXQgb2Zmc2V0IFwiK3RoaXMucG9zKX1yZXR1cm4gdGhpc30sdS5fY29uZmlndXJlPWZ1bmN0aW9uKGUpe3I9ZSx1LmNyZWF0ZT1wKCksci5fY29uZmlndXJlKCk7dmFyIHQ9by5Mb25nP1widG9Mb25nXCI6XCJ0b051bWJlclwiO28ubWVyZ2UodS5wcm90b3R5cGUse2ludDY0OmZ1bmN0aW9uKCl7cmV0dXJuIGQuY2FsbCh0aGlzKVt0XSghMSl9LHVpbnQ2NDpmdW5jdGlvbigpe3JldHVybiBkLmNhbGwodGhpcylbdF0oITApfSxzaW50NjQ6ZnVuY3Rpb24oKXtyZXR1cm4gZC5jYWxsKHRoaXMpLnp6RGVjb2RlKClbdF0oITEpfSxmaXhlZDY0OmZ1bmN0aW9uKCl7cmV0dXJuIGguY2FsbCh0aGlzKVt0XSghMCl9LHNmaXhlZDY0OmZ1bmN0aW9uKCl7cmV0dXJuIGguY2FsbCh0aGlzKVt0XSghMSl9fSl9fSw1OTM6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1pO3ZhciByPW4oMTQwOCk7KGkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1pO3ZhciBvPW4oOTY5Myk7ZnVuY3Rpb24gaShlKXtyLmNhbGwodGhpcyxlKX1pLl9jb25maWd1cmU9ZnVuY3Rpb24oKXtvLkJ1ZmZlciYmKGkucHJvdG90eXBlLl9zbGljZT1vLkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UpfSxpLnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnVpbnQzMigpO3JldHVybiB0aGlzLmJ1Zi51dGY4U2xpY2U/dGhpcy5idWYudXRmOFNsaWNlKHRoaXMucG9zLHRoaXMucG9zPU1hdGgubWluKHRoaXMucG9zK2UsdGhpcy5sZW4pKTp0aGlzLmJ1Zi50b1N0cmluZyhcInV0Zi04XCIsdGhpcy5wb3MsdGhpcy5wb3M9TWF0aC5taW4odGhpcy5wb3MrZSx0aGlzLmxlbikpfSxpLl9jb25maWd1cmUoKX0sNTA1NDplPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXt9fSw1OTk0OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjt0LlNlcnZpY2U9big3OTQ4KX0sNzk0ODooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPW87dmFyIHI9big5NjkzKTtmdW5jdGlvbiBvKGUsdCxuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IFR5cGVFcnJvcihcInJwY0ltcGwgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO3IuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyksdGhpcy5ycGNJbXBsPWUsdGhpcy5yZXF1ZXN0RGVsaW1pdGVkPUJvb2xlYW4odCksdGhpcy5yZXNwb25zZURlbGltaXRlZD1Cb29sZWFuKG4pfShvLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHIuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPW8sby5wcm90b3R5cGUucnBjQ2FsbD1mdW5jdGlvbiBlKHQsbixvLGksYSl7aWYoIWkpdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdCBtdXN0IGJlIHNwZWNpZmllZFwiKTt2YXIgcz10aGlzO2lmKCFhKXJldHVybiByLmFzUHJvbWlzZShlLHMsdCxuLG8saSk7aWYocy5ycGNJbXBsKXRyeXtyZXR1cm4gcy5ycGNJbXBsKHQsbltzLnJlcXVlc3REZWxpbWl0ZWQ/XCJlbmNvZGVEZWxpbWl0ZWRcIjpcImVuY29kZVwiXShpKS5maW5pc2goKSwoZnVuY3Rpb24oZSxuKXtpZihlKXJldHVybiBzLmVtaXQoXCJlcnJvclwiLGUsdCksYShlKTtpZihudWxsIT09bil7aWYoIShuIGluc3RhbmNlb2YgbykpdHJ5e249b1tzLnJlc3BvbnNlRGVsaW1pdGVkP1wiZGVjb2RlRGVsaW1pdGVkXCI6XCJkZWNvZGVcIl0obil9Y2F0Y2goZSl7cmV0dXJuIHMuZW1pdChcImVycm9yXCIsZSx0KSxhKGUpfXJldHVybiBzLmVtaXQoXCJkYXRhXCIsbix0KSxhKG51bGwsbil9cy5lbmQoITApfSkpfWNhdGNoKGUpe3JldHVybiBzLmVtaXQoXCJlcnJvclwiLGUsdCksdm9pZCBzZXRUaW1lb3V0KChmdW5jdGlvbigpe2EoZSl9KSwwKX1lbHNlIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7YShFcnJvcihcImFscmVhZHkgZW5kZWRcIikpfSksMCl9LG8ucHJvdG90eXBlLmVuZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5ycGNJbXBsJiYoZXx8dGhpcy5ycGNJbXBsKG51bGwsbnVsbCxudWxsKSx0aGlzLnJwY0ltcGw9bnVsbCx0aGlzLmVtaXQoXCJlbmRcIikub2ZmKCkpLHRoaXN9fSwxOTQ1OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9bzt2YXIgcj1uKDk2OTMpO2Z1bmN0aW9uIG8oZSx0KXt0aGlzLmxvPWU+Pj4wLHRoaXMuaGk9dD4+PjB9dmFyIGk9by56ZXJvPW5ldyBvKDAsMCk7aS50b051bWJlcj1mdW5jdGlvbigpe3JldHVybiAwfSxpLnp6RW5jb2RlPWkuenpEZWNvZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30saS5sZW5ndGg9ZnVuY3Rpb24oKXtyZXR1cm4gMX07dmFyIGE9by56ZXJvSGFzaD1cIlxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFwiO28uZnJvbU51bWJlcj1mdW5jdGlvbihlKXtpZigwPT09ZSlyZXR1cm4gaTt2YXIgdD1lPDA7dCYmKGU9LWUpO3ZhciBuPWU+Pj4wLHI9KGUtbikvNDI5NDk2NzI5Nj4+PjA7cmV0dXJuIHQmJihyPX5yPj4+MCxuPX5uPj4+MCwrK24+NDI5NDk2NzI5NSYmKG49MCwrK3I+NDI5NDk2NzI5NSYmKHI9MCkpKSxuZXcgbyhuLHIpfSxvLmZyb209ZnVuY3Rpb24oZSl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpcmV0dXJuIG8uZnJvbU51bWJlcihlKTtpZihyLmlzU3RyaW5nKGUpKXtpZighci5Mb25nKXJldHVybiBvLmZyb21OdW1iZXIocGFyc2VJbnQoZSwxMCkpO2U9ci5Mb25nLmZyb21TdHJpbmcoZSl9cmV0dXJuIGUubG93fHxlLmhpZ2g/bmV3IG8oZS5sb3c+Pj4wLGUuaGlnaD4+PjApOml9LG8ucHJvdG90eXBlLnRvTnVtYmVyPWZ1bmN0aW9uKGUpe2lmKCFlJiZ0aGlzLmhpPj4+MzEpe3ZhciB0PTErfnRoaXMubG8+Pj4wLG49fnRoaXMuaGk+Pj4wO3JldHVybiB0fHwobj1uKzE+Pj4wKSwtKHQrNDI5NDk2NzI5NipuKX1yZXR1cm4gdGhpcy5sbys0Mjk0OTY3Mjk2KnRoaXMuaGl9LG8ucHJvdG90eXBlLnRvTG9uZz1mdW5jdGlvbihlKXtyZXR1cm4gci5Mb25nP25ldyByLkxvbmcoMHx0aGlzLmxvLDB8dGhpcy5oaSxCb29sZWFuKGUpKTp7bG93OjB8dGhpcy5sbyxoaWdoOjB8dGhpcy5oaSx1bnNpZ25lZDpCb29sZWFuKGUpfX07dmFyIHM9U3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0O28uZnJvbUhhc2g9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1hP2k6bmV3IG8oKHMuY2FsbChlLDApfHMuY2FsbChlLDEpPDw4fHMuY2FsbChlLDIpPDwxNnxzLmNhbGwoZSwzKTw8MjQpPj4+MCwocy5jYWxsKGUsNCl8cy5jYWxsKGUsNSk8PDh8cy5jYWxsKGUsNik8PDE2fHMuY2FsbChlLDcpPDwyNCk+Pj4wKX0sby5wcm90b3R5cGUudG9IYXNoPWZ1bmN0aW9uKCl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1JnRoaXMubG8sdGhpcy5sbz4+PjgmMjU1LHRoaXMubG8+Pj4xNiYyNTUsdGhpcy5sbz4+PjI0LDI1NSZ0aGlzLmhpLHRoaXMuaGk+Pj44JjI1NSx0aGlzLmhpPj4+MTYmMjU1LHRoaXMuaGk+Pj4yNCl9LG8ucHJvdG90eXBlLnp6RW5jb2RlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5oaT4+MzE7cmV0dXJuIHRoaXMuaGk9KCh0aGlzLmhpPDwxfHRoaXMubG8+Pj4zMSleZSk+Pj4wLHRoaXMubG89KHRoaXMubG88PDFeZSk+Pj4wLHRoaXN9LG8ucHJvdG90eXBlLnp6RGVjb2RlPWZ1bmN0aW9uKCl7dmFyIGU9LSgxJnRoaXMubG8pO3JldHVybiB0aGlzLmxvPSgodGhpcy5sbz4+PjF8dGhpcy5oaTw8MzEpXmUpPj4+MCx0aGlzLmhpPSh0aGlzLmhpPj4+MV5lKT4+PjAsdGhpc30sby5wcm90b3R5cGUubGVuZ3RoPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5sbyx0PSh0aGlzLmxvPj4+Mjh8dGhpcy5oaTw8NCk+Pj4wLG49dGhpcy5oaT4+PjI0O3JldHVybiAwPT09bj8wPT09dD9lPDE2Mzg0P2U8MTI4PzE6MjplPDIwOTcxNTI/Mzo0OnQ8MTYzODQ/dDwxMjg/NTo2OnQ8MjA5NzE1Mj83Ojg6bjwxMjg/OToxMH19LDk2OTM6ZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciByPXQ7ZnVuY3Rpb24gbyhlLHQsbil7Zm9yKHZhciByPU9iamVjdC5rZXlzKHQpLG89MDtvPHIubGVuZ3RoOysrbyl2b2lkIDAhPT1lW3Jbb11dJiZufHwoZVtyW29dXT10W3Jbb11dKTtyZXR1cm4gZX1mdW5jdGlvbiBpKGUpe2Z1bmN0aW9uIHQoZSxuKXtpZighKHRoaXMgaW5zdGFuY2VvZiB0KSlyZXR1cm4gbmV3IHQoZSxuKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcIm1lc3NhZ2VcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGV9fSksRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U/RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcyx0KTpPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcInN0YWNrXCIse3ZhbHVlOihuZXcgRXJyb3IpLnN0YWNrfHxcIlwifSksbiYmbyh0aGlzLG4pfXJldHVybih0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPXQsT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwibmFtZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZX19KSx0LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5hbWUrXCI6IFwiK3RoaXMubWVzc2FnZX0sdH1yLmFzUHJvbWlzZT1uKDQ1MzcpLHIuYmFzZTY0PW4oNzQxOSksci5FdmVudEVtaXR0ZXI9big5MjExKSxyLmZsb2F0PW4oOTQ1KSxyLmlucXVpcmU9big3MTk5KSxyLnV0Zjg9big0OTk3KSxyLnBvb2w9big2NjYyKSxyLkxvbmdCaXRzPW4oMTk0NSksci5pc05vZGU9Qm9vbGVhbih2b2lkIDAhPT1uLmcmJm4uZyYmbi5nLnByb2Nlc3MmJm4uZy5wcm9jZXNzLnZlcnNpb25zJiZuLmcucHJvY2Vzcy52ZXJzaW9ucy5ub2RlKSxyLmdsb2JhbD1yLmlzTm9kZSYmbi5nfHxcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3d8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmfHx0aGlzLHIuZW1wdHlBcnJheT1PYmplY3QuZnJlZXplP09iamVjdC5mcmVlemUoW10pOltdLHIuZW1wdHlPYmplY3Q9T2JqZWN0LmZyZWV6ZT9PYmplY3QuZnJlZXplKHt9KTp7fSxyLmlzSW50ZWdlcj1OdW1iZXIuaXNJbnRlZ2VyfHxmdW5jdGlvbihlKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgZSYmaXNGaW5pdGUoZSkmJk1hdGguZmxvb3IoZSk9PT1lfSxyLmlzU3RyaW5nPWZ1bmN0aW9uKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlfHxlIGluc3RhbmNlb2YgU3RyaW5nfSxyLmlzT2JqZWN0PWZ1bmN0aW9uKGUpe3JldHVybiBlJiZcIm9iamVjdFwiPT10eXBlb2YgZX0sci5pc3NldD1yLmlzU2V0PWZ1bmN0aW9uKGUsdCl7dmFyIG49ZVt0XTtyZXR1cm4hKG51bGw9PW58fCFlLmhhc093blByb3BlcnR5KHQpKSYmKFwib2JqZWN0XCIhPXR5cGVvZiBufHwoQXJyYXkuaXNBcnJheShuKT9uLmxlbmd0aDpPYmplY3Qua2V5cyhuKS5sZW5ndGgpPjApfSxyLkJ1ZmZlcj1mdW5jdGlvbigpe3RyeXt2YXIgZT1yLmlucXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO3JldHVybiBlLnByb3RvdHlwZS51dGY4V3JpdGU/ZTpudWxsfWNhdGNoKGUpe3JldHVybiBudWxsfX0oKSxyLl9CdWZmZXJfZnJvbT1udWxsLHIuX0J1ZmZlcl9hbGxvY1Vuc2FmZT1udWxsLHIubmV3QnVmZmVyPWZ1bmN0aW9uKGUpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBlP3IuQnVmZmVyP3IuX0J1ZmZlcl9hbGxvY1Vuc2FmZShlKTpuZXcgci5BcnJheShlKTpyLkJ1ZmZlcj9yLl9CdWZmZXJfZnJvbShlKTpcInVuZGVmaW5lZFwiPT10eXBlb2YgVWludDhBcnJheT9lOm5ldyBVaW50OEFycmF5KGUpfSxyLkFycmF5PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBVaW50OEFycmF5P1VpbnQ4QXJyYXk6QXJyYXksci5Mb25nPXIuZ2xvYmFsLmRjb2RlSU8mJnIuZ2xvYmFsLmRjb2RlSU8uTG9uZ3x8ci5nbG9iYWwuTG9uZ3x8ci5pbnF1aXJlKFwibG9uZ1wiKSxyLmtleTJSZT0vXnRydWV8ZmFsc2V8MHwxJC8sci5rZXkzMlJlPS9eLT8oPzowfFsxLTldWzAtOV0qKSQvLHIua2V5NjRSZT0vXig/OltcXFxceDAwLVxcXFx4ZmZdezh9fC0/KD86MHxbMS05XVswLTldKikpJC8sci5sb25nVG9IYXNoPWZ1bmN0aW9uKGUpe3JldHVybiBlP3IuTG9uZ0JpdHMuZnJvbShlKS50b0hhc2goKTpyLkxvbmdCaXRzLnplcm9IYXNofSxyLmxvbmdGcm9tSGFzaD1mdW5jdGlvbihlLHQpe3ZhciBuPXIuTG9uZ0JpdHMuZnJvbUhhc2goZSk7cmV0dXJuIHIuTG9uZz9yLkxvbmcuZnJvbUJpdHMobi5sbyxuLmhpLHQpOm4udG9OdW1iZXIoQm9vbGVhbih0KSl9LHIubWVyZ2U9byxyLmxjRmlyc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkrZS5zdWJzdHJpbmcoMSl9LHIubmV3RXJyb3I9aSxyLlByb3RvY29sRXJyb3I9aShcIlByb3RvY29sRXJyb3JcIiksci5vbmVPZkdldHRlcj1mdW5jdGlvbihlKXtmb3IodmFyIHQ9e30sbj0wO248ZS5sZW5ndGg7KytuKXRbZVtuXV09MTtyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIGU9T2JqZWN0LmtleXModGhpcyksbj1lLmxlbmd0aC0xO24+LTE7LS1uKWlmKDE9PT10W2Vbbl1dJiZ2b2lkIDAhPT10aGlzW2Vbbl1dJiZudWxsIT09dGhpc1tlW25dXSlyZXR1cm4gZVtuXX19LHIub25lT2ZTZXR0ZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7KytuKWVbbl0hPT10JiZkZWxldGUgdGhpc1tlW25dXX19LHIudG9KU09OT3B0aW9ucz17bG9uZ3M6U3RyaW5nLGVudW1zOlN0cmluZyxieXRlczpTdHJpbmcsanNvbjohMH0sci5fY29uZmlndXJlPWZ1bmN0aW9uKCl7dmFyIGU9ci5CdWZmZXI7ZT8oci5fQnVmZmVyX2Zyb209ZS5mcm9tIT09VWludDhBcnJheS5mcm9tJiZlLmZyb218fGZ1bmN0aW9uKHQsbil7cmV0dXJuIG5ldyBlKHQsbil9LHIuX0J1ZmZlcl9hbGxvY1Vuc2FmZT1lLmFsbG9jVW5zYWZlfHxmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9KTpyLl9CdWZmZXJfZnJvbT1yLl9CdWZmZXJfYWxsb2NVbnNhZmU9bnVsbH19LDExNzM6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1wO3ZhciByLG89big5NjkzKSxpPW8uTG9uZ0JpdHMsYT1vLmJhc2U2NCxzPW8udXRmODtmdW5jdGlvbiB1KGUsdCxuKXt0aGlzLmZuPWUsdGhpcy5sZW49dCx0aGlzLm5leHQ9dm9pZCAwLHRoaXMudmFsPW59ZnVuY3Rpb24gbCgpe31mdW5jdGlvbiBjKGUpe3RoaXMuaGVhZD1lLmhlYWQsdGhpcy50YWlsPWUudGFpbCx0aGlzLmxlbj1lLmxlbix0aGlzLm5leHQ9ZS5zdGF0ZXN9ZnVuY3Rpb24gcCgpe3RoaXMubGVuPTAsdGhpcy5oZWFkPW5ldyB1KGwsMCwwKSx0aGlzLnRhaWw9dGhpcy5oZWFkLHRoaXMuc3RhdGVzPW51bGx9dmFyIGQ9ZnVuY3Rpb24oKXtyZXR1cm4gby5CdWZmZXI/ZnVuY3Rpb24oKXtyZXR1cm4ocC5jcmVhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHJ9KSgpfTpmdW5jdGlvbigpe3JldHVybiBuZXcgcH19O2Z1bmN0aW9uIGYoZSx0LG4pe3Rbbl09MjU1JmV9ZnVuY3Rpb24gaChlLHQpe3RoaXMubGVuPWUsdGhpcy5uZXh0PXZvaWQgMCx0aGlzLnZhbD10fWZ1bmN0aW9uIGcoZSx0LG4pe2Zvcig7ZS5oaTspdFtuKytdPTEyNyZlLmxvfDEyOCxlLmxvPShlLmxvPj4+N3xlLmhpPDwyNSk+Pj4wLGUuaGk+Pj49Nztmb3IoO2UubG8+MTI3Oyl0W24rK109MTI3JmUubG98MTI4LGUubG89ZS5sbz4+Pjc7dFtuKytdPWUubG99ZnVuY3Rpb24gbShlLHQsbil7dFtuXT0yNTUmZSx0W24rMV09ZT4+PjgmMjU1LHRbbisyXT1lPj4+MTYmMjU1LHRbbiszXT1lPj4+MjR9cC5jcmVhdGU9ZCgpLHAuYWxsb2M9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBvLkFycmF5KGUpfSxvLkFycmF5IT09QXJyYXkmJihwLmFsbG9jPW8ucG9vbChwLmFsbG9jLG8uQXJyYXkucHJvdG90eXBlLnN1YmFycmF5KSkscC5wcm90b3R5cGUuX3B1c2g9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0aGlzLnRhaWw9dGhpcy50YWlsLm5leHQ9bmV3IHUoZSx0LG4pLHRoaXMubGVuKz10LHRoaXN9LGgucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodS5wcm90b3R5cGUpLGgucHJvdG90eXBlLmZuPWZ1bmN0aW9uKGUsdCxuKXtmb3IoO2U+MTI3Oyl0W24rK109MTI3JmV8MTI4LGU+Pj49Nzt0W25dPWV9LHAucHJvdG90eXBlLnVpbnQzMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5sZW4rPSh0aGlzLnRhaWw9dGhpcy50YWlsLm5leHQ9bmV3IGgoKGU+Pj49MCk8MTI4PzE6ZTwxNjM4ND8yOmU8MjA5NzE1Mj8zOmU8MjY4NDM1NDU2PzQ6NSxlKSkubGVuLHRoaXN9LHAucHJvdG90eXBlLmludDMyPWZ1bmN0aW9uKGUpe3JldHVybiBlPDA/dGhpcy5fcHVzaChnLDEwLGkuZnJvbU51bWJlcihlKSk6dGhpcy51aW50MzIoZSl9LHAucHJvdG90eXBlLnNpbnQzMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy51aW50MzIoKGU8PDFeZT4+MzEpPj4+MCl9LHAucHJvdG90eXBlLnVpbnQ2ND1mdW5jdGlvbihlKXt2YXIgdD1pLmZyb20oZSk7cmV0dXJuIHRoaXMuX3B1c2goZyx0Lmxlbmd0aCgpLHQpfSxwLnByb3RvdHlwZS5pbnQ2ND1wLnByb3RvdHlwZS51aW50NjQscC5wcm90b3R5cGUuc2ludDY0PWZ1bmN0aW9uKGUpe3ZhciB0PWkuZnJvbShlKS56ekVuY29kZSgpO3JldHVybiB0aGlzLl9wdXNoKGcsdC5sZW5ndGgoKSx0KX0scC5wcm90b3R5cGUuYm9vbD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fcHVzaChmLDEsZT8xOjApfSxwLnByb3RvdHlwZS5maXhlZDMyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9wdXNoKG0sNCxlPj4+MCl9LHAucHJvdG90eXBlLnNmaXhlZDMyPXAucHJvdG90eXBlLmZpeGVkMzIscC5wcm90b3R5cGUuZml4ZWQ2ND1mdW5jdGlvbihlKXt2YXIgdD1pLmZyb20oZSk7cmV0dXJuIHRoaXMuX3B1c2gobSw0LHQubG8pLl9wdXNoKG0sNCx0LmhpKX0scC5wcm90b3R5cGUuc2ZpeGVkNjQ9cC5wcm90b3R5cGUuZml4ZWQ2NCxwLnByb3RvdHlwZS5mbG9hdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fcHVzaChvLmZsb2F0LndyaXRlRmxvYXRMRSw0LGUpfSxwLnByb3RvdHlwZS5kb3VibGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX3B1c2goby5mbG9hdC53cml0ZURvdWJsZUxFLDgsZSl9O3ZhciBiPW8uQXJyYXkucHJvdG90eXBlLnNldD9mdW5jdGlvbihlLHQsbil7dC5zZXQoZSxuKX06ZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7KytyKXRbbityXT1lW3JdfTtwLnByb3RvdHlwZS5ieXRlcz1mdW5jdGlvbihlKXt2YXIgdD1lLmxlbmd0aD4+PjA7aWYoIXQpcmV0dXJuIHRoaXMuX3B1c2goZiwxLDApO2lmKG8uaXNTdHJpbmcoZSkpe3ZhciBuPXAuYWxsb2ModD1hLmxlbmd0aChlKSk7YS5kZWNvZGUoZSxuLDApLGU9bn1yZXR1cm4gdGhpcy51aW50MzIodCkuX3B1c2goYix0LGUpfSxwLnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24oZSl7dmFyIHQ9cy5sZW5ndGgoZSk7cmV0dXJuIHQ/dGhpcy51aW50MzIodCkuX3B1c2gocy53cml0ZSx0LGUpOnRoaXMuX3B1c2goZiwxLDApfSxwLnByb3RvdHlwZS5mb3JrPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGVzPW5ldyBjKHRoaXMpLHRoaXMuaGVhZD10aGlzLnRhaWw9bmV3IHUobCwwLDApLHRoaXMubGVuPTAsdGhpc30scC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZXM/KHRoaXMuaGVhZD10aGlzLnN0YXRlcy5oZWFkLHRoaXMudGFpbD10aGlzLnN0YXRlcy50YWlsLHRoaXMubGVuPXRoaXMuc3RhdGVzLmxlbix0aGlzLnN0YXRlcz10aGlzLnN0YXRlcy5uZXh0KToodGhpcy5oZWFkPXRoaXMudGFpbD1uZXcgdShsLDAsMCksdGhpcy5sZW49MCksdGhpc30scC5wcm90b3R5cGUubGRlbGltPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5oZWFkLHQ9dGhpcy50YWlsLG49dGhpcy5sZW47cmV0dXJuIHRoaXMucmVzZXQoKS51aW50MzIobiksbiYmKHRoaXMudGFpbC5uZXh0PWUubmV4dCx0aGlzLnRhaWw9dCx0aGlzLmxlbis9biksdGhpc30scC5wcm90b3R5cGUuZmluaXNoPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMuaGVhZC5uZXh0LHQ9dGhpcy5jb25zdHJ1Y3Rvci5hbGxvYyh0aGlzLmxlbiksbj0wO2U7KWUuZm4oZS52YWwsdCxuKSxuKz1lLmxlbixlPWUubmV4dDtyZXR1cm4gdH0scC5fY29uZmlndXJlPWZ1bmN0aW9uKGUpe3I9ZSxwLmNyZWF0ZT1kKCksci5fY29uZmlndXJlKCl9fSwzMTU1OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9aTt2YXIgcj1uKDExNzMpOyhpLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHIucHJvdG90eXBlKSkuY29uc3RydWN0b3I9aTt2YXIgbz1uKDk2OTMpO2Z1bmN0aW9uIGkoKXtyLmNhbGwodGhpcyl9ZnVuY3Rpb24gYShlLHQsbil7ZS5sZW5ndGg8NDA/by51dGY4LndyaXRlKGUsdCxuKTp0LnV0ZjhXcml0ZT90LnV0ZjhXcml0ZShlLG4pOnQud3JpdGUoZSxuKX1pLl9jb25maWd1cmU9ZnVuY3Rpb24oKXtpLmFsbG9jPW8uX0J1ZmZlcl9hbGxvY1Vuc2FmZSxpLndyaXRlQnl0ZXNCdWZmZXI9by5CdWZmZXImJm8uQnVmZmVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkmJlwic2V0XCI9PT1vLkJ1ZmZlci5wcm90b3R5cGUuc2V0Lm5hbWU/ZnVuY3Rpb24oZSx0LG4pe3Quc2V0KGUsbil9OmZ1bmN0aW9uKGUsdCxuKXtpZihlLmNvcHkpZS5jb3B5KHQsbiwwLGUubGVuZ3RoKTtlbHNlIGZvcih2YXIgcj0wO3I8ZS5sZW5ndGg7KXRbbisrXT1lW3IrK119fSxpLnByb3RvdHlwZS5ieXRlcz1mdW5jdGlvbihlKXtvLmlzU3RyaW5nKGUpJiYoZT1vLl9CdWZmZXJfZnJvbShlLFwiYmFzZTY0XCIpKTt2YXIgdD1lLmxlbmd0aD4+PjA7cmV0dXJuIHRoaXMudWludDMyKHQpLHQmJnRoaXMuX3B1c2goaS53cml0ZUJ5dGVzQnVmZmVyLHQsZSksdGhpc30saS5wcm90b3R5cGUuc3RyaW5nPWZ1bmN0aW9uKGUpe3ZhciB0PW8uQnVmZmVyLmJ5dGVMZW5ndGgoZSk7cmV0dXJuIHRoaXMudWludDMyKHQpLHQmJnRoaXMuX3B1c2goYSx0LGUpLHRoaXN9LGkuX2NvbmZpZ3VyZSgpfSw0MTU0OmU9PntcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9J1widXNlIHN0cmljdFwiO3ZhciBlPXt9LHQ9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO2lmKHQpe3ZhciByPXJlcXVpcmUoXCJ3b3JrZXJfdGhyZWFkc1wiKSxhPXIucGFyZW50UG9ydDthLm9uKFwibWVzc2FnZVwiLChlPT5vbm1lc3NhZ2Uoe2RhdGE6ZX0pKSk7dmFyIG89cmVxdWlyZShcImZzXCIpO09iamVjdC5hc3NpZ24oZ2xvYmFsLHtzZWxmOmdsb2JhbCxyZXF1aXJlOnJlcXVpcmUsTW9kdWxlOmUsbG9jYXRpb246e2hyZWY6X19maWxlbmFtZX0sV29ya2VyOnIuV29ya2VyLGltcG9ydFNjcmlwdHM6ZnVuY3Rpb24oZSl7KDAsZXZhbCkoby5yZWFkRmlsZVN5bmMoZSxcInV0ZjhcIikpfSxwb3N0TWVzc2FnZTpmdW5jdGlvbihlKXthLnBvc3RNZXNzYWdlKGUpfSxwZXJmb3JtYW5jZTpnbG9iYWwucGVyZm9ybWFuY2V8fHtub3c6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX19fSl9dmFyIHM9ITEsbj1bXSxpPWZ1bmN0aW9uKCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTt0P28ud3JpdGVTeW5jKDIsZStcIlxcXFxuXCIpOmNvbnNvbGUuZXJyb3IoZSl9O3NlbGYuYWxlcnQ9ZnVuY3Rpb24oKXt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO3Bvc3RNZXNzYWdlKHtjbWQ6XCJhbGVydFwiLHRleHQ6dCx0aHJlYWRJZDplLl9wdGhyZWFkX3NlbGYoKX0pfSxlLmluc3RhbnRpYXRlV2FzbT0odCxyKT0+e3ZhciBhPW5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShlLndhc21Nb2R1bGUsdCk7cmV0dXJuIHIoYSksZS53YXNtTW9kdWxlPW51bGwsYS5leHBvcnRzfSxzZWxmLm9udW5oYW5kbGVkcmVqZWN0aW9uPWU9Pnt0aHJvdyBlLnJlYXNvbj8/ZX0sc2VsZi5vbm1lc3NhZ2U9dD0+e3RyeXtpZihcImxvYWRcIj09PXQuZGF0YS5jbWQpe2lmKGUud2FzbU1vZHVsZT10LmRhdGEud2FzbU1vZHVsZSxlLndhc21NZW1vcnk9dC5kYXRhLndhc21NZW1vcnksZS5idWZmZXI9ZS53YXNtTWVtb3J5LmJ1ZmZlcixlLkVOVklST05NRU5UX0lTX1BUSFJFQUQ9ITAsXCJzdHJpbmdcIj09dHlwZW9mIHQuZGF0YS51cmxPckJsb2IpaW1wb3J0U2NyaXB0cyh0LmRhdGEudXJsT3JCbG9iKTtlbHNle3ZhciByPVVSTC5jcmVhdGVPYmplY3RVUkwodC5kYXRhLnVybE9yQmxvYik7aW1wb3J0U2NyaXB0cyhyKSxVUkwucmV2b2tlT2JqZWN0VVJMKHIpfW9ydFdhc21UaHJlYWRlZChlKS50aGVuKChmdW5jdGlvbih0KXtlPXR9KSl9ZWxzZSBpZihcInJ1blwiPT09dC5kYXRhLmNtZCl7ZS5fX3BlcmZvcm1hbmNlX25vd19jbG9ja19kcmlmdD1wZXJmb3JtYW5jZS5ub3coKS10LmRhdGEudGltZSxlLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdCh0LmRhdGEucHRocmVhZF9wdHIsMCwwLDEpLGUuZXN0YWJsaXNoU3RhY2tTcGFjZSgpLGUuUFRocmVhZC5yZWNlaXZlT2JqZWN0VHJhbnNmZXIodC5kYXRhKSxlLlBUaHJlYWQudGhyZWFkSW5pdFRMUygpLHN8fChuLmZvckVhY2goKHQ9PntlLmV4ZWN1dGVOb3RpZmllZFByb3h5aW5nUXVldWUodCl9KSksbj1bXSxzPSEwKTt0cnl7ZS5pbnZva2VFbnRyeVBvaW50KHQuZGF0YS5zdGFydF9yb3V0aW5lLHQuZGF0YS5hcmcpfWNhdGNoKHQpe2lmKFwidW53aW5kXCIhPXQpe2lmKCEodCBpbnN0YW5jZW9mIGUuRXhpdFN0YXR1cykpdGhyb3cgdDtlLmtlZXBSdW50aW1lQWxpdmUoKXx8ZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQodC5zdGF0dXMpfX19ZWxzZVwiY2FuY2VsXCI9PT10LmRhdGEuY21kP2UuX3B0aHJlYWRfc2VsZigpJiZlLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdCgtMSk6XCJzZXRpbW1lZGlhdGVcIj09PXQuZGF0YS50YXJnZXR8fChcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCI9PT10LmRhdGEuY21kP3M/ZS5leGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlKHQuZGF0YS5xdWV1ZSk6bi5wdXNoKHQuZGF0YS5xdWV1ZSk6KGkoXCJ3b3JrZXIuanMgcmVjZWl2ZWQgdW5rbm93biBjb21tYW5kIFwiK3QuZGF0YS5jbWQpLGkodC5kYXRhKSkpfWNhdGNoKHQpe3Rocm93IGkoXCJ3b3JrZXIuanMgb25tZXNzYWdlKCkgY2FwdHVyZWQgYW4gdW5jYXVnaHQgZXhjZXB0aW9uOiBcIit0KSx0JiZ0LnN0YWNrJiZpKHQuc3RhY2spLGUuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkJiZlLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZCgpLHR9fTtcXG4nfSw3MDY3OigpPT57fSwxMjk2OigpPT57fSw3NjA6KCk9Pnt9LDEzODQ6KCk9Pnt9LDM5OTM6KCk9Pnt9LDkwODooKT0+e30sNjk1MzooKT0+e30sOTkyNTooKT0+e30sMjgwNjooKT0+e30sNjQ0OTooKT0+e30sMjg1MDooKT0+e30sNTM4MTooKT0+e30sNTY4NjooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7bi5yKHQpLG4uZCh0LHtmbGF0YnVmZmVyczooKT0+cn0pO3ZhciByPXt9O3IuT2Zmc2V0LHIuVGFibGUsci5TSVpFT0ZfU0hPUlQ9MixyLlNJWkVPRl9JTlQ9NCxyLkZJTEVfSURFTlRJRklFUl9MRU5HVEg9NCxyLlNJWkVfUFJFRklYX0xFTkdUSD00LHIuRW5jb2Rpbmc9e1VURjhfQllURVM6MSxVVEYxNl9TVFJJTkc6Mn0sci5pbnQzMj1uZXcgSW50MzJBcnJheSgyKSxyLmZsb2F0MzI9bmV3IEZsb2F0MzJBcnJheShyLmludDMyLmJ1ZmZlciksci5mbG9hdDY0PW5ldyBGbG9hdDY0QXJyYXkoci5pbnQzMi5idWZmZXIpLHIuaXNMaXR0bGVFbmRpYW49MT09PW5ldyBVaW50MTZBcnJheShuZXcgVWludDhBcnJheShbMSwwXSkuYnVmZmVyKVswXSxyLkxvbmc9ZnVuY3Rpb24oZSx0KXt0aGlzLmxvdz0wfGUsdGhpcy5oaWdoPTB8dH0sci5Mb25nLmNyZWF0ZT1mdW5jdGlvbihlLHQpe3JldHVybiAwPT1lJiYwPT10P3IuTG9uZy5aRVJPOm5ldyByLkxvbmcoZSx0KX0sci5Mb25nLnByb3RvdHlwZS50b0Zsb2F0NjQ9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5sb3c+Pj4wKSs0Mjk0OTY3Mjk2KnRoaXMuaGlnaH0sci5Mb25nLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubG93PT1lLmxvdyYmdGhpcy5oaWdoPT1lLmhpZ2h9LHIuTG9uZy5aRVJPPW5ldyByLkxvbmcoMCwwKSxyLkJ1aWxkZXI9ZnVuY3Rpb24oZSl7aWYoZSl0PWU7ZWxzZSB2YXIgdD0xMDI0O3RoaXMuYmI9ci5CeXRlQnVmZmVyLmFsbG9jYXRlKHQpLHRoaXMuc3BhY2U9dCx0aGlzLm1pbmFsaWduPTEsdGhpcy52dGFibGU9bnVsbCx0aGlzLnZ0YWJsZV9pbl91c2U9MCx0aGlzLmlzTmVzdGVkPSExLHRoaXMub2JqZWN0X3N0YXJ0PTAsdGhpcy52dGFibGVzPVtdLHRoaXMudmVjdG9yX251bV9lbGVtcz0wLHRoaXMuZm9yY2VfZGVmYXVsdHM9ITF9LHIuQnVpbGRlci5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLmJiLmNsZWFyKCksdGhpcy5zcGFjZT10aGlzLmJiLmNhcGFjaXR5KCksdGhpcy5taW5hbGlnbj0xLHRoaXMudnRhYmxlPW51bGwsdGhpcy52dGFibGVfaW5fdXNlPTAsdGhpcy5pc05lc3RlZD0hMSx0aGlzLm9iamVjdF9zdGFydD0wLHRoaXMudnRhYmxlcz1bXSx0aGlzLnZlY3Rvcl9udW1fZWxlbXM9MCx0aGlzLmZvcmNlX2RlZmF1bHRzPSExfSxyLkJ1aWxkZXIucHJvdG90eXBlLmZvcmNlRGVmYXVsdHM9ZnVuY3Rpb24oZSl7dGhpcy5mb3JjZV9kZWZhdWx0cz1lfSxyLkJ1aWxkZXIucHJvdG90eXBlLmRhdGFCdWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYn0sci5CdWlsZGVyLnByb3RvdHlwZS5hc1VpbnQ4QXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYi5ieXRlcygpLnN1YmFycmF5KHRoaXMuYmIucG9zaXRpb24oKSx0aGlzLmJiLnBvc2l0aW9uKCkrdGhpcy5vZmZzZXQoKSl9LHIuQnVpbGRlci5wcm90b3R5cGUucHJlcD1mdW5jdGlvbihlLHQpe2U+dGhpcy5taW5hbGlnbiYmKHRoaXMubWluYWxpZ249ZSk7Zm9yKHZhciBuPTErfih0aGlzLmJiLmNhcGFjaXR5KCktdGhpcy5zcGFjZSt0KSZlLTE7dGhpcy5zcGFjZTxuK2UrdDspe3ZhciBvPXRoaXMuYmIuY2FwYWNpdHkoKTt0aGlzLmJiPXIuQnVpbGRlci5ncm93Qnl0ZUJ1ZmZlcih0aGlzLmJiKSx0aGlzLnNwYWNlKz10aGlzLmJiLmNhcGFjaXR5KCktb310aGlzLnBhZChuKX0sci5CdWlsZGVyLnByb3RvdHlwZS5wYWQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTA7dDxlO3QrKyl0aGlzLmJiLndyaXRlSW50OCgtLXRoaXMuc3BhY2UsMCl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uKGUpe3RoaXMuYmIud3JpdGVJbnQ4KHRoaXMuc3BhY2UtPTEsZSl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQxNj1mdW5jdGlvbihlKXt0aGlzLmJiLndyaXRlSW50MTYodGhpcy5zcGFjZS09MixlKX0sci5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDMyPWZ1bmN0aW9uKGUpe3RoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlLT00LGUpfSxyLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlSW50NjQ9ZnVuY3Rpb24oZSl7dGhpcy5iYi53cml0ZUludDY0KHRoaXMuc3BhY2UtPTgsZSl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyPWZ1bmN0aW9uKGUpe3RoaXMuYmIud3JpdGVGbG9hdDMyKHRoaXMuc3BhY2UtPTQsZSl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVGbG9hdDY0PWZ1bmN0aW9uKGUpe3RoaXMuYmIud3JpdGVGbG9hdDY0KHRoaXMuc3BhY2UtPTgsZSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50OD1mdW5jdGlvbihlKXt0aGlzLnByZXAoMSwwKSx0aGlzLndyaXRlSW50OChlKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRJbnQxNj1mdW5jdGlvbihlKXt0aGlzLnByZXAoMiwwKSx0aGlzLndyaXRlSW50MTYoZSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50MzI9ZnVuY3Rpb24oZSl7dGhpcy5wcmVwKDQsMCksdGhpcy53cml0ZUludDMyKGUpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDY0PWZ1bmN0aW9uKGUpe3RoaXMucHJlcCg4LDApLHRoaXMud3JpdGVJbnQ2NChlKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGbG9hdDMyPWZ1bmN0aW9uKGUpe3RoaXMucHJlcCg0LDApLHRoaXMud3JpdGVGbG9hdDMyKGUpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZsb2F0NjQ9ZnVuY3Rpb24oZSl7dGhpcy5wcmVwKDgsMCksdGhpcy53cml0ZUZsb2F0NjQoZSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQ4PWZ1bmN0aW9uKGUsdCxuKXsodGhpcy5mb3JjZV9kZWZhdWx0c3x8dCE9bikmJih0aGlzLmFkZEludDgodCksdGhpcy5zbG90KGUpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDE2PWZ1bmN0aW9uKGUsdCxuKXsodGhpcy5mb3JjZV9kZWZhdWx0c3x8dCE9bikmJih0aGlzLmFkZEludDE2KHQpLHRoaXMuc2xvdChlKSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQzMj1mdW5jdGlvbihlLHQsbil7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fHQhPW4pJiYodGhpcy5hZGRJbnQzMih0KSx0aGlzLnNsb3QoZSkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkSW50NjQ9ZnVuY3Rpb24oZSx0LG4peyF0aGlzLmZvcmNlX2RlZmF1bHRzJiZ0LmVxdWFscyhuKXx8KHRoaXMuYWRkSW50NjQodCksdGhpcy5zbG90KGUpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEZsb2F0MzI9ZnVuY3Rpb24oZSx0LG4peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHx0IT1uKSYmKHRoaXMuYWRkRmxvYXQzMih0KSx0aGlzLnNsb3QoZSkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkRmxvYXQ2ND1mdW5jdGlvbihlLHQsbil7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fHQhPW4pJiYodGhpcy5hZGRGbG9hdDY0KHQpLHRoaXMuc2xvdChlKSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRPZmZzZXQ9ZnVuY3Rpb24oZSx0LG4peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHx0IT1uKSYmKHRoaXMuYWRkT2Zmc2V0KHQpLHRoaXMuc2xvdChlKSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRTdHJ1Y3Q9ZnVuY3Rpb24oZSx0LG4pe3QhPW4mJih0aGlzLm5lc3RlZCh0KSx0aGlzLnNsb3QoZSkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLm5lc3RlZD1mdW5jdGlvbihlKXtpZihlIT10aGlzLm9mZnNldCgpKXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBzdHJ1Y3QgbXVzdCBiZSBzZXJpYWxpemVkIGlubGluZS5cIil9LHIuQnVpbGRlci5wcm90b3R5cGUubm90TmVzdGVkPWZ1bmN0aW9uKCl7aWYodGhpcy5pc05lc3RlZCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogb2JqZWN0IHNlcmlhbGl6YXRpb24gbXVzdCBub3QgYmUgbmVzdGVkLlwiKX0sci5CdWlsZGVyLnByb3RvdHlwZS5zbG90PWZ1bmN0aW9uKGUpe3RoaXMudnRhYmxlW2VdPXRoaXMub2Zmc2V0KCl9LHIuQnVpbGRlci5wcm90b3R5cGUub2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmIuY2FwYWNpdHkoKS10aGlzLnNwYWNlfSxyLkJ1aWxkZXIuZ3Jvd0J5dGVCdWZmZXI9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jYXBhY2l0eSgpO2lmKDMyMjEyMjU0NzImdCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogY2Fubm90IGdyb3cgYnVmZmVyIGJleW9uZCAyIGdpZ2FieXRlcy5cIik7dmFyIG49dDw8MSxvPXIuQnl0ZUJ1ZmZlci5hbGxvY2F0ZShuKTtyZXR1cm4gby5zZXRQb3NpdGlvbihuLXQpLG8uYnl0ZXMoKS5zZXQoZS5ieXRlcygpLG4tdCksb30sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRPZmZzZXQ9ZnVuY3Rpb24oZSl7dGhpcy5wcmVwKHIuU0laRU9GX0lOVCwwKSx0aGlzLndyaXRlSW50MzIodGhpcy5vZmZzZXQoKS1lK3IuU0laRU9GX0lOVCl9LHIuQnVpbGRlci5wcm90b3R5cGUuc3RhcnRPYmplY3Q9ZnVuY3Rpb24oZSl7dGhpcy5ub3ROZXN0ZWQoKSxudWxsPT10aGlzLnZ0YWJsZSYmKHRoaXMudnRhYmxlPVtdKSx0aGlzLnZ0YWJsZV9pbl91c2U9ZTtmb3IodmFyIHQ9MDt0PGU7dCsrKXRoaXMudnRhYmxlW3RdPTA7dGhpcy5pc05lc3RlZD0hMCx0aGlzLm9iamVjdF9zdGFydD10aGlzLm9mZnNldCgpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmVuZE9iamVjdD1mdW5jdGlvbigpe2lmKG51bGw9PXRoaXMudnRhYmxlfHwhdGhpcy5pc05lc3RlZCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogZW5kT2JqZWN0IGNhbGxlZCB3aXRob3V0IHN0YXJ0T2JqZWN0XCIpO3RoaXMuYWRkSW50MzIoMCk7Zm9yKHZhciBlPXRoaXMub2Zmc2V0KCksdD10aGlzLnZ0YWJsZV9pbl91c2UtMTt0Pj0wJiYwPT10aGlzLnZ0YWJsZVt0XTt0LS0pO2Zvcih2YXIgbj10KzE7dD49MDt0LS0pdGhpcy5hZGRJbnQxNigwIT10aGlzLnZ0YWJsZVt0XT9lLXRoaXMudnRhYmxlW3RdOjApO3RoaXMuYWRkSW50MTYoZS10aGlzLm9iamVjdF9zdGFydCk7dmFyIG89KG4rMikqci5TSVpFT0ZfU0hPUlQ7dGhpcy5hZGRJbnQxNihvKTt2YXIgaT0wLGE9dGhpcy5zcGFjZTtlOmZvcih0PTA7dDx0aGlzLnZ0YWJsZXMubGVuZ3RoO3QrKyl7dmFyIHM9dGhpcy5iYi5jYXBhY2l0eSgpLXRoaXMudnRhYmxlc1t0XTtpZihvPT10aGlzLmJiLnJlYWRJbnQxNihzKSl7Zm9yKHZhciB1PXIuU0laRU9GX1NIT1JUO3U8bzt1Kz1yLlNJWkVPRl9TSE9SVClpZih0aGlzLmJiLnJlYWRJbnQxNihhK3UpIT10aGlzLmJiLnJlYWRJbnQxNihzK3UpKWNvbnRpbnVlIGU7aT10aGlzLnZ0YWJsZXNbdF07YnJlYWt9fXJldHVybiBpPyh0aGlzLnNwYWNlPXRoaXMuYmIuY2FwYWNpdHkoKS1lLHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlLGktZSkpOih0aGlzLnZ0YWJsZXMucHVzaCh0aGlzLm9mZnNldCgpKSx0aGlzLmJiLndyaXRlSW50MzIodGhpcy5iYi5jYXBhY2l0eSgpLWUsdGhpcy5vZmZzZXQoKS1lKSksdGhpcy5pc05lc3RlZD0hMSxlfSxyLkJ1aWxkZXIucHJvdG90eXBlLmZpbmlzaD1mdW5jdGlvbihlLHQsbil7dmFyIG89bj9yLlNJWkVfUFJFRklYX0xFTkdUSDowO2lmKHQpe3ZhciBpPXQ7aWYodGhpcy5wcmVwKHRoaXMubWluYWxpZ24sci5TSVpFT0ZfSU5UK3IuRklMRV9JREVOVElGSUVSX0xFTkdUSCtvKSxpLmxlbmd0aCE9ci5GSUxFX0lERU5USUZJRVJfTEVOR1RIKXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBmaWxlIGlkZW50aWZpZXIgbXVzdCBiZSBsZW5ndGggXCIrci5GSUxFX0lERU5USUZJRVJfTEVOR1RIKTtmb3IodmFyIGE9ci5GSUxFX0lERU5USUZJRVJfTEVOR1RILTE7YT49MDthLS0pdGhpcy53cml0ZUludDgoaS5jaGFyQ29kZUF0KGEpKX10aGlzLnByZXAodGhpcy5taW5hbGlnbixyLlNJWkVPRl9JTlQrbyksdGhpcy5hZGRPZmZzZXQoZSksbyYmdGhpcy5hZGRJbnQzMih0aGlzLmJiLmNhcGFjaXR5KCktdGhpcy5zcGFjZSksdGhpcy5iYi5zZXRQb3NpdGlvbih0aGlzLnNwYWNlKX0sci5CdWlsZGVyLnByb3RvdHlwZS5maW5pc2hTaXplUHJlZml4ZWQ9ZnVuY3Rpb24oZSx0KXt0aGlzLmZpbmlzaChlLHQsITApfSxyLkJ1aWxkZXIucHJvdG90eXBlLnJlcXVpcmVkRmllbGQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLmJiLmNhcGFjaXR5KCktZSxyPW4tdGhpcy5iYi5yZWFkSW50MzIobik7aWYoMD09dGhpcy5iYi5yZWFkSW50MTYocit0KSl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogZmllbGQgXCIrdCtcIiBtdXN0IGJlIHNldFwiKX0sci5CdWlsZGVyLnByb3RvdHlwZS5zdGFydFZlY3Rvcj1mdW5jdGlvbihlLHQsbil7dGhpcy5ub3ROZXN0ZWQoKSx0aGlzLnZlY3Rvcl9udW1fZWxlbXM9dCx0aGlzLnByZXAoci5TSVpFT0ZfSU5ULGUqdCksdGhpcy5wcmVwKG4sZSp0KX0sci5CdWlsZGVyLnByb3RvdHlwZS5lbmRWZWN0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53cml0ZUludDMyKHRoaXMudmVjdG9yX251bV9lbGVtcyksdGhpcy5vZmZzZXQoKX0sci5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVTdHJpbmc9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpdmFyIHQ9ZTtlbHNle3Q9W107Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDspe3ZhciByLG89ZS5jaGFyQ29kZUF0KG4rKyk7KHI9bzw1NTI5Nnx8bz49NTYzMjA/bzoobzw8MTApK2UuY2hhckNvZGVBdChuKyspKy01NjYxMzg4OCk8MTI4P3QucHVzaChyKToocjwyMDQ4P3QucHVzaChyPj42JjMxfDE5Mik6KHI8NjU1MzY/dC5wdXNoKHI+PjEyJjE1fDIyNCk6dC5wdXNoKHI+PjE4Jjd8MjQwLHI+PjEyJjYzfDEyOCksdC5wdXNoKHI+PjYmNjN8MTI4KSksdC5wdXNoKDYzJnJ8MTI4KSl9fXRoaXMuYWRkSW50OCgwKSx0aGlzLnN0YXJ0VmVjdG9yKDEsdC5sZW5ndGgsMSksdGhpcy5iYi5zZXRQb3NpdGlvbih0aGlzLnNwYWNlLT10Lmxlbmd0aCksbj0wO2Zvcih2YXIgaT10aGlzLnNwYWNlLGE9dGhpcy5iYi5ieXRlcygpO248dC5sZW5ndGg7bisrKWFbaSsrXT10W25dO3JldHVybiB0aGlzLmVuZFZlY3RvcigpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmNyZWF0ZUxvbmc9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gci5Mb25nLmNyZWF0ZShlLHQpfSxyLkJ5dGVCdWZmZXI9ZnVuY3Rpb24oZSl7dGhpcy5ieXRlc189ZSx0aGlzLnBvc2l0aW9uXz0wfSxyLkJ5dGVCdWZmZXIuYWxsb2NhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyByLkJ5dGVCdWZmZXIobmV3IFVpbnQ4QXJyYXkoZSkpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5wb3NpdGlvbl89MH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5ieXRlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ5dGVzX30sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5wb3NpdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvc2l0aW9uX30sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbj1mdW5jdGlvbihlKXt0aGlzLnBvc2l0aW9uXz1lfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLmNhcGFjaXR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnl0ZXNfLmxlbmd0aH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZWFkVWludDgoZSk8PDI0Pj4yNH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDg9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYnl0ZXNfW2VdfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZWFkVWludDE2KGUpPDwxNj4+MTZ9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5ieXRlc19bZV18dGhpcy5ieXRlc19bZSsxXTw8OH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYnl0ZXNfW2VdfHRoaXMuYnl0ZXNfW2UrMV08PDh8dGhpcy5ieXRlc19bZSsyXTw8MTZ8dGhpcy5ieXRlc19bZSszXTw8MjR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZWFkSW50MzIoZSk+Pj4wfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ2ND1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHIuTG9uZyh0aGlzLnJlYWRJbnQzMihlKSx0aGlzLnJlYWRJbnQzMihlKzQpKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDY0PWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgci5Mb25nKHRoaXMucmVhZFVpbnQzMihlKSx0aGlzLnJlYWRVaW50MzIoZSs0KSl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0MzI9ZnVuY3Rpb24oZSl7cmV0dXJuIHIuaW50MzJbMF09dGhpcy5yZWFkSW50MzIoZSksci5mbG9hdDMyWzBdfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdDY0PWZ1bmN0aW9uKGUpe3JldHVybiByLmludDMyW3IuaXNMaXR0bGVFbmRpYW4/MDoxXT10aGlzLnJlYWRJbnQzMihlKSxyLmludDMyW3IuaXNMaXR0bGVFbmRpYW4/MTowXT10aGlzLnJlYWRJbnQzMihlKzQpLHIuZmxvYXQ2NFswXX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24oZSx0KXt0aGlzLmJ5dGVzX1tlXT10fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDg9ZnVuY3Rpb24oZSx0KXt0aGlzLmJ5dGVzX1tlXT10fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTY9ZnVuY3Rpb24oZSx0KXt0aGlzLmJ5dGVzX1tlXT10LHRoaXMuYnl0ZXNfW2UrMV09dD4+OH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNj1mdW5jdGlvbihlLHQpe3RoaXMuYnl0ZXNfW2VdPXQsdGhpcy5ieXRlc19bZSsxXT10Pj44fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzI9ZnVuY3Rpb24oZSx0KXt0aGlzLmJ5dGVzX1tlXT10LHRoaXMuYnl0ZXNfW2UrMV09dD4+OCx0aGlzLmJ5dGVzX1tlKzJdPXQ+PjE2LHRoaXMuYnl0ZXNfW2UrM109dD4+MjR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzI9ZnVuY3Rpb24oZSx0KXt0aGlzLmJ5dGVzX1tlXT10LHRoaXMuYnl0ZXNfW2UrMV09dD4+OCx0aGlzLmJ5dGVzX1tlKzJdPXQ+PjE2LHRoaXMuYnl0ZXNfW2UrM109dD4+MjR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ2ND1mdW5jdGlvbihlLHQpe3RoaXMud3JpdGVJbnQzMihlLHQubG93KSx0aGlzLndyaXRlSW50MzIoZSs0LHQuaGlnaCl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50NjQ9ZnVuY3Rpb24oZSx0KXt0aGlzLndyaXRlVWludDMyKGUsdC5sb3cpLHRoaXMud3JpdGVVaW50MzIoZSs0LHQuaGlnaCl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyPWZ1bmN0aW9uKGUsdCl7ci5mbG9hdDMyWzBdPXQsdGhpcy53cml0ZUludDMyKGUsci5pbnQzMlswXSl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdDY0PWZ1bmN0aW9uKGUsdCl7ci5mbG9hdDY0WzBdPXQsdGhpcy53cml0ZUludDMyKGUsci5pbnQzMltyLmlzTGl0dGxlRW5kaWFuPzA6MV0pLHRoaXMud3JpdGVJbnQzMihlKzQsci5pbnQzMltyLmlzTGl0dGxlRW5kaWFuPzE6MF0pfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLmdldEJ1ZmZlcklkZW50aWZpZXI9ZnVuY3Rpb24oKXtpZih0aGlzLmJ5dGVzXy5sZW5ndGg8dGhpcy5wb3NpdGlvbl8rci5TSVpFT0ZfSU5UK3IuRklMRV9JREVOVElGSUVSX0xFTkdUSCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogQnl0ZUJ1ZmZlciBpcyB0b28gc2hvcnQgdG8gY29udGFpbiBhbiBpZGVudGlmaWVyLlwiKTtmb3IodmFyIGU9XCJcIix0PTA7dDxyLkZJTEVfSURFTlRJRklFUl9MRU5HVEg7dCsrKWUrPVN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkSW50OCh0aGlzLnBvc2l0aW9uXytyLlNJWkVPRl9JTlQrdCkpO3JldHVybiBlfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fb2Zmc2V0PWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS10aGlzLnJlYWRJbnQzMihlKTtyZXR1cm4gdDx0aGlzLnJlYWRJbnQxNihuKT90aGlzLnJlYWRJbnQxNihuK3QpOjB9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX191bmlvbj1mdW5jdGlvbihlLHQpe3JldHVybiBlLmJiX3Bvcz10K3RoaXMucmVhZEludDMyKHQpLGUuYmI9dGhpcyxlfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fc3RyaW5nPWZ1bmN0aW9uKGUsdCl7ZSs9dGhpcy5yZWFkSW50MzIoZSk7dmFyIG49dGhpcy5yZWFkSW50MzIoZSksbz1cIlwiLGk9MDtpZihlKz1yLlNJWkVPRl9JTlQsdD09PXIuRW5jb2RpbmcuVVRGOF9CWVRFUylyZXR1cm4gdGhpcy5ieXRlc18uc3ViYXJyYXkoZSxlK24pO2Zvcig7aTxuOyl7dmFyIGEscz10aGlzLnJlYWRVaW50OChlK2krKyk7aWYoczwxOTIpYT1zO2Vsc2V7dmFyIHU9dGhpcy5yZWFkVWludDgoZStpKyspO2lmKHM8MjI0KWE9KDMxJnMpPDw2fDYzJnU7ZWxzZXt2YXIgbD10aGlzLnJlYWRVaW50OChlK2krKyk7YT1zPDI0MD8oMTUmcyk8PDEyfCg2MyZ1KTw8Nnw2MyZsOig3JnMpPDwxOHwoNjMmdSk8PDEyfCg2MyZsKTw8Nnw2MyZ0aGlzLnJlYWRVaW50OChlK2krKyl9fWE8NjU1MzY/bys9U3RyaW5nLmZyb21DaGFyQ29kZShhKTooYS09NjU1MzYsbys9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NisoYT4+MTApLDU2MzIwKygxMDIzJmEpKSl9cmV0dXJuIG99LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19pbmRpcmVjdD1mdW5jdGlvbihlKXtyZXR1cm4gZSt0aGlzLnJlYWRJbnQzMihlKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3ZlY3Rvcj1mdW5jdGlvbihlKXtyZXR1cm4gZSt0aGlzLnJlYWRJbnQzMihlKStyLlNJWkVPRl9JTlR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX192ZWN0b3JfbGVuPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlYWRJbnQzMihlK3RoaXMucmVhZEludDMyKGUpKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX2hhc19pZGVudGlmaWVyPWZ1bmN0aW9uKGUpe2lmKGUubGVuZ3RoIT1yLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IGZpbGUgaWRlbnRpZmllciBtdXN0IGJlIGxlbmd0aCBcIityLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpO2Zvcih2YXIgdD0wO3Q8ci5GSUxFX0lERU5USUZJRVJfTEVOR1RIO3QrKylpZihlLmNoYXJDb2RlQXQodCkhPXRoaXMucmVhZEludDgodGhpcy5wb3NpdGlvbl8rci5TSVpFT0ZfSU5UK3QpKXJldHVybiExO3JldHVybiEwfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLmNyZWF0ZUxvbmc9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gci5Mb25nLmNyZWF0ZShlLHQpfX19LF9fd2VicGFja19tb2R1bGVfY2FjaGVfXz17fTtmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKGUpe3ZhciB0PV9fd2VicGFja19tb2R1bGVfY2FjaGVfX1tlXTtpZih2b2lkIDAhPT10KXJldHVybiB0LmV4cG9ydHM7dmFyIG49X193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW2VdPXtleHBvcnRzOnt9fTtyZXR1cm4gX193ZWJwYWNrX21vZHVsZXNfX1tlXS5jYWxsKG4uZXhwb3J0cyxuLG4uZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKSxuLmV4cG9ydHN9X193ZWJwYWNrX3JlcXVpcmVfXy5uPWU9Pnt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/KCk9PmUuZGVmYXVsdDooKT0+ZTtyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5kKHQse2E6dH0pLHR9LF9fd2VicGFja19yZXF1aXJlX18uZD0oZSx0KT0+e2Zvcih2YXIgbiBpbiB0KV9fd2VicGFja19yZXF1aXJlX18ubyh0LG4pJiYhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGUsbikmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se2VudW1lcmFibGU6ITAsZ2V0OnRbbl19KX0sX193ZWJwYWNrX3JlcXVpcmVfXy5nPWZ1bmN0aW9uKCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbFRoaXMpcmV0dXJuIGdsb2JhbFRoaXM7dHJ5e3JldHVybiB0aGlzfHxuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfWNhdGNoKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cpcmV0dXJuIHdpbmRvd319KCksX193ZWJwYWNrX3JlcXVpcmVfXy5vPShlLHQpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSxfX3dlYnBhY2tfcmVxdWlyZV9fLnI9ZT0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9O3ZhciBfX3dlYnBhY2tfZXhwb3J0c19fPV9fd2VicGFja19yZXF1aXJlX18oMTA1Nyk7cmV0dXJuIF9fd2VicGFja19leHBvcnRzX199KSgpKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcnQubWluLmpzLm1hcCIsImltcG9ydCB7IGVuY29kZVdBViB9IGZyb20gXCIuL1dhdkVuY29kZXJcIjtcblxuLyoqXG4gKiBDb252ZXJ0IGEgRmxvYXQzMkFycmF5IG9mIGF1ZGlvIHNhbXBsZXMgdG8gYSBXQVYgYXJyYXkgYnVmZmVyXG4gKiBAcGFyYW0gYXVkaW9EYXRhIC0gVGhlIGF1ZGlvIHNhbXBsZXNcbiAqIEByZXR1cm5zIC0gVGhlIGF1ZGlvIGluIFdBViBmb3JtYXQgYXMgYW4gQXJyYXlCdWZmZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb1dhdkJ1ZmZlcihhdWRpb0RhdGE6IEZsb2F0MzJBcnJheSk6IEFycmF5QnVmZmVyIHtcbiAgY29uc3QgYXJyYXlCdWZmZXIgPSBlbmNvZGVXQVYoYXVkaW9EYXRhKTtcbiAgcmV0dXJuIGFycmF5QnVmZmVyO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBGbG9hdDMyQXJyYXkgb2YgYXVkaW8gc2FtcGxlcyB0byBhIFdBViBCbG9iXG4gKiBAcGFyYW0gYXVkaW9EYXRhIC0gVGhlIGF1ZGlvIHNhbXBsZXNcbiAqIEByZXR1cm5zIC0gVGhlIGF1ZGlvIGluIFdBViBmb3JtYXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb1dhdkJsb2IoYXVkaW9EYXRhOiBGbG9hdDMyQXJyYXkpOiBCbG9iIHtcbiAgY29uc3QgYXJyYXlCdWZmZXIgPSBjb252ZXJ0VG9XYXZCdWZmZXIoYXVkaW9EYXRhKTtcbiAgcmV0dXJuIG5ldyBCbG9iKFthcnJheUJ1ZmZlcl0sIHsgdHlwZTogXCJhdWRpby93YXZcIiB9KTtcbn1cbiIsIi8vIE1vc3Qgb2YgdGhlIGNvZGUgaGVyZSBjb21lIGZyb20gcmlja3kwMTIzL3ZhZC13ZWJcbi8vIFdobyBpbiB0dXJuIGNvcGllZCBpdCBmcm9tIGxpbnRvLWFpL1dlYlZvaWNlU0RLXG5cbmV4cG9ydCBmdW5jdGlvbiBtaW5GcmFtZXNGb3JUYXJnZXRNUyhcbiAgdGFyZ2V0RHVyYXRpb246IG51bWJlcixcbiAgZnJhbWVTYW1wbGVzOiBudW1iZXIsXG4gIHNyID0gMTYwMDBcbik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLmNlaWwoKHRhcmdldER1cmF0aW9uICogc3IpIC8gMTAwMCAvIGZyYW1lU2FtcGxlcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUJ1ZmZlclRvQmFzZTY0KGJ1ZmZlcjogQXJyYXlCdWZmZXIpIHtcbiAgdmFyIGJpbmFyeSA9IFwiXCI7XG4gIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gIHZhciBsZW4gPSBieXRlcy5ieXRlTGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gYXMgbnVtYmVyKTtcbiAgfVxuICByZXR1cm4gYnRvYShiaW5hcnkpO1xufVxuXG4vKlxuICBUaGlzIHJlc3Qgb2YgdGhpcyB3YXMgbW9zdGx5IGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9saW50by1haS9XZWJWb2ljZVNES1xuICAqL1xuXG4vLyB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZW5jb2RlIHRoZSBGbG9hdDMyQXJyYXkgYXVkaW8gZGF0YSBwcm9kdWNlZCBmcm9tIGEgTWljVkFEXG4vLyBhcyBhIFdBViBmaWxlIGF1ZGlvIGJ1ZmZlclxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVdBVihcbiAgc2FtcGxlczogRmxvYXQzMkFycmF5LFxuICBmb3JtYXQ6IG51bWJlciA9IDMsXG4gIHNhbXBsZVJhdGU6IG51bWJlciA9IDE2MDAwLFxuICBudW1DaGFubmVsczogbnVtYmVyID0gMSxcbiAgYml0RGVwdGg6IG51bWJlciA9IDMyXG4pIHtcbiAgdmFyIGJ5dGVzUGVyU2FtcGxlID0gYml0RGVwdGggLyA4O1xuICB2YXIgYmxvY2tBbGlnbiA9IG51bUNoYW5uZWxzICogYnl0ZXNQZXJTYW1wbGU7XG4gIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoNDQgKyBzYW1wbGVzLmxlbmd0aCAqIGJ5dGVzUGVyU2FtcGxlKTtcbiAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgLyogUklGRiBpZGVudGlmaWVyICovXG4gIHdyaXRlU3RyaW5nKHZpZXcsIDAsIFwiUklGRlwiKTtcbiAgLyogUklGRiBjaHVuayBsZW5ndGggKi9cbiAgdmlldy5zZXRVaW50MzIoNCwgMzYgKyBzYW1wbGVzLmxlbmd0aCAqIGJ5dGVzUGVyU2FtcGxlLCB0cnVlKTtcbiAgLyogUklGRiB0eXBlICovXG4gIHdyaXRlU3RyaW5nKHZpZXcsIDgsIFwiV0FWRVwiKTtcbiAgLyogZm9ybWF0IGNodW5rIGlkZW50aWZpZXIgKi9cbiAgd3JpdGVTdHJpbmcodmlldywgMTIsIFwiZm10IFwiKTtcbiAgLyogZm9ybWF0IGNodW5rIGxlbmd0aCAqL1xuICB2aWV3LnNldFVpbnQzMigxNiwgMTYsIHRydWUpO1xuICAvKiBzYW1wbGUgZm9ybWF0IChyYXcpICovXG4gIHZpZXcuc2V0VWludDE2KDIwLCBmb3JtYXQsIHRydWUpO1xuICAvKiBjaGFubmVsIGNvdW50ICovXG4gIHZpZXcuc2V0VWludDE2KDIyLCBudW1DaGFubmVscywgdHJ1ZSk7XG4gIC8qIHNhbXBsZSByYXRlICovXG4gIHZpZXcuc2V0VWludDMyKDI0LCBzYW1wbGVSYXRlLCB0cnVlKTtcbiAgLyogYnl0ZSByYXRlIChzYW1wbGUgcmF0ZSAqIGJsb2NrIGFsaWduKSAqL1xuICB2aWV3LnNldFVpbnQzMigyOCwgc2FtcGxlUmF0ZSAqIGJsb2NrQWxpZ24sIHRydWUpO1xuICAvKiBibG9jayBhbGlnbiAoY2hhbm5lbCBjb3VudCAqIGJ5dGVzIHBlciBzYW1wbGUpICovXG4gIHZpZXcuc2V0VWludDE2KDMyLCBibG9ja0FsaWduLCB0cnVlKTtcbiAgLyogYml0cyBwZXIgc2FtcGxlICovXG4gIHZpZXcuc2V0VWludDE2KDM0LCBiaXREZXB0aCwgdHJ1ZSk7XG4gIC8qIGRhdGEgY2h1bmsgaWRlbnRpZmllciAqL1xuICB3cml0ZVN0cmluZyh2aWV3LCAzNiwgXCJkYXRhXCIpO1xuICAvKiBkYXRhIGNodW5rIGxlbmd0aCAqL1xuICB2aWV3LnNldFVpbnQzMig0MCwgc2FtcGxlcy5sZW5ndGggKiBieXRlc1BlclNhbXBsZSwgdHJ1ZSk7XG4gIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAvLyBSYXcgUENNXG4gICAgZmxvYXRUbzE2Qml0UENNKHZpZXcsIDQ0LCBzYW1wbGVzKTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZUZsb2F0MzIodmlldywgNDQsIHNhbXBsZXMpO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGludGVybGVhdmUoaW5wdXRMOiBGbG9hdDMyQXJyYXksIGlucHV0UjogRmxvYXQzMkFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBpbnB1dEwubGVuZ3RoICsgaW5wdXRSLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkobGVuZ3RoKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGlucHV0SW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXgrK10gPSBpbnB1dExbaW5wdXRJbmRleF0gYXMgbnVtYmVyO1xuICAgIHJlc3VsdFtpbmRleCsrXSA9IGlucHV0UltpbnB1dEluZGV4XSBhcyBudW1iZXI7XG4gICAgaW5wdXRJbmRleCsrO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQzMihvdXRwdXQ6IERhdGFWaWV3LCBvZmZzZXQ6IG51bWJlciwgaW5wdXQ6IEZsb2F0MzJBcnJheSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgIG91dHB1dC5zZXRGbG9hdDMyKG9mZnNldCwgaW5wdXRbaV0gYXMgbnVtYmVyLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmbG9hdFRvMTZCaXRQQ00oXG4gIG91dHB1dDogRGF0YVZpZXcsXG4gIG9mZnNldDogbnVtYmVyLFxuICBpbnB1dDogRmxvYXQzMkFycmF5XG4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKywgb2Zmc2V0ICs9IDIpIHtcbiAgICB2YXIgcyA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCBpbnB1dFtpXSBhcyBudW1iZXIpKTtcbiAgICBvdXRwdXQuc2V0SW50MTYob2Zmc2V0LCBzIDwgMCA/IHMgKiAweDgwMDAgOiBzICogMHg3ZmZmLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZVN0cmluZyh2aWV3OiBEYXRhVmlldywgb2Zmc2V0OiBudW1iZXIsIHN0cmluZzogc3RyaW5nKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQgKyBpLCBzdHJpbmcuY2hhckNvZGVBdChpKSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAnLi9fdmlydHVhbC9fdHNsaWIuanMnO1xuaW1wb3J0IHsgc3ltYm9sT2JzZXJ2YWJsZSwgdG9JbnZva2VTb3VyY2UsIG1hcENvbnRleHQsIGlzTWFjaGluZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgcHJvdmlkZSB9IGZyb20gJy4vc2VydmljZVNjb3BlLmpzJztcblxuZnVuY3Rpb24gY3JlYXRlTnVsbEFjdG9yKGlkKSB7XG4gIHZhciBfYTtcblxuICByZXR1cm4gX2EgPSB7XG4gICAgaWQ6IGlkLFxuICAgIHNlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfSxcbiAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFNuYXBzaG90OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogaWRcbiAgICAgIH07XG4gICAgfVxuICB9LCBfYVtzeW1ib2xPYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSwgX2E7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIGRlZmVycmVkIGFjdG9yIHRoYXQgaXMgYWJsZSB0byBiZSBpbnZva2VkIGdpdmVuIHRoZSBwcm92aWRlZFxyXG4gKiBpbnZvY2F0aW9uIGluZm9ybWF0aW9uIGluIGl0cyBgLm1ldGFgIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0gaW52b2tlRGVmaW5pdGlvbiBUaGUgbWV0YSBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gaW52b2tlIHRoZSBhY3Rvci5cclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUludm9jYWJsZUFjdG9yKGludm9rZURlZmluaXRpb24sIG1hY2hpbmUsIGNvbnRleHQsIF9ldmVudCkge1xuICB2YXIgX2E7XG5cbiAgdmFyIGludm9rZVNyYyA9IHRvSW52b2tlU291cmNlKGludm9rZURlZmluaXRpb24uc3JjKTtcbiAgdmFyIHNlcnZpY2VDcmVhdG9yID0gKF9hID0gbWFjaGluZSA9PT0gbnVsbCB8fCBtYWNoaW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYWNoaW5lLm9wdGlvbnMuc2VydmljZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtpbnZva2VTcmMudHlwZV07XG4gIHZhciByZXNvbHZlZERhdGEgPSBpbnZva2VEZWZpbml0aW9uLmRhdGEgPyBtYXBDb250ZXh0KGludm9rZURlZmluaXRpb24uZGF0YSwgY29udGV4dCwgX2V2ZW50KSA6IHVuZGVmaW5lZDtcbiAgdmFyIHRlbXBBY3RvciA9IHNlcnZpY2VDcmVhdG9yID8gY3JlYXRlRGVmZXJyZWRBY3RvcihzZXJ2aWNlQ3JlYXRvciwgaW52b2tlRGVmaW5pdGlvbi5pZCwgcmVzb2x2ZWREYXRhKSA6IGNyZWF0ZU51bGxBY3RvcihpbnZva2VEZWZpbml0aW9uLmlkKTsgLy8gQHRzLWlnbm9yZVxuXG4gIHRlbXBBY3Rvci5tZXRhID0gaW52b2tlRGVmaW5pdGlvbjtcbiAgcmV0dXJuIHRlbXBBY3Rvcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkQWN0b3IoZW50aXR5LCBpZCwgZGF0YSkge1xuICB2YXIgdGVtcEFjdG9yID0gY3JlYXRlTnVsbEFjdG9yKGlkKTsgLy8gQHRzLWlnbm9yZVxuXG4gIHRlbXBBY3Rvci5kZWZlcnJlZCA9IHRydWU7XG5cbiAgaWYgKGlzTWFjaGluZShlbnRpdHkpKSB7XG4gICAgLy8gXCJtdXRlXCIgdGhlIGV4aXN0aW5nIHNlcnZpY2Ugc2NvcGUgc28gcG90ZW50aWFsIHNwYXduZWQgYWN0b3JzIHdpdGhpbiB0aGUgYC5pbml0aWFsU3RhdGVgIHN0YXkgZGVmZXJyZWQgaGVyZVxuICAgIHZhciBpbml0aWFsU3RhdGVfMSA9IHRlbXBBY3Rvci5zdGF0ZSA9IHByb3ZpZGUodW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKGRhdGEgPyBlbnRpdHkud2l0aENvbnRleHQoZGF0YSkgOiBlbnRpdHkpLmluaXRpYWxTdGF0ZTtcbiAgICB9KTtcblxuICAgIHRlbXBBY3Rvci5nZXRTbmFwc2hvdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbml0aWFsU3RhdGVfMTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHRlbXBBY3Rvcjtcbn1cbmZ1bmN0aW9uIGlzQWN0b3IoaXRlbSkge1xuICB0cnkge1xuICAgIHJldHVybiB0eXBlb2YgaXRlbS5zZW5kID09PSAnZnVuY3Rpb24nO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc1NwYXduZWRBY3RvcihpdGVtKSB7XG4gIHJldHVybiBpc0FjdG9yKGl0ZW0pICYmICdpZCcgaW4gaXRlbTtcbn0gLy8gVE9ETzogcmVmYWN0b3IgdGhlIHJldHVybiB0eXBlLCB0aGlzIGNvdWxkIGJlIHdyaXR0ZW4gaW4gYSBiZXR0ZXIgd2F5IGJ1dCBpdCdzIGJlc3QgdG8gYXZvaWQgdW5uZWNjZXNzYXJ5IGJyZWFraW5nIGNoYW5nZXMgbm93XG5cbmZ1bmN0aW9uIHRvQWN0b3JSZWYoYWN0b3JSZWZMaWtlKSB7XG4gIHZhciBfYTtcblxuICByZXR1cm4gX19hc3NpZ24oKF9hID0ge1xuICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgaWQ6ICdhbm9ueW1vdXMnLFxuICAgIGdldFNuYXBzaG90OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSwgX2Fbc3ltYm9sT2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sIF9hKSwgYWN0b3JSZWZMaWtlKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRGVmZXJyZWRBY3RvciwgY3JlYXRlSW52b2NhYmxlQWN0b3IsIGNyZWF0ZU51bGxBY3RvciwgaXNBY3RvciwgaXNTcGF3bmVkQWN0b3IsIHRvQWN0b3JSZWYgfTtcbiIsImltcG9ydCB7IFN0YXRlTm9kZSB9IGZyb20gJy4vU3RhdGVOb2RlLmpzJztcbmltcG9ydCB7IElTX1BST0RVQ1RJT04gfSBmcm9tICcuL2Vudmlyb25tZW50LmpzJztcblxudmFyIHdhcm5lZCA9IGZhbHNlO1xuZnVuY3Rpb24gTWFjaGluZShjb25maWcsIG9wdGlvbnMsIGluaXRpYWxDb250ZXh0KSB7XG4gIGlmIChpbml0aWFsQ29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgaW5pdGlhbENvbnRleHQgPSBjb25maWcuY29udGV4dDtcbiAgfVxuXG4gIHJldHVybiBuZXcgU3RhdGVOb2RlKGNvbmZpZywgb3B0aW9ucywgaW5pdGlhbENvbnRleHQpO1xufVxuZnVuY3Rpb24gY3JlYXRlTWFjaGluZShjb25maWcsIG9wdGlvbnMpIHtcbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmICEoJ3ByZWRpY3RhYmxlQWN0aW9uQXJndW1lbnRzJyBpbiBjb25maWcpICYmICF3YXJuZWQpIHtcbiAgICB3YXJuZWQgPSB0cnVlO1xuICAgIGNvbnNvbGUud2FybignSXQgaXMgaGlnaGx5IHJlY29tbWVuZGVkIHRvIHNldCBgcHJlZGljdGFibGVBY3Rpb25Bcmd1bWVudHNgIHRvIGB0cnVlYCB3aGVuIHVzaW5nIGBjcmVhdGVNYWNoaW5lYC4gaHR0cHM6Ly94c3RhdGUuanMub3JnL2RvY3MvZ3VpZGVzL2FjdGlvbnMuaHRtbCcpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTdGF0ZU5vZGUoY29uZmlnLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IHsgTWFjaGluZSwgY3JlYXRlTWFjaGluZSB9O1xuIiwiaW1wb3J0IHsgX19hc3NpZ24sIF9fc3ByZWFkQXJyYXksIF9fcmVhZCwgX19yZXN0IH0gZnJvbSAnLi9fdmlydHVhbC9fdHNsaWIuanMnO1xuaW1wb3J0IHsgRU1QVFlfQUNUSVZJVFlfTUFQIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgaXNTdHJpbmcsIG1hdGNoZXNTdGF0ZSwgd2FybiB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgZ2V0TWV0YSwgbmV4dEV2ZW50cyB9IGZyb20gJy4vc3RhdGVVdGlscy5qcyc7XG5pbXBvcnQgeyBpbml0RXZlbnQgfSBmcm9tICcuL2FjdGlvbnMuanMnO1xuaW1wb3J0IHsgSVNfUFJPRFVDVElPTiB9IGZyb20gJy4vZW52aXJvbm1lbnQuanMnO1xuXG5mdW5jdGlvbiBzdGF0ZVZhbHVlc0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nKGEpIHx8IGlzU3RyaW5nKGIpKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cblxuICB2YXIgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gIHJldHVybiBhS2V5cy5sZW5ndGggPT09IGJLZXlzLmxlbmd0aCAmJiBhS2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHN0YXRlVmFsdWVzRXF1YWwoYVtrZXldLCBiW2tleV0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzU3RhdGVDb25maWcoc3RhdGUpIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZSAhPT0gJ29iamVjdCcgfHwgc3RhdGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gJ3ZhbHVlJyBpbiBzdGF0ZSAmJiAnX2V2ZW50JyBpbiBzdGF0ZTtcbn1cbi8qKlxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGlzU3RhdGVDb25maWcob2JqZWN0KWAgb3IgYHN0YXRlIGluc3RhbmNlb2YgU3RhdGVgIGluc3RlYWQuXHJcbiAqL1xuXG52YXIgaXNTdGF0ZSA9IGlzU3RhdGVDb25maWc7XG5mdW5jdGlvbiBiaW5kQWN0aW9uVG9TdGF0ZShhY3Rpb24sIHN0YXRlKSB7XG4gIHZhciBleGVjID0gYWN0aW9uLmV4ZWM7XG5cbiAgdmFyIGJvdW5kQWN0aW9uID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGFjdGlvbiksIHtcbiAgICBleGVjOiBleGVjICE9PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZXhlYyhzdGF0ZS5jb250ZXh0LCBzdGF0ZS5ldmVudCwge1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICBfZXZlbnQ6IHN0YXRlLl9ldmVudFxuICAgICAgfSk7XG4gICAgfSA6IHVuZGVmaW5lZFxuICB9KTtcblxuICByZXR1cm4gYm91bmRBY3Rpb247XG59XG5cbnZhciBTdGF0ZSA9XG4vKiNfX1BVUkVfXyovXG5cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBTdGF0ZSBpbnN0YW5jZS5cclxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHN0YXRlIHZhbHVlXHJcbiAgICogQHBhcmFtIGNvbnRleHQgVGhlIGV4dGVuZGVkIHN0YXRlXHJcbiAgICogQHBhcmFtIGhpc3RvcnlWYWx1ZSBUaGUgdHJlZSByZXByZXNlbnRpbmcgaGlzdG9yaWNhbCB2YWx1ZXMgb2YgdGhlIHN0YXRlIG5vZGVzXHJcbiAgICogQHBhcmFtIGhpc3RvcnkgVGhlIHByZXZpb3VzIHN0YXRlXHJcbiAgICogQHBhcmFtIGFjdGlvbnMgQW4gYXJyYXkgb2YgYWN0aW9uIG9iamVjdHMgdG8gZXhlY3V0ZSBhcyBzaWRlLWVmZmVjdHNcclxuICAgKiBAcGFyYW0gYWN0aXZpdGllcyBBIG1hcHBpbmcgb2YgYWN0aXZpdGllcyBhbmQgd2hldGhlciB0aGV5IGFyZSBzdGFydGVkIChgdHJ1ZWApIG9yIHN0b3BwZWQgKGBmYWxzZWApLlxyXG4gICAqIEBwYXJhbSBtZXRhXHJcbiAgICogQHBhcmFtIGV2ZW50cyBJbnRlcm5hbCBldmVudCBxdWV1ZS4gU2hvdWxkIGJlIGVtcHR5IHdpdGggcnVuLXRvLWNvbXBsZXRpb24gc2VtYW50aWNzLlxyXG4gICAqIEBwYXJhbSBjb25maWd1cmF0aW9uXHJcbiAgICovXG4gIGZ1bmN0aW9uIFN0YXRlKGNvbmZpZykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX2E7XG5cbiAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICB0aGlzLmFjdGl2aXRpZXMgPSBFTVBUWV9BQ1RJVklUWV9NQVA7XG4gICAgdGhpcy5tZXRhID0ge307XG4gICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICB0aGlzLnZhbHVlID0gY29uZmlnLnZhbHVlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbmZpZy5jb250ZXh0O1xuICAgIHRoaXMuX2V2ZW50ID0gY29uZmlnLl9ldmVudDtcbiAgICB0aGlzLl9zZXNzaW9uaWQgPSBjb25maWcuX3Nlc3Npb25pZDtcbiAgICB0aGlzLmV2ZW50ID0gdGhpcy5fZXZlbnQuZGF0YTtcbiAgICB0aGlzLmhpc3RvcnlWYWx1ZSA9IGNvbmZpZy5oaXN0b3J5VmFsdWU7XG4gICAgdGhpcy5oaXN0b3J5ID0gY29uZmlnLmhpc3Rvcnk7XG4gICAgdGhpcy5hY3Rpb25zID0gY29uZmlnLmFjdGlvbnMgfHwgW107XG4gICAgdGhpcy5hY3Rpdml0aWVzID0gY29uZmlnLmFjdGl2aXRpZXMgfHwgRU1QVFlfQUNUSVZJVFlfTUFQO1xuICAgIHRoaXMubWV0YSA9IGdldE1ldGEoY29uZmlnLmNvbmZpZ3VyYXRpb24pO1xuICAgIHRoaXMuZXZlbnRzID0gY29uZmlnLmV2ZW50cyB8fCBbXTtcbiAgICB0aGlzLm1hdGNoZXMgPSB0aGlzLm1hdGNoZXMuYmluZCh0aGlzKTtcbiAgICB0aGlzLnRvU3RyaW5ncyA9IHRoaXMudG9TdHJpbmdzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlnLmNvbmZpZ3VyYXRpb247XG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IGNvbmZpZy50cmFuc2l0aW9ucztcbiAgICB0aGlzLmNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuICAgIHRoaXMuZG9uZSA9ICEhY29uZmlnLmRvbmU7XG4gICAgdGhpcy50YWdzID0gKF9hID0gQXJyYXkuaXNBcnJheShjb25maWcudGFncykgPyBuZXcgU2V0KGNvbmZpZy50YWdzKSA6IGNvbmZpZy50YWdzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgU2V0KCk7XG4gICAgdGhpcy5tYWNoaW5lID0gY29uZmlnLm1hY2hpbmU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduZXh0RXZlbnRzJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXh0RXZlbnRzKF90aGlzLmNvbmZpZ3VyYXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgU3RhdGUgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBgc3RhdGVWYWx1ZWAgYW5kIGBjb250ZXh0YC5cclxuICAgKiBAcGFyYW0gc3RhdGVWYWx1ZVxyXG4gICAqIEBwYXJhbSBjb250ZXh0XHJcbiAgICovXG5cblxuICBTdGF0ZS5mcm9tID0gZnVuY3Rpb24gKHN0YXRlVmFsdWUsIGNvbnRleHQpIHtcbiAgICBpZiAoc3RhdGVWYWx1ZSBpbnN0YW5jZW9mIFN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGVWYWx1ZS5jb250ZXh0ICE9PSBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdGUoe1xuICAgICAgICAgIHZhbHVlOiBzdGF0ZVZhbHVlLnZhbHVlLFxuICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgX2V2ZW50OiBzdGF0ZVZhbHVlLl9ldmVudCxcbiAgICAgICAgICBfc2Vzc2lvbmlkOiBudWxsLFxuICAgICAgICAgIGhpc3RvcnlWYWx1ZTogc3RhdGVWYWx1ZS5oaXN0b3J5VmFsdWUsXG4gICAgICAgICAgaGlzdG9yeTogc3RhdGVWYWx1ZS5oaXN0b3J5LFxuICAgICAgICAgIGFjdGlvbnM6IFtdLFxuICAgICAgICAgIGFjdGl2aXRpZXM6IHN0YXRlVmFsdWUuYWN0aXZpdGllcyxcbiAgICAgICAgICBtZXRhOiB7fSxcbiAgICAgICAgICBldmVudHM6IFtdLFxuICAgICAgICAgIGNvbmZpZ3VyYXRpb246IFtdLFxuICAgICAgICAgIHRyYW5zaXRpb25zOiBbXSxcbiAgICAgICAgICBjaGlsZHJlbjoge31cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGF0ZVZhbHVlO1xuICAgIH1cblxuICAgIHZhciBfZXZlbnQgPSBpbml0RXZlbnQ7XG4gICAgcmV0dXJuIG5ldyBTdGF0ZSh7XG4gICAgICB2YWx1ZTogc3RhdGVWYWx1ZSxcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfZXZlbnQ6IF9ldmVudCxcbiAgICAgIF9zZXNzaW9uaWQ6IG51bGwsXG4gICAgICBoaXN0b3J5VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGhpc3Rvcnk6IHVuZGVmaW5lZCxcbiAgICAgIGFjdGlvbnM6IFtdLFxuICAgICAgYWN0aXZpdGllczogdW5kZWZpbmVkLFxuICAgICAgbWV0YTogdW5kZWZpbmVkLFxuICAgICAgZXZlbnRzOiBbXSxcbiAgICAgIGNvbmZpZ3VyYXRpb246IFtdLFxuICAgICAgdHJhbnNpdGlvbnM6IFtdLFxuICAgICAgY2hpbGRyZW46IHt9XG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgU3RhdGUgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBgY29uZmlnYC5cclxuICAgKiBAcGFyYW0gY29uZmlnIFRoZSBzdGF0ZSBjb25maWdcclxuICAgKi9cblxuXG4gIFN0YXRlLmNyZWF0ZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICByZXR1cm4gbmV3IFN0YXRlKGNvbmZpZyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBuZXcgYFN0YXRlYCBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIGBzdGF0ZVZhbHVlYCBhbmQgYGNvbnRleHRgIHdpdGggbm8gYWN0aW9ucyAoc2lkZS1lZmZlY3RzKS5cclxuICAgKiBAcGFyYW0gc3RhdGVWYWx1ZVxyXG4gICAqIEBwYXJhbSBjb250ZXh0XHJcbiAgICovXG5cblxuICBTdGF0ZS5pbmVydCA9IGZ1bmN0aW9uIChzdGF0ZVZhbHVlLCBjb250ZXh0KSB7XG4gICAgaWYgKHN0YXRlVmFsdWUgaW5zdGFuY2VvZiBTdGF0ZSkge1xuICAgICAgaWYgKCFzdGF0ZVZhbHVlLmFjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZVZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2V2ZW50ID0gaW5pdEV2ZW50O1xuICAgICAgcmV0dXJuIG5ldyBTdGF0ZSh7XG4gICAgICAgIHZhbHVlOiBzdGF0ZVZhbHVlLnZhbHVlLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICBfZXZlbnQ6IF9ldmVudCxcbiAgICAgICAgX3Nlc3Npb25pZDogbnVsbCxcbiAgICAgICAgaGlzdG9yeVZhbHVlOiBzdGF0ZVZhbHVlLmhpc3RvcnlWYWx1ZSxcbiAgICAgICAgaGlzdG9yeTogc3RhdGVWYWx1ZS5oaXN0b3J5LFxuICAgICAgICBhY3Rpdml0aWVzOiBzdGF0ZVZhbHVlLmFjdGl2aXRpZXMsXG4gICAgICAgIGNvbmZpZ3VyYXRpb246IHN0YXRlVmFsdWUuY29uZmlndXJhdGlvbixcbiAgICAgICAgdHJhbnNpdGlvbnM6IFtdLFxuICAgICAgICBjaGlsZHJlbjoge31cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBTdGF0ZS5mcm9tKHN0YXRlVmFsdWUsIGNvbnRleHQpO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgc3RyaW5nIGxlYWYgc3RhdGUgbm9kZSBwYXRocy5cclxuICAgKiBAcGFyYW0gc3RhdGVWYWx1ZVxyXG4gICAqIEBwYXJhbSBkZWxpbWl0ZXIgVGhlIGNoYXJhY3RlcihzKSB0aGF0IHNlcGFyYXRlIGVhY2ggc3VicGF0aCBpbiB0aGUgc3RyaW5nIHN0YXRlIG5vZGUgcGF0aC5cclxuICAgKi9cblxuXG4gIFN0YXRlLnByb3RvdHlwZS50b1N0cmluZ3MgPSBmdW5jdGlvbiAoc3RhdGVWYWx1ZSwgZGVsaW1pdGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChzdGF0ZVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHN0YXRlVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChkZWxpbWl0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgZGVsaW1pdGVyID0gJy4nO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyhzdGF0ZVZhbHVlKSkge1xuICAgICAgcmV0dXJuIFtzdGF0ZVZhbHVlXTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVLZXlzID0gT2JqZWN0LmtleXMoc3RhdGVWYWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlS2V5cy5jb25jYXQuYXBwbHkodmFsdWVLZXlzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQodmFsdWVLZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gX3RoaXMudG9TdHJpbmdzKHN0YXRlVmFsdWVba2V5XSwgZGVsaW1pdGVyKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIGtleSArIGRlbGltaXRlciArIHM7XG4gICAgICB9KTtcbiAgICB9KSksIGZhbHNlKSk7XG4gIH07XG5cbiAgU3RhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EgPSB0aGlzO1xuICAgICAgICBfYS5jb25maWd1cmF0aW9uO1xuICAgICAgICBfYS50cmFuc2l0aW9ucztcbiAgICAgICAgdmFyIHRhZ3MgPSBfYS50YWdzO1xuICAgICAgICBfYS5tYWNoaW5lO1xuICAgICAgICB2YXIganNvblZhbHVlcyA9IF9fcmVzdChfYSwgW1wiY29uZmlndXJhdGlvblwiLCBcInRyYW5zaXRpb25zXCIsIFwidGFnc1wiLCBcIm1hY2hpbmVcIl0pO1xuXG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBqc29uVmFsdWVzKSwge1xuICAgICAgdGFnczogQXJyYXkuZnJvbSh0YWdzKVxuICAgIH0pO1xuICB9O1xuXG4gIFN0YXRlLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKHBhcmVudFN0YXRlVmFsdWUpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0YXRlKHBhcmVudFN0YXRlVmFsdWUsIHRoaXMudmFsdWUpO1xuICB9O1xuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBjdXJyZW50IHN0YXRlIGNvbmZpZ3VyYXRpb24gaGFzIGEgc3RhdGUgbm9kZSB3aXRoIHRoZSBzcGVjaWZpZWQgYHRhZ2AuXHJcbiAgICogQHBhcmFtIHRhZ1xyXG4gICAqL1xuXG5cbiAgU3RhdGUucHJvdG90eXBlLmhhc1RhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmhhcyh0YWcpO1xuICB9O1xuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgc2VuZGluZyB0aGUgYGV2ZW50YCB3aWxsIGNhdXNlIGEgbm9uLWZvcmJpZGRlbiB0cmFuc2l0aW9uXHJcbiAgICogdG8gYmUgc2VsZWN0ZWQsIGV2ZW4gaWYgdGhlIHRyYW5zaXRpb25zIGhhdmUgbm8gYWN0aW9ucyBub3JcclxuICAgKiBjaGFuZ2UgdGhlIHN0YXRlIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byB0ZXN0XHJcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgZXZlbnQgd2lsbCBjYXVzZSBhIHRyYW5zaXRpb25cclxuICAgKi9cblxuXG4gIFN0YXRlLnByb3RvdHlwZS5jYW4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX2E7XG5cbiAgICBpZiAoSVNfUFJPRFVDVElPTikge1xuICAgICAgd2FybighIXRoaXMubWFjaGluZSwgXCJzdGF0ZS5jYW4oLi4uKSB1c2VkIG91dHNpZGUgb2YgYSBtYWNoaW5lLWNyZWF0ZWQgU3RhdGUgb2JqZWN0OyB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZS5cIik7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gKF9hID0gdGhpcy5tYWNoaW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0VHJhbnNpdGlvbkRhdGEodGhpcywgZXZlbnQpO1xuICAgIHJldHVybiAhISh0cmFuc2l0aW9uRGF0YSA9PT0gbnVsbCB8fCB0cmFuc2l0aW9uRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhbnNpdGlvbkRhdGEudHJhbnNpdGlvbnMubGVuZ3RoKSAmJiAvLyBDaGVjayB0aGF0IGF0IGxlYXN0IG9uZSB0cmFuc2l0aW9uIGlzIG5vdCBmb3JiaWRkZW5cbiAgICB0cmFuc2l0aW9uRGF0YS50cmFuc2l0aW9ucy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdC50YXJnZXQgIT09IHVuZGVmaW5lZCB8fCB0LmFjdGlvbnMubGVuZ3RoO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBTdGF0ZTtcbn0oKTtcblxuZXhwb3J0IHsgU3RhdGUsIGJpbmRBY3Rpb25Ub1N0YXRlLCBpc1N0YXRlLCBpc1N0YXRlQ29uZmlnLCBzdGF0ZVZhbHVlc0VxdWFsIH07XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiwgX19zcHJlYWRBcnJheSwgX19yZWFkLCBfX3ZhbHVlcywgX19yZXN0IH0gZnJvbSAnLi9fdmlydHVhbC9fdHNsaWIuanMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiwgbWFwVmFsdWVzLCBpc0FycmF5LCBmbGF0dGVuLCB0b0FycmF5LCB0b1N0YXRlVmFsdWUsIGlzU3RyaW5nLCBnZXRFdmVudFR5cGUsIHRvU0NYTUxFdmVudCwgbWF0Y2hlc1N0YXRlLCBwYXRoLCBldmFsdWF0ZUd1YXJkLCBtYXBDb250ZXh0LCBpc1JhaXNhYmxlQWN0aW9uLCBwYXRoVG9TdGF0ZVZhbHVlLCBpc0J1aWx0SW5FdmVudCwgcGFydGl0aW9uLCB1cGRhdGVIaXN0b3J5VmFsdWUsIHRvU3RhdGVQYXRoLCBtYXBGaWx0ZXJWYWx1ZXMsIHdhcm4sIHRvU3RhdGVQYXRocywgbmVzdGVkUGF0aCwgbm9ybWFsaXplVGFyZ2V0LCB0b0d1YXJkLCB0b1RyYW5zaXRpb25Db25maWdBcnJheSwgaXNNYWNoaW5lLCBjcmVhdGVJbnZva2VJZCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgU3RhdGUsIHN0YXRlVmFsdWVzRXF1YWwgfSBmcm9tICcuL1N0YXRlLmpzJztcbmltcG9ydCB7IHN0YXJ0IGFzIHN0YXJ0JDEsIHN0b3AgYXMgc3RvcCQxLCBpbnZva2UsIHVwZGF0ZSwgbnVsbEV2ZW50IH0gZnJvbSAnLi9hY3Rpb25UeXBlcy5qcyc7XG5pbXBvcnQgeyBkb25lLCBzdGFydCwgdG9BY3Rpb25PYmplY3RzLCByYWlzZSwgc3RvcCwgcmVzb2x2ZUFjdGlvbnMsIGRvbmVJbnZva2UsIGVycm9yLCB0b0FjdGlvbk9iamVjdCwgdG9BY3Rpdml0eURlZmluaXRpb24sIGFmdGVyLCBzZW5kLCBjYW5jZWwsIGluaXRFdmVudCB9IGZyb20gJy4vYWN0aW9ucy5qcyc7XG5pbXBvcnQgeyBJU19QUk9EVUNUSU9OIH0gZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5pbXBvcnQgeyBTVEFURV9ERUxJTUlURVIgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBnZXRBbGxTdGF0ZU5vZGVzLCBnZXRDb25maWd1cmF0aW9uLCBpc0luRmluYWxTdGF0ZSwgZ2V0VGFnc0Zyb21Db25maWd1cmF0aW9uLCBoYXMsIGdldENoaWxkcmVuLCBnZXRWYWx1ZSwgaXNMZWFmTm9kZSwgZ2V0QWxsQ2hpbGRyZW4gfSBmcm9tICcuL3N0YXRlVXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSW52b2NhYmxlQWN0b3IgfSBmcm9tICcuL0FjdG9yLmpzJztcbmltcG9ydCB7IHRvSW52b2tlRGVmaW5pdGlvbiB9IGZyb20gJy4vaW52b2tlVXRpbHMuanMnO1xuXG52YXIgTlVMTF9FVkVOVCA9ICcnO1xudmFyIFNUQVRFX0lERU5USUZJRVIgPSAnIyc7XG52YXIgV0lMRENBUkQgPSAnKic7XG52YXIgRU1QVFlfT0JKRUNUID0ge307XG5cbnZhciBpc1N0YXRlSWQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHJbMF0gPT09IFNUQVRFX0lERU5USUZJRVI7XG59O1xuXG52YXIgY3JlYXRlRGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgYWN0aW9uczoge30sXG4gICAgZ3VhcmRzOiB7fSxcbiAgICBzZXJ2aWNlczoge30sXG4gICAgYWN0aXZpdGllczoge30sXG4gICAgZGVsYXlzOiB7fVxuICB9O1xufTtcblxudmFyIHZhbGlkYXRlQXJyYXlpZmllZFRyYW5zaXRpb25zID0gZnVuY3Rpb24gKHN0YXRlTm9kZSwgZXZlbnQsIHRyYW5zaXRpb25zKSB7XG4gIHZhciBoYXNOb25MYXN0VW5ndWFyZGVkVGFyZ2V0ID0gdHJhbnNpdGlvbnMuc2xpY2UoMCwgLTEpLnNvbWUoZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gISgnY29uZCcgaW4gdHJhbnNpdGlvbikgJiYgISgnaW4nIGluIHRyYW5zaXRpb24pICYmIChpc1N0cmluZyh0cmFuc2l0aW9uLnRhcmdldCkgfHwgaXNNYWNoaW5lKHRyYW5zaXRpb24udGFyZ2V0KSk7XG4gIH0pO1xuICB2YXIgZXZlbnRUZXh0ID0gZXZlbnQgPT09IE5VTExfRVZFTlQgPyAndGhlIHRyYW5zaWVudCBldmVudCcgOiBcImV2ZW50ICdcIi5jb25jYXQoZXZlbnQsIFwiJ1wiKTtcbiAgd2FybighaGFzTm9uTGFzdFVuZ3VhcmRlZFRhcmdldCwgXCJPbmUgb3IgbW9yZSB0cmFuc2l0aW9ucyBmb3IgXCIuY29uY2F0KGV2ZW50VGV4dCwgXCIgb24gc3RhdGUgJ1wiKS5jb25jYXQoc3RhdGVOb2RlLmlkLCBcIicgYXJlIHVucmVhY2hhYmxlLiBcIikgKyBcIk1ha2Ugc3VyZSB0aGF0IHRoZSBkZWZhdWx0IHRyYW5zaXRpb24gaXMgdGhlIGxhc3Qgb25lIGRlZmluZWQuXCIpO1xufTtcblxudmFyIFN0YXRlTm9kZSA9XG4vKiNfX1BVUkVfXyovXG5cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RhdGVOb2RlKFxuICAvKipcclxuICAgKiBUaGUgcmF3IGNvbmZpZyB1c2VkIHRvIGNyZWF0ZSB0aGUgbWFjaGluZS5cclxuICAgKi9cbiAgY29uZmlnLCBvcHRpb25zLFxuICAvKipcclxuICAgKiBUaGUgaW5pdGlhbCBleHRlbmRlZCBzdGF0ZVxyXG4gICAqL1xuICBfY29udGV4dCwgLy8gVE9ETzogdGhpcyBpcyB1bnNhZmUsIGJ1dCB3ZSdyZSByZW1vdmluZyBpdCBpbiB2NSBhbnl3YXlcbiAgX3N0YXRlSW5mbykge1xuICAgIGlmIChfY29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICBfY29udGV4dCA9ICdjb250ZXh0JyBpbiBjb25maWcgPyBjb25maWcuY29udGV4dCA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF9hO1xuXG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5fY29udGV4dCA9IF9jb250ZXh0O1xuICAgIC8qKlxyXG4gICAgICogVGhlIG9yZGVyIHRoaXMgc3RhdGUgbm9kZSBhcHBlYXJzLiBDb3JyZXNwb25kcyB0byB0aGUgaW1wbGljaXQgU0NYTUwgZG9jdW1lbnQgb3JkZXIuXHJcbiAgICAgKi9cblxuICAgIHRoaXMub3JkZXIgPSAtMTtcbiAgICB0aGlzLl9feHN0YXRlbm9kZSA9IHRydWU7XG4gICAgdGhpcy5fX2NhY2hlID0ge1xuICAgICAgZXZlbnRzOiB1bmRlZmluZWQsXG4gICAgICByZWxhdGl2ZVZhbHVlOiBuZXcgTWFwKCksXG4gICAgICBpbml0aWFsU3RhdGVWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgaW5pdGlhbFN0YXRlOiB1bmRlZmluZWQsXG4gICAgICBvbjogdW5kZWZpbmVkLFxuICAgICAgdHJhbnNpdGlvbnM6IHVuZGVmaW5lZCxcbiAgICAgIGNhbmRpZGF0ZXM6IHt9LFxuICAgICAgZGVsYXllZFRyYW5zaXRpb25zOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHRoaXMuaWRNYXAgPSB7fTtcbiAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGNyZWF0ZURlZmF1bHRPcHRpb25zKCksIG9wdGlvbnMpO1xuICAgIHRoaXMucGFyZW50ID0gX3N0YXRlSW5mbyA9PT0gbnVsbCB8fCBfc3RhdGVJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGVJbmZvLnBhcmVudDtcbiAgICB0aGlzLmtleSA9IHRoaXMuY29uZmlnLmtleSB8fCAoX3N0YXRlSW5mbyA9PT0gbnVsbCB8fCBfc3RhdGVJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGVJbmZvLmtleSkgfHwgdGhpcy5jb25maWcuaWQgfHwgJyhtYWNoaW5lKSc7XG4gICAgdGhpcy5tYWNoaW5lID0gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5tYWNoaW5lIDogdGhpcztcbiAgICB0aGlzLnBhdGggPSB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBhdGguY29uY2F0KHRoaXMua2V5KSA6IFtdO1xuICAgIHRoaXMuZGVsaW1pdGVyID0gdGhpcy5jb25maWcuZGVsaW1pdGVyIHx8ICh0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmRlbGltaXRlciA6IFNUQVRFX0RFTElNSVRFUik7XG4gICAgdGhpcy5pZCA9IHRoaXMuY29uZmlnLmlkIHx8IF9fc3ByZWFkQXJyYXkoW3RoaXMubWFjaGluZS5rZXldLCBfX3JlYWQodGhpcy5wYXRoKSwgZmFsc2UpLmpvaW4odGhpcy5kZWxpbWl0ZXIpO1xuICAgIHRoaXMudmVyc2lvbiA9IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQudmVyc2lvbiA6IHRoaXMuY29uZmlnLnZlcnNpb247XG4gICAgdGhpcy50eXBlID0gdGhpcy5jb25maWcudHlwZSB8fCAodGhpcy5jb25maWcucGFyYWxsZWwgPyAncGFyYWxsZWwnIDogdGhpcy5jb25maWcuc3RhdGVzICYmIE9iamVjdC5rZXlzKHRoaXMuY29uZmlnLnN0YXRlcykubGVuZ3RoID8gJ2NvbXBvdW5kJyA6IHRoaXMuY29uZmlnLmhpc3RvcnkgPyAnaGlzdG9yeScgOiAnYXRvbWljJyk7XG4gICAgdGhpcy5zY2hlbWEgPSB0aGlzLnBhcmVudCA/IHRoaXMubWFjaGluZS5zY2hlbWEgOiAoX2EgPSB0aGlzLmNvbmZpZy5zY2hlbWEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSB0aGlzLmNvbmZpZy5kZXNjcmlwdGlvbjtcblxuICAgIGlmICghSVNfUFJPRFVDVElPTikge1xuICAgICAgd2FybighKCdwYXJhbGxlbCcgaW4gdGhpcy5jb25maWcpLCBcIlRoZSBcXFwicGFyYWxsZWxcXFwiIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDQuMS4gXCIuY29uY2F0KHRoaXMuY29uZmlnLnBhcmFsbGVsID8gXCJSZXBsYWNlIHdpdGggYHR5cGU6ICdwYXJhbGxlbCdgXCIgOiBcIlVzZSBgdHlwZTogJ1wiLmNvbmNhdCh0aGlzLnR5cGUsIFwiJ2BcIiksIFwiIGluIHRoZSBjb25maWcgZm9yIHN0YXRlIG5vZGUgJ1wiKS5jb25jYXQodGhpcy5pZCwgXCInIGluc3RlYWQuXCIpKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRpYWwgPSB0aGlzLmNvbmZpZy5pbml0aWFsO1xuICAgIHRoaXMuc3RhdGVzID0gdGhpcy5jb25maWcuc3RhdGVzID8gbWFwVmFsdWVzKHRoaXMuY29uZmlnLnN0YXRlcywgZnVuY3Rpb24gKHN0YXRlQ29uZmlnLCBrZXkpIHtcbiAgICAgIHZhciBfYTtcblxuICAgICAgdmFyIHN0YXRlTm9kZSA9IG5ldyBTdGF0ZU5vZGUoc3RhdGVDb25maWcsIHt9LCB1bmRlZmluZWQsIHtcbiAgICAgICAgcGFyZW50OiBfdGhpcyxcbiAgICAgICAga2V5OiBrZXlcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmFzc2lnbihfdGhpcy5pZE1hcCwgX19hc3NpZ24oKF9hID0ge30sIF9hW3N0YXRlTm9kZS5pZF0gPSBzdGF0ZU5vZGUsIF9hKSwgc3RhdGVOb2RlLmlkTWFwKSk7XG4gICAgICByZXR1cm4gc3RhdGVOb2RlO1xuICAgIH0pIDogRU1QVFlfT0JKRUNUOyAvLyBEb2N1bWVudCBvcmRlclxuXG4gICAgdmFyIG9yZGVyID0gMDtcblxuICAgIGZ1bmN0aW9uIGRmcyhzdGF0ZU5vZGUpIHtcbiAgICAgIHZhciBlXzEsIF9hO1xuXG4gICAgICBzdGF0ZU5vZGUub3JkZXIgPSBvcmRlcisrO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKGdldEFsbENoaWxkcmVuKHN0YXRlTm9kZSkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gX2MudmFsdWU7XG4gICAgICAgICAgZGZzKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgICAgZV8xID0ge1xuICAgICAgICAgIGVycm9yOiBlXzFfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGZzKHRoaXMpOyAvLyBIaXN0b3J5IGNvbmZpZ1xuXG4gICAgdGhpcy5oaXN0b3J5ID0gdGhpcy5jb25maWcuaGlzdG9yeSA9PT0gdHJ1ZSA/ICdzaGFsbG93JyA6IHRoaXMuY29uZmlnLmhpc3RvcnkgfHwgZmFsc2U7XG4gICAgdGhpcy5fdHJhbnNpZW50ID0gISF0aGlzLmNvbmZpZy5hbHdheXMgfHwgKCF0aGlzLmNvbmZpZy5vbiA/IGZhbHNlIDogQXJyYXkuaXNBcnJheSh0aGlzLmNvbmZpZy5vbikgPyB0aGlzLmNvbmZpZy5vbi5zb21lKGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIGV2ZW50ID0gX2EuZXZlbnQ7XG4gICAgICByZXR1cm4gZXZlbnQgPT09IE5VTExfRVZFTlQ7XG4gICAgfSkgOiBOVUxMX0VWRU5UIGluIHRoaXMuY29uZmlnLm9uKTtcbiAgICB0aGlzLnN0cmljdCA9ICEhdGhpcy5jb25maWcuc3RyaWN0OyAvLyBUT0RPOiBkZXByZWNhdGUgKGVudHJ5KVxuXG4gICAgdGhpcy5vbkVudHJ5ID0gdG9BcnJheSh0aGlzLmNvbmZpZy5lbnRyeSB8fCB0aGlzLmNvbmZpZy5vbkVudHJ5KS5tYXAoZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgcmV0dXJuIHRvQWN0aW9uT2JqZWN0KGFjdGlvbik7XG4gICAgfSk7IC8vIFRPRE86IGRlcHJlY2F0ZSAoZXhpdClcblxuICAgIHRoaXMub25FeGl0ID0gdG9BcnJheSh0aGlzLmNvbmZpZy5leGl0IHx8IHRoaXMuY29uZmlnLm9uRXhpdCkubWFwKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIHJldHVybiB0b0FjdGlvbk9iamVjdChhY3Rpb24pO1xuICAgIH0pO1xuICAgIHRoaXMubWV0YSA9IHRoaXMuY29uZmlnLm1ldGE7XG4gICAgdGhpcy5kb25lRGF0YSA9IHRoaXMudHlwZSA9PT0gJ2ZpbmFsJyA/IHRoaXMuY29uZmlnLmRhdGEgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbnZva2UgPSB0b0FycmF5KHRoaXMuY29uZmlnLmludm9rZSkubWFwKGZ1bmN0aW9uIChpbnZva2VDb25maWcsIGkpIHtcbiAgICAgIHZhciBfYSwgX2I7XG5cbiAgICAgIGlmIChpc01hY2hpbmUoaW52b2tlQ29uZmlnKSkge1xuICAgICAgICB2YXIgaW52b2tlSWQgPSBjcmVhdGVJbnZva2VJZChfdGhpcy5pZCwgaSk7XG4gICAgICAgIF90aGlzLm1hY2hpbmUub3B0aW9ucy5zZXJ2aWNlcyA9IF9fYXNzaWduKChfYSA9IHt9LCBfYVtpbnZva2VJZF0gPSBpbnZva2VDb25maWcsIF9hKSwgX3RoaXMubWFjaGluZS5vcHRpb25zLnNlcnZpY2VzKTtcbiAgICAgICAgcmV0dXJuIHRvSW52b2tlRGVmaW5pdGlvbih7XG4gICAgICAgICAgc3JjOiBpbnZva2VJZCxcbiAgICAgICAgICBpZDogaW52b2tlSWRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGludm9rZUNvbmZpZy5zcmMpKSB7XG4gICAgICAgIHZhciBpbnZva2VJZCA9IGludm9rZUNvbmZpZy5pZCB8fCBjcmVhdGVJbnZva2VJZChfdGhpcy5pZCwgaSk7XG4gICAgICAgIHJldHVybiB0b0ludm9rZURlZmluaXRpb24oX19hc3NpZ24oX19hc3NpZ24oe30sIGludm9rZUNvbmZpZyksIHtcbiAgICAgICAgICBpZDogaW52b2tlSWQsXG4gICAgICAgICAgc3JjOiBpbnZva2VDb25maWcuc3JjXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNYWNoaW5lKGludm9rZUNvbmZpZy5zcmMpIHx8IGlzRnVuY3Rpb24oaW52b2tlQ29uZmlnLnNyYykpIHtcbiAgICAgICAgdmFyIGludm9rZUlkID0gaW52b2tlQ29uZmlnLmlkIHx8IGNyZWF0ZUludm9rZUlkKF90aGlzLmlkLCBpKTtcbiAgICAgICAgX3RoaXMubWFjaGluZS5vcHRpb25zLnNlcnZpY2VzID0gX19hc3NpZ24oKF9iID0ge30sIF9iW2ludm9rZUlkXSA9IGludm9rZUNvbmZpZy5zcmMsIF9iKSwgX3RoaXMubWFjaGluZS5vcHRpb25zLnNlcnZpY2VzKTtcbiAgICAgICAgcmV0dXJuIHRvSW52b2tlRGVmaW5pdGlvbihfX2Fzc2lnbihfX2Fzc2lnbih7XG4gICAgICAgICAgaWQ6IGludm9rZUlkXG4gICAgICAgIH0sIGludm9rZUNvbmZpZyksIHtcbiAgICAgICAgICBzcmM6IGludm9rZUlkXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbnZva2VTb3VyY2UgPSBpbnZva2VDb25maWcuc3JjO1xuICAgICAgICByZXR1cm4gdG9JbnZva2VEZWZpbml0aW9uKF9fYXNzaWduKF9fYXNzaWduKHtcbiAgICAgICAgICBpZDogY3JlYXRlSW52b2tlSWQoX3RoaXMuaWQsIGkpXG4gICAgICAgIH0sIGludm9rZUNvbmZpZyksIHtcbiAgICAgICAgICBzcmM6IGludm9rZVNvdXJjZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hY3Rpdml0aWVzID0gdG9BcnJheSh0aGlzLmNvbmZpZy5hY3Rpdml0aWVzKS5jb25jYXQodGhpcy5pbnZva2UpLm1hcChmdW5jdGlvbiAoYWN0aXZpdHkpIHtcbiAgICAgIHJldHVybiB0b0FjdGl2aXR5RGVmaW5pdGlvbihhY3Rpdml0eSk7XG4gICAgfSk7XG4gICAgdGhpcy50cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy50YWdzID0gdG9BcnJheSh0aGlzLmNvbmZpZy50YWdzKTsgLy8gVE9ETzogdGhpcyBpcyB0aGUgcmVhbCBmaXggZm9yIGluaXRpYWxpemF0aW9uIG9uY2VcbiAgICAvLyBzdGF0ZSBub2RlIGdldHRlcnMgYXJlIGRlcHJlY2F0ZWRcbiAgICAvLyBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgLy8gICB0aGlzLl9pbml0KCk7XG4gICAgLy8gfVxuICB9XG5cbiAgU3RhdGVOb2RlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fX2NhY2hlLnRyYW5zaXRpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ2V0QWxsU3RhdGVOb2Rlcyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZU5vZGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZU5vZGUub247XG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIENsb25lcyB0aGlzIHN0YXRlIG1hY2hpbmUgd2l0aCBjdXN0b20gb3B0aW9ucyBhbmQgY29udGV4dC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgKGFjdGlvbnMsIGd1YXJkcywgYWN0aXZpdGllcywgc2VydmljZXMpIHRvIHJlY3Vyc2l2ZWx5IG1lcmdlIHdpdGggdGhlIGV4aXN0aW5nIG9wdGlvbnMuXHJcbiAgICogQHBhcmFtIGNvbnRleHQgQ3VzdG9tIGNvbnRleHQgKHdpbGwgb3ZlcnJpZGUgcHJlZGVmaW5lZCBjb250ZXh0KVxyXG4gICAqL1xuXG5cbiAgU3RhdGVOb2RlLnByb3RvdHlwZS53aXRoQ29uZmlnID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGFjdGlvbnMgPSBfYS5hY3Rpb25zLFxuICAgICAgICBhY3Rpdml0aWVzID0gX2EuYWN0aXZpdGllcyxcbiAgICAgICAgZ3VhcmRzID0gX2EuZ3VhcmRzLFxuICAgICAgICBzZXJ2aWNlcyA9IF9hLnNlcnZpY2VzLFxuICAgICAgICBkZWxheXMgPSBfYS5kZWxheXM7XG4gICAgcmV0dXJuIG5ldyBTdGF0ZU5vZGUodGhpcy5jb25maWcsIHtcbiAgICAgIGFjdGlvbnM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBhY3Rpb25zKSwgb3B0aW9ucy5hY3Rpb25zKSxcbiAgICAgIGFjdGl2aXRpZXM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBhY3Rpdml0aWVzKSwgb3B0aW9ucy5hY3Rpdml0aWVzKSxcbiAgICAgIGd1YXJkczogX19hc3NpZ24oX19hc3NpZ24oe30sIGd1YXJkcyksIG9wdGlvbnMuZ3VhcmRzKSxcbiAgICAgIHNlcnZpY2VzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc2VydmljZXMpLCBvcHRpb25zLnNlcnZpY2VzKSxcbiAgICAgIGRlbGF5czogX19hc3NpZ24oX19hc3NpZ24oe30sIGRlbGF5cyksIG9wdGlvbnMuZGVsYXlzKVxuICAgIH0sIGNvbnRleHQgIT09IG51bGwgJiYgY29udGV4dCAhPT0gdm9pZCAwID8gY29udGV4dCA6IHRoaXMuY29udGV4dCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIENsb25lcyB0aGlzIHN0YXRlIG1hY2hpbmUgd2l0aCBjdXN0b20gY29udGV4dC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBjb250ZXh0IEN1c3RvbSBjb250ZXh0ICh3aWxsIG92ZXJyaWRlIHByZWRlZmluZWQgY29udGV4dCwgbm90IHJlY3Vyc2l2ZSlcclxuICAgKi9cblxuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUud2l0aENvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgU3RhdGVOb2RlKHRoaXMuY29uZmlnLCB0aGlzLm9wdGlvbnMsIGNvbnRleHQpO1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZU5vZGUucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odGhpcy5fY29udGV4dCkgPyB0aGlzLl9jb250ZXh0KCkgOiB0aGlzLl9jb250ZXh0O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVOb2RlLnByb3RvdHlwZSwgXCJkZWZpbml0aW9uXCIsIHtcbiAgICAvKipcclxuICAgICAqIFRoZSB3ZWxsLXN0cnVjdHVyZWQgc3RhdGUgbm9kZSBkZWZpbml0aW9uLlxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxuICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgaW5pdGlhbDogdGhpcy5pbml0aWFsLFxuICAgICAgICBoaXN0b3J5OiB0aGlzLmhpc3RvcnksXG4gICAgICAgIHN0YXRlczogbWFwVmFsdWVzKHRoaXMuc3RhdGVzLCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUuZGVmaW5pdGlvbjtcbiAgICAgICAgfSksXG4gICAgICAgIG9uOiB0aGlzLm9uLFxuICAgICAgICB0cmFuc2l0aW9uczogdGhpcy50cmFuc2l0aW9ucyxcbiAgICAgICAgZW50cnk6IHRoaXMub25FbnRyeSxcbiAgICAgICAgZXhpdDogdGhpcy5vbkV4aXQsXG4gICAgICAgIGFjdGl2aXRpZXM6IHRoaXMuYWN0aXZpdGllcyB8fCBbXSxcbiAgICAgICAgbWV0YTogdGhpcy5tZXRhLFxuICAgICAgICBvcmRlcjogdGhpcy5vcmRlciB8fCAtMSxcbiAgICAgICAgZGF0YTogdGhpcy5kb25lRGF0YSxcbiAgICAgICAgaW52b2tlOiB0aGlzLmludm9rZSxcbiAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICAgIHRhZ3M6IHRoaXMudGFnc1xuICAgICAgfTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uO1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZU5vZGUucHJvdG90eXBlLCBcIm9uXCIsIHtcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXBwaW5nIG9mIGV2ZW50cyB0byB0cmFuc2l0aW9ucy5cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX19jYWNoZS5vbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLm9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJhbnNpdGlvbnMgPSB0aGlzLnRyYW5zaXRpb25zO1xuICAgICAgcmV0dXJuIHRoaXMuX19jYWNoZS5vbiA9IHRyYW5zaXRpb25zLnJlZHVjZShmdW5jdGlvbiAobWFwLCB0cmFuc2l0aW9uKSB7XG4gICAgICAgIG1hcFt0cmFuc2l0aW9uLmV2ZW50VHlwZV0gPSBtYXBbdHJhbnNpdGlvbi5ldmVudFR5cGVdIHx8IFtdO1xuICAgICAgICBtYXBbdHJhbnNpdGlvbi5ldmVudFR5cGVdLnB1c2godHJhbnNpdGlvbik7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9LCB7fSk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZU5vZGUucHJvdG90eXBlLCBcImFmdGVyXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fY2FjaGUuZGVsYXllZFRyYW5zaXRpb25zIHx8ICh0aGlzLl9fY2FjaGUuZGVsYXllZFRyYW5zaXRpb25zID0gdGhpcy5nZXREZWxheWVkVHJhbnNpdGlvbnMoKSwgdGhpcy5fX2NhY2hlLmRlbGF5ZWRUcmFuc2l0aW9ucyk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZU5vZGUucHJvdG90eXBlLCBcInRyYW5zaXRpb25zXCIsIHtcbiAgICAvKipcclxuICAgICAqIEFsbCB0aGUgdHJhbnNpdGlvbnMgdGhhdCBjYW4gYmUgdGFrZW4gZnJvbSB0aGlzIHN0YXRlIG5vZGUuXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fY2FjaGUudHJhbnNpdGlvbnMgfHwgKHRoaXMuX19jYWNoZS50cmFuc2l0aW9ucyA9IHRoaXMuZm9ybWF0VHJhbnNpdGlvbnMoKSwgdGhpcy5fX2NhY2hlLnRyYW5zaXRpb25zKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLmdldENhbmRpZGF0ZXMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgaWYgKHRoaXMuX19jYWNoZS5jYW5kaWRhdGVzW2V2ZW50TmFtZV0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9fY2FjaGUuY2FuZGlkYXRlc1tldmVudE5hbWVdO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2llbnQgPSBldmVudE5hbWUgPT09IE5VTExfRVZFTlQ7XG4gICAgdmFyIGNhbmRpZGF0ZXMgPSB0aGlzLnRyYW5zaXRpb25zLmZpbHRlcihmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICAgICAgdmFyIHNhbWVFdmVudFR5cGUgPSB0cmFuc2l0aW9uLmV2ZW50VHlwZSA9PT0gZXZlbnROYW1lOyAvLyBudWxsIGV2ZW50cyBzaG91bGQgb25seSBtYXRjaCBhZ2FpbnN0IGV2ZW50bGVzcyB0cmFuc2l0aW9uc1xuXG4gICAgICByZXR1cm4gdHJhbnNpZW50ID8gc2FtZUV2ZW50VHlwZSA6IHNhbWVFdmVudFR5cGUgfHwgdHJhbnNpdGlvbi5ldmVudFR5cGUgPT09IFdJTERDQVJEO1xuICAgIH0pO1xuICAgIHRoaXMuX19jYWNoZS5jYW5kaWRhdGVzW2V2ZW50TmFtZV0gPSBjYW5kaWRhdGVzO1xuICAgIHJldHVybiBjYW5kaWRhdGVzO1xuICB9O1xuICAvKipcclxuICAgKiBBbGwgZGVsYXllZCB0cmFuc2l0aW9ucyBmcm9tIHRoZSBjb25maWcuXHJcbiAgICovXG5cblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLmdldERlbGF5ZWRUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGFmdGVyQ29uZmlnID0gdGhpcy5jb25maWcuYWZ0ZXI7XG5cbiAgICBpZiAoIWFmdGVyQ29uZmlnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIG11dGF0ZUVudHJ5RXhpdCA9IGZ1bmN0aW9uIChkZWxheSwgaSkge1xuICAgICAgdmFyIGRlbGF5UmVmID0gaXNGdW5jdGlvbihkZWxheSkgPyBcIlwiLmNvbmNhdChfdGhpcy5pZCwgXCI6ZGVsYXlbXCIpLmNvbmNhdChpLCBcIl1cIikgOiBkZWxheTtcbiAgICAgIHZhciBldmVudFR5cGUgPSBhZnRlcihkZWxheVJlZiwgX3RoaXMuaWQpO1xuXG4gICAgICBfdGhpcy5vbkVudHJ5LnB1c2goc2VuZChldmVudFR5cGUsIHtcbiAgICAgICAgZGVsYXk6IGRlbGF5XG4gICAgICB9KSk7XG5cbiAgICAgIF90aGlzLm9uRXhpdC5wdXNoKGNhbmNlbChldmVudFR5cGUpKTtcblxuICAgICAgcmV0dXJuIGV2ZW50VHlwZTtcbiAgICB9O1xuXG4gICAgdmFyIGRlbGF5ZWRUcmFuc2l0aW9ucyA9IGlzQXJyYXkoYWZ0ZXJDb25maWcpID8gYWZ0ZXJDb25maWcubWFwKGZ1bmN0aW9uICh0cmFuc2l0aW9uLCBpKSB7XG4gICAgICB2YXIgZXZlbnRUeXBlID0gbXV0YXRlRW50cnlFeGl0KHRyYW5zaXRpb24uZGVsYXksIGkpO1xuICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0cmFuc2l0aW9uKSwge1xuICAgICAgICBldmVudDogZXZlbnRUeXBlXG4gICAgICB9KTtcbiAgICB9KSA6IGZsYXR0ZW4oT2JqZWN0LmtleXMoYWZ0ZXJDb25maWcpLm1hcChmdW5jdGlvbiAoZGVsYXksIGkpIHtcbiAgICAgIHZhciBjb25maWdUcmFuc2l0aW9uID0gYWZ0ZXJDb25maWdbZGVsYXldO1xuICAgICAgdmFyIHJlc29sdmVkVHJhbnNpdGlvbiA9IGlzU3RyaW5nKGNvbmZpZ1RyYW5zaXRpb24pID8ge1xuICAgICAgICB0YXJnZXQ6IGNvbmZpZ1RyYW5zaXRpb25cbiAgICAgIH0gOiBjb25maWdUcmFuc2l0aW9uO1xuICAgICAgdmFyIHJlc29sdmVkRGVsYXkgPSAhaXNOYU4oK2RlbGF5KSA/ICtkZWxheSA6IGRlbGF5O1xuICAgICAgdmFyIGV2ZW50VHlwZSA9IG11dGF0ZUVudHJ5RXhpdChyZXNvbHZlZERlbGF5LCBpKTtcbiAgICAgIHJldHVybiB0b0FycmF5KHJlc29sdmVkVHJhbnNpdGlvbikubWFwKGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdHJhbnNpdGlvbiksIHtcbiAgICAgICAgICBldmVudDogZXZlbnRUeXBlLFxuICAgICAgICAgIGRlbGF5OiByZXNvbHZlZERlbGF5XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSkpO1xuICAgIHJldHVybiBkZWxheWVkVHJhbnNpdGlvbnMubWFwKGZ1bmN0aW9uIChkZWxheWVkVHJhbnNpdGlvbikge1xuICAgICAgdmFyIGRlbGF5ID0gZGVsYXllZFRyYW5zaXRpb24uZGVsYXk7XG4gICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIF90aGlzLmZvcm1hdFRyYW5zaXRpb24oZGVsYXllZFRyYW5zaXRpb24pKSwge1xuICAgICAgICBkZWxheTogZGVsYXlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSBub2RlcyByZXByZXNlbnRlZCBieSB0aGUgY3VycmVudCBzdGF0ZSB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdmFsdWUgb3IgU3RhdGUgaW5zdGFuY2VcclxuICAgKi9cblxuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuZ2V0U3RhdGVOb2RlcyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIXN0YXRlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlVmFsdWUgPSBzdGF0ZSBpbnN0YW5jZW9mIFN0YXRlID8gc3RhdGUudmFsdWUgOiB0b1N0YXRlVmFsdWUoc3RhdGUsIHRoaXMuZGVsaW1pdGVyKTtcblxuICAgIGlmIChpc1N0cmluZyhzdGF0ZVZhbHVlKSkge1xuICAgICAgdmFyIGluaXRpYWxTdGF0ZVZhbHVlID0gdGhpcy5nZXRTdGF0ZU5vZGUoc3RhdGVWYWx1ZSkuaW5pdGlhbDtcbiAgICAgIHJldHVybiBpbml0aWFsU3RhdGVWYWx1ZSAhPT0gdW5kZWZpbmVkID8gdGhpcy5nZXRTdGF0ZU5vZGVzKChfYSA9IHt9LCBfYVtzdGF0ZVZhbHVlXSA9IGluaXRpYWxTdGF0ZVZhbHVlLCBfYSkpIDogW3RoaXMsIHRoaXMuc3RhdGVzW3N0YXRlVmFsdWVdXTtcbiAgICB9XG5cbiAgICB2YXIgc3ViU3RhdGVLZXlzID0gT2JqZWN0LmtleXMoc3RhdGVWYWx1ZSk7XG4gICAgdmFyIHN1YlN0YXRlTm9kZXMgPSBbdGhpc107XG4gICAgc3ViU3RhdGVOb2Rlcy5wdXNoLmFwcGx5KHN1YlN0YXRlTm9kZXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChmbGF0dGVuKHN1YlN0YXRlS2V5cy5tYXAoZnVuY3Rpb24gKHN1YlN0YXRlS2V5KSB7XG4gICAgICByZXR1cm4gX3RoaXMuZ2V0U3RhdGVOb2RlKHN1YlN0YXRlS2V5KS5nZXRTdGF0ZU5vZGVzKHN0YXRlVmFsdWVbc3ViU3RhdGVLZXldKTtcbiAgICB9KSkpLCBmYWxzZSkpO1xuICAgIHJldHVybiBzdWJTdGF0ZU5vZGVzO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIHN0YXRlIG5vZGUgZXhwbGljaXRseSBoYW5kbGVzIHRoZSBnaXZlbiBldmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgaW4gcXVlc3Rpb25cclxuICAgKi9cblxuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuaGFuZGxlcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBldmVudFR5cGUgPSBnZXRFdmVudFR5cGUoZXZlbnQpO1xuICAgIHJldHVybiB0aGlzLmV2ZW50cy5pbmNsdWRlcyhldmVudFR5cGUpO1xuICB9O1xuICAvKipcclxuICAgKiBSZXNvbHZlcyB0aGUgZ2l2ZW4gYHN0YXRlYCB0byBhIG5ldyBgU3RhdGVgIGluc3RhbmNlIHJlbGF0aXZlIHRvIHRoaXMgbWFjaGluZS5cclxuICAgKlxyXG4gICAqIFRoaXMgZW5zdXJlcyB0aGF0IGAuZXZlbnRzYCBhbmQgYC5uZXh0RXZlbnRzYCByZXByZXNlbnQgdGhlIGNvcnJlY3QgdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0byByZXNvbHZlXHJcbiAgICovXG5cblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLnJlc29sdmVTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHZhciBzdGF0ZUZyb21Db25maWcgPSBzdGF0ZSBpbnN0YW5jZW9mIFN0YXRlID8gc3RhdGUgOiBTdGF0ZS5jcmVhdGUoc3RhdGUpO1xuICAgIHZhciBjb25maWd1cmF0aW9uID0gQXJyYXkuZnJvbShnZXRDb25maWd1cmF0aW9uKFtdLCB0aGlzLmdldFN0YXRlTm9kZXMoc3RhdGVGcm9tQ29uZmlnLnZhbHVlKSkpO1xuICAgIHJldHVybiBuZXcgU3RhdGUoX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlRnJvbUNvbmZpZyksIHtcbiAgICAgIHZhbHVlOiB0aGlzLnJlc29sdmUoc3RhdGVGcm9tQ29uZmlnLnZhbHVlKSxcbiAgICAgIGNvbmZpZ3VyYXRpb246IGNvbmZpZ3VyYXRpb24sXG4gICAgICBkb25lOiBpc0luRmluYWxTdGF0ZShjb25maWd1cmF0aW9uLCB0aGlzKSxcbiAgICAgIHRhZ3M6IGdldFRhZ3NGcm9tQ29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKSxcbiAgICAgIG1hY2hpbmU6IHRoaXMubWFjaGluZVxuICAgIH0pKTtcbiAgfTtcblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLnRyYW5zaXRpb25MZWFmTm9kZSA9IGZ1bmN0aW9uIChzdGF0ZVZhbHVlLCBzdGF0ZSwgX2V2ZW50KSB7XG4gICAgdmFyIHN0YXRlTm9kZSA9IHRoaXMuZ2V0U3RhdGVOb2RlKHN0YXRlVmFsdWUpO1xuICAgIHZhciBuZXh0ID0gc3RhdGVOb2RlLm5leHQoc3RhdGUsIF9ldmVudCk7XG5cbiAgICBpZiAoIW5leHQgfHwgIW5leHQudHJhbnNpdGlvbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0KHN0YXRlLCBfZXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0O1xuICB9O1xuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUudHJhbnNpdGlvbkNvbXBvdW5kTm9kZSA9IGZ1bmN0aW9uIChzdGF0ZVZhbHVlLCBzdGF0ZSwgX2V2ZW50KSB7XG4gICAgdmFyIHN1YlN0YXRlS2V5cyA9IE9iamVjdC5rZXlzKHN0YXRlVmFsdWUpO1xuICAgIHZhciBzdGF0ZU5vZGUgPSB0aGlzLmdldFN0YXRlTm9kZShzdWJTdGF0ZUtleXNbMF0pO1xuXG4gICAgdmFyIG5leHQgPSBzdGF0ZU5vZGUuX3RyYW5zaXRpb24oc3RhdGVWYWx1ZVtzdWJTdGF0ZUtleXNbMF1dLCBzdGF0ZSwgX2V2ZW50KTtcblxuICAgIGlmICghbmV4dCB8fCAhbmV4dC50cmFuc2l0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5leHQoc3RhdGUsIF9ldmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH07XG5cbiAgU3RhdGVOb2RlLnByb3RvdHlwZS50cmFuc2l0aW9uUGFyYWxsZWxOb2RlID0gZnVuY3Rpb24gKHN0YXRlVmFsdWUsIHN0YXRlLCBfZXZlbnQpIHtcbiAgICB2YXIgZV8yLCBfYTtcblxuICAgIHZhciB0cmFuc2l0aW9uTWFwID0ge307XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhzdGF0ZVZhbHVlKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIHN1YlN0YXRlS2V5ID0gX2MudmFsdWU7XG4gICAgICAgIHZhciBzdWJTdGF0ZVZhbHVlID0gc3RhdGVWYWx1ZVtzdWJTdGF0ZUtleV07XG5cbiAgICAgICAgaWYgKCFzdWJTdGF0ZVZhbHVlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3ViU3RhdGVOb2RlID0gdGhpcy5nZXRTdGF0ZU5vZGUoc3ViU3RhdGVLZXkpO1xuXG4gICAgICAgIHZhciBuZXh0ID0gc3ViU3RhdGVOb2RlLl90cmFuc2l0aW9uKHN1YlN0YXRlVmFsdWUsIHN0YXRlLCBfZXZlbnQpO1xuXG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgdHJhbnNpdGlvbk1hcFtzdWJTdGF0ZUtleV0gPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZV8yXzEpIHtcbiAgICAgIGVfMiA9IHtcbiAgICAgICAgZXJyb3I6IGVfMl8xXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlVHJhbnNpdGlvbnMgPSBPYmplY3Qua2V5cyh0cmFuc2l0aW9uTWFwKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHRyYW5zaXRpb25NYXBba2V5XTtcbiAgICB9KTtcbiAgICB2YXIgZW5hYmxlZFRyYW5zaXRpb25zID0gZmxhdHRlbihzdGF0ZVRyYW5zaXRpb25zLm1hcChmdW5jdGlvbiAoc3QpIHtcbiAgICAgIHJldHVybiBzdC50cmFuc2l0aW9ucztcbiAgICB9KSk7XG4gICAgdmFyIHdpbGxUcmFuc2l0aW9uID0gc3RhdGVUcmFuc2l0aW9ucy5zb21lKGZ1bmN0aW9uIChzdCkge1xuICAgICAgcmV0dXJuIHN0LnRyYW5zaXRpb25zLmxlbmd0aCA+IDA7XG4gICAgfSk7XG5cbiAgICBpZiAoIXdpbGxUcmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0KHN0YXRlLCBfZXZlbnQpO1xuICAgIH1cblxuICAgIHZhciBjb25maWd1cmF0aW9uID0gZmxhdHRlbihPYmplY3Qua2V5cyh0cmFuc2l0aW9uTWFwKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHRyYW5zaXRpb25NYXBba2V5XS5jb25maWd1cmF0aW9uO1xuICAgIH0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNpdGlvbnM6IGVuYWJsZWRUcmFuc2l0aW9ucyxcbiAgICAgIGV4aXRTZXQ6IGZsYXR0ZW4oc3RhdGVUcmFuc2l0aW9ucy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuZXhpdFNldDtcbiAgICAgIH0pKSxcbiAgICAgIGNvbmZpZ3VyYXRpb246IGNvbmZpZ3VyYXRpb24sXG4gICAgICBzb3VyY2U6IHN0YXRlLFxuICAgICAgYWN0aW9uczogZmxhdHRlbihPYmplY3Qua2V5cyh0cmFuc2l0aW9uTWFwKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdHJhbnNpdGlvbk1hcFtrZXldLmFjdGlvbnM7XG4gICAgICB9KSlcbiAgICB9O1xuICB9O1xuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuX3RyYW5zaXRpb24gPSBmdW5jdGlvbiAoc3RhdGVWYWx1ZSwgc3RhdGUsIF9ldmVudCkge1xuICAgIC8vIGxlYWYgbm9kZVxuICAgIGlmIChpc1N0cmluZyhzdGF0ZVZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbkxlYWZOb2RlKHN0YXRlVmFsdWUsIHN0YXRlLCBfZXZlbnQpO1xuICAgIH0gLy8gaGllcmFyY2hpY2FsIG5vZGVcblxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHN0YXRlVmFsdWUpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbkNvbXBvdW5kTm9kZShzdGF0ZVZhbHVlLCBzdGF0ZSwgX2V2ZW50KTtcbiAgICB9IC8vIG9ydGhvZ29uYWwgbm9kZVxuXG5cbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uUGFyYWxsZWxOb2RlKHN0YXRlVmFsdWUsIHN0YXRlLCBfZXZlbnQpO1xuICB9O1xuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuZ2V0VHJhbnNpdGlvbkRhdGEgPSBmdW5jdGlvbiAoc3RhdGUsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb24oc3RhdGUudmFsdWUsIHN0YXRlLCB0b1NDWE1MRXZlbnQoZXZlbnQpKTtcbiAgfTtcblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoc3RhdGUsIF9ldmVudCkge1xuICAgIHZhciBlXzMsIF9hO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBldmVudE5hbWUgPSBfZXZlbnQubmFtZTtcbiAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgIHZhciBuZXh0U3RhdGVOb2RlcyA9IFtdO1xuICAgIHZhciBzZWxlY3RlZFRyYW5zaXRpb247XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLmdldENhbmRpZGF0ZXMoZXZlbnROYW1lKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IF9jLnZhbHVlO1xuICAgICAgICB2YXIgY29uZCA9IGNhbmRpZGF0ZS5jb25kLFxuICAgICAgICAgICAgc3RhdGVJbiA9IGNhbmRpZGF0ZS5pbjtcbiAgICAgICAgdmFyIHJlc29sdmVkQ29udGV4dCA9IHN0YXRlLmNvbnRleHQ7XG4gICAgICAgIHZhciBpc0luU3RhdGUgPSBzdGF0ZUluID8gaXNTdHJpbmcoc3RhdGVJbikgJiYgaXNTdGF0ZUlkKHN0YXRlSW4pID8gLy8gQ2hlY2sgaWYgaW4gc3RhdGUgYnkgSURcbiAgICAgICAgc3RhdGUubWF0Y2hlcyh0b1N0YXRlVmFsdWUodGhpcy5nZXRTdGF0ZU5vZGVCeUlkKHN0YXRlSW4pLnBhdGgsIHRoaXMuZGVsaW1pdGVyKSkgOiAvLyBDaGVjayBpZiBpbiBzdGF0ZSBieSByZWxhdGl2ZSBncmFuZHBhcmVudFxuICAgICAgICBtYXRjaGVzU3RhdGUodG9TdGF0ZVZhbHVlKHN0YXRlSW4sIHRoaXMuZGVsaW1pdGVyKSwgcGF0aCh0aGlzLnBhdGguc2xpY2UoMCwgLTIpKShzdGF0ZS52YWx1ZSkpIDogdHJ1ZTtcbiAgICAgICAgdmFyIGd1YXJkUGFzc2VkID0gZmFsc2U7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBndWFyZFBhc3NlZCA9ICFjb25kIHx8IGV2YWx1YXRlR3VhcmQodGhpcy5tYWNoaW5lLCBjb25kLCByZXNvbHZlZENvbnRleHQsIF9ldmVudCwgc3RhdGUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZXZhbHVhdGUgZ3VhcmQgJ1wiLmNvbmNhdChjb25kLm5hbWUgfHwgY29uZC50eXBlLCBcIicgaW4gdHJhbnNpdGlvbiBmb3IgZXZlbnQgJ1wiKS5jb25jYXQoZXZlbnROYW1lLCBcIicgaW4gc3RhdGUgbm9kZSAnXCIpLmNvbmNhdCh0aGlzLmlkLCBcIic6XFxuXCIpLmNvbmNhdChlcnIubWVzc2FnZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGd1YXJkUGFzc2VkICYmIGlzSW5TdGF0ZSkge1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUudGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5leHRTdGF0ZU5vZGVzID0gY2FuZGlkYXRlLnRhcmdldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhY3Rpb25zLnB1c2guYXBwbHkoYWN0aW9ucywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGNhbmRpZGF0ZS5hY3Rpb25zKSwgZmFsc2UpKTtcbiAgICAgICAgICBzZWxlY3RlZFRyYW5zaXRpb24gPSBjYW5kaWRhdGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzNfMSkge1xuICAgICAgZV8zID0ge1xuICAgICAgICBlcnJvcjogZV8zXzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNlbGVjdGVkVHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoIW5leHRTdGF0ZU5vZGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhbnNpdGlvbnM6IFtzZWxlY3RlZFRyYW5zaXRpb25dLFxuICAgICAgICBleGl0U2V0OiBbXSxcbiAgICAgICAgY29uZmlndXJhdGlvbjogc3RhdGUudmFsdWUgPyBbdGhpc10gOiBbXSxcbiAgICAgICAgc291cmNlOiBzdGF0ZSxcbiAgICAgICAgYWN0aW9uczogYWN0aW9uc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYWxsTmV4dFN0YXRlTm9kZXMgPSBmbGF0dGVuKG5leHRTdGF0ZU5vZGVzLm1hcChmdW5jdGlvbiAoc3RhdGVOb2RlKSB7XG4gICAgICByZXR1cm4gX3RoaXMuZ2V0UmVsYXRpdmVTdGF0ZU5vZGVzKHN0YXRlTm9kZSwgc3RhdGUuaGlzdG9yeVZhbHVlKTtcbiAgICB9KSk7XG4gICAgdmFyIGlzSW50ZXJuYWwgPSAhIXNlbGVjdGVkVHJhbnNpdGlvbi5pbnRlcm5hbDtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNpdGlvbnM6IFtzZWxlY3RlZFRyYW5zaXRpb25dLFxuICAgICAgZXhpdFNldDogaXNJbnRlcm5hbCA/IFtdIDogZmxhdHRlbihuZXh0U3RhdGVOb2Rlcy5tYXAoZnVuY3Rpb24gKHRhcmdldE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmdldFBvdGVudGlhbGx5UmVlbnRlcmluZ05vZGVzKHRhcmdldE5vZGUpO1xuICAgICAgfSkpLFxuICAgICAgY29uZmlndXJhdGlvbjogYWxsTmV4dFN0YXRlTm9kZXMsXG4gICAgICBzb3VyY2U6IHN0YXRlLFxuICAgICAgYWN0aW9uczogYWN0aW9uc1xuICAgIH07XG4gIH07IC8vIGV2ZW4gdGhvdWdoIHRoZSBuYW1lIG9mIHRoaXMgZnVuY3Rpb24gbWVudGlvbnMgcmVlbnRyeSBub2Rlc1xuICAvLyB3ZSBhcmUgcHVzaGluZyBpdHMgcmVzdWx0IGludG8gYGV4aXRTZXRgXG4gIC8vIHRoYXQncyBiZWNhdXNlIHdoYXQgd2UgZXhpdCBtaWdodCBiZSByZWVudGVyZWQgKGl0J3MgYW4gaW52YXJpYW50IG9mIHJlZW50cmFuY3kpXG5cblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLmdldFBvdGVudGlhbGx5UmVlbnRlcmluZ05vZGVzID0gZnVuY3Rpb24gKHRhcmdldE5vZGUpIHtcbiAgICBpZiAodGhpcy5vcmRlciA8IHRhcmdldE5vZGUub3JkZXIpIHtcbiAgICAgIHJldHVybiBbdGhpc107XG4gICAgfVxuXG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIG1hcmtlciA9IHRoaXM7XG4gICAgdmFyIHBvc3NpYmxlQW5jZXN0b3IgPSB0YXJnZXROb2RlO1xuXG4gICAgd2hpbGUgKG1hcmtlciAmJiBtYXJrZXIgIT09IHBvc3NpYmxlQW5jZXN0b3IpIHtcbiAgICAgIG5vZGVzLnB1c2gobWFya2VyKTtcbiAgICAgIG1hcmtlciA9IG1hcmtlci5wYXJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlciAhPT0gcG9zc2libGVBbmNlc3Rvcikge1xuICAgICAgLy8gd2UgbmV2ZXIgZ290IHRvIGBwb3NzaWJsZUFuY2VzdG9yYCwgdGhlcmVmb3JlIHRoZSBpbml0aWFsIGBtYXJrZXJgIFwiZXNjYXBlc1wiIGl0XG4gICAgICAvLyBpdCdzIGluIGEgZGlmZmVyZW50IHBhcnQgb2YgdGhlIHRyZWUgc28gbm8gc3RhdGVzIHdpbGwgYmUgcmVlbnRlcmVkIGZvciBzdWNoIGFuIGV4dGVybmFsIHRyYW5zaXRpb25cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBub2Rlcy5wdXNoKHBvc3NpYmxlQW5jZXN0b3IpO1xuICAgIHJldHVybiBub2RlcztcbiAgfTtcblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLmdldEFjdGlvbnMgPSBmdW5jdGlvbiAocmVzb2x2ZWRDb25maWcsIGlzRG9uZSwgdHJhbnNpdGlvbiwgY3VycmVudENvbnRleHQsIF9ldmVudCwgcHJldlN0YXRlLCBwcmVkaWN0YWJsZUV4ZWMpIHtcbiAgICB2YXIgZV80LCBfYSwgZV81LCBfYjtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgcHJldkNvbmZpZyA9IHByZXZTdGF0ZSA/IGdldENvbmZpZ3VyYXRpb24oW10sIHRoaXMuZ2V0U3RhdGVOb2RlcyhwcmV2U3RhdGUudmFsdWUpKSA6IFtdO1xuICAgIHZhciBlbnRyeVNldCA9IG5ldyBTZXQoKTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKEFycmF5LmZyb20ocmVzb2x2ZWRDb25maWcpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgICAgfSkpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgIHZhciBzbiA9IF9kLnZhbHVlO1xuXG4gICAgICAgIGlmICghaGFzKHByZXZDb25maWcsIHNuKSB8fCBoYXModHJhbnNpdGlvbi5leGl0U2V0LCBzbikgfHwgc24ucGFyZW50ICYmIGVudHJ5U2V0Lmhhcyhzbi5wYXJlbnQpKSB7XG4gICAgICAgICAgZW50cnlTZXQuYWRkKHNuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfNF8xKSB7XG4gICAgICBlXzQgPSB7XG4gICAgICAgIGVycm9yOiBlXzRfMVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBwcmV2Q29uZmlnXzEgPSBfX3ZhbHVlcyhwcmV2Q29uZmlnKSwgcHJldkNvbmZpZ18xXzEgPSBwcmV2Q29uZmlnXzEubmV4dCgpOyAhcHJldkNvbmZpZ18xXzEuZG9uZTsgcHJldkNvbmZpZ18xXzEgPSBwcmV2Q29uZmlnXzEubmV4dCgpKSB7XG4gICAgICAgIHZhciBzbiA9IHByZXZDb25maWdfMV8xLnZhbHVlO1xuXG4gICAgICAgIGlmICghaGFzKHJlc29sdmVkQ29uZmlnLCBzbikgfHwgaGFzKHRyYW5zaXRpb24uZXhpdFNldCwgc24ucGFyZW50KSkge1xuICAgICAgICAgIHRyYW5zaXRpb24uZXhpdFNldC5wdXNoKHNuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfNV8xKSB7XG4gICAgICBlXzUgPSB7XG4gICAgICAgIGVycm9yOiBlXzVfMVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHByZXZDb25maWdfMV8xICYmICFwcmV2Q29uZmlnXzFfMS5kb25lICYmIChfYiA9IHByZXZDb25maWdfMS5yZXR1cm4pKSBfYi5jYWxsKHByZXZDb25maWdfMSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJhbnNpdGlvbi5leGl0U2V0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBiLm9yZGVyIC0gYS5vcmRlcjtcbiAgICB9KTtcbiAgICB2YXIgZW50cnlTdGF0ZXMgPSBBcnJheS5mcm9tKGVudHJ5U2V0KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gICAgfSk7XG4gICAgdmFyIGV4aXRTdGF0ZXMgPSBuZXcgU2V0KHRyYW5zaXRpb24uZXhpdFNldCk7XG4gICAgdmFyIGRvbmVFdmVudHMgPSBmbGF0dGVuKGVudHJ5U3RhdGVzLm1hcChmdW5jdGlvbiAoc24pIHtcbiAgICAgIHZhciBldmVudHMgPSBbXTtcblxuICAgICAgaWYgKHNuLnR5cGUgIT09ICdmaW5hbCcpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudCA9IHNuLnBhcmVudDtcblxuICAgICAgaWYgKCFwYXJlbnQucGFyZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudHM7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50cy5wdXNoKGRvbmUoc24uaWQsIHNuLmRvbmVEYXRhKSwgLy8gVE9ETzogZGVwcmVjYXRlIC0gZmluYWwgc3RhdGVzIHNob3VsZCBub3QgZW1pdCBkb25lIGV2ZW50cyBmb3IgdGhlaXIgb3duIHN0YXRlLlxuICAgICAgZG9uZShwYXJlbnQuaWQsIHNuLmRvbmVEYXRhID8gbWFwQ29udGV4dChzbi5kb25lRGF0YSwgY3VycmVudENvbnRleHQsIF9ldmVudCkgOiB1bmRlZmluZWQpKTtcbiAgICAgIHZhciBncmFuZHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG5cbiAgICAgIGlmIChncmFuZHBhcmVudC50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgICAgIGlmIChnZXRDaGlsZHJlbihncmFuZHBhcmVudCkuZXZlcnkoZnVuY3Rpb24gKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gaXNJbkZpbmFsU3RhdGUodHJhbnNpdGlvbi5jb25maWd1cmF0aW9uLCBwYXJlbnROb2RlKTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBldmVudHMucHVzaChkb25lKGdyYW5kcGFyZW50LmlkKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICB9KSk7XG4gICAgdmFyIGVudHJ5QWN0aW9ucyA9IGVudHJ5U3RhdGVzLm1hcChmdW5jdGlvbiAoc3RhdGVOb2RlKSB7XG4gICAgICB2YXIgZW50cnlBY3Rpb25zID0gc3RhdGVOb2RlLm9uRW50cnk7XG4gICAgICB2YXIgaW52b2tlQWN0aW9ucyA9IHN0YXRlTm9kZS5hY3Rpdml0aWVzLm1hcChmdW5jdGlvbiAoYWN0aXZpdHkpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0KGFjdGl2aXR5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2VudHJ5JyxcbiAgICAgICAgYWN0aW9uczogdG9BY3Rpb25PYmplY3RzKHByZWRpY3RhYmxlRXhlYyA/IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGVudHJ5QWN0aW9ucyksIGZhbHNlKSwgX19yZWFkKGludm9rZUFjdGlvbnMpLCBmYWxzZSkgOiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChpbnZva2VBY3Rpb25zKSwgZmFsc2UpLCBfX3JlYWQoZW50cnlBY3Rpb25zKSwgZmFsc2UpLCBfdGhpcy5tYWNoaW5lLm9wdGlvbnMuYWN0aW9ucylcbiAgICAgIH07XG4gICAgfSkuY29uY2F0KHtcbiAgICAgIHR5cGU6ICdzdGF0ZV9kb25lJyxcbiAgICAgIGFjdGlvbnM6IGRvbmVFdmVudHMubWFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gcmFpc2UoZXZlbnQpO1xuICAgICAgfSlcbiAgICB9KTtcbiAgICB2YXIgZXhpdEFjdGlvbnMgPSBBcnJheS5mcm9tKGV4aXRTdGF0ZXMpLm1hcChmdW5jdGlvbiAoc3RhdGVOb2RlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZXhpdCcsXG4gICAgICAgIGFjdGlvbnM6IHRvQWN0aW9uT2JqZWN0cyhfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChzdGF0ZU5vZGUub25FeGl0KSwgZmFsc2UpLCBfX3JlYWQoc3RhdGVOb2RlLmFjdGl2aXRpZXMubWFwKGZ1bmN0aW9uIChhY3Rpdml0eSkge1xuICAgICAgICAgIHJldHVybiBzdG9wKGFjdGl2aXR5KTtcbiAgICAgICAgfSkpLCBmYWxzZSksIF90aGlzLm1hY2hpbmUub3B0aW9ucy5hY3Rpb25zKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgYWN0aW9ucyA9IGV4aXRBY3Rpb25zLmNvbmNhdCh7XG4gICAgICB0eXBlOiAndHJhbnNpdGlvbicsXG4gICAgICBhY3Rpb25zOiB0b0FjdGlvbk9iamVjdHModHJhbnNpdGlvbi5hY3Rpb25zLCB0aGlzLm1hY2hpbmUub3B0aW9ucy5hY3Rpb25zKVxuICAgIH0pLmNvbmNhdChlbnRyeUFjdGlvbnMpO1xuXG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgdmFyIHN0b3BBY3Rpb25zID0gdG9BY3Rpb25PYmplY3RzKGZsYXR0ZW4oX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHJlc29sdmVkQ29uZmlnKSwgZmFsc2UpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIub3JkZXIgLSBhLm9yZGVyO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChzdGF0ZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlTm9kZS5vbkV4aXQ7XG4gICAgICB9KSksIHRoaXMubWFjaGluZS5vcHRpb25zLmFjdGlvbnMpLmZpbHRlcihmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhaXNSYWlzYWJsZUFjdGlvbihhY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWN0aW9ucy5jb25jYXQoe1xuICAgICAgICB0eXBlOiAnc3RvcCcsXG4gICAgICAgIGFjdGlvbnM6IHN0b3BBY3Rpb25zXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9ucztcbiAgfTtcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyB0aGUgbmV4dCBzdGF0ZSBnaXZlbiB0aGUgY3VycmVudCBgc3RhdGVgIGFuZCBzZW50IGBldmVudGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc3RhdGUgVGhlIGN1cnJlbnQgU3RhdGUgaW5zdGFuY2Ugb3Igc3RhdGUgdmFsdWVcclxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRoYXQgd2FzIHNlbnQgYXQgdGhlIGN1cnJlbnQgc3RhdGVcclxuICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IChleHRlbmRlZCBzdGF0ZSkgb2YgdGhlIGN1cnJlbnQgc3RhdGVcclxuICAgKi9cblxuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUudHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChzdGF0ZSwgZXZlbnQsIGNvbnRleHQsIGV4ZWMpIHtcbiAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgc3RhdGUgPSB0aGlzLmluaXRpYWxTdGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgX2V2ZW50ID0gdG9TQ1hNTEV2ZW50KGV2ZW50KTtcblxuICAgIHZhciBjdXJyZW50U3RhdGU7XG5cbiAgICBpZiAoc3RhdGUgaW5zdGFuY2VvZiBTdGF0ZSkge1xuICAgICAgY3VycmVudFN0YXRlID0gY29udGV4dCA9PT0gdW5kZWZpbmVkID8gc3RhdGUgOiB0aGlzLnJlc29sdmVTdGF0ZShTdGF0ZS5mcm9tKHN0YXRlLCBjb250ZXh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXNvbHZlZFN0YXRlVmFsdWUgPSBpc1N0cmluZyhzdGF0ZSkgPyB0aGlzLnJlc29sdmUocGF0aFRvU3RhdGVWYWx1ZSh0aGlzLmdldFJlc29sdmVkUGF0aChzdGF0ZSkpKSA6IHRoaXMucmVzb2x2ZShzdGF0ZSk7XG4gICAgICB2YXIgcmVzb2x2ZWRDb250ZXh0ID0gY29udGV4dCAhPT0gbnVsbCAmJiBjb250ZXh0ICE9PSB2b2lkIDAgPyBjb250ZXh0IDogdGhpcy5tYWNoaW5lLmNvbnRleHQ7XG4gICAgICBjdXJyZW50U3RhdGUgPSB0aGlzLnJlc29sdmVTdGF0ZShTdGF0ZS5mcm9tKHJlc29sdmVkU3RhdGVWYWx1ZSwgcmVzb2x2ZWRDb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKCFJU19QUk9EVUNUSU9OICYmIF9ldmVudC5uYW1lID09PSBXSUxEQ0FSRCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gZXZlbnQgY2Fubm90IGhhdmUgdGhlIHdpbGRjYXJkIHR5cGUgKCdcIi5jb25jYXQoV0lMRENBUkQsIFwiJylcIikpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0cmljdCkge1xuICAgICAgaWYgKCF0aGlzLmV2ZW50cy5pbmNsdWRlcyhfZXZlbnQubmFtZSkgJiYgIWlzQnVpbHRJbkV2ZW50KF9ldmVudC5uYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWNoaW5lICdcIi5jb25jYXQodGhpcy5pZCwgXCInIGRvZXMgbm90IGFjY2VwdCBldmVudCAnXCIpLmNvbmNhdChfZXZlbnQubmFtZSwgXCInXCIpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3RhdGVUcmFuc2l0aW9uID0gdGhpcy5fdHJhbnNpdGlvbihjdXJyZW50U3RhdGUudmFsdWUsIGN1cnJlbnRTdGF0ZSwgX2V2ZW50KSB8fCB7XG4gICAgICB0cmFuc2l0aW9uczogW10sXG4gICAgICBjb25maWd1cmF0aW9uOiBbXSxcbiAgICAgIGV4aXRTZXQ6IFtdLFxuICAgICAgc291cmNlOiBjdXJyZW50U3RhdGUsXG4gICAgICBhY3Rpb25zOiBbXVxuICAgIH07XG4gICAgdmFyIHByZXZDb25maWcgPSBnZXRDb25maWd1cmF0aW9uKFtdLCB0aGlzLmdldFN0YXRlTm9kZXMoY3VycmVudFN0YXRlLnZhbHVlKSk7XG4gICAgdmFyIHJlc29sdmVkQ29uZmlnID0gc3RhdGVUcmFuc2l0aW9uLmNvbmZpZ3VyYXRpb24ubGVuZ3RoID8gZ2V0Q29uZmlndXJhdGlvbihwcmV2Q29uZmlnLCBzdGF0ZVRyYW5zaXRpb24uY29uZmlndXJhdGlvbikgOiBwcmV2Q29uZmlnO1xuICAgIHN0YXRlVHJhbnNpdGlvbi5jb25maWd1cmF0aW9uID0gX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHJlc29sdmVkQ29uZmlnKSwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVUcmFuc2l0aW9uKHN0YXRlVHJhbnNpdGlvbiwgY3VycmVudFN0YXRlLCBjdXJyZW50U3RhdGUuY29udGV4dCwgZXhlYywgX2V2ZW50KTtcbiAgfTtcblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLnJlc29sdmVSYWlzZWRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHN0YXRlLCBfZXZlbnQsIG9yaWdpbmFsRXZlbnQsIHByZWRpY3RhYmxlRXhlYykge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBjdXJyZW50QWN0aW9ucyA9IHN0YXRlLmFjdGlvbnM7XG4gICAgc3RhdGUgPSB0aGlzLnRyYW5zaXRpb24oc3RhdGUsIF9ldmVudCwgdW5kZWZpbmVkLCBwcmVkaWN0YWJsZUV4ZWMpOyAvLyBTYXZlIG9yaWdpbmFsIGV2ZW50IHRvIHN0YXRlXG4gICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgdGhlIHJhaXNlZCBldmVudCEgRGVsZXRlIGluIFY1IChicmVha2luZylcblxuICAgIHN0YXRlLl9ldmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gICAgc3RhdGUuZXZlbnQgPSBvcmlnaW5hbEV2ZW50LmRhdGE7XG5cbiAgICAoX2EgPSBzdGF0ZS5hY3Rpb25zKS51bnNoaWZ0LmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoY3VycmVudEFjdGlvbnMpLCBmYWxzZSkpO1xuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9O1xuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUucmVzb2x2ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoc3RhdGVUcmFuc2l0aW9uLCBjdXJyZW50U3RhdGUsIGNvbnRleHQsIHByZWRpY3RhYmxlRXhlYywgX2V2ZW50KSB7XG4gICAgdmFyIGVfNiwgX2EsIGVfNywgX2I7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKF9ldmVudCA9PT0gdm9pZCAwKSB7XG4gICAgICBfZXZlbnQgPSBpbml0RXZlbnQ7XG4gICAgfVxuXG4gICAgdmFyIGNvbmZpZ3VyYXRpb24gPSBzdGF0ZVRyYW5zaXRpb24uY29uZmlndXJhdGlvbjsgLy8gVHJhbnNpdGlvbiB3aWxsIFwiYXBwbHlcIiBpZjpcbiAgICAvLyAtIHRoaXMgaXMgdGhlIGluaXRpYWwgc3RhdGUgKHRoZXJlIGlzIG5vIGN1cnJlbnQgc3RhdGUpXG4gICAgLy8gLSBPUiB0aGVyZSBhcmUgdHJhbnNpdGlvbnNcblxuICAgIHZhciB3aWxsVHJhbnNpdGlvbiA9ICFjdXJyZW50U3RhdGUgfHwgc3RhdGVUcmFuc2l0aW9uLnRyYW5zaXRpb25zLmxlbmd0aCA+IDA7XG4gICAgdmFyIHJlc29sdmVkQ29uZmlndXJhdGlvbiA9IHdpbGxUcmFuc2l0aW9uID8gc3RhdGVUcmFuc2l0aW9uLmNvbmZpZ3VyYXRpb24gOiBjdXJyZW50U3RhdGUgPyBjdXJyZW50U3RhdGUuY29uZmlndXJhdGlvbiA6IFtdO1xuICAgIHZhciBpc0RvbmUgPSBpc0luRmluYWxTdGF0ZShyZXNvbHZlZENvbmZpZ3VyYXRpb24sIHRoaXMpO1xuICAgIHZhciByZXNvbHZlZFN0YXRlVmFsdWUgPSB3aWxsVHJhbnNpdGlvbiA/IGdldFZhbHVlKHRoaXMubWFjaGluZSwgY29uZmlndXJhdGlvbikgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGhpc3RvcnlWYWx1ZSA9IGN1cnJlbnRTdGF0ZSA/IGN1cnJlbnRTdGF0ZS5oaXN0b3J5VmFsdWUgPyBjdXJyZW50U3RhdGUuaGlzdG9yeVZhbHVlIDogc3RhdGVUcmFuc2l0aW9uLnNvdXJjZSA/IHRoaXMubWFjaGluZS5oaXN0b3J5VmFsdWUoY3VycmVudFN0YXRlLnZhbHVlKSA6IHVuZGVmaW5lZCA6IHVuZGVmaW5lZDtcbiAgICB2YXIgYWN0aW9uQmxvY2tzID0gdGhpcy5nZXRBY3Rpb25zKG5ldyBTZXQocmVzb2x2ZWRDb25maWd1cmF0aW9uKSwgaXNEb25lLCBzdGF0ZVRyYW5zaXRpb24sIGNvbnRleHQsIF9ldmVudCwgY3VycmVudFN0YXRlLCBwcmVkaWN0YWJsZUV4ZWMpO1xuICAgIHZhciBhY3Rpdml0aWVzID0gY3VycmVudFN0YXRlID8gX19hc3NpZ24oe30sIGN1cnJlbnRTdGF0ZS5hY3Rpdml0aWVzKSA6IHt9O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIGFjdGlvbkJsb2Nrc18xID0gX192YWx1ZXMoYWN0aW9uQmxvY2tzKSwgYWN0aW9uQmxvY2tzXzFfMSA9IGFjdGlvbkJsb2Nrc18xLm5leHQoKTsgIWFjdGlvbkJsb2Nrc18xXzEuZG9uZTsgYWN0aW9uQmxvY2tzXzFfMSA9IGFjdGlvbkJsb2Nrc18xLm5leHQoKSkge1xuICAgICAgICB2YXIgYmxvY2sgPSBhY3Rpb25CbG9ja3NfMV8xLnZhbHVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2MgPSAoZV83ID0gdm9pZCAwLCBfX3ZhbHVlcyhibG9jay5hY3Rpb25zKSksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBfZC52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSBzdGFydCQxKSB7XG4gICAgICAgICAgICAgIGFjdGl2aXRpZXNbYWN0aW9uLmFjdGl2aXR5LmlkIHx8IGFjdGlvbi5hY3Rpdml0eS50eXBlXSA9IGFjdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uLnR5cGUgPT09IHN0b3AkMSkge1xuICAgICAgICAgICAgICBhY3Rpdml0aWVzW2FjdGlvbi5hY3Rpdml0eS5pZCB8fCBhY3Rpb24uYWN0aXZpdHkudHlwZV0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVfN18xKSB7XG4gICAgICAgICAgZV83ID0ge1xuICAgICAgICAgICAgZXJyb3I6IGVfN18xXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYiA9IF9jLnJldHVybikpIF9iLmNhbGwoX2MpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZV83KSB0aHJvdyBlXzcuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZV82XzEpIHtcbiAgICAgIGVfNiA9IHtcbiAgICAgICAgZXJyb3I6IGVfNl8xXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoYWN0aW9uQmxvY2tzXzFfMSAmJiAhYWN0aW9uQmxvY2tzXzFfMS5kb25lICYmIChfYSA9IGFjdGlvbkJsb2Nrc18xLnJldHVybikpIF9hLmNhbGwoYWN0aW9uQmxvY2tzXzEpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVfNikgdGhyb3cgZV82LmVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfZSA9IF9fcmVhZChyZXNvbHZlQWN0aW9ucyh0aGlzLCBjdXJyZW50U3RhdGUsIGNvbnRleHQsIF9ldmVudCwgYWN0aW9uQmxvY2tzLCBwcmVkaWN0YWJsZUV4ZWMsIHRoaXMubWFjaGluZS5jb25maWcucHJlZGljdGFibGVBY3Rpb25Bcmd1bWVudHMgfHwgdGhpcy5tYWNoaW5lLmNvbmZpZy5wcmVzZXJ2ZUFjdGlvbk9yZGVyKSwgMiksXG4gICAgICAgIHJlc29sdmVkQWN0aW9ucyA9IF9lWzBdLFxuICAgICAgICB1cGRhdGVkQ29udGV4dCA9IF9lWzFdO1xuXG4gICAgdmFyIF9mID0gX19yZWFkKHBhcnRpdGlvbihyZXNvbHZlZEFjdGlvbnMsIGlzUmFpc2FibGVBY3Rpb24pLCAyKSxcbiAgICAgICAgcmFpc2VkRXZlbnRzID0gX2ZbMF0sXG4gICAgICAgIG5vblJhaXNlZEFjdGlvbnMgPSBfZlsxXTtcblxuICAgIHZhciBpbnZva2VBY3Rpb25zID0gcmVzb2x2ZWRBY3Rpb25zLmZpbHRlcihmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICB2YXIgX2E7XG5cbiAgICAgIHJldHVybiBhY3Rpb24udHlwZSA9PT0gc3RhcnQkMSAmJiAoKF9hID0gYWN0aW9uLmFjdGl2aXR5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09IGludm9rZTtcbiAgICB9KTtcbiAgICB2YXIgY2hpbGRyZW4gPSBpbnZva2VBY3Rpb25zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhY3Rpb24pIHtcbiAgICAgIGFjY1thY3Rpb24uYWN0aXZpdHkuaWRdID0gY3JlYXRlSW52b2NhYmxlQWN0b3IoYWN0aW9uLmFjdGl2aXR5LCBfdGhpcy5tYWNoaW5lLCB1cGRhdGVkQ29udGV4dCwgX2V2ZW50KTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgY3VycmVudFN0YXRlID8gX19hc3NpZ24oe30sIGN1cnJlbnRTdGF0ZS5jaGlsZHJlbikgOiB7fSk7XG4gICAgdmFyIG5leHRTdGF0ZSA9IG5ldyBTdGF0ZSh7XG4gICAgICB2YWx1ZTogcmVzb2x2ZWRTdGF0ZVZhbHVlIHx8IGN1cnJlbnRTdGF0ZS52YWx1ZSxcbiAgICAgIGNvbnRleHQ6IHVwZGF0ZWRDb250ZXh0LFxuICAgICAgX2V2ZW50OiBfZXZlbnQsXG4gICAgICAvLyBQZXJzaXN0IF9zZXNzaW9uaWQgYmV0d2VlbiBzdGF0ZXNcbiAgICAgIF9zZXNzaW9uaWQ6IGN1cnJlbnRTdGF0ZSA/IGN1cnJlbnRTdGF0ZS5fc2Vzc2lvbmlkIDogbnVsbCxcbiAgICAgIGhpc3RvcnlWYWx1ZTogcmVzb2x2ZWRTdGF0ZVZhbHVlID8gaGlzdG9yeVZhbHVlID8gdXBkYXRlSGlzdG9yeVZhbHVlKGhpc3RvcnlWYWx1ZSwgcmVzb2x2ZWRTdGF0ZVZhbHVlKSA6IHVuZGVmaW5lZCA6IGN1cnJlbnRTdGF0ZSA/IGN1cnJlbnRTdGF0ZS5oaXN0b3J5VmFsdWUgOiB1bmRlZmluZWQsXG4gICAgICBoaXN0b3J5OiAhcmVzb2x2ZWRTdGF0ZVZhbHVlIHx8IHN0YXRlVHJhbnNpdGlvbi5zb3VyY2UgPyBjdXJyZW50U3RhdGUgOiB1bmRlZmluZWQsXG4gICAgICBhY3Rpb25zOiByZXNvbHZlZFN0YXRlVmFsdWUgPyBub25SYWlzZWRBY3Rpb25zIDogW10sXG4gICAgICBhY3Rpdml0aWVzOiByZXNvbHZlZFN0YXRlVmFsdWUgPyBhY3Rpdml0aWVzIDogY3VycmVudFN0YXRlID8gY3VycmVudFN0YXRlLmFjdGl2aXRpZXMgOiB7fSxcbiAgICAgIGV2ZW50czogW10sXG4gICAgICBjb25maWd1cmF0aW9uOiByZXNvbHZlZENvbmZpZ3VyYXRpb24sXG4gICAgICB0cmFuc2l0aW9uczogc3RhdGVUcmFuc2l0aW9uLnRyYW5zaXRpb25zLFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgZG9uZTogaXNEb25lLFxuICAgICAgdGFnczogZ2V0VGFnc0Zyb21Db25maWd1cmF0aW9uKHJlc29sdmVkQ29uZmlndXJhdGlvbiksXG4gICAgICBtYWNoaW5lOiB0aGlzXG4gICAgfSk7XG4gICAgdmFyIGRpZFVwZGF0ZUNvbnRleHQgPSBjb250ZXh0ICE9PSB1cGRhdGVkQ29udGV4dDtcbiAgICBuZXh0U3RhdGUuY2hhbmdlZCA9IF9ldmVudC5uYW1lID09PSB1cGRhdGUgfHwgZGlkVXBkYXRlQ29udGV4dDsgLy8gRGlzcG9zZSBvZiBwZW51bHRpbWF0ZSBoaXN0b3JpZXMgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcblxuICAgIHZhciBoaXN0b3J5ID0gbmV4dFN0YXRlLmhpc3Rvcnk7XG5cbiAgICBpZiAoaGlzdG9yeSkge1xuICAgICAgZGVsZXRlIGhpc3RvcnkuaGlzdG9yeTtcbiAgICB9IC8vIFRoZXJlIGFyZSB0cmFuc2llbnQgdHJhbnNpdGlvbnMgaWYgdGhlIG1hY2hpbmUgaXMgbm90IGluIGEgZmluYWwgc3RhdGVcbiAgICAvLyBhbmQgaWYgc29tZSBvZiB0aGUgc3RhdGUgbm9kZXMgaGF2ZSB0cmFuc2llbnQgKFwiYWx3YXlzXCIpIHRyYW5zaXRpb25zLlxuXG5cbiAgICB2YXIgaGFzQWx3YXlzVHJhbnNpdGlvbnMgPSAhaXNEb25lICYmICh0aGlzLl90cmFuc2llbnQgfHwgY29uZmlndXJhdGlvbi5zb21lKGZ1bmN0aW9uIChzdGF0ZU5vZGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZU5vZGUuX3RyYW5zaWVudDtcbiAgICB9KSk7IC8vIElmIHRoZXJlIGFyZSBubyBlbmFibGVkIHRyYW5zaXRpb25zLCBjaGVjayBpZiB0aGVyZSBhcmUgdHJhbnNpZW50IHRyYW5zaXRpb25zLlxuICAgIC8vIElmIHRoZXJlIGFyZSB0cmFuc2llbnQgdHJhbnNpdGlvbnMsIGNvbnRpbnVlIGNoZWNraW5nIGZvciBtb3JlIHRyYW5zaXRpb25zXG4gICAgLy8gYmVjYXVzZSBhbiB0cmFuc2llbnQgdHJhbnNpdGlvbiBzaG91bGQgYmUgdHJpZ2dlcmVkIGV2ZW4gaWYgdGhlcmUgYXJlIG5vXG4gICAgLy8gZW5hYmxlZCB0cmFuc2l0aW9ucy5cbiAgICAvL1xuICAgIC8vIElmIHdlJ3JlIGFscmVhZHkgd29ya2luZyBvbiBhbiB0cmFuc2llbnQgdHJhbnNpdGlvbiB0aGVuIHN0b3AgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLlxuICAgIC8vXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGVyZSBhcmUgbm8gZW5hYmxlZCBub3IgdHJhbnNpZW50IHRyYW5zaXRpb25zLCB3ZSBhcmUgZG9uZS5cblxuICAgIGlmICghd2lsbFRyYW5zaXRpb24gJiYgKCFoYXNBbHdheXNUcmFuc2l0aW9ucyB8fCBfZXZlbnQubmFtZSA9PT0gTlVMTF9FVkVOVCkpIHtcbiAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlTmV4dFN0YXRlID0gbmV4dFN0YXRlO1xuXG4gICAgaWYgKCFpc0RvbmUpIHtcbiAgICAgIGlmIChoYXNBbHdheXNUcmFuc2l0aW9ucykge1xuICAgICAgICBtYXliZU5leHRTdGF0ZSA9IHRoaXMucmVzb2x2ZVJhaXNlZFRyYW5zaXRpb24obWF5YmVOZXh0U3RhdGUsIHtcbiAgICAgICAgICB0eXBlOiBudWxsRXZlbnRcbiAgICAgICAgfSwgX2V2ZW50LCBwcmVkaWN0YWJsZUV4ZWMpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAocmFpc2VkRXZlbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgcmFpc2VkRXZlbnQgPSByYWlzZWRFdmVudHMuc2hpZnQoKTtcbiAgICAgICAgbWF5YmVOZXh0U3RhdGUgPSB0aGlzLnJlc29sdmVSYWlzZWRUcmFuc2l0aW9uKG1heWJlTmV4dFN0YXRlLCByYWlzZWRFdmVudC5fZXZlbnQsIF9ldmVudCwgcHJlZGljdGFibGVFeGVjKTtcbiAgICAgIH1cbiAgICB9IC8vIERldGVjdCBpZiBzdGF0ZSBjaGFuZ2VkXG5cblxuICAgIHZhciBjaGFuZ2VkID0gbWF5YmVOZXh0U3RhdGUuY2hhbmdlZCB8fCAoaGlzdG9yeSA/ICEhbWF5YmVOZXh0U3RhdGUuYWN0aW9ucy5sZW5ndGggfHwgZGlkVXBkYXRlQ29udGV4dCB8fCB0eXBlb2YgaGlzdG9yeS52YWx1ZSAhPT0gdHlwZW9mIG1heWJlTmV4dFN0YXRlLnZhbHVlIHx8ICFzdGF0ZVZhbHVlc0VxdWFsKG1heWJlTmV4dFN0YXRlLnZhbHVlLCBoaXN0b3J5LnZhbHVlKSA6IHVuZGVmaW5lZCk7XG4gICAgbWF5YmVOZXh0U3RhdGUuY2hhbmdlZCA9IGNoYW5nZWQ7IC8vIFByZXNlcnZlIG9yaWdpbmFsIGhpc3RvcnkgYWZ0ZXIgcmFpc2VkIGV2ZW50c1xuXG4gICAgbWF5YmVOZXh0U3RhdGUuaGlzdG9yeSA9IGhpc3Rvcnk7XG4gICAgcmV0dXJuIG1heWJlTmV4dFN0YXRlO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBjaGlsZCBzdGF0ZSBub2RlIGZyb20gaXRzIHJlbGF0aXZlIGBzdGF0ZUtleWAsIG9yIHRocm93cy5cclxuICAgKi9cblxuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuZ2V0U3RhdGVOb2RlID0gZnVuY3Rpb24gKHN0YXRlS2V5KSB7XG4gICAgaWYgKGlzU3RhdGVJZChzdGF0ZUtleSkpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hY2hpbmUuZ2V0U3RhdGVOb2RlQnlJZChzdGF0ZUtleSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN0YXRlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJldHJpZXZlIGNoaWxkIHN0YXRlICdcIi5jb25jYXQoc3RhdGVLZXksIFwiJyBmcm9tICdcIikuY29uY2F0KHRoaXMuaWQsIFwiJzsgbm8gY2hpbGQgc3RhdGVzIGV4aXN0LlwiKSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuc3RhdGVzW3N0YXRlS2V5XTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBzdGF0ZSAnXCIuY29uY2F0KHN0YXRlS2V5LCBcIicgZG9lcyBub3QgZXhpc3Qgb24gJ1wiKS5jb25jYXQodGhpcy5pZCwgXCInXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSBub2RlIHdpdGggdGhlIGdpdmVuIGBzdGF0ZUlkYCwgb3IgdGhyb3dzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHN0YXRlSWQgVGhlIHN0YXRlIElELiBUaGUgcHJlZml4IFwiI1wiIGlzIHJlbW92ZWQuXHJcbiAgICovXG5cblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLmdldFN0YXRlTm9kZUJ5SWQgPSBmdW5jdGlvbiAoc3RhdGVJZCkge1xuICAgIHZhciByZXNvbHZlZFN0YXRlSWQgPSBpc1N0YXRlSWQoc3RhdGVJZCkgPyBzdGF0ZUlkLnNsaWNlKFNUQVRFX0lERU5USUZJRVIubGVuZ3RoKSA6IHN0YXRlSWQ7XG5cbiAgICBpZiAocmVzb2x2ZWRTdGF0ZUlkID09PSB0aGlzLmlkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgc3RhdGVOb2RlID0gdGhpcy5tYWNoaW5lLmlkTWFwW3Jlc29sdmVkU3RhdGVJZF07XG5cbiAgICBpZiAoIXN0YXRlTm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgc3RhdGUgbm9kZSAnI1wiLmNvbmNhdChyZXNvbHZlZFN0YXRlSWQsIFwiJyBkb2VzIG5vdCBleGlzdCBvbiBtYWNoaW5lICdcIikuY29uY2F0KHRoaXMuaWQsIFwiJ1wiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlTm9kZTtcbiAgfTtcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgcmVsYXRpdmUgc3RhdGUgbm9kZSBmcm9tIHRoZSBnaXZlbiBgc3RhdGVQYXRoYCwgb3IgdGhyb3dzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHN0YXRlUGF0aCBUaGUgc3RyaW5nIG9yIHN0cmluZyBhcnJheSByZWxhdGl2ZSBwYXRoIHRvIHRoZSBzdGF0ZSBub2RlLlxyXG4gICAqL1xuXG5cbiAgU3RhdGVOb2RlLnByb3RvdHlwZS5nZXRTdGF0ZU5vZGVCeVBhdGggPSBmdW5jdGlvbiAoc3RhdGVQYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZVBhdGggPT09ICdzdHJpbmcnICYmIGlzU3RhdGVJZChzdGF0ZVBhdGgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZU5vZGVCeUlkKHN0YXRlUGF0aC5zbGljZSgxKSk7XG4gICAgICB9IGNhdGNoIChlKSB7Ly8gdHJ5IGluZGl2aWR1YWwgcGF0aHNcbiAgICAgICAgLy8gdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyYXlTdGF0ZVBhdGggPSB0b1N0YXRlUGF0aChzdGF0ZVBhdGgsIHRoaXMuZGVsaW1pdGVyKS5zbGljZSgpO1xuICAgIHZhciBjdXJyZW50U3RhdGVOb2RlID0gdGhpcztcblxuICAgIHdoaWxlIChhcnJheVN0YXRlUGF0aC5sZW5ndGgpIHtcbiAgICAgIHZhciBrZXkgPSBhcnJheVN0YXRlUGF0aC5zaGlmdCgpO1xuXG4gICAgICBpZiAoIWtleS5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRTdGF0ZU5vZGUgPSBjdXJyZW50U3RhdGVOb2RlLmdldFN0YXRlTm9kZShrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50U3RhdGVOb2RlO1xuICB9O1xuICAvKipcclxuICAgKiBSZXNvbHZlcyBhIHBhcnRpYWwgc3RhdGUgdmFsdWUgd2l0aCBpdHMgZnVsbCByZXByZXNlbnRhdGlvbiBpbiB0aGlzIG1hY2hpbmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc3RhdGVWYWx1ZSBUaGUgcGFydGlhbCBzdGF0ZSB2YWx1ZSB0byByZXNvbHZlLlxyXG4gICAqL1xuXG5cbiAgU3RhdGVOb2RlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHN0YXRlVmFsdWUpIHtcbiAgICB2YXIgX2E7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCFzdGF0ZVZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsU3RhdGVWYWx1ZSB8fCBFTVBUWV9PQkpFQ1Q7IC8vIFRPRE86IHR5cGUtc3BlY2lmaWMgcHJvcGVydGllc1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlICdwYXJhbGxlbCc6XG4gICAgICAgIHJldHVybiBtYXBWYWx1ZXModGhpcy5pbml0aWFsU3RhdGVWYWx1ZSwgZnVuY3Rpb24gKHN1YlN0YXRlVmFsdWUsIHN1YlN0YXRlS2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHN1YlN0YXRlVmFsdWUgPyBfdGhpcy5nZXRTdGF0ZU5vZGUoc3ViU3RhdGVLZXkpLnJlc29sdmUoc3RhdGVWYWx1ZVtzdWJTdGF0ZUtleV0gfHwgc3ViU3RhdGVWYWx1ZSkgOiBFTVBUWV9PQkpFQ1Q7XG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdjb21wb3VuZCc6XG4gICAgICAgIGlmIChpc1N0cmluZyhzdGF0ZVZhbHVlKSkge1xuICAgICAgICAgIHZhciBzdWJTdGF0ZU5vZGUgPSB0aGlzLmdldFN0YXRlTm9kZShzdGF0ZVZhbHVlKTtcblxuICAgICAgICAgIGlmIChzdWJTdGF0ZU5vZGUudHlwZSA9PT0gJ3BhcmFsbGVsJyB8fCBzdWJTdGF0ZU5vZGUudHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgICAgICAgcmV0dXJuIF9hID0ge30sIF9hW3N0YXRlVmFsdWVdID0gc3ViU3RhdGVOb2RlLmluaXRpYWxTdGF0ZVZhbHVlLCBfYTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RhdGVWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghT2JqZWN0LmtleXMoc3RhdGVWYWx1ZSkubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFN0YXRlVmFsdWUgfHwge307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFwVmFsdWVzKHN0YXRlVmFsdWUsIGZ1bmN0aW9uIChzdWJTdGF0ZVZhbHVlLCBzdWJTdGF0ZUtleSkge1xuICAgICAgICAgIHJldHVybiBzdWJTdGF0ZVZhbHVlID8gX3RoaXMuZ2V0U3RhdGVOb2RlKHN1YlN0YXRlS2V5KS5yZXNvbHZlKHN1YlN0YXRlVmFsdWUpIDogRU1QVFlfT0JKRUNUO1xuICAgICAgICB9KTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN0YXRlVmFsdWUgfHwgRU1QVFlfT0JKRUNUO1xuICAgIH1cbiAgfTtcblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLmdldFJlc29sdmVkUGF0aCA9IGZ1bmN0aW9uIChzdGF0ZUlkZW50aWZpZXIpIHtcbiAgICBpZiAoaXNTdGF0ZUlkKHN0YXRlSWRlbnRpZmllcikpIHtcbiAgICAgIHZhciBzdGF0ZU5vZGUgPSB0aGlzLm1hY2hpbmUuaWRNYXBbc3RhdGVJZGVudGlmaWVyLnNsaWNlKFNUQVRFX0lERU5USUZJRVIubGVuZ3RoKV07XG5cbiAgICAgIGlmICghc3RhdGVOb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHN0YXRlIG5vZGUgJ1wiLmNvbmNhdChzdGF0ZUlkZW50aWZpZXIsIFwiJ1wiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGF0ZU5vZGUucGF0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9TdGF0ZVBhdGgoc3RhdGVJZGVudGlmaWVyLCB0aGlzLmRlbGltaXRlcik7XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlTm9kZS5wcm90b3R5cGUsIFwiaW5pdGlhbFN0YXRlVmFsdWVcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hO1xuXG4gICAgICBpZiAodGhpcy5fX2NhY2hlLmluaXRpYWxTdGF0ZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY2FjaGUuaW5pdGlhbFN0YXRlVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbml0aWFsU3RhdGVWYWx1ZTtcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgICBpbml0aWFsU3RhdGVWYWx1ZSA9IG1hcEZpbHRlclZhbHVlcyh0aGlzLnN0YXRlcywgZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmluaXRpYWxTdGF0ZVZhbHVlIHx8IEVNUFRZX09CSkVDVDtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHN0YXRlTm9kZSkge1xuICAgICAgICAgIHJldHVybiAhKHN0YXRlTm9kZS50eXBlID09PSAnaGlzdG9yeScpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbml0aWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlc1t0aGlzLmluaXRpYWxdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5pdGlhbCBzdGF0ZSAnXCIuY29uY2F0KHRoaXMuaW5pdGlhbCwgXCInIG5vdCBmb3VuZCBvbiAnXCIpLmNvbmNhdCh0aGlzLmtleSwgXCInXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXRpYWxTdGF0ZVZhbHVlID0gaXNMZWFmTm9kZSh0aGlzLnN0YXRlc1t0aGlzLmluaXRpYWxdKSA/IHRoaXMuaW5pdGlhbCA6IChfYSA9IHt9LCBfYVt0aGlzLmluaXRpYWxdID0gdGhpcy5zdGF0ZXNbdGhpcy5pbml0aWFsXS5pbml0aWFsU3RhdGVWYWx1ZSwgX2EpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGZpbml0ZSBzdGF0ZSB2YWx1ZSBvZiBhIG1hY2hpbmUgd2l0aG91dCBjaGlsZCBzdGF0ZXMgaXMganVzdCBhbiBlbXB0eSBvYmplY3RcbiAgICAgICAgaW5pdGlhbFN0YXRlVmFsdWUgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fX2NhY2hlLmluaXRpYWxTdGF0ZVZhbHVlID0gaW5pdGlhbFN0YXRlVmFsdWU7XG4gICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLmluaXRpYWxTdGF0ZVZhbHVlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlVmFsdWUsIGNvbnRleHQpIHtcbiAgICB0aGlzLl9pbml0KCk7IC8vIFRPRE86IHRoaXMgc2hvdWxkIGJlIGluIHRoZSBjb25zdHJ1Y3RvciAoc2VlIG5vdGUgaW4gY29uc3RydWN0b3IpXG5cblxuICAgIHZhciBjb25maWd1cmF0aW9uID0gdGhpcy5nZXRTdGF0ZU5vZGVzKHN0YXRlVmFsdWUpO1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVUcmFuc2l0aW9uKHtcbiAgICAgIGNvbmZpZ3VyYXRpb246IGNvbmZpZ3VyYXRpb24sXG4gICAgICBleGl0U2V0OiBbXSxcbiAgICAgIHRyYW5zaXRpb25zOiBbXSxcbiAgICAgIHNvdXJjZTogdW5kZWZpbmVkLFxuICAgICAgYWN0aW9uczogW11cbiAgICB9LCB1bmRlZmluZWQsIGNvbnRleHQgIT09IG51bGwgJiYgY29udGV4dCAhPT0gdm9pZCAwID8gY29udGV4dCA6IHRoaXMubWFjaGluZS5jb250ZXh0LCB1bmRlZmluZWQpO1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZU5vZGUucHJvdG90eXBlLCBcImluaXRpYWxTdGF0ZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5pdGlhbCBTdGF0ZSBpbnN0YW5jZSwgd2hpY2ggaW5jbHVkZXMgYWxsIGFjdGlvbnMgdG8gYmUgZXhlY3V0ZWQgZnJvbVxyXG4gICAgICogZW50ZXJpbmcgdGhlIGluaXRpYWwgc3RhdGUuXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbml0aWFsU3RhdGVWYWx1ZSA9IHRoaXMuaW5pdGlhbFN0YXRlVmFsdWU7XG5cbiAgICAgIGlmICghaW5pdGlhbFN0YXRlVmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJldHJpZXZlIGluaXRpYWwgc3RhdGUgZnJvbSBzaW1wbGUgc3RhdGUgJ1wiLmNvbmNhdCh0aGlzLmlkLCBcIicuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5pdGlhbFN0YXRlKGluaXRpYWxTdGF0ZVZhbHVlKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlTm9kZS5wcm90b3R5cGUsIFwidGFyZ2V0XCIsIHtcbiAgICAvKipcclxuICAgICAqIFRoZSB0YXJnZXQgc3RhdGUgdmFsdWUgb2YgdGhlIGhpc3Rvcnkgc3RhdGUgbm9kZSwgaWYgaXQgZXhpc3RzLiBUaGlzIHJlcHJlc2VudHMgdGhlXHJcbiAgICAgKiBkZWZhdWx0IHN0YXRlIHZhbHVlIHRvIHRyYW5zaXRpb24gdG8gaWYgbm8gaGlzdG9yeSB2YWx1ZSBleGlzdHMgeWV0LlxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGFyZ2V0O1xuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAnaGlzdG9yeScpIHtcbiAgICAgICAgdmFyIGhpc3RvcnlDb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICBpZiAoaXNTdHJpbmcoaGlzdG9yeUNvbmZpZy50YXJnZXQpKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gaXNTdGF0ZUlkKGhpc3RvcnlDb25maWcudGFyZ2V0KSA/IHBhdGhUb1N0YXRlVmFsdWUodGhpcy5tYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQoaGlzdG9yeUNvbmZpZy50YXJnZXQpLnBhdGguc2xpY2UodGhpcy5wYXRoLmxlbmd0aCAtIDEpKSA6IGhpc3RvcnlDb25maWcudGFyZ2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldCA9IGhpc3RvcnlDb25maWcudGFyZ2V0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGxlYWYgbm9kZXMgZnJvbSBhIHN0YXRlIHBhdGggcmVsYXRpdmUgdG8gdGhpcyBzdGF0ZSBub2RlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHJlbGF0aXZlU3RhdGVJZCBUaGUgcmVsYXRpdmUgc3RhdGUgcGF0aCB0byByZXRyaWV2ZSB0aGUgc3RhdGUgbm9kZXNcclxuICAgKiBAcGFyYW0gaGlzdG9yeSBUaGUgcHJldmlvdXMgc3RhdGUgdG8gcmV0cmlldmUgaGlzdG9yeVxyXG4gICAqIEBwYXJhbSByZXNvbHZlIFdoZXRoZXIgc3RhdGUgbm9kZXMgc2hvdWxkIHJlc29sdmUgdG8gaW5pdGlhbCBjaGlsZCBzdGF0ZSBub2Rlc1xyXG4gICAqL1xuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuZ2V0UmVsYXRpdmVTdGF0ZU5vZGVzID0gZnVuY3Rpb24gKHJlbGF0aXZlU3RhdGVJZCwgaGlzdG9yeVZhbHVlLCByZXNvbHZlKSB7XG4gICAgaWYgKHJlc29sdmUgPT09IHZvaWQgMCkge1xuICAgICAgcmVzb2x2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc29sdmUgPyByZWxhdGl2ZVN0YXRlSWQudHlwZSA9PT0gJ2hpc3RvcnknID8gcmVsYXRpdmVTdGF0ZUlkLnJlc29sdmVIaXN0b3J5KGhpc3RvcnlWYWx1ZSkgOiByZWxhdGl2ZVN0YXRlSWQuaW5pdGlhbFN0YXRlTm9kZXMgOiBbcmVsYXRpdmVTdGF0ZUlkXTtcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVOb2RlLnByb3RvdHlwZSwgXCJpbml0aWFsU3RhdGVOb2Rlc1wiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoaXNMZWFmTm9kZSh0aGlzKSkge1xuICAgICAgICByZXR1cm4gW3RoaXNdO1xuICAgICAgfSAvLyBDYXNlIHdoZW4gc3RhdGUgbm9kZSBpcyBjb21wb3VuZCBidXQgbm8gaW5pdGlhbCBzdGF0ZSBpcyBkZWZpbmVkXG5cblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2NvbXBvdW5kJyAmJiAhdGhpcy5pbml0aWFsKSB7XG4gICAgICAgIGlmICghSVNfUFJPRFVDVElPTikge1xuICAgICAgICAgIHdhcm4oZmFsc2UsIFwiQ29tcG91bmQgc3RhdGUgbm9kZSAnXCIuY29uY2F0KHRoaXMuaWQsIFwiJyBoYXMgbm8gaW5pdGlhbCBzdGF0ZS5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluaXRpYWxTdGF0ZU5vZGVQYXRocyA9IHRvU3RhdGVQYXRocyh0aGlzLmluaXRpYWxTdGF0ZVZhbHVlKTtcbiAgICAgIHJldHVybiBmbGF0dGVuKGluaXRpYWxTdGF0ZU5vZGVQYXRocy5tYXAoZnVuY3Rpb24gKGluaXRpYWxQYXRoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5nZXRGcm9tUmVsYXRpdmVQYXRoKGluaXRpYWxQYXRoKTtcbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXHJcbiAgICogUmV0cmlldmVzIHN0YXRlIG5vZGVzIGZyb20gYSByZWxhdGl2ZSBwYXRoIHRvIHRoaXMgc3RhdGUgbm9kZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSByZWxhdGl2ZVBhdGggVGhlIHJlbGF0aXZlIHBhdGggZnJvbSB0aGlzIHN0YXRlIG5vZGVcclxuICAgKiBAcGFyYW0gaGlzdG9yeVZhbHVlXHJcbiAgICovXG5cbiAgU3RhdGVOb2RlLnByb3RvdHlwZS5nZXRGcm9tUmVsYXRpdmVQYXRoID0gZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCkge1xuICAgIGlmICghcmVsYXRpdmVQYXRoLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSBfX3JlYWQocmVsYXRpdmVQYXRoKSxcbiAgICAgICAgc3RhdGVLZXkgPSBfYVswXSxcbiAgICAgICAgY2hpbGRTdGF0ZVBhdGggPSBfYS5zbGljZSgxKTtcblxuICAgIGlmICghdGhpcy5zdGF0ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXRyaWV2ZSBzdWJQYXRoICdcIi5jb25jYXQoc3RhdGVLZXksIFwiJyBmcm9tIG5vZGUgd2l0aCBubyBzdGF0ZXNcIikpO1xuICAgIH1cblxuICAgIHZhciBjaGlsZFN0YXRlTm9kZSA9IHRoaXMuZ2V0U3RhdGVOb2RlKHN0YXRlS2V5KTtcblxuICAgIGlmIChjaGlsZFN0YXRlTm9kZS50eXBlID09PSAnaGlzdG9yeScpIHtcbiAgICAgIHJldHVybiBjaGlsZFN0YXRlTm9kZS5yZXNvbHZlSGlzdG9yeSgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zdGF0ZXNbc3RhdGVLZXldKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBzdGF0ZSAnXCIuY29uY2F0KHN0YXRlS2V5LCBcIicgZG9lcyBub3QgZXhpc3Qgb24gJ1wiKS5jb25jYXQodGhpcy5pZCwgXCInXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdGF0ZXNbc3RhdGVLZXldLmdldEZyb21SZWxhdGl2ZVBhdGgoY2hpbGRTdGF0ZVBhdGgpO1xuICB9O1xuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuaGlzdG9yeVZhbHVlID0gZnVuY3Rpb24gKHJlbGF0aXZlU3RhdGVWYWx1ZSkge1xuICAgIGlmICghT2JqZWN0LmtleXModGhpcy5zdGF0ZXMpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudDogcmVsYXRpdmVTdGF0ZVZhbHVlIHx8IHRoaXMuaW5pdGlhbFN0YXRlVmFsdWUsXG4gICAgICBzdGF0ZXM6IG1hcEZpbHRlclZhbHVlcyh0aGlzLnN0YXRlcywgZnVuY3Rpb24gKHN0YXRlTm9kZSwga2V5KSB7XG4gICAgICAgIGlmICghcmVsYXRpdmVTdGF0ZVZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlTm9kZS5oaXN0b3J5VmFsdWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdWJTdGF0ZVZhbHVlID0gaXNTdHJpbmcocmVsYXRpdmVTdGF0ZVZhbHVlKSA/IHVuZGVmaW5lZCA6IHJlbGF0aXZlU3RhdGVWYWx1ZVtrZXldO1xuICAgICAgICByZXR1cm4gc3RhdGVOb2RlLmhpc3RvcnlWYWx1ZShzdWJTdGF0ZVZhbHVlIHx8IHN0YXRlTm9kZS5pbml0aWFsU3RhdGVWYWx1ZSk7XG4gICAgICB9LCBmdW5jdGlvbiAoc3RhdGVOb2RlKSB7XG4gICAgICAgIHJldHVybiAhc3RhdGVOb2RlLmhpc3Rvcnk7XG4gICAgICB9KVxuICAgIH07XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlc29sdmVzIHRvIHRoZSBoaXN0b3JpY2FsIHZhbHVlKHMpIG9mIHRoZSBwYXJlbnQgc3RhdGUgbm9kZSxcclxuICAgKiByZXByZXNlbnRlZCBieSBzdGF0ZSBub2Rlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBoaXN0b3J5VmFsdWVcclxuICAgKi9cblxuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUucmVzb2x2ZUhpc3RvcnkgPSBmdW5jdGlvbiAoaGlzdG9yeVZhbHVlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdoaXN0b3J5Jykge1xuICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cbiAgICBpZiAoIWhpc3RvcnlWYWx1ZSkge1xuICAgICAgdmFyIGhpc3RvcnlUYXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgIHJldHVybiBoaXN0b3J5VGFyZ2V0ID8gZmxhdHRlbih0b1N0YXRlUGF0aHMoaGlzdG9yeVRhcmdldCkubWFwKGZ1bmN0aW9uIChyZWxhdGl2ZUNoaWxkUGF0aCkge1xuICAgICAgICByZXR1cm4gcGFyZW50LmdldEZyb21SZWxhdGl2ZVBhdGgocmVsYXRpdmVDaGlsZFBhdGgpO1xuICAgICAgfSkpIDogcGFyZW50LmluaXRpYWxTdGF0ZU5vZGVzO1xuICAgIH1cblxuICAgIHZhciBzdWJIaXN0b3J5VmFsdWUgPSBuZXN0ZWRQYXRoKHBhcmVudC5wYXRoLCAnc3RhdGVzJykoaGlzdG9yeVZhbHVlKS5jdXJyZW50O1xuXG4gICAgaWYgKGlzU3RyaW5nKHN1Ykhpc3RvcnlWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBbcGFyZW50LmdldFN0YXRlTm9kZShzdWJIaXN0b3J5VmFsdWUpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmxhdHRlbih0b1N0YXRlUGF0aHMoc3ViSGlzdG9yeVZhbHVlKS5tYXAoZnVuY3Rpb24gKHN1YlN0YXRlUGF0aCkge1xuICAgICAgcmV0dXJuIF90aGlzLmhpc3RvcnkgPT09ICdkZWVwJyA/IHBhcmVudC5nZXRGcm9tUmVsYXRpdmVQYXRoKHN1YlN0YXRlUGF0aCkgOiBbcGFyZW50LnN0YXRlc1tzdWJTdGF0ZVBhdGhbMF1dXTtcbiAgICB9KSk7XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlTm9kZS5wcm90b3R5cGUsIFwic3RhdGVJZHNcIiwge1xuICAgIC8qKlxyXG4gICAgICogQWxsIHRoZSBzdGF0ZSBub2RlIElEcyBvZiB0aGlzIHN0YXRlIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50IHN0YXRlIG5vZGVzLlxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgY2hpbGRTdGF0ZUlkcyA9IGZsYXR0ZW4oT2JqZWN0LmtleXModGhpcy5zdGF0ZXMpLm1hcChmdW5jdGlvbiAoc3RhdGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnN0YXRlc1tzdGF0ZUtleV0uc3RhdGVJZHM7XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gW3RoaXMuaWRdLmNvbmNhdChjaGlsZFN0YXRlSWRzKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlTm9kZS5wcm90b3R5cGUsIFwiZXZlbnRzXCIsIHtcbiAgICAvKipcclxuICAgICAqIEFsbCB0aGUgZXZlbnQgdHlwZXMgYWNjZXB0ZWQgYnkgdGhpcyBzdGF0ZSBub2RlIGFuZCBpdHMgZGVzY2VuZGFudHMuXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlXzgsIF9hLCBlXzksIF9iO1xuXG4gICAgICBpZiAodGhpcy5fX2NhY2hlLmV2ZW50cykge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLmV2ZW50cztcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlcyA9IHRoaXMuc3RhdGVzO1xuICAgICAgdmFyIGV2ZW50cyA9IG5ldyBTZXQodGhpcy5vd25FdmVudHMpO1xuXG4gICAgICBpZiAoc3RhdGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhzdGF0ZXMpKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlSWQgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0YXRlc1tzdGF0ZUlkXTtcblxuICAgICAgICAgICAgaWYgKHN0YXRlLnN0YXRlcykge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9lID0gKGVfOSA9IHZvaWQgMCwgX192YWx1ZXMoc3RhdGUuZXZlbnRzKSksIF9mID0gX2UubmV4dCgpOyAhX2YuZG9uZTsgX2YgPSBfZS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBldmVudF8xID0gX2YudmFsdWU7XG4gICAgICAgICAgICAgICAgICBldmVudHMuYWRkKFwiXCIuY29uY2F0KGV2ZW50XzEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVfOV8xKSB7XG4gICAgICAgICAgICAgICAgZV85ID0ge1xuICAgICAgICAgICAgICAgICAgZXJyb3I6IGVfOV8xXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfYiA9IF9lLnJldHVybikpIF9iLmNhbGwoX2UpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZV85KSB0aHJvdyBlXzkuZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlXzhfMSkge1xuICAgICAgICAgIGVfOCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBlXzhfMVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGVfOCkgdGhyb3cgZV84LmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX2NhY2hlLmV2ZW50cyA9IEFycmF5LmZyb20oZXZlbnRzKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlTm9kZS5wcm90b3R5cGUsIFwib3duRXZlbnRzXCIsIHtcbiAgICAvKipcclxuICAgICAqIEFsbCB0aGUgZXZlbnRzIHRoYXQgaGF2ZSB0cmFuc2l0aW9ucyBkaXJlY3RseSBmcm9tIHRoaXMgc3RhdGUgbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBFeGNsdWRlcyBhbnkgaW5lcnQgZXZlbnRzLlxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZXZlbnRzID0gbmV3IFNldCh0aGlzLnRyYW5zaXRpb25zLmZpbHRlcihmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gISghdHJhbnNpdGlvbi50YXJnZXQgJiYgIXRyYW5zaXRpb24uYWN0aW9ucy5sZW5ndGggJiYgdHJhbnNpdGlvbi5pbnRlcm5hbCk7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zaXRpb24uZXZlbnRUeXBlO1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZXZlbnRzKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBTdGF0ZU5vZGUucHJvdG90eXBlLnJlc29sdmVUYXJnZXQgPSBmdW5jdGlvbiAoX3RhcmdldCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoX3RhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhbiB1bmRlZmluZWQgdGFyZ2V0IHNpZ25hbHMgdGhhdCB0aGUgc3RhdGUgbm9kZSBzaG91bGQgbm90IHRyYW5zaXRpb24gZnJvbSB0aGF0IHN0YXRlIHdoZW4gcmVjZWl2aW5nIHRoYXQgZXZlbnRcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90YXJnZXQubWFwKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGlmICghaXNTdHJpbmcodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNJbnRlcm5hbFRhcmdldCA9IHRhcmdldFswXSA9PT0gX3RoaXMuZGVsaW1pdGVyOyAvLyBJZiBpbnRlcm5hbCB0YXJnZXQgaXMgZGVmaW5lZCBvbiBtYWNoaW5lLFxuICAgICAgLy8gZG8gbm90IGluY2x1ZGUgbWFjaGluZSBrZXkgb24gdGFyZ2V0XG5cbiAgICAgIGlmIChpc0ludGVybmFsVGFyZ2V0ICYmICFfdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmdldFN0YXRlTm9kZUJ5UGF0aCh0YXJnZXQuc2xpY2UoMSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzb2x2ZWRUYXJnZXQgPSBpc0ludGVybmFsVGFyZ2V0ID8gX3RoaXMua2V5ICsgdGFyZ2V0IDogdGFyZ2V0O1xuXG4gICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHRhcmdldFN0YXRlTm9kZSA9IF90aGlzLnBhcmVudC5nZXRTdGF0ZU5vZGVCeVBhdGgocmVzb2x2ZWRUYXJnZXQpO1xuXG4gICAgICAgICAgcmV0dXJuIHRhcmdldFN0YXRlTm9kZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0cmFuc2l0aW9uIGRlZmluaXRpb24gZm9yIHN0YXRlIG5vZGUgJ1wiLmNvbmNhdChfdGhpcy5pZCwgXCInOlxcblwiKS5jb25jYXQoZXJyLm1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmdldFN0YXRlTm9kZUJ5UGF0aChyZXNvbHZlZFRhcmdldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgU3RhdGVOb2RlLnByb3RvdHlwZS5mb3JtYXRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHRyYW5zaXRpb25Db25maWcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG5vcm1hbGl6ZWRUYXJnZXQgPSBub3JtYWxpemVUYXJnZXQodHJhbnNpdGlvbkNvbmZpZy50YXJnZXQpO1xuICAgIHZhciBpbnRlcm5hbCA9ICdpbnRlcm5hbCcgaW4gdHJhbnNpdGlvbkNvbmZpZyA/IHRyYW5zaXRpb25Db25maWcuaW50ZXJuYWwgOiBub3JtYWxpemVkVGFyZ2V0ID8gbm9ybWFsaXplZFRhcmdldC5zb21lKGZ1bmN0aW9uIChfdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gaXNTdHJpbmcoX3RhcmdldCkgJiYgX3RhcmdldFswXSA9PT0gX3RoaXMuZGVsaW1pdGVyO1xuICAgIH0pIDogdHJ1ZTtcbiAgICB2YXIgZ3VhcmRzID0gdGhpcy5tYWNoaW5lLm9wdGlvbnMuZ3VhcmRzO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLnJlc29sdmVUYXJnZXQobm9ybWFsaXplZFRhcmdldCk7XG5cbiAgICB2YXIgdHJhbnNpdGlvbiA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0cmFuc2l0aW9uQ29uZmlnKSwge1xuICAgICAgYWN0aW9uczogdG9BY3Rpb25PYmplY3RzKHRvQXJyYXkodHJhbnNpdGlvbkNvbmZpZy5hY3Rpb25zKSksXG4gICAgICBjb25kOiB0b0d1YXJkKHRyYW5zaXRpb25Db25maWcuY29uZCwgZ3VhcmRzKSxcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgaW50ZXJuYWw6IGludGVybmFsLFxuICAgICAgZXZlbnRUeXBlOiB0cmFuc2l0aW9uQ29uZmlnLmV2ZW50LFxuICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdHJhbnNpdGlvbiksIHtcbiAgICAgICAgICB0YXJnZXQ6IHRyYW5zaXRpb24udGFyZ2V0ID8gdHJhbnNpdGlvbi50YXJnZXQubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4gXCIjXCIuY29uY2F0KHQuaWQpO1xuICAgICAgICAgIH0pIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHNvdXJjZTogXCIjXCIuY29uY2F0KF90aGlzLmlkKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0cmFuc2l0aW9uO1xuICB9O1xuXG4gIFN0YXRlTm9kZS5wcm90b3R5cGUuZm9ybWF0VHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVfMTAsIF9hO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvbkNvbmZpZztcblxuICAgIGlmICghdGhpcy5jb25maWcub24pIHtcbiAgICAgIG9uQ29uZmlnID0gW107XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY29uZmlnLm9uKSkge1xuICAgICAgb25Db25maWcgPSB0aGlzLmNvbmZpZy5vbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9iID0gdGhpcy5jb25maWcub24sXG4gICAgICAgICAgX2MgPSBXSUxEQ0FSRCxcbiAgICAgICAgICBfZCA9IF9iW19jXSxcbiAgICAgICAgICB3aWxkY2FyZENvbmZpZ3MgPSBfZCA9PT0gdm9pZCAwID8gW10gOiBfZCxcbiAgICAgICAgICBzdHJpY3RUcmFuc2l0aW9uQ29uZmlnc18xID0gX19yZXN0KF9iLCBbdHlwZW9mIF9jID09PSBcInN5bWJvbFwiID8gX2MgOiBfYyArIFwiXCJdKTtcblxuICAgICAgb25Db25maWcgPSBmbGF0dGVuKE9iamVjdC5rZXlzKHN0cmljdFRyYW5zaXRpb25Db25maWdzXzEpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghSVNfUFJPRFVDVElPTiAmJiBrZXkgPT09IE5VTExfRVZFTlQpIHtcbiAgICAgICAgICB3YXJuKGZhbHNlLCBcIkVtcHR5IHN0cmluZyB0cmFuc2l0aW9uIGNvbmZpZ3MgKGUuZy4sIGB7IG9uOiB7ICcnOiAuLi4gfX1gKSBmb3IgdHJhbnNpZW50IHRyYW5zaXRpb25zIGFyZSBkZXByZWNhdGVkLiBTcGVjaWZ5IHRoZSB0cmFuc2l0aW9uIGluIHRoZSBgeyBhbHdheXM6IC4uLiB9YCBwcm9wZXJ0eSBpbnN0ZWFkLiBcIiArIFwiUGxlYXNlIGNoZWNrIHRoZSBgb25gIGNvbmZpZ3VyYXRpb24gZm9yIFxcXCIjXCIuY29uY2F0KF90aGlzLmlkLCBcIlxcXCIuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0cmFuc2l0aW9uQ29uZmlnQXJyYXkgPSB0b1RyYW5zaXRpb25Db25maWdBcnJheShrZXksIHN0cmljdFRyYW5zaXRpb25Db25maWdzXzFba2V5XSk7XG5cbiAgICAgICAgaWYgKCFJU19QUk9EVUNUSU9OKSB7XG4gICAgICAgICAgdmFsaWRhdGVBcnJheWlmaWVkVHJhbnNpdGlvbnMoX3RoaXMsIGtleSwgdHJhbnNpdGlvbkNvbmZpZ0FycmF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmFuc2l0aW9uQ29uZmlnQXJyYXk7XG4gICAgICB9KS5jb25jYXQodG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkoV0lMRENBUkQsIHdpbGRjYXJkQ29uZmlncykpKTtcbiAgICB9XG5cbiAgICB2YXIgZXZlbnRsZXNzQ29uZmlnID0gdGhpcy5jb25maWcuYWx3YXlzID8gdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkoJycsIHRoaXMuY29uZmlnLmFsd2F5cykgOiBbXTtcbiAgICB2YXIgZG9uZUNvbmZpZyA9IHRoaXMuY29uZmlnLm9uRG9uZSA/IHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KFN0cmluZyhkb25lKHRoaXMuaWQpKSwgdGhpcy5jb25maWcub25Eb25lKSA6IFtdO1xuXG4gICAgaWYgKCFJU19QUk9EVUNUSU9OKSB7XG4gICAgICB3YXJuKCEodGhpcy5jb25maWcub25Eb25lICYmICF0aGlzLnBhcmVudCksIFwiUm9vdCBub2RlcyBjYW5ub3QgaGF2ZSBhbiBcXFwiLm9uRG9uZVxcXCIgdHJhbnNpdGlvbi4gUGxlYXNlIGNoZWNrIHRoZSBjb25maWcgb2YgXFxcIlwiLmNvbmNhdCh0aGlzLmlkLCBcIlxcXCIuXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgaW52b2tlQ29uZmlnID0gZmxhdHRlbih0aGlzLmludm9rZS5tYXAoZnVuY3Rpb24gKGludm9rZURlZikge1xuICAgICAgdmFyIHNldHRsZVRyYW5zaXRpb25zID0gW107XG5cbiAgICAgIGlmIChpbnZva2VEZWYub25Eb25lKSB7XG4gICAgICAgIHNldHRsZVRyYW5zaXRpb25zLnB1c2guYXBwbHkoc2V0dGxlVHJhbnNpdGlvbnMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZCh0b1RyYW5zaXRpb25Db25maWdBcnJheShTdHJpbmcoZG9uZUludm9rZShpbnZva2VEZWYuaWQpKSwgaW52b2tlRGVmLm9uRG9uZSkpLCBmYWxzZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW52b2tlRGVmLm9uRXJyb3IpIHtcbiAgICAgICAgc2V0dGxlVHJhbnNpdGlvbnMucHVzaC5hcHBseShzZXR0bGVUcmFuc2l0aW9ucywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KFN0cmluZyhlcnJvcihpbnZva2VEZWYuaWQpKSwgaW52b2tlRGVmLm9uRXJyb3IpKSwgZmFsc2UpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldHRsZVRyYW5zaXRpb25zO1xuICAgIH0pKTtcbiAgICB2YXIgZGVsYXllZFRyYW5zaXRpb25zID0gdGhpcy5hZnRlcjtcbiAgICB2YXIgZm9ybWF0dGVkVHJhbnNpdGlvbnMgPSBmbGF0dGVuKF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChkb25lQ29uZmlnKSwgZmFsc2UpLCBfX3JlYWQoaW52b2tlQ29uZmlnKSwgZmFsc2UpLCBfX3JlYWQob25Db25maWcpLCBmYWxzZSksIF9fcmVhZChldmVudGxlc3NDb25maWcpLCBmYWxzZSkubWFwKGZ1bmN0aW9uICh0cmFuc2l0aW9uQ29uZmlnKSB7XG4gICAgICByZXR1cm4gdG9BcnJheSh0cmFuc2l0aW9uQ29uZmlnKS5tYXAoZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmZvcm1hdFRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gICAgICB9KTtcbiAgICB9KSk7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgZGVsYXllZFRyYW5zaXRpb25zXzEgPSBfX3ZhbHVlcyhkZWxheWVkVHJhbnNpdGlvbnMpLCBkZWxheWVkVHJhbnNpdGlvbnNfMV8xID0gZGVsYXllZFRyYW5zaXRpb25zXzEubmV4dCgpOyAhZGVsYXllZFRyYW5zaXRpb25zXzFfMS5kb25lOyBkZWxheWVkVHJhbnNpdGlvbnNfMV8xID0gZGVsYXllZFRyYW5zaXRpb25zXzEubmV4dCgpKSB7XG4gICAgICAgIHZhciBkZWxheWVkVHJhbnNpdGlvbiA9IGRlbGF5ZWRUcmFuc2l0aW9uc18xXzEudmFsdWU7XG4gICAgICAgIGZvcm1hdHRlZFRyYW5zaXRpb25zLnB1c2goZGVsYXllZFRyYW5zaXRpb24pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfMTBfMSkge1xuICAgICAgZV8xMCA9IHtcbiAgICAgICAgZXJyb3I6IGVfMTBfMVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGRlbGF5ZWRUcmFuc2l0aW9uc18xXzEgJiYgIWRlbGF5ZWRUcmFuc2l0aW9uc18xXzEuZG9uZSAmJiAoX2EgPSBkZWxheWVkVHJhbnNpdGlvbnNfMS5yZXR1cm4pKSBfYS5jYWxsKGRlbGF5ZWRUcmFuc2l0aW9uc18xKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzEwKSB0aHJvdyBlXzEwLmVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXR0ZWRUcmFuc2l0aW9ucztcbiAgfTtcblxuICByZXR1cm4gU3RhdGVOb2RlO1xufSgpO1xuXG5leHBvcnQgeyBTdGF0ZU5vZGUgfTtcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxuXG5leHBvcnQgeyBfX2Fzc2lnbiwgX19yZWFkLCBfX3Jlc3QsIF9fc3ByZWFkQXJyYXksIF9fdmFsdWVzIH07XG4iLCJpbXBvcnQgeyBBY3Rpb25UeXBlcyB9IGZyb20gJy4vdHlwZXMuanMnO1xuXG52YXIgc3RhcnQgPSBBY3Rpb25UeXBlcy5TdGFydDtcbnZhciBzdG9wID0gQWN0aW9uVHlwZXMuU3RvcDtcbnZhciByYWlzZSA9IEFjdGlvblR5cGVzLlJhaXNlO1xudmFyIHNlbmQgPSBBY3Rpb25UeXBlcy5TZW5kO1xudmFyIGNhbmNlbCA9IEFjdGlvblR5cGVzLkNhbmNlbDtcbnZhciBudWxsRXZlbnQgPSBBY3Rpb25UeXBlcy5OdWxsRXZlbnQ7XG52YXIgYXNzaWduID0gQWN0aW9uVHlwZXMuQXNzaWduO1xudmFyIGFmdGVyID0gQWN0aW9uVHlwZXMuQWZ0ZXI7XG52YXIgZG9uZVN0YXRlID0gQWN0aW9uVHlwZXMuRG9uZVN0YXRlO1xudmFyIGxvZyA9IEFjdGlvblR5cGVzLkxvZztcbnZhciBpbml0ID0gQWN0aW9uVHlwZXMuSW5pdDtcbnZhciBpbnZva2UgPSBBY3Rpb25UeXBlcy5JbnZva2U7XG52YXIgZXJyb3JFeGVjdXRpb24gPSBBY3Rpb25UeXBlcy5FcnJvckV4ZWN1dGlvbjtcbnZhciBlcnJvclBsYXRmb3JtID0gQWN0aW9uVHlwZXMuRXJyb3JQbGF0Zm9ybTtcbnZhciBlcnJvciA9IEFjdGlvblR5cGVzLkVycm9yQ3VzdG9tO1xudmFyIHVwZGF0ZSA9IEFjdGlvblR5cGVzLlVwZGF0ZTtcbnZhciBjaG9vc2UgPSBBY3Rpb25UeXBlcy5DaG9vc2U7XG52YXIgcHVyZSA9IEFjdGlvblR5cGVzLlB1cmU7XG5cbmV4cG9ydCB7IGFmdGVyLCBhc3NpZ24sIGNhbmNlbCwgY2hvb3NlLCBkb25lU3RhdGUsIGVycm9yLCBlcnJvckV4ZWN1dGlvbiwgZXJyb3JQbGF0Zm9ybSwgaW5pdCwgaW52b2tlLCBsb2csIG51bGxFdmVudCwgcHVyZSwgcmFpc2UsIHNlbmQsIHN0YXJ0LCBzdG9wLCB1cGRhdGUgfTtcbiIsImltcG9ydCB7IF9fYXNzaWduLCBfX3NwcmVhZEFycmF5LCBfX3JlYWQsIF9fdmFsdWVzIH0gZnJvbSAnLi9fdmlydHVhbC9fdHNsaWIuanMnO1xuaW1wb3J0IHsgU3BlY2lhbFRhcmdldHMsIEFjdGlvblR5cGVzIH0gZnJvbSAnLi90eXBlcy5qcyc7XG5pbXBvcnQgeyBpbml0LCByYWlzZSBhcyByYWlzZSQxLCBzZW5kIGFzIHNlbmQkMSwgdXBkYXRlLCBsb2cgYXMgbG9nJDEsIGNhbmNlbCBhcyBjYW5jZWwkMSwgYXNzaWduIGFzIGFzc2lnbiQxLCBlcnJvciBhcyBlcnJvciQxLCBzdG9wIGFzIHN0b3AkMSwgcHVyZSBhcyBwdXJlJDEsIGNob29zZSBhcyBjaG9vc2UkMSB9IGZyb20gJy4vYWN0aW9uVHlwZXMuanMnO1xuaW1wb3J0ICogYXMgYWN0aW9uVHlwZXMgZnJvbSAnLi9hY3Rpb25UeXBlcy5qcyc7XG5leHBvcnQgeyBhY3Rpb25UeXBlcyB9O1xuaW1wb3J0IHsgdG9TQ1hNTEV2ZW50LCBpc1N0cmluZywgaXNGdW5jdGlvbiwgdG9FdmVudE9iamVjdCwgZ2V0RXZlbnRUeXBlLCB1cGRhdGVDb250ZXh0LCBmbGF0dGVuLCBpc0FycmF5LCB0b0FycmF5LCB0b0d1YXJkLCBldmFsdWF0ZUd1YXJkLCB3YXJuIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBJU19QUk9EVUNUSU9OIH0gZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5cbnZhciBpbml0RXZlbnQgPSAvKiNfX1BVUkVfXyovdG9TQ1hNTEV2ZW50KHtcbiAgdHlwZTogaW5pdFxufSk7XG5mdW5jdGlvbiBnZXRBY3Rpb25GdW5jdGlvbihhY3Rpb25UeXBlLCBhY3Rpb25GdW5jdGlvbk1hcCkge1xuICByZXR1cm4gYWN0aW9uRnVuY3Rpb25NYXAgPyBhY3Rpb25GdW5jdGlvbk1hcFthY3Rpb25UeXBlXSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiB0b0FjdGlvbk9iamVjdChhY3Rpb24sIGFjdGlvbkZ1bmN0aW9uTWFwKSB7XG4gIHZhciBhY3Rpb25PYmplY3Q7XG5cbiAgaWYgKGlzU3RyaW5nKGFjdGlvbikgfHwgdHlwZW9mIGFjdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgZXhlYyA9IGdldEFjdGlvbkZ1bmN0aW9uKGFjdGlvbiwgYWN0aW9uRnVuY3Rpb25NYXApO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXhlYykpIHtcbiAgICAgIGFjdGlvbk9iamVjdCA9IHtcbiAgICAgICAgdHlwZTogYWN0aW9uLFxuICAgICAgICBleGVjOiBleGVjXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZXhlYykge1xuICAgICAgYWN0aW9uT2JqZWN0ID0gZXhlYztcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0aW9uT2JqZWN0ID0ge1xuICAgICAgICB0eXBlOiBhY3Rpb24sXG4gICAgICAgIGV4ZWM6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihhY3Rpb24pKSB7XG4gICAgYWN0aW9uT2JqZWN0ID0ge1xuICAgICAgLy8gQ29udmVydCBhY3Rpb24gdG8gc3RyaW5nIGlmIHVubmFtZWRcbiAgICAgIHR5cGU6IGFjdGlvbi5uYW1lIHx8IGFjdGlvbi50b1N0cmluZygpLFxuICAgICAgZXhlYzogYWN0aW9uXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXhlYyA9IGdldEFjdGlvbkZ1bmN0aW9uKGFjdGlvbi50eXBlLCBhY3Rpb25GdW5jdGlvbk1hcCk7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihleGVjKSkge1xuICAgICAgYWN0aW9uT2JqZWN0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGFjdGlvbiksIHtcbiAgICAgICAgZXhlYzogZXhlY1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChleGVjKSB7XG4gICAgICB2YXIgYWN0aW9uVHlwZSA9IGV4ZWMudHlwZSB8fCBhY3Rpb24udHlwZTtcbiAgICAgIGFjdGlvbk9iamVjdCA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBleGVjKSwgYWN0aW9uKSwge1xuICAgICAgICB0eXBlOiBhY3Rpb25UeXBlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0aW9uT2JqZWN0ID0gYWN0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhY3Rpb25PYmplY3Q7XG59XG52YXIgdG9BY3Rpb25PYmplY3RzID0gZnVuY3Rpb24gKGFjdGlvbiwgYWN0aW9uRnVuY3Rpb25NYXApIHtcbiAgaWYgKCFhY3Rpb24pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgYWN0aW9ucyA9IGlzQXJyYXkoYWN0aW9uKSA/IGFjdGlvbiA6IFthY3Rpb25dO1xuICByZXR1cm4gYWN0aW9ucy5tYXAoZnVuY3Rpb24gKHN1YkFjdGlvbikge1xuICAgIHJldHVybiB0b0FjdGlvbk9iamVjdChzdWJBY3Rpb24sIGFjdGlvbkZ1bmN0aW9uTWFwKTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gdG9BY3Rpdml0eURlZmluaXRpb24oYWN0aW9uKSB7XG4gIHZhciBhY3Rpb25PYmplY3QgPSB0b0FjdGlvbk9iamVjdChhY3Rpb24pO1xuICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe1xuICAgIGlkOiBpc1N0cmluZyhhY3Rpb24pID8gYWN0aW9uIDogYWN0aW9uT2JqZWN0LmlkXG4gIH0sIGFjdGlvbk9iamVjdCksIHtcbiAgICB0eXBlOiBhY3Rpb25PYmplY3QudHlwZVxuICB9KTtcbn1cbi8qKlxyXG4gKiBSYWlzZXMgYW4gZXZlbnQuIFRoaXMgcGxhY2VzIHRoZSBldmVudCBpbiB0aGUgaW50ZXJuYWwgZXZlbnQgcXVldWUsIHNvIHRoYXRcclxuICogdGhlIGV2ZW50IGlzIGltbWVkaWF0ZWx5IGNvbnN1bWVkIGJ5IHRoZSBtYWNoaW5lIGluIHRoZSBjdXJyZW50IHN0ZXAuXHJcbiAqXHJcbiAqIEBwYXJhbSBldmVudFR5cGUgVGhlIGV2ZW50IHRvIHJhaXNlLlxyXG4gKi9cblxuZnVuY3Rpb24gcmFpc2UoZXZlbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiByYWlzZSQxLFxuICAgIGV2ZW50OiB0eXBlb2YgZXZlbnQgPT09ICdmdW5jdGlvbicgPyBldmVudCA6IHRvRXZlbnRPYmplY3QoZXZlbnQpLFxuICAgIGRlbGF5OiBvcHRpb25zID8gb3B0aW9ucy5kZWxheSA6IHVuZGVmaW5lZCxcbiAgICBpZDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlkXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlUmFpc2UoYWN0aW9uLCBjdHgsIF9ldmVudCwgZGVsYXlzTWFwKSB7XG4gIHZhciBtZXRhID0ge1xuICAgIF9ldmVudDogX2V2ZW50XG4gIH07XG4gIHZhciByZXNvbHZlZEV2ZW50ID0gdG9TQ1hNTEV2ZW50KGlzRnVuY3Rpb24oYWN0aW9uLmV2ZW50KSA/IGFjdGlvbi5ldmVudChjdHgsIF9ldmVudC5kYXRhLCBtZXRhKSA6IGFjdGlvbi5ldmVudCk7XG4gIHZhciByZXNvbHZlZERlbGF5O1xuXG4gIGlmIChpc1N0cmluZyhhY3Rpb24uZGVsYXkpKSB7XG4gICAgdmFyIGNvbmZpZ0RlbGF5ID0gZGVsYXlzTWFwICYmIGRlbGF5c01hcFthY3Rpb24uZGVsYXldO1xuICAgIHJlc29sdmVkRGVsYXkgPSBpc0Z1bmN0aW9uKGNvbmZpZ0RlbGF5KSA/IGNvbmZpZ0RlbGF5KGN0eCwgX2V2ZW50LmRhdGEsIG1ldGEpIDogY29uZmlnRGVsYXk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWREZWxheSA9IGlzRnVuY3Rpb24oYWN0aW9uLmRlbGF5KSA/IGFjdGlvbi5kZWxheShjdHgsIF9ldmVudC5kYXRhLCBtZXRhKSA6IGFjdGlvbi5kZWxheTtcbiAgfVxuXG4gIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYWN0aW9uKSwge1xuICAgIHR5cGU6IHJhaXNlJDEsXG4gICAgX2V2ZW50OiByZXNvbHZlZEV2ZW50LFxuICAgIGRlbGF5OiByZXNvbHZlZERlbGF5XG4gIH0pO1xufVxuLyoqXHJcbiAqIFNlbmRzIGFuIGV2ZW50LiBUaGlzIHJldHVybnMgYW4gYWN0aW9uIHRoYXQgd2lsbCBiZSByZWFkIGJ5IGFuIGludGVycHJldGVyIHRvXHJcbiAqIHNlbmQgdGhlIGV2ZW50IGluIHRoZSBuZXh0IHN0ZXAsIGFmdGVyIHRoZSBjdXJyZW50IHN0ZXAgaXMgZmluaXNoZWQgZXhlY3V0aW5nLlxyXG4gKlxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBzZW5kVG8oLi4uKWAgYWN0aW9uIGNyZWF0b3IgaW5zdGVhZC5cclxuICpcclxuICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBzZW5kLlxyXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIHBhc3MgaW50byB0aGUgc2VuZCBldmVudDpcclxuICogIC0gYGlkYCAtIFRoZSB1bmlxdWUgc2VuZCBldmVudCBpZGVudGlmaWVyICh1c2VkIHdpdGggYGNhbmNlbCgpYCkuXHJcbiAqICAtIGBkZWxheWAgLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSB0aGUgc2VuZGluZyBvZiB0aGUgZXZlbnQuXHJcbiAqICAtIGB0b2AgLSBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQgKGJ5IGRlZmF1bHQsIHRoZSBtYWNoaW5lIHRoZSBldmVudCB3YXMgc2VudCBmcm9tKS5cclxuICovXG5cbmZ1bmN0aW9uIHNlbmQoZXZlbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICB0bzogb3B0aW9ucyA/IG9wdGlvbnMudG8gOiB1bmRlZmluZWQsXG4gICAgdHlwZTogc2VuZCQxLFxuICAgIGV2ZW50OiBpc0Z1bmN0aW9uKGV2ZW50KSA/IGV2ZW50IDogdG9FdmVudE9iamVjdChldmVudCksXG4gICAgZGVsYXk6IG9wdGlvbnMgPyBvcHRpb25zLmRlbGF5IDogdW5kZWZpbmVkLFxuICAgIC8vIFRPRE86IGRvbid0IGF1dG8tZ2VuZXJhdGUgSURzIGhlcmUgbGlrZSB0aGF0XG4gICAgLy8gdGhlcmUgaXMgdG9vIGJpZyBjaGFuY2Ugb2YgdGhlIElEIGNvbGxpc2lvblxuICAgIGlkOiBvcHRpb25zICYmIG9wdGlvbnMuaWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaWQgOiBpc0Z1bmN0aW9uKGV2ZW50KSA/IGV2ZW50Lm5hbWUgOiBnZXRFdmVudFR5cGUoZXZlbnQpXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlU2VuZChhY3Rpb24sIGN0eCwgX2V2ZW50LCBkZWxheXNNYXApIHtcbiAgdmFyIG1ldGEgPSB7XG4gICAgX2V2ZW50OiBfZXZlbnRcbiAgfTsgLy8gVE9ETzogaGVscGVyIGZ1bmN0aW9uIGZvciByZXNvbHZpbmcgRXhwclxuXG4gIHZhciByZXNvbHZlZEV2ZW50ID0gdG9TQ1hNTEV2ZW50KGlzRnVuY3Rpb24oYWN0aW9uLmV2ZW50KSA/IGFjdGlvbi5ldmVudChjdHgsIF9ldmVudC5kYXRhLCBtZXRhKSA6IGFjdGlvbi5ldmVudCk7XG4gIHZhciByZXNvbHZlZERlbGF5O1xuXG4gIGlmIChpc1N0cmluZyhhY3Rpb24uZGVsYXkpKSB7XG4gICAgdmFyIGNvbmZpZ0RlbGF5ID0gZGVsYXlzTWFwICYmIGRlbGF5c01hcFthY3Rpb24uZGVsYXldO1xuICAgIHJlc29sdmVkRGVsYXkgPSBpc0Z1bmN0aW9uKGNvbmZpZ0RlbGF5KSA/IGNvbmZpZ0RlbGF5KGN0eCwgX2V2ZW50LmRhdGEsIG1ldGEpIDogY29uZmlnRGVsYXk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWREZWxheSA9IGlzRnVuY3Rpb24oYWN0aW9uLmRlbGF5KSA/IGFjdGlvbi5kZWxheShjdHgsIF9ldmVudC5kYXRhLCBtZXRhKSA6IGFjdGlvbi5kZWxheTtcbiAgfVxuXG4gIHZhciByZXNvbHZlZFRhcmdldCA9IGlzRnVuY3Rpb24oYWN0aW9uLnRvKSA/IGFjdGlvbi50byhjdHgsIF9ldmVudC5kYXRhLCBtZXRhKSA6IGFjdGlvbi50bztcbiAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBhY3Rpb24pLCB7XG4gICAgdG86IHJlc29sdmVkVGFyZ2V0LFxuICAgIF9ldmVudDogcmVzb2x2ZWRFdmVudCxcbiAgICBldmVudDogcmVzb2x2ZWRFdmVudC5kYXRhLFxuICAgIGRlbGF5OiByZXNvbHZlZERlbGF5XG4gIH0pO1xufVxuLyoqXHJcbiAqIFNlbmRzIGFuIGV2ZW50IHRvIHRoaXMgbWFjaGluZSdzIHBhcmVudC5cclxuICpcclxuICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBzZW5kIHRvIHRoZSBwYXJlbnQgbWFjaGluZS5cclxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIGludG8gdGhlIHNlbmQgZXZlbnQuXHJcbiAqL1xuXG5mdW5jdGlvbiBzZW5kUGFyZW50KGV2ZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBzZW5kKGV2ZW50LCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHtcbiAgICB0bzogU3BlY2lhbFRhcmdldHMuUGFyZW50XG4gIH0pKTtcbn1cbi8qKlxyXG4gKiBTZW5kcyBhbiBldmVudCB0byBhbiBhY3Rvci5cclxuICpcclxuICogQHBhcmFtIGFjdG9yIFRoZSBgQWN0b3JSZWZgIHRvIHNlbmQgdGhlIGV2ZW50IHRvLlxyXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHNlbmQsIG9yIGFuIGV4cHJlc3Npb24gdGhhdCBldmFsdWF0ZXMgdG8gdGhlIGV2ZW50IHRvIHNlbmRcclxuICogQHBhcmFtIG9wdGlvbnMgU2VuZCBhY3Rpb24gb3B0aW9uc1xyXG4gKiBAcmV0dXJucyBBbiBYU3RhdGUgc2VuZCBhY3Rpb24gb2JqZWN0XHJcbiAqL1xuXG5mdW5jdGlvbiBzZW5kVG8oYWN0b3IsIGV2ZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBzZW5kKGV2ZW50LCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHtcbiAgICB0bzogYWN0b3JcbiAgfSkpO1xufVxuLyoqXHJcbiAqIFNlbmRzIGFuIHVwZGF0ZSBldmVudCB0byB0aGlzIG1hY2hpbmUncyBwYXJlbnQuXHJcbiAqL1xuXG5mdW5jdGlvbiBzZW5kVXBkYXRlKCkge1xuICByZXR1cm4gc2VuZFBhcmVudCh1cGRhdGUpO1xufVxuLyoqXHJcbiAqIFNlbmRzIGFuIGV2ZW50IGJhY2sgdG8gdGhlIHNlbmRlciBvZiB0aGUgb3JpZ2luYWwgZXZlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gc2VuZCBiYWNrIHRvIHRoZSBzZW5kZXJcclxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIGludG8gdGhlIHNlbmQgZXZlbnRcclxuICovXG5cbmZ1bmN0aW9uIHJlc3BvbmQoZXZlbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNlbmQoZXZlbnQsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgIHRvOiBmdW5jdGlvbiAoXywgX18sIF9hKSB7XG4gICAgICB2YXIgX2V2ZW50ID0gX2EuX2V2ZW50O1xuICAgICAgcmV0dXJuIF9ldmVudC5vcmlnaW47IC8vIFRPRE86IGhhbmRsZSB3aGVuIF9ldmVudC5vcmlnaW4gaXMgdW5kZWZpbmVkXG4gICAgfVxuICB9KSk7XG59XG5cbnZhciBkZWZhdWx0TG9nRXhwciA9IGZ1bmN0aW9uIChjb250ZXh0LCBldmVudCkge1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgZXZlbnQ6IGV2ZW50XG4gIH07XG59O1xuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBleHByIFRoZSBleHByZXNzaW9uIGZ1bmN0aW9uIHRvIGV2YWx1YXRlIHdoaWNoIHdpbGwgYmUgbG9nZ2VkLlxyXG4gKiAgVGFrZXMgaW4gMiBhcmd1bWVudHM6XHJcbiAqICAtIGBjdHhgIC0gdGhlIGN1cnJlbnQgc3RhdGUgY29udGV4dFxyXG4gKiAgLSBgZXZlbnRgIC0gdGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxyXG4gKiBAcGFyYW0gbGFiZWwgVGhlIGxhYmVsIHRvIGdpdmUgdG8gdGhlIGxvZ2dlZCBleHByZXNzaW9uLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBsb2coZXhwciwgbGFiZWwpIHtcbiAgaWYgKGV4cHIgPT09IHZvaWQgMCkge1xuICAgIGV4cHIgPSBkZWZhdWx0TG9nRXhwcjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogbG9nJDEsXG4gICAgbGFiZWw6IGxhYmVsLFxuICAgIGV4cHI6IGV4cHJcbiAgfTtcbn1cbnZhciByZXNvbHZlTG9nID0gZnVuY3Rpb24gKGFjdGlvbiwgY3R4LCBfZXZlbnQpIHtcbiAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBhY3Rpb24pLCB7XG4gICAgdmFsdWU6IGlzU3RyaW5nKGFjdGlvbi5leHByKSA/IGFjdGlvbi5leHByIDogYWN0aW9uLmV4cHIoY3R4LCBfZXZlbnQuZGF0YSwge1xuICAgICAgX2V2ZW50OiBfZXZlbnRcbiAgICB9KVxuICB9KTtcbn07XG4vKipcclxuICogQ2FuY2VscyBhbiBpbi1mbGlnaHQgYHNlbmQoLi4uKWAgYWN0aW9uLiBBIGNhbmNlbGVkIHNlbnQgYWN0aW9uIHdpbGwgbm90XHJcbiAqIGJlIGV4ZWN1dGVkLCBub3Igd2lsbCBpdHMgZXZlbnQgYmUgc2VudCwgdW5sZXNzIGl0IGhhcyBhbHJlYWR5IGJlZW4gc2VudFxyXG4gKiAoZS5nLiwgaWYgYGNhbmNlbCguLi4pYCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGBzZW5kKC4uLilgIGFjdGlvbidzIGBkZWxheWApLlxyXG4gKlxyXG4gKiBAcGFyYW0gc2VuZElkIFRoZSBgaWRgIG9mIHRoZSBgc2VuZCguLi4pYCBhY3Rpb24gdG8gY2FuY2VsLlxyXG4gKi9cblxudmFyIGNhbmNlbCA9IGZ1bmN0aW9uIChzZW5kSWQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBjYW5jZWwkMSxcbiAgICBzZW5kSWQ6IHNlbmRJZFxuICB9O1xufTtcbi8qKlxyXG4gKiBTdGFydHMgYW4gYWN0aXZpdHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBhY3Rpdml0eSBUaGUgYWN0aXZpdHkgdG8gc3RhcnQuXHJcbiAqL1xuXG5mdW5jdGlvbiBzdGFydChhY3Rpdml0eSkge1xuICB2YXIgYWN0aXZpdHlEZWYgPSB0b0FjdGl2aXR5RGVmaW5pdGlvbihhY3Rpdml0eSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQWN0aW9uVHlwZXMuU3RhcnQsXG4gICAgYWN0aXZpdHk6IGFjdGl2aXR5RGVmLFxuICAgIGV4ZWM6IHVuZGVmaW5lZFxuICB9O1xufVxuLyoqXHJcbiAqIFN0b3BzIGFuIGFjdGl2aXR5LlxyXG4gKlxyXG4gKiBAcGFyYW0gYWN0b3JSZWYgVGhlIGFjdGl2aXR5IHRvIHN0b3AuXHJcbiAqL1xuXG5mdW5jdGlvbiBzdG9wKGFjdG9yUmVmKSB7XG4gIHZhciBhY3Rpdml0eSA9IGlzRnVuY3Rpb24oYWN0b3JSZWYpID8gYWN0b3JSZWYgOiB0b0FjdGl2aXR5RGVmaW5pdGlvbihhY3RvclJlZik7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQWN0aW9uVHlwZXMuU3RvcCxcbiAgICBhY3Rpdml0eTogYWN0aXZpdHksXG4gICAgZXhlYzogdW5kZWZpbmVkXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlU3RvcChhY3Rpb24sIGNvbnRleHQsIF9ldmVudCkge1xuICB2YXIgYWN0b3JSZWZPclN0cmluZyA9IGlzRnVuY3Rpb24oYWN0aW9uLmFjdGl2aXR5KSA/IGFjdGlvbi5hY3Rpdml0eShjb250ZXh0LCBfZXZlbnQuZGF0YSkgOiBhY3Rpb24uYWN0aXZpdHk7XG4gIHZhciByZXNvbHZlZEFjdG9yUmVmID0gdHlwZW9mIGFjdG9yUmVmT3JTdHJpbmcgPT09ICdzdHJpbmcnID8ge1xuICAgIGlkOiBhY3RvclJlZk9yU3RyaW5nXG4gIH0gOiBhY3RvclJlZk9yU3RyaW5nO1xuICB2YXIgYWN0aW9uT2JqZWN0ID0ge1xuICAgIHR5cGU6IEFjdGlvblR5cGVzLlN0b3AsXG4gICAgYWN0aXZpdHk6IHJlc29sdmVkQWN0b3JSZWZcbiAgfTtcbiAgcmV0dXJuIGFjdGlvbk9iamVjdDtcbn1cbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSBjdXJyZW50IGNvbnRleHQgb2YgdGhlIG1hY2hpbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhc3NpZ25tZW50IEFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhcnRpYWwgY29udGV4dCB0byB1cGRhdGUuXHJcbiAqL1xuXG52YXIgYXNzaWduID0gZnVuY3Rpb24gKGFzc2lnbm1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBhc3NpZ24kMSxcbiAgICBhc3NpZ25tZW50OiBhc3NpZ25tZW50XG4gIH07XG59O1xuZnVuY3Rpb24gaXNBY3Rpb25PYmplY3QoYWN0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnb2JqZWN0JyAmJiAndHlwZScgaW4gYWN0aW9uO1xufVxuLyoqXHJcbiAqIFJldHVybnMgYW4gZXZlbnQgdHlwZSB0aGF0IHJlcHJlc2VudHMgYW4gaW1wbGljaXQgZXZlbnQgdGhhdFxyXG4gKiBpcyBzZW50IGFmdGVyIHRoZSBzcGVjaWZpZWQgYGRlbGF5YC5cclxuICpcclxuICogQHBhcmFtIGRlbGF5UmVmIFRoZSBkZWxheSBpbiBtaWxsaXNlY29uZHNcclxuICogQHBhcmFtIGlkIFRoZSBzdGF0ZSBub2RlIElEIHdoZXJlIHRoaXMgZXZlbnQgaXMgaGFuZGxlZFxyXG4gKi9cblxuZnVuY3Rpb24gYWZ0ZXIoZGVsYXlSZWYsIGlkKSB7XG4gIHZhciBpZFN1ZmZpeCA9IGlkID8gXCIjXCIuY29uY2F0KGlkKSA6ICcnO1xuICByZXR1cm4gXCJcIi5jb25jYXQoQWN0aW9uVHlwZXMuQWZ0ZXIsIFwiKFwiKS5jb25jYXQoZGVsYXlSZWYsIFwiKVwiKS5jb25jYXQoaWRTdWZmaXgpO1xufVxuLyoqXHJcbiAqIFJldHVybnMgYW4gZXZlbnQgdGhhdCByZXByZXNlbnRzIHRoYXQgYSBmaW5hbCBzdGF0ZSBub2RlXHJcbiAqIGhhcyBiZWVuIHJlYWNoZWQgaW4gdGhlIHBhcmVudCBzdGF0ZSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gaWQgVGhlIGZpbmFsIHN0YXRlIG5vZGUncyBwYXJlbnQgc3RhdGUgbm9kZSBgaWRgXHJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIHBhc3MgaW50byB0aGUgZXZlbnRcclxuICovXG5cbmZ1bmN0aW9uIGRvbmUoaWQsIGRhdGEpIHtcbiAgdmFyIHR5cGUgPSBcIlwiLmNvbmNhdChBY3Rpb25UeXBlcy5Eb25lU3RhdGUsIFwiLlwiKS5jb25jYXQoaWQpO1xuICB2YXIgZXZlbnRPYmplY3QgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBkYXRhOiBkYXRhXG4gIH07XG5cbiAgZXZlbnRPYmplY3QudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH07XG5cbiAgcmV0dXJuIGV2ZW50T2JqZWN0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYW4gZXZlbnQgdGhhdCByZXByZXNlbnRzIHRoYXQgYW4gaW52b2tlZCBzZXJ2aWNlIGhhcyB0ZXJtaW5hdGVkLlxyXG4gKlxyXG4gKiBBbiBpbnZva2VkIHNlcnZpY2UgaXMgdGVybWluYXRlZCB3aGVuIGl0IGhhcyByZWFjaGVkIGEgdG9wLWxldmVsIGZpbmFsIHN0YXRlIG5vZGUsXHJcbiAqIGJ1dCBub3Qgd2hlbiBpdCBpcyBjYW5jZWxlZC5cclxuICpcclxuICogQHBhcmFtIGlkIFRoZSBmaW5hbCBzdGF0ZSBub2RlIElEXHJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIHBhc3MgaW50byB0aGUgZXZlbnRcclxuICovXG5cbmZ1bmN0aW9uIGRvbmVJbnZva2UoaWQsIGRhdGEpIHtcbiAgdmFyIHR5cGUgPSBcIlwiLmNvbmNhdChBY3Rpb25UeXBlcy5Eb25lSW52b2tlLCBcIi5cIikuY29uY2F0KGlkKTtcbiAgdmFyIGV2ZW50T2JqZWN0ID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgZGF0YTogZGF0YVxuICB9O1xuXG4gIGV2ZW50T2JqZWN0LnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0eXBlO1xuICB9O1xuXG4gIHJldHVybiBldmVudE9iamVjdDtcbn1cbmZ1bmN0aW9uIGVycm9yKGlkLCBkYXRhKSB7XG4gIHZhciB0eXBlID0gXCJcIi5jb25jYXQoQWN0aW9uVHlwZXMuRXJyb3JQbGF0Zm9ybSwgXCIuXCIpLmNvbmNhdChpZCk7XG4gIHZhciBldmVudE9iamVjdCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGE6IGRhdGFcbiAgfTtcblxuICBldmVudE9iamVjdC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfTtcblxuICByZXR1cm4gZXZlbnRPYmplY3Q7XG59XG5mdW5jdGlvbiBwdXJlKGdldEFjdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBY3Rpb25UeXBlcy5QdXJlLFxuICAgIGdldDogZ2V0QWN0aW9uc1xuICB9O1xufVxuLyoqXHJcbiAqIEZvcndhcmRzIChzZW5kcykgYW4gZXZlbnQgdG8gYSBzcGVjaWZpZWQgc2VydmljZS5cclxuICpcclxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IHNlcnZpY2UgdG8gZm9yd2FyZCB0aGUgZXZlbnQgdG8uXHJcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gcGFzcyBpbnRvIHRoZSBzZW5kIGFjdGlvbiBjcmVhdG9yLlxyXG4gKi9cblxuZnVuY3Rpb24gZm9yd2FyZFRvKHRhcmdldCwgb3B0aW9ucykge1xuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgKCF0YXJnZXQgfHwgdHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB2YXIgb3JpZ2luYWxUYXJnZXRfMSA9IHRhcmdldDtcblxuICAgIHRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc29sdmVkVGFyZ2V0ID0gdHlwZW9mIG9yaWdpbmFsVGFyZ2V0XzEgPT09ICdmdW5jdGlvbicgPyBvcmlnaW5hbFRhcmdldF8xLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpIDogb3JpZ2luYWxUYXJnZXRfMTtcblxuICAgICAgaWYgKCFyZXNvbHZlZFRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gZm9yd2FyZCBldmVudCB0byB1bmRlZmluZWQgYWN0b3IuIFRoaXMgcmlza3MgYW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgc2VuZGVyLlwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc29sdmVkVGFyZ2V0O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gc2VuZChmdW5jdGlvbiAoXywgZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgIHRvOiB0YXJnZXRcbiAgfSkpO1xufVxuLyoqXHJcbiAqIEVzY2FsYXRlcyBhbiBlcnJvciBieSBzZW5kaW5nIGl0IGFzIGFuIGV2ZW50IHRvIHRoaXMgbWFjaGluZSdzIHBhcmVudC5cclxuICpcclxuICogQHBhcmFtIGVycm9yRGF0YSBUaGUgZXJyb3IgZGF0YSB0byBzZW5kLCBvciB0aGUgZXhwcmVzc2lvbiBmdW5jdGlvbiB0aGF0XHJcbiAqIHRha2VzIGluIHRoZSBgY29udGV4dGAsIGBldmVudGAsIGFuZCBgbWV0YWAsIGFuZCByZXR1cm5zIHRoZSBlcnJvciBkYXRhIHRvIHNlbmQuXHJcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gcGFzcyBpbnRvIHRoZSBzZW5kIGFjdGlvbiBjcmVhdG9yLlxyXG4gKi9cblxuZnVuY3Rpb24gZXNjYWxhdGUoZXJyb3JEYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiBzZW5kUGFyZW50KGZ1bmN0aW9uIChjb250ZXh0LCBldmVudCwgbWV0YSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBlcnJvciQxLFxuICAgICAgZGF0YTogaXNGdW5jdGlvbihlcnJvckRhdGEpID8gZXJyb3JEYXRhKGNvbnRleHQsIGV2ZW50LCBtZXRhKSA6IGVycm9yRGF0YVxuICAgIH07XG4gIH0sIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgIHRvOiBTcGVjaWFsVGFyZ2V0cy5QYXJlbnRcbiAgfSkpO1xufVxuZnVuY3Rpb24gY2hvb3NlKGNvbmRzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQWN0aW9uVHlwZXMuQ2hvb3NlLFxuICAgIGNvbmRzOiBjb25kc1xuICB9O1xufVxuXG52YXIgcGx1Y2tBc3NpZ25zID0gZnVuY3Rpb24gKGFjdGlvbkJsb2Nrcykge1xuICB2YXIgZV8xLCBfYTtcblxuICB2YXIgYXNzaWduQWN0aW9ucyA9IFtdO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgYWN0aW9uQmxvY2tzXzEgPSBfX3ZhbHVlcyhhY3Rpb25CbG9ja3MpLCBhY3Rpb25CbG9ja3NfMV8xID0gYWN0aW9uQmxvY2tzXzEubmV4dCgpOyAhYWN0aW9uQmxvY2tzXzFfMS5kb25lOyBhY3Rpb25CbG9ja3NfMV8xID0gYWN0aW9uQmxvY2tzXzEubmV4dCgpKSB7XG4gICAgICB2YXIgYmxvY2sgPSBhY3Rpb25CbG9ja3NfMV8xLnZhbHVlO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IGJsb2NrLmFjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChibG9jay5hY3Rpb25zW2ldLnR5cGUgPT09IGFzc2lnbiQxKSB7XG4gICAgICAgICAgYXNzaWduQWN0aW9ucy5wdXNoKGJsb2NrLmFjdGlvbnNbaV0pO1xuICAgICAgICAgIGJsb2NrLmFjdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICBlXzEgPSB7XG4gICAgICBlcnJvcjogZV8xXzFcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoYWN0aW9uQmxvY2tzXzFfMSAmJiAhYWN0aW9uQmxvY2tzXzFfMS5kb25lICYmIChfYSA9IGFjdGlvbkJsb2Nrc18xLnJldHVybikpIF9hLmNhbGwoYWN0aW9uQmxvY2tzXzEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFzc2lnbkFjdGlvbnM7XG59O1xuXG5mdW5jdGlvbiByZXNvbHZlQWN0aW9ucyhtYWNoaW5lLCBjdXJyZW50U3RhdGUsIGN1cnJlbnRDb250ZXh0LCBfZXZlbnQsIGFjdGlvbkJsb2NrcywgcHJlZGljdGFibGVFeGVjLCBwcmVzZXJ2ZUFjdGlvbk9yZGVyKSB7XG4gIGlmIChwcmVzZXJ2ZUFjdGlvbk9yZGVyID09PSB2b2lkIDApIHtcbiAgICBwcmVzZXJ2ZUFjdGlvbk9yZGVyID0gZmFsc2U7XG4gIH1cblxuICB2YXIgYXNzaWduQWN0aW9ucyA9IHByZXNlcnZlQWN0aW9uT3JkZXIgPyBbXSA6IHBsdWNrQXNzaWducyhhY3Rpb25CbG9ja3MpO1xuICB2YXIgdXBkYXRlZENvbnRleHQgPSBhc3NpZ25BY3Rpb25zLmxlbmd0aCA/IHVwZGF0ZUNvbnRleHQoY3VycmVudENvbnRleHQsIF9ldmVudCwgYXNzaWduQWN0aW9ucywgY3VycmVudFN0YXRlKSA6IGN1cnJlbnRDb250ZXh0O1xuICB2YXIgcHJlc2VydmVkQ29udGV4dHMgPSBwcmVzZXJ2ZUFjdGlvbk9yZGVyID8gW2N1cnJlbnRDb250ZXh0XSA6IHVuZGVmaW5lZDtcbiAgdmFyIGRlZmVycmVkVG9CbG9ja0VuZCA9IFtdO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUFjdGlvbihibG9ja1R5cGUsIGFjdGlvbk9iamVjdCkge1xuICAgIHZhciBfYTtcblxuICAgIHN3aXRjaCAoYWN0aW9uT2JqZWN0LnR5cGUpIHtcbiAgICAgIGNhc2UgcmFpc2UkMTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciByYWlzZWRBY3Rpb24gPSByZXNvbHZlUmFpc2UoYWN0aW9uT2JqZWN0LCB1cGRhdGVkQ29udGV4dCwgX2V2ZW50LCBtYWNoaW5lLm9wdGlvbnMuZGVsYXlzKTtcblxuICAgICAgICAgIGlmIChwcmVkaWN0YWJsZUV4ZWMgJiYgdHlwZW9mIHJhaXNlZEFjdGlvbi5kZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHByZWRpY3RhYmxlRXhlYyhyYWlzZWRBY3Rpb24sIHVwZGF0ZWRDb250ZXh0LCBfZXZlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByYWlzZWRBY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBzZW5kJDE6XG4gICAgICAgIHZhciBzZW5kQWN0aW9uID0gcmVzb2x2ZVNlbmQoYWN0aW9uT2JqZWN0LCB1cGRhdGVkQ29udGV4dCwgX2V2ZW50LCBtYWNoaW5lLm9wdGlvbnMuZGVsYXlzKTsgLy8gVE9ETzogZml4IEFjdGlvblR5cGVzLkluaXRcblxuICAgICAgICBpZiAoIUlTX1BST0RVQ1RJT04pIHtcbiAgICAgICAgICB2YXIgY29uZmlndXJlZERlbGF5ID0gYWN0aW9uT2JqZWN0LmRlbGF5OyAvLyB3YXJuIGFmdGVyIHJlc29sdmluZyBhcyB3ZSBjYW4gY3JlYXRlIGJldHRlciBjb250ZXh0dWFsIG1lc3NhZ2UgaGVyZVxuXG4gICAgICAgICAgd2FybighaXNTdHJpbmcoY29uZmlndXJlZERlbGF5KSB8fCB0eXBlb2Ygc2VuZEFjdGlvbi5kZWxheSA9PT0gJ251bWJlcicsIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgICAgICBcIk5vIGRlbGF5IHJlZmVyZW5jZSBmb3IgZGVsYXkgZXhwcmVzc2lvbiAnXCIuY29uY2F0KGNvbmZpZ3VyZWREZWxheSwgXCInIHdhcyBmb3VuZCBvbiBtYWNoaW5lICdcIikuY29uY2F0KG1hY2hpbmUuaWQsIFwiJ1wiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlZGljdGFibGVFeGVjICYmIHNlbmRBY3Rpb24udG8gIT09IFNwZWNpYWxUYXJnZXRzLkludGVybmFsKSB7XG4gICAgICAgICAgaWYgKGJsb2NrVHlwZSA9PT0gJ2VudHJ5Jykge1xuICAgICAgICAgICAgZGVmZXJyZWRUb0Jsb2NrRW5kLnB1c2goc2VuZEFjdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZWRpY3RhYmxlRXhlYyhzZW5kQWN0aW9uLCB1cGRhdGVkQ29udGV4dCwgX2V2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VuZEFjdGlvbjtcblxuICAgICAgY2FzZSBsb2ckMTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciByZXNvbHZlZCA9IHJlc29sdmVMb2coYWN0aW9uT2JqZWN0LCB1cGRhdGVkQ29udGV4dCwgX2V2ZW50KTtcbiAgICAgICAgICBwcmVkaWN0YWJsZUV4ZWMgPT09IG51bGwgfHwgcHJlZGljdGFibGVFeGVjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmVkaWN0YWJsZUV4ZWMocmVzb2x2ZWQsIHVwZGF0ZWRDb250ZXh0LCBfZXZlbnQpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIGNob29zZSQxOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNob29zZUFjdGlvbiA9IGFjdGlvbk9iamVjdDtcbiAgICAgICAgICB2YXIgbWF0Y2hlZEFjdGlvbnMgPSAoX2EgPSBjaG9vc2VBY3Rpb24uY29uZHMuZmluZChmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZ3VhcmQgPSB0b0d1YXJkKGNvbmRpdGlvbi5jb25kLCBtYWNoaW5lLm9wdGlvbnMuZ3VhcmRzKTtcbiAgICAgICAgICAgIHJldHVybiAhZ3VhcmQgfHwgZXZhbHVhdGVHdWFyZChtYWNoaW5lLCBndWFyZCwgdXBkYXRlZENvbnRleHQsIF9ldmVudCwgIXByZWRpY3RhYmxlRXhlYyA/IGN1cnJlbnRTdGF0ZSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3Rpb25zO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaGVkQWN0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChyZXNvbHZlQWN0aW9ucyhtYWNoaW5lLCBjdXJyZW50U3RhdGUsIHVwZGF0ZWRDb250ZXh0LCBfZXZlbnQsIFt7XG4gICAgICAgICAgICB0eXBlOiBibG9ja1R5cGUsXG4gICAgICAgICAgICBhY3Rpb25zOiB0b0FjdGlvbk9iamVjdHModG9BcnJheShtYXRjaGVkQWN0aW9ucyksIG1hY2hpbmUub3B0aW9ucy5hY3Rpb25zKVxuICAgICAgICAgIH1dLCBwcmVkaWN0YWJsZUV4ZWMsIHByZXNlcnZlQWN0aW9uT3JkZXIpLCAyKSxcbiAgICAgICAgICAgICAgcmVzb2x2ZWRBY3Rpb25zRnJvbUNob29zZSA9IF9iWzBdLFxuICAgICAgICAgICAgICByZXNvbHZlZENvbnRleHRGcm9tQ2hvb3NlID0gX2JbMV07XG5cbiAgICAgICAgICB1cGRhdGVkQ29udGV4dCA9IHJlc29sdmVkQ29udGV4dEZyb21DaG9vc2U7XG4gICAgICAgICAgcHJlc2VydmVkQ29udGV4dHMgPT09IG51bGwgfHwgcHJlc2VydmVkQ29udGV4dHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXNlcnZlZENvbnRleHRzLnB1c2godXBkYXRlZENvbnRleHQpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlZEFjdGlvbnNGcm9tQ2hvb3NlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgcHVyZSQxOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG1hdGNoZWRBY3Rpb25zID0gYWN0aW9uT2JqZWN0LmdldCh1cGRhdGVkQ29udGV4dCwgX2V2ZW50LmRhdGEpO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaGVkQWN0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfYyA9IF9fcmVhZChyZXNvbHZlQWN0aW9ucyhtYWNoaW5lLCBjdXJyZW50U3RhdGUsIHVwZGF0ZWRDb250ZXh0LCBfZXZlbnQsIFt7XG4gICAgICAgICAgICB0eXBlOiBibG9ja1R5cGUsXG4gICAgICAgICAgICBhY3Rpb25zOiB0b0FjdGlvbk9iamVjdHModG9BcnJheShtYXRjaGVkQWN0aW9ucyksIG1hY2hpbmUub3B0aW9ucy5hY3Rpb25zKVxuICAgICAgICAgIH1dLCBwcmVkaWN0YWJsZUV4ZWMsIHByZXNlcnZlQWN0aW9uT3JkZXIpLCAyKSxcbiAgICAgICAgICAgICAgcmVzb2x2ZWRBY3Rpb25zRnJvbVB1cmUgPSBfY1swXSxcbiAgICAgICAgICAgICAgcmVzb2x2ZWRDb250ZXh0ID0gX2NbMV07XG5cbiAgICAgICAgICB1cGRhdGVkQ29udGV4dCA9IHJlc29sdmVkQ29udGV4dDtcbiAgICAgICAgICBwcmVzZXJ2ZWRDb250ZXh0cyA9PT0gbnVsbCB8fCBwcmVzZXJ2ZWRDb250ZXh0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlc2VydmVkQ29udGV4dHMucHVzaCh1cGRhdGVkQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVkQWN0aW9uc0Zyb21QdXJlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2Ugc3RvcCQxOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHJlc29sdmVkID0gcmVzb2x2ZVN0b3AoYWN0aW9uT2JqZWN0LCB1cGRhdGVkQ29udGV4dCwgX2V2ZW50KTtcbiAgICAgICAgICBwcmVkaWN0YWJsZUV4ZWMgPT09IG51bGwgfHwgcHJlZGljdGFibGVFeGVjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmVkaWN0YWJsZUV4ZWMocmVzb2x2ZWQsIGN1cnJlbnRDb250ZXh0LCBfZXZlbnQpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIGFzc2lnbiQxOlxuICAgICAgICB7XG4gICAgICAgICAgdXBkYXRlZENvbnRleHQgPSB1cGRhdGVDb250ZXh0KHVwZGF0ZWRDb250ZXh0LCBfZXZlbnQsIFthY3Rpb25PYmplY3RdLCAhcHJlZGljdGFibGVFeGVjID8gY3VycmVudFN0YXRlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICBwcmVzZXJ2ZWRDb250ZXh0cyA9PT0gbnVsbCB8fCBwcmVzZXJ2ZWRDb250ZXh0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlc2VydmVkQ29udGV4dHMucHVzaCh1cGRhdGVkQ29udGV4dCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHJlc29sdmVkQWN0aW9uT2JqZWN0ID0gdG9BY3Rpb25PYmplY3QoYWN0aW9uT2JqZWN0LCBtYWNoaW5lLm9wdGlvbnMuYWN0aW9ucyk7XG4gICAgICAgIHZhciBleGVjXzEgPSByZXNvbHZlZEFjdGlvbk9iamVjdC5leGVjO1xuXG4gICAgICAgIGlmIChwcmVkaWN0YWJsZUV4ZWMpIHtcbiAgICAgICAgICBwcmVkaWN0YWJsZUV4ZWMocmVzb2x2ZWRBY3Rpb25PYmplY3QsIHVwZGF0ZWRDb250ZXh0LCBfZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4ZWNfMSAmJiBwcmVzZXJ2ZWRDb250ZXh0cykge1xuICAgICAgICAgIHZhciBjb250ZXh0SW5kZXhfMSA9IHByZXNlcnZlZENvbnRleHRzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICB2YXIgd3JhcHBlZCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXNvbHZlZEFjdGlvbk9iamVjdCksIHtcbiAgICAgICAgICAgIGV4ZWM6IGZ1bmN0aW9uIChfY3R4KSB7XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZXhlY18xLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbcHJlc2VydmVkQ29udGV4dHNbY29udGV4dEluZGV4XzFdXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmVzb2x2ZWRBY3Rpb25PYmplY3QgPSB3cmFwcGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkQWN0aW9uT2JqZWN0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NCbG9jayhibG9jaykge1xuICAgIHZhciBlXzIsIF9hO1xuXG4gICAgdmFyIHJlc29sdmVkQWN0aW9ucyA9IFtdO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoYmxvY2suYWN0aW9ucyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIGFjdGlvbiA9IF9jLnZhbHVlO1xuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBoYW5kbGVBY3Rpb24oYmxvY2sudHlwZSwgYWN0aW9uKTtcblxuICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICByZXNvbHZlZEFjdGlvbnMgPSByZXNvbHZlZEFjdGlvbnMuY29uY2F0KHJlc29sdmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfMl8xKSB7XG4gICAgICBlXzIgPSB7XG4gICAgICAgIGVycm9yOiBlXzJfMVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlZmVycmVkVG9CbG9ja0VuZC5mb3JFYWNoKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIHByZWRpY3RhYmxlRXhlYyhhY3Rpb24sIHVwZGF0ZWRDb250ZXh0LCBfZXZlbnQpO1xuICAgIH0pO1xuICAgIGRlZmVycmVkVG9CbG9ja0VuZC5sZW5ndGggPSAwO1xuICAgIHJldHVybiByZXNvbHZlZEFjdGlvbnM7XG4gIH1cblxuICB2YXIgcmVzb2x2ZWRBY3Rpb25zID0gZmxhdHRlbihhY3Rpb25CbG9ja3MubWFwKHByb2Nlc3NCbG9jaykpO1xuICByZXR1cm4gW3Jlc29sdmVkQWN0aW9ucywgdXBkYXRlZENvbnRleHRdO1xufVxuXG5leHBvcnQgeyBhZnRlciwgYXNzaWduLCBjYW5jZWwsIGNob29zZSwgZG9uZSwgZG9uZUludm9rZSwgZXJyb3IsIGVzY2FsYXRlLCBmb3J3YXJkVG8sIGdldEFjdGlvbkZ1bmN0aW9uLCBpbml0RXZlbnQsIGlzQWN0aW9uT2JqZWN0LCBsb2csIHB1cmUsIHJhaXNlLCByZXNvbHZlQWN0aW9ucywgcmVzb2x2ZUxvZywgcmVzb2x2ZVJhaXNlLCByZXNvbHZlU2VuZCwgcmVzb2x2ZVN0b3AsIHJlc3BvbmQsIHNlbmQsIHNlbmRQYXJlbnQsIHNlbmRUbywgc2VuZFVwZGF0ZSwgc3RhcnQsIHN0b3AsIHRvQWN0aW9uT2JqZWN0LCB0b0FjdGlvbk9iamVjdHMsIHRvQWN0aXZpdHlEZWZpbml0aW9uIH07XG4iLCJpbXBvcnQgeyBlcnJvciwgZG9uZUludm9rZSB9IGZyb20gJy4vYWN0aW9ucy5qcyc7XG5pbXBvcnQgeyB0b0FjdG9yUmVmIH0gZnJvbSAnLi9BY3Rvci5qcyc7XG5pbXBvcnQgeyB0b09ic2VydmVyIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGFjdG9yIGJlaGF2aW9yIGZyb20gYSByZWR1Y2VyIGFuZCBpdHMgaW5pdGlhbCBzdGF0ZS5cclxuICpcclxuICogQHBhcmFtIHRyYW5zaXRpb24gVGhlIHB1cmUgcmVkdWNlciB0aGF0IHJldHVybnMgdGhlIG5leHQgc3RhdGUgZ2l2ZW4gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGV2ZW50LlxyXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSByZWR1Y2VyLlxyXG4gKiBAcmV0dXJucyBBbiBhY3RvciBiZWhhdmlvclxyXG4gKi9cblxuZnVuY3Rpb24gZnJvbVJlZHVjZXIodHJhbnNpdGlvbiwgaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiB7XG4gICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbixcbiAgICBpbml0aWFsU3RhdGU6IGluaXRpYWxTdGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gZnJvbVByb21pc2UocHJvbWlzZUZuKSB7XG4gIHZhciBpbml0aWFsU3RhdGUgPSB7XG4gICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgc3RhdHVzOiAncGVuZGluZydcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2l0aW9uOiBmdW5jdGlvbiAoc3RhdGUsIGV2ZW50LCBfYSkge1xuICAgICAgdmFyIHBhcmVudCA9IF9hLnBhcmVudCxcbiAgICAgICAgICBpZCA9IF9hLmlkLFxuICAgICAgICAgIG9ic2VydmVycyA9IF9hLm9ic2VydmVycztcblxuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2Z1bGZpbGwnOlxuICAgICAgICAgIHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5zZW5kKGRvbmVJbnZva2UoaWQsIGV2ZW50LmRhdGEpKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEsXG4gICAgICAgICAgICBzdGF0dXM6ICdmdWxmaWxsZWQnXG4gICAgICAgICAgfTtcblxuICAgICAgICBjYXNlICdyZWplY3QnOlxuICAgICAgICAgIHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5zZW5kKGVycm9yKGlkLCBldmVudC5lcnJvcikpO1xuICAgICAgICAgIG9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXZlbnQuZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcjogZXZlbnQuZXJyb3IsXG4gICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdGF0dXM6ICdyZWplY3RlZCdcbiAgICAgICAgICB9O1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW5pdGlhbFN0YXRlOiBpbml0aWFsU3RhdGUsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIHNlbGYgPSBfYS5zZWxmO1xuICAgICAgcHJvbWlzZUZuKCkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLnNlbmQoe1xuICAgICAgICAgIHR5cGU6ICdmdWxmaWxsJyxcbiAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBzZWxmLnNlbmQoe1xuICAgICAgICAgIHR5cGU6ICdyZWplY3QnLFxuICAgICAgICAgIGVycm9yOiByZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpbml0aWFsU3RhdGU7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc3Bhd25CZWhhdmlvcihiZWhhdmlvciwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHN0YXRlID0gYmVoYXZpb3IuaW5pdGlhbFN0YXRlO1xuICB2YXIgb2JzZXJ2ZXJzID0gbmV3IFNldCgpO1xuICB2YXIgbWFpbGJveCA9IFtdO1xuICB2YXIgZmx1c2hpbmcgPSBmYWxzZTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGZsdXNoaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmx1c2hpbmcgPSB0cnVlO1xuXG4gICAgd2hpbGUgKG1haWxib3gubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGV2ZW50XzEgPSBtYWlsYm94LnNoaWZ0KCk7XG4gICAgICBzdGF0ZSA9IGJlaGF2aW9yLnRyYW5zaXRpb24oc3RhdGUsIGV2ZW50XzEsIGFjdG9yQ3R4KTtcbiAgICAgIG9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXIubmV4dChzdGF0ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmbHVzaGluZyA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBhY3RvciA9IHRvQWN0b3JSZWYoe1xuICAgIGlkOiBvcHRpb25zLmlkLFxuICAgIHNlbmQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgbWFpbGJveC5wdXNoKGV2ZW50KTtcbiAgICAgIGZsdXNoKCk7XG4gICAgfSxcbiAgICBnZXRTbmFwc2hvdDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAobmV4dCwgaGFuZGxlRXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSB0b09ic2VydmVyKG5leHQsIGhhbmRsZUVycm9yLCBjb21wbGV0ZSk7XG4gICAgICBvYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICAgIG9ic2VydmVyLm5leHQoc3RhdGUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICB2YXIgYWN0b3JDdHggPSB7XG4gICAgcGFyZW50OiBvcHRpb25zLnBhcmVudCxcbiAgICBzZWxmOiBhY3RvcixcbiAgICBpZDogb3B0aW9ucy5pZCB8fCAnYW5vbnltb3VzJyxcbiAgICBvYnNlcnZlcnM6IG9ic2VydmVyc1xuICB9O1xuICBzdGF0ZSA9IGJlaGF2aW9yLnN0YXJ0ID8gYmVoYXZpb3Iuc3RhcnQoYWN0b3JDdHgpIDogc3RhdGU7XG4gIHJldHVybiBhY3Rvcjtcbn1cblxuZXhwb3J0IHsgZnJvbVByb21pc2UsIGZyb21SZWR1Y2VyLCBzcGF3bkJlaGF2aW9yIH07XG4iLCJ2YXIgU1RBVEVfREVMSU1JVEVSID0gJy4nO1xudmFyIEVNUFRZX0FDVElWSVRZX01BUCA9IHt9O1xudmFyIERFRkFVTFRfR1VBUkRfVFlQRSA9ICd4c3RhdGUuZ3VhcmQnO1xudmFyIFRBUkdFVExFU1NfS0VZID0gJyc7XG5cbmV4cG9ydCB7IERFRkFVTFRfR1VBUkRfVFlQRSwgRU1QVFlfQUNUSVZJVFlfTUFQLCBTVEFURV9ERUxJTUlURVIsIFRBUkdFVExFU1NfS0VZIH07XG4iLCJpbXBvcnQgeyBJU19QUk9EVUNUSU9OIH0gZnJvbSAnLi9lbnZpcm9ubWVudC5qcyc7XG5cbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cblxuICBpZiAoIUlTX1BST0RVQ1RJT04pIHtcbiAgICBjb25zb2xlLndhcm4oJ1hTdGF0ZSBjb3VsZCBub3QgZmluZCBhIGdsb2JhbCBvYmplY3QgaW4gdGhpcyBlbnZpcm9ubWVudC4gUGxlYXNlIGxldCB0aGUgbWFpbnRhaW5lcnMga25vdyBhbmQgcmFpc2UgYW4gaXNzdWUgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3N0YXRlbHlhaS94c3RhdGUvaXNzdWVzJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGV2VG9vbHMoKSB7XG4gIHZhciBnbG9iYWwgPSBnZXRHbG9iYWwoKTtcblxuICBpZiAoZ2xvYmFsICYmICdfX3hzdGF0ZV9fJyBpbiBnbG9iYWwpIHtcbiAgICByZXR1cm4gZ2xvYmFsLl9feHN0YXRlX187XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlclNlcnZpY2Uoc2VydmljZSkge1xuICBpZiAoIWdldEdsb2JhbCgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRldlRvb2xzID0gZ2V0RGV2VG9vbHMoKTtcblxuICBpZiAoZGV2VG9vbHMpIHtcbiAgICBkZXZUb29scy5yZWdpc3RlcihzZXJ2aWNlKTtcbiAgfVxufVxuXG5leHBvcnQgeyBnZXRHbG9iYWwsIHJlZ2lzdGVyU2VydmljZSB9O1xuIiwidmFyIElTX1BST0RVQ1RJT04gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuXG5leHBvcnQgeyBJU19QUk9EVUNUSU9OIH07XG4iLCJpbXBvcnQgeyBhc3NpZ24gYXMgYXNzaWduJDEsIGNhbmNlbCBhcyBjYW5jZWwkMSwgc2VuZCBhcyBzZW5kJDEsIHNlbmRUbyBhcyBzZW5kVG8kMSwgc2VuZFBhcmVudCBhcyBzZW5kUGFyZW50JDEsIHNlbmRVcGRhdGUgYXMgc2VuZFVwZGF0ZSQxLCBmb3J3YXJkVG8gYXMgZm9yd2FyZFRvJDEsIGRvbmVJbnZva2UgYXMgZG9uZUludm9rZSQxLCByYWlzZSBhcyByYWlzZSQxLCBsb2cgYXMgbG9nJDEsIHB1cmUgYXMgcHVyZSQxLCBjaG9vc2UgYXMgY2hvb3NlJDEsIHN0b3AgYXMgc3RvcCQxIH0gZnJvbSAnLi9hY3Rpb25zLmpzJztcbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSAnLi9hY3Rpb25zLmpzJztcbmV4cG9ydCB7IGFjdGlvbnMgfTtcbmV4cG9ydCB7IHRvQWN0b3JSZWYgfSBmcm9tICcuL0FjdG9yLmpzJztcbmV4cG9ydCB7IEludGVycHJldGVyLCBJbnRlcnByZXRlclN0YXR1cywgaW50ZXJwcmV0LCBzcGF3biB9IGZyb20gJy4vaW50ZXJwcmV0ZXIuanMnO1xuZXhwb3J0IHsgTWFjaGluZSwgY3JlYXRlTWFjaGluZSB9IGZyb20gJy4vTWFjaGluZS5qcyc7XG5leHBvcnQgeyBtYXBTdGF0ZSB9IGZyb20gJy4vbWFwU3RhdGUuanMnO1xuZXhwb3J0IHsgbWF0Y2hTdGF0ZSB9IGZyb20gJy4vbWF0Y2guanMnO1xuZXhwb3J0IHsgY3JlYXRlU2NoZW1hLCB0IH0gZnJvbSAnLi9zY2hlbWEuanMnO1xuZXhwb3J0IHsgU3RhdGUgfSBmcm9tICcuL1N0YXRlLmpzJztcbmV4cG9ydCB7IFN0YXRlTm9kZSB9IGZyb20gJy4vU3RhdGVOb2RlLmpzJztcbmV4cG9ydCB7IHNwYXduQmVoYXZpb3IgfSBmcm9tICcuL2JlaGF2aW9ycy5qcyc7XG5leHBvcnQgeyBBY3Rpb25UeXBlcywgU3BlY2lhbFRhcmdldHMgfSBmcm9tICcuL3R5cGVzLmpzJztcbmV4cG9ydCB7IG1hdGNoZXNTdGF0ZSwgdG9FdmVudE9iamVjdCwgdG9PYnNlcnZlciwgdG9TQ1hNTEV2ZW50IH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbnZhciBhc3NpZ24gPSBhc3NpZ24kMSxcbiAgICBjYW5jZWwgPSBjYW5jZWwkMSxcbiAgICBzZW5kID0gc2VuZCQxLFxuICAgIHNlbmRUbyA9IHNlbmRUbyQxLFxuICAgIHNlbmRQYXJlbnQgPSBzZW5kUGFyZW50JDEsXG4gICAgc2VuZFVwZGF0ZSA9IHNlbmRVcGRhdGUkMSxcbiAgICBmb3J3YXJkVG8gPSBmb3J3YXJkVG8kMSxcbiAgICBkb25lSW52b2tlID0gZG9uZUludm9rZSQxLFxuICAgIHJhaXNlID0gcmFpc2UkMSxcbiAgICBsb2cgPSBsb2ckMSxcbiAgICBwdXJlID0gcHVyZSQxLFxuICAgIGNob29zZSA9IGNob29zZSQxLFxuICAgIHN0b3AgPSBzdG9wJDE7XG5cbmV4cG9ydCB7IGFzc2lnbiwgY2FuY2VsLCBjaG9vc2UsIGRvbmVJbnZva2UsIGZvcndhcmRUbywgbG9nLCBwdXJlLCByYWlzZSwgc2VuZCwgc2VuZFBhcmVudCwgc2VuZFRvLCBzZW5kVXBkYXRlLCBzdG9wIH07XG4iLCJpbXBvcnQgeyBfX3ZhbHVlcywgX19zcHJlYWRBcnJheSwgX19yZWFkLCBfX2Fzc2lnbiB9IGZyb20gJy4vX3ZpcnR1YWwvX3RzbGliLmpzJztcbmltcG9ydCB7IFNwZWNpYWxUYXJnZXRzLCBBY3Rpb25UeXBlcyB9IGZyb20gJy4vdHlwZXMuanMnO1xuaW1wb3J0IHsgaXNTdGF0ZUNvbmZpZywgU3RhdGUsIGJpbmRBY3Rpb25Ub1N0YXRlIH0gZnJvbSAnLi9TdGF0ZS5qcyc7XG5pbXBvcnQgeyBlcnJvclBsYXRmb3JtLCB1cGRhdGUsIGVycm9yIGFzIGVycm9yJDEsIGxvZywgc3RvcCwgc3RhcnQsIGNhbmNlbCwgc2VuZCwgcmFpc2UgfSBmcm9tICcuL2FjdGlvblR5cGVzLmpzJztcbmltcG9ydCB7IGluaXRFdmVudCwgZG9uZUludm9rZSwgdG9BY3Rpb25PYmplY3RzLCByZXNvbHZlQWN0aW9ucywgZXJyb3IsIGdldEFjdGlvbkZ1bmN0aW9uIH0gZnJvbSAnLi9hY3Rpb25zLmpzJztcbmltcG9ydCB7IElTX1BST0RVQ1RJT04gfSBmcm9tICcuL2Vudmlyb25tZW50LmpzJztcbmltcG9ydCB7IHdhcm4sIG1hcENvbnRleHQsIHRvT2JzZXJ2ZXIsIGlzRnVuY3Rpb24sIHRvU0NYTUxFdmVudCwgZmxhdHRlbiwgaXNSYWlzYWJsZUFjdGlvbiwgaXNQcm9taXNlTGlrZSwgaXNPYnNlcnZhYmxlLCBpc01hY2hpbmUsIGlzQmVoYXZpb3IsIHJlcG9ydFVuaGFuZGxlZEV4Y2VwdGlvbk9uSW52b2NhdGlvbiwgc3ltYm9sT2JzZXJ2YWJsZSwgaXNBcnJheSwgdG9FdmVudE9iamVjdCwgaXNTdHJpbmcsIGlzQWN0b3IsIHRvSW52b2tlU291cmNlLCB1bmlxdWVJZCB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgU2NoZWR1bGVyIH0gZnJvbSAnLi9zY2hlZHVsZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlRGVmZXJyZWRBY3RvciwgaXNTcGF3bmVkQWN0b3IgfSBmcm9tICcuL0FjdG9yLmpzJztcbmltcG9ydCB7IHJlZ2lzdHJ5IH0gZnJvbSAnLi9yZWdpc3RyeS5qcyc7XG5pbXBvcnQgeyBnZXRHbG9iYWwsIHJlZ2lzdGVyU2VydmljZSB9IGZyb20gJy4vZGV2VG9vbHMuanMnO1xuaW1wb3J0IHsgcHJvdmlkZSwgY29uc3VtZSB9IGZyb20gJy4vc2VydmljZVNjb3BlLmpzJztcbmltcG9ydCB7IHNwYXduQmVoYXZpb3IgfSBmcm9tICcuL2JlaGF2aW9ycy5qcyc7XG5cbnZhciBERUZBVUxUX1NQQVdOX09QVElPTlMgPSB7XG4gIHN5bmM6IGZhbHNlLFxuICBhdXRvRm9yd2FyZDogZmFsc2Vcbn07XG52YXIgSW50ZXJwcmV0ZXJTdGF0dXM7XG5cbihmdW5jdGlvbiAoSW50ZXJwcmV0ZXJTdGF0dXMpIHtcbiAgSW50ZXJwcmV0ZXJTdGF0dXNbSW50ZXJwcmV0ZXJTdGF0dXNbXCJOb3RTdGFydGVkXCJdID0gMF0gPSBcIk5vdFN0YXJ0ZWRcIjtcbiAgSW50ZXJwcmV0ZXJTdGF0dXNbSW50ZXJwcmV0ZXJTdGF0dXNbXCJSdW5uaW5nXCJdID0gMV0gPSBcIlJ1bm5pbmdcIjtcbiAgSW50ZXJwcmV0ZXJTdGF0dXNbSW50ZXJwcmV0ZXJTdGF0dXNbXCJTdG9wcGVkXCJdID0gMl0gPSBcIlN0b3BwZWRcIjtcbn0pKEludGVycHJldGVyU3RhdHVzIHx8IChJbnRlcnByZXRlclN0YXR1cyA9IHt9KSk7XG5cbnZhciBJbnRlcnByZXRlciA9XG4vKiNfX1BVUkVfXyovXG5cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBJbnRlcnByZXRlciBpbnN0YW5jZSAoaS5lLiwgc2VydmljZSkgZm9yIHRoZSBnaXZlbiBtYWNoaW5lIHdpdGggdGhlIHByb3ZpZGVkIG9wdGlvbnMsIGlmIGFueS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBtYWNoaW5lIFRoZSBtYWNoaW5lIHRvIGJlIGludGVycHJldGVkXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgSW50ZXJwcmV0ZXIgb3B0aW9uc1xyXG4gICAqL1xuICBmdW5jdGlvbiBJbnRlcnByZXRlcihtYWNoaW5lLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IEludGVycHJldGVyLmRlZmF1bHRPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLm1hY2hpbmUgPSBtYWNoaW5lO1xuICAgIHRoaXMuZGVsYXllZEV2ZW50c01hcCA9IHt9O1xuICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuY29udGV4dExpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnN0b3BMaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5kb25lTGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zZW5kTGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgc2VydmljZSBpcyBzdGFydGVkLlxyXG4gICAgICovXG5cbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0dXMgPSBJbnRlcnByZXRlclN0YXR1cy5Ob3RTdGFydGVkO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5mb3J3YXJkVG8gPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fb3V0Z29pbmdRdWV1ZSA9IFtdO1xuICAgIC8qKlxyXG4gICAgICogQWxpYXMgZm9yIEludGVycHJldGVyLnByb3RvdHlwZS5zdGFydFxyXG4gICAgICovXG5cbiAgICB0aGlzLmluaXQgPSB0aGlzLnN0YXJ0O1xuICAgIC8qKlxyXG4gICAgICogU2VuZHMgYW4gZXZlbnQgdG8gdGhlIHJ1bm5pbmcgaW50ZXJwcmV0ZXIgdG8gdHJpZ2dlciBhIHRyYW5zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQW4gYXJyYXkgb2YgZXZlbnRzIChiYXRjaGVkKSBjYW4gYmUgc2VudCBhcyB3ZWxsLCB3aGljaCB3aWxsIHNlbmQgYWxsXHJcbiAgICAgKiBiYXRjaGVkIGV2ZW50cyB0byB0aGUgcnVubmluZyBpbnRlcnByZXRlci4gVGhlIGxpc3RlbmVycyB3aWxsIGJlXHJcbiAgICAgKiBub3RpZmllZCBvbmx5ICoqb25jZSoqIHdoZW4gYWxsIGV2ZW50cyBhcmUgcHJvY2Vzc2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQocykgdG8gc2VuZFxyXG4gICAgICovXG5cbiAgICB0aGlzLnNlbmQgPSBmdW5jdGlvbiAoZXZlbnQsIHBheWxvYWQpIHtcbiAgICAgIGlmIChpc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBfdGhpcy5iYXRjaChldmVudCk7XG5cbiAgICAgICAgcmV0dXJuIF90aGlzLnN0YXRlO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2V2ZW50ID0gdG9TQ1hNTEV2ZW50KHRvRXZlbnRPYmplY3QoZXZlbnQsIHBheWxvYWQpKTtcblxuICAgICAgaWYgKF90aGlzLnN0YXR1cyA9PT0gSW50ZXJwcmV0ZXJTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgIGlmICghSVNfUFJPRFVDVElPTikge1xuICAgICAgICAgIHdhcm4oZmFsc2UsIFwiRXZlbnQgXFxcIlwiLmNvbmNhdChfZXZlbnQubmFtZSwgXCJcXFwiIHdhcyBzZW50IHRvIHN0b3BwZWQgc2VydmljZSBcXFwiXCIpLmNvbmNhdChfdGhpcy5tYWNoaW5lLmlkLCBcIlxcXCIuIFRoaXMgc2VydmljZSBoYXMgYWxyZWFkeSByZWFjaGVkIGl0cyBmaW5hbCBzdGF0ZSwgYW5kIHdpbGwgbm90IHRyYW5zaXRpb24uXFxuRXZlbnQ6IFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkoX2V2ZW50LmRhdGEpKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMuc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5zdGF0dXMgIT09IEludGVycHJldGVyU3RhdHVzLlJ1bm5pbmcgJiYgIV90aGlzLm9wdGlvbnMuZGVmZXJFdmVudHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgXFxcIlwiLmNvbmNhdChfZXZlbnQubmFtZSwgXCJcXFwiIHdhcyBzZW50IHRvIHVuaW5pdGlhbGl6ZWQgc2VydmljZSBcXFwiXCIpLmNvbmNhdChfdGhpcy5tYWNoaW5lLmlkIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgICAgLCBcIlxcXCIuIE1ha2Ugc3VyZSAuc3RhcnQoKSBpcyBjYWxsZWQgZm9yIHRoaXMgc2VydmljZSwgb3Igc2V0IHsgZGVmZXJFdmVudHM6IHRydWUgfSBpbiB0aGUgc2VydmljZSBvcHRpb25zLlxcbkV2ZW50OiBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KF9ldmVudC5kYXRhKSkpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGb3J3YXJkIGNvcHkgb2YgZXZlbnQgdG8gY2hpbGQgYWN0b3JzXG4gICAgICAgIF90aGlzLmZvcndhcmQoX2V2ZW50KTtcblxuICAgICAgICB2YXIgbmV4dFN0YXRlID0gX3RoaXMuX25leHRTdGF0ZShfZXZlbnQpO1xuXG4gICAgICAgIF90aGlzLnVwZGF0ZShuZXh0U3RhdGUsIF9ldmVudCk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF90aGlzLl9zdGF0ZTsgLy8gVE9ETzogZGVwcmVjYXRlIChzaG91bGQgcmV0dXJuIHZvaWQpXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6c2VtaWNvbG9uXG4gICAgfTtcblxuICAgIHRoaXMuc2VuZFRvID0gZnVuY3Rpb24gKGV2ZW50LCB0bywgaW1tZWRpYXRlKSB7XG4gICAgICB2YXIgaXNQYXJlbnQgPSBfdGhpcy5wYXJlbnQgJiYgKHRvID09PSBTcGVjaWFsVGFyZ2V0cy5QYXJlbnQgfHwgX3RoaXMucGFyZW50LmlkID09PSB0byk7XG4gICAgICB2YXIgdGFyZ2V0ID0gaXNQYXJlbnQgPyBfdGhpcy5wYXJlbnQgOiBpc1N0cmluZyh0bykgPyB0byA9PT0gU3BlY2lhbFRhcmdldHMuSW50ZXJuYWwgPyBfdGhpcyA6IF90aGlzLmNoaWxkcmVuLmdldCh0bykgfHwgcmVnaXN0cnkuZ2V0KHRvKSA6IGlzQWN0b3IodG8pID8gdG8gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIGlmICghaXNQYXJlbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gc2VuZCBldmVudCB0byBjaGlsZCAnXCIuY29uY2F0KHRvLCBcIicgZnJvbSBzZXJ2aWNlICdcIikuY29uY2F0KF90aGlzLmlkLCBcIicuXCIpKTtcbiAgICAgICAgfSAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuXG5cbiAgICAgICAgaWYgKCFJU19QUk9EVUNUSU9OKSB7XG4gICAgICAgICAgd2FybihmYWxzZSwgXCJTZXJ2aWNlICdcIi5jb25jYXQoX3RoaXMuaWQsIFwiJyBoYXMgbm8gcGFyZW50OiB1bmFibGUgdG8gc2VuZCBldmVudCBcIikuY29uY2F0KGV2ZW50LnR5cGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCdtYWNoaW5lJyBpbiB0YXJnZXQpIHtcbiAgICAgICAgLy8gcGVyaGFwcyB0aG9zZSBldmVudHMgc2hvdWxkIGJlIHJlamVjdGVkIGluIHRoZSBwYXJlbnRcbiAgICAgICAgLy8gYnV0IGF0bSBpdCBkb2Vzbid0IGhhdmUgZWFzeSBhY2Nlc3MgdG8gYWxsIG9mIHRoZSBpbmZvcm1hdGlvbiB0aGF0IGlzIHJlcXVpcmVkIHRvIGRvIGl0IHJlbGlhYmx5XG4gICAgICAgIGlmIChfdGhpcy5zdGF0dXMgIT09IEludGVycHJldGVyU3RhdHVzLlN0b3BwZWQgfHwgX3RoaXMucGFyZW50ICE9PSB0YXJnZXQgfHwgLy8gd2UgbmVlZCB0byBzZW5kIGV2ZW50cyB0byB0aGUgcGFyZW50IGZyb20gZXhpdCBoYW5kbGVycyBvZiBhIG1hY2hpbmUgdGhhdCByZWFjaGVkIGl0cyBmaW5hbCBzdGF0ZVxuICAgICAgICBfdGhpcy5zdGF0ZS5kb25lKSB7XG4gICAgICAgICAgLy8gU2VuZCBTQ1hNTCBldmVudHMgdG8gbWFjaGluZXNcbiAgICAgICAgICB2YXIgc2N4bWxFdmVudCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBldmVudCksIHtcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50Lm5hbWUgPT09IGVycm9yJDEgPyBcIlwiLmNvbmNhdChlcnJvcihfdGhpcy5pZCkpIDogZXZlbnQubmFtZSxcbiAgICAgICAgICAgIG9yaWdpbjogX3RoaXMuc2Vzc2lvbklkXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIWltbWVkaWF0ZSAmJiBfdGhpcy5tYWNoaW5lLmNvbmZpZy5wcmVkaWN0YWJsZUFjdGlvbkFyZ3VtZW50cykge1xuICAgICAgICAgICAgX3RoaXMuX291dGdvaW5nUXVldWUucHVzaChbdGFyZ2V0LCBzY3htbEV2ZW50XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5zZW5kKHNjeG1sRXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2VuZCBub3JtYWwgZXZlbnRzIHRvIG90aGVyIHRhcmdldHNcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUgJiYgX3RoaXMubWFjaGluZS5jb25maWcucHJlZGljdGFibGVBY3Rpb25Bcmd1bWVudHMpIHtcbiAgICAgICAgICBfdGhpcy5fb3V0Z29pbmdRdWV1ZS5wdXNoKFt0YXJnZXQsIGV2ZW50LmRhdGFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXQuc2VuZChldmVudC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl9leGVjID0gZnVuY3Rpb24gKGFjdGlvbiwgY29udGV4dCwgX2V2ZW50LCBhY3Rpb25GdW5jdGlvbk1hcCkge1xuICAgICAgaWYgKGFjdGlvbkZ1bmN0aW9uTWFwID09PSB2b2lkIDApIHtcbiAgICAgICAgYWN0aW9uRnVuY3Rpb25NYXAgPSBfdGhpcy5tYWNoaW5lLm9wdGlvbnMuYWN0aW9ucztcbiAgICAgIH1cblxuICAgICAgdmFyIGFjdGlvbk9yRXhlYyA9IGFjdGlvbi5leGVjIHx8IGdldEFjdGlvbkZ1bmN0aW9uKGFjdGlvbi50eXBlLCBhY3Rpb25GdW5jdGlvbk1hcCk7XG4gICAgICB2YXIgZXhlYyA9IGlzRnVuY3Rpb24oYWN0aW9uT3JFeGVjKSA/IGFjdGlvbk9yRXhlYyA6IGFjdGlvbk9yRXhlYyA/IGFjdGlvbk9yRXhlYy5leGVjIDogYWN0aW9uLmV4ZWM7XG5cbiAgICAgIGlmIChleGVjKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGV4ZWMoY29udGV4dCwgX2V2ZW50LmRhdGEsICFfdGhpcy5tYWNoaW5lLmNvbmZpZy5wcmVkaWN0YWJsZUFjdGlvbkFyZ3VtZW50cyA/IHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgc3RhdGU6IF90aGlzLnN0YXRlLFxuICAgICAgICAgICAgX2V2ZW50OiBfZXZlbnRcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBfZXZlbnQ6IF9ldmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoX3RoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5wYXJlbnQuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6ICd4c3RhdGUuZXJyb3InLFxuICAgICAgICAgICAgICBkYXRhOiBlcnJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgcmFpc2U6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gaWYgcmFpc2UgYWN0aW9uIHJlYWNoZWQgdGhlIGludGVycHJldGVyIHRoZW4gaXQncyBhIGRlbGF5ZWQgb25lXG4gICAgICAgICAgICB2YXIgc2VuZEFjdGlvbl8xID0gYWN0aW9uO1xuXG4gICAgICAgICAgICBfdGhpcy5kZWZlcihzZW5kQWN0aW9uXzEpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBzZW5kOlxuICAgICAgICAgIHZhciBzZW5kQWN0aW9uID0gYWN0aW9uO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBzZW5kQWN0aW9uLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgX3RoaXMuZGVmZXIoc2VuZEFjdGlvbik7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlbmRBY3Rpb24udG8pIHtcbiAgICAgICAgICAgICAgX3RoaXMuc2VuZFRvKHNlbmRBY3Rpb24uX2V2ZW50LCBzZW5kQWN0aW9uLnRvLCBfZXZlbnQgPT09IGluaXRFdmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpcy5zZW5kKHNlbmRBY3Rpb24uX2V2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGNhbmNlbDpcbiAgICAgICAgICBfdGhpcy5jYW5jZWwoYWN0aW9uLnNlbmRJZCk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0dXMgIT09IEludGVycHJldGVyU3RhdHVzLlJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYWN0aXZpdHkgPSBhY3Rpb24uYWN0aXZpdHk7IC8vIElmIHRoZSBhY3Rpdml0eSB3aWxsIGJlIHN0b3BwZWQgcmlnaHQgYWZ0ZXIgaXQncyBzdGFydGVkXG4gICAgICAgICAgICAvLyAoc3VjaCBhcyBpbiB0cmFuc2llbnQgc3RhdGVzKVxuICAgICAgICAgICAgLy8gZG9uJ3QgYm90aGVyIHN0YXJ0aW5nIHRoZSBhY3Rpdml0eS5cblxuICAgICAgICAgICAgaWYgKCAvLyBpbiB2NCB3aXRoIGBwcmVkaWN0YWJsZUFjdGlvbkFyZ3VtZW50c2AgaW52b2tlcyBhcmUgY2FsbGVkIGVhZ2VybHkgd2hlbiB0aGUgYHRoaXMuc3RhdGVgIHN0aWxsIHBvaW50cyB0byB0aGUgcHJldmlvdXMgc3RhdGVcbiAgICAgICAgICAgICFfdGhpcy5tYWNoaW5lLmNvbmZpZy5wcmVkaWN0YWJsZUFjdGlvbkFyZ3VtZW50cyAmJiAhX3RoaXMuc3RhdGUuYWN0aXZpdGllc1thY3Rpdml0eS5pZCB8fCBhY3Rpdml0eS50eXBlXSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gLy8gSW52b2tlZCBzZXJ2aWNlc1xuXG5cbiAgICAgICAgICAgIGlmIChhY3Rpdml0eS50eXBlID09PSBBY3Rpb25UeXBlcy5JbnZva2UpIHtcbiAgICAgICAgICAgICAgdmFyIGludm9rZVNvdXJjZSA9IHRvSW52b2tlU291cmNlKGFjdGl2aXR5LnNyYyk7XG4gICAgICAgICAgICAgIHZhciBzZXJ2aWNlQ3JlYXRvciA9IF90aGlzLm1hY2hpbmUub3B0aW9ucy5zZXJ2aWNlcyA/IF90aGlzLm1hY2hpbmUub3B0aW9ucy5zZXJ2aWNlc1tpbnZva2VTb3VyY2UudHlwZV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIHZhciBpZCA9IGFjdGl2aXR5LmlkLFxuICAgICAgICAgICAgICAgICAgZGF0YSA9IGFjdGl2aXR5LmRhdGE7XG5cbiAgICAgICAgICAgICAgaWYgKCFJU19QUk9EVUNUSU9OKSB7XG4gICAgICAgICAgICAgICAgd2FybighKCdmb3J3YXJkJyBpbiBhY3Rpdml0eSksIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgICAgICAgICAgICBcImBmb3J3YXJkYCBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkIChmb3VuZCBpbiBpbnZvY2F0aW9uIG9mICdcIi5jb25jYXQoYWN0aXZpdHkuc3JjLCBcIicgaW4gaW4gbWFjaGluZSAnXCIpLmNvbmNhdChfdGhpcy5tYWNoaW5lLmlkLCBcIicpLiBcIikgKyBcIlBsZWFzZSB1c2UgYGF1dG9Gb3J3YXJkYCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBhdXRvRm9yd2FyZCA9ICdhdXRvRm9yd2FyZCcgaW4gYWN0aXZpdHkgPyBhY3Rpdml0eS5hdXRvRm9yd2FyZCA6ICEhYWN0aXZpdHkuZm9yd2FyZDtcblxuICAgICAgICAgICAgICBpZiAoIXNlcnZpY2VDcmVhdG9yKSB7XG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBpZiAoIUlTX1BST0RVQ1RJT04pIHtcbiAgICAgICAgICAgICAgICAgIHdhcm4oZmFsc2UsIFwiTm8gc2VydmljZSBmb3VuZCBmb3IgaW52b2NhdGlvbiAnXCIuY29uY2F0KGFjdGl2aXR5LnNyYywgXCInIGluIG1hY2hpbmUgJ1wiKS5jb25jYXQoX3RoaXMubWFjaGluZS5pZCwgXCInLlwiKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHJlc29sdmVkRGF0YSA9IGRhdGEgPyBtYXBDb250ZXh0KGRhdGEsIGNvbnRleHQsIF9ldmVudCkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXJ2aWNlQ3JlYXRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3YXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGlzRnVuY3Rpb24oc2VydmljZUNyZWF0b3IpID8gc2VydmljZUNyZWF0b3IoY29udGV4dCwgX2V2ZW50LmRhdGEsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiByZXNvbHZlZERhdGEsXG4gICAgICAgICAgICAgICAgc3JjOiBpbnZva2VTb3VyY2UsXG4gICAgICAgICAgICAgICAgbWV0YTogYWN0aXZpdHkubWV0YVxuICAgICAgICAgICAgICB9KSA6IHNlcnZpY2VDcmVhdG9yO1xuXG4gICAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2Fybj9cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICBpZiAoaXNNYWNoaW5lKHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSByZXNvbHZlZERhdGEgPyBzb3VyY2Uud2l0aENvbnRleHQocmVzb2x2ZWREYXRhKSA6IHNvdXJjZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgYXV0b0ZvcndhcmQ6IGF1dG9Gb3J3YXJkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF90aGlzLnNwYXduKHNvdXJjZSwgaWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXMuc3Bhd25BY3Rpdml0eShhY3Rpdml0eSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIHN0b3A6XG4gICAgICAgICAge1xuICAgICAgICAgICAgX3RoaXMuc3RvcENoaWxkKGFjdGlvbi5hY3Rpdml0eS5pZCk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIGxvZzpcbiAgICAgICAgICB2YXIgX2EgPSBhY3Rpb24sXG4gICAgICAgICAgICAgIGxhYmVsID0gX2EubGFiZWwsXG4gICAgICAgICAgICAgIHZhbHVlID0gX2EudmFsdWU7XG5cbiAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlcihsYWJlbCwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIodmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFJU19QUk9EVUNUSU9OKSB7XG4gICAgICAgICAgICB3YXJuKGZhbHNlLCBcIk5vIGltcGxlbWVudGF0aW9uIGZvdW5kIGZvciBhY3Rpb24gdHlwZSAnXCIuY29uY2F0KGFjdGlvbi50eXBlLCBcIidcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZWRPcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIEludGVycHJldGVyLmRlZmF1bHRPcHRpb25zKSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgY2xvY2sgPSByZXNvbHZlZE9wdGlvbnMuY2xvY2ssXG4gICAgICAgIGxvZ2dlciA9IHJlc29sdmVkT3B0aW9ucy5sb2dnZXIsXG4gICAgICAgIHBhcmVudCA9IHJlc29sdmVkT3B0aW9ucy5wYXJlbnQsXG4gICAgICAgIGlkID0gcmVzb2x2ZWRPcHRpb25zLmlkO1xuICAgIHZhciByZXNvbHZlZElkID0gaWQgIT09IHVuZGVmaW5lZCA/IGlkIDogbWFjaGluZS5pZDtcbiAgICB0aGlzLmlkID0gcmVzb2x2ZWRJZDtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmNsb2NrID0gY2xvY2s7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gcmVzb2x2ZWRPcHRpb25zO1xuICAgIHRoaXMuc2NoZWR1bGVyID0gbmV3IFNjaGVkdWxlcih7XG4gICAgICBkZWZlckV2ZW50czogdGhpcy5vcHRpb25zLmRlZmVyRXZlbnRzXG4gICAgfSk7XG4gICAgdGhpcy5zZXNzaW9uSWQgPSByZWdpc3RyeS5ib29rSWQoKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnRlcnByZXRlci5wcm90b3R5cGUsIFwiaW5pdGlhbFN0YXRlXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9pbml0aWFsU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXRpYWxTdGF0ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb3ZpZGUodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5faW5pdGlhbFN0YXRlID0gX3RoaXMubWFjaGluZS5pbml0aWFsU3RhdGU7XG4gICAgICAgIHJldHVybiBfdGhpcy5faW5pdGlhbFN0YXRlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnRlcnByZXRlci5wcm90b3R5cGUsIFwic3RhdGVcIiwge1xuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGAuZ2V0U25hcHNob3QoKWAgaW5zdGVhZC5cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFJU19QUk9EVUNUSU9OKSB7XG4gICAgICAgIHdhcm4odGhpcy5zdGF0dXMgIT09IEludGVycHJldGVyU3RhdHVzLk5vdFN0YXJ0ZWQsIFwiQXR0ZW1wdGVkIHRvIHJlYWQgc3RhdGUgZnJvbSB1bmluaXRpYWxpemVkIHNlcnZpY2UgJ1wiLmNvbmNhdCh0aGlzLmlkLCBcIicuIE1ha2Ugc3VyZSB0aGUgc2VydmljZSBpcyBzdGFydGVkIGZpcnN0LlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXHJcbiAgICogRXhlY3V0ZXMgdGhlIGFjdGlvbnMgb2YgdGhlIGdpdmVuIHN0YXRlLCB3aXRoIHRoYXQgc3RhdGUncyBgY29udGV4dGAgYW5kIGBldmVudGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHdob3NlIGFjdGlvbnMgd2lsbCBiZSBleGVjdXRlZFxyXG4gICAqIEBwYXJhbSBhY3Rpb25zQ29uZmlnIFRoZSBhY3Rpb24gaW1wbGVtZW50YXRpb25zIHRvIHVzZVxyXG4gICAqL1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb25zQ29uZmlnKSB7XG4gICAgdmFyIGVfMSwgX2E7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhzdGF0ZS5hY3Rpb25zKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICB2YXIgYWN0aW9uID0gX2MudmFsdWU7XG4gICAgICAgIHRoaXMuZXhlYyhhY3Rpb24sIHN0YXRlLCBhY3Rpb25zQ29uZmlnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgZV8xID0ge1xuICAgICAgICBlcnJvcjogZV8xXzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgX2V2ZW50KSB7XG4gICAgdmFyIGVfMiwgX2EsIGVfMywgX2IsIGVfNCwgX2MsIGVfNSwgX2Q7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzOyAvLyBBdHRhY2ggc2Vzc2lvbiBJRCB0byBzdGF0ZVxuXG5cbiAgICBzdGF0ZS5fc2Vzc2lvbmlkID0gdGhpcy5zZXNzaW9uSWQ7IC8vIFVwZGF0ZSBzdGF0ZVxuXG4gICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTsgLy8gRXhlY3V0ZSBhY3Rpb25zXG5cbiAgICBpZiAoKCF0aGlzLm1hY2hpbmUuY29uZmlnLnByZWRpY3RhYmxlQWN0aW9uQXJndW1lbnRzIHx8IC8vIHRoaXMgaXMgY3VycmVudGx5IHJlcXVpcmVkIHRvIGV4ZWN1dGUgaW5pdGlhbCBhY3Rpb25zIGFzIHRoZSBgaW5pdGlhbFN0YXRlYCBnZXRzIGNhY2hlZFxuICAgIC8vIHdlIGNhbid0IGp1c3QgcmVjb21wdXRlIGl0IChhbmQgZXhlY3V0ZSBhY3Rpb25zIHdoaWxlIGRvaW5nIHNvKSBiZWNhdXNlIHdlIHRyeSB0byBwcmVzZXJ2ZSBpZGVudGl0eSBvZiBhY3RvcnMgY3JlYXRlZCB3aXRoaW4gaW5pdGlhbCBhc3NpZ25zXG4gICAgX2V2ZW50ID09PSBpbml0RXZlbnQpICYmIHRoaXMub3B0aW9ucy5leGVjdXRlKSB7XG4gICAgICB0aGlzLmV4ZWN1dGUodGhpcy5zdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpdGVtID0gdm9pZCAwO1xuXG4gICAgICB3aGlsZSAoaXRlbSA9IHRoaXMuX291dGdvaW5nUXVldWUuc2hpZnQoKSkge1xuICAgICAgICBpdGVtWzBdLnNlbmQoaXRlbVsxXSk7XG4gICAgICB9XG4gICAgfSAvLyBVcGRhdGUgY2hpbGRyZW5cblxuXG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgX3RoaXMuc3RhdGUuY2hpbGRyZW5bY2hpbGQuaWRdID0gY2hpbGQ7XG4gICAgfSk7IC8vIERldiB0b29sc1xuXG4gICAgaWYgKHRoaXMuZGV2VG9vbHMpIHtcbiAgICAgIHRoaXMuZGV2VG9vbHMuc2VuZChfZXZlbnQuZGF0YSwgc3RhdGUpO1xuICAgIH0gLy8gRXhlY3V0ZSBsaXN0ZW5lcnNcblxuXG4gICAgaWYgKHN0YXRlLmV2ZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfZSA9IF9fdmFsdWVzKHRoaXMuZXZlbnRMaXN0ZW5lcnMpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGxpc3RlbmVyID0gX2YudmFsdWU7XG4gICAgICAgICAgbGlzdGVuZXIoc3RhdGUuZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzJfMSkge1xuICAgICAgICBlXzIgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfMl8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChfZiAmJiAhX2YuZG9uZSAmJiAoX2EgPSBfZS5yZXR1cm4pKSBfYS5jYWxsKF9lKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2cgPSBfX3ZhbHVlcyh0aGlzLmxpc3RlbmVycyksIF9oID0gX2cubmV4dCgpOyAhX2guZG9uZTsgX2ggPSBfZy5uZXh0KCkpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gX2gudmFsdWU7XG4gICAgICAgIGxpc3RlbmVyKHN0YXRlLCBzdGF0ZS5ldmVudCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZV8zXzEpIHtcbiAgICAgIGVfMyA9IHtcbiAgICAgICAgZXJyb3I6IGVfM18xXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoX2ggJiYgIV9oLmRvbmUgJiYgKF9iID0gX2cucmV0dXJuKSkgX2IuY2FsbChfZyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9qID0gX192YWx1ZXModGhpcy5jb250ZXh0TGlzdGVuZXJzKSwgX2sgPSBfai5uZXh0KCk7ICFfay5kb25lOyBfayA9IF9qLm5leHQoKSkge1xuICAgICAgICB2YXIgY29udGV4dExpc3RlbmVyID0gX2sudmFsdWU7XG4gICAgICAgIGNvbnRleHRMaXN0ZW5lcih0aGlzLnN0YXRlLmNvbnRleHQsIHRoaXMuc3RhdGUuaGlzdG9yeSA/IHRoaXMuc3RhdGUuaGlzdG9yeS5jb250ZXh0IDogdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzRfMSkge1xuICAgICAgZV80ID0ge1xuICAgICAgICBlcnJvcjogZV80XzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfayAmJiAhX2suZG9uZSAmJiAoX2MgPSBfai5yZXR1cm4pKSBfYy5jYWxsKF9qKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5kb25lKSB7XG4gICAgICAvLyBnZXQgZmluYWwgY2hpbGQgc3RhdGUgbm9kZVxuICAgICAgdmFyIGZpbmFsQ2hpbGRTdGF0ZU5vZGUgPSBzdGF0ZS5jb25maWd1cmF0aW9uLmZpbmQoZnVuY3Rpb24gKHNuKSB7XG4gICAgICAgIHJldHVybiBzbi50eXBlID09PSAnZmluYWwnICYmIHNuLnBhcmVudCA9PT0gX3RoaXMubWFjaGluZTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGRvbmVEYXRhID0gZmluYWxDaGlsZFN0YXRlTm9kZSAmJiBmaW5hbENoaWxkU3RhdGVOb2RlLmRvbmVEYXRhID8gbWFwQ29udGV4dChmaW5hbENoaWxkU3RhdGVOb2RlLmRvbmVEYXRhLCBzdGF0ZS5jb250ZXh0LCBfZXZlbnQpIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fZG9uZUV2ZW50ID0gZG9uZUludm9rZSh0aGlzLmlkLCBkb25lRGF0YSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9sID0gX192YWx1ZXModGhpcy5kb25lTGlzdGVuZXJzKSwgX20gPSBfbC5uZXh0KCk7ICFfbS5kb25lOyBfbSA9IF9sLm5leHQoKSkge1xuICAgICAgICAgIHZhciBsaXN0ZW5lciA9IF9tLnZhbHVlO1xuICAgICAgICAgIGxpc3RlbmVyKHRoaXMuX2RvbmVFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVfNV8xKSB7XG4gICAgICAgIGVfNSA9IHtcbiAgICAgICAgICBlcnJvcjogZV81XzFcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKF9tICYmICFfbS5kb25lICYmIChfZCA9IF9sLnJldHVybikpIF9kLmNhbGwoX2wpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zdG9wKCk7XG5cbiAgICAgIHRoaXMuX3N0b3BDaGlsZHJlbigpO1xuXG4gICAgICByZWdpc3RyeS5mcmVlKHRoaXMuc2Vzc2lvbklkKTtcbiAgICB9XG4gIH07XG4gIC8qXHJcbiAgICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgaXMgbm90aWZpZWQgd2hlbmV2ZXIgYSBzdGF0ZSB0cmFuc2l0aW9uIGhhcHBlbnMuIFRoZSBsaXN0ZW5lciBpcyBjYWxsZWQgd2l0aFxyXG4gICAqIHRoZSBuZXh0IHN0YXRlIGFuZCB0aGUgZXZlbnQgb2JqZWN0IHRoYXQgY2F1c2VkIHRoZSBzdGF0ZSB0cmFuc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBzdGF0ZSBsaXN0ZW5lclxyXG4gICAqL1xuXG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLm9uVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIHRoaXMubGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7IC8vIFNlbmQgY3VycmVudCBzdGF0ZSB0byBsaXN0ZW5lclxuXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBJbnRlcnByZXRlclN0YXR1cy5SdW5uaW5nKSB7XG4gICAgICBsaXN0ZW5lcih0aGlzLnN0YXRlLCB0aGlzLnN0YXRlLmV2ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG5leHRMaXN0ZW5lck9yT2JzZXJ2ZXIsIF8sIC8vIFRPRE86IGVycm9yIGxpc3RlbmVyXG4gIGNvbXBsZXRlTGlzdGVuZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9ic2VydmVyID0gdG9PYnNlcnZlcihuZXh0TGlzdGVuZXJPck9ic2VydmVyLCBfLCBjb21wbGV0ZUxpc3RlbmVyKTtcbiAgICB0aGlzLmxpc3RlbmVycy5hZGQob2JzZXJ2ZXIubmV4dCk7IC8vIFNlbmQgY3VycmVudCBzdGF0ZSB0byBsaXN0ZW5lclxuXG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBJbnRlcnByZXRlclN0YXR1cy5Ob3RTdGFydGVkKSB7XG4gICAgICBvYnNlcnZlci5uZXh0KHRoaXMuc3RhdGUpO1xuICAgIH1cblxuICAgIHZhciBjb21wbGV0ZU9uY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5kb25lTGlzdGVuZXJzLmRlbGV0ZShjb21wbGV0ZU9uY2UpO1xuXG4gICAgICBfdGhpcy5zdG9wTGlzdGVuZXJzLmRlbGV0ZShjb21wbGV0ZU9uY2UpO1xuXG4gICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgIH07XG5cbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IEludGVycHJldGVyU3RhdHVzLlN0b3BwZWQpIHtcbiAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25Eb25lKGNvbXBsZXRlT25jZSk7XG4gICAgICB0aGlzLm9uU3RvcChjb21wbGV0ZU9uY2UpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5saXN0ZW5lcnMuZGVsZXRlKG9ic2VydmVyLm5leHQpO1xuXG4gICAgICAgIF90aGlzLmRvbmVMaXN0ZW5lcnMuZGVsZXRlKGNvbXBsZXRlT25jZSk7XG5cbiAgICAgICAgX3RoaXMuc3RvcExpc3RlbmVycy5kZWxldGUoY29tcGxldGVPbmNlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICAvKipcclxuICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgaXMgbm90aWZpZWQgd2hlbmV2ZXIgYW4gZXZlbnQgaXMgc2VudCB0byB0aGUgcnVubmluZyBpbnRlcnByZXRlci5cclxuICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGV2ZW50IGxpc3RlbmVyXHJcbiAgICovXG5cblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUub25FdmVudCA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGlzIG5vdGlmaWVkIHdoZW5ldmVyIGEgYHNlbmRgIGV2ZW50IG9jY3Vycy5cclxuICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGV2ZW50IGxpc3RlbmVyXHJcbiAgICovXG5cblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUub25TZW5kID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5zZW5kTGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIEFkZHMgYSBjb250ZXh0IGxpc3RlbmVyIHRoYXQgaXMgbm90aWZpZWQgd2hlbmV2ZXIgdGhlIHN0YXRlIGNvbnRleHQgY2hhbmdlcy5cclxuICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGNvbnRleHQgbGlzdGVuZXJcclxuICAgKi9cblxuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5vbkNoYW5nZSA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIHRoaXMuY29udGV4dExpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBBZGRzIGEgbGlzdGVuZXIgdGhhdCBpcyBub3RpZmllZCB3aGVuIHRoZSBtYWNoaW5lIGlzIHN0b3BwZWQuXHJcbiAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lclxyXG4gICAqL1xuXG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLm9uU3RvcCA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIHRoaXMuc3RvcExpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBBZGRzIGEgc3RhdGUgbGlzdGVuZXIgdGhhdCBpcyBub3RpZmllZCB3aGVuIHRoZSBzdGF0ZWNoYXJ0IGhhcyByZWFjaGVkIGl0cyBmaW5hbCBzdGF0ZS5cclxuICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIHN0YXRlIGxpc3RlbmVyXHJcbiAgICovXG5cblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUub25Eb25lID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBJbnRlcnByZXRlclN0YXR1cy5TdG9wcGVkICYmIHRoaXMuX2RvbmVFdmVudCkge1xuICAgICAgbGlzdGVuZXIodGhpcy5fZG9uZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb25lTGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgYSBsaXN0ZW5lci5cclxuICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIHJlbW92ZVxyXG4gICAqL1xuXG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIHRoaXMuc2VuZExpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIHRoaXMuc3RvcExpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIHRoaXMuZG9uZUxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIHRoaXMuY29udGV4dExpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBTdGFydHMgdGhlIGludGVycHJldGVyIGZyb20gdGhlIGdpdmVuIHN0YXRlLCBvciB0aGUgaW5pdGlhbCBzdGF0ZS5cclxuICAgKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFRoZSBzdGF0ZSB0byBzdGFydCB0aGUgc3RhdGVjaGFydCBmcm9tXHJcbiAgICovXG5cblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gSW50ZXJwcmV0ZXJTdGF0dXMuUnVubmluZykge1xuICAgICAgLy8gRG8gbm90IHJlc3RhcnQgdGhlIHNlcnZpY2UgaWYgaXQgaXMgYWxyZWFkeSBzdGFydGVkXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIHllcywgaXQncyBhIGhhY2sgYnV0IHdlIG5lZWQgdGhlIHJlbGF0ZWQgY2FjaGUgdG8gYmUgcG9wdWxhdGVkIGZvciBzb21lIHRoaW5ncyB0byB3b3JrIChsaWtlIGRlbGF5ZWQgdHJhbnNpdGlvbnMpXG4gICAgLy8gdGhpcyBpcyB1c3VhbGx5IGNhbGxlZCBieSBgbWFjaGluZS5nZXRJbml0aWFsU3RhdGVgIGJ1dCBpZiB3ZSByZWh5ZHJhdGUgZnJvbSBhIHN0YXRlIHdlIG1pZ2h0IGJ5cGFzcyB0aGlzIGNhbGxcbiAgICAvLyB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB0aGlzIG1ldGhvZCBoZXJlIGFzIGl0IHJlc29sdmVzIHRoZSBmdWxsIGluaXRpYWwgc3RhdGUgd2hpY2ggbWlnaHQgaW52b2x2ZSBjYWxsaW5nIGFzc2lnbiBhY3Rpb25zXG4gICAgLy8gYW5kIHRoYXQgY291bGQgcG90ZW50aWFsbHkgbGVhZCB0byBzb21lIHVud2FudGVkIHNpZGUtZWZmZWN0cyAoZXZlbiBzdWNoIGFzIGNyZWF0aW5nIHNvbWUgcm9ndWUgYWN0b3JzKVxuXG5cbiAgICB0aGlzLm1hY2hpbmUuX2luaXQoKTtcblxuICAgIHJlZ2lzdHJ5LnJlZ2lzdGVyKHRoaXMuc2Vzc2lvbklkLCB0aGlzKTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXR1cyA9IEludGVycHJldGVyU3RhdHVzLlJ1bm5pbmc7XG4gICAgdmFyIHJlc29sdmVkU3RhdGUgPSBpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCA/IHRoaXMuaW5pdGlhbFN0YXRlIDogcHJvdmlkZSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaXNTdGF0ZUNvbmZpZyhpbml0aWFsU3RhdGUpID8gX3RoaXMubWFjaGluZS5yZXNvbHZlU3RhdGUoaW5pdGlhbFN0YXRlKSA6IF90aGlzLm1hY2hpbmUucmVzb2x2ZVN0YXRlKFN0YXRlLmZyb20oaW5pdGlhbFN0YXRlLCBfdGhpcy5tYWNoaW5lLmNvbnRleHQpKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGV2VG9vbHMpIHtcbiAgICAgIHRoaXMuYXR0YWNoRGV2KCk7XG4gICAgfVxuXG4gICAgdGhpcy5zY2hlZHVsZXIuaW5pdGlhbGl6ZShmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy51cGRhdGUocmVzb2x2ZWRTdGF0ZSwgaW5pdEV2ZW50KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuX3N0b3BDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPOiB0aGluayBhYm91dCBjb252ZXJ0aW5nIHRob3NlIHRvIGFjdGlvbnNcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihjaGlsZC5zdG9wKSkge1xuICAgICAgICBjaGlsZC5zdG9wKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jaGlsZHJlbi5jbGVhcigpO1xuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZV82LCBfYSwgZV83LCBfYiwgZV84LCBfYywgZV85LCBfZCwgZV8xMCwgX2U7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2YgPSBfX3ZhbHVlcyh0aGlzLmxpc3RlbmVycyksIF9nID0gX2YubmV4dCgpOyAhX2cuZG9uZTsgX2cgPSBfZi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gX2cudmFsdWU7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZV82XzEpIHtcbiAgICAgIGVfNiA9IHtcbiAgICAgICAgZXJyb3I6IGVfNl8xXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoX2cgJiYgIV9nLmRvbmUgJiYgKF9hID0gX2YucmV0dXJuKSkgX2EuY2FsbChfZik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZV82KSB0aHJvdyBlXzYuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9oID0gX192YWx1ZXModGhpcy5zdG9wTGlzdGVuZXJzKSwgX2ogPSBfaC5uZXh0KCk7ICFfai5kb25lOyBfaiA9IF9oLm5leHQoKSkge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBfai52YWx1ZTsgLy8gY2FsbCBsaXN0ZW5lciwgdGhlbiByZW1vdmVcblxuICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzdfMSkge1xuICAgICAgZV83ID0ge1xuICAgICAgICBlcnJvcjogZV83XzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfaiAmJiAhX2ouZG9uZSAmJiAoX2IgPSBfaC5yZXR1cm4pKSBfYi5jYWxsKF9oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzcpIHRocm93IGVfNy5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2sgPSBfX3ZhbHVlcyh0aGlzLmNvbnRleHRMaXN0ZW5lcnMpLCBfbCA9IF9rLm5leHQoKTsgIV9sLmRvbmU7IF9sID0gX2submV4dCgpKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IF9sLnZhbHVlO1xuICAgICAgICB0aGlzLmNvbnRleHRMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzhfMSkge1xuICAgICAgZV84ID0ge1xuICAgICAgICBlcnJvcjogZV84XzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfbCAmJiAhX2wuZG9uZSAmJiAoX2MgPSBfay5yZXR1cm4pKSBfYy5jYWxsKF9rKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzgpIHRocm93IGVfOC5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX20gPSBfX3ZhbHVlcyh0aGlzLmRvbmVMaXN0ZW5lcnMpLCBfbyA9IF9tLm5leHQoKTsgIV9vLmRvbmU7IF9vID0gX20ubmV4dCgpKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IF9vLnZhbHVlO1xuICAgICAgICB0aGlzLmRvbmVMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzlfMSkge1xuICAgICAgZV85ID0ge1xuICAgICAgICBlcnJvcjogZV85XzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfbyAmJiAhX28uZG9uZSAmJiAoX2QgPSBfbS5yZXR1cm4pKSBfZC5jYWxsKF9tKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzkpIHRocm93IGVfOS5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIC8vIEludGVycHJldGVyIGFscmVhZHkgc3RvcHBlZDsgZG8gbm90aGluZ1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdHVzID0gSW50ZXJwcmV0ZXJTdGF0dXMuU3RvcHBlZDtcbiAgICB0aGlzLl9pbml0aWFsU3RhdGUgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgLy8gd2UgYXJlIGdvaW5nIHRvIHN0b3Agd2l0aGluIHRoZSBjdXJyZW50IHN5bmMgZnJhbWVcbiAgICAgIC8vIHNvIHdlIGNhbiBzYWZlbHkganVzdCBjYW5jZWwgdGhpcyBoZXJlIGFzIG5vdGhpbmcgYXN5bmMgc2hvdWxkIGJlIGZpcmVkIGFueXdheVxuICAgICAgZm9yICh2YXIgX3AgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyh0aGlzLmRlbGF5ZWRFdmVudHNNYXApKSwgX3EgPSBfcC5uZXh0KCk7ICFfcS5kb25lOyBfcSA9IF9wLm5leHQoKSkge1xuICAgICAgICB2YXIga2V5ID0gX3EudmFsdWU7XG4gICAgICAgIHRoaXMuY2xvY2suY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXllZEV2ZW50c01hcFtrZXldKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzEwXzEpIHtcbiAgICAgIGVfMTAgPSB7XG4gICAgICAgIGVycm9yOiBlXzEwXzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfcSAmJiAhX3EuZG9uZSAmJiAoX2UgPSBfcC5yZXR1cm4pKSBfZS5jYWxsKF9wKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzEwKSB0aHJvdyBlXzEwLmVycm9yO1xuICAgICAgfVxuICAgIH0gLy8gY2xlYXIgZXZlcnl0aGluZyB0aGF0IG1pZ2h0IGJlIGVucXVldWVkXG5cblxuICAgIHRoaXMuc2NoZWR1bGVyLmNsZWFyKCk7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBuZXcgU2NoZWR1bGVyKHtcbiAgICAgIGRlZmVyRXZlbnRzOiB0aGlzLm9wdGlvbnMuZGVmZXJFdmVudHNcbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogU3RvcHMgdGhlIGludGVycHJldGVyIGFuZCB1bnN1YnNjcmliZSBhbGwgbGlzdGVuZXJzLlxyXG4gICAqXHJcbiAgICogVGhpcyB3aWxsIGFsc28gbm90aWZ5IHRoZSBgb25TdG9wYCBsaXN0ZW5lcnMuXHJcbiAgICovXG5cblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPOiBhZGQgd2FybmluZyBmb3Igc3RvcHBpbmcgbm9uLXJvb3QgaW50ZXJwcmV0ZXJzXG4gICAgdmFyIF90aGlzID0gdGhpczsgLy8gZ3JhYiB0aGUgY3VycmVudCBzY2hlZHVsZXIgYXMgaXQgd2lsbCBiZSByZXBsYWNlZCBpbiBfc3RvcFxuXG5cbiAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG5cbiAgICB0aGlzLl9zdG9wKCk7IC8vIGxldCB3aGF0IGlzIGN1cnJlbnRseSBwcm9jZXNzZWQgdG8gYmUgZmluaXNoZWRcblxuXG4gICAgc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGl0IGZlZWxzIHdlaXJkIHRvIGhhbmRsZSB0aGlzIGhlcmUgYnV0IHdlIG5lZWQgdG8gaGFuZGxlIHRoaXMgZXZlbiBzbGlnaHRseSBcIm91dCBvZiBiYW5kXCJcbiAgICAgIHZhciBfZXZlbnQgPSB0b1NDWE1MRXZlbnQoe1xuICAgICAgICB0eXBlOiAneHN0YXRlLnN0b3AnXG4gICAgICB9KTtcblxuICAgICAgdmFyIG5leHRTdGF0ZSA9IHByb3ZpZGUoX3RoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV4aXRBY3Rpb25zID0gZmxhdHRlbihfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoX3RoaXMuc3RhdGUuY29uZmlndXJhdGlvbiksIGZhbHNlKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGIub3JkZXIgLSBhLm9yZGVyO1xuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHN0YXRlTm9kZSkge1xuICAgICAgICAgIHJldHVybiB0b0FjdGlvbk9iamVjdHMoc3RhdGVOb2RlLm9uRXhpdCwgX3RoaXMubWFjaGluZS5vcHRpb25zLmFjdGlvbnMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgdmFyIF9hID0gX19yZWFkKHJlc29sdmVBY3Rpb25zKF90aGlzLm1hY2hpbmUsIF90aGlzLnN0YXRlLCBfdGhpcy5zdGF0ZS5jb250ZXh0LCBfZXZlbnQsIFt7XG4gICAgICAgICAgdHlwZTogJ2V4aXQnLFxuICAgICAgICAgIGFjdGlvbnM6IGV4aXRBY3Rpb25zXG4gICAgICAgIH1dLCBfdGhpcy5tYWNoaW5lLmNvbmZpZy5wcmVkaWN0YWJsZUFjdGlvbkFyZ3VtZW50cyA/IF90aGlzLl9leGVjIDogdW5kZWZpbmVkLCBfdGhpcy5tYWNoaW5lLmNvbmZpZy5wcmVkaWN0YWJsZUFjdGlvbkFyZ3VtZW50cyB8fCBfdGhpcy5tYWNoaW5lLmNvbmZpZy5wcmVzZXJ2ZUFjdGlvbk9yZGVyKSwgMiksXG4gICAgICAgICAgICByZXNvbHZlZEFjdGlvbnMgPSBfYVswXSxcbiAgICAgICAgICAgIHVwZGF0ZWRDb250ZXh0ID0gX2FbMV07XG5cbiAgICAgICAgdmFyIG5ld1N0YXRlID0gbmV3IFN0YXRlKHtcbiAgICAgICAgICB2YWx1ZTogX3RoaXMuc3RhdGUudmFsdWUsXG4gICAgICAgICAgY29udGV4dDogdXBkYXRlZENvbnRleHQsXG4gICAgICAgICAgX2V2ZW50OiBfZXZlbnQsXG4gICAgICAgICAgX3Nlc3Npb25pZDogX3RoaXMuc2Vzc2lvbklkLFxuICAgICAgICAgIGhpc3RvcnlWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGhpc3Rvcnk6IF90aGlzLnN0YXRlLFxuICAgICAgICAgIGFjdGlvbnM6IHJlc29sdmVkQWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuICFpc1JhaXNhYmxlQWN0aW9uKGFjdGlvbik7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgYWN0aXZpdGllczoge30sXG4gICAgICAgICAgZXZlbnRzOiBbXSxcbiAgICAgICAgICBjb25maWd1cmF0aW9uOiBbXSxcbiAgICAgICAgICB0cmFuc2l0aW9uczogW10sXG4gICAgICAgICAgY2hpbGRyZW46IHt9LFxuICAgICAgICAgIGRvbmU6IF90aGlzLnN0YXRlLmRvbmUsXG4gICAgICAgICAgdGFnczogX3RoaXMuc3RhdGUudGFncyxcbiAgICAgICAgICBtYWNoaW5lOiBfdGhpcy5tYWNoaW5lXG4gICAgICAgIH0pO1xuICAgICAgICBuZXdTdGF0ZS5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLnVwZGF0ZShuZXh0U3RhdGUsIF9ldmVudCk7XG5cbiAgICAgIF90aGlzLl9zdG9wQ2hpbGRyZW4oKTtcblxuICAgICAgcmVnaXN0cnkuZnJlZShfdGhpcy5zZXNzaW9uSWQpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5iYXRjaCA9IGZ1bmN0aW9uIChldmVudHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBJbnRlcnByZXRlclN0YXR1cy5Ob3RTdGFydGVkICYmIHRoaXMub3B0aW9ucy5kZWZlckV2ZW50cykge1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgIGlmICghSVNfUFJPRFVDVElPTikge1xuICAgICAgICB3YXJuKGZhbHNlLCBcIlwiLmNvbmNhdChldmVudHMubGVuZ3RoLCBcIiBldmVudChzKSB3ZXJlIHNlbnQgdG8gdW5pbml0aWFsaXplZCBzZXJ2aWNlIFxcXCJcIikuY29uY2F0KHRoaXMubWFjaGluZS5pZCwgXCJcXFwiIGFuZCBhcmUgZGVmZXJyZWQuIE1ha2Ugc3VyZSAuc3RhcnQoKSBpcyBjYWxsZWQgZm9yIHRoaXMgc2VydmljZS5cXG5FdmVudDogXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShldmVudCkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzICE9PSBJbnRlcnByZXRlclN0YXR1cy5SdW5uaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgIFwiXCIuY29uY2F0KGV2ZW50cy5sZW5ndGgsIFwiIGV2ZW50KHMpIHdlcmUgc2VudCB0byB1bmluaXRpYWxpemVkIHNlcnZpY2UgXFxcIlwiKS5jb25jYXQodGhpcy5tYWNoaW5lLmlkLCBcIlxcXCIuIE1ha2Ugc3VyZSAuc3RhcnQoKSBpcyBjYWxsZWQgZm9yIHRoaXMgc2VydmljZSwgb3Igc2V0IHsgZGVmZXJFdmVudHM6IHRydWUgfSBpbiB0aGUgc2VydmljZSBvcHRpb25zLlwiKSk7XG4gICAgfVxuXG4gICAgaWYgKCFldmVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGV4ZWMgPSAhIXRoaXMubWFjaGluZS5jb25maWcucHJlZGljdGFibGVBY3Rpb25Bcmd1bWVudHMgJiYgdGhpcy5fZXhlYztcbiAgICB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZV8xMSwgX2E7XG5cbiAgICAgIHZhciBuZXh0U3RhdGUgPSBfdGhpcy5zdGF0ZTtcbiAgICAgIHZhciBiYXRjaENoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciBiYXRjaGVkQWN0aW9ucyA9IFtdO1xuXG4gICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChldmVudF8xKSB7XG4gICAgICAgIHZhciBfZXZlbnQgPSB0b1NDWE1MRXZlbnQoZXZlbnRfMSk7XG5cbiAgICAgICAgX3RoaXMuZm9yd2FyZChfZXZlbnQpO1xuXG4gICAgICAgIG5leHRTdGF0ZSA9IHByb3ZpZGUoX3RoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMubWFjaGluZS50cmFuc2l0aW9uKG5leHRTdGF0ZSwgX2V2ZW50LCB1bmRlZmluZWQsIGV4ZWMgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJhdGNoZWRBY3Rpb25zLnB1c2guYXBwbHkoYmF0Y2hlZEFjdGlvbnMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChfdGhpcy5tYWNoaW5lLmNvbmZpZy5wcmVkaWN0YWJsZUFjdGlvbkFyZ3VtZW50cyA/IG5leHRTdGF0ZS5hY3Rpb25zIDogbmV4dFN0YXRlLmFjdGlvbnMubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgcmV0dXJuIGJpbmRBY3Rpb25Ub1N0YXRlKGEsIG5leHRTdGF0ZSk7XG4gICAgICAgIH0pKSwgZmFsc2UpKTtcbiAgICAgICAgYmF0Y2hDaGFuZ2VkID0gYmF0Y2hDaGFuZ2VkIHx8ICEhbmV4dFN0YXRlLmNoYW5nZWQ7XG4gICAgICB9O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBldmVudHNfMSA9IF9fdmFsdWVzKGV2ZW50cyksIGV2ZW50c18xXzEgPSBldmVudHNfMS5uZXh0KCk7ICFldmVudHNfMV8xLmRvbmU7IGV2ZW50c18xXzEgPSBldmVudHNfMS5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgZXZlbnRfMSA9IGV2ZW50c18xXzEudmFsdWU7XG5cbiAgICAgICAgICBfbG9vcF8xKGV2ZW50XzEpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzExXzEpIHtcbiAgICAgICAgZV8xMSA9IHtcbiAgICAgICAgICBlcnJvcjogZV8xMV8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChldmVudHNfMV8xICYmICFldmVudHNfMV8xLmRvbmUgJiYgKF9hID0gZXZlbnRzXzEucmV0dXJuKSkgX2EuY2FsbChldmVudHNfMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVfMTEpIHRocm93IGVfMTEuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dFN0YXRlLmNoYW5nZWQgPSBiYXRjaENoYW5nZWQ7XG4gICAgICBuZXh0U3RhdGUuYWN0aW9ucyA9IGJhdGNoZWRBY3Rpb25zO1xuXG4gICAgICBfdGhpcy51cGRhdGUobmV4dFN0YXRlLCB0b1NDWE1MRXZlbnQoZXZlbnRzW2V2ZW50cy5sZW5ndGggLSAxXSkpO1xuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm5zIGEgc2VuZCBmdW5jdGlvbiBib3VuZCB0byB0aGlzIGludGVycHJldGVyIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBiZSBzZW50IGJ5IHRoZSBzZW5kZXIuXHJcbiAgICovXG5cblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuc2VuZGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZC5iaW5kKHRoaXMsIGV2ZW50KTtcbiAgfTtcblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuX25leHRTdGF0ZSA9IGZ1bmN0aW9uIChldmVudCwgZXhlYykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoZXhlYyA9PT0gdm9pZCAwKSB7XG4gICAgICBleGVjID0gISF0aGlzLm1hY2hpbmUuY29uZmlnLnByZWRpY3RhYmxlQWN0aW9uQXJndW1lbnRzICYmIHRoaXMuX2V4ZWM7XG4gICAgfVxuXG4gICAgdmFyIF9ldmVudCA9IHRvU0NYTUxFdmVudChldmVudCk7XG5cbiAgICBpZiAoX2V2ZW50Lm5hbWUuaW5kZXhPZihlcnJvclBsYXRmb3JtKSA9PT0gMCAmJiAhdGhpcy5zdGF0ZS5uZXh0RXZlbnRzLnNvbWUoZnVuY3Rpb24gKG5leHRFdmVudCkge1xuICAgICAgcmV0dXJuIG5leHRFdmVudC5pbmRleE9mKGVycm9yUGxhdGZvcm0pID09PSAwO1xuICAgIH0pKSB7XG4gICAgICB0aHJvdyBfZXZlbnQuZGF0YS5kYXRhO1xuICAgIH1cblxuICAgIHZhciBuZXh0U3RhdGUgPSBwcm92aWRlKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5tYWNoaW5lLnRyYW5zaXRpb24oX3RoaXMuc3RhdGUsIF9ldmVudCwgdW5kZWZpbmVkLCBleGVjIHx8IHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgfTtcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgbmV4dCBzdGF0ZSBnaXZlbiB0aGUgaW50ZXJwcmV0ZXIncyBjdXJyZW50IHN0YXRlIGFuZCB0aGUgZXZlbnQuXHJcbiAgICpcclxuICAgKiBUaGlzIGlzIGEgcHVyZSBtZXRob2QgdGhhdCBkb2VzIF9ub3RfIHVwZGF0ZSB0aGUgaW50ZXJwcmV0ZXIncyBzdGF0ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gZGV0ZXJtaW5lIHRoZSBuZXh0IHN0YXRlXHJcbiAgICovXG5cblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUubmV4dFN0YXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX25leHRTdGF0ZShldmVudCwgZmFsc2UpO1xuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGVfMTIsIF9hO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5mb3J3YXJkVG8pLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgIHZhciBpZCA9IF9jLnZhbHVlO1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChpZCk7XG5cbiAgICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmb3J3YXJkIGV2ZW50ICdcIi5jb25jYXQoZXZlbnQsIFwiJyBmcm9tIGludGVycHJldGVyICdcIikuY29uY2F0KHRoaXMuaWQsIFwiJyB0byBub25leGlzdGFudCBjaGlsZCAnXCIpLmNvbmNhdChpZCwgXCInLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZC5zZW5kKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzEyXzEpIHtcbiAgICAgIGVfMTIgPSB7XG4gICAgICAgIGVycm9yOiBlXzEyXzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzEyKSB0aHJvdyBlXzEyLmVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuZGVmZXIgPSBmdW5jdGlvbiAoc2VuZEFjdGlvbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgdGltZXJJZCA9IHRoaXMuY2xvY2suc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoJ3RvJyBpbiBzZW5kQWN0aW9uICYmIHNlbmRBY3Rpb24udG8pIHtcbiAgICAgICAgX3RoaXMuc2VuZFRvKHNlbmRBY3Rpb24uX2V2ZW50LCBzZW5kQWN0aW9uLnRvLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnNlbmQoc2VuZEFjdGlvbi5fZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHNlbmRBY3Rpb24uZGVsYXkpO1xuXG4gICAgaWYgKHNlbmRBY3Rpb24uaWQpIHtcbiAgICAgIHRoaXMuZGVsYXllZEV2ZW50c01hcFtzZW5kQWN0aW9uLmlkXSA9IHRpbWVySWQ7XG4gICAgfVxuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoc2VuZElkKSB7XG4gICAgdGhpcy5jbG9jay5jbGVhclRpbWVvdXQodGhpcy5kZWxheWVkRXZlbnRzTWFwW3NlbmRJZF0pO1xuICAgIGRlbGV0ZSB0aGlzLmRlbGF5ZWRFdmVudHNNYXBbc2VuZElkXTtcbiAgfTtcblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uIChhY3Rpb24sIHN0YXRlLCBhY3Rpb25GdW5jdGlvbk1hcCkge1xuICAgIGlmIChhY3Rpb25GdW5jdGlvbk1hcCA9PT0gdm9pZCAwKSB7XG4gICAgICBhY3Rpb25GdW5jdGlvbk1hcCA9IHRoaXMubWFjaGluZS5vcHRpb25zLmFjdGlvbnM7XG4gICAgfVxuXG4gICAgdGhpcy5fZXhlYyhhY3Rpb24sIHN0YXRlLmNvbnRleHQsIHN0YXRlLl9ldmVudCwgYWN0aW9uRnVuY3Rpb25NYXApO1xuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZElkKSB7XG4gICAgdmFyIF9hO1xuXG4gICAgdGhpcy5jaGlsZHJlbi5kZWxldGUoY2hpbGRJZCk7XG4gICAgdGhpcy5mb3J3YXJkVG8uZGVsZXRlKGNoaWxkSWQpOyAvLyB0aGlzLnN0YXRlIG1pZ2h0IG5vdCBleGlzdCBhdCB0aGUgdGltZSB0aGlzIGlzIGNhbGxlZCxcbiAgICAvLyBzdWNoIGFzIHdoZW4gYSBjaGlsZCBpcyBhZGRlZCB0aGVuIHJlbW92ZWQgd2hpbGUgaW5pdGlhbGl6aW5nIHRoZSBzdGF0ZVxuXG4gICAgKF9hID0gdGhpcy5zdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHRydWUgOiBkZWxldGUgX2EuY2hpbGRyZW5bY2hpbGRJZF07XG4gIH07XG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLnN0b3BDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZElkKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoY2hpbGRJZCk7XG5cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZElkKTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGNoaWxkLnN0b3ApKSB7XG4gICAgICBjaGlsZC5zdG9wKCk7XG4gICAgfVxuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5zcGF3biA9IGZ1bmN0aW9uIChlbnRpdHksIG5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IEludGVycHJldGVyU3RhdHVzLlJ1bm5pbmcpIHtcbiAgICAgIHJldHVybiBjcmVhdGVEZWZlcnJlZEFjdG9yKGVudGl0eSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzUHJvbWlzZUxpa2UoZW50aXR5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3Bhd25Qcm9taXNlKFByb21pc2UucmVzb2x2ZShlbnRpdHkpLCBuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oZW50aXR5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3Bhd25DYWxsYmFjayhlbnRpdHksIG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoaXNTcGF3bmVkQWN0b3IoZW50aXR5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3Bhd25BY3RvcihlbnRpdHksIG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlKGVudGl0eSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwYXduT2JzZXJ2YWJsZShlbnRpdHksIG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoaXNNYWNoaW5lKGVudGl0eSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwYXduTWFjaGluZShlbnRpdHksIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgICAgICBpZDogbmFtZVxuICAgICAgfSkpO1xuICAgIH0gZWxzZSBpZiAoaXNCZWhhdmlvcihlbnRpdHkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGF3bkJlaGF2aW9yKGVudGl0eSwgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBzcGF3biBlbnRpdHkgXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIgb2YgdHlwZSBcXFwiXCIpLmNvbmNhdCh0eXBlb2YgZW50aXR5LCBcIlxcXCIuXCIpKTtcbiAgICB9XG4gIH07XG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLnNwYXduTWFjaGluZSA9IGZ1bmN0aW9uIChtYWNoaW5lLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRTZXJ2aWNlID0gbmV3IEludGVycHJldGVyKG1hY2hpbmUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCB7XG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBpZDogb3B0aW9ucy5pZCB8fCBtYWNoaW5lLmlkXG4gICAgfSkpO1xuXG4gICAgdmFyIHJlc29sdmVkT3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBERUZBVUxUX1NQQVdOX09QVElPTlMpLCBvcHRpb25zKTtcblxuICAgIGlmIChyZXNvbHZlZE9wdGlvbnMuc3luYykge1xuICAgICAgY2hpbGRTZXJ2aWNlLm9uVHJhbnNpdGlvbihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgX3RoaXMuc2VuZCh1cGRhdGUsIHtcbiAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgaWQ6IGNoaWxkU2VydmljZS5pZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBhY3RvciA9IGNoaWxkU2VydmljZTtcbiAgICB0aGlzLmNoaWxkcmVuLnNldChjaGlsZFNlcnZpY2UuaWQsIGFjdG9yKTtcblxuICAgIGlmIChyZXNvbHZlZE9wdGlvbnMuYXV0b0ZvcndhcmQpIHtcbiAgICAgIHRoaXMuZm9yd2FyZFRvLmFkZChjaGlsZFNlcnZpY2UuaWQpO1xuICAgIH1cblxuICAgIGNoaWxkU2VydmljZS5vbkRvbmUoZnVuY3Rpb24gKGRvbmVFdmVudCkge1xuICAgICAgX3RoaXMucmVtb3ZlQ2hpbGQoY2hpbGRTZXJ2aWNlLmlkKTtcblxuICAgICAgX3RoaXMuc2VuZCh0b1NDWE1MRXZlbnQoZG9uZUV2ZW50LCB7XG4gICAgICAgIG9yaWdpbjogY2hpbGRTZXJ2aWNlLmlkXG4gICAgICB9KSk7XG4gICAgfSkuc3RhcnQoKTtcbiAgICByZXR1cm4gYWN0b3I7XG4gIH07XG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLnNwYXduQmVoYXZpb3IgPSBmdW5jdGlvbiAoYmVoYXZpb3IsIGlkKSB7XG4gICAgdmFyIGFjdG9yUmVmID0gc3Bhd25CZWhhdmlvcihiZWhhdmlvciwge1xuICAgICAgaWQ6IGlkLFxuICAgICAgcGFyZW50OiB0aGlzXG4gICAgfSk7XG4gICAgdGhpcy5jaGlsZHJlbi5zZXQoaWQsIGFjdG9yUmVmKTtcbiAgICByZXR1cm4gYWN0b3JSZWY7XG4gIH07XG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLnNwYXduUHJvbWlzZSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpZCkge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmVzb2x2ZWREYXRhO1xuICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmICghY2FuY2VsZWQpIHtcbiAgICAgICAgcmVzb2x2ZWREYXRhID0gcmVzcG9uc2U7XG5cbiAgICAgICAgX3RoaXMucmVtb3ZlQ2hpbGQoaWQpO1xuXG4gICAgICAgIF90aGlzLnNlbmQodG9TQ1hNTEV2ZW50KGRvbmVJbnZva2UoaWQsIHJlc3BvbnNlKSwge1xuICAgICAgICAgIG9yaWdpbjogaWRcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvckRhdGEpIHtcbiAgICAgIGlmICghY2FuY2VsZWQpIHtcbiAgICAgICAgX3RoaXMucmVtb3ZlQ2hpbGQoaWQpO1xuXG4gICAgICAgIHZhciBlcnJvckV2ZW50ID0gZXJyb3IoaWQsIGVycm9yRGF0YSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBTZW5kIFwiZXJyb3IucGxhdGZvcm0uaWRcIiB0byB0aGlzIChwYXJlbnQpLlxuICAgICAgICAgIF90aGlzLnNlbmQodG9TQ1hNTEV2ZW50KGVycm9yRXZlbnQsIHtcbiAgICAgICAgICAgIG9yaWdpbjogaWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXhjZXB0aW9uT25JbnZvY2F0aW9uKGVycm9yRGF0YSwgZXJyb3IsIGlkKTtcblxuICAgICAgICAgIGlmIChfdGhpcy5kZXZUb29scykge1xuICAgICAgICAgICAgX3RoaXMuZGV2VG9vbHMuc2VuZChlcnJvckV2ZW50LCBfdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF90aGlzLm1hY2hpbmUuc3RyaWN0KSB7XG4gICAgICAgICAgICAvLyBpdCB3b3VsZCBiZSBiZXR0ZXIgdG8gYWx3YXlzIHN0b3AgdGhlIHN0YXRlIG1hY2hpbmUgaWYgdW5oYW5kbGVkXG4gICAgICAgICAgICAvLyBleGNlcHRpb24vcHJvbWlzZSByZWplY3Rpb24gaGFwcGVucyBidXQgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgICAgICAvLyBicmVhayBleGlzdGluZyBjb2RlIHNvIGVuZm9yY2UgaXQgb24gc3RyaWN0IG1vZGUgb25seSBlc3BlY2lhbGx5IHNvXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGRvY3VtZW50YXRpb24gc2F5cyB0aGF0IG9uRXJyb3IgaXMgb3B0aW9uYWxcbiAgICAgICAgICAgIF90aGlzLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgYWN0b3IgPSAoX2EgPSB7XG4gICAgICBpZDogaWQsXG4gICAgICBzZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9LFxuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAobmV4dCwgaGFuZGxlRXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IHRvT2JzZXJ2ZXIobmV4dCwgaGFuZGxlRXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgaWYgKHVuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9ic2VydmVyLm5leHQocmVzcG9uc2UpO1xuXG4gICAgICAgICAgaWYgKHVuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAodW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogaWRcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBnZXRTbmFwc2hvdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWREYXRhO1xuICAgICAgfVxuICAgIH0sIF9hW3N5bWJvbE9ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgX2EpO1xuICAgIHRoaXMuY2hpbGRyZW4uc2V0KGlkLCBhY3Rvcik7XG4gICAgcmV0dXJuIGFjdG9yO1xuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5zcGF3bkNhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBpZCkge1xuICAgIHZhciBfYTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmVjZWl2ZXJzID0gbmV3IFNldCgpO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGVtaXR0ZWQ7XG5cbiAgICB2YXIgcmVjZWl2ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBlbWl0dGVkID0gZTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoZSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2VuZCh0b1NDWE1MRXZlbnQoZSwge1xuICAgICAgICBvcmlnaW46IGlkXG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIHZhciBjYWxsYmFja1N0b3A7XG5cbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2tTdG9wID0gY2FsbGJhY2socmVjZWl2ZSwgZnVuY3Rpb24gKG5ld0xpc3RlbmVyKSB7XG4gICAgICAgIHJlY2VpdmVycy5hZGQobmV3TGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLnNlbmQoZXJyb3IoaWQsIGVycikpO1xuICAgIH1cblxuICAgIGlmIChpc1Byb21pc2VMaWtlKGNhbGxiYWNrU3RvcCkpIHtcbiAgICAgIC8vIGl0IHR1cm5lZCBvdXQgdG8gYmUgYW4gYXN5bmMgZnVuY3Rpb24sIGNhbid0IHJlbGlhYmx5IGNoZWNrIHRoaXMgYmVmb3JlIGNhbGxpbmcgYGNhbGxiYWNrYFxuICAgICAgLy8gYmVjYXVzZSB0cmFuc3BpbGVkIGFzeW5jIGZ1bmN0aW9ucyBhcmUgbm90IHJlY29nbml6YWJsZVxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd25Qcm9taXNlKGNhbGxiYWNrU3RvcCwgaWQpO1xuICAgIH1cblxuICAgIHZhciBhY3RvciA9IChfYSA9IHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHNlbmQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gcmVjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlY2VpdmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlY2VpdmVyKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSB0b09ic2VydmVyKG5leHQpO1xuICAgICAgICBsaXN0ZW5lcnMuYWRkKG9ic2VydmVyLm5leHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKG9ic2VydmVyLm5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFja1N0b3ApKSB7XG4gICAgICAgICAgY2FsbGJhY2tTdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogaWRcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBnZXRTbmFwc2hvdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZW1pdHRlZDtcbiAgICAgIH1cbiAgICB9LCBfYVtzeW1ib2xPYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9hKTtcbiAgICB0aGlzLmNoaWxkcmVuLnNldChpZCwgYWN0b3IpO1xuICAgIHJldHVybiBhY3RvcjtcbiAgfTtcblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuc3Bhd25PYnNlcnZhYmxlID0gZnVuY3Rpb24gKHNvdXJjZSwgaWQpIHtcbiAgICB2YXIgX2E7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGVtaXR0ZWQ7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHNvdXJjZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBlbWl0dGVkID0gdmFsdWU7XG5cbiAgICAgIF90aGlzLnNlbmQodG9TQ1hNTEV2ZW50KHZhbHVlLCB7XG4gICAgICAgIG9yaWdpbjogaWRcbiAgICAgIH0pKTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBfdGhpcy5yZW1vdmVDaGlsZChpZCk7XG5cbiAgICAgIF90aGlzLnNlbmQodG9TQ1hNTEV2ZW50KGVycm9yKGlkLCBlcnIpLCB7XG4gICAgICAgIG9yaWdpbjogaWRcbiAgICAgIH0pKTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5yZW1vdmVDaGlsZChpZCk7XG5cbiAgICAgIF90aGlzLnNlbmQodG9TQ1hNTEV2ZW50KGRvbmVJbnZva2UoaWQpLCB7XG4gICAgICAgIG9yaWdpbjogaWRcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICB2YXIgYWN0b3IgPSAoX2EgPSB7XG4gICAgICBpZDogaWQsXG4gICAgICBzZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9LFxuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAobmV4dCwgaGFuZGxlRXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5leHQsIGhhbmRsZUVycm9yLCBjb21wbGV0ZSk7XG4gICAgICB9LFxuICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9LFxuICAgICAgZ2V0U25hcHNob3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVtaXR0ZWQ7XG4gICAgICB9LFxuICAgICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IGlkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwgX2Fbc3ltYm9sT2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfYSk7XG4gICAgdGhpcy5jaGlsZHJlbi5zZXQoaWQsIGFjdG9yKTtcbiAgICByZXR1cm4gYWN0b3I7XG4gIH07XG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLnNwYXduQWN0b3IgPSBmdW5jdGlvbiAoYWN0b3IsIG5hbWUpIHtcbiAgICB0aGlzLmNoaWxkcmVuLnNldChuYW1lLCBhY3Rvcik7XG4gICAgcmV0dXJuIGFjdG9yO1xuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS5zcGF3bkFjdGl2aXR5ID0gZnVuY3Rpb24gKGFjdGl2aXR5KSB7XG4gICAgdmFyIGltcGxlbWVudGF0aW9uID0gdGhpcy5tYWNoaW5lLm9wdGlvbnMgJiYgdGhpcy5tYWNoaW5lLm9wdGlvbnMuYWN0aXZpdGllcyA/IHRoaXMubWFjaGluZS5vcHRpb25zLmFjdGl2aXRpZXNbYWN0aXZpdHkudHlwZV0gOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIWltcGxlbWVudGF0aW9uKSB7XG4gICAgICBpZiAoIUlTX1BST0RVQ1RJT04pIHtcbiAgICAgICAgd2FybihmYWxzZSwgXCJObyBpbXBsZW1lbnRhdGlvbiBmb3VuZCBmb3IgYWN0aXZpdHkgJ1wiLmNvbmNhdChhY3Rpdml0eS50eXBlLCBcIidcIikpO1xuICAgICAgfSAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuXG5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFN0YXJ0IGltcGxlbWVudGF0aW9uXG5cblxuICAgIHZhciBkaXNwb3NlID0gaW1wbGVtZW50YXRpb24odGhpcy5zdGF0ZS5jb250ZXh0LCBhY3Rpdml0eSk7XG4gICAgdGhpcy5zcGF3bkVmZmVjdChhY3Rpdml0eS5pZCwgZGlzcG9zZSk7XG4gIH07XG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLnNwYXduRWZmZWN0ID0gZnVuY3Rpb24gKGlkLCBkaXNwb3NlKSB7XG4gICAgdmFyIF9hO1xuXG4gICAgdGhpcy5jaGlsZHJlbi5zZXQoaWQsIChfYSA9IHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHNlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH0sXG4gICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgc3RvcDogZGlzcG9zZSB8fCB1bmRlZmluZWQsXG4gICAgICBnZXRTbmFwc2hvdDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICAgIHRvSlNPTjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBpZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIF9hW3N5bWJvbE9ic2VydmFibGVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgX2EpKTtcbiAgfTtcblxuICBJbnRlcnByZXRlci5wcm90b3R5cGUuYXR0YWNoRGV2ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnbG9iYWwgPSBnZXRHbG9iYWwoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGV2VG9vbHMgJiYgZ2xvYmFsKSB7XG4gICAgICBpZiAoZ2xvYmFsLl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18pIHtcbiAgICAgICAgdmFyIGRldlRvb2xzT3B0aW9ucyA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuZGV2VG9vbHMgPT09ICdvYmplY3QnID8gdGhpcy5vcHRpb25zLmRldlRvb2xzIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRldlRvb2xzID0gZ2xvYmFsLl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18uY29ubmVjdChfX2Fzc2lnbihfX2Fzc2lnbih7XG4gICAgICAgICAgbmFtZTogdGhpcy5pZCxcbiAgICAgICAgICBhdXRvUGF1c2U6IHRydWUsXG4gICAgICAgICAgc3RhdGVTYW5pdGl6ZXI6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHN0YXRlLnZhbHVlLFxuICAgICAgICAgICAgICBjb250ZXh0OiBzdGF0ZS5jb250ZXh0LFxuICAgICAgICAgICAgICBhY3Rpb25zOiBzdGF0ZS5hY3Rpb25zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZGV2VG9vbHNPcHRpb25zKSwge1xuICAgICAgICAgIGZlYXR1cmVzOiBfX2Fzc2lnbih7XG4gICAgICAgICAgICBqdW1wOiBmYWxzZSxcbiAgICAgICAgICAgIHNraXA6IGZhbHNlXG4gICAgICAgICAgfSwgZGV2VG9vbHNPcHRpb25zID8gZGV2VG9vbHNPcHRpb25zLmZlYXR1cmVzIDogdW5kZWZpbmVkKVxuICAgICAgICB9KSwgdGhpcy5tYWNoaW5lKTtcbiAgICAgICAgdGhpcy5kZXZUb29scy5pbml0KHRoaXMuc3RhdGUpO1xuICAgICAgfSAvLyBhZGQgWFN0YXRlLXNwZWNpZmljIGRldiB0b29saW5nIGhvb2tcblxuXG4gICAgICByZWdpc3RlclNlcnZpY2UodGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIEludGVycHJldGVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmlkXG4gICAgfTtcbiAgfTtcblxuICBJbnRlcnByZXRlci5wcm90b3R5cGVbc3ltYm9sT2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgSW50ZXJwcmV0ZXIucHJvdG90eXBlLmdldFNuYXBzaG90ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gSW50ZXJwcmV0ZXJTdGF0dXMuTm90U3RhcnRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFN0YXRlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVGhlIGRlZmF1bHQgaW50ZXJwcmV0ZXIgb3B0aW9uczpcclxuICAgKlxyXG4gICAqIC0gYGNsb2NrYCB1c2VzIHRoZSBnbG9iYWwgYHNldFRpbWVvdXRgIGFuZCBgY2xlYXJUaW1lb3V0YCBmdW5jdGlvbnNcclxuICAgKiAtIGBsb2dnZXJgIHVzZXMgdGhlIGdsb2JhbCBgY29uc29sZS5sb2coKWAgbWV0aG9kXHJcbiAgICovXG5cblxuICBJbnRlcnByZXRlci5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBleGVjdXRlOiB0cnVlLFxuICAgIGRlZmVyRXZlbnRzOiB0cnVlLFxuICAgIGNsb2NrOiB7XG4gICAgICBzZXRUaW1lb3V0OiBmdW5jdGlvbiAoZm4sIG1zKSB7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZuLCBtcyk7XG4gICAgICB9LFxuICAgICAgY2xlYXJUaW1lb3V0OiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChpZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsb2dnZXI6IC8qI19fUFVSRV9fKi9jb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFxuICAgIGRldlRvb2xzOiBmYWxzZVxuICB9O1xuICBJbnRlcnByZXRlci5pbnRlcnByZXQgPSBpbnRlcnByZXQ7XG4gIHJldHVybiBJbnRlcnByZXRlcjtcbn0oKTtcblxudmFyIHJlc29sdmVTcGF3bk9wdGlvbnMgPSBmdW5jdGlvbiAobmFtZU9yT3B0aW9ucykge1xuICBpZiAoaXNTdHJpbmcobmFtZU9yT3B0aW9ucykpIHtcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIERFRkFVTFRfU1BBV05fT1BUSU9OUyksIHtcbiAgICAgIG5hbWU6IG5hbWVPck9wdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgREVGQVVMVF9TUEFXTl9PUFRJT05TKSwge1xuICAgIG5hbWU6IHVuaXF1ZUlkKClcbiAgfSksIG5hbWVPck9wdGlvbnMpO1xufTtcblxuZnVuY3Rpb24gc3Bhd24oZW50aXR5LCBuYW1lT3JPcHRpb25zKSB7XG4gIHZhciByZXNvbHZlZE9wdGlvbnMgPSByZXNvbHZlU3Bhd25PcHRpb25zKG5hbWVPck9wdGlvbnMpO1xuICByZXR1cm4gY29uc3VtZShmdW5jdGlvbiAoc2VydmljZSkge1xuICAgIGlmICghSVNfUFJPRFVDVElPTikge1xuICAgICAgdmFyIGlzTGF6eUVudGl0eSA9IGlzTWFjaGluZShlbnRpdHkpIHx8IGlzRnVuY3Rpb24oZW50aXR5KTtcbiAgICAgIHdhcm4oISFzZXJ2aWNlIHx8IGlzTGF6eUVudGl0eSwgXCJBdHRlbXB0ZWQgdG8gc3Bhd24gYW4gQWN0b3IgKElEOiBcXFwiXCIuY29uY2F0KGlzTWFjaGluZShlbnRpdHkpID8gZW50aXR5LmlkIDogJ3VuZGVmaW5lZCcsIFwiXFxcIikgb3V0c2lkZSBvZiBhIHNlcnZpY2UuIFRoaXMgd2lsbCBoYXZlIG5vIGVmZmVjdC5cIikpO1xuICAgIH1cblxuICAgIGlmIChzZXJ2aWNlKSB7XG4gICAgICByZXR1cm4gc2VydmljZS5zcGF3bihlbnRpdHksIHJlc29sdmVkT3B0aW9ucy5uYW1lLCByZXNvbHZlZE9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3JlYXRlRGVmZXJyZWRBY3RvcihlbnRpdHksIHJlc29sdmVkT3B0aW9ucy5uYW1lKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgSW50ZXJwcmV0ZXIgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBtYWNoaW5lIHdpdGggdGhlIHByb3ZpZGVkIG9wdGlvbnMsIGlmIGFueS5cclxuICpcclxuICogQHBhcmFtIG1hY2hpbmUgVGhlIG1hY2hpbmUgdG8gaW50ZXJwcmV0XHJcbiAqIEBwYXJhbSBvcHRpb25zIEludGVycHJldGVyIG9wdGlvbnNcclxuICovXG5cbmZ1bmN0aW9uIGludGVycHJldChtYWNoaW5lLCBvcHRpb25zKSB7XG4gIHZhciBpbnRlcnByZXRlciA9IG5ldyBJbnRlcnByZXRlcihtYWNoaW5lLCBvcHRpb25zKTtcbiAgcmV0dXJuIGludGVycHJldGVyO1xufVxuXG5leHBvcnQgeyBJbnRlcnByZXRlciwgSW50ZXJwcmV0ZXJTdGF0dXMsIGludGVycHJldCwgc3Bhd24gfTtcbiIsImltcG9ydCB7IF9fYXNzaWduLCBfX3Jlc3QgfSBmcm9tICcuL192aXJ0dWFsL190c2xpYi5qcyc7XG5pbXBvcnQgJy4vdHlwZXMuanMnO1xuaW1wb3J0IHsgaW52b2tlIH0gZnJvbSAnLi9hY3Rpb25UeXBlcy5qcyc7XG5pbXBvcnQgJy4vdXRpbHMuanMnO1xuaW1wb3J0ICcuL2Vudmlyb25tZW50LmpzJztcblxuZnVuY3Rpb24gdG9JbnZva2VTb3VyY2Uoc3JjKSB7XG4gIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzaW1wbGVTcmMgPSB7XG4gICAgICB0eXBlOiBzcmNcbiAgICB9O1xuXG4gICAgc2ltcGxlU3JjLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNyYztcbiAgICB9OyAvLyB2NCBjb21wYXQgLSBUT0RPOiByZW1vdmUgaW4gdjVcblxuXG4gICAgcmV0dXJuIHNpbXBsZVNyYztcbiAgfVxuXG4gIHJldHVybiBzcmM7XG59XG5mdW5jdGlvbiB0b0ludm9rZURlZmluaXRpb24oaW52b2tlQ29uZmlnKSB7XG4gIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7XG4gICAgdHlwZTogaW52b2tlXG4gIH0sIGludm9rZUNvbmZpZyksIHtcbiAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgIGludm9rZUNvbmZpZy5vbkRvbmU7XG4gICAgICAgICAgaW52b2tlQ29uZmlnLm9uRXJyb3I7XG4gICAgICAgICAgdmFyIGludm9rZURlZiA9IF9fcmVzdChpbnZva2VDb25maWcsIFtcIm9uRG9uZVwiLCBcIm9uRXJyb3JcIl0pO1xuXG4gICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGludm9rZURlZiksIHtcbiAgICAgICAgdHlwZTogaW52b2tlLFxuICAgICAgICBzcmM6IHRvSW52b2tlU291cmNlKGludm9rZUNvbmZpZy5zcmMpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgeyB0b0ludm9rZURlZmluaXRpb24sIHRvSW52b2tlU291cmNlIH07XG4iLCJpbXBvcnQgeyBfX3ZhbHVlcyB9IGZyb20gJy4vX3ZpcnR1YWwvX3RzbGliLmpzJztcbmltcG9ydCB7IG1hdGNoZXNTdGF0ZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5mdW5jdGlvbiBtYXBTdGF0ZShzdGF0ZU1hcCwgc3RhdGVJZCkge1xuICB2YXIgZV8xLCBfYTtcblxuICB2YXIgZm91bmRTdGF0ZUlkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhzdGF0ZU1hcCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICB2YXIgbWFwcGVkU3RhdGVJZCA9IF9jLnZhbHVlO1xuXG4gICAgICBpZiAobWF0Y2hlc1N0YXRlKG1hcHBlZFN0YXRlSWQsIHN0YXRlSWQpICYmICghZm91bmRTdGF0ZUlkIHx8IHN0YXRlSWQubGVuZ3RoID4gZm91bmRTdGF0ZUlkLmxlbmd0aCkpIHtcbiAgICAgICAgZm91bmRTdGF0ZUlkID0gbWFwcGVkU3RhdGVJZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgZV8xID0ge1xuICAgICAgZXJyb3I6IGVfMV8xXG4gICAgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0YXRlTWFwW2ZvdW5kU3RhdGVJZF07XG59XG5cbmV4cG9ydCB7IG1hcFN0YXRlIH07XG4iLCJpbXBvcnQgeyBfX3ZhbHVlcywgX19yZWFkIH0gZnJvbSAnLi9fdmlydHVhbC9fdHNsaWIuanMnO1xuaW1wb3J0IHsgU3RhdGUgfSBmcm9tICcuL1N0YXRlLmpzJztcblxuZnVuY3Rpb24gbWF0Y2hTdGF0ZShzdGF0ZSwgcGF0dGVybnMsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgZV8xLCBfYTtcblxuICB2YXIgcmVzb2x2ZWRTdGF0ZSA9IFN0YXRlLmZyb20oc3RhdGUsIHN0YXRlIGluc3RhbmNlb2YgU3RhdGUgPyBzdGF0ZS5jb250ZXh0IDogdW5kZWZpbmVkKTtcblxuICB0cnkge1xuICAgIGZvciAodmFyIHBhdHRlcm5zXzEgPSBfX3ZhbHVlcyhwYXR0ZXJucyksIHBhdHRlcm5zXzFfMSA9IHBhdHRlcm5zXzEubmV4dCgpOyAhcGF0dGVybnNfMV8xLmRvbmU7IHBhdHRlcm5zXzFfMSA9IHBhdHRlcm5zXzEubmV4dCgpKSB7XG4gICAgICB2YXIgX2IgPSBfX3JlYWQocGF0dGVybnNfMV8xLnZhbHVlLCAyKSxcbiAgICAgICAgICBzdGF0ZVZhbHVlID0gX2JbMF0sXG4gICAgICAgICAgZ2V0VmFsdWUgPSBfYlsxXTtcblxuICAgICAgaWYgKHJlc29sdmVkU3RhdGUubWF0Y2hlcyhzdGF0ZVZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZ2V0VmFsdWUocmVzb2x2ZWRTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlXzFfMSkge1xuICAgIGVfMSA9IHtcbiAgICAgIGVycm9yOiBlXzFfMVxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChwYXR0ZXJuc18xXzEgJiYgIXBhdHRlcm5zXzFfMS5kb25lICYmIChfYSA9IHBhdHRlcm5zXzEucmV0dXJuKSkgX2EuY2FsbChwYXR0ZXJuc18xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0VmFsdWUocmVzb2x2ZWRTdGF0ZSk7XG59XG5cbmV4cG9ydCB7IG1hdGNoU3RhdGUgfTtcbiIsInZhciBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi9uZXcgTWFwKCk7XG52YXIgc2Vzc2lvbklkSW5kZXggPSAwO1xudmFyIHJlZ2lzdHJ5ID0ge1xuICBib29rSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJ4OlwiLmNvbmNhdChzZXNzaW9uSWRJbmRleCsrKTtcbiAgfSxcbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChpZCwgYWN0b3IpIHtcbiAgICBjaGlsZHJlbi5zZXQoaWQsIGFjdG9yKTtcbiAgICByZXR1cm4gaWQ7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuLmdldChpZCk7XG4gIH0sXG4gIGZyZWU6IGZ1bmN0aW9uIChpZCkge1xuICAgIGNoaWxkcmVuLmRlbGV0ZShpZCk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IHJlZ2lzdHJ5IH07XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJy4vX3ZpcnR1YWwvX3RzbGliLmpzJztcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBkZWZlckV2ZW50czogZmFsc2Vcbn07XG5cbnZhciBTY2hlZHVsZXIgPVxuLyojX19QVVJFX18qL1xuXG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNjaGVkdWxlcihvcHRpb25zKSB7XG4gICAgdGhpcy5wcm9jZXNzaW5nRXZlbnQgPSBmYWxzZTtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucyksIG9wdGlvbnMpO1xuICB9XG5cbiAgU2NoZWR1bGVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmRlZmVyRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoY2FsbGJhY2spO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvY2VzcyhjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgdGhpcy5mbHVzaEV2ZW50cygpO1xuICB9O1xuXG4gIFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAodGFzaykge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCB8fCB0aGlzLnByb2Nlc3NpbmdFdmVudCkge1xuICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRhc2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCBxdWV1ZSBzaG91bGQgYmUgZW1wdHkgd2hlbiBpdCBpcyBub3QgcHJvY2Vzc2luZyBldmVudHMnKTtcbiAgICB9XG5cbiAgICB0aGlzLnByb2Nlc3ModGFzayk7XG4gICAgdGhpcy5mbHVzaEV2ZW50cygpO1xuICB9O1xuXG4gIFNjaGVkdWxlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICB9O1xuXG4gIFNjaGVkdWxlci5wcm90b3R5cGUuZmx1c2hFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5leHRDYWxsYmFjayA9IHRoaXMucXVldWUuc2hpZnQoKTtcblxuICAgIHdoaWxlIChuZXh0Q2FsbGJhY2spIHtcbiAgICAgIHRoaXMucHJvY2VzcyhuZXh0Q2FsbGJhY2spO1xuICAgICAgbmV4dENhbGxiYWNrID0gdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgIH1cbiAgfTtcblxuICBTY2hlZHVsZXIucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnByb2Nlc3NpbmdFdmVudCA9IHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyB0aGVyZSBpcyBubyB1c2UgdG8ga2VlcCB0aGUgZnV0dXJlIGV2ZW50c1xuICAgICAgLy8gYXMgdGhlIHNpdHVhdGlvbiBpcyBub3QgYW55bW9yZSB0aGUgc2FtZVxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5wcm9jZXNzaW5nRXZlbnQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNjaGVkdWxlcjtcbn0oKTtcblxuZXhwb3J0IHsgU2NoZWR1bGVyIH07XG4iLCJmdW5jdGlvbiBjcmVhdGVTY2hlbWEoc2NoZW1hKSB7XG4gIHJldHVybiBzY2hlbWE7XG59XG52YXIgdCA9IGNyZWF0ZVNjaGVtYTtcblxuZXhwb3J0IHsgY3JlYXRlU2NoZW1hLCB0IH07XG4iLCIvKipcclxuICogTWFpbnRhaW5zIGEgc3RhY2sgb2YgdGhlIGN1cnJlbnQgc2VydmljZSBpbiBzY29wZS5cclxuICogVGhpcyBpcyB1c2VkIHRvIHByb3ZpZGUgdGhlIGNvcnJlY3Qgc2VydmljZSB0byBzcGF3bigpLlxyXG4gKi9cbnZhciBzZXJ2aWNlU3RhY2sgPSBbXTtcbnZhciBwcm92aWRlID0gZnVuY3Rpb24gKHNlcnZpY2UsIGZuKSB7XG4gIHNlcnZpY2VTdGFjay5wdXNoKHNlcnZpY2UpO1xuICB2YXIgcmVzdWx0ID0gZm4oc2VydmljZSk7XG4gIHNlcnZpY2VTdGFjay5wb3AoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgY29uc3VtZSA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZm4oc2VydmljZVN0YWNrW3NlcnZpY2VTdGFjay5sZW5ndGggLSAxXSk7XG59O1xuXG5leHBvcnQgeyBjb25zdW1lLCBwcm92aWRlIH07XG4iLCJpbXBvcnQgeyBfX3ZhbHVlcywgX19zcHJlYWRBcnJheSwgX19yZWFkIH0gZnJvbSAnLi9fdmlydHVhbC9fdHNsaWIuanMnO1xuaW1wb3J0IHsgZmxhdHRlbiB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG52YXIgaXNMZWFmTm9kZSA9IGZ1bmN0aW9uIChzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIHN0YXRlTm9kZS50eXBlID09PSAnYXRvbWljJyB8fCBzdGF0ZU5vZGUudHlwZSA9PT0gJ2ZpbmFsJztcbn07XG5mdW5jdGlvbiBnZXRBbGxDaGlsZHJlbihzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHN0YXRlTm9kZS5zdGF0ZXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5zdGF0ZXNba2V5XTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIGdldEFsbENoaWxkcmVuKHN0YXRlTm9kZSkuZmlsdGVyKGZ1bmN0aW9uIChzbikge1xuICAgIHJldHVybiBzbi50eXBlICE9PSAnaGlzdG9yeSc7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0QWxsU3RhdGVOb2RlcyhzdGF0ZU5vZGUpIHtcbiAgdmFyIHN0YXRlTm9kZXMgPSBbc3RhdGVOb2RlXTtcblxuICBpZiAoaXNMZWFmTm9kZShzdGF0ZU5vZGUpKSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZXM7XG4gIH1cblxuICByZXR1cm4gc3RhdGVOb2Rlcy5jb25jYXQoZmxhdHRlbihnZXRDaGlsZHJlbihzdGF0ZU5vZGUpLm1hcChnZXRBbGxTdGF0ZU5vZGVzKSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29uZmlndXJhdGlvbihwcmV2U3RhdGVOb2Rlcywgc3RhdGVOb2Rlcykge1xuICB2YXIgZV8xLCBfYSwgZV8yLCBfYiwgZV8zLCBfYywgZV80LCBfZDtcblxuICB2YXIgcHJldkNvbmZpZ3VyYXRpb24gPSBuZXcgU2V0KHByZXZTdGF0ZU5vZGVzKTtcbiAgdmFyIHByZXZBZGpMaXN0ID0gZ2V0QWRqTGlzdChwcmV2Q29uZmlndXJhdGlvbik7XG4gIHZhciBjb25maWd1cmF0aW9uID0gbmV3IFNldChzdGF0ZU5vZGVzKTtcblxuICB0cnkge1xuICAgIC8vIGFkZCBhbGwgYW5jZXN0b3JzXG4gICAgZm9yICh2YXIgY29uZmlndXJhdGlvbl8xID0gX192YWx1ZXMoY29uZmlndXJhdGlvbiksIGNvbmZpZ3VyYXRpb25fMV8xID0gY29uZmlndXJhdGlvbl8xLm5leHQoKTsgIWNvbmZpZ3VyYXRpb25fMV8xLmRvbmU7IGNvbmZpZ3VyYXRpb25fMV8xID0gY29uZmlndXJhdGlvbl8xLm5leHQoKSkge1xuICAgICAgdmFyIHMgPSBjb25maWd1cmF0aW9uXzFfMS52YWx1ZTtcbiAgICAgIHZhciBtID0gcy5wYXJlbnQ7XG5cbiAgICAgIHdoaWxlIChtICYmICFjb25maWd1cmF0aW9uLmhhcyhtKSkge1xuICAgICAgICBjb25maWd1cmF0aW9uLmFkZChtKTtcbiAgICAgICAgbSA9IG0ucGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICBlXzEgPSB7XG4gICAgICBlcnJvcjogZV8xXzFcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbl8xXzEgJiYgIWNvbmZpZ3VyYXRpb25fMV8xLmRvbmUgJiYgKF9hID0gY29uZmlndXJhdGlvbl8xLnJldHVybikpIF9hLmNhbGwoY29uZmlndXJhdGlvbl8xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhZGpMaXN0ID0gZ2V0QWRqTGlzdChjb25maWd1cmF0aW9uKTtcblxuICB0cnkge1xuICAgIC8vIGFkZCBkZXNjZW5kYW50c1xuICAgIGZvciAodmFyIGNvbmZpZ3VyYXRpb25fMiA9IF9fdmFsdWVzKGNvbmZpZ3VyYXRpb24pLCBjb25maWd1cmF0aW9uXzJfMSA9IGNvbmZpZ3VyYXRpb25fMi5uZXh0KCk7ICFjb25maWd1cmF0aW9uXzJfMS5kb25lOyBjb25maWd1cmF0aW9uXzJfMSA9IGNvbmZpZ3VyYXRpb25fMi5uZXh0KCkpIHtcbiAgICAgIHZhciBzID0gY29uZmlndXJhdGlvbl8yXzEudmFsdWU7IC8vIGlmIHByZXZpb3VzbHkgYWN0aXZlLCBhZGQgZXhpc3RpbmcgY2hpbGQgbm9kZXNcblxuICAgICAgaWYgKHMudHlwZSA9PT0gJ2NvbXBvdW5kJyAmJiAoIWFkakxpc3QuZ2V0KHMpIHx8ICFhZGpMaXN0LmdldChzKS5sZW5ndGgpKSB7XG4gICAgICAgIGlmIChwcmV2QWRqTGlzdC5nZXQocykpIHtcbiAgICAgICAgICBwcmV2QWRqTGlzdC5nZXQocykuZm9yRWFjaChmdW5jdGlvbiAoc24pIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWd1cmF0aW9uLmFkZChzbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcy5pbml0aWFsU3RhdGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzbikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb24uYWRkKHNuKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHMudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZSA9IChlXzMgPSB2b2lkIDAsIF9fdmFsdWVzKGdldENoaWxkcmVuKHMpKSksIF9mID0gX2UubmV4dCgpOyAhX2YuZG9uZTsgX2YgPSBfZS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2YudmFsdWU7XG5cbiAgICAgICAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uLmFkZChjaGlsZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJldkFkakxpc3QuZ2V0KGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgcHJldkFkakxpc3QuZ2V0KGNoaWxkKS5mb3JFYWNoKGZ1bmN0aW9uIChzbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlndXJhdGlvbi5hZGQoc24pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkLmluaXRpYWxTdGF0ZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHNuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25maWd1cmF0aW9uLmFkZChzbik7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlXzNfMSkge1xuICAgICAgICAgICAgZV8zID0ge1xuICAgICAgICAgICAgICBlcnJvcjogZV8zXzFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChfZiAmJiAhX2YuZG9uZSAmJiAoX2MgPSBfZS5yZXR1cm4pKSBfYy5jYWxsKF9lKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVfMl8xKSB7XG4gICAgZV8yID0ge1xuICAgICAgZXJyb3I6IGVfMl8xXG4gICAgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKGNvbmZpZ3VyYXRpb25fMl8xICYmICFjb25maWd1cmF0aW9uXzJfMS5kb25lICYmIChfYiA9IGNvbmZpZ3VyYXRpb25fMi5yZXR1cm4pKSBfYi5jYWxsKGNvbmZpZ3VyYXRpb25fMik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjtcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIC8vIGFkZCBhbGwgYW5jZXN0b3JzXG4gICAgZm9yICh2YXIgY29uZmlndXJhdGlvbl8zID0gX192YWx1ZXMoY29uZmlndXJhdGlvbiksIGNvbmZpZ3VyYXRpb25fM18xID0gY29uZmlndXJhdGlvbl8zLm5leHQoKTsgIWNvbmZpZ3VyYXRpb25fM18xLmRvbmU7IGNvbmZpZ3VyYXRpb25fM18xID0gY29uZmlndXJhdGlvbl8zLm5leHQoKSkge1xuICAgICAgdmFyIHMgPSBjb25maWd1cmF0aW9uXzNfMS52YWx1ZTtcbiAgICAgIHZhciBtID0gcy5wYXJlbnQ7XG5cbiAgICAgIHdoaWxlIChtICYmICFjb25maWd1cmF0aW9uLmhhcyhtKSkge1xuICAgICAgICBjb25maWd1cmF0aW9uLmFkZChtKTtcbiAgICAgICAgbSA9IG0ucGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZV80XzEpIHtcbiAgICBlXzQgPSB7XG4gICAgICBlcnJvcjogZV80XzFcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbl8zXzEgJiYgIWNvbmZpZ3VyYXRpb25fM18xLmRvbmUgJiYgKF9kID0gY29uZmlndXJhdGlvbl8zLnJldHVybikpIF9kLmNhbGwoY29uZmlndXJhdGlvbl8zKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWd1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZUZyb21BZGooYmFzZU5vZGUsIGFkakxpc3QpIHtcbiAgdmFyIGNoaWxkU3RhdGVOb2RlcyA9IGFkakxpc3QuZ2V0KGJhc2VOb2RlKTtcblxuICBpZiAoIWNoaWxkU3RhdGVOb2Rlcykge1xuICAgIHJldHVybiB7fTsgLy8gdG9kbzogZml4P1xuICB9XG5cbiAgaWYgKGJhc2VOb2RlLnR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICB2YXIgY2hpbGRTdGF0ZU5vZGUgPSBjaGlsZFN0YXRlTm9kZXNbMF07XG5cbiAgICBpZiAoY2hpbGRTdGF0ZU5vZGUpIHtcbiAgICAgIGlmIChpc0xlYWZOb2RlKGNoaWxkU3RhdGVOb2RlKSkge1xuICAgICAgICByZXR1cm4gY2hpbGRTdGF0ZU5vZGUua2V5O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlVmFsdWUgPSB7fTtcbiAgY2hpbGRTdGF0ZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGNzbikge1xuICAgIHN0YXRlVmFsdWVbY3NuLmtleV0gPSBnZXRWYWx1ZUZyb21BZGooY3NuLCBhZGpMaXN0KTtcbiAgfSk7XG4gIHJldHVybiBzdGF0ZVZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRBZGpMaXN0KGNvbmZpZ3VyYXRpb24pIHtcbiAgdmFyIGVfNSwgX2E7XG5cbiAgdmFyIGFkakxpc3QgPSBuZXcgTWFwKCk7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBjb25maWd1cmF0aW9uXzQgPSBfX3ZhbHVlcyhjb25maWd1cmF0aW9uKSwgY29uZmlndXJhdGlvbl80XzEgPSBjb25maWd1cmF0aW9uXzQubmV4dCgpOyAhY29uZmlndXJhdGlvbl80XzEuZG9uZTsgY29uZmlndXJhdGlvbl80XzEgPSBjb25maWd1cmF0aW9uXzQubmV4dCgpKSB7XG4gICAgICB2YXIgcyA9IGNvbmZpZ3VyYXRpb25fNF8xLnZhbHVlO1xuXG4gICAgICBpZiAoIWFkakxpc3QuaGFzKHMpKSB7XG4gICAgICAgIGFkakxpc3Quc2V0KHMsIFtdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMucGFyZW50KSB7XG4gICAgICAgIGlmICghYWRqTGlzdC5oYXMocy5wYXJlbnQpKSB7XG4gICAgICAgICAgYWRqTGlzdC5zZXQocy5wYXJlbnQsIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkakxpc3QuZ2V0KHMucGFyZW50KS5wdXNoKHMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZV81XzEpIHtcbiAgICBlXzUgPSB7XG4gICAgICBlcnJvcjogZV81XzFcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbl80XzEgJiYgIWNvbmZpZ3VyYXRpb25fNF8xLmRvbmUgJiYgKF9hID0gY29uZmlndXJhdGlvbl80LnJldHVybikpIF9hLmNhbGwoY29uZmlndXJhdGlvbl80KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhZGpMaXN0O1xufVxuZnVuY3Rpb24gZ2V0VmFsdWUocm9vdE5vZGUsIGNvbmZpZ3VyYXRpb24pIHtcbiAgdmFyIGNvbmZpZyA9IGdldENvbmZpZ3VyYXRpb24oW3Jvb3ROb2RlXSwgY29uZmlndXJhdGlvbik7XG4gIHJldHVybiBnZXRWYWx1ZUZyb21BZGoocm9vdE5vZGUsIGdldEFkakxpc3QoY29uZmlnKSk7XG59XG5mdW5jdGlvbiBoYXMoaXRlcmFibGUsIGl0ZW0pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaXRlcmFibGUpKSB7XG4gICAgcmV0dXJuIGl0ZXJhYmxlLnNvbWUoZnVuY3Rpb24gKG1lbWJlcikge1xuICAgICAgcmV0dXJuIG1lbWJlciA9PT0gaXRlbTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpdGVyYWJsZSBpbnN0YW5jZW9mIFNldCkge1xuICAgIHJldHVybiBpdGVyYWJsZS5oYXMoaXRlbSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7IC8vIFRPRE86IGZpeFxufVxuZnVuY3Rpb24gbmV4dEV2ZW50cyhjb25maWd1cmF0aW9uKSB7XG4gIHJldHVybiBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQobmV3IFNldChmbGF0dGVuKF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChjb25maWd1cmF0aW9uLm1hcChmdW5jdGlvbiAoc24pIHtcbiAgICByZXR1cm4gc24ub3duRXZlbnRzO1xuICB9KSksIGZhbHNlKSkpKSwgZmFsc2UpO1xufVxuZnVuY3Rpb24gaXNJbkZpbmFsU3RhdGUoY29uZmlndXJhdGlvbiwgc3RhdGVOb2RlKSB7XG4gIGlmIChzdGF0ZU5vZGUudHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgIHJldHVybiBnZXRDaGlsZHJlbihzdGF0ZU5vZGUpLnNvbWUoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiBzLnR5cGUgPT09ICdmaW5hbCcgJiYgaGFzKGNvbmZpZ3VyYXRpb24sIHMpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHN0YXRlTm9kZS50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgcmV0dXJuIGdldENoaWxkcmVuKHN0YXRlTm9kZSkuZXZlcnkoZnVuY3Rpb24gKHNuKSB7XG4gICAgICByZXR1cm4gaXNJbkZpbmFsU3RhdGUoY29uZmlndXJhdGlvbiwgc24pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0TWV0YShjb25maWd1cmF0aW9uKSB7XG4gIGlmIChjb25maWd1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICBjb25maWd1cmF0aW9uID0gW107XG4gIH1cblxuICByZXR1cm4gY29uZmlndXJhdGlvbi5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc3RhdGVOb2RlKSB7XG4gICAgaWYgKHN0YXRlTm9kZS5tZXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFjY1tzdGF0ZU5vZGUuaWRdID0gc3RhdGVOb2RlLm1ldGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gZ2V0VGFnc0Zyb21Db25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pIHtcbiAgcmV0dXJuIG5ldyBTZXQoZmxhdHRlbihjb25maWd1cmF0aW9uLm1hcChmdW5jdGlvbiAoc24pIHtcbiAgICByZXR1cm4gc24udGFncztcbiAgfSkpKTtcbn1cblxuZXhwb3J0IHsgZ2V0QWRqTGlzdCwgZ2V0QWxsQ2hpbGRyZW4sIGdldEFsbFN0YXRlTm9kZXMsIGdldENoaWxkcmVuLCBnZXRDb25maWd1cmF0aW9uLCBnZXRNZXRhLCBnZXRUYWdzRnJvbUNvbmZpZ3VyYXRpb24sIGdldFZhbHVlLCBoYXMsIGlzSW5GaW5hbFN0YXRlLCBpc0xlYWZOb2RlLCBuZXh0RXZlbnRzIH07XG4iLCJ2YXIgQWN0aW9uVHlwZXM7XG5cbihmdW5jdGlvbiAoQWN0aW9uVHlwZXMpIHtcbiAgQWN0aW9uVHlwZXNbXCJTdGFydFwiXSA9IFwieHN0YXRlLnN0YXJ0XCI7XG4gIEFjdGlvblR5cGVzW1wiU3RvcFwiXSA9IFwieHN0YXRlLnN0b3BcIjtcbiAgQWN0aW9uVHlwZXNbXCJSYWlzZVwiXSA9IFwieHN0YXRlLnJhaXNlXCI7XG4gIEFjdGlvblR5cGVzW1wiU2VuZFwiXSA9IFwieHN0YXRlLnNlbmRcIjtcbiAgQWN0aW9uVHlwZXNbXCJDYW5jZWxcIl0gPSBcInhzdGF0ZS5jYW5jZWxcIjtcbiAgQWN0aW9uVHlwZXNbXCJOdWxsRXZlbnRcIl0gPSBcIlwiO1xuICBBY3Rpb25UeXBlc1tcIkFzc2lnblwiXSA9IFwieHN0YXRlLmFzc2lnblwiO1xuICBBY3Rpb25UeXBlc1tcIkFmdGVyXCJdID0gXCJ4c3RhdGUuYWZ0ZXJcIjtcbiAgQWN0aW9uVHlwZXNbXCJEb25lU3RhdGVcIl0gPSBcImRvbmUuc3RhdGVcIjtcbiAgQWN0aW9uVHlwZXNbXCJEb25lSW52b2tlXCJdID0gXCJkb25lLmludm9rZVwiO1xuICBBY3Rpb25UeXBlc1tcIkxvZ1wiXSA9IFwieHN0YXRlLmxvZ1wiO1xuICBBY3Rpb25UeXBlc1tcIkluaXRcIl0gPSBcInhzdGF0ZS5pbml0XCI7XG4gIEFjdGlvblR5cGVzW1wiSW52b2tlXCJdID0gXCJ4c3RhdGUuaW52b2tlXCI7XG4gIEFjdGlvblR5cGVzW1wiRXJyb3JFeGVjdXRpb25cIl0gPSBcImVycm9yLmV4ZWN1dGlvblwiO1xuICBBY3Rpb25UeXBlc1tcIkVycm9yQ29tbXVuaWNhdGlvblwiXSA9IFwiZXJyb3IuY29tbXVuaWNhdGlvblwiO1xuICBBY3Rpb25UeXBlc1tcIkVycm9yUGxhdGZvcm1cIl0gPSBcImVycm9yLnBsYXRmb3JtXCI7XG4gIEFjdGlvblR5cGVzW1wiRXJyb3JDdXN0b21cIl0gPSBcInhzdGF0ZS5lcnJvclwiO1xuICBBY3Rpb25UeXBlc1tcIlVwZGF0ZVwiXSA9IFwieHN0YXRlLnVwZGF0ZVwiO1xuICBBY3Rpb25UeXBlc1tcIlB1cmVcIl0gPSBcInhzdGF0ZS5wdXJlXCI7XG4gIEFjdGlvblR5cGVzW1wiQ2hvb3NlXCJdID0gXCJ4c3RhdGUuY2hvb3NlXCI7XG59KShBY3Rpb25UeXBlcyB8fCAoQWN0aW9uVHlwZXMgPSB7fSkpO1xuXG52YXIgU3BlY2lhbFRhcmdldHM7XG5cbihmdW5jdGlvbiAoU3BlY2lhbFRhcmdldHMpIHtcbiAgU3BlY2lhbFRhcmdldHNbXCJQYXJlbnRcIl0gPSBcIiNfcGFyZW50XCI7XG4gIFNwZWNpYWxUYXJnZXRzW1wiSW50ZXJuYWxcIl0gPSBcIiNfaW50ZXJuYWxcIjtcbn0pKFNwZWNpYWxUYXJnZXRzIHx8IChTcGVjaWFsVGFyZ2V0cyA9IHt9KSk7XG5cbmV4cG9ydCB7IEFjdGlvblR5cGVzLCBTcGVjaWFsVGFyZ2V0cyB9O1xuIiwiaW1wb3J0IHsgX192YWx1ZXMsIF9fc3ByZWFkQXJyYXksIF9fcmVhZCwgX19hc3NpZ24gfSBmcm9tICcuL192aXJ0dWFsL190c2xpYi5qcyc7XG5pbXBvcnQgeyBTcGVjaWFsVGFyZ2V0cyB9IGZyb20gJy4vdHlwZXMuanMnO1xuaW1wb3J0IHsgcmFpc2UsIHNlbmQgfSBmcm9tICcuL2FjdGlvblR5cGVzLmpzJztcbmltcG9ydCB7IERFRkFVTFRfR1VBUkRfVFlQRSwgVEFSR0VUTEVTU19LRVksIFNUQVRFX0RFTElNSVRFUiB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IElTX1BST0RVQ1RJT04gfSBmcm9tICcuL2Vudmlyb25tZW50LmpzJztcblxudmFyIF9hO1xuZnVuY3Rpb24ga2V5cyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpO1xufVxuZnVuY3Rpb24gbWF0Y2hlc1N0YXRlKHBhcmVudFN0YXRlSWQsIGNoaWxkU3RhdGVJZCwgZGVsaW1pdGVyKSB7XG4gIGlmIChkZWxpbWl0ZXIgPT09IHZvaWQgMCkge1xuICAgIGRlbGltaXRlciA9IFNUQVRFX0RFTElNSVRFUjtcbiAgfVxuXG4gIHZhciBwYXJlbnRTdGF0ZVZhbHVlID0gdG9TdGF0ZVZhbHVlKHBhcmVudFN0YXRlSWQsIGRlbGltaXRlcik7XG4gIHZhciBjaGlsZFN0YXRlVmFsdWUgPSB0b1N0YXRlVmFsdWUoY2hpbGRTdGF0ZUlkLCBkZWxpbWl0ZXIpO1xuXG4gIGlmIChpc1N0cmluZyhjaGlsZFN0YXRlVmFsdWUpKSB7XG4gICAgaWYgKGlzU3RyaW5nKHBhcmVudFN0YXRlVmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2hpbGRTdGF0ZVZhbHVlID09PSBwYXJlbnRTdGF0ZVZhbHVlO1xuICAgIH0gLy8gUGFyZW50IG1vcmUgc3BlY2lmaWMgdGhhbiBjaGlsZFxuXG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNTdHJpbmcocGFyZW50U3RhdGVWYWx1ZSkpIHtcbiAgICByZXR1cm4gcGFyZW50U3RhdGVWYWx1ZSBpbiBjaGlsZFN0YXRlVmFsdWU7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmtleXMocGFyZW50U3RhdGVWYWx1ZSkuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghKGtleSBpbiBjaGlsZFN0YXRlVmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXNTdGF0ZShwYXJlbnRTdGF0ZVZhbHVlW2tleV0sIGNoaWxkU3RhdGVWYWx1ZVtrZXldKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRFdmVudFR5cGUoZXZlbnQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXNTdHJpbmcoZXZlbnQpIHx8IHR5cGVvZiBldmVudCA9PT0gJ251bWJlcicgPyBcIlwiLmNvbmNhdChldmVudCkgOiBldmVudC50eXBlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudHMgbXVzdCBiZSBzdHJpbmdzIG9yIG9iamVjdHMgd2l0aCBhIHN0cmluZyBldmVudC50eXBlIHByb3BlcnR5LicpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRBY3Rpb25UeXBlKGFjdGlvbikge1xuICB0cnkge1xuICAgIHJldHVybiBpc1N0cmluZyhhY3Rpb24pIHx8IHR5cGVvZiBhY3Rpb24gPT09ICdudW1iZXInID8gXCJcIi5jb25jYXQoYWN0aW9uKSA6IGlzRnVuY3Rpb24oYWN0aW9uKSA/IGFjdGlvbi5uYW1lIDogYWN0aW9uLnR5cGU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbXVzdCBiZSBzdHJpbmdzIG9yIG9iamVjdHMgd2l0aCBhIHN0cmluZyBhY3Rpb24udHlwZSBwcm9wZXJ0eS4nKTtcbiAgfVxufVxuZnVuY3Rpb24gdG9TdGF0ZVBhdGgoc3RhdGVJZCwgZGVsaW1pdGVyKSB7XG4gIHRyeSB7XG4gICAgaWYgKGlzQXJyYXkoc3RhdGVJZCkpIHtcbiAgICAgIHJldHVybiBzdGF0ZUlkO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZUlkLnRvU3RyaW5nKCkuc3BsaXQoZGVsaW1pdGVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIidcIi5jb25jYXQoc3RhdGVJZCwgXCInIGlzIG5vdCBhIHZhbGlkIHN0YXRlIHBhdGguXCIpKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTdGF0ZUxpa2Uoc3RhdGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gJ29iamVjdCcgJiYgJ3ZhbHVlJyBpbiBzdGF0ZSAmJiAnY29udGV4dCcgaW4gc3RhdGUgJiYgJ2V2ZW50JyBpbiBzdGF0ZSAmJiAnX2V2ZW50JyBpbiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHRvU3RhdGVWYWx1ZShzdGF0ZVZhbHVlLCBkZWxpbWl0ZXIpIHtcbiAgaWYgKGlzU3RhdGVMaWtlKHN0YXRlVmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0YXRlVmFsdWUudmFsdWU7XG4gIH1cblxuICBpZiAoaXNBcnJheShzdGF0ZVZhbHVlKSkge1xuICAgIHJldHVybiBwYXRoVG9TdGF0ZVZhbHVlKHN0YXRlVmFsdWUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzdGF0ZVZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdGF0ZVZhbHVlO1xuICB9XG5cbiAgdmFyIHN0YXRlUGF0aCA9IHRvU3RhdGVQYXRoKHN0YXRlVmFsdWUsIGRlbGltaXRlcik7XG4gIHJldHVybiBwYXRoVG9TdGF0ZVZhbHVlKHN0YXRlUGF0aCk7XG59XG5mdW5jdGlvbiBwYXRoVG9TdGF0ZVZhbHVlKHN0YXRlUGF0aCkge1xuICBpZiAoc3RhdGVQYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBzdGF0ZVBhdGhbMF07XG4gIH1cblxuICB2YXIgdmFsdWUgPSB7fTtcbiAgdmFyIG1hcmtlciA9IHZhbHVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVQYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmIChpID09PSBzdGF0ZVBhdGgubGVuZ3RoIC0gMikge1xuICAgICAgbWFya2VyW3N0YXRlUGF0aFtpXV0gPSBzdGF0ZVBhdGhbaSArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrZXJbc3RhdGVQYXRoW2ldXSA9IHt9O1xuICAgICAgbWFya2VyID0gbWFya2VyW3N0YXRlUGF0aFtpXV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gbWFwVmFsdWVzKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIGNvbGxlY3Rpb25LZXlzID0gT2JqZWN0LmtleXMoY29sbGVjdGlvbik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBjb2xsZWN0aW9uS2V5c1tpXTtcbiAgICByZXN1bHRba2V5XSA9IGl0ZXJhdGVlKGNvbGxlY3Rpb25ba2V5XSwga2V5LCBjb2xsZWN0aW9uLCBpKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtYXBGaWx0ZXJWYWx1ZXMoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHByZWRpY2F0ZSkge1xuICB2YXIgZV8xLCBfYTtcblxuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgdmFyIGtleSA9IF9jLnZhbHVlO1xuICAgICAgdmFyIGl0ZW0gPSBjb2xsZWN0aW9uW2tleV07XG5cbiAgICAgIGlmICghcHJlZGljYXRlKGl0ZW0pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRba2V5XSA9IGl0ZXJhdGVlKGl0ZW0sIGtleSwgY29sbGVjdGlvbik7XG4gICAgfVxuICB9IGNhdGNoIChlXzFfMSkge1xuICAgIGVfMSA9IHtcbiAgICAgIGVycm9yOiBlXzFfMVxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcclxuICogUmV0cmlldmVzIGEgdmFsdWUgYXQgdGhlIGdpdmVuIHBhdGguXHJcbiAqIEBwYXJhbSBwcm9wcyBUaGUgZGVlcCBwYXRoIHRvIHRoZSBwcm9wIG9mIHRoZSBkZXNpcmVkIHZhbHVlXHJcbiAqL1xuXG52YXIgcGF0aCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBlXzIsIF9hO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9iamVjdDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBwcm9wc18xID0gX192YWx1ZXMocHJvcHMpLCBwcm9wc18xXzEgPSBwcm9wc18xLm5leHQoKTsgIXByb3BzXzFfMS5kb25lOyBwcm9wc18xXzEgPSBwcm9wc18xLm5leHQoKSkge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzXzFfMS52YWx1ZTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0W3Byb3BdO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfMl8xKSB7XG4gICAgICBlXzIgPSB7XG4gICAgICAgIGVycm9yOiBlXzJfMVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHByb3BzXzFfMSAmJiAhcHJvcHNfMV8xLmRvbmUgJiYgKF9hID0gcHJvcHNfMS5yZXR1cm4pKSBfYS5jYWxsKHByb3BzXzEpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuLyoqXHJcbiAqIFJldHJpZXZlcyBhIHZhbHVlIGF0IHRoZSBnaXZlbiBwYXRoIHZpYSB0aGUgbmVzdGVkIGFjY2Vzc29yIHByb3AuXHJcbiAqIEBwYXJhbSBwcm9wcyBUaGUgZGVlcCBwYXRoIHRvIHRoZSBwcm9wIG9mIHRoZSBkZXNpcmVkIHZhbHVlXHJcbiAqL1xuXG5mdW5jdGlvbiBuZXN0ZWRQYXRoKHByb3BzLCBhY2Nlc3NvclByb3ApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgZV8zLCBfYTtcblxuICAgIHZhciByZXN1bHQgPSBvYmplY3Q7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgcHJvcHNfMiA9IF9fdmFsdWVzKHByb3BzKSwgcHJvcHNfMl8xID0gcHJvcHNfMi5uZXh0KCk7ICFwcm9wc18yXzEuZG9uZTsgcHJvcHNfMl8xID0gcHJvcHNfMi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc18yXzEudmFsdWU7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdFthY2Nlc3NvclByb3BdW3Byb3BdO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfM18xKSB7XG4gICAgICBlXzMgPSB7XG4gICAgICAgIGVycm9yOiBlXzNfMVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHByb3BzXzJfMSAmJiAhcHJvcHNfMl8xLmRvbmUgJiYgKF9hID0gcHJvcHNfMi5yZXR1cm4pKSBfYS5jYWxsKHByb3BzXzIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5mdW5jdGlvbiB0b1N0YXRlUGF0aHMoc3RhdGVWYWx1ZSkge1xuICBpZiAoIXN0YXRlVmFsdWUpIHtcbiAgICByZXR1cm4gW1tdXTtcbiAgfVxuXG4gIGlmIChpc1N0cmluZyhzdGF0ZVZhbHVlKSkge1xuICAgIHJldHVybiBbW3N0YXRlVmFsdWVdXTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBmbGF0dGVuKE9iamVjdC5rZXlzKHN0YXRlVmFsdWUpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHN1YlN0YXRlVmFsdWUgPSBzdGF0ZVZhbHVlW2tleV07XG5cbiAgICBpZiAodHlwZW9mIHN1YlN0YXRlVmFsdWUgIT09ICdzdHJpbmcnICYmICghc3ViU3RhdGVWYWx1ZSB8fCAhT2JqZWN0LmtleXMoc3ViU3RhdGVWYWx1ZSkubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIFtba2V5XV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvU3RhdGVQYXRocyhzdGF0ZVZhbHVlW2tleV0pLm1hcChmdW5jdGlvbiAoc3ViUGF0aCkge1xuICAgICAgcmV0dXJuIFtrZXldLmNvbmNhdChzdWJQYXRoKTtcbiAgICB9KTtcbiAgfSkpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGF0aHNUb1N0YXRlVmFsdWUocGF0aHMpIHtcbiAgdmFyIGVfNCwgX2E7XG5cbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGlmIChwYXRocyAmJiBwYXRocy5sZW5ndGggPT09IDEgJiYgcGF0aHNbMF0ubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHBhdGhzWzBdWzBdO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBwYXRoc18xID0gX192YWx1ZXMocGF0aHMpLCBwYXRoc18xXzEgPSBwYXRoc18xLm5leHQoKTsgIXBhdGhzXzFfMS5kb25lOyBwYXRoc18xXzEgPSBwYXRoc18xLm5leHQoKSkge1xuICAgICAgdmFyIGN1cnJlbnRQYXRoID0gcGF0aHNfMV8xLnZhbHVlO1xuICAgICAgdmFyIG1hcmtlciA9IHJlc3VsdDsgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnByZWZlci1mb3Itb2ZcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyZW50UGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3ViUGF0aCA9IGN1cnJlbnRQYXRoW2ldO1xuXG4gICAgICAgIGlmIChpID09PSBjdXJyZW50UGF0aC5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgbWFya2VyW3N1YlBhdGhdID0gY3VycmVudFBhdGhbaSArIDFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFya2VyW3N1YlBhdGhdID0gbWFya2VyW3N1YlBhdGhdIHx8IHt9O1xuICAgICAgICBtYXJrZXIgPSBtYXJrZXJbc3ViUGF0aF07XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlXzRfMSkge1xuICAgIGVfNCA9IHtcbiAgICAgIGVycm9yOiBlXzRfMVxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChwYXRoc18xXzEgJiYgIXBhdGhzXzFfMS5kb25lICYmIChfYSA9IHBhdGhzXzEucmV0dXJuKSkgX2EuY2FsbChwYXRoc18xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBfYTtcblxuICByZXR1cm4gKF9hID0gW10pLmNvbmNhdC5hcHBseShfYSwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFycmF5KSwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIHRvQXJyYXlTdHJpY3QodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIFt2YWx1ZV07XG59XG5mdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIHRvQXJyYXlTdHJpY3QodmFsdWUpO1xufVxuZnVuY3Rpb24gbWFwQ29udGV4dChtYXBwZXIsIGNvbnRleHQsIF9ldmVudCkge1xuICB2YXIgZV81LCBfYTtcblxuICBpZiAoaXNGdW5jdGlvbihtYXBwZXIpKSB7XG4gICAgcmV0dXJuIG1hcHBlcihjb250ZXh0LCBfZXZlbnQuZGF0YSk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKE9iamVjdC5rZXlzKG1hcHBlcikpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICB2YXIga2V5ID0gX2MudmFsdWU7XG4gICAgICB2YXIgc3ViTWFwcGVyID0gbWFwcGVyW2tleV07XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHN1Yk1hcHBlcikpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBzdWJNYXBwZXIoY29udGV4dCwgX2V2ZW50LmRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBzdWJNYXBwZXI7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlXzVfMSkge1xuICAgIGVfNSA9IHtcbiAgICAgIGVycm9yOiBlXzVfMVxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc0J1aWx0SW5FdmVudChldmVudFR5cGUpIHtcbiAgcmV0dXJuIC9eKGRvbmV8ZXJyb3IpXFwuLy50ZXN0KGV2ZW50VHlwZSk7XG59XG5mdW5jdGlvbiBpc1Byb21pc2VMaWtlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBDaGVjayBpZiBzaGFwZSBtYXRjaGVzIHRoZSBQcm9taXNlL0ErIHNwZWNpZmljYXRpb24gZm9yIGEgXCJ0aGVuYWJsZVwiLlxuXG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnRoZW4pKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0JlaGF2aW9yKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICd0cmFuc2l0aW9uJyBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudHJhbnNpdGlvbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIHBhcnRpdGlvbihpdGVtcywgcHJlZGljYXRlKSB7XG4gIHZhciBlXzYsIF9hO1xuXG4gIHZhciBfYiA9IF9fcmVhZChbW10sIFtdXSwgMiksXG4gICAgICB0cnV0aHkgPSBfYlswXSxcbiAgICAgIGZhbHN5ID0gX2JbMV07XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBpdGVtc18xID0gX192YWx1ZXMoaXRlbXMpLCBpdGVtc18xXzEgPSBpdGVtc18xLm5leHQoKTsgIWl0ZW1zXzFfMS5kb25lOyBpdGVtc18xXzEgPSBpdGVtc18xLm5leHQoKSkge1xuICAgICAgdmFyIGl0ZW0gPSBpdGVtc18xXzEudmFsdWU7XG5cbiAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSkpIHtcbiAgICAgICAgdHJ1dGh5LnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWxzeS5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZV82XzEpIHtcbiAgICBlXzYgPSB7XG4gICAgICBlcnJvcjogZV82XzFcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoaXRlbXNfMV8xICYmICFpdGVtc18xXzEuZG9uZSAmJiAoX2EgPSBpdGVtc18xLnJldHVybikpIF9hLmNhbGwoaXRlbXNfMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlXzYpIHRocm93IGVfNi5lcnJvcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW3RydXRoeSwgZmFsc3ldO1xufVxuZnVuY3Rpb24gdXBkYXRlSGlzdG9yeVN0YXRlcyhoaXN0LCBzdGF0ZVZhbHVlKSB7XG4gIHJldHVybiBtYXBWYWx1ZXMoaGlzdC5zdGF0ZXMsIGZ1bmN0aW9uIChzdWJIaXN0LCBrZXkpIHtcbiAgICBpZiAoIXN1Ykhpc3QpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIHN1YlN0YXRlVmFsdWUgPSAoaXNTdHJpbmcoc3RhdGVWYWx1ZSkgPyB1bmRlZmluZWQgOiBzdGF0ZVZhbHVlW2tleV0pIHx8IChzdWJIaXN0ID8gc3ViSGlzdC5jdXJyZW50IDogdW5kZWZpbmVkKTtcblxuICAgIGlmICghc3ViU3RhdGVWYWx1ZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudDogc3ViU3RhdGVWYWx1ZSxcbiAgICAgIHN0YXRlczogdXBkYXRlSGlzdG9yeVN0YXRlcyhzdWJIaXN0LCBzdWJTdGF0ZVZhbHVlKVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlSGlzdG9yeVZhbHVlKGhpc3QsIHN0YXRlVmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBzdGF0ZVZhbHVlLFxuICAgIHN0YXRlczogdXBkYXRlSGlzdG9yeVN0YXRlcyhoaXN0LCBzdGF0ZVZhbHVlKVxuICB9O1xufVxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dChjb250ZXh0LCBfZXZlbnQsIGFzc2lnbkFjdGlvbnMsIHN0YXRlKSB7XG4gIGlmICghSVNfUFJPRFVDVElPTikge1xuICAgIHdhcm4oISFjb250ZXh0LCAnQXR0ZW1wdGluZyB0byB1cGRhdGUgdW5kZWZpbmVkIGNvbnRleHQnKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVkQ29udGV4dCA9IGNvbnRleHQgPyBhc3NpZ25BY3Rpb25zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhc3NpZ25BY3Rpb24pIHtcbiAgICB2YXIgZV83LCBfYTtcblxuICAgIHZhciBhc3NpZ25tZW50ID0gYXNzaWduQWN0aW9uLmFzc2lnbm1lbnQ7XG4gICAgdmFyIG1ldGEgPSB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBhY3Rpb246IGFzc2lnbkFjdGlvbixcbiAgICAgIF9ldmVudDogX2V2ZW50XG4gICAgfTtcbiAgICB2YXIgcGFydGlhbFVwZGF0ZSA9IHt9O1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oYXNzaWdubWVudCkpIHtcbiAgICAgIHBhcnRpYWxVcGRhdGUgPSBhc3NpZ25tZW50KGFjYywgX2V2ZW50LmRhdGEsIG1ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKE9iamVjdC5rZXlzKGFzc2lnbm1lbnQpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgIHZhciBrZXkgPSBfYy52YWx1ZTtcbiAgICAgICAgICB2YXIgcHJvcEFzc2lnbm1lbnQgPSBhc3NpZ25tZW50W2tleV07XG4gICAgICAgICAgcGFydGlhbFVwZGF0ZVtrZXldID0gaXNGdW5jdGlvbihwcm9wQXNzaWdubWVudCkgPyBwcm9wQXNzaWdubWVudChhY2MsIF9ldmVudC5kYXRhLCBtZXRhKSA6IHByb3BBc3NpZ25tZW50O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzdfMSkge1xuICAgICAgICBlXzcgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfN18xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV83KSB0aHJvdyBlXzcuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYWNjLCBwYXJ0aWFsVXBkYXRlKTtcbiAgfSwgY29udGV4dCkgOiBjb250ZXh0O1xuICByZXR1cm4gdXBkYXRlZENvbnRleHQ7XG59IC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1lbXB0eVxuXG52YXIgd2FybiA9IGZ1bmN0aW9uICgpIHt9O1xuXG5pZiAoIUlTX1BST0RVQ1RJT04pIHtcbiAgd2FybiA9IGZ1bmN0aW9uIChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICB2YXIgZXJyb3IgPSBjb25kaXRpb24gaW5zdGFuY2VvZiBFcnJvciA/IGNvbmRpdGlvbiA6IHVuZGVmaW5lZDtcblxuICAgIGlmICghZXJyb3IgJiYgY29uZGl0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNvbnNvbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXCJXYXJuaW5nOiBcIi5jb25jYXQobWVzc2FnZSldO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgYXJncy5wdXNoKGVycm9yKTtcbiAgICAgIH0gLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcblxuXG4gICAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59IC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpiYW4tdHlwZXNcblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5mdW5jdGlvbiB0b0d1YXJkKGNvbmRpdGlvbiwgZ3VhcmRNYXApIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nKGNvbmRpdGlvbikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogREVGQVVMVF9HVUFSRF9UWVBFLFxuICAgICAgbmFtZTogY29uZGl0aW9uLFxuICAgICAgcHJlZGljYXRlOiBndWFyZE1hcCA/IGd1YXJkTWFwW2NvbmRpdGlvbl0gOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG5cbiAgaWYgKGlzRnVuY3Rpb24oY29uZGl0aW9uKSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBERUZBVUxUX0dVQVJEX1RZUEUsXG4gICAgICBuYW1lOiBjb25kaXRpb24ubmFtZSxcbiAgICAgIHByZWRpY2F0ZTogY29uZGl0aW9uXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBjb25kaXRpb247XG59XG5mdW5jdGlvbiBpc09ic2VydmFibGUodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJ3N1YnNjcmliZScgaW4gdmFsdWUgJiYgaXNGdW5jdGlvbih2YWx1ZS5zdWJzY3JpYmUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG52YXIgc3ltYm9sT2JzZXJ2YWJsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5vYnNlcnZhYmxlIHx8ICdAQG9ic2VydmFibGUnO1xufSgpOyAvLyBUT0RPOiB0byBiZSByZW1vdmVkIGluIHY1LCBsZWZ0IGl0IG91dCBqdXN0IHRvIG1pbmltaXplIHRoZSBzY29wZSBvZiB0aGUgY2hhbmdlIGFuZCBtYWludGFpbiBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgaW50ZWdyYXRpb24gcGFhY2thZ2VzXG5cbnZhciBpbnRlcm9wU3ltYm9scyA9IChfYSA9IHt9LCBfYVtzeW1ib2xPYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59LCBfYVtTeW1ib2wub2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufSwgX2EpO1xuZnVuY3Rpb24gaXNNYWNoaW5lKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmICdfX3hzdGF0ZW5vZGUnIGluIHZhbHVlO1xufVxuZnVuY3Rpb24gaXNBY3Rvcih2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuc2VuZCA9PT0gJ2Z1bmN0aW9uJztcbn1cbnZhciB1bmlxdWVJZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBjdXJyZW50SWQgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGN1cnJlbnRJZCsrO1xuICAgIHJldHVybiBjdXJyZW50SWQudG9TdHJpbmcoMTYpO1xuICB9O1xufSgpO1xuZnVuY3Rpb24gdG9FdmVudE9iamVjdChldmVudCwgcGF5bG9hZCAvLyBpZD86IFRFdmVudFsndHlwZSddXG4pIHtcbiAgaWYgKGlzU3RyaW5nKGV2ZW50KSB8fCB0eXBlb2YgZXZlbnQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIF9fYXNzaWduKHtcbiAgICAgIHR5cGU6IGV2ZW50XG4gICAgfSwgcGF5bG9hZCk7XG4gIH1cblxuICByZXR1cm4gZXZlbnQ7XG59XG5mdW5jdGlvbiB0b1NDWE1MRXZlbnQoZXZlbnQsIHNjeG1sRXZlbnQpIHtcbiAgaWYgKCFpc1N0cmluZyhldmVudCkgJiYgJyQkdHlwZScgaW4gZXZlbnQgJiYgZXZlbnQuJCR0eXBlID09PSAnc2N4bWwnKSB7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgdmFyIGV2ZW50T2JqZWN0ID0gdG9FdmVudE9iamVjdChldmVudCk7XG4gIHJldHVybiBfX2Fzc2lnbih7XG4gICAgbmFtZTogZXZlbnRPYmplY3QudHlwZSxcbiAgICBkYXRhOiBldmVudE9iamVjdCxcbiAgICAkJHR5cGU6ICdzY3htbCcsXG4gICAgdHlwZTogJ2V4dGVybmFsJ1xuICB9LCBzY3htbEV2ZW50KTtcbn1cbmZ1bmN0aW9uIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KGV2ZW50LCBjb25maWdMaWtlKSB7XG4gIHZhciB0cmFuc2l0aW9ucyA9IHRvQXJyYXlTdHJpY3QoY29uZmlnTGlrZSkubWFwKGZ1bmN0aW9uICh0cmFuc2l0aW9uTGlrZSkge1xuICAgIGlmICh0eXBlb2YgdHJhbnNpdGlvbkxpa2UgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB0cmFuc2l0aW9uTGlrZSA9PT0gJ3N0cmluZycgfHwgaXNNYWNoaW5lKHRyYW5zaXRpb25MaWtlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiB0cmFuc2l0aW9uTGlrZSxcbiAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdHJhbnNpdGlvbkxpa2UpLCB7XG4gICAgICBldmVudDogZXZlbnRcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0cmFuc2l0aW9ucztcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gVEFSR0VUTEVTU19LRVkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHRvQXJyYXkodGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHJlcG9ydFVuaGFuZGxlZEV4Y2VwdGlvbk9uSW52b2NhdGlvbihvcmlnaW5hbEVycm9yLCBjdXJyZW50RXJyb3IsIGlkKSB7XG4gIGlmICghSVNfUFJPRFVDVElPTikge1xuICAgIHZhciBvcmlnaW5hbFN0YWNrVHJhY2UgPSBvcmlnaW5hbEVycm9yLnN0YWNrID8gXCIgU3RhY2t0cmFjZSB3YXMgJ1wiLmNvbmNhdChvcmlnaW5hbEVycm9yLnN0YWNrLCBcIidcIikgOiAnJztcblxuICAgIGlmIChvcmlnaW5hbEVycm9yID09PSBjdXJyZW50RXJyb3IpIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKFwiTWlzc2luZyBvbkVycm9yIGhhbmRsZXIgZm9yIGludm9jYXRpb24gJ1wiLmNvbmNhdChpZCwgXCInLCBlcnJvciB3YXMgJ1wiKS5jb25jYXQob3JpZ2luYWxFcnJvciwgXCInLlwiKS5jb25jYXQob3JpZ2luYWxTdGFja1RyYWNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFja1RyYWNlID0gY3VycmVudEVycm9yLnN0YWNrID8gXCIgU3RhY2t0cmFjZSB3YXMgJ1wiLmNvbmNhdChjdXJyZW50RXJyb3Iuc3RhY2ssIFwiJ1wiKSA6ICcnOyAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuXG4gICAgICBjb25zb2xlLmVycm9yKFwiTWlzc2luZyBvbkVycm9yIGhhbmRsZXIgYW5kL29yIHVuaGFuZGxlZCBleGNlcHRpb24vcHJvbWlzZSByZWplY3Rpb24gZm9yIGludm9jYXRpb24gJ1wiLmNvbmNhdChpZCwgXCInLiBcIikgKyBcIk9yaWdpbmFsIGVycm9yOiAnXCIuY29uY2F0KG9yaWdpbmFsRXJyb3IsIFwiJy4gXCIpLmNvbmNhdChvcmlnaW5hbFN0YWNrVHJhY2UsIFwiIEN1cnJlbnQgZXJyb3IgaXMgJ1wiKS5jb25jYXQoY3VycmVudEVycm9yLCBcIicuXCIpLmNvbmNhdChzdGFja1RyYWNlKSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBldmFsdWF0ZUd1YXJkKG1hY2hpbmUsIGd1YXJkLCBjb250ZXh0LCBfZXZlbnQsIHN0YXRlKSB7XG4gIHZhciBndWFyZHMgPSBtYWNoaW5lLm9wdGlvbnMuZ3VhcmRzO1xuICB2YXIgZ3VhcmRNZXRhID0ge1xuICAgIHN0YXRlOiBzdGF0ZSxcbiAgICBjb25kOiBndWFyZCxcbiAgICBfZXZlbnQ6IF9ldmVudFxuICB9OyAvLyBUT0RPOiBkbyBub3QgaGFyZGNvZGUhXG5cbiAgaWYgKGd1YXJkLnR5cGUgPT09IERFRkFVTFRfR1VBUkRfVFlQRSkge1xuICAgIHJldHVybiAoKGd1YXJkcyA9PT0gbnVsbCB8fCBndWFyZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGd1YXJkc1tndWFyZC5uYW1lXSkgfHwgZ3VhcmQucHJlZGljYXRlKShjb250ZXh0LCBfZXZlbnQuZGF0YSwgZ3VhcmRNZXRhKTtcbiAgfVxuXG4gIHZhciBjb25kRm4gPSBndWFyZHMgPT09IG51bGwgfHwgZ3VhcmRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBndWFyZHNbZ3VhcmQudHlwZV07XG5cbiAgaWYgKCFjb25kRm4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJHdWFyZCAnXCIuY29uY2F0KGd1YXJkLnR5cGUsIFwiJyBpcyBub3QgaW1wbGVtZW50ZWQgb24gbWFjaGluZSAnXCIpLmNvbmNhdChtYWNoaW5lLmlkLCBcIicuXCIpKTtcbiAgfVxuXG4gIHJldHVybiBjb25kRm4oY29udGV4dCwgX2V2ZW50LmRhdGEsIGd1YXJkTWV0YSk7XG59XG5mdW5jdGlvbiB0b0ludm9rZVNvdXJjZShzcmMpIHtcbiAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHNyY1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gc3JjO1xufVxuZnVuY3Rpb24gdG9PYnNlcnZlcihuZXh0SGFuZGxlciwgZXJyb3JIYW5kbGVyLCBjb21wbGV0aW9uSGFuZGxlcikge1xuICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIHZhciBpc09ic2VydmVyID0gdHlwZW9mIG5leHRIYW5kbGVyID09PSAnb2JqZWN0JztcbiAgdmFyIHNlbGYgPSBpc09ic2VydmVyID8gbmV4dEhhbmRsZXIgOiBudWxsO1xuICByZXR1cm4ge1xuICAgIG5leHQ6ICgoaXNPYnNlcnZlciA/IG5leHRIYW5kbGVyLm5leHQgOiBuZXh0SGFuZGxlcikgfHwgbm9vcCkuYmluZChzZWxmKSxcbiAgICBlcnJvcjogKChpc09ic2VydmVyID8gbmV4dEhhbmRsZXIuZXJyb3IgOiBlcnJvckhhbmRsZXIpIHx8IG5vb3ApLmJpbmQoc2VsZiksXG4gICAgY29tcGxldGU6ICgoaXNPYnNlcnZlciA/IG5leHRIYW5kbGVyLmNvbXBsZXRlIDogY29tcGxldGlvbkhhbmRsZXIpIHx8IG5vb3ApLmJpbmQoc2VsZilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludm9rZUlkKHN0YXRlTm9kZUlkLCBpbmRleCkge1xuICByZXR1cm4gXCJcIi5jb25jYXQoc3RhdGVOb2RlSWQsIFwiOmludm9jYXRpb25bXCIpLmNvbmNhdChpbmRleCwgXCJdXCIpO1xufVxuZnVuY3Rpb24gaXNSYWlzYWJsZUFjdGlvbihhY3Rpb24pIHtcbiAgcmV0dXJuIChhY3Rpb24udHlwZSA9PT0gcmFpc2UgfHwgYWN0aW9uLnR5cGUgPT09IHNlbmQgJiYgYWN0aW9uLnRvID09PSBTcGVjaWFsVGFyZ2V0cy5JbnRlcm5hbCkgJiYgdHlwZW9mIGFjdGlvbi5kZWxheSAhPT0gJ251bWJlcic7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUludm9rZUlkLCBldmFsdWF0ZUd1YXJkLCBmbGF0dGVuLCBnZXRBY3Rpb25UeXBlLCBnZXRFdmVudFR5cGUsIGludGVyb3BTeW1ib2xzLCBpc0FjdG9yLCBpc0FycmF5LCBpc0JlaGF2aW9yLCBpc0J1aWx0SW5FdmVudCwgaXNGdW5jdGlvbiwgaXNNYWNoaW5lLCBpc09ic2VydmFibGUsIGlzUHJvbWlzZUxpa2UsIGlzUmFpc2FibGVBY3Rpb24sIGlzU3RhdGVMaWtlLCBpc1N0cmluZywga2V5cywgbWFwQ29udGV4dCwgbWFwRmlsdGVyVmFsdWVzLCBtYXBWYWx1ZXMsIG1hdGNoZXNTdGF0ZSwgbmVzdGVkUGF0aCwgbm9ybWFsaXplVGFyZ2V0LCBwYXJ0aXRpb24sIHBhdGgsIHBhdGhUb1N0YXRlVmFsdWUsIHBhdGhzVG9TdGF0ZVZhbHVlLCByZXBvcnRVbmhhbmRsZWRFeGNlcHRpb25Pbkludm9jYXRpb24sIHN5bWJvbE9ic2VydmFibGUsIHRvQXJyYXksIHRvQXJyYXlTdHJpY3QsIHRvRXZlbnRPYmplY3QsIHRvR3VhcmQsIHRvSW52b2tlU291cmNlLCB0b09ic2VydmVyLCB0b1NDWE1MRXZlbnQsIHRvU3RhdGVQYXRoLCB0b1N0YXRlUGF0aHMsIHRvU3RhdGVWYWx1ZSwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXksIHVuaXF1ZUlkLCB1cGRhdGVDb250ZXh0LCB1cGRhdGVIaXN0b3J5U3RhdGVzLCB1cGRhdGVIaXN0b3J5VmFsdWUsIHdhcm4gfTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8vIGltcG9ydCBzdGF0ZSBtYWNoaW5lcyBmb3IgYXVkaW8gaW5wdXQgYW5kIG91dHB1dFxuY29uc3QgeyBpbnRlcnByZXQgfSA9IHJlcXVpcmUoXCJ4c3RhdGVcIik7XG5jb25zdCB7IGF1ZGlvSW5wdXRNYWNoaW5lIH0gPSByZXF1aXJlKFwiLi9zdGF0ZS1tYWNoaW5lcy9BdWRpb0lucHV0TWFjaGluZVwiKTtcbmNvbnN0IHsgYXVkaW9PdXRwdXRNYWNoaW5lIH0gPSByZXF1aXJlKFwiLi9zdGF0ZS1tYWNoaW5lcy9BdWRpb091dHB1dE1hY2hpbmVcIik7XG5jb25zdCB7IHNlcmlhbGl6ZVN0YXRlVmFsdWUgfSA9IHJlcXVpcmUoXCIuL0xvZ2dpbmdNb2R1bGVcIik7XG5cbi8vIGRlcGVuZHMgb24gdGhlIGluamVjdGluZyBzY3JpcHQgKHNheXBpLmluZGV4LmpzKSBkZWNsYXJpbmcgdGhlIEV2ZW50QnVzIGFzIGEgZ2xvYmFsIHZhcmlhYmxlXG5jb25zdCBFdmVudEJ1cyA9IHdpbmRvdy5FdmVudEJ1cztcblxuLy8gYXVkaW8gb3V0cHV0IChQaSlcbmNvbnN0IGF1ZGlvRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJhdWRpb1wiKTtcbmlmICghYXVkaW9FbGVtZW50KSB7XG4gIGNvbnNvbGUuZXJyb3IoXCJBdWRpbyBlbGVtZW50IG5vdCBmb3VuZCFcIik7XG59IGVsc2Uge1xuICBhdWRpb0VsZW1lbnQucHJlbG9hZCA9IFwiYXV0b1wiOyAvLyBlbmFibGUgYWdncmVzc2l2ZSBwcmVsb2FkaW5nIG9mIGF1ZGlvXG59XG5cbmNvbnN0IGF1ZGlvT3V0cHV0QWN0b3IgPSBpbnRlcnByZXQoYXVkaW9PdXRwdXRNYWNoaW5lKVxuICAub25UcmFuc2l0aW9uKChzdGF0ZSkgPT4ge1xuICAgIGlmIChzdGF0ZS5jaGFuZ2VkKSB7XG4gICAgICBjb25zdCBmcm9tU3RhdGUgPSBzdGF0ZS5oaXN0b3J5XG4gICAgICAgID8gc2VyaWFsaXplU3RhdGVWYWx1ZShzdGF0ZS5oaXN0b3J5LnZhbHVlKVxuICAgICAgICA6IFwiTi9BXCI7XG4gICAgICBjb25zdCB0b1N0YXRlID0gc2VyaWFsaXplU3RhdGVWYWx1ZShzdGF0ZS52YWx1ZSk7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYEF1ZGlvIE91dHB1dCBNYWNoaW5lIHRyYW5zaXRpb25lZCBmcm9tICR7ZnJvbVN0YXRlfSB0byAke3RvU3RhdGV9IHdpdGggJHtzdGF0ZS5ldmVudC50eXBlfWBcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmxvZyhzdGF0ZS5jb250ZXh0KTtcbiAgICB9XG4gIH0pXG4gIC5zdGFydCgpO1xuXG5mdW5jdGlvbiByZWdpc3RlckF1ZGlvUGxheWJhY2tFdmVudHMoYXVkaW8sIGFjdG9yKSB7XG4gIGNvbnN0IGV2ZW50cyA9IFtcbiAgICBcImxvYWRzdGFydFwiLFxuICAgIFwibG9hZGVkbWV0YWRhdGFcIixcbiAgICBcImNhbnBsYXl0aHJvdWdoXCIsXG4gICAgXCJwbGF5XCIsXG4gICAgXCJwYXVzZVwiLFxuICAgIFwiZW5kZWRcIixcbiAgICBcInNlZWtlZFwiLFxuICAgIFwiZW1wdGllZFwiLFxuICBdO1xuXG4gIGV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsICgpID0+IGFjdG9yLnNlbmQoZXZlbnQpKTtcbiAgfSk7XG5cbiAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcihcInBsYXlpbmdcIiwgKCkgPT4ge1xuICAgIGFjdG9yLnNlbmQoXCJwbGF5XCIpO1xuICB9KTtcbn1cbnJlZ2lzdGVyQXVkaW9QbGF5YmFja0V2ZW50cyhhdWRpb0VsZW1lbnQsIGF1ZGlvT3V0cHV0QWN0b3IpO1xuXG4vLyBhdWRpbyBpbnB1dCAodXNlcilcbmNvbnN0IGF1ZGlvSW5wdXRBY3RvciA9IGludGVycHJldChhdWRpb0lucHV0TWFjaGluZSlcbiAgLm9uVHJhbnNpdGlvbigoc3RhdGUpID0+IHtcbiAgICBpZiAoc3RhdGUuY2hhbmdlZCkge1xuICAgICAgY29uc3QgZnJvbVN0YXRlID0gc3RhdGUuaGlzdG9yeVxuICAgICAgICA/IHNlcmlhbGl6ZVN0YXRlVmFsdWUoc3RhdGUuaGlzdG9yeS52YWx1ZSlcbiAgICAgICAgOiBcIk4vQVwiO1xuICAgICAgY29uc3QgdG9TdGF0ZSA9IHNlcmlhbGl6ZVN0YXRlVmFsdWUoc3RhdGUudmFsdWUpO1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGBBdWRpbyBJbnB1dCBNYWNoaW5lIHRyYW5zaXRpb25lZCBmcm9tICR7ZnJvbVN0YXRlfSB0byAke3RvU3RhdGV9IHdpdGggJHtzdGF0ZS5ldmVudC50eXBlfWBcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmxvZyhzdGF0ZS5jb250ZXh0KTtcbiAgICB9XG4gIH0pXG4gIC5zdGFydCgpO1xuXG4vKiBUaGVzZSBldmVudHMgYXJlIHVzZWQgdG8gY29udHJvbC9wYXNzIHJlcXVlc3RzIHRvIHRoZSBhdWRpbyBtb2R1bGUgZnJvbSBvdGhlciBtb2R1bGVzICovXG5mdW5jdGlvbiByZWdpc3RlckF1ZGlvQ29tbWFuZHMoKSB7XG4gIC8vIGF1ZGlvIGlucHV0IChyZWNvcmRpbmcpIGNvbW1hbmRzXG4gIEV2ZW50QnVzLm9uKFwiYXVkaW86c2V0dXBSZWNvcmRpbmdcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICBhdWRpb0lucHV0QWN0b3Iuc2VuZChcImFjcXVpcmVcIik7XG4gIH0pO1xuXG4gIEV2ZW50QnVzLm9uKFwiYXVkaW86dGVhckRvd25SZWNvcmRpbmdcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICBhdWRpb0lucHV0QWN0b3Iuc2VuZChcInJlbGVhc2VcIik7XG4gIH0pO1xuXG4gIEV2ZW50QnVzLm9uKFwiYXVkaW86c3RhcnRSZWNvcmRpbmdcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAvLyBDaGVjayBpZiBQaSBpcyBjdXJyZW50bHkgc3BlYWtpbmcgYW5kIHN0b3AgaGVyIGF1ZGlvXG4gICAgYXVkaW9PdXRwdXRBY3Rvci5zZW5kKFwicGF1c2VcIik7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgTWVkaWFSZWNvcmRlciBpcyBhY3F1aXJlZCBiZWZvcmUgc3RhcnRpbmc/XG4gICAgYXVkaW9JbnB1dEFjdG9yLnNlbmQoW1wiYWNxdWlyZVwiLCBcInN0YXJ0XCJdKTtcbiAgfSk7XG4gIEV2ZW50QnVzLm9uKFwiYXVkaW86c3RvcFJlY29yZGluZ1wiLCBmdW5jdGlvbiAoZSkge1xuICAgIGF1ZGlvSW5wdXRBY3Rvci5zZW5kKFwic3RvcFJlcXVlc3RlZFwiKTtcbiAgICAvKiByZXN1bWUgb3IgY2FuY2VsIFBpJ3MgYXVkaW8gKi9cbiAgICAvKiBUT0RPOiByZWFzc2VzcyBob3cgdG8gaGFuZGxlIGludGVycnVwdGlvbnNcbiAgICBhdWRpb091dHB1dEFjdG9yLnNlbmQoXCJwbGF5XCIpOyAvLyByZXN1bWUgUGkncyBhdWRpb1xuICAgIGF1ZGlvT3V0cHV0QWN0b3Iuc2VuZChcInN0b3BcIik7IC8vIGNhbmNlbCBQaSdzIGF1ZGlvXG4gICAgKi9cbiAgfSk7XG4gIC8vIGF1ZGlvIGlucHV0IChyZWNvcmRpbmcpIGV2ZW50cyAocGFzcyBtZWRpYSByZWNvcmRlciBldmVudHMgLT4gYXVkaW8gaW5wdXQgbWFjaGluZSBhY3RvcilcbiAgRXZlbnRCdXMub24oXCJhdWRpbzpkYXRhYXZhaWxhYmxlXCIsIChkZXRhaWwpID0+IHtcbiAgICBhdWRpb0lucHV0QWN0b3Iuc2VuZCh7IHR5cGU6IFwiZGF0YUF2YWlsYWJsZVwiLCAuLi5kZXRhaWwgfSk7XG4gIH0pO1xuICBFdmVudEJ1cy5vbihcImF1ZGlvOmlucHV0OnN0b3BcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICBhdWRpb0lucHV0QWN0b3Iuc2VuZChcInN0b3BcIik7XG4gIH0pO1xuXG4gIC8vIGF1ZGlvIG91dHB1dCAocGxheWJhY2spIGNvbW1hbmRzXG4gIEV2ZW50QnVzLm9uKFwiYXVkaW86cmVsb2FkXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgYXVkaW9PdXRwdXRBY3Rvci5zZW5kKFwicmVsb2FkXCIpO1xuICB9KTtcbn1cbnJlZ2lzdGVyQXVkaW9Db21tYW5kcygpO1xuIl0sIm5hbWVzIjpbImNvbmZpZyIsImFwcFNlcnZlclVybCIsInByb2Nlc3MiLCJlbnYiLCJBUFBfU0VSVkVSX1VSTCIsImFwaVNlcnZlclVybCIsIkFQSV9TRVJWRVJfVVJMIiwic2VyaWFsaXplU3RhdGVWYWx1ZSIsInN0YXRlVmFsdWUiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwia2V5IiwiY29uY2F0Iiwiam9pbiIsImZpbGVzVG9SZWRpcmVjdCIsInJlZGlyZWN0WE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwiWE1MSHR0cFJlcXVlc3QiLCJwcm90b3R5cGUiLCJtZXRob2QiLCJ1cmwiLCJhc3luYyIsInVzZXIiLCJwYXNzd29yZCIsImZpbGVuYW1lIiwic3BsaXQiLCJwb3AiLCJpbmNsdWRlcyIsImFyZ3VtZW50cyIsImFwcGx5IiwicmVkaXJlY3RGZXRjaCIsIl9mZXRjaCIsIndpbmRvdyIsImZldGNoIiwib3B0cyIsInNldHVwSW50ZXJjZXB0b3JzIiwiaXNTYWZhcmkiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNNb2JpbGVEZXZpY2UiLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsImlzTW9iaWxlVmlldyIsInVzZXJWaWV3UHJlZmVyZW5jZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJlIiwiY29uc29sZSIsIndhcm4iLCJwcmVmZXJzTW9iaWxlIiwiZXhpdE1vYmlsZU1vZGUiLCJzZXRJdGVtIiwiZWxlbWVudCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwiYWRkIiwiZW50ZXJNb2JpbGVNb2RlIiwiYWRkVXNlckFnZW50RmxhZ3MiLCJpc0ZpcmVmb3hBbmRyb2lkIiwiYWRkRGV2aWNlRmxhZ3MiLCJhZGRWaWV3RmxhZ3MiLCJfcmVnZW5lcmF0b3JSdW50aW1lIiwiZXhwb3J0cyIsIk9wIiwiaGFzT3duIiwiaGFzT3duUHJvcGVydHkiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImRlc2MiLCJ2YWx1ZSIsIiRTeW1ib2wiLCJTeW1ib2wiLCJpdGVyYXRvclN5bWJvbCIsIml0ZXJhdG9yIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsInRvU3RyaW5nVGFnIiwiZGVmaW5lIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiZXJyIiwid3JhcCIsImlubmVyRm4iLCJvdXRlckZuIiwic2VsZiIsInRyeUxvY3NMaXN0IiwicHJvdG9HZW5lcmF0b3IiLCJHZW5lcmF0b3IiLCJnZW5lcmF0b3IiLCJjcmVhdGUiLCJjb250ZXh0IiwiQ29udGV4dCIsIm1ha2VJbnZva2VNZXRob2QiLCJ0cnlDYXRjaCIsImZuIiwiYXJnIiwidHlwZSIsImNhbGwiLCJDb250aW51ZVNlbnRpbmVsIiwiR2VuZXJhdG9yRnVuY3Rpb24iLCJHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSIsIkl0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwidmFsdWVzIiwiR3AiLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJmb3JFYWNoIiwiX2ludm9rZSIsIkFzeW5jSXRlcmF0b3IiLCJQcm9taXNlSW1wbCIsImludm9rZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWNvcmQiLCJyZXN1bHQiLCJfdHlwZW9mIiwiX19hd2FpdCIsInRoZW4iLCJ1bndyYXBwZWQiLCJlcnJvciIsInByZXZpb3VzUHJvbWlzZSIsImNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnIiwic3RhdGUiLCJFcnJvciIsImRvbmUiLCJkZWxlZ2F0ZSIsImRlbGVnYXRlUmVzdWx0IiwibWF5YmVJbnZva2VEZWxlZ2F0ZSIsInNlbnQiLCJfc2VudCIsImRpc3BhdGNoRXhjZXB0aW9uIiwiYWJydXB0IiwibWV0aG9kTmFtZSIsInVuZGVmaW5lZCIsIlR5cGVFcnJvciIsImluZm8iLCJyZXN1bHROYW1lIiwibmV4dCIsIm5leHRMb2MiLCJwdXNoVHJ5RW50cnkiLCJsb2NzIiwiZW50cnkiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJwdXNoIiwicmVzZXRUcnlFbnRyeSIsImNvbXBsZXRpb24iLCJyZXNldCIsIml0ZXJhYmxlIiwiaXRlcmF0b3JNZXRob2QiLCJpc05hTiIsImxlbmd0aCIsImkiLCJkaXNwbGF5TmFtZSIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5GdW4iLCJjdG9yIiwiY29uc3RydWN0b3IiLCJuYW1lIiwibWFyayIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiYXdyYXAiLCJQcm9taXNlIiwiaXRlciIsInZhbCIsIm9iamVjdCIsInJldmVyc2UiLCJza2lwVGVtcFJlc2V0IiwicHJldiIsImNoYXJBdCIsInNsaWNlIiwic3RvcCIsInJvb3RSZWNvcmQiLCJydmFsIiwiZXhjZXB0aW9uIiwiaGFuZGxlIiwibG9jIiwiY2F1Z2h0IiwiaGFzQ2F0Y2giLCJoYXNGaW5hbGx5IiwiZmluYWxseUVudHJ5IiwiY29tcGxldGUiLCJmaW5pc2giLCJfY2F0Y2giLCJ0aHJvd24iLCJkZWxlZ2F0ZVlpZWxkIiwiYXN5bmNHZW5lcmF0b3JTdGVwIiwiZ2VuIiwiX25leHQiLCJfdGhyb3ciLCJfYXN5bmNUb0dlbmVyYXRvciIsImFyZ3MiLCJjcmVhdGVNYWNoaW5lIiwiYWN0aW9ucyIsImxvZyIsIk1pY1ZBRCIsImNvbnZlcnRUb1dhdkJsb2IiLCJmdWxsV29ya2xldFVSTCIsIkV2ZW50QnVzIiwiYXVkaW9NaW1lVHlwZSIsInNwZWVjaFN0YXJ0VGltZSIsInRocmVzaG9sZCIsIm1pY3JvcGhvbmUiLCJzZXR1cFJlY29yZGluZyIsIl94IiwiX3NldHVwUmVjb3JkaW5nIiwiX2NhbGxlZSIsImNhbGxiYWNrIiwic3RyZWFtIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsImF1ZGlvIiwiY2hhbm5lbENvdW50IiwiZWNob0NhbmNlbGxhdGlvbiIsImF1dG9HYWluQ29udHJvbCIsIm5vaXNlU3VwcHJlc3Npb24iLCJ3b3JrbGV0VVJMIiwicG9zaXRpdmVTcGVlY2hUaHJlc2hvbGQiLCJtaW5TcGVlY2hGcmFtZXMiLCJwcmVTcGVlY2hQYWRGcmFtZXMiLCJvblNwZWVjaFN0YXJ0IiwiRGF0ZSIsIm5vdyIsIm9uU3BlZWNoRW5kIiwicmF3QXVkaW9EYXRhIiwiYXVkaW9CbG9iIiwiZW1pdCIsImJsb2IiLCJvblZBRE1pc2ZpcmUiLCJ0MCIsInRlYXJEb3duUmVjb3JkaW5nIiwicGF1c2UiLCJhdWRpb0lucHV0TWFjaGluZSIsIndhaXRpbmdUb1N0b3AiLCJpZCIsImluaXRpYWwiLCJzdGF0ZXMiLCJyZWxlYXNlZCIsIm9uIiwiYWNxdWlyZSIsInRhcmdldCIsImFjcXVpcmluZyIsImRlc2NyaXB0aW9uIiwic3JjIiwib25Eb25lIiwib25FcnJvciIsImFjcXVpcmVkIiwiaWRsZSIsInN0YXJ0IiwiY29uZCIsInJlY29yZGluZyIsInN0b3BSZXF1ZXN0ZWQiLCJkYXRhQXZhaWxhYmxlIiwicGFyYW1zIiwiaW50ZXJuYWwiLCJwZW5kaW5nU3RvcCIsInN0b3BwZWQiLCJhbHdheXMiLCJyZWxlYXNlIiwicHJlZGljdGFibGVBY3Rpb25Bcmd1bWVudHMiLCJwcmVzZXJ2ZUFjdGlvbk9yZGVyIiwic3RhcnRSZWNvcmRpbmciLCJldmVudCIsInJlY29yZGluZ1N0YXJ0VGltZSIsImxpc3RlbmluZyIsInByZXBhcmVTdG9wIiwibm90aWZ5U3RvcHBlZCIsInJlY29yZGluZ1N0b3BUaW1lIiwicmVjb3JkaW5nRHVyYXRpb24iLCJkdXJhdGlvblJlY29yZGluZyIsInNlbmREYXRhIiwic2l6ZUluS2IiLCJieXRlTGVuZ3RoIiwidG9GaXhlZCIsInNwZWVjaFN0b3BUaW1lIiwic3BlZWNoRHVyYXRpb24iLCJkdXJhdGlvbiIsInJlbGVhc2VNaWNyb3Bob25lIiwibG9nRXJyb3IiLCJkYXRhIiwic2VydmljZXMiLCJhY3F1aXJlTWljcm9waG9uZSIsIl9yZWYiLCJzZW5kIiwiZ3VhcmRzIiwibWljcm9waG9uZUFjcXVpcmVkIiwiaGFzRGF0YSIsImF1ZGlvRGF0YUNodW5rcyIsImRlbGF5cyIsImFzc2lnbiIsImF1ZGlvRWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJhdWRpb091dHB1dE1hY2hpbmUiLCJhdXRvcGxheSIsImxvYWRzdGFydCIsImxvYWRpbmciLCJsb2FkZWRtZXRhZGF0YSIsImxvYWRlZCIsImVtcHRpZWQiLCJyZWFkeSIsInBsYXkiLCJldmVudE5hbWUiLCJwbGF5aW5nIiwiZW5kZWQiLCJjYW5wbGF5dGhyb3VnaCIsImV4aXQiLCJwYXVzZWQiLCJyZWxvYWQiLCJzZWVrZWQiLCJlbWl0RXZlbnQiLCJhY3Rpb24iLCJyZXF1ZXN0UGF1c2UiLCJzZWVrVG9FbmQiLCJjdXJyZW50VGltZSIsInJlcXVlc3RSZWxvYWQiLCJsb2FkIiwiaXNTYWZhcmlBdXRvUGxheSIsIl9yZXF1aXJlIiwicmVxdWlyZSIsImludGVycHJldCIsIl9yZXF1aXJlMiIsIl9yZXF1aXJlMyIsIl9yZXF1aXJlNCIsInByZWxvYWQiLCJhdWRpb091dHB1dEFjdG9yIiwib25UcmFuc2l0aW9uIiwiY2hhbmdlZCIsImZyb21TdGF0ZSIsImhpc3RvcnkiLCJ0b1N0YXRlIiwicmVnaXN0ZXJBdWRpb1BsYXliYWNrRXZlbnRzIiwiYWN0b3IiLCJldmVudHMiLCJhZGRFdmVudExpc3RlbmVyIiwiYXVkaW9JbnB1dEFjdG9yIiwicmVnaXN0ZXJBdWRpb0NvbW1hbmRzIiwiZGV0YWlsIiwiX29iamVjdFNwcmVhZCJdLCJzb3VyY2VSb290IjoiIn0=