Investigating Reddit’s Post Composer: Rich Text vs Markdown Modes

Underlying Editor Frameworks and Architecture

Reddit’s new post composer supports two modes – a Rich Text Editor (RTE) and a Markdown editor – which are implemented with different underlying frameworks. The Rich Text mode uses a modern WYSIWYG editor framework (likely Lexical, developed by Meta/Facebook), whereas the Markdown mode uses a plain text input (a standard HTML <textarea>). These two modes are separate implementations, not just two views on one editor. In practice, the RTE is a contenteditable field powered by Lexical’s engine, while the Markdown editor is a simple text area for raw Markdown input. The two modes live within the same shreddit-composer component but toggle distinct subcomponents: one for the Lexical editor vs. one for the Markdown textarea ￼. This means a browser extension must handle each mode a bit differently.

Rich Text (WYSIWYG) Mode: The RTE is built on a contenteditable <div> element (or similar) that Lexical controls. A telltale sign is the attribute data-lexical-editor="true" on the contenteditable element. This is a marker Lexical uses on its editable root; for example, Facebook’s Messenger input and other Lexical-based editors have a <div contenteditable="true" role="textbox" data-lexical-editor="true"> in the DOM ￼. Reddit’s composer shows the same attribute on its rich text field, confirming the use of Lexical. Lexical manages its content with an internal state (not just the DOM), updating the DOM in response to user input events. The RTE supports formatted text (bold, links, etc.), and Reddit likely serializes it to a Lexical JSON or HTML when submitting.

Markdown Mode: In Markdown mode, the composer exposes a plain text area for unformatted text. Internally, Reddit wraps this in a web component <shreddit-markdown-composer>, whose shadow DOM contains a <textarea> element (with attributes like spellcheck="false", etc.). This is essentially a standard HTML textarea, meaning it doesn’t use a complex framework – just the browser’s native text input. The Markdown editor doesn’t maintain a separate rich-text state; it directly uses the textarea’s value (which will be parsed as Markdown on submission). The two modes are distinct enough that switching modes will hide one editor and show the other (possibly even unmounting the Lexical editor when in Markdown mode to free resources).

DOM Structure: Contenteditable vs Textarea

Rich Text Editor Structure: The Lexical RTE is rendered as a contenteditable container in the DOM (inside the shreddit-composer shadow). For example, a snippet of a Lexical editor’s DOM (from a similar implementation) looks like:

￼

This shows a <div> with contenteditable="true", role="textbox", and data-lexical-editor="true". In Reddit’s case, you can find a similar element by querying the composer’s shadow DOM for [data-lexical-editor="true"]. This element is where the user’s rich-text content lives. Lexical attaches event handlers to this contenteditable to intercept typing, handle formatting, etc. The presence of data-lexical-editor="true" is a strong indicator of Lexical – indeed, Lexical’s code sets this attribute on its editable element for identification ￼.

Notably, the Lexical contenteditable is likely wrapped in the shadow DOM of shreddit-composer (and possibly further nested in a child shadow of a <shreddit-editor> or similar). Reddit appears to use open shadow DOM, since scripts can query into it (as demonstrated by community scripts). For example, a user script accesses composer.shadowRoot.querySelector('[data-lexical-editor="true"]') ￼, implying the shadow DOM is not closed. This is good news for extension developers: the contenteditable can be found and focused from a content script.

Markdown Editor Structure: The Markdown mode uses a <textarea> element contained within the shreddit-markdown-composer web component (which itself is inside the main composer’s shadow). The <textarea> is a normal text input field (with no rich formatting). A user script similarly finds it via composer.shadowRoot.querySelector('shreddit-markdown-composer')…shadowRoot.querySelector('textarea') ￼. Because it’s a standard textarea, it has typical properties like .value, .selectionStart, etc. The textarea is likely styled to match Reddit’s UI and might be resizable, but functionally it’s just an input box for text.

In summary, the two modes do not share the same editor object; the RTE is a Lexical-controlled contenteditable (with its own internal state and event handling), while the Markdown mode is a basic textarea. This separation means an extension needs to use different insertion strategies depending on which mode is active.

Inserting Text in Rich Text (Lexical) Mode

Use of Lexical (data-lexical-editor): Given that Reddit’s rich text composer is Lexical-based, we must insert text in a way that Lexical’s state stays consistent. It’s not enough to just manipulate the DOM (e.g. setting innerText on the contenteditable) because Lexical might not register that change. Instead, we should simulate a user input event so that Lexical’s listeners update the editor state with the new text.

Simulated Input via ExecCommand: The simplest reliable method – as observed in community solutions – is to focus the contenteditable and use the document.execCommand('insertText', false, "...') API ￼. This legacy command (while officially deprecated) still works in browsers and effectively injects text at the current cursor position as if the user typed it. For Lexical editors, execCommand('insertText') triggers the normal input event flow (beforeinput/input events) that Lexical intercepts, thereby updating the Lexical state. For example, a user script on Reddit’s RTE does:

lexicalEditor.focus();
document.execCommand('insertText', false, code + ' ');

If the command returns true, it indicates the text was inserted successfully ￼. This approach has been shown to work reliably for adding text in Lexical editors (Reddit and even Facebook Messenger’s Lexical-based chat input ￼). The inserted text will appear in the RTE and, importantly, Lexical’s internal state will include it (meaning the user can continue editing or undo/redo as expected).

Fallback for Insertion: In cases where execCommand('insertText') might not work (for instance, if the browser one day disables it, or if the command isn’t supported in a particular environment), a fallback is to insert a text node at the selection range manually. The GreasyFork “Reddit Emoji Picker” script demonstrates this fallback: it obtains the current window.getSelection(), then uses range.insertNode(textNode) and adjusts the selection range to be after the inserted node ￼. This ensures the new text is in the DOM. However, direct DOM insertion is not ideal because Lexical might not immediately sync this into its model. (In practice, Lexical usually listens to the input event that firing execCommand triggers. Manually inserting nodes without triggering an event could leave Lexical unaware of the change until the next user input.) Thus, the preferred method is to use execCommand or a synthetic beforeinput/input event if possible, rather than directly mutating the DOM.

Maintaining Cursor Position: A key requirement is that after inserting text, the user’s cursor (caret) remains at the end of the inserted text so they can continue typing naturally. Using execCommand('insertText') inherently does this – it inserts at the cursor and places the caret after the inserted text (just as normal typing would). In the fallback manual method, the script explicitly moves the caret: after inserting the text node, it calls range.setStartAfter(textNode) and updates the selection ￼. For a browser extension, the LexicalEditorStrategy should ensure that focus stays in the editor and the caret is positioned after the inserted text. Fortunately, simulating normal typing (via execCommand or equivalent events) will naturally maintain the cursor position. In testing, the inserted text does not disrupt focus – the editor remains focused and the user can immediately continue typing.

No Internal API Access: It’s worth noting we do not need to (and should not) call Lexical’s internal APIs (like editor.update() or insertText() methods) from the extension, since those are not accessible without injecting script into the page context (which would violate extension content script boundaries). The approach outlined above – using standard DOM methods and events – works within the content script context and is compliant with extension policies. In summary, treat the Lexical editor as a contenteditable textbox: focus it, then simulate keystrokes/insertions in a user-like way. This will preserve Lexical’s state and formatting. (Indeed, Lexical’s design specifically listens to native input events on the contenteditable ￼, so generating those events is the proper way to programmatically insert text.)

Inserting Text in Markdown Mode

When the composer is in Markdown mode, the extension can interact with it like a normal <textarea> input. Reddit’s Markdown composer textarea is accessible (via the open shadow DOM) and supports typical value manipulation. The strategy here is straightforward and aligns with an InputTextareaStrategy pattern:
	1.	Identify the <textarea> element: The textarea resides in shreddit-markdown-composer’s shadow. For example, composer.shadowRoot.querySelector('shreddit-markdown-composer') then .shadowRoot.querySelector('textarea') yields the element ￼. (In practice, your extension could locate it by traversing shadow DOM, or possibly by focusing – if the user has already focused it, you might detect document.activeElement as the host and then find the textarea inside.) Once you have the textarea element, ensure it’s focused or focus it via .focus() so that the user sees the caret and any placeholder text disappears.
	2.	Insert text at the cursor position: To preserve existing content and not clobber it, insert text at the current selection (caret) position. You can use the standard technique:
	•	Get startPos = textarea.selectionStart and endPos = textarea.selectionEnd.
	•	Compute the new value as textBefore = textarea.value.slice(0, startPos), textAfter = textarea.value.slice(endPos), then textarea.value = textBefore + newText + textAfter ￼.
	•	Update the selection/caret if needed: for insertion, set the caret after the newly inserted text. For example, const newPos = startPos + newText.length; textarea.setSelectionRange(newPos, newPos); puts the cursor right after the inserted content ￼. This step ensures the user can continue typing immediately after the inserted text, as if they typed it themselves. The Reddit script does exactly this when inserting an emoji code in Markdown mode, maintaining the cursor position after the inserted emoji text ￼.
	3.	Dispatch input events: After changing the .value, it’s important to notify Reddit’s application that the content changed. Normally, typing in a textarea triggers an input event, which frameworks or other code can listen for (e.g. to enable the “Post” button or to update a live preview). So the extension should dispatch an InputEvent or at least a simple Event on the textarea. The user script triggers both an 'input' event and a 'change' event on the textarea ￼. Dispatching an input event (bubbles = true) is usually sufficient to mimic typing. (They also dispatch change perhaps to cover any cases where Reddit’s code listens for change on blur – but input is the key for real-time updates). Example:

textarea.value = newValue;
textarea.dispatchEvent(new Event('input', { bubbles: true }));

This will ensure Reddit’s UI knows the content was modified. After this, the textarea’s content is updated and the user can continue editing. The focus/caret we set remains active.

Using InputTextareaStrategy: The above steps are essentially what a well-designed InputTextareaStrategy would do. If your extension already has an abstraction for textareas (setting value and firing an input event), you can reuse it here. The main addition for Reddit’s case is that the textarea lives inside a shadow DOM, so your strategy needs to find it. In many cases, InputTextareaStrategy might assume direct access to a visible <textarea> or <input> in the document. On Reddit, you might need to traverse into the shadow (e.g., find the <shreddit-markdown-composer> element and then its shadow child). Since the shadow is open, you can script this. Alternatively, if your extension identifies the active element differently, note that the actual focused element might be this textarea (which might not appear as document.activeElement due to the shadow host – the activeElement could be the host component). You may have to specifically query it.

Once you have the actual textarea element, though, no new strategy class is needed – the generic approach for textareas applies: set value, dispatch input event, maintain cursor. This will integrate seamlessly with Reddit’s Markdown mode, which expects direct text input.

Integration with Extension’s Strategy Pattern

With the above understanding, we can map Reddit’s editors to the appropriate existing strategies:
	•	Rich Text mode ➜ LexicalEditorStrategy: You can treat the Reddit RTE as a Lexical editor (just like other Lexical-based editors). The LexicalEditorStrategy should be used when a contenteditable with data-lexical-editor="true" is detected. This strategy would focus the contenteditable and programmatically insert text via an event simulation. Ensure this strategy uses methods like execCommand('insertText') or synthetic input events as described, rather than naive DOM insertion. Also, account for selection: if your strategy allows inserting at cursor vs replacing all content, use the cursor insertion approach. In practice, a robust Lexical strategy might:
	•	Locate the contenteditable element (perhaps via document.querySelector('[data-lexical-editor="true"]'), noting you may need to search within shadow roots).
	•	Focus it (to ensure the editor is active).
	•	Use document.execCommand('insertText', false, text) to insert, or fallback to a series of KeyboardEvent simulations if needed (though execCommand is simpler and has been shown to work on Lexical ￼).
	•	Not disturb the selection (execCommand will place caret correctly; if doing manually, adjust selection as shown in the fallback code ￼).
	•	Not rely on any Lexical global objects (just use DOM methods).
Since LexicalEditorStrategy likely already encapsulates this logic (especially if it was designed to handle Messenger or other Lexical editors), Reddit’s RTE should fit it well. You might just need to ensure your detection includes Reddit’s editor (the presence of data-lexical-editor="true" is a reliable indicator).
	•	Markdown mode ➜ InputTextareaStrategy: When the user is in Markdown mode, the editor is a standard textarea (albeit in a shadow DOM). Your existing InputTextareaStrategy can be applied. It typically sets the element’s value and fires an input event. You should extend it slightly to make sure it finds the textarea inside Reddit’s composer. For example, your code might need to detect if shreddit-markdown-composer is present and then get its shadow’s textarea. If your extension’s content script runs with enough privileges, you can navigate shadow roots directly. Otherwise, a workaround is to inject a small script to retrieve it, but since the shadow is open, direct access is simplest. Once you have the textarea element, use the strategy:
	•	Save the current cursor position (selectionStart/End).
	•	Insert or replace text accordingly, update .value.
	•	Restore the cursor (as shown above).
	•	Dispatch an input event on the textarea element.
This will emulate user typing or pasting text. The result is that Reddit’s Markdown editor will update just as if the user typed the text themselves. The user can then continue typing – the cursor remains where it should be (after the inserted text), and focus stays in the textarea (since we don’t blur it at any point).

Do We Need a New Strategy? Probably not. The behaviors needed for Reddit align with existing categories:
	•	Contenteditable (rich text) – already handled by a Lexical/dynamic editor strategy.
	•	Textarea (plain text) – handled by a generic input/textarea strategy.

The key addition is detecting which mode is active and choosing the correct strategy at runtime. As long as your extension can figure out the current mode (see next section), it can route to the appropriate strategy. One corner case: if Reddit’s Lexical editor had unique quirks that differ from other Lexical editors, you might adjust the strategy. For example, if execCommand didn’t work on Reddit for some reason, you’d need an alternate approach (such as simulating individual keystrokes via KeyboardEvent and letting the browser/lexical handle them – which is complicated and usually unnecessary). However, according to testing and community scripts, Reddit’s Lexical editor accepts execCommand('insertText') insertions just fine ￼. Therefore, the LexicalEditorStrategy can be reused without special cases.

One subtlety: if the extension’s Lexical strategy was implemented for a different site, ensure it doesn’t assume a specific element ID or structure. In Reddit, the contenteditable has no unique ID (just an attribute). So the strategy might need to detect by attribute data-lexical-editor or by role="textbox" and other clues that it’s the Lexical editor. Since no new strategy class is needed, it’s more about extending detection patterns within the existing ones.

Finally, maintaining user focus and editing flow is crucial. Both strategies should insert text without stealing focus away or resetting the caret to the end of all text (unless that’s intended). As we discussed, the recommended methods inherently preserve the caret position (for contenteditable via execCommand, for textarea via manual selectionRange adjustments). This means after the extension inserts the text, the user can immediately continue typing as normal. This is compatible with the “Say, Pi” dictation architecture – the user could dictate a phrase into Reddit’s composer and then continue typing or dictating more.

Detecting Rich Text vs Markdown Mode at Runtime

The extension should dynamically detect which mode the Reddit composer is in, because the same page could have either mode depending on user preference or a toggle. There are a few reliable indicators:
	•	Presence of the Markdown textarea vs. Lexical element: The simplest check is to see which editor element exists (and is visible) inside the composer. If you can access the shreddit-composer element’s shadow DOM, you can do something like:

const composer = document.querySelector('shreddit-composer');
if (composer) {
    const shadow = composer.shadowRoot;
    if (shadow.querySelector('shreddit-markdown-composer')) {
        // Markdown mode active
    } else if (shadow.querySelector('[data-lexical-editor="true"]')) {
        // Rich text mode active
    }
}

In practice, when the user has switched to Markdown, a <shreddit-markdown-composer> element will be present (with its textarea inside) and the Lexical contenteditable might be absent or hidden. Conversely, in Rich Text mode, the Lexical editor (data-lexical-editor element) will be present, and the markdown component likely not in the DOM. The Reddit emoji picker script uses a similar logic: it tries to find the textarea first and, if not found, assumes the Lexical editor is in use ￼ ￼.

	•	Mode toggle button label: Reddit’s UI provides a toggle to switch editors. The button’s aria-label changes depending on mode. In Rich Text mode, the button says “Switch to Markdown Editor”, whereas in Markdown mode it says (presumably) “Switch to Rich Text Editor”. These are accessible labels. A content script can look for buttons with those labels. For example, a query for button[aria-label="Switch to Markdown Editor"] returning an element that is currently visible would indicate the user is in Rich Text mode (since the option being offered is to switch to Markdown) ￼. Conversely, if you find button[aria-label="Switch to Rich Text Editor"] (or similar wording), then Markdown mode is active. This method might require searching through shadow DOM as well (the button might be inside the composer’s toolbar shadow). The referenced user script uses a utility to search all open shadow roots for such a button ￼. You could implement a recursive DOM search or maintain a query for that aria-label.
	•	CSS/Attributes on the composer: It’s possible (though not confirmed by documentation) that the host shreddit-composer element or some parent has a state attribute when switched. For example, some apps toggle a class like “markdown-mode” vs “richtext-mode”. A quick inspection of Reddit’s elements (or the data attributes like data-show-formatting-bar) didn’t reveal a clear mode flag, so the direct presence of the respective editor element remains the most robust indicator.

In real-time, the user can toggle modes manually at any time. Your extension should be prepared to detect this switch. A strategy is to listen for DOM changes on the composer: for instance, a MutationObserver on shreddit-composer could catch child list changes (i.e., the insertion or removal of the shreddit-markdown-composer element) or attribute changes. However, polling or on-demand checking can also suffice: whenever the user triggers dictation or when focusing the composer, check the current mode then. The mode toggle button press will re-render the composer’s content, so detecting the presence of the textarea vs contenteditable at that moment is enough.

Summary of Detection Methods (for clarity):
	•	Option 1: Check for textarea vs contenteditable: If a <textarea> is found in the composer’s shadow, use Markdown approach; else if a [data-lexical-editor="true"] element is found, use RTE approach.
	•	Option 2: Check toggle button label: If “Switch to Markdown Editor” button is present (and likely visible), currently in RTE mode; if “Switch to Rich Text Editor” is present, in Markdown mode.
	•	Option 3: Observe mode toggle via mutations: Watch for the DOM structure changes that correspond to mode switches and update the extension’s mode state accordingly.

Using these, the extension can decide which Strategy to apply at insertion time or focus time. For example, the extension could attempt to identify the active element the user is typing in: if it’s a contenteditable with the Lexical attribute, attach LexicalStrategy; if it’s a textarea, attach InputTextareaStrategy.

One additional note: Reddit supports multiple composers on the page (e.g., one for the main post, and others for comments or modals). Each shreddit-composer is separate. The extension might need to detect which one the user is currently interacting with (likely the one with focus or the one visible). The strategies don’t change per instance, but your DOM queries should be scoped appropriately (for example, you might use document.activeElement to find the focused composer component). If document.activeElement returns the shadow host (e.g., shreddit-composer itself might become active when its internal field is focused), you can use that to locate the exact composer and then inspect its shadow for which mode is active.

Recommendations and Edge Cases
	•	Focus Management: Ensure your extension does not blur the editor when inserting text. Always call .focus() on the target element (textarea or contenteditable) before inserting, to guarantee the editor has focus. The sample scripts consistently do this (focus the textarea or Lexical div) ￼ ￼. This prevents any loss of cursor position and ensures the user can continue typing without an extra click.
	•	Event Dispatching: Always dispatch an input event after programmatic insertion. Reddit’s interface likely uses the input event to enable the “Post”/“Comment” button only when there is content. If you set the text but don’t fire input, the button might stay disabled (thinking the field is empty) until the user types a character. The Markdown script explicitly fires both input and change events ￼. For Lexical, using execCommand('insertText') under the hood triggers the appropriate events. If you ever end up manually inserting text nodes in the contenteditable, you might also consider dispatching a DOM InputEvent to mimic that (though this is advanced and usually not needed if using execCommand).
	•	Compatibility with “Say, Pi” Architecture: All suggested methods work within the content script environment and use standard web APIs, so they are compatible with browser extensions’ security model. We avoid any direct calls into Reddit’s or Lexical’s JavaScript objects – no eval or function hooking is needed, only DOM manipulation and events. This means we respect the extension guidelines (we’re effectively doing what a user’s keyboard would do, just via script). The strategies outlined fit naturally into the abstraction of a dictation system: one strategy for generic text inputs, another for advanced editors. No site-specific hacks beyond identifying the correct element and events are required.
	•	Public Examples: The Greasy Fork script “Reddit Emoji Picker Pro” is a great reference implementation of inserting text/emojis into Reddit’s composer in both modes. It confirms the use of a textarea for Markdown and a Lexical contenteditable for rich text, and it uses the approaches described (value setting + dispatch for textarea; focus + execCommand for Lexical) ￼ ￼. The StackOverflow community has also tackled similar problems (e.g., inserting text into Facebook’s Lexical editor in Messenger), generally concluding that simulating key input or using execCommand is necessary since direct .textContent changes don’t register ￼ ￼. These examples give confidence that our strategy will work and persist the changes in the editor’s state.
	•	Edge Cases: If the user had a selection (highlighted text) when dictation inserts text, the behavior should ideally replace the selection. The current strategy suggestions assume insertion at caret when no range is selected. You might want to enhance it: for textareas, if startPos != endPos (text was selected), the new text will naturally replace the selection because of how we construct textBefore + newText + textAfter. In the Lexical contenteditable, if text was selected, execCommand('insertText') will replace the selection with the new text (this is default browser behavior for execCommand). That’s likely acceptable. Another edge case is if the editor is empty vs not – but the same methods apply regardless (in empty case, selectionStart = 0, and Lexical will just insert into an empty paragraph).
	•	Future-proofing: While document.execCommand is deprecated, there is currently no better standardized alternative for programmatically inserting text into a contenteditable and having editing frameworks pick it up ￼. The deprecation simply means “no longer being improved”, but browsers still support it. Should it ever be removed, the fallback would involve creating and dispatching a beforeinput event with InputEvent.inputType = "insertText" and data property set to your text. Lexical does listen to beforeinput events extensively, so a synthetic beforeinput might work, though it’s not guaranteed if not trusted. For now, using execCommand for text insertion is common in extensions and scripts (and Lexical has been built with that in mind as a graceful fallback for paste/insert operations).
	•	Shadow DOM Access: We rely on Reddit’s shadow DOM being open. If Reddit were to switch those web components to closed shadow DOM in the future, an extension could no longer directly query inside. The extension would then need to inject a script tag into the page context to operate on the editor (since the page’s JS can access its closed shadow, but our content script cannot). This is a more complex scenario and currently not necessary. As of now, the presence of scripts like the emoji picker successfully querying composer.shadowRoot indicates it’s open ￼. So our approach is valid under current conditions.

Conclusion: To support Reddit’s post composer, your extension should implement logic to detect the editor mode and then apply the appropriate insertion strategy:
	•	Use LexicalEditorStrategy (contenteditable approach) for the Rich Text mode – focus the [data-lexical-editor] element and insert text via execCommand or input events, which keeps Lexical’s state consistent.
	•	Use InputTextareaStrategy for the Markdown mode – manipulate the textarea’s value and fire an input event, preserving the cursor position.
	•	Implement reliable mode detection by checking the DOM (textarea vs contenteditable) or the toggle button’s label. Switch strategies on the fly if the user switches modes.
	•	Ensure that cursor position is maintained (as demonstrated by setting selection range for textareas ￼ and by the nature of execCommand for contenteditables). The user experience should be seamless: the dictated text appears at the correct spot and the user can continue typing or dictating further.

By following these guidelines, you can integrate Reddit support into your extension without breaking the user’s flow or violating extension policies. The strategies align well with the existing architecture, so you likely won’t need a completely new strategy class – just augment your detection and reuse the appropriate insertion logic for each mode. Each mode’s implementation has been vetted by the community (through scripts and Q&A), indicating this approach will be both effective and robust ￼ ￼.