import { SpeechSynthesisModule } from "../tts/SpeechSynthesisModule";
import { UserPreferenceModule } from "../prefs/PreferenceModule";

function addIdChatHistory() {
  const chatHistory = document.querySelector("div.t-body-chat");
  if (!chatHistory) {
    return false;
  } else {
    chatHistory.id = "saypi-chat-history";
    // select the second div child element of the chat history, which is the past chat messages container
    const pastChatMessagesContainer =
      chatHistory.querySelector(":nth-child(2)");
    if (pastChatMessagesContainer) {
      pastChatMessagesContainer.id = "saypi-chat-history-past-messages";
    }
    // select the third div child element of the chat history, which is the present chat messages container
    const presentChatMessagesContainer =
      chatHistory.querySelector(":nth-child(3)");
    if (presentChatMessagesContainer) {
      presentChatMessagesContainer.id = "saypi-chat-history-present-messages";
    }
  }
  return true;
}

function addIdVoiceMenu() {
  // voice selection menu is the first div descendent of the audio controls container with a class 't-action-m'
  const audioControlsContainer = document.getElementById(
    "saypi-audio-controls"
  );
  if (!audioControlsContainer) {
    return false;
  }
  const voiceMenu = audioControlsContainer.querySelector("div.t-action-m");
  if (!voiceMenu) {
    return false;
  } else {
    voiceMenu.id = "saypi-voice-menu";
  }
  return true;
}

function restyleVoiceMenuControls() {
  const voiceMenu = document.getElementById("saypi-voice-menu");
  if (!voiceMenu) {
    return false;
  }
  const voiceMenuControls = voiceMenu.nextSibling;
  if (!voiceMenuControls) {
    return false;
  }
  voiceMenuControls.id = "saypi-voice-menu-controls";

  // Create a MutationObserver instance
  const observer = new MutationObserver((mutationsList) => {
    for (let mutation of mutationsList) {
      if (
        mutation.type === "attributes" &&
        mutation.attributeName === "class" &&
        voiceMenuControls.classList.contains("self-end")
      ) {
        voiceMenuControls.classList.remove("self-end");
      }
    }
  });

  // Start observing the voiceMenuControls for configuration changes
  observer.observe(voiceMenuControls, {
    attributes: true,
    attributeFilter: ["class"],
  });
}

function registerVoiceChangeHandler(menu) {
  // for each pre-existing voice button in the menu, add a click handler to unset the voice
  const voiceButtons = Array.from(menu.querySelectorAll("button"));
  if (!voiceButtons || voiceButtons.length === 0) {
    return false;
  }
  const builtInPiVoiceButtons = voiceButtons.filter(
    (button) => !button.classList.contains("saypi-voice-button")
  );
  builtInPiVoiceButtons.forEach((button) => {
    button.addEventListener("click", () => {
      UserPreferenceModule.unsetVoice().then(() => {
        markVoiceButtonAsSelected(button);
      });
    });
  });
}

function addVoiceMenuExpansionListener() {
  const audioControlsContainer = document.getElementById(
    "saypi-audio-controls"
  );
  const voiceMenu = document.getElementById("saypi-voice-menu");

  if (!audioControlsContainer || !voiceMenu) {
    return false;
  }

  const observerCallback = async function (mutationsList, observer) {
    for (let mutation of mutationsList) {
      if (mutation.type === "childList") {
        for (let node of mutation.addedNodes) {
          // the addition of a button with an aria-label giving instructions to "close the menu", indicates the voice menu is expanded
          if (
            node.nodeName === "BUTTON" &&
            node.getAttribute("aria-label") &&
            node === audioControlsContainer.firstChild
          ) {
            voiceMenu.classList.add("expanded");
            // mark the selected voice each time the menu is expanded (because pi.ai recreates the menu each time)
            addVoicesToMenu(voiceMenu);
            registerVoiceChangeHandler(voiceMenu);
          }
        }
        for (let node of mutation.removedNodes) {
          if (node.nodeName === "BUTTON" && node.getAttribute("aria-label")) {
            voiceMenu.classList.remove("expanded");
            return;
          }
        }
      }
    }
  };

  const observer = new MutationObserver(observerCallback);
  observer.observe(audioControlsContainer, { childList: true });
}

function introduceVoice(voice) {
  const introduction = "Hello, World!";
  const speechSynthesis = SpeechSynthesisModule.getInstance();
  speechSynthesis.createSpeech(introduction).then((utterance) => {
    speechSynthesis.speak(utterance);
  });
}

function populateVoices(voices, menu) {
  if (!voices || voices.length === 0) {
    console.log("No voices found");
    return false;
  }

  const customVoiceButtons = Array(voices.length);

  voices.forEach((voice) => {
    // if not already in the menu, add the voice
    if (menu.querySelector(`button[data-voice-id="${voice.id}"]`)) {
      // voice already in menu, skip to next voice
      return;
    }
    const button = document.createElement("button");
    // template: <button type="button" class="mb-1 rounded px-2 py-3 text-center hover:bg-neutral-300">Pi 6</button>
    button.type = "button";
    button.classList.add(
      "mb-1",
      "rounded",
      "px-2",
      "py-3",
      "text-center",
      "hover:bg-neutral-300",
      "saypi-voice-button"
    );
    button.innerHTML = "Say, Pi - " + voice.name; // TODO: localize
    button.addEventListener("click", () => {
      UserPreferenceModule.setVoice(voice).then(() => {
        markVoiceButtonAsSelected(button);
        introduceVoice(voice);
      });
    });
    button.dataset.voiceId = voice.id;
    customVoiceButtons.push(button);
  });

  // add the custom voice buttons to the start of the menu
  customVoiceButtons.reverse().forEach((button) => {
    menu.insertBefore(button, menu.firstChild);
  });

  return true;
}

function isBuiltInVoiceButton(button) {
  return !button.classList.contains("saypi-voice-button");
}

function addVoiceButtonAdditionListener() {
  const voiceMenu = document.getElementById("saypi-voice-menu");
  if (!voiceMenu) {
    return false;
  }
  // observe the voice menu for changes to child nodes
  // if a button is added that does not have class 'saypi-voice-button', evaluate whether it should be marked as selected
  const observerCallback = function (mutationsList, observer) {
    for (let mutation of mutationsList) {
      if (mutation.type === "childList") {
        for (let node of mutation.addedNodes) {
          if (node.nodeName === "BUTTON") {
            // a voice button was added to the menu that is not a custom voice button
            // if a voice is selected, mark the button as selected
            UserPreferenceModule.getVoice().then((voice) => {
              const customVoiceIsSelected = voice !== null;
              if (customVoiceIsSelected) {
                if (isBuiltInVoiceButton(node)) {
                  unmarkButtonAsSelectedVoice(node);
                } else if (node.dataset.voiceId === voice.id) {
                  markButtonAsSelectedVoice(node);
                }
              }
            });
          }
        }
      }
    }
  };
  const observer = new MutationObserver(observerCallback);
  observer.observe(voiceMenu, { childList: true });
}

function addVoicesToMenu(voiceMenu) {
  const speechSynthesis = SpeechSynthesisModule.getInstance();
  speechSynthesis.getVoices().then((voices) => {
    populateVoices(voices, voiceMenu);
  });
}

function markButtonAsSelectedVoice(button) {
  button.disabled = true;
  button.classList.add("selected", "bg-neutral-300", "text-primary-700");
  button.classList.remove("hover:bg-neutral-300");
}

function unmarkButtonAsSelectedVoice(button) {
  button.disabled = false;
  button.classList.remove("selected", "bg-neutral-300", "text-primary-700");
  button.classList.add("hover:bg-neutral-300");
}

/**
 * Mark the specified button as the selected voice, and unmark all other buttons
 * @param {HTMLButtonElement} button
 * @returns void
 */
async function markVoiceButtonAsSelected(button) {
  const voiceMenu = document.getElementById("saypi-voice-menu");
  if (!voiceMenu) {
    return false;
  }

  // iterative over buttons in the menu, and mark the selected voice
  const voiceButtons = voiceMenu.querySelectorAll("button");
  if (!voiceButtons || voiceButtons.length === 0) {
    return false;
  }
  voiceButtons.forEach((button) => {
    unmarkButtonAsSelectedVoice(button);
  });
  markButtonAsSelectedVoice(button);
}

function assistantChatMessageAdded(node) {
  // a new assistant chat message element was added to the chat history
  // tag the element with a class and start streaming the text
  console.log("chat message added to chat history", node);
  node.classList.add("chat-message", "assistant-message");
  const speechSynthesis = SpeechSynthesisModule.getInstance();
  if (speechSynthesis.isEnabled()) {
    speechSynthesis.createSpeechStream().then((utterance) => {
      node.dataset.utteranceId = utterance.id;
      console.log("Created audio stream", utterance.id);

      // add a button that will read the chat message aloud
      addSpeechButton(speechSynthesis, utterance, node);

      autoplaySpeech(speechSynthesis, utterance); // handle any errors
    });
  }
}

async function registerChatHistoryListener() {
  const chatHistory = document.getElementById(
    "saypi-chat-history-present-messages"
  );
  if (!chatHistory) {
    return;
  }
  let lastMessage = null;
  const speechSynthesis = SpeechSynthesisModule.getInstance();

  const observerCallback = function (mutationsList, observer) {
    for (let mutation of mutationsList) {
      if (mutation.type === "childList") {
        for (let node of mutation.addedNodes) {
          if (
            node.nodeName === "DIV" &&
            node.classList.contains("break-anywhere") &&
            !node.classList.contains("justify-end")
          ) {
            assistantChatMessageAdded(node);
            lastMessage = node;
          } else if (node.nodeName === "SPAN") {
            // streaming text initially appears as within a span node with style display: none and opacity: 0
            if (speechSynthesis.isEnabled()) {
              speechSynthesis.addSpeechToStream(
                lastMessage.dataset.utteranceId,
                node.innerText
              );
            }
          }
        }
      }
    }
  };
  const observer = new MutationObserver(observerCallback);

  observer.observe(chatHistory, { childList: true, subtree: true });
}
